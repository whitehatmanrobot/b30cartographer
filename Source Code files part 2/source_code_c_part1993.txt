ECL( ECC_P256_POINT_SIZE_IN_BYTES ) )       DRM_BYTE  f_rgbOutBytes[] )
{
    /*
    ** Decls
    */
    DRM_RESULT dr = DRM_SUCCESS;
    digit_t    rgdTemp[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] = { 0 };

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_Convert_P256_PointToBigEndianBytes );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgptInPoint );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_rgbOutBytes );
	ChkArg( NULL != f_pEcurve->fdesc );
	ChkArg( NULL != f_pEcurve->fdesc->modulo );
	ChkArg( ECC_P256_INTEGER_SIZE_IN_DIGITS == f_pEcurve->fdesc->modulo->length );

    /*
    ** Convert the x-coord out of modular format ( into digits ) then into bytes
    */
    ChkBOOL( from_modular( f_rgptInPoint,
                           rgdTemp,
                           f_pEcurve->fdesc->modulo ),
             DRM_E_P256_CONVERSION_FAILURE );
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdTemp, f_rgbOutBytes ) );

    /*
    ** Convert the y-coord out of modular format ( into digits ) then into bytes
    */
    ChkBOOL( from_modular( f_rgptInPoint + ECC_P256_POINT_SIZE_IN_ECAFFINES / 2,
                           rgdTemp,
                           f_pEcurve->fdesc->modulo ),
             DRM_E_P256_CONVERSION_FAILURE );
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdTemp, 
                                               &f_rgbOutBytes[ ECC_P256_POINT_SIZE_IN_BYTES / 2 ] ) );

ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end Convert_P256_PointToBigEndianBytes */


/*************************************************************************************************
**
** Function: Convert_P256_PointToPlaintext
**
** Description: Converts points into plaintext, assuming a lossless integer-to-point formula 
**              see DRM_ECC_Encrpyt_P256 for details
**
** Arguements:
**    [f_rgptPoint]:  EC point to convert
**    [f_pEcurve ]:   EC that we are working on
**    [f_pPlaintext]: Convert plaintext output
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL Convert_P256_PointToPlaintext(
    __in_ecount( ECC_P256_POINT_SIZE_IN_ECAFFINES ) const digit_t          f_rgptPoint[],
    __in_ecount( 1 )                                const ecurve_t        *f_pEcurve,
    __out_ecount( 1 )                                     PLAINTEXT_P256  *f_pPlaintext )
{
    /*
    ** Decls
    */
    DRM_RESULT dr = DRM_SUCCESS;
    digit_t    rgdTemp[ ECC_P256_INTEGER_SIZE_IN_DIGITS ] = { 0 };

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_Convert_P256_PointToPlaintext );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_pPlaintext );
    ChkArg( NULL != f_rgptPoint );
    ChkArg( NULL != f_pEcurve );
    ChkArg( NULL != f_pEcurve->fdesc );
    ChkArg( FIELD_Q_MP == f_pEcurve->fdesc->ftype );
	ChkArg( NULL != f_pEcurve->fdesc->modulo );
	ChkArg( ECC_P256_INTEGER_SIZE_IN_DIGITS == f_pEcurve->fdesc->modulo->length );

    /*
    ** Convert the x coord of the point from modular format to digits
    */
    ChkBOOL( from_modular( f_rgptPoint,
                           rgdTemp,
                           f_pEcurve->fdesc->modulo ),
             DRM_E_P256_CONVERSION_FAILURE );

    /*
    ** Now convert the digits into the DRM_BYTE array output
    */
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdTemp, f_pPlaintext->m_rgbPlaintext ) );
    
ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end Convert_P256_PointToPlaintext */

/*************************************************************************************************
**
** Function:    DRM_AES_GenerateHMacKey
**
** Description: This function assumes that PLAINTEXT_P256 stucture can contain 2 128bit AES keys.
**              It will, given a PLAINTEXT_P256 struct with the 2nd key set, generate the 1st key
**              in the struct (used for XMR HMACing ) such that will have a 100% chance of being
**              Mapped to an EC point without losing any information. (See DRM_ECC_Encrypt_P256 
**              function header for more details ).
**
** Arguements:
**    [f_pKeys]   : A struct containing the ALREADY SET 2nd key (content key ) for XMR lics.
**    [f_pBigCtx] : Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes: This function uses the P256 bit curve. 
**        ( !!!) There is a very small chance that this function may fail to find a HMAC key
**        that, coupled with the content key will map to an EC Point. While the probability 
**        is very low (way less then .01%) the caller should check if the DRM_RESULT returned
**        is DRM_E_P256_HMAC_KEYGEN_FAILURE. In which case calling the function another time will
**        probably solve the issue.
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_ECC_GenerateHMACKey_P256(
    __inout PLAINTEXT_P256  *f_pKeys, 
    __inout struct bigctx_t *f_pBigCtx )
{
    /*
    ** Decls
    */
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  i        = 0;
    digit_t    rgdRandNum[ ECC_P256_POINT_SIZE_IN_DIGITS ] = { 0 };

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_DRM_AES_GenerateHMACKey );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_pKeys );
    ChkArg( NULL != f_pBigCtx );
     
    /*
    ** Init big num context
    */
    ChkDR( DRM_ECC_PKInit( f_pBigCtx, NULL ) );
    
    /*
    ** Zero the HMAC key that was given
    */
    MEMSET( f_pKeys, 0, ECC_P256_INTEGER_SIZE_IN_BYTES / 2 );

    /*
    ** Convert the first key to digits
    */
    Convert_P256_BigEndianBytesToDigits( f_pKeys->m_rgbPlaintext, 
                                         rgdRandNum );

    /*
    ** Now do a loop where I attempt to generate an AES key such that the two
    ** keys will successfully map into an EC point
    */
    for ( i = 0; i < P256_KEY_GEN_TRIES; ++i )
    {
        /*
        ** Generate the digits
        */
        ChkBOOL( random_mod_nonzero( g_Ecurve.gorder + ECC_P256_INTEGER_SIZE_IN_DIGITS / 2,  
                                     rgdRandNum + ECC_P256_INTEGER_SIZE_IN_DIGITS / 2, 
                                     ECC_P256_INTEGER_SIZE_IN_DIGITS / 2, 
                                     f_pBigCtx ),
                 DRM_E_P256_PKCRYPTO_FAILURE );


        /*
        ** Check if it there is a solution to the EC equation for this x value,
        ** if there is then we have generated a good key.
        */
        dr = DRM_ECC_CanMapToPoint_P256( rgdRandNum, f_pBigCtx );

        if ( DRM_SUCCESS == dr )
        {
            /*
            ** SUCCESS: Now lets covert the digits to bytes
            */
            ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdRandNum, f_pKeys->m_rgbPlaintext ) );           
            break;
        } /* end if */
        else if ( DRM_S_FALSE == dr )
        {
            /*
            ** The number we produced does not have a solution to the EC equation, try again.
            */
            continue;
        } /* end else if */
        else
        {
            /*
            ** Some error occured in the Mapping test function, bail out of this function.
            */
            ChkDR( dr );
        }
    } /* end for */

    /*
    ** Check we ran out of generation tries, if so then return a corresponding error.
    */
    if ( i >= P256_KEY_GEN_TRIES )
    {
        ChkDR( DRM_E_P256_HMAC_KEYGEN_FAILURE );
    } /* end if */
ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} 



/************************************************************************************************
**
** Function:  DRM_ECC_CanMapToPoint_P256
**
** Synopsis:  This function test to see if a number can be mapped into an EC point, to do this
**            the function checks if the number has a solution to the equation y^2 = x^3 + ax + b,
**            where the passed in number is the 'x' value
**
** Arguments:  
**    [f_rgdNumber]: Number to test if it can map to an EC point
**    [f_pBigCtx]  : Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
** Returns: DRM_SUCCESS if the number can be mapped, DRM_S_FALSE if it can not, and returns
**          an error code if there has an error while executing the function
**
** Notes: 
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_ECC_CanMapToPoint_P256(
    __in_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS ) const  digit_t   f_rgdNumber[], 
    __inout                                        struct bigctx_t *f_pBigCtx )
{
    /*
    ** Decls
    */
    DRM_RESULT dr      = DRM_SUCCESS;
    digit_t rgptTemp[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]    = { 0 };
    digit_t    rgdSuppliedTemps[ ECC_P256_INTEGERADD_TEMPS ]   = { 0 };

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_DRM_ECC_CanMapToPoint_P256 );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgdNumber );
    ChkArg( NULL != f_pBigCtx );
	ChkArg( NULL != g_Ecurve.fdesc->modulo );
	ChkArg( ECC_P256_INTEGER_SIZE_IN_DIGITS == g_Ecurve.fdesc->modulo->length );


    /*
    ** Convert to the array to modular format
    */
    ChkBOOL( to_modular( f_rgdNumber,
                         ECC_P256_INTEGER_SIZE_IN_DIGITS,
                         rgptTemp,
                         g_Ecurve.fdesc->modulo,
                         NULL ),
             DRM_E_P256_CONVERSION_FAILURE );

    dr = DRM_ECC_MapX2PointP256(
        rgptTemp,
       &rgptTemp[ ECC_P256_POINT_SIZE_IN_ECAFFINES / 2 ] ,
        rgdSuppliedTemps, 
        f_pBigCtx ); 
    
    if ( DRM_E_P256_PLAINTEXT_MAPPING_FAILURE == dr )
    {
        dr = DRM_S_FALSE; 
    }

ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end DRM_ECC_CanMapToPoint_P256 */

/************************************************************************************************
**
** Function: DRM_ECC_Decrypt_P256
**
** Synopsis: Performs EC El-Gamal P256 decryption on a buffer. The equation is:
**           P = C2 - k*C1, where ( C1, C2 ) is the ciphertext, P is the plaintext 
**           and k is the private key.
**
** Arguments:  
**    [f_pprivkey] -- Private key to decrypt with
**    [f_pCiphertext]    -- Encrypted bytes that are to be decrypted
**    [f_pPlaintext]   -- Clear text result
**    [f_pBigCtx]  -- Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully. 
**
** Notes: It is put in the [f_pPlaintext]. This function uses
**        the private key, be sure to protect/obfuscate/encrypt this function if the private key
**        is an asset. Also refer to the DRM_ECC_Decrypt_P256 function comments for more details
**        about the exact protocol for encyption and plaintext convesion.
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_ECC_Decrypt_P256(
    __in    const  PRIVKEY_P256    *f_pPrivkey,
    __in    const  CIPHERTEXT_P256 *f_pCiphertext,
    __out          PLAINTEXT_P256  *f_pPlaintext,
    __inout struct bigctx_t        *f_pBigCtx ) 
{
    /*
    ** decls
    */
    DRM_RESULT dr = DRM_SUCCESS;
    digit_t    rgdTemps[ ECC_P256_DECRYPT_TEMPS ]             = { 0 };
    digit_t    rgdPrivkey[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]  = { 0 };
    digit_t rgptC1[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]     = { 0 };
    digit_t rgptC2[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]     = { 0 };
    digit_t rgptResult[ ECC_P256_POINT_SIZE_IN_ECAFFINES ] = { 0 };
    CIPHERTEXT_P256_2POINTS *pCtPoints = ( CIPHERTEXT_P256_2POINTS* )f_pCiphertext;

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_DRM_ECC_Decrypt_P256 );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_pPrivkey );
    ChkArg( NULL != f_pCiphertext );
    ChkArg( NULL != f_pPlaintext );
    ChkArg( NULL != f_pBigCtx );

    DRM_ECC_PKInit( f_pBigCtx, NULL );
    
    /*
    ** Convert priv key from big endian bytes to digits
    */
    ChkDR( Convert_P256_BigEndianBytesToDigits( f_pPrivkey->m_rgbPrivkey, rgdPrivkey ) );

    /*
    ** Convert the ciphertext byte stream to two modular format points
    */
    ChkDR( Convert_P256_BigEndianBytesToPoint( pCtPoints->m_rgbC1,
                                              &g_Ecurve,
                                               rgptC1,
                                               f_pBigCtx ) );
    ChkDR( Convert_P256_BigEndianBytesToPoint( pCtPoints->m_rgbC2,
                                              &g_Ecurve,
                                               rgptC2,
                                               f_pBigCtx ) );

    /*
    ** Calc: result := k*C1, where k is the private key
    */
    ChkBOOL( ecaffine_exponentiation( rgptC1,
                                      rgdPrivkey,
                                      ECC_P256_INTEGER_SIZE_IN_DIGITS,
                                      rgptResult,
                                     &g_Ecurve,
                                      f_pBigCtx ),
             DRM_E_PKCRYPTO_FAILURE );

    /*
    ** Calc: plaintext point == result := C2 - k*C1, where k*C1
    ** was calculated in the previous step
    */
    ChkBOOL( ecaffine_addition( rgptC2,
                                rgptResult,
                                rgptResult,
                                ECC_POINT_SUBTRACTION,
                               &g_Ecurve,
                                rgdTemps,
                                f_pBigCtx ),
             DRM_E_PKCRYPTO_FAILURE );

    /*
    ** Do some magic and convert the plaintext point ( 512 bit ) back to a plaintext
    ** big endian byte array ( 256 bit ) ( !!11!?11! )
    */
    ChkDR( Convert_P256_PointToPlaintext( rgptResult,
                                        &g_Ecurve,
                                         f_pPlaintext ) );

ErrorExit:
    OEM_SECURE_ZERO_MEMORY( rgdPrivkey, ECC_P256_INTEGER_SIZE_IN_DIGITS  * SIZEOF( digit_t ) );
    OEM_SECURE_ZERO_MEMORY( rgptResult, ECC_P256_POINT_SIZE_IN_ECAFFINES * SIZEOF( digit_t ) );

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC    
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
}/* end DRM_ECC_Decrypt_P256 */

/************************************************************************************************
**
** Function:  DRM_ECC_Encrypt_P256
**
** Synopsis:  Encrpyts a block of plaintext, given a public key. The algorithm is EC El-Gamal:
**            C1 = r*G, C2 = P + r*K, where ( C1, C2 ) is the ciphertext, r is a runtime generated
**            random integer (256 bit) K is the public key, G is the generator or basepoint for 
**            the elliptic curve and P is the plaintext.
**
** Arguments:  
**    [f_pPubkey]:     Public key used to encrypt the plaintext
**    [f_pPlaintext]:  Plaintext data to be encrypted. Not all plaintext can map to Ciphertext!
**    [f_pCiphertext]: Ciphertext result, this will be output if function succeeds
**    [f_pBigCtx]:     Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:  Data is not encrpyted in place.  It is put in the f_pCiphertext. Not all plaintext
**         maps to ciphertext. There are two methods in which to deal with this:
**         1) Shorten the plaintext buffer such that the left over space can be arbirarily changed.
**            At decryption time we will not be able to retrieve those spare bytes.
**         2) Choose the ciphertext such that we know that it will be able to map to ciphertext.
**            In this way we can use all 32 bytes in the plaintext buffer, but if someone does not
**            choose a good plaintext then there is a chance that encryption will fail!
**         This function implements the 2nd of the two options, so your plaintext must be good!
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_ECC_Encrypt_P256( 
    __in    const   PUBKEY_P256      *f_pPubkey,
    __in    const   PLAINTEXT_P256   *f_pPlaintext,
    __out           CIPHERTEXT_P256  *f_pCiphertext,
    __inout struct  bigctx_t         *f_pBigCtx )
{
    /*
    ** decls
    */
    DRM_RESULT dr = DRM_SUCCESS;
    digit_t    rgdTemps[ ECC_P256_ENCRYPT_TEMPS ]                = { 0 };
    digit_t    rgptPubkey[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]    = { 0 };
    digit_t    rgptC1[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]        = { 0 };
    digit_t    rgptC2[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]        = { 0 };
    digit_t    rgptPlaintext[ ECC_P256_POINT_SIZE_IN_ECAFFINES ] = { 0 };
    digit_t    rgdR[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]           = { 0 };
    CIPHERTEXT_P256_2POINTS *pCtPoints = ( CIPHERTEXT_P256_2POINTS* )f_pCiphertext;

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_DRM_ECC_Encrypt_P256 );
#endif

    /*
    ** Arg Checks ( we allow f_rgdSuppliedTemps to be NULL )
    */
    ChkArg( NULL != f_pPubkey );
    ChkArg( NULL != f_pPlaintext );
    ChkArg( NULL != f_pCiphertext );
    ChkArg( NULL != f_pBigCtx );
    
    /*
    ** Ensure that BigNum context is initialized
    */
    DRM_ECC_PKInit( f_pBigCtx, NULL );
     
    /*
    ** Convert the public key and generator point ( aka base point ) into point format
    */
    ChkDR( Convert_P256_BigEndianBytesToPoint( f_pPubkey->m_rgbPubkey, 
                                              &g_Ecurve, 
                                               rgptPubkey, 
                                               f_pBigCtx ) );


    /*
    ** Verify the (now converted) point is a valid curve point
    */
    ChkBOOL( ecaffine_on_curve( rgptPubkey, 
                               &g_Ecurve, 
                                NULL, 
                                rgdTemps, 
                                f_pBigCtx ),
             DRM_E_PKCRYPTO_FAILURE );

    /*
    ** Now map the plaintext byte array to a plaintext point
    */
    ChkDR( Convert_P256_PlaintextToPoint( f_pPlaintext, 
                                        &g_Ecurve,
                                         rgdTemps, 
                                         rgptPlaintext,
                                         f_pBigCtx ) );

    /*
    ** Generate our random integer for encryption, r ( it must be smaller than our curve's order )
    */
    ChkBOOL( random_mod_nonzero( g_Ecurve.gorder, 
                                 rgdR, 
                                 ECC_P256_INTEGER_SIZE_IN_DIGITS,
                                 f_pBigCtx ),
             DRM_E_PKCRYPTO_FAILURE );

    /*
    ** Calculate C1 = rG
    */
#if DRM_PRECOMPUTE_GTABLE

    ChkBOOL( ecaffine_exponentiation_tabular( TABLE, 
                                              ECC_P256_TABLE_SPACING, 
                                              ECC_P256_TABLE_LAST, 
                                              rgdR, 
                                              ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                              rgptC1,
                                             &g_Ecurve,
                                              f_pBigCtx ),
             DRM_E_PKCRYPTO_FAILURE );
#else
    ChkBOOL( ecaffine_exponentiation( g_Ecurve.generator,
                                      rgdR,
                                      ECC_P256_INTEGER_SIZE_IN_DIGITS,
                                      rgptC1,
                                     &g_Ecurve,
                                      f_pBigCtx ),
             DRM_E_PKCRYPTO_FAILURE );
#endif
    /*
    ** Calculate C2 = P + rK where P is the plaintext point and K is the pub key point
    */
    ChkBOOL( ecaffine_exponentiation( rgptPubkey,
                                      rgdR,
                                      ECC_P256_INTEGER_SIZE_IN_DIGITS,
                                      rgptC2,
                                     &g_Ecurve,
                                      f_pBigCtx ),
             DRM_E_PKCRYPTO_FAILURE );

    ChkBOOL( ecaffine_addition( rgptPlaintext, 
                                rgptC2,
                                rgptC2,
                                ECC_POINT_ADDITION,
                               &g_Ecurve,
                                rgdTemps,
                                f_pBigCtx ),
             DRM_E_PKCRYPTO_FAILURE );

     /*
     ** We now have our two ciphertext points, now convert them to one big
     ** ciphertext byte array ( in big endian bytes format )
     */
    ChkDR( Convert_P256_PointToBigEndianBytes( rgptC1,
                                              &g_Ecurve,
                                               pCtPoints->m_rgbC1 ) );
    ChkDR( Convert_P256_PointToBigEndianBytes( rgptC2,
                                              &g_Ecurve,
                                               pCtPoints->m_rgbC2 ) );

ErrorExit:
    OEM_SECURE_ZERO_MEMORY( rgptPlaintext, ECC_P256_POINT_SIZE_IN_ECAFFINES * SIZEOF( digit_t ) );
    OEM_SECURE_ZERO_MEMORY( rgdR, ECC_P256_INTEGER_SIZE_IN_DIGITS * SIZEOF( digit_t ) ) ;

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif
    
    return dr;
} /* end DRM_ECC_Encrypt_P256 */ 

/************************************************************************************************
**
** Function:  DRM_ECC_GenKeyPair_P256
**
** Synopsis:  Generates a public-private key pair for the P256 FIPS Elliptic Curve
**
** Arguments:  
**    [f_pPubKey]:  A pointer to the structure that will be populated with the new public key
**    [f_pPrivKey]: A pointer to the structure that will be populated with the new public key
**    [f_pBigCtx]:  Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes: Generates a private key, this function should be protected the key is deemed as an asset
**
*************************************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ECC_GenKeyPair_P256( 
    __out          PUBKEY_P256  *f_pPubKey,
    __out          PRIVKEY_P256 *f_pPrivKey,
    __inout struct bigctx_t     *f_pBigCtx )
{
    /*
    ** decls
    */
    DRM_RESULT dr = DRM_SUCCESS;
    digit_t    rgdPriv[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]    = { 0 };
    digit_t    rgdSuppliedTemps[ ECC_P256_GENKEYPAIR_TEMPS ] = { 0 };
    digit_t rgptPub[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]   = { 0 };

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_DRM_ECC_GenKeyPair_P256 );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_pPrivKey );
    ChkArg( NULL != f_pPubKey );
    ChkArg( NULL != f_pBigCtx );

    DRM_ECC_PKInit( f_pBigCtx, NULL );
    /*
    ** Create the private key such that it is any random number < curve order
    */
    ChkBOOL( random_mod_nonzero( g_Ecurve.gorder, 
                                 rgdPriv, 
                                 ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                 f_pBigCtx ),
             DRM_E_P256_PKCRYPTO_FAILURE );

    /*
    ** Compute the Public key ( privKey * G )
    */
    ChkBOOL( ecaffine_exponentiation( g_Ecurve.generator,
                                      rgdPriv, 
                                      ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                      rgptPub, 
                                     &g_Ecurve, 
                                      f_pBigCtx ),
             DRM_E_P256_PKCRYPTO_FAILURE );

    /*
    ** Just to be safe lets make sure the pubkey is on the curve
    */
    ChkBOOL( ecaffine_on_curve( rgptPub, 
                               &g_Ecurve,
                                NULL, 
                                rgdSuppliedTemps,
                                f_pBigCtx ),
             DRM_E_P256_PKCRYPTO_FAILURE );

    /*
    ** Now Convert the priv and pub keys into big-endian DRM-BYTES
    */
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdPriv, f_pPrivKey->m_rgbPrivkey ) );
    ChkDR( Convert_P256_PointToBigEndianBytes( rgptPub,
                                              &g_Ecurve,
                                               f_pPubKey->m_rgbPubkey ) );   
ErrorExit: 
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC   
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end DRM_ECC_GenKeyPair_P256 */

/************************************************************************************************
**
** Function:  DRM_ECC_GenKeyPairRestrictedPriv_P256
**
** Synopsis:  Generates a public-private key pair for the P256 FIPS Elliptic Curve
**
** Arguments:  
**    [f_pPubKey]:  A pointer to the structure that will be populated with the new public key
**    [f_pPrivKey]: A pointer to the structure that will be populated with the new public key
**    [f_pBigCtx]:  Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes: Generates a private key, this function should be protected the key is deemed as an asset
**
*************************************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ECC_GenKeyPairRestrictedPriv_P256( 
    __out          PUBKEY_P256  *f_pPubKey,
    __out          PRIVKEY_P256 *f_pPrivKey,
    __inout struct bigctx_t     *f_pBigCtx )
{
    /*
    ** decls
    */
    DRM_RESULT dr         = DRM_SUCCESS;
    DRM_DWORD  dwNumTries = 0;
    digit_t    rgdPriv[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]    = { 0 };
    digit_t    rgdSuppliedTemps[ ECC_P256_GENKEYPAIR_TEMPS ] = { 0 };
    digit_t    rgptPub[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]   = { 0 };

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_DRM_ECC_GenKeyPair_P256 );
#endif
    
    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_pPrivKey );
    ChkArg( NULL != f_pPubKey );
    ChkArg( NULL != f_pBigCtx );

    DRM_ECC_PKInit( f_pBigCtx, NULL );
    /*
    ** Create the private key such that it is any random number < curve order
    */
    do
    {
        /* 
        ** Make sure we have not tried too many times (prevent infinite loop)
        */
        if ( P256_KEY_GEN_TRIES < dwNumTries )
        {
            ChkDR( DRM_E_P256_PLAINTEXT_MAPPING_FAILURE );
        } /* end if */

        /*
        ** Generate random key, test to see if it is a valid key
        */
        ChkBOOL( random_mod_nonzero( g_Ecurve.gorder, 
                                     rgdPriv, 
                                     ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                     f_pBigCtx ),
                 DRM_E_P256_PKCRYPTO_FAILURE );

        ChkDR( DRM_ECC_CanMapToPoint_P256(rgdPriv, f_pBigCtx) );

        ++dwNumTries;
    } /* end do/while */
    while  ( DRM_SUCCESS != dr );
        
    /*
    ** Compute the Public key ( privKey * G )
    */
    ChkBOOL( ecaffine_exponentiation( g_Ecurve.generator,
                                      rgdPriv, 
                                      ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                      rgptPub, 
                                     &g_Ecurve, 
                                      f_pBigCtx ),
             DRM_E_P256_PKCRYPTO_FAILURE );

    /*
    ** Just to be safe lets make sure the pubkey is on the curve
    */
    ChkBOOL( ecaffine_on_curve( rgptPub, 
                               &g_Ecurve,
                                NULL, 
                                rgdSuppliedTemps,
                                f_pBigCtx ),
             DRM_E_P256_PKCRYPTO_FAILURE );

    /*
    ** Now Convert the priv and pub keys into big-endian DRM-BYTES
    */
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdPriv, f_pPrivKey->m_rgbPrivkey ) );
    ChkDR( Convert_P256_PointToBigEndianBytes( rgptPub,
                                              &g_Ecurve,
                                               f_pPubKey->m_rgbPubkey ) );   
ErrorExit: 
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif
    
    return dr;
} /* end DRM_ECC_GenKeyPairEncryptablePriv_P256 */

/*************************************************************************************************
**
**  Function: DRM_ECDSA_Sign_P256
**
**  Synopsis: Creates an ECDSA P256 signature for a message, given a private keys
**
**  Algorithm: x = message, P = public key, G = generator pt,
**             ( s, t ) = signature, q = field order and the ECDSA modulus
**             w = inverse( t ) MOD q
**             i = w * SHA256( x ) MOD q
**             j = w * s MOD q
**             ( u, v ) = iG + jP
**             Verify( x, ( s, t ) ) := u MOQ q == s
**
**  Arguments:
**   IN   [f_rgbMessage ]:   Message to check signature
**   IN   [f_cbMessageLen]: Message length in bytes
**   IN   [f_pPrivkey]:      Pointer to ECC Priv Key struct containing the privkey
**   OUT  [f_pSignature ]:   Pointer to the signature for the message 
**        [f_pBigCtx] :   Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
**  Notes: This function deals with the private key thus it must be protected/obfuscated/encrypted
**
*************************************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ECDSA_Sign_P256(
    __in_ecount( f_cbMessageLen ) const  DRM_BYTE         f_rgbMessage[],
    __in                          const  DRM_DWORD        f_cbMessageLen,
    __in                          const  PRIVKEY_P256    *f_pPrivkey,
    __out                                SIGNATURE_P256  *f_pSignature,
    __inout                       struct bigctx_t        *f_pBigCtx )
{    
    /*
    ** Decls
    */
    DRM_RESULT  dr            = DRM_SUCCESS;
    DRM_DWORD   dwNumTry      = 0;
    DRM_DWORD   cdGCDLen      = 0;
    digit_t  rgptRandPoint[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]          = { 0 };
    digit_t     rgdRandNum[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]              = { 0 };
    digit_t     rgdRandNumInverse[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]       = { 0 };
    digit_t     rgdSigElement[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]           = { 0 };
    digit_t     rgdIntermediateVal1[ 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ] = { 0 };
    digit_t     rgdIntermediateVal2[ 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ] = { 0 }; 
    digit_t     rgdIntermediateVal3[ 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ] = { 0 };
    digit_t     rgdMessageHash[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]          = { 0 };
    digit_t     rgdSuppliedTemps[ ECC_P256_SIGN_TEMPS ]                    = { 0 };

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_DRM_ECDSA_Sign_P256 );
#endif

    /*
    ** Arg Checks
    */  
    ChkArg( NULL !=  f_rgbMessage );
    ChkArg( NULL !=  f_pPrivkey );
    ChkArg( 0    !=  f_cbMessageLen );
    ChkArg( NULL !=  f_pSignature );
    ChkArg( NULL !=  f_pBigCtx )

    /*
    ** Re-Init big num context if it was not inialized or erased.
    */ 
    DRM_ECC_PKInit( f_pBigCtx, NULL );

    /*
    ** Hash the message
    */
    {
        DRM_SHA256_Digest  shaDigest;
        DRM_SHA256_Context shaData;  
    
        ChkDR( DRM_SHA256_Init( &shaData ) );
        ChkDR( DRM_SHA256_Update( &shaData,
                                   f_rgbMessage, 
                                   f_cbMessageLen ) );
        ChkDR( DRM_SHA256_Finalize( &shaData, &shaDigest ) );

        /*
        ** Convert the data into digits MOD order
        */
        ChkDR( Convert_P256_BigEndianBytesToDigitsModOrder( shaDigest.m_rgbDigest, 
                                                           &g_Ecurve,
                                                            rgdMessageHash ) );
    } /* end Hashing block */

    /* 
    ** Attempt the rest of the algorithm, if something is wrong, like we hit the pt at infinity, 
    ** if something goes wrong try again, until it succeeds or our loop ctr expires 
    */ 
    for( dwNumTry = 0; dwNumTry < 1000; ++dwNumTry ) 
    {
        /*
        ** Generate r, the random number
        */
        ChkBOOL( random_mod_nonzero( g_Ecurve.gorder, 
                                     rgdRandNum, 
                                     ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                     f_pBigCtx ),
                 DRM_E_P256_ECDSA_SIGNING_ERROR );

        /*  
        ** Calculate r*G, where G is the generator point 
        */  
#if DRM_PRECOMPUTE_GTABLE


        ChkBOOL( ecaffine_exponentiation_tabular( TABLE, 
                                                  ECC_P256_TABLE_SPACING, 
                                                  ECC_P256_TABLE_LAST, 
                                                  rgdRandNum, 
                                                  ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                                  rgptRandPoint,
                                                 &g_Ecurve,
                                                  f_pBigCtx ),
                 DRM_E_P256_ECDSA_SIGNING_ERROR );
#else
        ChkBOOL( ecaffine_exponentiation( g_Ecurve.generator, 
                                          rgdRandNum, 
                                          ECC_P256_INTEGER_SIZE_IN_DIGITS,   
                                          rgptRandPoint,      
                                         &g_Ecurve,          
                                          f_pBigCtx ),
                 DRM_E_P256_ECDSA_SIGNING_ERROR );
#endif

        /*
        ** where r*G = (u, v) grab u, then calculate s = u MOD q  
        */ 
        ChkDR( Convert_P256_ModularIntToDigitsModOrder( rgptRandPoint,
                                                       &g_Ecurve,
                                                        rgdSigElement ) );

        /*
        ** Chk to make sure that our signature element is not zero, if it is try again!
        ** If != 0, top the first part of the sig. out to the output buffer in big endian bytes
        */
        if ( significant_digit_count( rgdSigElement,  ECC_P256_INTEGER_SIZE_IN_DIGITS ) == 0 )
        {
            continue;
        } /* end if */
        ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdSigElement, f_pSignature->m_rgbSignature ) );

        /*
        ** Calculate inverse( r )   
        */   
        ChkBOOL( mp_gcdex( rgdRandNum,  
                           ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                           g_Ecurve.gorder,                
                           ECC_P256_INTEGER_SIZE_IN_DIGITS,  
                           rgdRandNumInverse,   
                           NULL, 
                           rgdIntermediateVal1, 
                           NULL,
                          &cdGCDLen, 
                           rgdSuppliedTemps, 
                           f_pBigCtx ),
                 DRM_E_P256_ECDSA_SIGNING_ERROR );  

        /*  
        ** Make sure that the rand num and the modulus are relative primes, (GDC must == 1 too!) 
        ** if not then there can be no inverse, try the whole process again!
        */
        if (   1 != cdGCDLen 
            || 1 != rgdIntermediateVal1[ 0 ] )
        {
            continue;
        } /* end if */

        /*
        ** Convert the priv key into digit format
        */
        ChkDR( Convert_P256_BigEndianBytesToDigits( f_pPrivkey->m_rgbPrivkey, rgdRandNum ) );

        /*  
        ** Calculate k*s and zero the priv key afterwards regardless of success or failure
        ** Note: I am reusing the randnum buffer b/c it does not need to be use anymore
        */  
        ChkBOOL( multiply( rgdSigElement,
                           ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                           rgdRandNum,   
                           ECC_P256_INTEGER_SIZE_IN_DIGITS,  
                           rgdIntermediateVal1 ),
                 DRM_E_P256_ECDSA_SIGNING_ERROR );

        /*
        ** Need to zero out ASAP b/c this is a weakpoint of the algorimth 
        */
        ZEROMEM( rgdRandNum, SIZEOF( digit_t ) * ECC_P256_INTEGER_SIZE_IN_DIGITS ); 
        
        /*
        ** calc: k*s mod q, 
        */
        ChkBOOL( divide( rgdIntermediateVal1, 
                          2 * ECC_P256_INTEGER_SIZE_IN_DIGITS,   
                          g_Ecurve.gorder, 
                          ECC_P256_INTEGER_SIZE_IN_DIGITS,   
                          NULL,
                          NULL, 
                          rgdIntermediateVal2 ),
                 DRM_E_P256_ECDSA_SIGNING_ERROR );

        /*   
        ** Calculate x + (k*s MOD q), where x is the message hash
        */ 
        ChkBOOL( add_diff( rgdIntermediateVal2,  
                           2 * ECC_P256_INTEGER_SIZE_IN_DIGITS,    
                           rgdMessageHash,
                           ECC_P256_INTEGER_SIZE_IN_DIGITS,    
                           rgdIntermediateVal3,
                           NULL ),
                 DRM_E_P256_ECDSA_SIGNING_ERROR );  

        /*
        ** Calculate x + (k*s MOD q) MOD q
        ** Note I am reusing the randNum buffer b/c it is not used for either the priv key,
        ** or the random number anymore.
        */
        ChkBOOL( divide( rgdIntermediateVal3, 
                         2 * ECC_P256_INTEGER_SIZE_IN_DIGITS,   
                         g_Ecurve.gorder, 
                         ECC_P256_INTEGER_SIZE_IN_DIGITS,   
                         NULL,
                         NULL, 
                         rgdRandNum ),
                 DRM_E_P256_ECDSA_SIGNING_ERROR );

        /* 
        ** Calculate (x + (k*s MOD q) MOD q)/r mod q 
        ** Note: Need to zero out the out param before hand just in case all bits don't
        ** get written over
        */ 
        ZEROMEM( rgdIntermediateVal1, SIZEOF( digit_t ) * 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS );     
        ChkBOOL( multiply( rgdRandNumInverse, 
                           ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                           rgdRandNum,     
                           ECC_P256_INTEGER_SIZE_IN_DIGITS,       
                           rgdIntermediateVal1 ),
                DRM_E_P256_ECDSA_SIGNING_ERROR );
        ChkBOOL( divide( rgdIntermediateVal1, 
                         2 * ECC_P256_INTEGER_SIZE_IN_DIGITS,
                         g_Ecurve.gorder,     
                         ECC_P256_INTEGER_SIZE_IN_DIGITS,  
                         NULL,    
                         NULL,      
                         rgdSigElement ), 
                 DRM_E_P256_ECDSA_SIGNING_ERROR );   

        /*  
        ** Chk to make sure that our signature element is not zero, if it is try again!
        */
        if( significant_digit_count( rgdSigElement,  ECC_P256_INTEGER_SIZE_IN_DIGITS ) == 0 )
        {
            continue;
        } /* end if */  

        /*
        ** We must have created a good signature at this point, so lets end the loop
        */
        break;
    }/* end for */

    /*
    ** Pop out the second signature element into the output buff in BE Bytes
    */
    ChkDR( Convert_P256_DigitsToBigEndianBytes( rgdSigElement,
                                               &f_pSignature->m_rgbSignature[ __CB_DECL( ECC_P256_INTEGER_SIZE_IN_BYTES ) ] ) );
  
ErrorExit: 

    /*
    ** Be safe and zero some critical buffers
    */
    OEM_SECURE_ZERO_MEMORY( rgdRandNum,          SIZEOF( digit_t ) * ECC_P256_INTEGER_SIZE_IN_DIGITS );
    OEM_SECURE_ZERO_MEMORY( rgdRandNumInverse,   SIZEOF( digit_t ) * ECC_P256_INTEGER_SIZE_IN_DIGITS );
    OEM_SECURE_ZERO_MEMORY( rgdIntermediateVal1, SIZEOF( digit_t ) * 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ); 
    OEM_SECURE_ZERO_MEMORY( rgdIntermediateVal2, SIZEOF( digit_t ) * 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ); 
    OEM_SECURE_ZERO_MEMORY( rgdIntermediateVal2, SIZEOF( digit_t ) * 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ); 
    OEM_SECURE_ZERO_MEMORY( rgdSigElement,       SIZEOF( digit_t ) * ECC_P256_INTEGER_SIZE_IN_DIGITS ); 

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr; 
} /* end ECDSAV_Sign */

/*************************************************************************************************
**
**  Function: DRM_ECDSA_Verify_P256
**
**  Synopsis: Test to see if a message and a ECDSA signature match
**
**  Algorithm: x = message, P = public key, G = generator pt (
**             (s,t) = signature, q = field order and the ECDSA modulus
**             w = inverse( t ) MOD q
**             i = w * SHA1(x) MOD q
**             j = w * s MOD q
**             (u, v) = iG + jP
**             Verify(x, (s, t) ) := u MOQ q == s
**
**  Arguments:
**   IN   [f_rgbMessage ]:   Message to check signature
**   IN   [f_cbMessageLen]: Message length in bytes
**   IN   [f_pPubkey]:      Pointer to ECC Public Key struct containing the pubkey
**   IN   [f_pSignature ]:   Pointer to the signature for the message 
**     OUT[f_pfVerified]:   Returned true if signature was valid, else false
**        [f_pBigCtx] :   Pointer to DRMBIGNUM_CONTEXT_STRUCT for temporary memory allocations.
**
**  Returns:    S_OK if not errors in the function, else corresponding
**              DRM_RESULT error code. [f_pfVerified] param tells if the
**              signature matched the message ( and pub key )
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_ECDSA_Verify_P256(
    __in_ecount( __CB_DECL( f_cbMessageLen ) ) const  DRM_BYTE         f_rgbMessage[],
    __in                                       const  DRM_DWORD        f_cbMessageLen,
    __in                                       const  PUBKEY_P256     *f_pPubkey,
    __in                                       const  SIGNATURE_P256  *f_pSignature,
    __inout                                    struct bigctx_t        *f_pBigCtx )
{
    /*
    ** Decls
    */
    DRM_RESULT  dr        = DRM_SUCCESS;
    DRM_DWORD   cdGCDLen  = 0;
    digit_t     rgdSigTInverse[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]   = { 0 };
    digit_t     rgdGCD[ 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ]       = { 0 };
    digit_t     rgdSigS[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]          = { 0 };
    digit_t     rgdSigT[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]          = { 0 };
    digit_t     rgdTempVar1[ 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ]  = { 0 };
    digit_t     rgdTempVar2[ 2 * ECC_P256_INTEGER_SIZE_IN_DIGITS ]  = { 0 };
    digit_t     rgdMsgHash[ ECC_P256_INTEGER_SIZE_IN_DIGITS ]       = { 0 };
    digit_t     rgdSuppliedTemps[ ECC_P256_VERIFY_TEMPS ]           = { 0 }; 
    digit_t  rgptA[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]           = { 0 };
    digit_t  rgptB[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]           = { 0 };
    digit_t  rgptP[ ECC_P256_POINT_SIZE_IN_ECAFFINES ]           = { 0 };
    DRM_BYTE    rgbU[ __CB_DECL( ECC_P256_INTEGER_SIZE_IN_BYTES ) ] = { 0 };

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRM_ECC_P256, PERF_FUNC_DRM_ECDSA_Verify_P256 );
#endif

    /*
    ** Arg Checks
    */
    ChkArg( NULL  !=  f_pPubkey );
    ChkArg( NULL  !=  f_rgbMessage );
    ChkArg( 0     <   f_cbMessageLen );
    ChkArg( NULL  !=  f_pSignature );
    ChkArg( NULL != f_pBigCtx );

    DRM_ECC_PKInit( f_pBigCtx, NULL );
    /*
    ** Convert our public key into EC Point ( modular ) format
    */
    ChkDR( Convert_P256_BigEndianBytesToPoint( f_pPubkey->m_rgbPubkey,
                                              &g_Ecurve,
                                               rgptP,
                                               f_pBigCtx ) );

    /*
    ** Hash the message
    */
    {
        DRM_SHA256_Digest  shaDigest;
        DRM_SHA256_Context shaData;  
      
        ChkDR( DRM_SHA256_Init( &shaData ) );

        ChkDR( DRM_SHA256_Update( &shaData,
                                   f_rgbMessage, 
                                   f_cbMessageLen ) );
        ChkDR( DRM_SHA256_Finalize( &shaData, &shaDigest ) );

        /*
        ** Convert the data into digits MOD order
        */
        ChkDR( Convert_P256_BigEndianBytesToDigitsModOrder( shaDigest.m_rgbDigest, 
                                                           &g_Ecurve,
                                                            rgdMsgHash ) );
    } /* end Hashing block */

    /*
    ** Convert the signature to digits
    */
    ChkDR( Convert_P256_BigEndianBytesToDigits( f_pSignature->m_rgbSignature, rgdSigS ) );
    ChkDR( Convert_P256_BigEndianBytesToDigits( &f_pSignature->m_rgbSignature[ ECC_P256_INTEGER_SIZE_IN_BYTES ],
                                                 rgdSigT ) );
    /*
    ** make sure that our sig was not all zeros (should have caused
    ** an error condition while signing )
    */
    ChkBOOL( (   significant_digit_count( rgdSigS,  ECC_P256_INTEGER_SIZE_IN_DIGITS ) != 0 
              && significant_digit_count( rgdSigT,  ECC_P256_INTEGER_SIZE_IN_DIGITS ) != 0 ),
            DRM_E_P256_INVALID_SIGNATURE );

    /*
    ** Test to see if either halves of the signature >= the curve order. They should not 
    ** ever be >= to this value ( alway less ) if they are then the signature used a larger
    ** modulus thus we have to fail!
    */
    ChkBOOL( (   compare_same( rgdSigS, g_Ecurve.gorder, ECC_P256_INTEGER_SIZE_IN_DIGITS ) < 0
              && compare_same( rgdSigT, g_Ecurve.gorder, ECC_P256_INTEGER_SIZE_IN_DIGITS ) < 0 ),
            DRM_E_P256_INVALID_SIGNATURE );  

    /*
    ** calculate inverse(T) = w
    */
    ChkBOOL( mp_gcdex( rgdSigT,
                       ECC_P256_INTEGER_SIZE_IN_DIGITS,
                       g_Ecurve.gorder,
                       ECC_P256_INTEGER_SIZE_IN_DIGITS,
                       rgdSigTInverse,
                       NULL,
                       rgdGCD,
                       NULL,
                      &cdGCDLen,
                       rgdSuppliedTemps,
                       f_pBigCtx ),
             DRM_E_P256_ECDSA_VERIFICATION_ERROR );

    /*
    ** Make sure that t and the modulus are coprimes (GCD == 1) if not
    ** then there was no inverse and we fail
    */
    ChkBOOL( (   1 == cdGCDLen 
              || 1 == rgdGCD[ 0 ] ),
            DRM_E_P256_INVALID_SIGNATURE );

    /*
    ** Calculate i = w * SHA(x) mod Q
    */
    ChkBOOL( multiply( rgdSigTInverse, 
                     ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                     rgdMsgHash, 
                     ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                     rgdTempVar1 ),
            DRM_E_P256_ECDSA_VERIFICATION_ERROR );      
    ChkBOOL( divide( rgdTempVar1,
                     2 * ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     g_Ecurve.gorder, 
                     ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     NULL, 
                     NULL, 
                     rgdTempVar2 ),
             DRM_E_P256_ECDSA_VERIFICATION_ERROR );

    /*
    ** Calculate A=iG, where G is the generator point
    */
#if DRM_PRECOMPUTE_GTABLE


    ChkBOOL( ecaffine_exponentiation_tabular( TABLE, 
                                              ECC_P256_TABLE_SPACING, 
                                              ECC_P256_TABLE_LAST, 
                                              rgdTempVar2, 
                                              ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                              rgptA,
                                             &g_Ecurve,
                                              f_pBigCtx ),
             DRM_E_P256_ECDSA_VERIFICATION_ERROR );
#else

    ChkBOOL( ecaffine_exponentiation( g_Ecurve.generator, 
                                      rgdTempVar2, 
                                      ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                      rgptA, 
                                     &g_Ecurve, 
                                      f_pBigCtx ),
             DRM_E_P256_ECDSA_VERIFICATION_ERROR );
#endif

    /*
    ** j = ws*mod(Q)
    */
    ChkBOOL( multiply( rgdSigTInverse, 
                       ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                       rgdSigS,
                       ECC_P256_INTEGER_SIZE_IN_DIGITS,
                       rgdTempVar1 ),
             DRM_E_P256_ECDSA_VERIFICATION_ERROR );
    ChkBOOL( divide( rgdTempVar1, 
                     2 * ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     g_Ecurve.gorder,
                     ECC_P256_INTEGER_SIZE_IN_DIGITS,
                     NULL,
                     NULL,
                     rgdTempVar2 ),
             DRM_E_P256_ECDSA_VERIFICATION_ERROR );

    /*
    ** Calculate B=jP, where P is the public key
    */
    ChkBOOL( ecaffine_exponentiation( rgptP,
                                      rgdTempVar2, 
                                      ECC_P256_INTEGER_SIZE_IN_DIGITS, 
                                      rgptB, 
                                     &g_Ecurve, 
                                      f_pBigCtx ),
             DRM_E_P256_ECDSA_VERIFICATION_ERROR );

    /*
    ** Calculate (u,v) = iA + jB ( in our variables we have A = A + B
    */
    ChkBOOL( ecaffine_addition( rgptA,
                                rgptB,
                                rgptA,
                                ECC_POINT_ADDITION,
                               &g_Ecurve,
                                rgdSuppliedTemps,
                                f_pBigCtx ),
             DRM_E_P256_ECDSA_VERIFICATION_ERROR );

    /*
    ** Check to make sure the pt is not the pt at infinity, ECDSA does not allow this
    */
    ChkBOOL( !ecaffine_is_infinite( rgptA, &g_Ecurve, NULL ),
              DRM_E_P256_INVALID_SIGNATURE );

    /*
    ** Convert (u,v) into integers so we can compare them to (s,t ) or rather 
    ** compare u to s
    */
    ChkDR( Convert_P256_ModularIntToBigEndianBytesModOrder( rgptA,
                                                           &g_Ecurve,
                                                            rgbU ) );

    /*
    ** If the two numbers match then we have validated the signature! 
    */
  if (0 != MEMCMP( f_pSignature->m_rgbSignature, 
                   rgbU,
                   ECC_P256_INTEGER_SIZE_IN_BYTES ) )
  {
    ChkDR(DRM_E_INVALID_SIGNATURE);
  } /* end if */

ErrorExit:
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC   
    DRM_PROFILING_LEAVE_SCOPE;
#endif

    return dr;
} /* end DRM_ECDSA_Verify_P256 */


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmeccp160.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <bignum.h>
#include <field.h>
#include <ecurve.h>
#include <mprand.h>
#include <drmcommon.h>
#include <drmprofile.h>
#include <drmpkcrypto.h>
#include <drmsha1.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

#define TABLE_SPACING 4
#define TABLE_LAST 60

#define PK_DATA_HEAP_SIZE 250

typedef struct {
    digit_t q[LNGQ]; 
    digit_t a[LNGQ];
    digit_t b[LNGQ];
    digit_t r[LNGQ];         /* from singature file,   order of g */
    DRM_DWORD   lngr;            /* Length of r (digits) */

    digit_t g[2*LNGQ];
    digit_t TABLE[ 2 * LNGQ * (TABLE_LAST+1) ];  /* TEST */

    mp_modulus_t   qmodulus;
    ecurve_t       ecurve;
    field_desc_t   fdesc;    
    reciprocal_1_t rrecip;             /* For division by r */
    
    DRM_STACK_ALLOCATOR_CONTEXT pkdHeap;
    DRM_BYTE rgbHeap[__CB_DECL(PK_DATA_HEAP_SIZE)];
} PK_DATA;

typedef struct __DRMBIGNUM_CONTEXT_STRUCT
{
    DRM_STACK_ALLOCATOR_CONTEXT oHeap;
    DRM_BYTE  rgbHeap[__CB_DECL(DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE)];
    PK_DATA   pkData;
    DRM_DWORD fInited;
    DRM_VOID *pOEMContext;
} DRMBIGNUM_CONTEXT_STRUCT;

static const DRM_DWORD ecdw_q[5] = 
{
    0x141424F7, 0x31415926, 0x27182818, 0x01234567, 0x89ABCDEF
};
/* ecdw_q = 785963102379428822376694789446897396207498568951 */

static const DRM_DWORD ecdw_order[5] = 
{
    0x28C2A675, 0xEC149044, 0x2716B26E, 0x01234567, 0x89ABCDEF
};
/* ecdw_order = 785963102379428822376693024881714957612686157429 */

static const DRM_DWORD ecdw_a[5] = 
{
    0xEBE41497, 0x4780C009, 0x7632FF3D, 0xD277BCE8, 0x37A5ABCC
};
/* ecdw_a = 317689081251325503476317476413827693272746955927 */

static const DRM_DWORD ecdw_b[5] = 
{
    0x9328239E, 0xD78FDEDF, 0x28E85F1A, 0x725E2F32, 0x0DD8DABF
};
/* ecdw_b = 79052896607878758718120572025718535432100651934 */

static const DRM_DWORD ecdw_genx[5] = 
{
    0x109FA120, 0xBA38DAF0, 0x3510C07D, 0xD6A3A1E5, 0x8723947F
};
/* ecdw_genx = 771507216262649826170648268565579889907769254176 */

static const DRM_DWORD ecdw_geny[5] = 
{
    0xA379936F, 0xD4ED7ACD, 0x8C3C5856, 0x1075522D, 0x44574491
};
/* ecdw_geny = 390157510246556628525279459266514995562533196655 */


static DRM_VOID endian_reverse_dwords( const DRM_DWORD f_rgdwIn[], DRM_DWORD f_rgdwOut[], DRM_DWORD cdw )
{
    if( f_rgdwOut != f_rgdwIn )
    {
        MEMCPY( f_rgdwOut, f_rgdwIn, cdw*SIZEOF(DRM_DWORD) );
    }

#if !TARGET_LITTLE_ENDIAN
    while( cdw>0 )
    {
        DRM_DWORD dw;

        cdw--;
        BYTES_TO_DWORD( dw, (DRM_BYTE*) &f_rgdwOut[cdw] );
        FIX_ENDIAN_DWORD( dw );
        DWORD_TO_BYTES( (DRM_BYTE*) &f_rgdwOut[cdw], dw );
    }
#endif

}

static DRM_BOOL dw_to_modular(               
    const  DRM_DWORD        *dwnum,
    const  DRM_DWORD         lngdw,
           digit_t          *answer,      /* OUT, length LNGQ */
    const  mp_modulus_t     *modulo,
    struct bigctx_t         *f_pBigCtx    )
{
    digit_t temp1[LNGQ];
    DRM_BOOL OK = FALSE;

    if( temp1 != NULL )
    {

        if (DWORDS_TO_DIGITS(lngdw) <= LNGQ)
        {        
            dwords_to_digits(dwnum, temp1, lngdw );
            OK = to_modular(temp1, DWORDS_TO_DIGITS(lngdw), answer, modulo, f_pBigCtx);
        }

        OEM_SECURE_ZERO_MEMORY( temp1, SIZEOF (digit_t) * LNGQ );
    }

    return OK;
} /* end dw_to_modular */


DRM_NO_INLINE DRM_BOOL words_to_ecaffine( 
    const DRM_DWORD *in, digit_t *P,        /* OUT */
    const ecurve_t  *E,
    struct bigctx_t *f_pBigCtx )  
/* map bits of "in" to a point on the curve such that the first n-1 bytes can be recovered

  NOTE: this is only supposed to work for my ec over FIELD_Q_MP and not intended to be
        used as a general purpose library function.    marcuspe

 NOTE -- We never return the point at infinity,
         so this may fail if the group has no other points,
         such as y^2 == x^3 - x - 1 (mod 3)
 NOTE -- A given point of order 2 (with y = 0) is twice as
         likely to be chosen as a given point of order > 2.
*/
{
    DRM_BOOL found = FALSE;
    DRM_INT tries;    
    flongest_t *t1;
    DRM_DWORD *tmp; /*[LNGQDW] */

    tmp = (DRM_DWORD*) bignum_alloc (SIZEOF (DRM_DWORD) * LNGQDW + SIZEOF (flongest_t), f_pBigCtx);

    if( tmp == NULL )
    {
        return found;
    }

    t1 = (flongest_t*)(tmp + LNGQDW);
    MEMCPY( tmp, in,( LNGQDW-1 )*SIZEOF( digit_t ));
    switch(E->fdesc->ftype) {
    case FIELD_Q_MP:
    case FIELD_2_POLYNOMIAL: 
    case FIELD_2_NORMAL:
        for (tries = 0; 
            tries < 100 && !found;
            tries++) {

                tmp[LNGQDW-1] = tries; 
                if( !dw_to_modular( tmp, LNGQDW, P, E->fdesc->modulo, f_pBigCtx) )
                {
                    found = FALSE;
                    break;
                }
                if (E->fdesc->ftype == FIELD_Q_MP || Kiszero(P, E->fdesc, f_pBigCtx) )
                {
                    if (Kmuladd (P, P,   E->a, *t1, E->fdesc, NULL, f_pBigCtx) 
                    &&  Kmuladd (P, *t1, E->b, *t1, E->fdesc, NULL, f_pBigCtx))
                    /*      t1 = x^2 + a                      t1 = x^3 + ax + b */
                    {
                        /* fSquare must be volatile to work in optimized builds of some compilers */
                        volatile DRM_BOOL fSquare = FALSE;
                        found = Kprime_sqrter(*t1, (P + E->fdesc->elng), 1, E->fdesc, ( DRM_BOOL* )&fSquare, f_pBigCtx) && fSquare;/* Is x^3 + ax + b  a square? */
                        continue;
                    }
                    found = FALSE;
                    break;
                } 
                else 
                {   
                    found = FALSE;
                    break;
                }
            } /* for tries */
            break;
    } /* switch */

    OEM_SECURE_ZERO_MEMORY( tmp, SIZEOF (DRM_DWORD) * LNGQDW + SIZEOF (flongest_t) );
    bignum_free (tmp, f_pBigCtx);
    return found;
} /* words_to_ecaffine */


static DRM_BOOL ecaffine_to_dwords( digit_t *P, DRM_DWORD *out, const ecurve_t  *E)
{
    /* inverts the mapping of dwords_to_ecaffine */
    DRM_DWORD tmp[LNGQDW + (SIZEOF( digit_t ) * LNGQ)/SIZEOF( DRM_DWORD )]; /*[LNGQDW]; */
    digit_t *digs; /*[LNGQ]; */

    if ( E != NULL &&
         E->fdesc != NULL &&
         E->fdesc->modulo != NULL &&
         E->fdesc->modulo->length == LNGQ &&
         tmp != NULL )
    {
        digs = (digit_t*)(tmp + LNGQDW );
        from_modular ( P, digs, E->fdesc->modulo);
        digits_to_dwords( digs, tmp, LNGQDW );
        endian_reverse_dwords( (const DRM_DWORD *)tmp, out, LNGQDW-1 );

        OEM_SECURE_ZERO_MEMORY( tmp, SIZEOF(DRM_DWORD) * LNGQDW + SIZEOF( digit_t ) * LNGQ );
        return( TRUE );
    }

    return FALSE;
}


#if defined( _PREFAST_ )
#pragma prefast(suppress:22112) /* security mitigation warning */
#endif
static DRM_VOID _PKLock();
static DRM_VOID _PKUnlock();

#if DRM_THREAD_SAFE
#define USEPKLOCK DRM_BOOL fLocked = FALSE;
#define PKLOCK {_PKLock();fLocked=TRUE;}
#define PKUNLOCK {if(fLocked){_PKUnlock();}}
#else
#define USEPKLOCK
#define PKLOCK
#define PKUNLOCK
#endif

static DRM_NO_INLINE DRM_RESULT ec_init( 
    PK_DATA         *pEc, 
    const DRM_DWORD *q, 
    const DRM_DWORD *order, 
    const DRM_DWORD *a, 
    const DRM_DWORD *b, 
    const DRM_DWORD *genx, 
    const DRM_DWORD *geny, 
    struct bigctx_t *f_pBigCtx) 
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( pEc   != NULL 
         || q     != NULL 
         || order != NULL 
         || a     != NULL 
         || b     != NULL 
         || genx  != NULL 
         || geny  != NULL );
    
    dwords_to_digits( q, pEc->q, LNGQDW );
    dwords_to_digits( order, pEc->r, LNGQDW );

    ChkBOOL( create_modulus( pEc->q, LNGQ, FROM_RIGHT, &pEc->qmodulus, f_pBigCtx, (struct bigctx_t*)&pEc->pkdHeap ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( dw_to_modular( a, LNGQDW, pEc->a, &pEc->qmodulus, f_pBigCtx ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( dw_to_modular( b, LNGQDW, pEc->b, &pEc->qmodulus, f_pBigCtx ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( Kinitialize_prime( &pEc->qmodulus, &pEc->fdesc, f_pBigCtx , (struct bigctx_t*)&pEc->pkdHeap ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( ec_initialize( pEc->a, pEc->b, &pEc->fdesc, &pEc->ecurve, f_pBigCtx, (struct bigctx_t*)&pEc->pkdHeap ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( dw_to_modular( ecdw_genx, LNGQDW, pEc->g, &pEc->qmodulus, f_pBigCtx ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( dw_to_modular( ecdw_geny, LNGQDW, pEc->g + LNGQ, &pEc->qmodulus, f_pBigCtx ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( ecaffine_on_curve(pEc->g, &pEc->ecurve, NULL, NULL, f_pBigCtx), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( ecaffine_table_construction( pEc->g, TABLE_SPACING, TABLE_LAST, pEc->TABLE, &pEc->ecurve, f_pBigCtx ), DRM_E_PKCRYPTO_FAILURE);

    pEc->lngr = LNGQ;
    divide_precondition_1( pEc->r, pEc->lngr, &pEc->rrecip );

ErrorExit:
    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_ECC_ThreadUnSafePKInit( 
    DRM_VOID* f_pContext, 
    DRM_VOID* f_pOEMContext )

{
    DRM_RESULT dr = DRM_E_PKCRYPTO_FAILURE;
    DRMBIGNUM_CONTEXT_STRUCT *pContext = (DRMBIGNUM_CONTEXT_STRUCT*) f_pContext;

    DRMCASSERT( SIZEOF( DRMBIGNUM_CONTEXT_STRUCT ) <= DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE );
    
    /* We need to check that big num stack is in good shape. 
    ** It is not trivial to check if it is initialized or not.
    ** I found taht sometimes this object is used as temporary scratch pad
    ** and pContext->oHeap might be in invalid state
    ** We make the check based on consistent value of cbStack and pbStack
    */
    if (    pContext->oHeap.cbStack != DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE 
         || pContext->oHeap.pbStack != pContext->rgbHeap
       )
    { 
        pContext->oHeap.nStackTop = 0;
        pContext->oHeap.cbStack = DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE;
        pContext->oHeap.pbStack = pContext->rgbHeap;
    }
    
    if( pContext->fInited )
    {
        return DRM_SUCCESS;
    }

    
    pContext->pOEMContext = f_pOEMContext;
    
    MEMSET( (DRM_BYTE*)&pContext->pkData, 0, SIZEOF( pContext->pkData ));    
    
    pContext->pkData.pkdHeap.nStackTop = 0;
    pContext->pkData.pkdHeap.cbStack = PK_DATA_HEAP_SIZE;
    pContext->pkData.pkdHeap.pbStack = pContext->pkData.rgbHeap;

    dr = ec_init(&pContext->pkData, ecdw_q, ecdw_order, ecdw_a, ecdw_b, ecdw_genx, ecdw_geny, (struct bigctx_t*)&pContext->oHeap);
    if( DRM_SUCCEEDED( dr ) )
    {
        pContext->fInited = TRUE;
    }
    
    return dr;
}

DRM_VOID DRM_CALL DRM_RSA_PKInit(
    IN OUT DRM_VOID *f_pContext )
{
    DRM_RSA_PKInitWithSize( f_pContext, SIZEOF(DRMBIGNUM_CONTEXT_STRUCT) );
}

DRM_VOID DRM_CALL DRM_RSA_PKInitWithSize(
    IN OUT DRM_VOID *f_pContext,
    IN     DRM_DWORD f_dwSize )
{
    DRMBIGNUM_CONTEXT_STRUCT *pContext = (DRMBIGNUM_CONTEXT_STRUCT*) f_pContext;

    DRMASSERT( f_dwSize >= SIZEOF(DRMBIGNUM_CONTEXT_STRUCT) );

    f_dwSize -= SIZEOF( DRMBIGNUM_CONTEXT_STRUCT );
    f_dwSize += DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE;
    f_dwSize += SIZEOF( PK_DATA );

    if (    pContext->oHeap.cbStack != f_dwSize
         || pContext->oHeap.pbStack != pContext->rgbHeap
       )
    { 
        pContext->oHeap.nStackTop = 0;
        pContext->oHeap.cbStack = f_dwSize;
        pContext->oHeap.pbStack = pContext->rgbHeap;
    }
    pContext->fInited = TRUE;
}


/*********************************************************************
**
**  Function:  DRM_ECC_GenKeyPair_P160
**
**  Synopsis:  Generate a matched public and private key pair
**
**  Arguments:  
**     [f_pContext] -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_ppubkey]  -- New public key
**     [f_pprivkey] -- New private key
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ECC_GenKeyPair_P160( 
    IN     DRM_VOID *f_pContext,
       OUT PUBKEY   *f_ppubkey,
       OUT PRIVKEY  *f_pprivkey )
{
    DRM_RESULT dr = DRM_E_PKCRYPTO_FAILURE;
    DRMBIGNUM_CONTEXT_STRUCT *pContext = (DRMBIGNUM_CONTEXT_STRUCT *)f_pContext;
    struct bigctx_t *pBigCtx                                                            = NULL;
    digit_t    tmp[2 * LNGQ + ( SIZEOF( digit_t ) * 2 *LNGQ )/SIZEOF(digit_t)]          = {0}; /* [LNGQ] */
    digit_t   *priv                                                                     = NULL; /* [LNGQ] */
    digit_t   *pub                                                                      = NULL; /* [2*LNGQ] */
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRM_ECC_P160, PERF_FUNC_DRM_ECC_GenKeyPair_P160);
#endif
    
    USEPKLOCK;

    ChkArg( f_pContext != NULL 
         && f_ppubkey  != NULL 
         && f_pprivkey != NULL );

    DRMASSERT( (DRM_DWORD_PTR)f_ppubkey % SIZEOF( DRM_DWORD ) == 0 );
    DRMASSERT( (DRM_DWORD_PTR)f_pprivkey % SIZEOF( DRM_DWORD ) == 0 );

    ChkDR( DRM_ECC_PKInit( pContext, NULL ) );

    PKLOCK;

    pContext->oHeap.nStackTop = 0;
    pContext->oHeap.cbStack = DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE;
    pContext->oHeap.pbStack = pContext->rgbHeap;

    pBigCtx = (struct bigctx_t *) &pContext->oHeap;

    priv = (digit_t*)(tmp  + LNGQ);
    pub  = (digit_t*)(priv + LNGQ);
    
    random_mod_nonzero( pContext->pkData.q, priv, LNGQ, pBigCtx );
    if( ecaffine_exponentiation_tabular( pContext->pkData.TABLE, TABLE_SPACING, TABLE_LAST, priv, LNGQ, pub, &(pContext->pkData.ecurve), pBigCtx ) )
    {

        digits_to_dwords( priv, (DRM_DWORD*)f_pprivkey->x, LNGQDW );
        endian_reverse_dwords( (DRM_DWORD*)f_pprivkey->x, (DRM_DWORD*)f_pprivkey->x, DRM_ECC160_PRIVATE_KEY_LEN / SIZEOF( DRM_DWORD ) );
        
        from_modular ( pub, tmp, &(pContext->pkData.qmodulus) );
        digits_to_dwords( tmp, (DRM_DWORD*)f_ppubkey->y, LNGQDW ); 

        from_modular ( pub+LNGQ, tmp, &(pContext->pkData.qmodulus) );
        digits_to_dwords( tmp, ((DRM_DWORD*)f_ppubkey->y) + LNGQDW, LNGQDW ); 
        endian_reverse_dwords( (DRM_DWORD*)f_ppubkey->y, (DRM_DWORD *)f_ppubkey->y, DRM_ECC160_PUBLIC_KEY_LEN / SIZEOF( DRM_DWORD ) );

        dr = DRM_SUCCESS;
    }

    OEM_SECURE_ZERO_MEMORY( tmp, (SIZEOF ( digit_t ) * 2 * LNGQ) + ( SIZEOF( digit_t ) * 2 *LNGQ ) );

ErrorExit:
    PKUNLOCK;
   
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif
    
    return dr;    
}


/*********************************************************************
**
**  Function:  DRM_ECC_Encrypt_P160
**
**  Synopsis:  Encrypt a block of data with a given public key.
**
**  Arguments:  
**     [f_pContext] -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_ppubkey]  -- Public key to encrypt with
**     [f_rgbIn]    -- Data to be encrypted
**     [f_rgbOut]   -- Buffer to hold the encrypted data value.
**
**  Notes:  Data is not encrpyted in place.  It is put in the rgbOut buffer.
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_ECC_Encrypt_P160( 
    IN        DRM_VOID *f_pContext, 
    IN  const PUBKEY   *f_ppubkey,
    __in_bcount( DRM_ECC160_PLAINTEXT_LEN ) const DRM_BYTE  f_rgbIn[__CB_DECL(DRM_ECC160_PLAINTEXT_LEN)],
    __out_bcount( DRM_ECC160_CIPHERTEXT_LEN ) DRM_BYTE  f_rgbOut[__CB_DECL(DRM_ECC160_CIPHERTEXT_LEN)] )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRMBIGNUM_CONTEXT_STRUCT *pContext = (DRMBIGNUM_CONTEXT_STRUCT *)f_pContext;
    DRM_DWORD rgdwPubKey[ DRM_ECC160_PUBLIC_KEY_LEN / SIZEOF( DRM_DWORD )  ];
    digit_t    k[LNGQ + ( SIZEOF(digit_t) * 5*2*LNGQ )/SIZEOF(digit_t)]; /* [LNGQ]   */
    struct bigctx_t *pBigCtx = NULL;
    digit_t *a   = NULL; /* [2*LNGQ] */
    digit_t *b   = NULL; /* [2*LNGQ] */
    digit_t *tmp = NULL; /* [2*LNGQ] */
    digit_t *ecM = NULL; /* [2*LNGQ] */
    digit_t *pk  = NULL; /* [2*LNGQ] */
    USEPKLOCK;

    ChkArg( f_pContext    != NULL
         && f_ppubkey     != NULL
         && f_rgbIn       != NULL
         && f_rgbOut      != NULL );

    DRMASSERT( (DRM_DWORD_PTR)f_ppubkey % SIZEOF( DRM_DWORD ) == 0 );

    ChkDR( DRM_ECC_PKInit( pContext, NULL ) );

    PKLOCK;

    pContext->oHeap.nStackTop = 0;
    pContext->oHeap.cbStack   = DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE;
    pContext->oHeap.pbStack   = pContext->rgbHeap;

    pBigCtx = (struct bigctx_t *) &pContext->oHeap;

    a   = (digit_t*)(k   + LNGQ);
    b   = (digit_t*)(a   + 2 * LNGQ);
    tmp = (digit_t*)(b   + 2 * LNGQ);
    ecM = (digit_t*)(tmp + 2 * LNGQ);
    pk  = (digit_t*)(ecM + 2 * LNGQ);

    endian_reverse_dwords( (const DRM_DWORD*)f_ppubkey->y, rgdwPubKey, DRM_ECC160_PUBLIC_KEY_LEN / SIZEOF( DRM_DWORD ) );

    ChkArg( pContext->pkData.qmodulus.length == LNGQ );

    dw_to_modular( rgdwPubKey,          LNGQDW, pk,      &(pContext->pkData.qmodulus), pBigCtx );
    dw_to_modular( rgdwPubKey + LNGQDW, LNGQDW, pk+LNGQ, &(pContext->pkData.qmodulus), pBigCtx );

    if( !ecaffine_on_curve(pk, &(pContext->pkData.ecurve), NULL, NULL, pBigCtx ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    /* Do a byte copy from the input buffer to the output buffer since
    ** only the output buffer is guaranteed to be DWORD aligned
    */
    MEMCPY( f_rgbOut, f_rgbIn, DRM_ECC160_PLAINTEXT_LEN );
    
    endian_reverse_dwords( (const DRM_DWORD*)f_rgbOut, (DRM_DWORD*)f_rgbOut, DRM_ECC160_PLAINTEXT_LEN / SIZEOF(DRM_DWORD) );
    if( !words_to_ecaffine( (DRM_DWORD *)f_rgbOut, ecM, &(pContext->pkData.ecurve), pBigCtx ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    random_mod_nonzero( pContext->pkData.q, k, LNGQ, pBigCtx );

    if( !ecaffine_exponentiation_tabular( pContext->pkData.TABLE, TABLE_SPACING, TABLE_LAST, k, LNGQ, a, &(pContext->pkData.ecurve), pBigCtx ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    if( !ecaffine_on_curve( pk, &pContext->pkData.ecurve, NULL, NULL, pBigCtx ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    if( !ecaffine_exponentiation_tabular( pk, TABLE_SPACING, 0, k, LNGQ, tmp, &(pContext->pkData.ecurve), pBigCtx ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    if( !ecaffine_addition( tmp, ecM, b, 1, &(pContext->pkData.ecurve), NULL, pBigCtx  ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }


    from_modular ( a, tmp, &(pContext->pkData.qmodulus) );
    digits_to_dwords( tmp, (DRM_DWORD *)f_rgbOut, LNGQDW ); 
    from_modular ( a+LNGQ, tmp, &pContext->pkData.qmodulus );
    digits_to_dwords( tmp, ((DRM_DWORD *)f_rgbOut)+LNGQDW, LNGQDW ); 

    from_modular ( b, tmp, &pContext->pkData.qmodulus );
    digits_to_dwords( tmp, ((DRM_DWORD *)f_rgbOut) + 2*LNGQDW, LNGQDW ); 
    from_modular ( b+LNGQ, tmp, &pContext->pkData.qmodulus );
    digits_to_dwords( tmp, ((DRM_DWORD *)f_rgbOut) + 3*LNGQDW, LNGQDW ); 

    endian_reverse_dwords( (DRM_DWORD *)f_rgbOut, (DRM_DWORD*)f_rgbOut, 4*LNGQDW );

ErrorExit:
    PKUNLOCK;
    if( k )
    {
        OEM_SECURE_ZERO_MEMORY( k, (SIZEOF( digit_t) * LNGQ ) + ( SIZEOF (digit_t) * 5*2*LNGQ ) );
    }
    return dr;
}


/*********************************************************************
**
**  Function:  DRM_ECC_Decrypt_P160
**
**  Synopsis:  
**
**  Arguments:  
**     [f_pContext] -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_pprivkey] -- Private key to decrypt with
**     [f_rgbIn]    -- Encrypted bytes that are to be decrypted
**     [f_rgbOut]   -- Clear text result
**
**  Notes:  Data is not decrpyted in place.  It is put in the rgbOut buffer.
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ECC_Decrypt_P160(
    IN        DRM_VOID *f_pContext,
    IN  const PRIVKEY  *f_pprivkey,
    __in_bcount( DRM_ECC160_CIPHERTEXT_LEN ) const DRM_BYTE  f_rgbIn[__CB_DECL(DRM_ECC160_CIPHERTEXT_LEN)],
    __out_bcount( DRM_ECC160_PLAINTEXT_LEN ) DRM_BYTE  f_rgbOut[__CB_DECL(DRM_ECC160_PLAINTEXT_LEN)] )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRMBIGNUM_CONTEXT_STRUCT *pContext = (DRMBIGNUM_CONTEXT_STRUCT *)f_pContext;
    DRM_DWORD rgdwPrivKey[ DRM_ECC160_PRIVATE_KEY_LEN / SIZEOF( DRM_DWORD ) ];
    DRM_DWORD rgdwIn     [DRM_ECC160_CIPHERTEXT_LEN / SIZEOF( DRM_DWORD )];
    DRM_DWORD rgdwOut    [DRM_ECC160_PLAINTEXT_LEN / SIZEOF( DRM_DWORD )];
    digit_t *a   = NULL; /* [2*LNGQ] */
    digit_t *b   = NULL; /* [2*LNGQ] */
    digit_t *tmp = NULL; /* [2*LNGQ] */
    digit_t *ecM = NULL; /* [2*LNGQ] */
    digit_t    pk[(SIZEOF( digit_t) * LNGQ ) + ( SIZEOF (digit_t) * 4*2*LNGQ )] = {0}; /* [LNGQ]   */
    struct bigctx_t *pBigCtx = NULL;

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRM_ECC_P160, PERF_FUNC_DRM_ECC_Decrypt_P160);
#endif

    USEPKLOCK;
    
    ChkArg( f_pContext    != NULL
         && f_pprivkey    != NULL 
         && f_rgbIn       != NULL 
         && f_rgbOut      != NULL );

    DRMASSERT( (DRM_DWORD_PTR)f_pprivkey % SIZEOF( DRM_DWORD ) == 0 );

    ChkDR( DRM_ECC_PKInit( pContext, NULL ) );

    PKLOCK;

    pContext->oHeap.nStackTop = 0;
    pContext->oHeap.cbStack   = DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE;
    pContext->oHeap.pbStack   = pContext->rgbHeap;

    pBigCtx = (struct bigctx_t *) &pContext->oHeap;

    a   = (digit_t*)(pk  +     LNGQ);
    b   = (digit_t*)(a   + 2 * LNGQ);
    tmp = (digit_t*)(b   + 2 * LNGQ);
    ecM = (digit_t*)(tmp + 2 * LNGQ);


    endian_reverse_dwords( (const DRM_DWORD *)f_pprivkey->x, rgdwPrivKey, DRM_ECC160_PRIVATE_KEY_LEN / SIZEOF( DRM_DWORD ) );
    dwords_to_digits( rgdwPrivKey, pk, LNGQDW );

    /* Do a byte copy from the input buffer to the local buffer since
    ** only the local buffer is guaranteed to be DWORD aligned
    */
    MEMCPY( rgdwIn, f_rgbIn, DRM_ECC160_CIPHERTEXT_LEN );

    endian_reverse_dwords( (const DRM_DWORD *)rgdwIn, rgdwIn, DRM_ECC160_CIPHERTEXT_LEN / SIZEOF(DRM_DWORD) );

    dw_to_modular( rgdwIn,          LNGQDW, a,      &pContext->pkData.qmodulus, pBigCtx );
    dw_to_modular( rgdwIn + LNGQDW, LNGQDW, a+LNGQ, &pContext->pkData.qmodulus, pBigCtx );
    dw_to_modular( rgdwIn+2*LNGQDW, LNGQDW, b,      &pContext->pkData.qmodulus, pBigCtx );
    dw_to_modular( rgdwIn+3*LNGQDW, LNGQDW, b+LNGQ, &pContext->pkData.qmodulus, pBigCtx );

    if( !ecaffine_on_curve( a, &pContext->pkData.ecurve, NULL, NULL, pBigCtx ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    if( !ecaffine_exponentiation_tabular( a, TABLE_SPACING, 0, pk, LNGQ, tmp, &(pContext->pkData.ecurve), pBigCtx ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( !ecaffine_addition( b, tmp, ecM, -1, &(pContext->pkData.ecurve), NULL, pBigCtx ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( !ecaffine_to_dwords( ecM, rgdwOut, &(pContext->pkData.ecurve) ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    MEMCPY( f_rgbOut, rgdwOut, DRM_ECC160_PLAINTEXT_LEN );
    OEM_SECURE_ZERO_MEMORY( rgdwOut, DRM_ECC160_PLAINTEXT_LEN );
    
ErrorExit:
    PKUNLOCK;
    if( pContext )
    {
        if( pk )
        {
            OEM_SECURE_ZERO_MEMORY( pk, (SIZEOF( digit_t) * LNGQ ) + ( SIZEOF (digit_t) * 4*2*LNGQ ) );
        }
        
    }

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif
    
    return( dr );
}

#define SIGN_BUF_LEN  (LNGQDW*SIZEOF(DRM_DWORD))

static DRM_BOOL DRM_CALL byte_array_mod_bignum(
    const  DRM_BYTE     buf[__CB_DECL(SIGN_BUF_LEN)],                                  
           digit_t      remainder[],
           PK_DATA     *pPKData )               /* Given a message to be signed, in byte form reduce it modulo pkData.r[].  */
{

#define PACKED_CHAR_BIT (CHAR_BIT/CB_NATIVE_BYTE)
#define BYTES_PER_DIGIT (RADIX_BITS/PACKED_CHAR_BIT)

#if (RADIX_BITS % CHAR_BIT != 0) 
#error "Radix_bits not multiple of CHAR_BIT"
#endif    
    digit_t dividend[SIGN_BUF_LEN]; /*[SIGN_BUF_LEN] */
    DRM_DWORD ib;

    if( dividend == NULL )
    {
        return FALSE;
    }

    ZEROMEM(dividend, SIGN_BUF_LEN*SIZEOF( digit_t ));
        
    for (ib = 0; ib < SIGN_BUF_LEN; ib++) 
    {
        const DRM_DWORD idigit = ib/BYTES_PER_DIGIT;
        const DRM_DWORD ishift = PACKED_CHAR_BIT*ib - RADIX_BITS*idigit;
        dividend[idigit] |= ((digit_t)GET_BYTE(buf,ib)) << ishift;
    }

    /* Do the division, discard quotient. */
    divide(dividend, SIGN_BUF_LEN, pPKData->r, pPKData->lngr, &pPKData->rrecip, NULL, remainder);
    OEM_SECURE_ZERO_MEMORY( dividend, SIGN_BUF_LEN * SIZEOF( digit_t ) );
    return TRUE;
} /* end byte_array_mod_bignum */

static DRM_NO_INLINE DRM_BOOL FE2IPmod(
    const digit_t     *fdata,
    const field_desc_t    *fdesc,
    const digit_t          divisor[],
    const DRM_DWORD        ldivisor,
    const reciprocal_1_t  *recip,
    digit_t                remainder[],    /* OUT */
    DRM_VOID              *pContext )
    /* Convert (i.e., cast) a field element to an integer, */
    /* reduce the value modulo divisor.  FE2IP is a P1363 function. */
    /* TBD -- Do we need byte reversal? */
{
    DRM_BOOL OK = TRUE;
    digit_t *mdata; /*[MP_LONGEST]; */
    const digit_t *data;
    struct bigctx_t *pBigCtx = (struct bigctx_t*) pContext;

    mdata = (digit_t*)bignum_alloc( SIZEOF( digit_t ) * MP_LONGEST, pBigCtx );
    if( mdata == NULL )
    {
        return FALSE;
    }

    if (fdesc->ftype == FIELD_Q_MP)
    {
        from_modular(fdata, mdata, fdesc->modulo);    /* Get standard representation */
        data = mdata;
    }
    else
    {  /* Characteristic 2 */
        data = fdata;
        if( !(mp_significant_bit_count(fdata, fdesc->elng) <= fdesc->degree) )
        {
            OK = FALSE;
            /* Leading zeros expected */
        }        
    }
    if( OK )
    {
        divide(data, fdesc->elng, divisor, ldivisor, recip, NULL, remainder);
    }
    OEM_SECURE_ZERO_MEMORY( mdata, SIZEOF( digit_t ) * MP_LONGEST );
    bignum_free( mdata, pBigCtx );
    return OK;
} /* end FE2IPmod */



/*********************************************************************
**
**  Function:  DRM_ECC_Sign_P160
**
**  Synopsis:  Generate a digital signature with a private key
**
**  Arguments:  
**     [f_pContext]     -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_privkey]      -- Private key to create a signature with
**     [f_pbData]       -- Array of bytes to create a signature over
**     [f_cbData]       -- Length of pbBuffer in bytes
**     [f_rgbSignature] -- Buffer to hold result signature
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ECC_Sign_P160(
    IN       DRM_VOID  *f_pContext,
    IN const PRIVKEY   *f_privkey,
    __out_bcount( f_cbData ) const DRM_BYTE  *f_pbData,
    IN       DRM_DWORD  f_cbData,
    __out_bcount( DRM_ECC160_SIGNATURE_LEN ) DRM_BYTE   f_rgbSignature[__CB_DECL(DRM_ECC160_SIGNATURE_LEN)] )
{    
    DRM_RESULT dr = DRM_SUCCESS;
    DRMBIGNUM_CONTEXT_STRUCT *pContext = (DRMBIGNUM_CONTEXT_STRUCT *)f_pContext;
    DRM_DWORD rgdwPrivKey[ DRM_ECC160_PRIVATE_KEY_LEN / SIZEOF( DRM_DWORD )];
    DRM_DWORD ntry = 0;
    DRM_DWORD    lgcd   = 0;
    digit_t  *Gpriv2    = NULL;  /* [2*MP_LONGEST] */
    digit_t  *gcd       = NULL;  /* [MP_LONGEST] */
    digit_t  *priv2     = NULL;  /* [MP_LONGEST] */
    digit_t  *priv2inv  = NULL;  /* [MP_LONGEST] */
    digit_t  *sigc      = NULL;  /* [LNGQ] */
    digit_t  *sigd      = NULL;  /* [LNGQ] */
    digit_t  *privexpon = NULL;  /* [LNGQ] */
    DRM_BYTE *buffer    = NULL;  /* [SIGN_BUF_LEN]     */
    struct bigctx_t *pBigCtx = NULL;
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRM_ECC_P160, PERF_FUNC_DRM_ECC_Sign_P160);
#endif    
    
    USEPKLOCK;  
    
    ChkArg( f_pContext     != NULL 
         && f_privkey      != NULL 
         && f_pbData       != NULL 
         && f_cbData       != 0 
         && f_rgbSignature != NULL );

    DRMASSERT( (DRM_DWORD_PTR)f_privkey % SIZEOF( DRM_DWORD ) == 0 );

    ChkDR( DRM_ECC_PKInit( pContext, NULL ) );

    PKLOCK;

    pContext->oHeap.nStackTop = 0;
    pContext->oHeap.cbStack   = DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE;
    pContext->oHeap.pbStack   = pContext->rgbHeap;

    pBigCtx = (struct bigctx_t *) &pContext->oHeap;

    ChkMem( gcd = (digit_t*)bignum_alloc( (SIZEOF( digit_t) * (3*LNGQ + 3*MP_LONGEST) ) 
                                         +(SIZEOF(digit_t) * 2*MP_LONGEST ) 
                                         +SIGN_BUF_LEN,
                                         pBigCtx ) );

    priv2     = gcd      + MP_LONGEST;
    priv2inv  = priv2    + MP_LONGEST;
    sigc      = priv2inv + MP_LONGEST;
    sigd      = sigc     + LNGQ;
    privexpon = sigd     + LNGQ;

    Gpriv2    = (digit_t*)(privexpon + LNGQ);
    buffer    = (DRM_BYTE*)(Gpriv2      + 2 * MP_LONGEST);

    endian_reverse_dwords( (const DRM_DWORD *)f_privkey->x, rgdwPrivKey, DRM_ECC160_PRIVATE_KEY_LEN / SIZEOF( DRM_DWORD ) );
    dwords_to_digits( rgdwPrivKey, privexpon, LNGQDW );

    {
        DRM_SHA_CONTEXT shadata;

        MEMSET( buffer, 0, SIGN_BUF_LEN );

        ChkDR( DRM_SHA_Init( &shadata, eDRM_SHA_1 ) );
        ChkDR( DRM_SHA_Update( (DRM_BYTE*) f_pbData, f_cbData, &shadata ) );
        ChkDR( DRM_SHA_Finalize( &shadata, DRM_SHA1_DIGEST_LEN, buffer ) );
    }

    for( ntry = 0; ntry < 1000; ntry++ )
    {
        random_mod_nonzero( pContext->pkData.q, priv2, LNGQ, pBigCtx );
        
        if( !ecaffine_exponentiation_tabular( pContext->pkData.TABLE, TABLE_SPACING, TABLE_LAST, priv2, LNGQ, Gpriv2, &pContext->pkData.ecurve, pBigCtx ) )
        {
            ChkDR( DRM_E_PKCRYPTO_FAILURE );
        }

        if( ecaffine_is_infinite(Gpriv2, &pContext->pkData.ecurve, pBigCtx ) )
        {
            break;
        }

        if( !FE2IPmod(Gpriv2, pContext->pkData.ecurve.fdesc, pContext->pkData.r, pContext->pkData.lngr, &pContext->pkData.rrecip, sigc, pBigCtx ) )
        {
            break;
        }

        if( compare_immediate(gcd, 1, mp_gcdex(priv2, pContext->pkData.lngr, pContext->pkData.r, pContext->pkData.lngr,  priv2inv, NULL, gcd, NULL, &lgcd, NULL, pBigCtx)) != 0 )
        {
            break;
        }

        multiply(sigc, pContext->pkData.lngr, privexpon, pContext->pkData.lngr, Gpriv2);   
        if( !byte_array_mod_bignum(buffer, gcd, &pContext->pkData ) )
        {
            break;
        }
        
        add_diff(Gpriv2, 2*pContext->pkData.lngr, gcd, pContext->pkData.lngr, Gpriv2, NULL);  /* Overflow impossible */
        divide(Gpriv2, 2*pContext->pkData.lngr, pContext->pkData.r, pContext->pkData.lngr, &pContext->pkData.rrecip, NULL, gcd);
        multiply(priv2inv, pContext->pkData.lngr, gcd, pContext->pkData.lngr, Gpriv2);
        divide(Gpriv2, 2*pContext->pkData.lngr, pContext->pkData.r, pContext->pkData.lngr, &pContext->pkData.rrecip, NULL, sigd);            
        
        /* TBD -- should check more error codes */

        if( significant_digit_count(sigc,  pContext->pkData.lngr) != 0 
         && significant_digit_count(sigd,  pContext->pkData.lngr) != 0 )
        {
            break;
        }

    }

    ZEROMEM(priv2, pContext->pkData.lngr*SIZEOF( digit_t ));    /* P1363 recommends this for security */
    ZEROMEM(priv2inv, pContext->pkData.lngr*SIZEOF( digit_t ));
    ZEROMEM(Gpriv2, MAX(2*pContext->pkData.lngr, 2*pContext->pkData.ecurve.fdesc->elng)*SIZEOF( digit_t ));

    digits_to_dwords( sigc, (DRM_DWORD *)f_rgbSignature, LNGQDW );
    digits_to_dwords( sigd, ((DRM_DWORD *)f_rgbSignature) + LNGQDW, LNGQDW );

    endian_reverse_dwords( (const DRM_DWORD *)f_rgbSignature, (DRM_DWORD*) f_rgbSignature, 2*LNGQDW );

ErrorExit:
    PKUNLOCK;
    if( pContext )
    {
        if( gcd )
        {
            OEM_SECURE_ZERO_MEMORY( gcd, (SIZEOF( digit_t) * (3*LNGQ + 3*MP_LONGEST) ) + (SIZEOF(digit_t) * 2*MP_LONGEST ) + SIGN_BUF_LEN );
        }
        bignum_free( gcd, pBigCtx );
    }
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif
        
    return dr;
} /* end DRM_ECC_Sign_P160 */


/*********************************************************************
**
**  Function:  DRM_ECC_Verify_P160
**
**  Synopsis:  Verify a digital signature created by DRM_ECC_Sign_P160.
**
**  Arguments:  
**     [f_pContext]     -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_ppubkey]      -- Pubkey to check the signature with
**     [f_pbData]       -- Data buffer that the signature was created over
**     [f_cbData]       -- Length of pbBuffer in bytes
**     [f_rgbSignature] -- The signature to verify
**
**  Returns:  TRUE if the signature verified correctly.  FALSE is it didn't
**
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL DRM_ECC_Verify_P160( 
    IN       DRM_VOID  *f_pContext,
    IN const PUBKEY    *f_ppubkey, 
    __in_bcount( f_cbData ) const DRM_BYTE  *f_pbData, 
    IN       DRM_DWORD  f_cbData, 
    __in_bcount( DRM_ECC160_SIGNATURE_LEN ) const DRM_BYTE   f_rgbSignature[__CB_DECL(DRM_ECC160_SIGNATURE_LEN)] )
{    
    DRM_RESULT dr = DRM_SUCCESS;
    DRMBIGNUM_CONTEXT_STRUCT *pContext = (DRMBIGNUM_CONTEXT_STRUCT *)f_pContext;
    DRM_DWORD rgdwPubKey[ DRM_ECC160_PUBLIC_KEY_LEN / SIZEOF( DRM_DWORD ) ];
    DRM_DWORD rgdwSignature[ 2*LNGQDW ];
    DRM_DWORD   lgcd     = 0;
    digit_t    *sigdinv  = NULL; /* [MP_LONGEST] */
    digit_t    *gcd      = NULL; /* [MP_LONGEST] */
    digit_t    *sigc     = NULL; /* [LNGQ] */
    digit_t    *sigd     = NULL; /* [LNGQ] */
    digit_t    *h1G      = NULL; /* [2*MP_LONGEST] */
    digit_t    *h2pubkey = NULL; /* [2*MP_LONGEST] */
    digit_t    *pubkey   = NULL; /* [2*LNGQ] */
    DRM_BYTE   *buffer   = NULL; /* [SIGN_BUF_LEN] */
    struct bigctx_t *pBigCtx  = NULL;
    const ecurve_t  *ecurve   = NULL;
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRM_ECC_P160, PERF_FUNC_DRM_ECC_Verify_P160);
#endif
    
    USEPKLOCK;
    
    ChkArg( f_pContext     != NULL 
         && f_ppubkey      != NULL 
         && f_pbData       != NULL 
         && f_cbData       != 0 
         && f_rgbSignature != NULL );

    DRMASSERT( (DRM_DWORD_PTR)f_ppubkey % SIZEOF( DRM_DWORD ) == 0 );

    ChkDR( DRM_ECC_PKInit( pContext, NULL ) );

    PKLOCK;

    pContext->oHeap.nStackTop = 0;
    pContext->oHeap.cbStack   = DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE;
    pContext->oHeap.pbStack   = pContext->rgbHeap;

    pBigCtx = (struct bigctx_t *) &pContext->oHeap;

    ChkMem( sigdinv = (digit_t*)bignum_alloc( (SIZEOF( digit_t) * (2*LNGQ + 2*MP_LONGEST) ) 
                                             +(SIZEOF(digit_t) * (2*2*MP_LONGEST + 2*LNGQ) )
                                             + SIGN_BUF_LEN, 
                                             pBigCtx ) );

    gcd      = sigdinv  + MP_LONGEST;
    sigc     = gcd      + MP_LONGEST;
    sigd     = sigc     + LNGQ;
    h1G      = (digit_t*)(sigd     +  LNGQ);
    h2pubkey = h1G      + 2*MP_LONGEST;
    pubkey   = h2pubkey + 2*MP_LONGEST;
    buffer   = (DRM_BYTE*)(pubkey   +2*LNGQ);

    ecurve = &pContext->pkData.ecurve;

    endian_reverse_dwords( (const DRM_DWORD *)f_rgbSignature, rgdwSignature, 2*LNGQDW );

    dwords_to_digits( rgdwSignature,          sigc, LNGQDW );
    dwords_to_digits( rgdwSignature + LNGQDW, sigd, LNGQDW );

    endian_reverse_dwords( (const DRM_DWORD *)f_ppubkey->y, rgdwPubKey, DRM_ECC160_PUBLIC_KEY_LEN / SIZEOF( DRM_DWORD ) );

    dw_to_modular( rgdwPubKey,        LNGQDW, pubkey,      &(pContext->pkData.qmodulus), pBigCtx );
    dw_to_modular( rgdwPubKey+LNGQDW, LNGQDW, pubkey+LNGQ, &(pContext->pkData.qmodulus), pBigCtx );


    {
        DRM_SHA_CONTEXT shadata;

        MEMSET( buffer, 0, SIGN_BUF_LEN);

        ChkDR( DRM_SHA_Init( &shadata, eDRM_SHA_1 ) );
        ChkDR( DRM_SHA_Update( (DRM_BYTE*)f_pbData, f_cbData, &shadata ) );
        ChkDR( DRM_SHA_Finalize( &shadata, DRM_SHA1_DIGEST_LEN, buffer ) ); 
    }


    if( !ecaffine_on_curve(pubkey, ecurve, NULL, NULL, pBigCtx) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( significant_digit_count(sigc,  pContext->pkData.lngr) == 0 
     && significant_digit_count(sigd,  pContext->pkData.lngr) != 0 )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( compare_same(sigc, pContext->pkData.r, pContext->pkData.lngr) >= 0 )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( compare_same(sigd, pContext->pkData.r, pContext->pkData.lngr) >= 0 )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }


    if( compare_immediate(gcd, 1, mp_gcdex(sigd, pContext->pkData.lngr, pContext->pkData.r, pContext->pkData.lngr, sigdinv, NULL, gcd, NULL, &lgcd, NULL, pBigCtx)) != 0 )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( !byte_array_mod_bignum(buffer, gcd, &pContext->pkData) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    multiply(sigdinv, pContext->pkData.lngr, gcd, pContext->pkData.lngr, h1G);      
    divide(h1G, 2*pContext->pkData.lngr, pContext->pkData.r, pContext->pkData.lngr, &(pContext->pkData.rrecip), NULL, gcd);
    
    if( !ecaffine_exponentiation_tabular(pContext->pkData.TABLE, TABLE_SPACING, TABLE_LAST, gcd, pContext->pkData.lngr, h1G, ecurve, pBigCtx) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    multiply(sigdinv, pContext->pkData.lngr, sigc, pContext->pkData.lngr, h2pubkey);
    divide(h2pubkey, 2*pContext->pkData.lngr, pContext->pkData.r, pContext->pkData.lngr, &(pContext->pkData.rrecip), NULL, gcd);

    if( !ecaffine_on_curve( pubkey, ecurve, NULL, NULL, pBigCtx) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( !ecaffine_exponentiation_tabular(pubkey, TABLE_SPACING, 0, gcd, pContext->pkData.lngr, h2pubkey, ecurve, pBigCtx ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    
    ecaffine_addition(h1G, h2pubkey, h1G, +1, ecurve, NULL, pBigCtx );
    
    if( ecaffine_is_infinite(h1G, ecurve, pBigCtx ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( !FE2IPmod(h1G, ecurve->fdesc, pContext->pkData.r, pContext->pkData.lngr, &(pContext->pkData.rrecip), gcd, pBigCtx ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    if( compare_same(sigc, gcd, pContext->pkData.lngr) != 0 )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

ErrorExit:
    PKUNLOCK;
    if( pContext )
    {
        if( sigdinv )
        {
            OEM_SECURE_ZERO_MEMORY( sigdinv, (SIZEOF( digit_t) * (2*LNGQ + 2*MP_LONGEST) ) + (SIZEOF(digit_t) * (2*2*MP_LONGEST + 2*LNGQ) ) + SIGN_BUF_LEN );
        }
        bignum_free( sigdinv, pBigCtx );
    }
    
#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
    DRM_PROFILING_LEAVE_SCOPE;
#endif
        
    return DRM_SUCCEEDED( dr );
} /* end ecvp_dsa */

DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL random_bytes(
    DRM_BYTE* byte_array, 
    const DRM_DWORD nbyte, 
    struct bigctx_t *f_pBigCtx )
{
    /*
    ** BIGNUM context is passed all around BIGNUM code.
    ** Convert to proper structure and get pOEMContext. 
    ** pOEMContext can be NULL on certain cases, for example in tools. It is set in Drm_Initialize
    ** If Drm_Initialize is called, then pBigNumCtx is present and pOEMContext also present.
    */

    DRMBIGNUM_CONTEXT_STRUCT *pBigNumCtx  = (DRMBIGNUM_CONTEXT_STRUCT *)f_pBigCtx;
    DRM_VOID                 *pOEMContext = NULL;

    DRMASSERT( pBigNumCtx != NULL );
    
    if ( pBigNumCtx != NULL )
    {
        pOEMContext = pBigNumCtx->pOEMContext;
    }

    if( DRM_SUCCEEDED( Oem_Random_GetBytes( pOEMContext, byte_array, (DRM_DWORD)nbyte ) ) )
    {
        return TRUE;
    }

    return FALSE;
}

 
DRM_API DRM_NO_INLINE DRM_VOID* DRM_CALL bignum_alloc(const DRM_DWORD cblen, struct bigctx_t *f_pBigCtx )
{
    DRM_VOID *pbRet = NULL;

    DRMASSERT(  f_pBigCtx != NULL );

    if (DRM_FAILED (DRM_STK_Alloc ((DRM_STACK_ALLOCATOR_CONTEXT*) f_pBigCtx, (DRM_DWORD)cblen, &pbRet)))
    {
        return NULL;
    }

    return pbRet;
}

DRM_API DRM_NO_INLINE DRM_VOID DRM_CALL bignum_free(DRM_VOID *pvMem, struct bigctx_t *f_pBigCtx)
{

    if ( pvMem != NULL &&  f_pBigCtx != NULL )
    {
        DRM_STK_Free( (DRM_STACK_ALLOCATOR_CONTEXT*) f_pBigCtx, pvMem );
    }
}
 
EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmembedding.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmembedding.h>

ENTER_PK_NAMESPACE_CODE;                     

/**********************************************************************
**
** Function:    _AddLicenseWithPriority
**
** Synopsis:    Adds a license to the license store with the priority.
**
** Arguments:
**
** [f_pLicStore]            -- License store to add the licens to.
** [f_pbLicenseBuffer]      -- Pointer to the license buffer containing the license.
** [f_cbLicenseBuffer]      -- Size of the license buffer.
** [f_cbLicense]            -- Size of the license in bytes.
** [f_pKID]                 -- Pointer to the KID for the license.
** [f_pLID]                 -- Pointer to the LID for the license.
** [f_dwPriority]           -- Specifies the license priority
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _AddLicenseWithPriority( 
    __in                                DRM_LICSTORE_CONTEXT *f_pLicStore, 
    __inout_bcount( f_cbLicenseBuffer ) DRM_BYTE             *f_pbLicenseBuffer, 
    __in                                DRM_DWORD             f_cbLicenseBuffer, 
    __in                                DRM_DWORD             f_cbLicense,
    __in                                DRM_KID              *f_pKID, 
    __in                                DRM_LID              *f_pLID,     
    __in                                DRM_DWORD             f_dwPriority )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkBOOL( f_cbLicense + SIZEOF( DRM_DWORD ) <= f_cbLicenseBuffer, DRM_E_OUTOFMEMORY );

    DRM_BYT_MoveBytes( f_pbLicenseBuffer,
                       SIZEOF( DRM_DWORD ),
                       f_pbLicenseBuffer,
                       0,
                       f_cbLicense );

    ChkDR( DRM_LST_AddLicense( f_pLicStore,
                               f_cbLicense,
                               f_pbLicenseBuffer,
                               f_pKID,
                               f_pLID,
                               f_dwPriority ) );

ErrorExit:
    return dr;
}

/**********************************************************************
**
** Function:    _CopyLicenseBetweenStores
**
** Synopsis:    Copies the specified license from one store into the second store.
**
** Arguments:
**
** [f_pLicStoreSource]      -- Source store for the license.
** [f_pLicStoreDest]        -- Destination store for the license.
** [f_pKID]                 -- Pointer to the KID for the license.
** [f_pLID]                 -- Pointer to the LID for the license.
** [f_pbLicenseBuffer]      -- Pointer to the license buffer.
** [f_cbLicenseBuffer]      -- Size of the license buffer.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _CopyLicenseBetweenStores( 
    __in                                DRM_LICSTORE_CONTEXT *f_pLicStoreSource, 
    __in                                DRM_LICSTORE_CONTEXT *f_pLicStoreDest, 
    __in                                DRM_KID              *f_pKID, 
    __in                                DRM_LID              *f_pLID, 
    __inout_bcount( f_cbLicenseBuffer ) DRM_BYTE             *f_pbLicenseBuffer, 
    __in                                DRM_DWORD             f_cbLicenseBuffer )
{
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_DWORD  cbLicense = f_cbLicenseBuffer - SIZEOF( DRM_DWORD );

    ChkDR( DRM_LST_GetLicense( f_pLicStoreSource,
                               f_pKID,
                               f_pLID,
                               NULL,
                               f_pbLicenseBuffer,
                              &cbLicense ) ); 

    ChkDR( _AddLicenseWithPriority( f_pLicStoreDest,
                                    f_pbLicenseBuffer,
                                    f_cbLicenseBuffer,
                                    cbLicense,
                                    f_pKID,
                                    f_pLID,
                                    0 ) );

ErrorExit:
    return dr;
}

/**********************************************************************
**
** Function:    _RetrieveAndUnpackLicense
**
** Synopsis:    Retrieves the specified license from the store and unpacks it.
**
** Arguments:
**
** [f_pLicStore]            -- License Store to retrieve the license from.
** [f_pKID]                 -- Pointer to the KID for the license.
** [f_pLID]                 -- Pointer to the LID for the license.
** [f_pSlotHint]            -- Pointer to a slot hint for the license (optional)
** [f_pbLicense]            -- Pointer to the license buffer.
** [f_cbLicenseBuffer]      -- Specifies the total length of the scratch buffer
** [f_pStack]               -- Pointer to the stack context
** [f_pcbLicense]           -- Returns the size of the license.
** [f_pXMRLicense]          -- Returns the unpacked XMR license
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _RetrieveAndUnpackLicense( 
    __in                                DRM_LICSTORE_CONTEXT        *f_pLicStore, 
    __in                                DRM_KID                     *f_pKID, 
    __in                                DRM_LID                     *f_pLID, 
    __in_opt                            DRM_DST_SLOT_HINT           *f_pSlotHint,
    __inout_bcount( f_cbLicenseBuffer ) DRM_BYTE                    *f_pbLicenseBuffer, 
    __in                                DRM_DWORD                    f_cbLicenseBuffer,
    __inout                             DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    __out                               DRM_DWORD                   *f_pcbLicense, 
    __out                               DRM_XMR_LICENSE             *f_pXMRLicense )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pcbLicense != NULL );

    *f_pcbLicense = f_cbLicenseBuffer;
    ChkDR( DRM_LST_GetLicense( f_pLicStore,
                               f_pKID,
                               f_pLID,
                               f_pSlotHint,
                               f_pbLicenseBuffer,
                               f_pcbLicense ) );

    f_pStack->pbStack = f_pbLicenseBuffer + __CB_DECL( *f_pcbLicense + SIZEOF( DRM_DWORD ) );
    f_pStack->cbStack = f_cbLicenseBuffer - ( *f_pcbLicense + SIZEOF( DRM_DWORD ) );
    f_pStack->nStackTop = 0;
    
    ChkDR( DRM_XMR_UnpackLicense( f_pbLicenseBuffer,
                                 *f_pcbLicense,
                                  f_pStack,
                                  f_pXMRLicense ) );
ErrorExit:
    return dr;
}
/**********************************************************************
**
** Function:    _IsLicenseValidForELS
**
** Synopsis:    Checks that the License has a Root and/or domain cert in the HDS if needed.
**
** Arguments:
**
** [f_pEmbeddedStore]         -- Embedded License Store to receive licenses.
** [f_pLicStore]              -- License Store to scan for licenses to embed. Must be the HDS XMR Store.
** [f_pDomainStore]           -- Domain store context.
** [f_pXMRLicense]            -- The unpacked XMR license
** [f_pfValidForELS]          -- Pointer to a BOOL to state if License is Valid. This value is undefined on function failure.
**
** Returns:
**      DRM_SUCCESS           -- No error occured, the License may not be valid for Embedding.
**      DRM_E_INVALID_ARG     -- f_pXMRLicense or f_pfValidForELS was NULL or a called function had an invalid arg.
**      other DRM Error codes
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _IsLicenseValidForELS( 
    __in                                DRM_LICSTORE_CONTEXT        *f_pEmbeddedStore, 
    __in                                DRM_LICSTORE_CONTEXT        *f_pLicStore, 
    __in                                DRM_DOMAINSTORE_CONTEXT     *f_pDomainStore,
    __inout                             DRM_XMR_LICENSE             *f_pXMRLicense,
    __inout                             DRM_BOOL                    *f_pfValidForELS )
{
    DRM_RESULT dr           = DRM_SUCCESS;
    DRM_DWORD  cbCert       = 0;   
    DRM_GUID   oScratchGuid = { 0 };    
    DRM_GUID   oAccountID   = { 0 };    

    DRM_LICSTOREENUM_CONTEXT oEnumHDS = { 0 };

    ChkArg( NULL != f_pfValidForELS );
    ChkArg( NULL != f_pXMRLicense   );


    if ( XMR_IS_EMBEDDING_BEHAVIOR_VALID( f_pXMRLicense )
       && ( f_pXMRLicense->containerOuter.containerGlobalPolicies.EmbeddingBehavior.wValue ==  XMR_EMBEDDING_BEHAVIOR_COPY
         || f_pXMRLicense->containerOuter.containerGlobalPolicies.EmbeddingBehavior.wValue ==  XMR_EMBEDDING_BEHAVIOR_MOVE ) )
    {
        *f_pfValidForELS = TRUE;
    }
    else
    {
        *f_pfValidForELS = FALSE;
        goto ErrorExit;
    }


    /*
    ** If the license is domain-bound, verify that there is a domain cert for it
    ** in the domain store
    */
    if ( XMR_IS_DOMAIN_ID_VALID( f_pXMRLicense ) )
    {                                   
        DRMASSERT( f_pXMRLicense->containerOuter.containerGlobalPolicies.DomainID.cbAccountID == SIZEOF( DRM_GUID ) );

        DRM_BYT_CopyBytes( &oAccountID, 
                            0,
                            f_pXMRLicense->containerOuter.containerGlobalPolicies.DomainID.pbAccountID,
                            f_pXMRLicense->containerOuter.containerGlobalPolicies.DomainID.ibAccountID,
                            SIZEOF( DRM_GUID ) );

        cbCert = 0;
        dr = DRM_DOMST_GetCert( f_pDomainStore,
                               &oAccountID,
                               &oScratchGuid,
                                NULL,
                               &cbCert );
        /*
        ** This is returned if there is a certificate for this domain
        */
        if ( dr == DRM_E_BUFFERTOOSMALL )
        {
            dr = DRM_SUCCESS;
        }
        /*
        ** This is returned if there is NO certificate for this domain
        */
        else if ( dr == DRM_E_DOMAIN_STORE_GET_DATA )
        {   
            *f_pfValidForELS = FALSE;
            dr = DRM_SUCCESS;
            goto ErrorExit;
        }
    }
    /*
    ** Otherwise, if it is a leaf license, verify that a root exists in the HDS
    */
    else if ( XMR_IS_UPLINK_KID_VALID( f_pXMRLicense ) )
    {                   
        DRM_BYT_CopyBytes( &oScratchGuid, 
                            0,
                            f_pXMRLicense->containerOuter.containerKeys.UplinkKid.pbguidUplinkKID,
                            f_pXMRLicense->containerOuter.containerKeys.UplinkKid.iguidUplinkKID,
                            SIZEOF( DRM_GUID ) );

        ChkDR( DRM_LST_InitEnum( f_pLicStore,
                                ( DRM_KID * )&oScratchGuid,
                                 FALSE,
                                &oEnumHDS ) );
        if ( oEnumHDS.eMode == eDRM_LICENSE_STORE_MODE_NONE )
        {
            *f_pfValidForELS = FALSE;
            goto ErrorExit;
        }
    }
    /* 
    ** If we get here then the license can be embedded. We set f_pfValidForELS to true above. 
    */

ErrorExit:
    return dr;
}


/**********************************************************************
**
** Function:    _DoLicenseBumpOff
**
** Synopsis:    Performs the following 'bump-off' algorithm on the embedded license store:
**              If there are pending licenses in the list, do -
**                  - Delete licenses belonging to domains we don't have a cert for
**                  - Delete licenses with lower priority than those in the list
**
** Arguments:
**
** [f_pEmbeddedStore]         -- Embedded License Store to receive licenses.
** [f_pLicStore]              -- License Store to scan for licenses to embed. Must be the HDS XMR Store.
** [f_pDomainStore]           -- Domain store context.
** [f_pKID]                   -- Pointer to the KID for the license.
** [f_pLID]                   -- Pointer to the LID for the license.
** [f_pPendingAddList]        -- Array of LIDs pending add to the ELS.
** [f_pdwPendingAddIssueDate] -- Array of priority values corresponding to f_pPendingAddList.
** [f_pcPendingAddList]       -- Element count of f_pPendingAddList and f_pdwPendingAddPri.
** [f_pbLicense]              -- Pointer to the license buffer.
** [f_cbLicense]              -- Size of the license buffer.
** [f_pSlotHint]              -- Pointer to a slot hint for the license (optional)
** [f_cbScratchBuffer]        -- Specifies the total length of the scratch buffer
** [f_pStack]                 -- Pointer to the stack context
** [f_pXMRLicense]            -- Returns the unpacked XMR license
** [f_pfModifiedEST]          -- Pointer to a BOOL to state if the f_pEmbeddedStore was modified.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _DoLicenseBumpOff( 
    __in                                DRM_LICSTORE_CONTEXT        *f_pEmbeddedStore, 
    __in                                DRM_LICSTORE_CONTEXT        *f_pLicStore, 
    __in                                DRM_DOMAINSTORE_CONTEXT     *f_pDomainStore,
    __in                                DRM_KID                     *f_pKID, 
    __in                                DRM_LID                     *f_pLID, 
    __in_ecount( f_cPendingAddList )    DRM_LID                     *f_pPendingAddList,
    __in_ecount( f_cPendingAddList )    DRM_DWORD                   *f_pdwPendingAddIssueDate,
    __in                                DRM_DWORD                    f_cPendingAddList,   
    __inout_bcount( f_cbScratchBuffer ) DRM_BYTE                    *f_pbScratchBuffer, 
    __in                                DRM_DWORD                    f_cbScratchBuffer, 
    __in_opt                            DRM_DST_SLOT_HINT           *f_pSlotHint,
    __inout                             DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    __inout                             DRM_XMR_LICENSE             *f_pXMRLicense,
    __inout                             DRM_BOOL                    *f_pfModifiedEST )
{
    DRM_RESULT dr           = DRM_SUCCESS;
    DRM_WORD   i            = 0;
    DRM_BOOL   fKeepGoing   = FALSE;
    DRM_BOOL   fDeleted     = FALSE;
    DRM_DWORD  cbLicense    = 0;
    DRM_BOOL   fValidForELS = FALSE;

    DRM_LICSTOREENUM_CONTEXT oEnumELS = { 0 };

    ChkArg( f_pfModifiedEST != NULL );
        
    if ( f_cPendingAddList == 0 )
    {
        goto ErrorExit;
    }
    
    /*
    ** Start enumerating embedded licenses
    */
    ChkDR( DRM_LST_InitEnum( f_pEmbeddedStore,
                             f_pKID,
                             FALSE, /* enumerate in KID-filtered mode */
                            &oEnumELS ) );
    dr = DRM_LST_EnumNext( &oEnumELS,
                           f_pKID,
                           f_pLID,                               
                           f_pSlotHint,
                          &cbLicense ); 
    if ( dr != DRM_E_NOMORE )
    {
        ChkDR( dr );
        fKeepGoing = TRUE;
    }
    while ( i < f_cPendingAddList && fKeepGoing )
    {
        /*
        ** Try to add the next license
        */            
        dr = _CopyLicenseBetweenStores( f_pLicStore, 
                                        f_pEmbeddedStore,
                                        f_pKID, 
                                       &f_pPendingAddList[i],
                                        f_pbScratchBuffer,
                                        f_cbScratchBuffer );

        /*
        ** If adding fails, enumerate ELS licenses until 
        ** one from a bogus domain is found or with a bogus ROOT, and delete
        ** If nomore is reached, then fKeepGoing = false
        */
        if ( dr == DRM_E_DSTSTOREFULL )
        {            
            fKeepGoing = TRUE;
            fDeleted   = FALSE;

            while ( !fDeleted && fKeepGoing )
            {
                ChkDR( _RetrieveAndUnpackLicense( f_pEmbeddedStore, 
                                                  f_pKID,
                                                  f_pLID,
                                                  f_pSlotHint,
                                                  f_pbScratchBuffer,
                                                  f_cbScratchBuffer,                                                 
                                                  f_pStack,
                                                 &cbLicense,
                                                  f_pXMRLicense ) );

                /*
                ** Check to see if we should remove the license from the ELS
                */
                ChkDR( _IsLicenseValidForELS( f_pEmbeddedStore,
                                              f_pLicStore,
                                              f_pDomainStore,
                                              f_pXMRLicense,
                                             &fValidForELS ) );

                if( !fValidForELS )
                { 
                    ChkDR( DRM_LST_EnumDelete( &oEnumELS ) );
                   *f_pfModifiedEST = TRUE;
                    fDeleted = TRUE;
                }
                dr = DRM_LST_EnumNext( &oEnumELS,
                                        f_pKID,
                                        f_pLID,
                                        f_pSlotHint,
                                       &cbLicense );

                /*
                ** Did not delete license, move to next license
                */
                if ( dr == DRM_E_NOMORE )
                {                    
                    dr = DRM_SUCCESS;                        
                    fKeepGoing = fDeleted;
                }
                else
                {
                    ChkDR( dr );
                }                
            }
        }
        else
        {                
            ChkDR( dr );
            *f_pfModifiedEST = TRUE;
            i++;
        }        
    }
    for ( ; i < f_cPendingAddList; i++ )
    {
        DRM_DWORD dwIssueDateThreshhold = f_pdwPendingAddIssueDate[i];

        /*
        ** Remove the oldest license from the ELS 
        */
        ChkDR( DRM_LST_InitEnum( f_pEmbeddedStore,
                                 f_pKID,
                                 FALSE,
                                &oEnumELS ) );

        fKeepGoing = TRUE;
        while ( fKeepGoing )
        {                    
            dr = DRM_LST_EnumNext( &oEnumELS,
                                    f_pKID,
                                    f_pLID,                               
                                    f_pSlotHint,
                                   &cbLicense );
            if ( dr == DRM_E_NOMORE )
            {
                dr = DRM_SUCCESS;
                fKeepGoing = FALSE;
            }
            else
            {
                ChkDR( dr );
                ChkDR( _RetrieveAndUnpackLicense( f_pEmbeddedStore, 
                                                  f_pKID,
                                                  f_pLID,
                                                  f_pSlotHint,
                                                  f_pbScratchBuffer,                                                 
                                                  f_cbScratchBuffer,
                                                  f_pStack,
                                                 &cbLicense,
                                                  f_pXMRLicense ) );
                
                /*
                ** If the license is below the IssueDate threshhold, or it doesn't have one, move it into the HDS.
                */
                if ( !XMR_IS_ISSUEDATE_VALID( f_pXMRLicense )
                  || dwIssueDateThreshhold > f_pXMRLicense->containerOuter.containerGlobalPolicies.IssueDate.dwValue )
                {
                    /*
                    ** Copy to HDS, then delete from ELS
                    */
                    dr = _CopyLicenseBetweenStores( f_pEmbeddedStore,
                                                    f_pLicStore,
                                                    f_pKID, 
                                                    f_pLID, 
                                                    f_pbScratchBuffer,                                                 
                                                    f_cbScratchBuffer );                    
                    if ( dr != DRM_E_DUPLICATE_LICENSE )
                    {                            
                        ChkDR( dr );
                    }
                    ChkDR( DRM_LST_EnumDelete( &oEnumELS ) );   
                    fKeepGoing = TRUE;
                    *f_pfModifiedEST = TRUE;

                    /*
                    ** Try to add the next license
                    */            
                    dr = _CopyLicenseBetweenStores( f_pLicStore, 
                                                    f_pEmbeddedStore,
                                                    f_pKID, 
                                                   &f_pPendingAddList[i], 
                                                    f_pbScratchBuffer,                                                 
                                                    f_cbScratchBuffer );
                    if ( dr == DRM_E_DSTSTOREFULL )
                    {
                        dr = DRM_SUCCESS;
                    }
                    else
                    {
                        ChkDR( dr );
                        fKeepGoing = FALSE;
                    }
                }
            }
        }
    }
ErrorExit:
    return dr;
}
   
                         
                                  
/**********************************************************************
**
** Function:    DRM_EMB_UpdateEmbeddedStore
**
** Synopsis:    Searches for suitable licenses in the HDS and embeds
**              them, if found, into the Embedded Store.
**
** Arguments:
**
** [f_pEmbeddedStore]       -- Embedded License Store to receive licenses.
** [f_pLicStore]            -- License Store to scan for licenses to embed. Must be the HDS XMR Store.
** [f_poDomainStoreContext] -- Domain store context.
** [f_pLicEvalBackup]       -- Initialized LicEval Context to use to setup and reset the eval buffer.
** [f_rgbLicEvalBuffer]     -- Empty buffer large enough for a liceval context. This will be churned during embedding.
** [f_pbScratchBuffer]      -- Generic scratch buffer for use with the Stack Allocator context.
** [f_pcbScratchBuffer]     -- Size of the Scratch buffer. Receives the needed size if the buffer is too small.
** [f_poKID]                -- Pointer to the KID for which to embed licenses.
** [f_pfModifiedEST]        -- Pointer to a BOOL to state if the f_pEmbeddedStore was modified.
**
** Returns:                 DRM_SUCCESS          - No error occurred.
**                          DRM_E_INVALIDARG     - An argument is invalid or improperly initialized.
**                          DRM_E_BUFFERTOOSMALL - Returned if the scratch buffer is too small.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EMB_UpdateEmbeddedStore(
    __in                                                       DRM_LICSTORE_CONTEXT    *f_pEmbeddedStore,
    __in                                                       DRM_LICSTORE_CONTEXT    *f_pLicStore,
    __in                                                       DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    __in const                                                 DRM_LICEVAL_CONTEXT     *f_pLicEvalBackup,
    __in_bcount( __CB_DECL( SIZEOF( DRM_LICEVAL_CONTEXT ) ) )  DRM_BYTE                 f_rgbLicEvalBuffer[ ],
    __in_bcount( *f_pcbScratchBuffer )                         DRM_BYTE                *f_pbScratchBuffer,
    __inout                                                    DRM_DWORD               *f_pcbScratchBuffer,
    __in                                                       DRM_KID                 *f_poKID,
    __out                                                      DRM_BOOL                *f_pfModifiedEST
 )
{ 
#define MAX_EMBEDDED_BUMPOFF 20 /* Maximum # of licenses that can be 'bumped off' */
    DRM_RESULT                        dr                                            = DRM_SUCCESS;
    DRM_BOOL                          fDeleteLicense                                = FALSE;
    DRM_BOOL                          fSecStoreLicOpen                              = FALSE;
    DRM_BOOL                          fRepeatLID                                    = FALSE;
    DRM_KID                           oKID                                          = { 0 };
    DRM_LID                           oLID                                          = { 0 };
    DRM_LID                           oLIDLast                                      = { 0 };
    DRM_DST_SLOT_HINT                 oSlotHint                                     = { 0 };   
    DRM_DWORD                         cbLicense                                     = 0;
    DRM_STACK_ALLOCATOR_CONTEXT       oStack                                        = { 0 };
    DRM_LICSTORE_CONTEXT             *rgpLicStores[2]                               = { NULL }; 
    DRM_DWORD                         cLicStores                                    = 0;
    DRM_LICSTORE_CONTEXT             *pLicStore                                     = NULL;
    DRM_LICEVAL_CONTEXT              *pLicEval                                      = NULL;
    DRM_XMR_LICENSE                   oLicenseXMR                                   = { 0 };
    DRM_LICSTOREENUM_MULTIPLE_CONTEXT oLicEnumMultiple                              = { 0 };
    DRM_LID                           oPendingAddList[MAX_EMBEDDED_BUMPOFF]         = { 0 };
    DRM_DWORD                         rgdwPendingAddIssueDate[MAX_EMBEDDED_BUMPOFF] = { 0 };
    DRM_WORD                          cPendingAddList                               = 0;
    DRM_DWORD                         cbLicenseTemp                                 = 0;


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMEMB, PERF_FUNC_DRM_EMB_UpdateEmbeddedStore );

    ChkArg( NULL != f_pEmbeddedStore );
    ChkArg( NULL != f_pLicStore );
    ChkArg( NULL != f_pLicEvalBackup );
    ChkArg( NULL != f_poDomainStoreContext );
    ChkArg( NULL != f_poKID );
    ChkArg( NULL != f_pcbScratchBuffer );
    
    if ( *f_pcbScratchBuffer < DRM_MAX_LICENSESIZE + SIZEOF( DRM_DWORD ) )
    {
        *f_pcbScratchBuffer = DRM_MAX_LICENSESIZE + SIZEOF( DRM_DWORD );
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }
    
    /*
    ** Use an internal temporary LicEval Buffer
    */
    pLicEval = ( DRM_LICEVAL_CONTEXT * ) f_rgbLicEvalBuffer;

    /*
    ** Ensure that we are not trying to embed licenses from the xml or temp stores
    */    
    ChkArg( f_pLicStore->eType == eDRM_LICENSE_STORE_XMR );

    /*
    ** Set up enumeration over embedded store and HDS (XMR) store
    */
    rgpLicStores[cLicStores++] = f_pEmbeddedStore;
    rgpLicStores[cLicStores++] = f_pLicStore;

    /*
    ** Search for a suitable license for this KID
    */
    ChkDR( DRM_LST_InitEnumMultiple( rgpLicStores,
                                     cLicStores,
                                     f_poKID,
                                     TRUE,
                                    &oLicEnumMultiple ) );
           
    while ( TRUE )
    {
        DRM_BYTE rgbSSTPassword[ __CB_DECL( DRM_SHA1_DIGEST_LEN ) ] = { 0 };
        
        MEMCPY( &oLIDLast, &oLID, SIZEOF( DRM_LID ) );
        dr = DRM_LST_EnumNextMultiple( &oLicEnumMultiple,
                                       &oKID,
                                       &oLID,
                                       &pLicStore,
                                       &oSlotHint,
                                       &cbLicense );        
        
        /*
        ** If no more licenses are found
        */
        if ( dr == DRM_E_NOMORE )
        {
            dr = DRM_SUCCESS;
            break;
        }                
        ChkDR( dr );        

        /*
        ** Check for licenses with copies in both stores,
        ** as they require less processing
        */
        fRepeatLID = ( MEMCMP( &oLIDLast, &oLID, SIZEOF( DRM_LID ) ) == 0 );
        
        if ( cbLicense > *f_pcbScratchBuffer )
        {
            *f_pcbScratchBuffer += cbLicense;
            ChkDR( DRM_E_BUFFERTOOSMALL );
        }

        ChkDR( _RetrieveAndUnpackLicense( pLicStore,
                                         &oKID,
                                         &oLID,
                                         &oSlotHint,
                                          f_pbScratchBuffer,                                          
                                         *f_pcbScratchBuffer,
                                         &oStack,
                                         &cbLicense,
                                         &oLicenseXMR ) );

        /*
        ** Delete any expired licenses found
        */

        if ( fSecStoreLicOpen )
        {
            fSecStoreLicOpen = FALSE;
            ZEROMEM(  pLicEval->pcontextSSTLicense,
                  SIZEOF(  DRM_SECSTORE_CONTEXT ) );
        }

        /*
        ** Reset the LicEval Object with the backup one.
        */
        MEMCPY( f_rgbLicEvalBuffer, f_pLicEvalBackup, SIZEOF( DRM_LICEVAL_CONTEXT ) );
        
        /*
        ** Clear and set some liceval information
        */
#if DRM_SUPPORT_REVOCATION
        if( pLicEval->cbRevocationBuffer > 0 )
        {
            ZEROMEM( pLicEval->pbRevocationBuffer, pLicEval->cbRevocationBuffer );
        }
#endif /* DRM_SUPPORT_REVOCATION */
        pLicEval->dwFlags = LICEVAL_VERIFY_IGNORE_VERIFICATION;
        pLicEval->fLicenseIsXMR = TRUE;
        pLicEval->plicenseXMR   = &oLicenseXMR;
        
        /*
        ** Talk to blackbox to get the secure store password for this license
        */
        ChkDR( DRM_SST_CreateLicenseStatePassword( &oLID,
                                                    rgbSSTPassword,
                                                    pLicEval->pcontextBBX ) );

        ChkDR( DRM_SST_OpenKeyTokens(  pLicEval->pcontextSSTLicense,
                                      &oLID,
                                       NULL,
                                       rgbSSTPassword,
                                       0,
                                       SECURE_STORE_LICENSE_DATA,
                                       f_pLicStore->pDatastore ) );
        fSecStoreLicOpen = TRUE;
    
        /*
        ** Check for deletion
        */
        ChkDR( DRM_LEVL_IsLicenseReadyForDeletion( pLicEval,
                                                  &fDeleteLicense ) );
        if ( fDeleteLicense )
        {
            ChkDR( DRM_LST_EnumDeleteMultiple( &oLicEnumMultiple ) );

            /*
            ** Set fModifiedEST to TRUE if a license was deleted from the EST.
            */
            if ( pLicStore == f_pEmbeddedStore )
            {
                *f_pfModifiedEST = TRUE;
            }
        }
        /*
        ** If it is an HDS license, verify that it is embeddable, then embed,
        ** if there is room in the EST.
        */
        else if ( pLicStore == f_pLicStore && !fRepeatLID )
        {   
            DRM_BOOL fShouldEmbed = FALSE;
            /*
            ** Check whether this license is 'embeddable'
            */
            ChkDR( _IsLicenseValidForELS( f_pEmbeddedStore,
                                          f_pLicStore,
                                          f_poDomainStoreContext,
                                          &oLicenseXMR,
                                          &fShouldEmbed ) );


            if ( fShouldEmbed )
            {                
                /*
                ** Make sure this is not a duplicate license
                */
                cbLicenseTemp = 0;
                dr = DRM_LST_GetLicense( f_pEmbeddedStore,
                                        &oKID,
                                        &oLID,
                                         NULL,
                                         NULL,
                                        &cbLicenseTemp );

                /*
                ** Found a license, so skip adding it again
                */
                if ( dr == DRM_E_BUFFERTOOSMALL )
                {
                    dr = DRM_SUCCESS;
                }
                else if ( dr != DRM_E_DSTSLOTNOTFOUND )
                {
                    ChkDR( dr );
                }
                else
                {
	                /*
	                ** Embed the license
	                */
                    dr = _AddLicenseWithPriority( f_pEmbeddedStore,
                                                  f_pbScratchBuffer,
                                                 *f_pcbScratchBuffer,
                                                  cbLicense,
                                                 &oKID,
                                                 &oLID,
                                                  0 );
                                                  
                    /*
                    ** If the store is full, add this license to the 'to add' list
                    */
                    if ( dr == DRM_E_DSTSTOREFULL )
                    {                            
                        if ( cPendingAddList < MAX_EMBEDDED_BUMPOFF )
                        {
                            MEMCPY( &oPendingAddList[cPendingAddList], &oLID, SIZEOF( DRM_LID ) );
                            if( XMR_IS_ISSUEDATE_VALID( &oLicenseXMR ) )
                            {
                                rgdwPendingAddIssueDate[cPendingAddList] = oLicenseXMR.containerOuter.containerGlobalPolicies.IssueDate.dwValue;
                            }
                            else
                            {
                                rgdwPendingAddIssueDate[cPendingAddList] = 0;
                            }
                            cPendingAddList++;
                        }
                        dr = DRM_SUCCESS;
                    } 
                    else
                    {
                        ChkDR( dr );
                        *f_pfModifiedEST = TRUE;
                    }
                }
            }
        }
        /*
        ** Do nothing for licenses which are already embedded and are not expired
        */
    } 

    /*
    ** Licenses were pending add but the store was full
    */
    if ( cPendingAddList > 0 )
    {
        ChkDR( _DoLicenseBumpOff( f_pEmbeddedStore,
                                  f_pLicStore,
                                  f_poDomainStoreContext,
                                 &oKID, 
                                 &oLID,
                                  oPendingAddList,
                                  rgdwPendingAddIssueDate,
                                  cPendingAddList,
                                  f_pbScratchBuffer,
                                 *f_pcbScratchBuffer,
                                 &oSlotHint,                                  
                                 &oStack,
                                 &oLicenseXMR,
                                  f_pfModifiedEST ) );
    }                                  
ErrorExit:
    if ( fSecStoreLicOpen )
    {
        ZEROMEM( pLicEval->pcontextSSTLicense, SIZEOF(  DRM_SECSTORE_CONTEXT ) );
    }
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
#undef MAX_EMBEDDED_BUMPOFF
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmembeddedstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <byteorder.h>
#include <drmembeddedstore.h>
#include <drmembeddedstore_impl.h>

ENTER_PK_NAMESPACE_CODE;

/*
** Embedded store header constants
*/
#define DRM_EST_MINIMUM_VERSION  1     /* Lowest valid version for the embedded store format */
#define DRM_EST_CURRENT_VERSION  1     /* Current version of the embedded store format. */
#define DRM_EST_HEADER_CONST     "EST" /* Constant which must begin the EST buffer. */
#define DRM_EST_HEADER_CONST_LEN 4     /* Length of DRM_EST_HEADER_CONST in bytes. */
#define DRM_EST_HEADER_LEN       ( 2 * SIZEOF( DRM_WORD ) + SIZEOF( DRM_DWORD ) + DRM_EST_HEADER_CONST_LEN )

/*
** Embedded store slot constants
*/
#define DRM_EST_SLOTHEADER_LEN  ( SIZEOF( DRM_DWORD ) + 2 * SIZEOF( DRM_DST_KEY ) )

#define BYTES_PER_DWORD      SIZEOF( DRM_DWORD )
#define PAD_AMOUNT(x)        ( ( (x) > 0 ) ? ( ( BYTES_PER_DWORD - ( (x) % BYTES_PER_DWORD ) ) % BYTES_PER_DWORD ) : 0 )
#define PADDED_LEN(x)   ((x) + PAD_AMOUNT(x))
/* Static functions. */

/**********************************************************************
**
** Function :   _EST_PrepareUnusedBuffer
**
** Synopsis :   Function that initializes two EST context fields that manage
**              a buffer at the end of the buffer available for new slots.
**              The two fields are m_ibUnused and m_cbUnused.
**
** Arguments :
** [f_pESTContext]       : Pointer to an EST context.
**
** Returns :
**      DRM_SUCCESS      - Success.
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _EST_PrepareUnusedBuffer(
    __in DRM_EST_CONTEXT *f_pContextEST )
{
    DRM_RESULT dr             = DRM_SUCCESS;
    DRM_DWORD ibCur           = DRM_EST_HEADER_LEN;
    DRM_DWORD cbSlot          = 0;
    DRM_BOOL fFound = FALSE;

    ChkArg( f_pContextEST != NULL );

    /* Search for the a slot with the first DWORD as 0. */
    while ( ibCur < f_pContextEST->m_cbEmbeddedStore )
    {
        NETWORKBYTES_TO_DWORD( cbSlot, f_pContextEST->m_pbEmbeddedStore, ibCur );

        if ( cbSlot == 0 )
        {
            /* A 0 size slot indicates the start of the unused buffer. */
            f_pContextEST->m_ibUnused = ibCur;
            f_pContextEST->m_cbUnused = f_pContextEST->m_cbEmbeddedStore - ibCur;

            fFound = TRUE;
            break;
        }
        else
        {
            ChkBOOL( cbSlot <= MAX_EMBEDDED_STORE_LEN, DRM_E_DSTCORRUPTED );
            ChkBOOL( cbSlot > DRM_EST_SLOTHEADER_LEN, DRM_E_DSTCORRUPTED );
            /*
            ** In case cbSlot is corrupt and very large, we don't want to integer overflow
            ** So we use subtraction (A<=B-C) instead of addition (A+C<=B).
            ** We know we won't UNDERFLOW in subtraction because we verified B>C above.
            */
            ChkBOOL( PADDED_LEN(cbSlot) >= cbSlot, DRM_E_DSTCORRUPTED );
            ChkBOOL( PADDED_LEN(cbSlot) <= f_pContextEST->m_cbEmbeddedStore - ibCur, DRM_E_DSTCORRUPTED );

            ibCur += PADDED_LEN(cbSlot) ;
        }
    }

    if ( !fFound )
    {
        /* The whole EST buffer has already been used. */
        f_pContextEST->m_ibUnused = f_pContextEST->m_cbEmbeddedStore;
        f_pContextEST->m_cbUnused = 0;
    }

ErrorExit:

    return dr;
}

/**********************************************************************
**
** Function :   _EST_PrepareSlotToBeReturned
**
** Synopsis :   Funtion that fills fields of the passed in EST slot context
**              with information of a cached EST slot. Other optional output
**              parameters are filled by the function.
**
** Arguments :
** [f_pESTNSContext]     : Pointer to an EST namespace context.
** [f_pESTContext]       : Pointer to an EST context.
** [f_pSlotHint]         : Pointer to an EST slot hint.
** [f_eLockMode]         : Lock mode of the slot.
** [f_pESTSlotContext]   : Pointer to an EST slot context to be filled.
** [f_pKey1]             : Pointer to an optional buffer to receive the
**                         primary key of the cached EST slot.
** [f_pKey2]             : Pointer to an optional buffer to receive the
**                         secondary key of the cached EST slot.
** [f_pcbSize]           : Pointer to an optional variable to receive the
**                         size of the cached EST slot (no padding)
**
** Returns :
**      DRM_SUCCESS      - Success.
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _EST_PrepareSlotToBeReturned(
    __in       DRM_EST_NAMESPACE_CONTEXT *f_pESTNSContext,
    __in       DRM_EST_CONTEXT           *f_pESTContext,
    __in       DRM_EST_SLOT_HINT         *f_pSlotHint,
    __in       DRM_DST_LOCKMODE           f_eLockMode,
    __out      DRM_EST_SLOT_CONTEXT      *f_pESTSlotContext,
    __out_opt  DRM_DST_KEY               *f_pKey1,
    __out_opt  DRM_DST_KEY               *f_pKey2,
    __out_opt  DRM_DWORD                 *f_pcbSize )
{
    DRM_RESULT dr             = DRM_SUCCESS;
    DRM_DWORD ibCur           = DRM_EST_HEADER_LEN;
    DRM_DWORD cbSlot          = 0;

    ChkArg( f_pESTNSContext != NULL );
    ChkArg( f_pESTContext != NULL );
    ChkArg( f_pSlotHint != NULL );
    ChkArg( f_pESTSlotContext != NULL );

    DRMASSERT( f_pSlotHint->m_ibOffset >= DRM_EST_HEADER_LEN );
    DRMASSERT( f_pSlotHint->m_cbSlotLen > DRM_EST_SLOTHEADER_LEN );
    DRMASSERT( f_pSlotHint->m_ibOffset +
               PADDED_LEN(f_pSlotHint->m_cbSlotLen) <= f_pESTContext->m_ibUnused );

    ZEROMEM( f_pESTSlotContext, SIZEOF( DRM_EST_SLOT_CONTEXT ) );

    ibCur = f_pSlotHint->m_ibOffset;
    cbSlot = f_pSlotHint->m_cbSlotLen;

    ChkArg( ibCur >= DRM_EST_HEADER_LEN && ibCur < f_pESTContext->m_ibUnused );
    /*
    ** In case cbSlot is corrupt and very large, we don't want to integer overflow
    ** So we use subtraction (A<=B-C) instead of addition (A+C<=B).
    ** We know we won't UNDERFLOW in subtraction because we verified B>C above.
    */
    ChkBOOL( PADDED_LEN(cbSlot) >= cbSlot, DRM_E_DSTCORRUPTED );
    ChkArg( PADDED_LEN(cbSlot) <= f_pESTContext->m_ibUnused - ibCur );

    /* Skip the slot length field. */
    ibCur += SIZEOF( DRM_DWORD );

    /* Copy the primary key of the cached slot. */
    DRM_BYT_CopyBytes( ( DRM_BYTE * )&f_pESTSlotContext->m_oKey1,
                       0,
                       f_pESTContext->m_pbEmbeddedStore,
                       ibCur,
                       SIZEOF( DRM_DST_KEY ) );
    ibCur += SIZEOF( DRM_DST_KEY );

    /* Copy the secondary key of the cached slot. */
    DRM_BYT_CopyBytes( ( DRM_BYTE * )&f_pESTSlotContext->m_oKey2,
                       0,
                       f_pESTContext->m_pbEmbeddedStore,
                       ibCur,
                       SIZEOF( DRM_DST_KEY ) );
    ibCur += SIZEOF( DRM_DST_KEY );

    /* All locks are shared until locking is implemented fully. */
    f_pESTSlotContext->m_eLockmode = eDRM_DST_LOCKSHARED;

    MEMCPY( ( DRM_BYTE * )&f_pESTSlotContext->m_oSlotLocation,
            ( DRM_BYTE * )f_pSlotHint,
            SIZEOF( DRM_EST_SLOT_HINT ) );

    f_pESTSlotContext->m_eLockmode = f_eLockMode;
    f_pESTSlotContext->m_fSlotOpen = TRUE;
    f_pESTSlotContext->m_poESTNSContext = f_pESTNSContext;

    /* Copy information to the optional output parameters. */
    if ( f_pKey1 != NULL )
    {
        MEMCPY( ( DRM_BYTE * )f_pKey1,
                ( DRM_BYTE * )&f_pESTSlotContext->m_oKey1,
                SIZEOF( DRM_DST_KEY ) );
    }

    if ( f_pKey2 != NULL )
    {
        MEMCPY( ( DRM_BYTE * )f_pKey2,
                ( DRM_BYTE * )&f_pESTSlotContext->m_oKey2,
                SIZEOF( DRM_DST_KEY ) );
    }

    if ( f_pcbSize != NULL )
    {
        *f_pcbSize = f_pESTSlotContext->m_oSlotLocation.m_cbSlotLen -
                     DRM_EST_SLOTHEADER_LEN;
    }

ErrorExit:

    return dr;
}

/**********************************************************************
**
** Function :   _EST_OpenSlot
**
** Synopsis :   Attempts to open an existing slot.
**
** Arguments :
**      [f_pContextEST]  : Specifies the EST context.
**      [f_dwMode]       : Specifies the mode (only lock mode is used)
**      [f_pKey1]        : Specifies the optional primary key of the slot to open.
**      [f_pKey2]        : Specifies the optional secondary key of the slot to open.
**      [f_pSlotHint]    : Optional. Contains a slot hint for the slot to open.
**                         Not used here.
**      [f_pContextSlot] : Returns the slot context.
**
** Returns :
**      DRM_SUCCESS      - Success.
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _EST_OpenSlot(
    __in           DRM_EST_CONTEXT           *f_pContextEST,
    __in           DRM_DWORD                  f_dwMode,
    __in_opt const DRM_DST_KEY               *f_pKey1,
    __in_opt const DRM_DST_KEY               *f_pKey2,
    __in_opt       DRM_EST_SLOT_HINT         *f_pSlotHint,
    __out          DRM_EST_SLOT_CONTEXT      *f_pContextSlot )
{
    DRM_RESULT dr             = DRM_SUCCESS;
    DRM_DWORD ibCur           = DRM_EST_HEADER_LEN;
    DRM_DWORD cbSlot          = 0;
    DRM_BOOL fFound           = FALSE;

    ChkArg( f_pContextEST != NULL );
    ChkArg( f_pContextSlot != NULL );

    /* Search all slots ahead of the unused buffer. */
    while ( ibCur < f_pContextEST->m_ibUnused )
    {
        NETWORKBYTES_TO_DWORD( cbSlot, f_pContextEST->m_pbEmbeddedStore, ibCur );
        ChkBOOL( cbSlot <= MAX_EMBEDDED_STORE_LEN, DRM_E_DSTCORRUPTED );
        ChkBOOL( cbSlot > DRM_EST_SLOTHEADER_LEN, DRM_E_DSTCORRUPTED );
        /*
        ** In case cbSlot is corrupt and very large, we don't want to integer overflow
        ** So we use subtraction (A<=B-C) instead of addition (A+C<=B).
        ** We know we won't UNDERFLOW in subtraction because we verified B>C above.
        */
        ChkBOOL( PADDED_LEN(cbSlot) >= cbSlot, DRM_E_DSTCORRUPTED );
        ChkBOOL( PADDED_LEN(cbSlot) <= f_pContextEST->m_ibUnused - ibCur, DRM_E_DSTCORRUPTED );

        ibCur += SIZEOF( DRM_DWORD );

        if ( f_pKey1 != NULL )
        {
            /*
            ** If the passed in primary key is not NULL, check it against
            ** the current slot being examined.
            */
            if ( DRM_BYT_CompareBytes( f_pContextEST->m_pbEmbeddedStore,
                                       ibCur,
                                       ( DRM_BYTE * )f_pKey1,
                                       0,
                                       SIZEOF( DRM_DST_KEY ) ) != 0 )
            {
                /* Skip the two keys. */
                ibCur += 2 * SIZEOF( DRM_DST_KEY );

                /* Skip the data portion of the slot. */
                ChkBOOL( PADDED_LEN(cbSlot) >= cbSlot, DRM_E_DSTCORRUPTED );
                ibCur += ( PADDED_LEN(cbSlot) - DRM_EST_SLOTHEADER_LEN );

                continue;
            }
        }

        /* Cache the primary key of the slot being examined. */
        DRM_BYT_CopyBytes( ( DRM_BYTE * )&f_pContextSlot->m_oKey1,
                           0,
                           f_pContextEST->m_pbEmbeddedStore,
                           ibCur,
                           SIZEOF( DRM_DST_KEY ) );

        /* Skip the primary key. */
        ibCur += SIZEOF( DRM_DST_KEY );

        if ( f_pKey2 != NULL )
        {
            /*
            ** If the passed in secondary key is not NULL, check it against
            ** the current slot being examined.
            */
            if ( DRM_BYT_CompareBytes( f_pContextEST->m_pbEmbeddedStore,
                                       ibCur,
                                       ( DRM_BYTE * )f_pKey2,
                                       0,
                                       SIZEOF( DRM_DST_KEY ) ) != 0 )
            {
                /* Skip the secondary key. */
                ibCur += SIZEOF( DRM_DST_KEY );

                /* Skip the data portion of the slot. */
                ChkBOOL( PADDED_LEN(cbSlot) >= cbSlot, DRM_E_DSTCORRUPTED );
                ibCur += ( PADDED_LEN(cbSlot) - DRM_EST_SLOTHEADER_LEN );

                continue;
            }
        }

        /* Cache the secondary key of the slot being examined. */
        DRM_BYT_CopyBytes( ( DRM_BYTE * )&f_pContextSlot->m_oKey2,
                           0,
                           f_pContextEST->m_pbEmbeddedStore,
                           ibCur,
                           SIZEOF( DRM_DST_KEY ) );

        /* Skip the secondary key. */
        ibCur += SIZEOF( DRM_DST_KEY );

        fFound = TRUE;
        break;
    }

    if ( fFound )
    {
        /* Found the requested slot. Copy data into the slot context. */

        /* All locks are shared until locking is implemented fully */
        f_pContextSlot->m_eLockmode = eDRM_DST_LOCKSHARED;

        /* Write the location (starting index and size) of the slot within the overall EST buffer. */
        f_pContextSlot->m_oSlotLocation.m_ibOffset = ibCur - DRM_EST_SLOTHEADER_LEN;
        f_pContextSlot->m_oSlotLocation.m_cbSlotLen = cbSlot;

        f_pContextSlot->m_fSlotOpen = TRUE;
    }
    else
    {
        ChkDR( DRM_E_DSTSLOTNOTFOUND );
    }

ErrorExit:

    return dr;
}

/**********************************************************************
**
** Function :   _EST_CreateSlot
**
** Synopsis :   Attempts to create a new slot.
**
** Arguments :
**      [f_pContextEST]  : Specifies the EST context.
**      [f_dwMode]       : Specifies the mode (only lock mode is used)
**      [f_pKey1]        : Specifies the first key of the slot to create.
**      [f_pKey2]        : Specifies the second key of the slot to create.
**      [f_pcbSize]      : Specifies the desired size for the slot.
**      [f_pContextSlot] : Returns the slot context.
**
** Returns :
**      DRM_SUCCESS      - Success.
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _EST_CreateSlot(
    __in        DRM_EST_CONTEXT           *f_pContextEST,
    __in        DRM_DWORD                  f_dwMode,
    __in const  DRM_DST_KEY               *f_pKey1,
    __in const  DRM_DST_KEY               *f_pKey2,
    __inout_opt DRM_DWORD                 *f_pcbSize,
    __out       DRM_EST_SLOT_CONTEXT      *f_pContextSlot )
{
    DRM_RESULT dr             = DRM_SUCCESS;
    DRM_DWORD ibCur           = 0;
    DRM_DWORD cbSlot          = 0;

    ChkArg( f_pContextEST != NULL );
    ChkArg( f_pKey1 != NULL );
    ChkArg( f_pKey2 != NULL );
    ChkArg( f_pcbSize != NULL );
    ChkArg( *f_pcbSize > 0 );
    ChkArg( f_pContextSlot != NULL );

    /*
    ** The size of the unused EST buffer should be big enough to hold the requested slot size plus
    ** a fixed slot header.
    */
    ChkOverflow( PADDED_LEN(*f_pcbSize), *f_pcbSize );
    ChkOverflow( PADDED_LEN(*f_pcbSize) + DRM_EST_SLOTHEADER_LEN, PADDED_LEN(*f_pcbSize) );
    ChkBOOL( f_pContextEST->m_cbUnused >=
             PADDED_LEN(*f_pcbSize) + DRM_EST_SLOTHEADER_LEN, DRM_E_DSTSTOREFULL );

    ibCur = f_pContextEST->m_ibUnused;
    cbSlot = *f_pcbSize + DRM_EST_SLOTHEADER_LEN;

    /* Initialize the underlying buffer of the whole slot to 0, padding bytes included. */
    ChkBOOL( PADDED_LEN(cbSlot) >= cbSlot, DRM_E_DSTCORRUPTED );
    DRM_BYT_SetBytes( f_pContextEST->m_pbEmbeddedStore, ibCur, PADDED_LEN(cbSlot), 0 );

    /* Write the length of the slot. */
    DWORD_TO_NETWORKBYTES( f_pContextEST->m_pbEmbeddedStore, ibCur, cbSlot );
    ibCur += SIZEOF( DRM_DWORD );

    /* Write the primary key of the slot. */
    DRM_BYT_CopyBytes( f_pContextEST->m_pbEmbeddedStore,
                       ibCur,
                       ( DRM_BYTE * )f_pKey1,
                       0,
                       SIZEOF( DRM_DST_KEY ) );
    ibCur += SIZEOF( DRM_DST_KEY );

    /* Write the secondary key of the slot. */
    DRM_BYT_CopyBytes( f_pContextEST->m_pbEmbeddedStore,
                       ibCur,
                       ( DRM_BYTE * )f_pKey2,
                       0,
                       SIZEOF( DRM_DST_KEY ) );
    ibCur += SIZEOF( DRM_DST_KEY );

    /* Initialize the slot context provided by the caller. */
    MEMCPY( ( DRM_BYTE * )&f_pContextSlot->m_oKey1,
            ( DRM_BYTE * )f_pKey1,
            SIZEOF( DRM_DST_KEY ) );

    MEMCPY( ( DRM_BYTE * )&f_pContextSlot->m_oKey2,
            ( DRM_BYTE * )f_pKey2,
            SIZEOF( DRM_DST_KEY ) );

    /* All locks are shared until locking is implemented fully. */
    f_pContextSlot->m_eLockmode = eDRM_DST_LOCKSHARED;

    /* Write the location (starting index and size) of the slot within the overall EST buffer. */
    f_pContextSlot->m_oSlotLocation.m_ibOffset = ibCur - DRM_EST_SLOTHEADER_LEN;
    f_pContextSlot->m_oSlotLocation.m_cbSlotLen = cbSlot;

    /* Reduce the size of the unused EST buffer. */
    ChkBOOL( PADDED_LEN(cbSlot) >= cbSlot, DRM_E_DSTCORRUPTED );
    f_pContextEST->m_ibUnused += PADDED_LEN(cbSlot);
    f_pContextEST->m_cbUnused -= PADDED_LEN(cbSlot);
    DRMASSERT( f_pContextEST->m_ibUnused + f_pContextEST->m_cbUnused ==
               f_pContextEST->m_cbEmbeddedStore );

    f_pContextEST->m_fIsDirty = TRUE;

ErrorExit:

    return dr;
}

/**********************************************************************
**
** Function :   DRM_EST_InitializeDST
**
** Synopsis :   Initializes function pointers and other members of the DST
**              structure for use with an EST implementation.
**
** Arguments :
**      [f_pDst] : Returns the initialized DST structure.
**
** Returns :
**      DRM_SUCCESS      - Success.
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_InitializeDST(
    __out DRM_DST *f_pDst )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDst != NULL );

    /*
    ** Context size verification
    */
    DRMCASSERT( SIZEOF( DRM_EST_CONTEXT )           <= SIZEOF( DRM_DST_CONTEXT ) );
    DRMCASSERT( SIZEOF( DRM_EST_NAMESPACE_CONTEXT ) <= SIZEOF( DRM_DST_NAMESPACE_CONTEXT ) );
    DRMCASSERT( SIZEOF( DRM_EST_SLOT_CONTEXT )      <= SIZEOF( DRM_DST_SLOT_CONTEXT ) );
    DRMCASSERT( SIZEOF( DRM_EST_SLOT_HINT )         <= SIZEOF( DRM_DST_SLOT_HINT ) );
    DRMCASSERT( SIZEOF( DRM_EST_ENUM_CONTEXT )      <= SIZEOF( DRM_DST_ENUM_CONTEXT ) );

    /*
    ** Slot header is guaranteed to be 32-bit aligned
    */
    DRMCASSERT( PAD_AMOUNT(DRM_EST_SLOTHEADER_LEN) == 0 );

    f_pDst->eImplementationType                          = eDRM_DST_EMBEDDED;
    f_pDst->oDataStoreInterface.pfnInit                  = DRM_EST_Init;
    f_pDst->oDataStoreInterface.pfnUninit                = DRM_EST_Uninit;
    f_pDst->oDataStoreInterface.pfnCreateStore           = DRM_EST_CreateStore;
    f_pDst->oDataStoreInterface.pfnOpenStore             = DRM_EST_OpenStore;
    f_pDst->oDataStoreInterface.pfnCloseStore            = DRM_EST_CloseStore;
    f_pDst->oDataStoreInterface.pfnCommitStore           = DRM_EST_CommitStore;
    f_pDst->oDataStoreInterface.pfnCleanupStore          = DRM_EST_CleanupStore;
    f_pDst->oDataStoreInterface.pfnOpenNamespace         = DRM_EST_OpenNamespace;
    f_pDst->oDataStoreInterface.pfnDeleteNamespace       = DRM_EST_DeleteNamespace;
    f_pDst->oDataStoreInterface.pfnCloseNamespace        = DRM_EST_CloseNamespace;
    f_pDst->oDataStoreInterface.pfnCommitNamespace       = DRM_EST_CommitNamespace;
    f_pDst->oDataStoreInterface.pfnMakeSlotHint          = DRM_EST_MakeSlotHint;
    f_pDst->oDataStoreInterface.pfnOpenSlot              = DRM_EST_OpenSlot;
    f_pDst->oDataStoreInterface.pfnCloseSlot             = DRM_EST_CloseSlot;
    f_pDst->oDataStoreInterface.pfnDeleteSlot            = DRM_EST_DeleteSlot;
    f_pDst->oDataStoreInterface.pfnInitSlotEnum          = DRM_EST_InitSlotEnum;
    f_pDst->oDataStoreInterface.pfnSlotEnumNext          = DRM_EST_SlotEnumNext;
    f_pDst->oDataStoreInterface.pfnSlotEnumReloadCurrent = DRM_EST_SlotEnumReloadCurrent;
    f_pDst->oDataStoreInterface.pfnSlotEnumDeleteCurrent = DRM_EST_SlotEnumDeleteCurrent;
    f_pDst->oDataStoreInterface.pfnBlockScanDelete       = DRM_EST_BlockScanDelete;
    f_pDst->oDataStoreInterface.pfnSlotResize            = DRM_EST_SlotResize;
    f_pDst->oDataStoreInterface.pfnSlotSeek              = DRM_EST_SlotSeek;
    f_pDst->oDataStoreInterface.pfnSlotRead              = DRM_EST_SlotRead;
    f_pDst->oDataStoreInterface.pfnSlotWrite             = DRM_EST_SlotWrite;

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_Init
**
** Synopsis:    Initializes an embedded store context.
**
** Arguments:
**      [f_pDSTContext]         - Specifies the DST Context.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
** Notes:       The function MUST be called in the main thread BEFORE
**              any of the child thread(s) starting sharing the same
**              context. If this function is called after the child
**              thread(s) started, the result is undefined.
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_Init (
    __inout DRM_DST_CONTEXT *f_pContextDST )
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_EST_CONTEXT *poESTContext = ( DRM_EST_CONTEXT * )f_pContextDST;

    ChkArg( f_pContextDST != NULL );

    poESTContext->m_fInited         = TRUE;
    poESTContext->m_fStoreOpen      = FALSE;
    poESTContext->m_fIsDirty        = FALSE;
    poESTContext->m_cbEmbeddedStore = 0;
    poESTContext->m_pbEmbeddedStore = NULL;

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_Uninit
**
** Synopsis:    Uninitializes an Embedded Data Store context.
**
** Arguments:
**      [f_pContextDST] - Specifies the data store context to uninitialize.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.

**
** Notes:       This function MUST be called in the main thread AFTER
**              any of the child thread(s) sharing the same context
**              stopped. If this function is called before the child
**              thread(s) stopped, the result is undefined.
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_Uninit (
    __inout DRM_DST_CONTEXT *f_pContextDST )
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_EST_CONTEXT *poESTContext = ( DRM_EST_CONTEXT * )f_pContextDST;

    ChkArg( f_pContextDST != NULL );

    poESTContext->m_fInited         = FALSE;
    poESTContext->m_fStoreOpen      = FALSE;
    poESTContext->m_fIsDirty        = FALSE;
    poESTContext->m_cbEmbeddedStore = 0;
    poESTContext->m_pbEmbeddedStore = NULL;

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_CreateStore
**
** Synopsis:    Creates an embedded data store.
**
** Arguments:
**      [f_pvOEMContext]   - Optional pointer to OEM-specific context.
**      [f_pbStoreData]    - Specifies store initialization data.
**      [f_cbStoreData]    - Specifies the length of f_pbStoreData.
**      [f_dwBlockSize]    - Specifies the block size for the store.
**      [f_eBlkNumType]    - Specifies a block numbering type for the store.
**      [f_fTruncateExist] - Specifies whether to truncate an existing store at this location.
**      [f_dwInitSizeInKB] - Specifies the initial size of the data store in KB.
**      [f_pContextDST]    - Returns the updated data store context.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_CreateStore (
    __in_opt                           DRM_VOID          *f_pbOEMContext,
    __in_bcount( f_cbStoreData ) const DRM_BYTE          *f_pbStoreData,
    __in                               DRM_DWORD          f_cbStoreData,
    __in                         const DRM_DWORD          f_dwBlockSize,
    __in                               DRM_DST_BLKNUMTYPE f_eBlNumType,
    __in                               DRM_BOOL           f_fTruncateExist,
    __in                         const DRM_DWORD          f_dwInitSizeInKB,
    __inout                            DRM_DST_CONTEXT   *f_pContextDST )
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_EST_CONTEXT *poESTContext = ( DRM_EST_CONTEXT * )f_pContextDST;
    DRM_WORD         wCurVersion  = DRM_EST_CURRENT_VERSION;
    DRM_WORD         wMinVersion  = DRM_EST_MINIMUM_VERSION;

    ChkArg( f_pContextDST != NULL );
    ChkArg( poESTContext->m_fInited );
    ChkArg( f_pbStoreData != NULL );

    ChkBOOL( f_cbStoreData > DRM_EST_HEADER_LEN, DRM_E_BUFFERTOOSMALL );

    /*
    ** Check for an existing store
    */
    ChkBOOL( f_fTruncateExist || MEMCMP( f_pbStoreData, DRM_EST_HEADER_CONST, DRM_EST_HEADER_CONST_LEN ) != 0,
             DRM_E_DSTEXISTS );

    poESTContext->m_fStoreOpen      = TRUE;
    poESTContext->m_fIsDirty        = TRUE;
    poESTContext->m_cbEmbeddedStore = f_cbStoreData;
    poESTContext->m_pbEmbeddedStore = ( DRM_BYTE * )f_pbStoreData;

    if ( f_fTruncateExist )
    {
        ZEROMEM( poESTContext->m_pbEmbeddedStore, poESTContext->m_cbEmbeddedStore );
    }

    /*
    ** Initialize the embedded store
    */
    MEMCPY( poESTContext->m_pbEmbeddedStore, DRM_EST_HEADER_CONST, DRM_EST_HEADER_CONST_LEN );
    WORD_TO_NETWORKBYTES( poESTContext->m_pbEmbeddedStore, DRM_EST_HEADER_CONST_LEN, wCurVersion );
    WORD_TO_NETWORKBYTES( poESTContext->m_pbEmbeddedStore, DRM_EST_HEADER_CONST_LEN + SIZEOF( DRM_WORD ), wMinVersion );
    DWORD_TO_NETWORKBYTES( poESTContext->m_pbEmbeddedStore, DRM_EST_HEADER_CONST_LEN + 2 * SIZEOF( DRM_WORD ), f_cbStoreData );

    ChkDR( _EST_PrepareUnusedBuffer( poESTContext ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_OpenStore
**
** Synopsis:    Opens a previously created embedded store.
**
** Arguments:
**      [f_pOEMContext]      - Pointer to OEM-specific context data.
**      [f_pbStoreData]      - Specifies store initialization data.
**      [f_cbStoreData]      - Specifies the length of f_pbStoreData.
**      [f_dwGrowBySizeinKB] - Specifies the number of bytes to grow the store
**                             during resizing.
**      [f_pContextDST]      - Returns the updated data store context.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_OpenStore (
    __in_opt                     DRM_VOID        *f_pOEMContext,
    __in_bcount( f_cbStoreData ) DRM_BYTE        *f_pbStoreData,
    __in                         DRM_DWORD        f_cbStoreData,
    __in                         DRM_DWORD        f_dwGrowBySizeinKB,
    __inout                      DRM_DST_CONTEXT *f_pContextDST )
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_EST_CONTEXT *poESTContext = ( DRM_EST_CONTEXT * )f_pContextDST;
    DRM_DWORD        cbExpected   = 0;
    DRM_WORD         wCurVersion  = 0;
    DRM_WORD         wMinVersion  = 0;

    ChkArg( f_pContextDST != NULL );
    ChkArg( poESTContext->m_fInited );
    ChkArg( f_pbStoreData != NULL );

    ChkBOOL( f_cbStoreData > DRM_EST_HEADER_LEN, DRM_E_BUFFERTOOSMALL );

    /*
    ** Verify store header
    */
    ChkBOOL( MEMCMP( f_pbStoreData, DRM_EST_HEADER_CONST, DRM_EST_HEADER_CONST_LEN ) == 0,
             DRM_E_DSTCORRUPTED);

    NETWORKBYTES_TO_WORD( wCurVersion, f_pbStoreData, DRM_EST_HEADER_CONST_LEN );
    NETWORKBYTES_TO_WORD( wMinVersion, f_pbStoreData, DRM_EST_HEADER_CONST_LEN + SIZEOF( DRM_WORD ) );
    ChkBOOL( wMinVersion >= DRM_EST_MINIMUM_VERSION, DRM_E_DST_NOT_COMPATIBLE );
    ChkBOOL( wMinVersion <= DRM_EST_CURRENT_VERSION, DRM_E_DST_NOT_COMPATIBLE );
    ChkBOOL( wMinVersion <= wCurVersion, DRM_E_DSTCORRUPTED );

    NETWORKBYTES_TO_DWORD( cbExpected, f_pbStoreData, DRM_EST_HEADER_CONST_LEN + 2 * SIZEOF( DRM_WORD ) );
    ChkBOOL( cbExpected <= f_cbStoreData, DRM_E_BUFFERTOOSMALL );
    ChkBOOL( cbExpected <= MAX_EMBEDDED_STORE_LEN, DRM_E_DSTCORRUPTED ); /* total ELS size cannot be > 10K */

    poESTContext->m_fStoreOpen      = TRUE;
    poESTContext->m_fIsDirty        = FALSE;
    poESTContext->m_cbEmbeddedStore = cbExpected;
    poESTContext->m_pbEmbeddedStore = f_pbStoreData;

    ChkDR( _EST_PrepareUnusedBuffer( poESTContext ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_CloseStore
**
** Synopsis:    Close the embedded data store.
**
** Arguments:
**      [f_pContextDST] - Specifies the data store context to close.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_CloseStore ( __inout DRM_DST_CONTEXT *f_pContextDST )
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_EST_CONTEXT *poESTContext = ( DRM_EST_CONTEXT * )f_pContextDST;

    ChkArg( f_pContextDST != NULL );
    ChkArg( poESTContext->m_fInited );

    poESTContext->m_fStoreOpen       = FALSE;
    poESTContext->m_cbEmbeddedStore  = 0;
    poESTContext->m_pbEmbeddedStore  = NULL;

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_CommitStore
**
** Synopsis:    Flushes unwritten data to the embedded store.
**
** Arguments:
**      [f_pContextDST] - Specifies the data store context to flush.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_CommitStore (
    __inout DRM_DST_CONTEXT *f_pContextDST )
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_EST_CONTEXT *poESTContext = ( DRM_EST_CONTEXT * )f_pContextDST;

    ChkArg( f_pContextDST != NULL );
    ChkArg( poESTContext->m_fInited );
    ChkArg( poESTContext->m_fStoreOpen );

    poESTContext->m_fIsDirty = FALSE;

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_CleanupStore
**
** Synopsis:    Performs cleanup on an embedded data store.
**
** Arguments:
**      [f_pContextDST] - Specifies the data store context to clean.
**      [f_fWait]       - Specifies whether to wait for locked slots to unlock.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_CleanupStore (
    __inout DRM_DST_CONTEXT *f_pContextDST,
    __in    DRM_BOOL         f_fWait )
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_EST_CONTEXT *poESTContext = ( DRM_EST_CONTEXT * )f_pContextDST;

    ChkArg( f_pContextDST != NULL );
    ChkArg( poESTContext->m_fInited );
    ChkArg( poESTContext->m_fStoreOpen );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_OpenNamespace
**
** Synopsis:    Opens a specified namespace within an embedded data store.
**
** Arguments:
**      [f_pContextDST]        - Specifies the data store context.
**      [f_pbNamespace]        - Namespace identifier to open.
**      [f_cbNamespace]        - Specifies the length in bytes of f_pbNamespace.
**      [f_eOpenMode]          - Specifies the open mode.
**      [f_wMaxNumChildren]    - Specifies the number of children to create if a new
**                               namespace is to be created.
**      [f_dwExpectedSlotSize] - Expected size of bytes in slots for this namespace.
**      [f_pContextNS]         - Returns the context for the opened namespace.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_OpenNamespace (
    __inout        DRM_DST_CONTEXT           *f_pContextDST,
    __in    const  DRM_DST_NAMESPACE         *f_pNamespace,
    __in           DRM_DST_OPENMODE           f_eOpenMode,
    __in           DRM_WORD                   f_wMaxNumChildren,
    __in           DRM_DWORD                  f_dwExpectedSlotSize,
    __out          DRM_DST_NAMESPACE_CONTEXT *f_pContextNS )
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_EST_CONTEXT *poESTContext = ( DRM_EST_CONTEXT * )f_pContextDST;
    DRM_EST_NAMESPACE_CONTEXT *poESTNSContext = ( DRM_EST_NAMESPACE_CONTEXT * )f_pContextNS;

    ChkArg( f_pContextDST != NULL );
    ChkArg( f_pContextNS  != NULL );
    ChkArg( poESTContext->m_fInited );
    ChkArg( poESTContext->m_fStoreOpen );

    poESTNSContext->m_fNamespaceOpen = TRUE;
    poESTNSContext->m_poESTContext   = poESTContext;

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_DeleteNamespace
**
** Synopsis:    Deletes a specified namespace and all sub-nodes from an
**              embedded data store.
**
** Arguments:
**      [f_pContextDST] - Specifies the data store context.
**      [f_pNS]         - Identifies the namespace to delete.
**      [f_fWait]       - Specifies whether to wait for locks before deletion.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_DeleteNamespace (
    __inout    DRM_DST_CONTEXT   *f_pContextDST,
    __inout    DRM_DST_NAMESPACE *f_pNS,
    __in       DRM_BOOL           f_fWait )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pContextDST != NULL );
    ChkArg( f_pNS         != NULL );

    dr = DRM_E_NOTIMPL;
ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_CloseNamespace
**
** Synopsis:    Closes the specified namespace.
**
** Arguments:
**      [f_pContextNS]  - Specifies the context of the namespace to close.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_CloseNamespace (
    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS )
{
    DRM_RESULT                 dr             = DRM_SUCCESS;
    DRM_EST_NAMESPACE_CONTEXT *poESTNSContext = ( DRM_EST_NAMESPACE_CONTEXT * )f_pContextNS;

    ChkArg( f_pContextNS  != NULL );
    ChkArg( poESTNSContext->m_fNamespaceOpen );

    poESTNSContext->m_fNamespaceOpen = FALSE;

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_CommitNamespace
**
** Synopsis:    Flushes open data to the specified namespace.
**
** Arguments:
**      [f_pContextNS]  - Specifies the context of the namespace to flush.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_CommitNamespace (
    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS )
{
    return DRM_SUCCESS;
}

/**********************************************************************
** Function:    DRM_EST_MakeSlotHint
**
** Synopsis:    Initialize a slot hint based on the slot context passed.
**
** Arguments:
**      [f_pContextSlot]  - Specifies the slot context.
**      [f_pSlotHint]     - Returns the initialized slot hint.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_MakeSlotHint (
    __in    DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out   DRM_DST_SLOT_HINT     *f_pSlotHint )
{
    DRM_RESULT            dr               = DRM_SUCCESS;
    DRM_EST_SLOT_CONTEXT *poESTSlotContext = ( DRM_EST_SLOT_CONTEXT * )f_pContextSlot;

    ChkArg( f_pContextSlot != NULL );
    ChkArg( f_pSlotHint    != NULL );

    MEMCPY( f_pSlotHint, &poESTSlotContext->m_oSlotLocation, SIZEOF( DRM_EST_SLOT_HINT ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_OpenSlot
**
** Synopsis:    Create or open a dataslot using given key1 and key2.
**
** Arguments:
**      [f_pContextNS]    - Specifies the namespace to search for a slot.
**      [f_dwMode]        - Combo of DRM_DST_OPENMODE and DRM_DSTSLOT_LOCKMODE.
**      [f_pKey1]         - Specifies the first key of the slot to open.
**      [f_pKey2]         - Specifies the second (unique) key of the slot to open.
**      [f_pSlotHint]     - Optional. Specifies a slot hint for the slot to open.
**      [f_pcbSlotSize]   - Specifies the slot context size.
**                          Returns the size of the data slot in bytes (no padding)
**      [f_pContextSlot]  - Returns the context for the opened slot.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_OpenSlot (
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in       DRM_DWORD                  f_dwMode,
    __in const DRM_DST_KEY               *f_pKey1,
    __in const DRM_DST_KEY               *f_pKey2,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __inout    DRM_DWORD                 *f_pcbSlotSize,
    __out      DRM_DST_SLOT_CONTEXT      *f_pContextSlot )
{
    DRM_RESULT                 dr               = DRM_SUCCESS;
    DRM_RESULT                 dr2              = DRM_SUCCESS;
    DRM_EST_NAMESPACE_CONTEXT *poESTNSContext   = ( DRM_EST_NAMESPACE_CONTEXT * )f_pContextNS;
    DRM_EST_CONTEXT           *poESTContext     = NULL;
    DRM_EST_SLOT_CONTEXT      *poESTSlotContext = ( DRM_EST_SLOT_CONTEXT * )f_pContextSlot;

    ChkArg( f_pContextNS   != NULL );
    ChkArg( f_pKey1        != NULL );
    ChkArg( f_pKey2        != NULL );
    ChkArg( f_pcbSlotSize  != NULL );
    ChkArg( f_pContextSlot != NULL );
    ChkArg( poESTNSContext->m_poESTContext != NULL );
    ChkArg( poESTNSContext->m_fNamespaceOpen );

    poESTContext = poESTNSContext->m_poESTContext;
    DRMASSERT( poESTContext != NULL );

    ChkArg( poESTContext->m_fStoreOpen );
    ChkBOOL( poESTContext->m_cbEmbeddedStore > DRM_EST_HEADER_LEN + DRM_EST_SLOTHEADER_LEN,
             DRM_E_BUFFERTOOSMALL );

    /*
    ** Attempt to open existing slot
    */
    if ( f_dwMode & eDRM_DST_OPEN_EXISTING
      || f_dwMode & eDRM_DST_OPEN_ALWAYS )
    {
        dr2 = _EST_OpenSlot( poESTContext,
                             f_dwMode,
                             f_pKey1,
                             f_pKey2,
                             ( DRM_EST_SLOT_HINT * )f_pSlotHint,
                             poESTSlotContext );

        if ( DRM_SUCCEEDED( dr2 ) )
        {
            *f_pcbSlotSize = poESTSlotContext->m_oSlotLocation.m_cbSlotLen - DRM_EST_SLOTHEADER_LEN;
            goto ErrorExit; /* Success. Do not create slot */
        }
        else if ( f_dwMode & eDRM_DST_OPEN_EXISTING )
        {
            ChkDR( dr2 ); /* Failed to open slot. */
        }
        dr2 = DRM_S_FALSE; /* False indicates a slot was not found */
    }

    /* Try to create the slot. */
    dr = _EST_CreateSlot( poESTContext,
                          f_dwMode,
                          f_pKey1,
                          f_pKey2,
                          f_pcbSlotSize,
                          poESTSlotContext );

    if ( DRM_FAILED( dr ) )
    {
        /* If create slot fails, error should always be returned to the caller. */
        dr2 = dr;
    }

ErrorExit:

    if ( DRM_SUCCEEDED( dr2 ) )
    {
        dr = dr2;
    }

    if ( DRM_SUCCEEDED( dr ) && poESTSlotContext != NULL )
    {
        poESTSlotContext->m_fSlotOpen      = TRUE;
        poESTSlotContext->m_ibSeekPtr      = 0;
        poESTSlotContext->m_poESTNSContext = poESTNSContext;
    }

    return dr;
}

/**********************************************************************
** Function:    DRM_EST_CloseSlot
**
** Synopsis:    Closes an open data slot.
**
** Arguments:
**      [f_pContextSlot] - Specifies the slot context.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_CloseSlot (
    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot )
{
    DRM_RESULT            dr               = DRM_SUCCESS;
    DRM_EST_SLOT_CONTEXT *poESTSlotContext = ( DRM_EST_SLOT_CONTEXT * )f_pContextSlot;

    ChkArg( f_pContextSlot != NULL );
    ChkArg( poESTSlotContext->m_fSlotOpen );

    /*
    ** Zero out the following members:
    ** poESTSlotContext->m_fSlotOpen      = FALSE;
    ** poESTSlotContext->m_poESTNSContext = NULL;
    ** poESTSlotContext->m_ibSeekPtr      = 0;
    */
    ZEROMEM( poESTSlotContext, SIZEOF( DRM_EST_SLOT_CONTEXT ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_DeleteSlot
**
** Synopsis:    Deletes a dataslot with given key1 and key2.
**
** Arguments:
**      [f_pContextNS] - Specifies the namespace to search for the slot.
**      [f_dwMode]     - Combo of DRM_DST_OPENMODE and DRM_DSTSLOT_LOCKMODE.
**      [f_pKey1]      - Specifies the first key of the slot to delete.
**      [f_pKey2]      - Specifies the second (unique) key of the slot to delete.
**      [f_pSlotHint]  - Optional. Specifies a slot hint for the slot to delete.
**      [f_fWait]      - Specifies whether to wait for open locks before deletion.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_DeleteSlot (
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in const DRM_DST_KEY               *f_pKey1,
    __in const DRM_DST_KEY               *f_pKey2,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __in       DRM_BOOL                   f_fWait )
{
    DRM_RESULT                 dr              = DRM_SUCCESS;
    DRM_EST_NAMESPACE_CONTEXT *poESTNSContext  = ( DRM_EST_NAMESPACE_CONTEXT * )f_pContextNS;
    DRM_EST_CONTEXT           *poESTContext     = NULL;
    DRM_EST_SLOT_CONTEXT       oESTSlotContext = { 0 };
    DRM_DWORD                  ibTarget = 0;
    DRM_DWORD                  ibSource = 0;
    DRM_DWORD                  cbCopy   = 0;

    ChkArg( poESTNSContext != NULL );
    ChkArg( f_pKey2 != NULL );

    poESTContext = poESTNSContext->m_poESTContext;
    DRMASSERT( poESTContext != NULL );

    /*
    ** Open the slot with exclusive access
    */
    ChkDR( _EST_OpenSlot( poESTContext,
                          eDRM_DST_LOCKEXCLUSIVE,
                          f_pKey1,
                          f_pKey2,
                          ( DRM_EST_SLOT_HINT * )f_pSlotHint,
                          &oESTSlotContext ) );

    DRMASSERT( oESTSlotContext.m_oSlotLocation.m_ibOffset >= DRM_EST_HEADER_LEN );
    DRMASSERT( oESTSlotContext.m_oSlotLocation.m_cbSlotLen > DRM_EST_SLOTHEADER_LEN );
    DRMASSERT( oESTSlotContext.m_oSlotLocation.m_ibOffset +
               PADDED_LEN(oESTSlotContext.m_oSlotLocation.m_cbSlotLen) <= poESTContext->m_ibUnused );

    /*
    ** In order to delete a slot, just shift all subsequent slots forward and
    ** overwrite the slot to be deleted.
    */
    ibTarget = oESTSlotContext.m_oSlotLocation.m_ibOffset;
    ChkOverflow( ibTarget + PADDED_LEN(oESTSlotContext.m_oSlotLocation.m_cbSlotLen), ibTarget );
    ibSource = ibTarget + PADDED_LEN(oESTSlotContext.m_oSlotLocation.m_cbSlotLen);
    cbCopy = poESTNSContext->m_poESTContext->m_ibUnused - ibSource;
    ChkOverflow( poESTNSContext->m_poESTContext->m_ibUnused, cbCopy );

    DRM_BYT_MoveBytes( poESTContext->m_pbEmbeddedStore,
                       ibTarget,
                       poESTContext->m_pbEmbeddedStore,
                       ibSource,
                       cbCopy );

    /* Increase the size of the unused EST buffer. */
    poESTContext->m_ibUnused -= PADDED_LEN(oESTSlotContext.m_oSlotLocation.m_cbSlotLen);
    poESTContext->m_cbUnused += PADDED_LEN(oESTSlotContext.m_oSlotLocation.m_cbSlotLen);
    DRMASSERT( poESTContext->m_ibUnused + poESTContext->m_cbUnused ==
               poESTContext->m_cbEmbeddedStore );

    /*
    ** Clear the leftover bytes belonging to the unused buffer after memory
    ** shift is done.
    */
    DRM_BYT_SetBytes( poESTContext->m_pbEmbeddedStore,
                      poESTContext->m_ibUnused,
                      poESTContext->m_cbUnused,
                      0 );

    poESTContext->m_dwDeleteCount++;
    poESTContext->m_fIsDirty = TRUE;

ErrorExit:

    return dr;
}

/**********************************************************************
** Function:    DRM_EST_InitSlotEnum
**
** Synopsis:    Initialized an enumeration of slots within a namespace.
**
** Arguments:
**      [f_pContextNS]   - Specifies the namespace to enumerate in.
**      [f_pKey1]        - Optional. Specifies the key to enumerate. If NULL, enumerates
**                         over all keys in the namespace.
**      [f_eLockMode]    - Specifies the lock mode to use for enumerated slots.
**      [f_pContextEnum] - Returns the initialized enumeration context.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_InitSlotEnum (
    __in           DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in_opt const DRM_DST_KEY               *f_pKey1,
    __in           DRM_DST_LOCKMODE           f_eLockMode,
    __out          DRM_DST_ENUM_CONTEXT      *f_pContextEnum )
{
    DRM_RESULT                 dr               = DRM_SUCCESS;
    DRM_EST_NAMESPACE_CONTEXT *poESTNSContext   = ( DRM_EST_NAMESPACE_CONTEXT * )f_pContextNS;
    DRM_EST_CONTEXT           *poESTContext     = NULL;
    DRM_EST_ENUM_CONTEXT      *poESTEnumContext = ( DRM_EST_ENUM_CONTEXT  * )f_pContextEnum;
    DRM_DWORD                  ibCur            = DRM_EST_HEADER_LEN;
    DRM_DWORD                  cbSlot           = 0;

    ChkArg( poESTNSContext   != NULL );
    ChkArg( poESTNSContext->m_poESTContext != NULL );
    ChkArg( poESTEnumContext != NULL );

    poESTContext = poESTNSContext->m_poESTContext;
    DRMASSERT( poESTContext != NULL );

    ZEROMEM( poESTEnumContext, SIZEOF( DRM_EST_ENUM_CONTEXT ) );

    if ( f_pKey1 != NULL )
    {
        /*
        ** Save the key that is used to determine the candidancy of the slots being examined.
        ** If the key is NULL, all slots are eligible to be enumerated.
        */
        MEMCPY( &poESTEnumContext->m_oKey1, f_pKey1, SIZEOF( DRM_DST_KEY ) );
    }

    poESTEnumContext->m_eLockMode = f_eLockMode;

    /*
    ** Calculate the total number of slots (both candidate and non-candidate) in
    ** the EST. The enumeration examination starts with slot 0.
    */
    while ( ibCur < poESTContext->m_ibUnused )
    {
        NETWORKBYTES_TO_DWORD( cbSlot, poESTContext->m_pbEmbeddedStore, ibCur );
        ChkBOOL( cbSlot <= MAX_EMBEDDED_STORE_LEN, DRM_E_DSTCORRUPTED );
        ChkBOOL( cbSlot > DRM_EST_SLOTHEADER_LEN, DRM_E_DSTCORRUPTED );
        /*
        ** In case cbSlot is corrupt and very large, we don't want to integer overflow
        ** So we use subtraction (A<=B-C) instead of addition (A+C<=B).
        ** We know we won't UNDERFLOW in subtraction because we verified B>C above.
        */
        ChkBOOL( PADDED_LEN(cbSlot) >= cbSlot, DRM_E_DSTCORRUPTED );
        ChkBOOL( PADDED_LEN(cbSlot) <= poESTContext->m_ibUnused - ibCur, DRM_E_DSTCORRUPTED );
        ibCur += PADDED_LEN(cbSlot);

        poESTEnumContext->m_cSlots++;
    }

    poESTEnumContext->m_fInited        = TRUE;
    poESTEnumContext->m_poESTNSContext = poESTNSContext;
    poESTEnumContext->m_dwCurrentDeleteCount = poESTContext->m_dwDeleteCount;

ErrorExit:

    return dr;
}

/**********************************************************************
** Function:    DRM_EST_SlotEnumNext
**
** Synopsis:    Retrieves the next slot from an enumeration.
**
** Arguments:
**      [f_pContextEnum] - Specifies the initialized enumeration context.
**      [f_pContextSlot] - Returns the slot data for the next slot in the enumeration.
**      [f_pKey1]        - Optional. Returns the first key value for the next slot.
**      [f_pKey2]        - Optional. Returns the second (unique) key value for the next slot.
**      [f_pcbSize]      - Optional. Returns the data slot size in bytes (no padding)
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_SlotEnumNext (
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out_opt  DRM_DST_KEY           *f_pKey1,
    __out_opt  DRM_DST_KEY           *f_pKey2,
    __out_opt  DRM_DWORD             *f_pcbSize )
{
    DRM_RESULT             dr               = DRM_SUCCESS;
    DRM_EST_ENUM_CONTEXT  *poESTEnumContext = ( DRM_EST_ENUM_CONTEXT * )f_pContextEnum;
    DRM_EST_CONTEXT       *poESTContext     = NULL;
    DRM_EST_SLOT_CONTEXT  *poESTSlotContext = ( DRM_EST_SLOT_CONTEXT * )f_pContextSlot;
    DRM_DWORD              ibCur            = DRM_EST_HEADER_LEN;
    DRM_DWORD              cbSlot           = 0;
    DRM_DWORD              i                = 0;
    DRM_GUID               oEmptyKey        = EMPTY_DRM_GUID;

    ChkArg( f_pContextEnum                     != NULL );
    ChkArg( f_pContextSlot                     != NULL );
    ChkArg( poESTEnumContext->m_poESTNSContext != NULL );
    ChkArg( poESTEnumContext->m_poESTNSContext->m_poESTContext != NULL );
    ChkArg( poESTEnumContext->m_fInited );
    ChkArg( f_pContextSlot != NULL );

    poESTContext = poESTEnumContext->m_poESTNSContext->m_poESTContext;
    DRMASSERT( poESTContext != NULL );

    DRMCASSERT( SIZEOF( DRM_GUID ) == SIZEOF( DRM_DST_KEY ) );

    if( poESTContext->m_dwDeleteCount > poESTEnumContext->m_dwCurrentDeleteCount )
    {
        /* A deletion has occurred since we started, need to restart the enumeration */
        poESTEnumContext->m_dwCurrentDeleteCount = poESTContext->m_dwDeleteCount;
        poESTEnumContext->m_iSlot = 0;
    }

    /*
    ** Check whether the enumeration index has already reached the end of all
    ** available slots.
    */
    ChkBOOL( poESTEnumContext->m_iSlot < poESTEnumContext->m_cSlots, DRM_E_NOMORE );

    /* Skip the slots that have been visited before. */
    for ( i = 0; i < poESTEnumContext->m_iSlot; ++i )
    {
        if( ibCur >= poESTContext->m_ibUnused )
        {
            /* If we hit here it means someone deleted slots between InitSlotEnum and now */
            ChkDR( DRM_E_NOMORE );
        }

        NETWORKBYTES_TO_DWORD( cbSlot, poESTContext->m_pbEmbeddedStore, ibCur );
        ChkBOOL( cbSlot <= MAX_EMBEDDED_STORE_LEN, DRM_E_DSTCORRUPTED );
        ChkBOOL( cbSlot > DRM_EST_SLOTHEADER_LEN, DRM_E_DSTCORRUPTED );
        ChkBOOL( ibCur <= poESTContext->m_ibUnused, DRM_E_DSTCORRUPTED );
        /*
        ** In case cbSlot is corrupt and very large, we don't want to integer overflow
        ** So we use subtraction (A<=B-C) instead of addition (A+C<=B).
        ** We know we won't UNDERFLOW in subtraction because we verified B>C above.
        */
        ChkBOOL( PADDED_LEN(cbSlot) >= cbSlot, DRM_E_DSTCORRUPTED );
        ChkBOOL( PADDED_LEN(cbSlot) <= poESTContext->m_ibUnused - ibCur, DRM_E_DSTCORRUPTED );
        ibCur += PADDED_LEN(cbSlot);
    }

    while ( ibCur < poESTContext->m_ibUnused &&
            poESTEnumContext->m_iSlot < poESTEnumContext->m_cSlots )
    {
        NETWORKBYTES_TO_DWORD( cbSlot, poESTContext->m_pbEmbeddedStore, ibCur );
        ChkBOOL( cbSlot <= MAX_EMBEDDED_STORE_LEN, DRM_E_DSTCORRUPTED );
        ChkBOOL( cbSlot > DRM_EST_SLOTHEADER_LEN, DRM_E_DSTCORRUPTED );
        /*
        ** In case cbSlot is corrupt and very large, we don't want to integer overflow
        ** So we use subtraction (A<=B-C) instead of addition (A+C<=B).
        ** We know we won't UNDERFLOW in subtraction because we verified B>C above.
        */
        ChkBOOL( PADDED_LEN(cbSlot) >= cbSlot, DRM_E_DSTCORRUPTED );
        ChkBOOL( PADDED_LEN(cbSlot) <= poESTContext->m_ibUnused - ibCur, DRM_E_DSTCORRUPTED );

        ibCur += SIZEOF( DRM_DWORD );

        /*
        ** If the primary key is not empty, use it to check whether the current
        ** slot being examined is a candidate of the enumeration.
        */
        if ( MEMCMP( &poESTEnumContext->m_oKey1, &oEmptyKey, SIZEOF( DRM_DST_KEY ) ) != 0 &&
             DRM_BYT_CompareBytes( poESTContext->m_pbEmbeddedStore,
                                   ibCur,
                                   ( DRM_BYTE * )&poESTEnumContext->m_oKey1,
                                   0,
                                   SIZEOF( DRM_DST_KEY ) ) != 0 )
        {
            ChkBOOL( cbSlot >= DRM_EST_SLOTHEADER_LEN, DRM_E_DSTCORRUPTED );
            ChkOverflow( PADDED_LEN( cbSlot - DRM_EST_SLOTHEADER_LEN ), cbSlot - DRM_EST_SLOTHEADER_LEN );
            ibCur += ( 2 * SIZEOF( DRM_DST_KEY ) + PADDED_LEN( cbSlot - DRM_EST_SLOTHEADER_LEN ) );
            DRMASSERT( ibCur <= poESTContext->m_ibUnused );

            poESTEnumContext->m_iSlot++;
        }
        else
        {
            /*
            ** Cache the location of the current slot. The location will be used when the slot is
            ** reloaded or deleted.
            */
            poESTEnumContext->m_oSlotHint.m_ibOffset = ibCur - SIZEOF( DRM_DWORD );
            poESTEnumContext->m_oSlotHint.m_cbSlotLen = cbSlot;

            /* Set the slot valid flag to allow reload current and delete current operations. */
            poESTEnumContext->m_fSlotValid = TRUE;

            break;
        }
    }

    if ( ibCur >= poESTContext->m_ibUnused ||
         poESTEnumContext->m_iSlot >= poESTEnumContext->m_cSlots )
    {
        /* No matching slot is found. */
        ChkDR( DRM_E_NOMORE );
    }

    /* Fill the information of the current slot into the slot context provided by the caller. */
    ChkDR( _EST_PrepareSlotToBeReturned( poESTEnumContext->m_poESTNSContext,
                                         poESTContext,
                                         &poESTEnumContext->m_oSlotHint,
                                         poESTEnumContext->m_eLockMode,
                                         poESTSlotContext,
                                         f_pKey1,
                                         f_pKey2,
                                         f_pcbSize ) );

    /* Increase the starting index of the slot to be enumerated next. */
    poESTEnumContext->m_iSlot++;

ErrorExit:

    return dr;
}

/**********************************************************************
** Function:    DRM_EST_SlotEnumReloadCurrent
**
** Synopsis:    Reload the current slot in the enumeration.
**
** Arguments:
**      [f_pContextEnum] - Specifies the initialized enumeration context.
**      [f_pContextSlot] - Returns the slot data for the current slot in the enumeration.
**      [f_pKey1]        - Optional. Returns the first key value for the slot.
**      [f_pKey2]        - Optional. Returns the second (unique) key value for the slot.
**      [f_pcbSize]      - Optional. Returns the data slot size in bytes (no padding).
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_SlotEnumReloadCurrent (
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out_opt  DRM_DST_KEY           *f_pKey1,
    __out_opt  DRM_DST_KEY           *f_pKey2,
    __out_opt  DRM_DWORD             *f_pcbSize )
{
    DRM_RESULT             dr               = DRM_SUCCESS;
    DRM_EST_ENUM_CONTEXT  *poESTEnumContext = ( DRM_EST_ENUM_CONTEXT * )f_pContextEnum;

    ChkArg( poESTEnumContext != NULL );
    ChkArg( poESTEnumContext->m_poESTNSContext != NULL );
    ChkArg( poESTEnumContext->m_poESTNSContext->m_poESTContext != NULL );
    ChkArg( poESTEnumContext->m_fInited );
    ChkArg( f_pContextSlot != NULL );

    /* If the current slot has not yet been enumerated, return with error. */
    ChkBOOL( poESTEnumContext->m_fSlotValid, DRM_E_NOMORE );

    /* Fill the information of the current slot into the slot context provided by the caller. */
    ChkDR( _EST_PrepareSlotToBeReturned( poESTEnumContext->m_poESTNSContext,
                                         poESTEnumContext->m_poESTNSContext->m_poESTContext,
                                         &poESTEnumContext->m_oSlotHint,
                                         poESTEnumContext->m_eLockMode,
                                         ( DRM_EST_SLOT_CONTEXT * )f_pContextSlot,
                                         f_pKey1,
                                         f_pKey2,
                                         f_pcbSize ) );

ErrorExit:

    return dr;
}

/**********************************************************************
** Function:    DRM_EST_SlotEnumDeleteCurrent
**
** Synopsis:    Deletes the currently enumerated slot.
**
** Arguments:
**      [f_pContextEnum] - Specifies the initialized enumeration context.
**      [f_pContextSlot] - Specifies the slot context of the current slot.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
** Notes: The enumeration must be initialized with exclusive access.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_SlotEnumDeleteCurrent (
    __inout   DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot )
{
    DRM_RESULT             dr               = DRM_SUCCESS;
    DRM_EST_ENUM_CONTEXT  *poESTEnumContext = ( DRM_EST_ENUM_CONTEXT * )f_pContextEnum;
    DRM_EST_CONTEXT       *poESTContext     = NULL;
    DRM_DWORD              ibTarget         = 0;
    DRM_DWORD              ibSource         = 0;
    DRM_DWORD              cbCopy           = 0;

    ChkArg( poESTEnumContext != NULL );
    ChkArg( poESTEnumContext->m_poESTNSContext != NULL );
    ChkArg( poESTEnumContext->m_poESTNSContext->m_poESTContext != NULL );
    ChkArg( poESTEnumContext->m_fInited );

    /*
    ** Although this parameter is not used for EST, it is still checked to be consistent
    ** with other data store implementation.
    */
    ChkArg( f_pContextSlot != NULL );

    /* If the current slot has not yet been enumerated, return with error. */
    ChkBOOL( poESTEnumContext->m_fSlotValid, DRM_E_NOMORE );

    /*
    ** Since there is at least one slot that has already been enumerated,
    ** the total number of slots should be at least 0.
    */
    DRMASSERT( poESTEnumContext->m_cSlots > 0 );

    poESTContext = poESTEnumContext->m_poESTNSContext->m_poESTContext;
    DRMASSERT( poESTContext != NULL );

    DRMASSERT( poESTEnumContext->m_oSlotHint.m_ibOffset >= DRM_EST_HEADER_LEN );
    DRMASSERT( poESTEnumContext->m_oSlotHint.m_cbSlotLen > DRM_EST_SLOTHEADER_LEN );
    DRMASSERT( poESTEnumContext->m_oSlotHint.m_ibOffset +
               PADDED_LEN(poESTEnumContext->m_oSlotHint.m_cbSlotLen) <= poESTContext->m_ibUnused );

    /*
    ** Delete the current slot using the cached slot hint information.
    ** In order to delete a slot, just shift all subsequent slots forward and
    ** overwrite the slot to be deleted.
    */
    ibTarget = poESTEnumContext->m_oSlotHint.m_ibOffset;
    ChkOverflow( ibTarget + PADDED_LEN(poESTEnumContext->m_oSlotHint.m_cbSlotLen), ibTarget );
    ibSource = ibTarget + PADDED_LEN(poESTEnumContext->m_oSlotHint.m_cbSlotLen);
    cbCopy = poESTContext->m_ibUnused - ibSource;
    ChkOverflow( poESTContext->m_ibUnused, cbCopy );

    DRM_BYT_MoveBytes( poESTContext->m_pbEmbeddedStore,
                       ibTarget,
                       poESTContext->m_pbEmbeddedStore,
                       ibSource,
                       cbCopy );

    /* Increase the size of the unused EST buffer. */
    poESTContext->m_ibUnused -= PADDED_LEN(poESTEnumContext->m_oSlotHint.m_cbSlotLen);
    poESTContext->m_cbUnused += PADDED_LEN(poESTEnumContext->m_oSlotHint.m_cbSlotLen);
    DRMASSERT( poESTContext->m_ibUnused + poESTContext->m_cbUnused ==
               poESTContext->m_cbEmbeddedStore );

    /*
    ** Set all unused EST buffer to 0 to clear the leftover bytes from the
    ** deleted slot.
    */
    DRM_BYT_SetBytes( poESTContext->m_pbEmbeddedStore,
                      poESTContext->m_ibUnused,
                      poESTContext->m_cbUnused,
                      0 );

    /* The current slot is not valid to be used any more. */
    poESTEnumContext->m_fSlotValid = FALSE;

    /* Reduce the total number of candidate slots. */
    poESTEnumContext->m_cSlots--;

    if ( poESTEnumContext->m_iSlot > 0 )
    {
        poESTEnumContext->m_iSlot--;
    }

    /* Increment the delete count, but for this particular enumerator we don't need to
    ** restart our loop since we already corrected for the deletion
    */
    if( poESTContext->m_dwDeleteCount++ == poESTEnumContext->m_dwCurrentDeleteCount )
    {
        poESTEnumContext->m_dwCurrentDeleteCount = poESTContext->m_dwDeleteCount;
    }

ErrorExit:

    return dr;
}

/**********************************************************************
** Function:    DRM_EST_BlockScanDelete
**
** Synopsis:    Rapid deletion of multiple slots.
**
** Arguments:
**      [f_pContextNS] - Specifies the namespace context to delete from.
**      [f_rgKey1]     - Specifies a list of keys (first key) to delete.
**      [f_cKey1]      - Specifies the number of elements in f_rgKey1.
**      [f_pKey2]      - Specifies a unique key
**      [f_fWait]      - Specifies whether to wait for locks before deletion.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_BlockScanDelete (
    __inout                DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS,
    __in_ecount( f_cKey1 ) DRM_DST_KEY                *f_rgKey1,
    __in                   DRM_DWORD                   f_cKey1,
    __in                   DRM_DST_KEY                *f_pKey2,
    __in                   DRM_BOOL                    f_fWait )
{
    return DRM_E_NOTIMPL; /* Not yet implemented for the embedded store. */
}

/**********************************************************************
** Function:    DRM_EST_SlotResize
**
** Synopsis:    Resizes an open data slot.
**
** Arguments:
**      [f_pContextSlot] - Specifies the slot context to resize.
**      [f_cbSize]       - Specifies the new size for the slot
**                         (padding is not included).
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_SlotResize (
    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in     DRM_DWORD              f_cbSize )
{
    DRM_RESULT            dr               = DRM_SUCCESS;
    DRM_EST_SLOT_CONTEXT *poESTSlotContext = ( DRM_EST_SLOT_CONTEXT * )f_pContextSlot;
    DRM_EST_CONTEXT      *poESTContext     = NULL;
    DRM_INT               nDiff            = 0;
    DRM_INT               nPaddedDiff      = 0;
    DRM_DWORD             ibTarget         = 0;
    DRM_DWORD             ibSource         = 0;
    DRM_DWORD             cbCopy           = 0;

    ChkArg( poESTSlotContext != NULL );
    ChkArg( poESTSlotContext->m_poESTNSContext != NULL );
    ChkArg( poESTSlotContext->m_poESTNSContext->m_poESTContext != NULL );
    ChkArg( f_cbSize > 0 );

    poESTContext = poESTSlotContext->m_poESTNSContext->m_poESTContext;
    DRMASSERT( poESTContext != NULL );

    /* Size diff without padding, tells if slot size should be rewritten */
    nDiff = f_cbSize - ( poESTSlotContext->m_oSlotLocation.m_cbSlotLen - DRM_EST_SLOTHEADER_LEN );
    /* "Real" size diff, tells if subsequent slots should be moved and size of unused buffer changed */
    ChkOverflow( PADDED_LEN(f_cbSize), f_cbSize );
    ChkBOOL( poESTSlotContext->m_oSlotLocation.m_cbSlotLen >= DRM_EST_SLOTHEADER_LEN, DRM_E_DSTCORRUPTED );
    ChkOverflow( PADDED_LEN(poESTSlotContext->m_oSlotLocation.m_cbSlotLen - DRM_EST_SLOTHEADER_LEN ), poESTSlotContext->m_oSlotLocation.m_cbSlotLen - DRM_EST_SLOTHEADER_LEN );
    nPaddedDiff = PADDED_LEN(f_cbSize) - PADDED_LEN(poESTSlotContext->m_oSlotLocation.m_cbSlotLen - DRM_EST_SLOTHEADER_LEN );

    if ( nDiff == 0 )
    {
        /*
        ** If the size to be changed is the same as the size of the slot,
        ** no change is necessary.
        */
        DRMASSERT( nPaddedDiff == 0 );
        goto ErrorExit;
    }
    else if ( nPaddedDiff > 0 )
    {
        /*
        ** Make sure there is enough space of the unused buffer to satisfy the growth.
        */
        ChkBOOL( poESTContext->m_cbUnused >= ( DRM_DWORD )nPaddedDiff,
                 DRM_E_BUFFERTOOSMALL);
    }

    DRMASSERT( poESTSlotContext->m_oSlotLocation.m_ibOffset >= DRM_EST_HEADER_LEN );
    DRMASSERT( poESTSlotContext->m_oSlotLocation.m_cbSlotLen > DRM_EST_SLOTHEADER_LEN );
    DRMASSERT( poESTSlotContext->m_oSlotLocation.m_ibOffset +
               PADDED_LEN(poESTSlotContext->m_oSlotLocation.m_cbSlotLen) <= poESTContext->m_ibUnused );

    /* Update the new size of the slot being resized. */
    DWORD_TO_NETWORKBYTES( poESTContext->m_pbEmbeddedStore,
                           poESTSlotContext->m_oSlotLocation.m_ibOffset,
                           f_cbSize + DRM_EST_SLOTHEADER_LEN );

    if ( nPaddedDiff != 0 )
    {
        /*
        ** To relaize the effect of changing the size of a slot. Shift the content of the subsequent
        ** slots forward when the slot being resized shrinks, or backward when the slot being resized
        ** grows.
        */
        ibTarget = poESTSlotContext->m_oSlotLocation.m_ibOffset + PADDED_LEN(f_cbSize + DRM_EST_SLOTHEADER_LEN);
        ChkOverflow( ibTarget, poESTSlotContext->m_oSlotLocation.m_ibOffset );
        ibSource = poESTSlotContext->m_oSlotLocation.m_ibOffset + PADDED_LEN(poESTSlotContext->m_oSlotLocation.m_cbSlotLen);
        ChkOverflow( ibSource, poESTSlotContext->m_oSlotLocation.m_ibOffset );
        cbCopy = poESTContext->m_ibUnused - ibSource;
        ChkOverflow( poESTContext->m_ibUnused, cbCopy );

        DRM_BYT_MoveBytes( poESTContext->m_pbEmbeddedStore,
                           ibTarget,
                           poESTContext->m_pbEmbeddedStore,
                           ibSource,
                           cbCopy );
    }

    /* Update the size of the unused EST buffer. */
    poESTContext->m_ibUnused = ( DRM_INT )poESTContext->m_ibUnused + nPaddedDiff;
    poESTContext->m_cbUnused = ( DRM_INT )poESTContext->m_cbUnused - nPaddedDiff;
    DRMASSERT( poESTContext->m_ibUnused + poESTContext->m_cbUnused ==
               poESTContext->m_cbEmbeddedStore );

    if ( nPaddedDiff < 0 )
    {
        /* If the size shrinks, overwrite the leftover bytes of the unused EST buffer with 0. */
        DRM_BYT_SetBytes( poESTContext->m_pbEmbeddedStore,
                          poESTContext->m_ibUnused,
                          poESTContext->m_cbUnused,
                          0 );
    }
    else
    {
        /* If the size grows, overwrite the newly allocated slot buffer with 0. */
        DRM_BYT_SetBytes( poESTContext->m_pbEmbeddedStore,
                          poESTSlotContext->m_oSlotLocation.m_ibOffset + poESTSlotContext->m_oSlotLocation.m_cbSlotLen,
                          nDiff,
                          0 );
    }

    /* Update the size of the passed in slot context. */
    poESTSlotContext->m_oSlotLocation.m_cbSlotLen = f_cbSize + DRM_EST_SLOTHEADER_LEN;

    /* Should reset the seek pointer after the slot is resized. */
    poESTSlotContext->m_ibSeekPtr = 0;

ErrorExit:

    return dr;
}

/**********************************************************************
** Function:    DRM_EST_SlotSeek
**
** Synopsis:    Set the seek pointer within an open data slot.
**
** Arguments:
**      [f_pContextSlot]  - Specifies the slot context.
**      [f_lOffset]       - Specifies the seek offset
**      [f_eSeekMode]     - Specifies the seek mode to use.
**      [f_pdwSeekPointer]- Optional. Returns the new seek pointer value.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_SlotSeek (
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in      DRM_LONG               f_lOffset,
    __in      DRM_DST_SEEKMODE       f_eSeekMode,
    __out_opt DRM_DWORD             *f_pdwSeekPointer )
{
    DRM_RESULT            dr               = DRM_SUCCESS;
    DRM_EST_SLOT_CONTEXT *poESTSlotContext = ( DRM_EST_SLOT_CONTEXT * )f_pContextSlot;
    DRM_DWORD             ibExpected       = 0;

    ChkArg( f_pContextSlot != NULL );
    ChkArg( poESTSlotContext->m_fSlotOpen );

    /*
    ** Set the seek pointer
    */
    switch ( f_eSeekMode )
    {
    case eDRM_DST_SEEKCUR:
        ibExpected = poESTSlotContext->m_ibSeekPtr + f_lOffset;
        break;
    case eDRM_DST_SEEKEND:
        ibExpected = ( poESTSlotContext->m_oSlotLocation.m_cbSlotLen - DRM_EST_SLOTHEADER_LEN ) - f_lOffset;
        break;
    case eDRM_DST_SEEKSET:
        ibExpected = f_lOffset;
        break;
    default:
        ChkArg( FALSE );
    }
    /*
    ** Verify that the new pointer is within bounds
    */
    ChkBOOL( ibExpected + DRM_EST_SLOTHEADER_LEN <= poESTSlotContext->m_oSlotLocation.m_cbSlotLen,
             DRM_E_DSTSEEKERROR );
    poESTSlotContext->m_ibSeekPtr = ibExpected;

    if ( f_pdwSeekPointer != NULL )
    {
        *f_pdwSeekPointer = ibExpected;
    }

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_SlotRead
**
** Synopsis:    Read data from an open data slot.
**
** Arguments:
**      [f_pContextSlot] - Specifies the slot context.
**      [f_cbData]       - Specifies the size in bytes to read.
**      [f_pbData]       - The data buffer to read into.
**      [f_pcbRead]      - Returns the number of bytes read.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_SlotRead (
    __inout                  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                     DRM_DWORD              f_cbData,
    __out_bcount( f_cbData ) DRM_BYTE              *f_pbData,
    __out_opt                DRM_DWORD             *f_pcbRead )
{
    DRM_RESULT            dr               = DRM_SUCCESS;
    DRM_EST_SLOT_CONTEXT *poESTSlotContext = ( DRM_EST_SLOT_CONTEXT * )f_pContextSlot;
    DRM_EST_CONTEXT      *poESTContext     = NULL;
    DRM_DWORD             ibCurr           = 0;
    DRM_DWORD             cbRead           = f_cbData;

    ChkArg( f_pContextSlot != NULL );
    ChkArg( f_pbData       != NULL );
    ChkArg( poESTSlotContext->m_fSlotOpen );
    ChkArg( poESTSlotContext->m_poESTNSContext != NULL );
    ChkArg( poESTSlotContext->m_poESTNSContext->m_poESTContext != NULL );

    /*
    ** Read from data store:
    */
    poESTContext = poESTSlotContext->m_poESTNSContext->m_poESTContext;
    ibCurr = poESTSlotContext->m_oSlotLocation.m_ibOffset + DRM_EST_SLOTHEADER_LEN + poESTSlotContext->m_ibSeekPtr;

    if ( ibCurr + cbRead > poESTSlotContext->m_oSlotLocation.m_ibOffset + poESTSlotContext->m_oSlotLocation.m_cbSlotLen )
    {
        cbRead = poESTSlotContext->m_oSlotLocation.m_ibOffset + poESTSlotContext->m_oSlotLocation.m_cbSlotLen - ibCurr;
    }
    DRM_BYT_CopyBytes( f_pbData, 0, poESTContext->m_pbEmbeddedStore, ibCurr, cbRead );
    poESTSlotContext->m_ibSeekPtr += cbRead;

    if ( f_pcbRead != NULL )
    {
        *f_pcbRead = cbRead;
    }

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_EST_SlotWrite
**
** Synopsis:    Write data from an open and locked data slot.
**
** Arguments:
**      [f_pContextSlot] - Specifies the slot context.
**      [f_cbData]       - Specifies the size in bytes to write.
**      [f_pbData]       - The data buffer to write from.
**      [f_pcbWritten]   - Returns the number of bytes written.
**
** Returns:
**      DRM_SUCCESS      - Success
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EST_SlotWrite (
    __inout                       DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                          DRM_DWORD              f_cbData,
    __in_bcount( f_cbData ) const DRM_BYTE              *f_pbData,
    __out_opt                     DRM_DWORD             *f_pcbWritten )
{
    DRM_RESULT            dr               = DRM_SUCCESS;
    DRM_EST_SLOT_CONTEXT *poESTSlotContext = ( DRM_EST_SLOT_CONTEXT * )f_pContextSlot;
    DRM_EST_CONTEXT      *poESTContext     = NULL;
    DRM_DWORD             ibCurr           = 0;
    DRM_DWORD             cbWritten        = f_cbData;

    ChkArg( f_pContextSlot != NULL );
    ChkArg( f_pbData       != NULL );
    ChkArg( poESTSlotContext->m_fSlotOpen );
    ChkArg( poESTSlotContext->m_poESTNSContext != NULL );
    ChkArg( poESTSlotContext->m_poESTNSContext->m_poESTContext != NULL );

    /*
    ** Write to data store:
    */
    poESTContext = poESTSlotContext->m_poESTNSContext->m_poESTContext;
    ibCurr = poESTSlotContext->m_oSlotLocation.m_ibOffset + DRM_EST_SLOTHEADER_LEN + poESTSlotContext->m_ibSeekPtr;

    if ( ibCurr + cbWritten > poESTSlotContext->m_oSlotLocation.m_ibOffset + poESTSlotContext->m_oSlotLocation.m_cbSlotLen )
    {
        cbWritten = poESTSlotContext->m_oSlotLocation.m_ibOffset + poESTSlotContext->m_oSlotLocation.m_cbSlotLen - ibCurr;
    }
    DRM_BYT_CopyBytes( poESTContext->m_pbEmbeddedStore, ibCurr, f_pbData, 0, cbWritten );

    poESTSlotContext->m_ibSeekPtr += cbWritten;

    if ( f_pcbWritten != NULL )
    {
        *f_pcbWritten = cbWritten;
    }
    poESTContext->m_fIsDirty = TRUE;

ErrorExit:
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmexpreval.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmexpreval.h>
#include "drmexprfunc.h"

ENTER_PK_NAMESPACE_CODE;

/* Operators we don't care to support anymore: */
/* ++, --, %, unary +, unary - */
/* maybe ! */

/* Supported functions */
/* exists, dateadd, datediff, datepart, min, max, long */
/* string, versioncompare, datetime, index, length, deletelicense */


static DRM_RESULT PerformOperation(
    TOKEN             *pOperator,
    EXPR_EVAL_CONTEXT *pEEContext);

/* Stub'd functions */
static DRM_NO_INLINE DRM_RESULT EvalVariable(
    TOKEN             *pToken,
    EXPR_EVAL_CONTEXT *pEEContext)
{
    TOKEN Token;
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDR( pEEContext->GetVariable( &(pToken->val.stringValue), &Token, pEEContext->pvOpaqueData ) );
    MEMCPY( pToken, &Token, SIZEOF( TOKEN ) );

ErrorExit:
    return dr;
}

static DRM_NO_INLINE DRM_BOOL IsOperand(DRM_EXPR_TOKEN_TYPE TokenType)
{
    return ( 
        TokenType == TOKEN_VARIABLE ||
        TokenType == TOKEN_STRING   ||
        TokenType == TOKEN_LONG     ||
        TokenType == TOKEN_DATETIME
        );
}

static DRM_BOOL IsPreUnaryOp(DRM_EXPR_TOKEN_TYPE TokenType)
{
    return ( 
        TokenType == TOKEN_PLUS     ||
        TokenType == TOKEN_MINUS    ||
        TokenType == TOKEN_NOT      ||
        TokenType == TOKEN_PREINCR  ||
        TokenType == TOKEN_PREDECR  ||
        TokenType == TOKEN_FUNCTION
        );
}

static DRM_NO_INLINE DRM_BOOL IsBinaryOp( DRM_EXPR_TOKEN_TYPE TokenType)
{
    return ( 
        TokenType == TOKEN_ADD     ||
        TokenType == TOKEN_SUB     ||
        TokenType == TOKEN_MUL     ||
        TokenType == TOKEN_DIV     ||
        TokenType == TOKEN_MOD     ||
        TokenType == TOKEN_ASSIGN  ||
        TokenType == TOKEN_LESS    ||
        TokenType == TOKEN_LESSEQ  ||
        TokenType == TOKEN_GREAT   ||
        TokenType == TOKEN_GREATEQ ||
        TokenType == TOKEN_NOTEQ   ||
        TokenType == TOKEN_EQ      ||
        TokenType == TOKEN_AND     ||
        TokenType == TOKEN_OR      ||
        TokenType == TOKEN_IF      ||
        TokenType == TOKEN_COLON   ||
        TokenType == TOKEN_COMMA   ||
        TokenType == TOKEN_SEMICOLON
        );
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL ExtractStringToken( 
    DRM_CONST_STRING *pdstrExpression,
    TOKEN            *pToken )
{
    DRM_RESULT dr = DRM_SUCCESS;    
    const DRM_WCHAR* pwcStart = NULL;

    pwcStart = pdstrExpression->pwszString;       /* Now we are at the start of a token. */
    /* Loop until matching one is found. Don't forget escape symbol \. */
    /* First we need to keep track of the count to allocate space.         */
    while( pdstrExpression->cchString && *(pdstrExpression->pwszString) != g_wchQuote && *(pdstrExpression->pwszString) != g_wchNewLine ) 
    { 

        if (*(pdstrExpression->pwszString) == g_wchBackSlash && pdstrExpression->cchString > 1)
        {
            /* Escape character followed by a non-null character. */
            pdstrExpression->pwszString += 2;
            pdstrExpression->cchString  -= 2;
        }
        else
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString --;            
        }
    }
    if ( *(pdstrExpression->pwszString) != g_wchQuote)
    {
        dr = CPRMEXP_STRING_UNTERMINATED;
        goto ErrorExit;
    }

    /* Skip the ending quote.          */
    pToken->val.stringValue.pwszString = pwcStart;
    pToken->val.stringValue.cchString = (DRM_DWORD) ( pdstrExpression->pwszString - pwcStart );

    pdstrExpression->pwszString++;
    pdstrExpression->cchString--;

ErrorExit:
    return dr;

}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL ExtractLongToken( 
    DRM_CONST_STRING *pdstrExpression, 
    TOKEN            *pToken )
{
    DRM_RESULT  dr           = DRM_SUCCESS;
    DRM_BOOL    bSkipRest    = FALSE;
    DRM_BOOL    bHexNumber   = FALSE;
    DRM_LONG    lBase        = 10;
    DRM_LONG    lNextDigit   = 0;
    DRM_UINT    iHexCount    = 0;    

    pToken->TokenType = TOKEN_LONG;
    
    if ( *(pdstrExpression->pwszString) == g_wch0 )
    {
        /* Check if it is a hex number. */
        if ( pdstrExpression->cchString > 1 && 
            ( *(pdstrExpression->pwszString +1 ) == g_wchx || *(pdstrExpression->pwszString +1 ) == g_wchX ) )
        {
            lBase = 16;
            bHexNumber = TRUE;
            pdstrExpression->pwszString += 2;
            pdstrExpression->cchString -= 2;
            pToken->val.lValue = 0;
            if ( pdstrExpression->cchString > 0 && !DRMCRT_iswxdigit( *( pdstrExpression->pwszString ) ) )
            {
                dr = CPRMEXP_INVALID_CONSTANT;
                goto ErrorExit;
            }
        }
        else
        {
            pToken->val.lValue = 0;
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
        }
    }
    else if ( !DRMCRT_iswdigit( *( pdstrExpression->pwszString ) ) )
    {
        dr = CPRMEXP_INVALID_CONSTANT;
        goto ErrorExit;
    }
    else
    {
        pToken->val.lValue = ( NATIVE_WCHAR(*(pdstrExpression->pwszString)) - NATIVE_WCHAR(g_wch0));
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
    }

    while( pdstrExpression->cchString > 0 && 
            ( DRMCRT_iswdigit( *( pdstrExpression->pwszString ) ) || 
                ( bHexNumber && DRMCRT_iswxdigit( *(pdstrExpression->pwszString) ) ) 
            ) 
         )
    {

        if (DRMCRT_iswdigit( *(pdstrExpression->pwszString) ) )
        {
            lNextDigit = (NATIVE_WCHAR(*(pdstrExpression->pwszString)) - NATIVE_WCHAR(g_wch0));
        }
        else
        {
            lNextDigit = (NATIVE_WCHAR(DRMCRT_towlower(*(pdstrExpression->pwszString))) - NATIVE_WCHAR(g_wcha)) + 10;
        }
        if (!bSkipRest && bHexNumber && iHexCount < (SIZEOF(DRM_LONG)*CHAR_BIT)/4)
        {
            iHexCount++;
            pToken->val.lValue = (pToken->val.lValue << 4) | lNextDigit; 
        }
        else if (!bSkipRest && !bHexNumber && pToken->val.lValue <= ((LONG_MAX - lNextDigit) / lBase) )
        {
            pToken->val.lValue = lBase * pToken->val.lValue + lNextDigit;
        }
        else if (!bSkipRest)
        {
            bSkipRest = TRUE; /* To ensure that this part is done only once per integer. */
            /* Must be overflow. Flag it for error. */
            dr = CPRMEXP_OVERFLOW;
            /* Continue to process the integer to consume the rest of the digits. */
        }
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
    }

    if( pdstrExpression->cchString == 0 && bHexNumber )
    {
        /* 
           There is a case that if the entire string ends with "... 0x" we could let 0x be treated as a valid number 0.  
           Just make sure this doesn't happen
        */
        /* It is also safe to reference the string pointer -1 because we know we have seen at least the 0x characters */
        if( *(pdstrExpression->pwszString - 1 ) == g_wchx || 
            *(pdstrExpression->pwszString - 1 ) == g_wchX   )
        {
            /* The last character was an x or X */
            dr = CPRMEXP_INVALID_CONSTANT;
            goto ErrorExit;
        }
    }

ErrorExit:
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL ExtractSymbolToken( 
    DRM_CONST_STRING *pdstrExpression,
    TOKEN            *pToken )
{
    const DRM_WCHAR* pwcStart    = NULL;
    DRM_RESULT dr = DRM_SUCCESS;

    pwcStart = pdstrExpression->pwszString;
    while ( pdstrExpression->cchString > 0 &&
            ( DRMCRT_iswalpha( *(pdstrExpression->pwszString) ) || 
            DRMCRT_iswdigit( *(pdstrExpression->pwszString) ) || 
            *(pdstrExpression->pwszString)== g_wchPeriod || 
            *(pdstrExpression->pwszString)== g_wchUnderscore) )
    {
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
    }

    pToken->val.stringValue.pwszString = pwcStart;
    pToken->val.stringValue.cchString = (DRM_DWORD) ( pdstrExpression->pwszString - pwcStart );

    /* Check if it is a function symbol or a variable */
    /* Function symbol must follow (. Look ahead for (.     */
    while ( pdstrExpression->cchString > 0 &&
            DRMCRT_iswspace(*(pdstrExpression->pwszString ) ) )
    {
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
    }
    if ( pdstrExpression->cchString > 0 && *(pdstrExpression->pwszString) == g_wchOpenParen )
    {        
        if (IsValidFunction(&(pToken->val.stringValue), &( pToken->val.fnValue ) ) )
        {
            pToken->TokenType = TOKEN_FUNCTION;     
        }
        else
        {
            dr = CPRMEXP_INVALID_FUNCTION;                
        }
    }
    else
    {
        pToken->TokenType = TOKEN_VARIABLE;
    }

    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL ExtractDateToken( 
    DRM_CONST_STRING *pdstrExpression,
    TOKEN            *pToken)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRMSYSTEMTIME Date;
    DRMFILETIME   filetime;

    ZEROMEM(&Date, SIZEOF(Date));
    if( pdstrExpression->cchString < 11 ) /* Minimum of 11 characters */
    {
        return DRM_E_INVALIDARG;
    }

    pToken->TokenType = TOKEN_DATETIME;

    if ( *(pdstrExpression->pwszString) != g_wchPound)
    {
        dr = CPRMEXP_INVALID_CONSTANT;
        goto ErrorExit;
    }    
    
    pdstrExpression->pwszString++; /*Consume # */
    pdstrExpression->cchString--;

    if ( DRMCRT_iswdigit(*(pdstrExpression->pwszString)) && 
         DRMCRT_iswdigit(*(pdstrExpression->pwszString+1)) && 
         DRMCRT_iswdigit(*(pdstrExpression->pwszString+2)) && 
         DRMCRT_iswdigit(*(pdstrExpression->pwszString+3)) )
    {
        /* We got YYYY             */
        Date.wYear = ( NATIVE_WCHAR(*(pdstrExpression->pwszString  )) - NATIVE_WCHAR(g_wch0)) * 1000 + 
                     ( NATIVE_WCHAR(*(pdstrExpression->pwszString+1)) - NATIVE_WCHAR(g_wch0)) * 100 + 
                     ( NATIVE_WCHAR(*(pdstrExpression->pwszString+2)) - NATIVE_WCHAR(g_wch0)) * 10 +
                     ( NATIVE_WCHAR(*(pdstrExpression->pwszString+3)) - NATIVE_WCHAR(g_wch0));
        pdstrExpression->pwszString += 4;
        pdstrExpression->cchString -= 4;
    }
    else
    {
        dr = CPRMEXP_INVALID_CONSTANT;
        goto ErrorExit;
    }

    /* Next we should have MM */
    if ( DRMCRT_iswdigit( *(pdstrExpression->pwszString) ) && DRMCRT_iswdigit( *(pdstrExpression->pwszString+1) ) )
    {
        /* We got MM */
        Date.wMonth = ( NATIVE_WCHAR(*(pdstrExpression->pwszString  )) - NATIVE_WCHAR(g_wch0) ) * 10 +
                      ( NATIVE_WCHAR(*(pdstrExpression->pwszString+1)) - NATIVE_WCHAR(g_wch0) );
        pdstrExpression->pwszString += 2;
        pdstrExpression->cchString -= 2;
    }
    else
    {
        dr = CPRMEXP_INVALID_CONSTANT;
        goto ErrorExit;
    }
    /* Next we should have DD */
    if ( DRMCRT_iswdigit( *(pdstrExpression->pwszString) ) && DRMCRT_iswdigit( *(pdstrExpression->pwszString+1) ) )
    {
        /* We got DD */
        Date.wDay = ( NATIVE_WCHAR(*(pdstrExpression->pwszString  )) - NATIVE_WCHAR(g_wch0) ) * 10 + 
                    ( NATIVE_WCHAR(*(pdstrExpression->pwszString+1)) - NATIVE_WCHAR(g_wch0) );            
        pdstrExpression->pwszString += 2;
        pdstrExpression->cchString -= 2;
    }
    else
    {
        dr = CPRMEXP_INVALID_CONSTANT;
        goto ErrorExit;
    }
    /* Now we expect a space or Z */
    if ( *(pdstrExpression->pwszString) != g_wchSpace && *(pdstrExpression->pwszString) != g_wchZ )
    {
        dr = CPRMEXP_INVALID_CONSTANT;
    }
    else
    {
        if (*(pdstrExpression->pwszString) == g_wchSpace)
        {            
            pdstrExpression->pwszString++; /* If it was a space, skip. */
            pdstrExpression->cchString--;
        }
        /* Now we expect optional time fields */
        if ( pdstrExpression->cchString > 2 &&
            DRMCRT_iswdigit(*(pdstrExpression->pwszString)) && 
            DRMCRT_iswdigit(*(pdstrExpression->pwszString+1)) )
        {
            /* We got HH. */
            Date.wHour =  (NATIVE_WCHAR(*(pdstrExpression->pwszString  )) - NATIVE_WCHAR(g_wch0)) * 10 
                         +(NATIVE_WCHAR(*(pdstrExpression->pwszString+1)) - NATIVE_WCHAR(g_wch0));            
            pdstrExpression->pwszString += 2;
            pdstrExpression->cchString -= 2;
            /* We look for :MM only if we got HH */
            if ( pdstrExpression->cchString >3 &&
                *(pdstrExpression->pwszString) == g_wchColon && 
                DRMCRT_iswdigit(*(pdstrExpression->pwszString+1)) && 
                DRMCRT_iswdigit(*(pdstrExpression->pwszString+2)) )
            {
                Date.wMinute = (NATIVE_WCHAR(*(pdstrExpression->pwszString+1)) - NATIVE_WCHAR(g_wch0)) * 10 
                             + (NATIVE_WCHAR(*(pdstrExpression->pwszString+2)) - NATIVE_WCHAR(g_wch0));
                pdstrExpression->pwszString += 3;
                pdstrExpression->cchString -=3;
                /* We look for :SS only if we got MM */
                if (pdstrExpression->cchString >3 &&
                    *(pdstrExpression->pwszString) == g_wchColon && 
                    DRMCRT_iswdigit(*(pdstrExpression->pwszString+1)) && 
                    DRMCRT_iswdigit(*(pdstrExpression->pwszString+2)) )
                {
                    Date.wSecond = (NATIVE_WCHAR(*(pdstrExpression->pwszString+1)) - NATIVE_WCHAR(g_wch0)) * 10 
                                 + (NATIVE_WCHAR(*(pdstrExpression->pwszString+2)) - NATIVE_WCHAR(g_wch0));
                    pdstrExpression->pwszString += 3;
                    pdstrExpression->cchString -=3;
                }                
            }
        }
        /* Now we must see the closing Z# symbols */
        if ( pdstrExpression->cchString <2 || *(pdstrExpression->pwszString) != g_wchZ)
        {
            dr = CPRMEXP_INVALID_CONSTANT;
            goto ErrorExit;
        }
        pdstrExpression->pwszString++; /* Consume Z */
        pdstrExpression->cchString--;
        if (*(pdstrExpression->pwszString) != g_wchPound)
        {
            dr = CPRMEXP_INVALID_CONSTANT;
            goto ErrorExit;
        }
        pdstrExpression->pwszString++; /* Consume # */
        pdstrExpression->cchString--;
    }
    if (!Oem_Clock_SystemTimeToFileTime(&Date, &filetime))
    {
        dr = CPRMEXP_INVALID_CONSTANT; /* One or more fields in the date must be invalid. */
        goto ErrorExit;
    }
    FILETIME_TO_UI64( filetime, pToken->val.u64DateTime );
ErrorExit:
    return dr;
}

static DRM_NO_INLINE DRM_RESULT GetToken( 
    DRM_CONST_STRING    *pdstrExpression,
    TOKEN               *pToken, 
    DRM_EXPR_TOKEN_TYPE *psLastToken)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BOOL fFound;    

    /* Skip whitespace */
    while ( pdstrExpression->cchString && DRMCRT_iswspace(*(pdstrExpression->pwszString)))
    {
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
    }

    if ( pdstrExpression->cchString == 0 )
    {
        /* We are at the end of buffer. No more args. */
        dr = DRM_E_NOMORE;
        goto ErrorExit;
    }

    fFound = TRUE;
    if( *(pdstrExpression->pwszString) == g_wchOpenParen )
    {
        (*pToken).TokenType = TOKEN_OPEN;
    }
    else if( *(pdstrExpression->pwszString) == g_wchCloseParen )
    {
        (*pToken).TokenType = TOKEN_CLOSE;
    }
    else if( *(pdstrExpression->pwszString) == g_wchComma )
    {
        (*pToken).TokenType = TOKEN_COMMA;
    }
    else if( *(pdstrExpression->pwszString) == g_wchAsterisk)
    {
        (*pToken).TokenType = TOKEN_MUL;
    }
    else if( *(pdstrExpression->pwszString) == g_wchForwardSlash )
    {
        (*pToken).TokenType = TOKEN_DIV;
    }
    else if( *(pdstrExpression->pwszString) == g_wchPercent )
    {
        (*pToken).TokenType = TOKEN_MOD;
    }
    else if( *(pdstrExpression->pwszString) == g_wchColon )
    {
        (*pToken).TokenType = TOKEN_COLON;
    }
    else if( *(pdstrExpression->pwszString) == g_wchQuestionMark )
    {
        (*pToken).TokenType = TOKEN_IF;
    }
    else if( *(pdstrExpression->pwszString) == g_wchSemiColon )
    {
        (*pToken).TokenType = TOKEN_SEMICOLON;
    }
    else if( *(pdstrExpression->pwszString) == g_wchExclamationMark )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchEqual )
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            (*pToken).TokenType = TOKEN_NOTEQ;
        }
        else
        {
            (*pToken).TokenType = TOKEN_NOT;
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchEqual )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchEqual )
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            (*pToken).TokenType = TOKEN_EQ;
        }
        else
        {
            (*pToken).TokenType = TOKEN_ASSIGN;
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchLessThan )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchEqual )
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            (*pToken).TokenType = TOKEN_LESSEQ;
        }
        else
        {
            (*pToken).TokenType = TOKEN_LESS;
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchGreaterThan )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchEqual )
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            (*pToken).TokenType = TOKEN_GREATEQ;
        }
        else
        {
            (*pToken).TokenType = TOKEN_GREAT;
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchAmpersand )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchAmpersand )
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            (*pToken).TokenType = TOKEN_AND;
        }
        else
        {
            (*pToken).TokenType = TOKEN_UNKNOWN;
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchPipe )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchPipe )
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            (*pToken).TokenType = TOKEN_OR;
        }
        else
        {
            (*pToken).TokenType = TOKEN_UNKNOWN;
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchPlus )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchPlus )
        {
            /* It is an increment operator. Determine if it is pre or post. */
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            if (*psLastToken == TOKEN_VARIABLE || *psLastToken == TOKEN_CLOSE) 
            {
                (*pToken).TokenType = TOKEN_POSTINCR;
            }
            else
            {
                (*pToken).TokenType = TOKEN_PREINCR;
            }                     
        }
        else if (*psLastToken == TOKEN_LONG || *psLastToken == TOKEN_STRING || *psLastToken == TOKEN_DATETIME || 
            *psLastToken == TOKEN_VARIABLE || *psLastToken == TOKEN_CLOSE ||
            *psLastToken == TOKEN_POSTINCR || *psLastToken == TOKEN_POSTDECR)
        {
            (*pToken).TokenType = TOKEN_ADD;    /* Binary operator */
        }
        else
        {
            (*pToken).TokenType = TOKEN_PLUS; /*Unary operator */
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchMinus )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchMinus )
        {
            /* It is an increment operator. Determine if it is pre or post. */
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            if (*psLastToken == TOKEN_VARIABLE || *psLastToken == TOKEN_CLOSE) 
            {
                (*pToken).TokenType = TOKEN_POSTDECR;
            }
            else
            {
                (*pToken).TokenType = TOKEN_PREDECR;
            }                     
        }
        else if (*psLastToken == TOKEN_LONG || *psLastToken == TOKEN_STRING || *psLastToken == TOKEN_DATETIME || 
            *psLastToken == TOKEN_VARIABLE || *psLastToken == TOKEN_CLOSE ||
            *psLastToken == TOKEN_POSTINCR || *psLastToken == TOKEN_POSTDECR)
        {
            (*pToken).TokenType = TOKEN_SUB;    /* Binary operator */
        }
        else
        {
            (*pToken).TokenType = TOKEN_MINUS; /*Unary operator */
        }
    }
    else
    {
        fFound = FALSE;
    }

    if( fFound )
    {
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
        goto ErrorExit;
    }

    /* We have not identified this token yet -- it's obviously not an operator.  Let's see if we can figure 
    it out */   

    if (*(pdstrExpression->pwszString) == g_wchQuote) 
    { 
        /* String Constant */
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
        dr = ExtractStringToken( pdstrExpression, pToken );
        (*pToken).TokenType = TOKEN_STRING;
    } 
    else if (DRMCRT_iswdigit(*(pdstrExpression->pwszString)))
    {
        (*pToken).TokenType = TOKEN_LONG;
        dr = ExtractLongToken( pdstrExpression, pToken );
    }
    else if (DRMCRT_iswalpha(*(pdstrExpression->pwszString)))
    {
        /* This could be either a function or a variable */
        dr = ExtractSymbolToken( pdstrExpression, pToken );
    }
    else if (*(pdstrExpression->pwszString) == g_wchPound)
    {        
        dr = ExtractDateToken( pdstrExpression, pToken);
        (*pToken).TokenType = TOKEN_DATETIME;
    }
    else
    {
        /* This must be an invalid character. */
        dr = CPRMEXP_INVALID_TOKEN;
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
    }

ErrorExit:
    *psLastToken = (DRM_EXPR_TOKEN_TYPE)((*pToken).TokenType);
    return (dr);
}


static DRM_NO_INLINE DRM_LONG InputPrecedence(DRM_EXPR_TOKEN_TYPE tokenType)
{
    switch(tokenType)
    {
    case TOKEN_OPEN:
        return(1000);
    case TOKEN_CLOSE:
        return(0);
    case TOKEN_FUNCTION:
        return(300);
    case TOKEN_POSTINCR:
    case TOKEN_POSTDECR:
        return(220);
    case TOKEN_NOT:
    case TOKEN_PREINCR:
    case TOKEN_PREDECR:
    case TOKEN_PLUS:
    case TOKEN_MINUS:
        return(200);
    case TOKEN_MUL:
    case TOKEN_DIV:
    case TOKEN_MOD:
        return(180);
    case TOKEN_ADD:
    case TOKEN_SUB:
        return(160);
    case TOKEN_LESS:
    case TOKEN_GREAT:
    case TOKEN_LESSEQ:
    case TOKEN_GREATEQ:
        return(140);
    case TOKEN_EQ:
    case TOKEN_NOTEQ:
        return(120);
    case TOKEN_AND:
        return(100);
    case TOKEN_OR:
        return(80);
    case TOKEN_IF:
        return(60);
    case TOKEN_COLON:
        return(25);               
    case TOKEN_ASSIGN:
        return(50);
    case TOKEN_SEMICOLON:
        return(20);
    case TOKEN_COMMA:
        return(10);
    }
    return (-1000); /* Should not happen. */
}

static DRM_NO_INLINE DRM_LONG StackPrecedence(DRM_EXPR_TOKEN_TYPE tokenType)
{

    switch(tokenType)
    {
    case TOKEN_OPEN:
        return(-1);
    case TOKEN_CLOSE:
        return(0);
    case TOKEN_FUNCTION:
        return(300);
    case TOKEN_POSTINCR:
    case TOKEN_POSTDECR:
        return(220);
    case TOKEN_NOT:
    case TOKEN_PREINCR:
    case TOKEN_PREDECR:
    case TOKEN_PLUS:
    case TOKEN_MINUS:
        return(190);
    case TOKEN_MUL:
    case TOKEN_DIV:
    case TOKEN_MOD:
        return(180);
    case TOKEN_ADD:
    case TOKEN_SUB:
        return(160);
    case TOKEN_LESS:
    case TOKEN_GREAT:
    case TOKEN_LESSEQ:
    case TOKEN_GREATEQ:
        return(140);
    case TOKEN_EQ:
    case TOKEN_NOTEQ:
        return(120);
    case TOKEN_AND:
    case TOKEN_ANDSKIP:
        return(100);
    case TOKEN_OR:
    case TOKEN_ORSKIP:
        return(80);
    case TOKEN_IF:
    case TOKEN_IFSKIP:
        return(22);
    case TOKEN_COLON:
    case TOKEN_COLONSKIP:
        return(25);
    case TOKEN_ASSIGN:
        return(30);
    case TOKEN_SEMICOLON:
        return(20);
    case TOKEN_COMMA:
        return(10);
    }
    return(-1000); /* Should not happen. */
}

static DRM_NO_INLINE DRM_RESULT TokenStackPush( 
    TOKEN      rgTokenStack[],
    DRM_DWORD *pdwStackHead, 
    TOKEN     *pNewToken )
{
    if( *pdwStackHead == DRM_EXPR_EVAL_MAX_TOKEN_STACK_SIZE )
    {
        /* The stack is full.  Fail */
        return DRM_E_OUTOFMEMORY;
    }
    MEMCPY( &(rgTokenStack[*pdwStackHead]), pNewToken, SIZEOF( TOKEN ) );
    *pdwStackHead += 1;
    return DRM_SUCCESS;
}

static DRM_NO_INLINE DRM_RESULT TokenStackPop( 
    TOKEN      rgTokenStack[],
    DRM_DWORD *pdwStackHead, 
    TOKEN     *pNewToken )
{
    if( *pdwStackHead == 0 )
    {
        return CPRMEXP_MISSING_OPERAND;
    }
    *pdwStackHead -= 1;
    MEMCPY( pNewToken, &(rgTokenStack[*pdwStackHead]), SIZEOF( TOKEN ) );
    return DRM_SUCCESS;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_EXPR_EvaluateExpression(
    IN const DRM_CONST_STRING  *pdstrExpression, 
    IN OUT   EXPR_EVAL_CONTEXT *pEEContext, 
       OUT   TOKEN             *ptResult )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrExpression = EMPTY_DRM_STRING;
    TOKEN Token, newToken;
    DRM_EXPR_TOKEN_TYPE sLastToken = TOKEN_UNKNOWN;
    DRM_LONG lRank = 0;        /* Rank will tell us if we have operands to gether without operators or operators that are stranded */
    DRM_LONG lInputPrecedence = 0;   
    
    ChkDRMString( pdstrExpression );
    ChkArg( pEEContext && ptResult );

    ZEROMEM( &(pEEContext->ExprEvalData), SIZEOF( pEEContext->ExprEvalData ) );
    ASSIGN_DRM_STRING( dstrExpression, *pdstrExpression );    
    for( dr = GetToken( &dstrExpression, &Token, &sLastToken ); DRM_SUCCEEDED( dr ); dr = GetToken( &dstrExpression, &Token, &sLastToken ) )
    {        
        if (Token.TokenType == TOKEN_UNKNOWN)
        {
            dr = CPRMEXP_INVALID_TOKEN;
            goto ErrorExit;
        }

        if (IsOperand((DRM_EXPR_TOKEN_TYPE)Token.TokenType))
        {
            lRank++;
        }
        else if (IsBinaryOp((DRM_EXPR_TOKEN_TYPE)Token.TokenType))
        {
            lRank--;
        }
        /* Now check the rank. It should always be 0 or 1 */
        if (lRank != 0 && lRank != 1)
        {            
            dr = CPRMEXP_ISOLATED_OPERAND_OR_OPERATOR;
            goto ErrorExit;
        }

        /* If it is an operand, push onto the operand stack. */
        if (IsOperand((DRM_EXPR_TOKEN_TYPE)Token.TokenType))
        {
            ChkDR( TokenStackPush( pEEContext->ExprEvalData.rgOperandTokenStack, &(pEEContext->ExprEvalData.dwOperandStack), &Token ) );
            ZEROMEM( &Token, SIZEOF( Token ) );
            continue;        
        }
        /* If it is ), then pop all operators of higher precedence in stack and perform operation. */
        if (Token.TokenType == TOKEN_CLOSE)
        {
            lInputPrecedence = InputPrecedence(TOKEN_CLOSE);
            while ( 0 < pEEContext->ExprEvalData.dwOperatorStack && 
                StackPrecedence((DRM_EXPR_TOKEN_TYPE)pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType) >= lInputPrecedence)    /* Loop through operators in the stack and perform the operations if their precedence is right */
            {
                
                ChkDR( TokenStackPop( pEEContext->ExprEvalData.rgOperatorTokenStack, &( pEEContext->ExprEvalData.dwOperatorStack ), &newToken ) );
                ChkDR( PerformOperation(&newToken, pEEContext ) );
                /* &pEEContext->ExprEvalData.rgOperandTokenStack, &pEEContext->ExprEvalData.rgOperatorTokenStack, &fShortCircuit, pEEContext->pvOpaqueData); */
                if (newToken.TokenType == TOKEN_FUNCTION)
                {
                    /* It was a function call. Rand must be 0 or 1. It will be 0 if it was a function call with 0 args.  */
                    /* We need to set rank to 1. */
                    if (Arity((DRM_EXPR_FUNCTION_TYPE)newToken.val.fnValue) == 0)
                    {
                        lRank++;
                    }                    
                }
            }
            if (0 == pEEContext->ExprEvalData.dwOperatorStack || 
                pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType != TOKEN_OPEN)
            {
                dr = CPRMEXP_UNMATCHED;
                goto ErrorExit;
            }

            /* Pop and discard the token TOPEN. Here the stack must be non-empty and has TOPEN. */
            ChkDR( TokenStackPop( pEEContext->ExprEvalData.rgOperatorTokenStack, &( pEEContext->ExprEvalData.dwOperatorStack ), &newToken ) );

            /* Check if the ) we are processing corresponds to the one closing a function call. If so, execute the function. */
            if ( 0 != pEEContext->ExprEvalData.dwOperatorStack)
            {                
                if (pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType == TOKEN_FUNCTION)
                {
                    ChkDR( TokenStackPop( pEEContext->ExprEvalData.rgOperatorTokenStack, &( pEEContext->ExprEvalData.dwOperatorStack ), &newToken ) );
                    dr = PerformOperation(&newToken, pEEContext );
                     /*&pEEContext->ExprEvalData.rgOperandTokenStack, &pEEContext->ExprEvalData.rgOperatorTokenStack, &fShortCircuit, pEEContext->pvOpaqueData); */
                    if( DRM_FAILED( dr ) )
                    {
                        goto ErrorExit;
                    }
                    /* It was a function call. Rank must be 0 or 1. It will be 0 if it was a function call with 0 args.  */
                    /* We need to set rank to 1. */
                    if (Arity((DRM_EXPR_FUNCTION_TYPE)newToken.val.fnValue) == 0)
                    {
                        lRank++;
                    }                    
                }
            }
            ZEROMEM( &Token, SIZEOF( Token ) );
            continue;
        }

        /* It must be an operator or TOKEN_OPEN. Pop all operators of higher precedence and perform op.                 */
        lInputPrecedence = InputPrecedence((DRM_EXPR_TOKEN_TYPE)Token.TokenType);
        while (0 != pEEContext->ExprEvalData.dwOperatorStack && 
            StackPrecedence((DRM_EXPR_TOKEN_TYPE)pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType) >= lInputPrecedence)
        {
            ChkDR( TokenStackPop( pEEContext->ExprEvalData.rgOperatorTokenStack, &( pEEContext->ExprEvalData.dwOperatorStack ), &newToken ) );
            dr = PerformOperation(&newToken, pEEContext );
            if( DRM_FAILED( dr ) )
            {
                goto ErrorExit;
            }
            /* The stackOp cannot be a function symbol here. No need to check for it like in other places. */
        }

        /* Push the new operator onto the stack. Do not delete the token as it lives in stack. */
        /* Take care of && || ? and :.  */
        if ( pEEContext->ExprEvalData.fShortCircuit )
        {
            /* We are in skip mode in this section. */
            /* Simply push the corresponding token. */
            switch(Token.TokenType)
            {
            case TOKEN_AND:
                Token.TokenType = TOKEN_ANDSKIP;
                break;
            case TOKEN_OR:
                Token.TokenType = TOKEN_ORSKIP;
                break;
            case TOKEN_IF:
                Token.TokenType = TOKEN_IFSKIP;
                break;
            case TOKEN_COLON:
                if ( 0 == pEEContext->ExprEvalData.dwOperatorStack || 
                    ( pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType != TOKEN_IF && 
                    pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType != TOKEN_IFSKIP 
                    ) 
                    )
                {                    
                    dr = CPRMEXP_UNMATCHED;
                    goto ErrorExit;
                }
                if (pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType == TOKEN_IF)
                {
                    pEEContext->ExprEvalData.fShortCircuit = FALSE; /* Then part skipping is over. We are at the begining of else part. Turn eval on. */
                    Token.TokenType = TOKEN_COLON;
                }
                else
                {
                    Token.TokenType = TOKEN_COLONSKIP;    /* The matching ? was found in skip mode. */
                }                          
            }
        }
        else
        {
            /* We are in evaluation mode in this section. */
            if (Token.TokenType == TOKEN_AND ||
                Token.TokenType == TOKEN_OR  ||
                Token.TokenType == TOKEN_IF)
            {
                /* Pop an operand and evaluate before proceeding. This is for shortcut or conditional evaluation. */
                dr = TokenStackPop( pEEContext->ExprEvalData.rgOperandTokenStack, &(pEEContext->ExprEvalData.dwOperandStack), &newToken );
                if ( DRM_FAILED( dr ) )
                {
                    dr = CPRMEXP_MISSING_OPERAND;
                    goto ErrorExit;
                }
                if ( newToken.TokenType == TOKEN_VARIABLE)
                {
                    dr = EvalVariable(&newToken, pEEContext);    /* This can change the type of NODE after evaluation */
                    if( DRM_FAILED( dr ) )
                    {
                        goto ErrorExit;
                    }
                }
                if ( newToken.TokenType != TOKEN_LONG )
                {
                    dr = CPRMEXP_WRONG_TYPE_OPERAND;
                    goto ErrorExit;
                }
                if ( ( Token.TokenType == TOKEN_AND && newToken.val.lValue == 0 ) ||
                     ( Token.TokenType == TOKEN_OR  && newToken.val.lValue == 1  ) ||
                     ( Token.TokenType == TOKEN_IF  && newToken.val.lValue == 0  ) )
                {
                    pEEContext->ExprEvalData.fShortCircuit = TRUE;
                }
                ChkDR( TokenStackPush( pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &newToken) );
            }
            else if (Token.TokenType == TOKEN_COLON)
            {
                /* It is ':'. The stack must have matching ?.  */
                if (0 == pEEContext->ExprEvalData.dwOperatorStack || 
                    pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType != TOKEN_IF)
                {                    
                    dr = CPRMEXP_UNMATCHED;
                    goto ErrorExit;
                }
                pEEContext->ExprEvalData.fShortCircuit = TRUE; /* fShortCircuit is FALSE currently. Which means we got then part. We need to skip else part.                 */
            }
        }

        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperatorTokenStack, &( pEEContext->ExprEvalData.dwOperatorStack ), &Token) );
        
        if (Token.TokenType == TOKEN_FUNCTION)
        {
            /* Push TOKEN_FUNCTIONSYNC token into the operand stack.             */
            ZEROMEM( &Token, SIZEOF( TOKEN ) );
            Token.TokenType = TOKEN_FUNCTIONSYNC;
            ChkDR( TokenStackPush( pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &Token) );
        }
        else if (IsPreUnaryOp((DRM_EXPR_TOKEN_TYPE)Token.TokenType))
        {
            /* Push TUNARYSYNC token into the operand stack. */
            ZEROMEM( &Token, SIZEOF( TOKEN ) );
            Token.TokenType = TOKEN_UNARYSYNC;
            ChkDR( TokenStackPush( pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &Token) );
        }
        ZEROMEM( &Token, SIZEOF( Token ) );
    } /* for loop */


    if (dr == DRM_E_NOMORE)
    {
        /* We have a valid expression. Clean up stack and return the result. */
        ChkDR(DRM_SUCCESS); /* This sets 'dr' and keeps the PREfast tool happy. */
        while (0 != pEEContext->ExprEvalData.dwOperatorStack )
        {
            ChkDR( TokenStackPop( pEEContext->ExprEvalData.rgOperatorTokenStack, &(pEEContext->ExprEvalData.dwOperatorStack), &Token) );
            ChkDR( PerformOperation(&Token, pEEContext ) );
            /* ->ExprEvalData.rgOperandTokenStack, &pEEContext->ExprEvalData.rgOperatorTokenStack, &fShortCircuit, pEEContext->pvOpaqueData)); */
            if ( Token.TokenType == TOKEN_FUNCTION )
            {
                /* It was a function call. Rand must be 0 or 1. It will be 0 if it was a function call with 0 args.  */
                /* We need to set rank to 1. */
                if (Arity((DRM_EXPR_FUNCTION_TYPE)Token.val.fnValue) == 0)
                {
                    lRank++;
                }                    
            }
        }
        if ( 0 == pEEContext->ExprEvalData.dwOperandStack )
        {
            dr = CPRMEXP_NO_OPERANDS_IN_EXPRESSION;
            goto ErrorExit;
        }

        ChkDR( TokenStackPop( pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &Token) );        

        if ( 0 != pEEContext->ExprEvalData.dwOperandStack )
        {
            dr = CPRMEXP_TOO_MANY_OPERANDS;
            goto ErrorExit;
        }

        /* At the end, lRank should be 1 for a valid expression. */
        if (lRank != 1)
        {
            dr = CPRMEXP_ISOLATED_OPERAND_OR_OPERATOR;
            goto ErrorExit;
        }

        /* At the end if the token is a variable, evaluate it and return that value */
        if (Token.TokenType == TOKEN_VARIABLE)
        {
            ChkDR( EvalVariable( &Token, pEEContext ) );
        }

        /* Examine the value of the node at this point.         */
        MEMCPY( ptResult, &Token, SIZEOF( TOKEN ) );
    }

ErrorExit:
    return dr;
}


/* PerformOperation & EvalVariable ( this is a big one with the different types of variables we might have. ) */

/* Peform the operation passed in the token. Do not delete the token. */
/* Stack of operands gets affected. Stack of operators may also get affected. */
/* This function can change operand stack, operator stack, state of fShortCircuit, will also need access to the expression string. */
DRM_NO_INLINE DRM_RESULT PerformOperation(TOKEN *pOperator, EXPR_EVAL_CONTEXT* pEEContext)
{
    DRM_RESULT dr = DRM_SUCCESS;/*vinceyu:replaced CPRMEXP_NOERROR */
    TOKEN Operand1;
    TOKEN Operand2;    
    TOKEN OperandResult;    
    DRM_INT64 i64Value;
    
    ZEROMEM( &OperandResult, SIZEOF( TOKEN ) );
    OperandResult.TokenType = TOKEN_LONG;        
    switch(pOperator->TokenType)
    {
    case TOKEN_PLUS:
    case TOKEN_MINUS:
    case TOKEN_NOT:
        /* Unary operator. Pop one operand, perform operation, and push result back. */
        /* We should have TUNARYSYNC followed by operand. */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );
        if (Operand1.TokenType == TOKEN_UNARYSYNC || Operand1.TokenType == TOKEN_FUNCTIONSYNC)
        {
            dr = CPRMEXP_MISSING_OPERAND;
            goto ErrorExit;
        }

        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
        if (Operand2.TokenType != TOKEN_UNARYSYNC)
        {
            dr = CPRMEXP_UNKNOWN_PARSE_ERROR; /* This should not really happen. */
            goto ErrorExit;        
        }

        if (!pEEContext->ExprEvalData.fShortCircuit)
        {
            /* Do the actual evaluation */
            if (Operand1.TokenType == TOKEN_VARIABLE)
            {
                ChkDR( EvalVariable( &Operand1, pEEContext) );
            }
            if ( Operand1.TokenType != TOKEN_LONG)
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }

            OperandResult.val.lValue = Operand1.val.lValue;
            if (pOperator->TokenType == TOKEN_MINUS)
            {
                i64Value = DRM_I64Sub(DRM_I64(0), DRM_I64(OperandResult.val.lValue) );

                if ( DRM_I64Les( DRM_I64(LONG_MAX), i64Value ) )
                {
                    dr = CPRMEXP_OVERFLOW;
                    goto ErrorExit;
                }
                else if ( DRM_I64Les( i64Value, DRM_I64(LONG_MIN)) )
                {
                    dr = CPRMEXP_UNDERFLOW;
                    goto ErrorExit;
                }
                OperandResult.val.lValue = DRM_I64ToUI32(i64Value);
            }
            else if (pOperator->TokenType == TOKEN_NOT)
            {
                OperandResult.val.lValue = !(OperandResult.val.lValue != 0);
            }
        }
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
    case TOKEN_ADD:
    case TOKEN_SUB:
    case TOKEN_MUL:
    case TOKEN_DIV:
    case TOKEN_MOD:
        /* Binary arithmetic operators. TADD can also be used for strings. */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );

        if (!pEEContext->ExprEvalData.fShortCircuit)
        {
            /* Perform the operation on the two operands and produce result. */
            if (Operand1.TokenType == TOKEN_VARIABLE)
            {
                ChkDR(EvalVariable(&Operand1, pEEContext));
            }
            if (Operand2.TokenType == TOKEN_VARIABLE)
            {
                ChkDR(EvalVariable(&Operand2, pEEContext));
            }
            if ( pOperator->TokenType != TOKEN_ADD && 
                ( Operand2.TokenType != TOKEN_LONG || Operand1.TokenType != TOKEN_LONG) )
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
            else if (pOperator->TokenType == TOKEN_ADD && 
                !(
                (Operand2.TokenType == TOKEN_LONG && Operand1.TokenType == TOKEN_LONG) ||
                (Operand2.TokenType == TOKEN_STRING && Operand1.TokenType == TOKEN_STRING)
                )
                )

            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
            switch(pOperator->TokenType)
            {
            case TOKEN_ADD:
                if (Operand2.TokenType == TOKEN_LONG)
                {
                    i64Value = DRM_I64Add( DRM_I64(Operand1.val.lValue), DRM_I64(Operand2.val.lValue) );

                    if ( DRM_I64Les( DRM_I64(LONG_MAX), i64Value ) )
                    {
                        dr = CPRMEXP_OVERFLOW;
                        goto ErrorExit;
                    }
                    else if ( DRM_I64Les( i64Value, DRM_I64(LONG_MIN) ) )
                    {
                        dr = CPRMEXP_UNDERFLOW;
                        goto ErrorExit;
                    }
                    OperandResult.val.lValue = DRM_I64ToUI32(i64Value);
                }
                else
                {
                    dr = CPRMEXP_WRONG_TYPE_OPERAND;
                    goto ErrorExit;
                }

                break;
            case TOKEN_SUB:
                i64Value = DRM_I64Sub( DRM_I64(Operand1.val.lValue), DRM_I64(Operand2.val.lValue) );
                if ( DRM_I64Les( DRM_I64(LONG_MAX), i64Value ) )
                {
                    dr = CPRMEXP_OVERFLOW;
                    goto ErrorExit;
                }
                else if ( DRM_I64Les( i64Value, DRM_I64(LONG_MIN) ) )
                {
                    dr = CPRMEXP_UNDERFLOW;
                    goto ErrorExit;
                }
                OperandResult.val.lValue = DRM_I64ToUI32(i64Value);
                break;
            case TOKEN_MUL:
                i64Value = DRM_I64Mul( DRM_I64(Operand1.val.lValue), DRM_I64(Operand2.val.lValue) );
                if ( DRM_I64Les( DRM_I64(LONG_MAX), i64Value ) )
                {
                    dr = CPRMEXP_OVERFLOW;
                    goto ErrorExit;
                }
                else if ( DRM_I64Les( i64Value, DRM_I64(LONG_MIN) ) )
                {
                    dr = CPRMEXP_UNDERFLOW;
                    goto ErrorExit;
                }
                OperandResult.val.lValue = DRM_I64ToUI32(i64Value);
                break;
            case TOKEN_DIV:
                if (Operand2.val.lValue == 0)
                {
                    dr = CPRMEXP_OVERFLOW;
                    goto ErrorExit;
                }
                OperandResult.val.lValue = Operand1.val.lValue / Operand2.val.lValue;
                break;
            case TOKEN_MOD:
                if (Operand2.val.lValue == 0)
                {
                    dr = CPRMEXP_OVERFLOW;
                    goto ErrorExit;
                }
                OperandResult.val.lValue = Operand1.val.lValue % Operand2.val.lValue;
            }
        }
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
    case TOKEN_PREINCR:
    case TOKEN_POSTINCR:
    case TOKEN_PREDECR:
    case TOKEN_POSTDECR:
        /* Unary increment or decrement operator. */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );

        if (pOperator->TokenType == TOKEN_PREINCR || pOperator->TokenType == TOKEN_PREDECR)
        {
            if (pOperator->TokenType == TOKEN_UNARYSYNC || pOperator->TokenType == TOKEN_FUNCTIONSYNC)
            {
                dr = CPRMEXP_MISSING_OPERAND;
                goto ErrorExit;
            }
            ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
            if (Operand2.TokenType != TOKEN_UNARYSYNC)
            {
                dr = CPRMEXP_UNKNOWN_PARSE_ERROR;
                goto ErrorExit;        
            }
        }

        if (!pEEContext->ExprEvalData.fShortCircuit)
        {
            /* The operand must be a varialble that can be set. */
            if (Operand1.TokenType != TOKEN_VARIABLE)
            {
                dr = CPRMEXP_VARIABLE_EXPECTED;
                goto ErrorExit;
            }            
            
            ZEROMEM( &Operand2, SIZEOF( TOKEN ) );

            ChkDR( pEEContext->GetVariable( &(Operand1.val.stringValue), &Operand2, pEEContext->pvOpaqueData ) );
            if (Operand2.TokenType != TOKEN_LONG)
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }          
            OperandResult.val.lValue = Operand2.val.lValue; /* For preincr or predecr. */
            /* Perform the incr or decr operation on the variable. */
            if (pOperator->TokenType == TOKEN_PREINCR || pOperator->TokenType == TOKEN_POSTINCR)
            {
                i64Value = DRM_I64Add( DRM_I64(Operand2.val.lValue), DRM_I64(1) );
            }
            else
            {
                i64Value = DRM_I64Sub( DRM_I64(Operand2.val.lValue), DRM_I64(1) );
            }
            if ( DRM_I64Les( DRM_I64(LONG_MAX), i64Value ) )
            {
                dr = CPRMEXP_OVERFLOW;
                goto ErrorExit;
            }
            else if ( DRM_I64Les( i64Value, DRM_I64(LONG_MIN) ) )
            {
                dr = CPRMEXP_UNDERFLOW;
                goto ErrorExit;
            }
            Operand2.val.lValue = DRM_I64ToUI32(i64Value);
            if (pOperator->TokenType == TOKEN_PREINCR || pOperator->TokenType == TOKEN_PREDECR)
            {
                OperandResult.val.lValue = Operand2.val.lValue;
            }
            ChkDR( pEEContext->SetVariable( &(Operand1.val.stringValue), &Operand2, NULL, pEEContext->pvOpaqueData) );
        }
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
    case TOKEN_ASSIGN:
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );  /* The right side operand of = */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );  /* The left side operand (i.e variable) of = */

        /* The operand must be a varialble that can be set. */
        if (Operand1.TokenType != TOKEN_VARIABLE)
        {
            dr = CPRMEXP_VARIABLE_EXPECTED;
            goto ErrorExit;
        }        
        if (!pEEContext->ExprEvalData.fShortCircuit)
        {
            if (Operand2.TokenType == TOKEN_VARIABLE)
            {
                ChkDR(EvalVariable(&Operand2, pEEContext));
            }

            ZEROMEM( &OperandResult, SIZEOF( TOKEN ) );
            ChkDR( pEEContext->SetVariable( &(Operand1.val.stringValue), &Operand2, &OperandResult, pEEContext->pvOpaqueData ) );            
        }
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
    case TOKEN_LESS:
    case TOKEN_GREAT:
    case TOKEN_LESSEQ:
    case TOKEN_GREATEQ:
    case TOKEN_NOTEQ:
    case TOKEN_EQ:
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );  /* The right side operand of comparison */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );  /* The left side operand of comparison */
        if (!pEEContext->ExprEvalData.fShortCircuit)
        {
            /* Perform the operation on the two operands and produce result. */
            if (Operand1.TokenType == TOKEN_VARIABLE)
            {
                ChkDR(EvalVariable(&Operand1, pEEContext));
            }
            if (Operand2.TokenType == TOKEN_VARIABLE)
            {
                ChkDR(EvalVariable(&Operand2, pEEContext));
            }
            if (Operand1.TokenType != Operand2.TokenType)
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
            switch(pOperator->TokenType)
            {
            case TOKEN_LESS:
                if (Operand1.TokenType == TOKEN_LONG)                                                              
                {
                    OperandResult.val.lValue = Operand1.val.lValue < Operand2.val.lValue;
                }
                else if (Operand2.TokenType == TOKEN_STRING)              
                {
                    OperandResult.val.lValue =  DRMCRT_wcsncmp( Operand1.val.stringValue.pwszString, 
                                                         Operand2.val.stringValue.pwszString,
                                                         min( Operand1.val.stringValue.cchString, Operand2.val.stringValue.cchString) ) < 0;
                }
                else
                {
                    OperandResult.val.lValue = DRM_UI64Les( Operand1.val.u64DateTime, Operand2.val.u64DateTime );
                }
                break;
            case TOKEN_GREAT:
                if (Operand1.TokenType == TOKEN_LONG)
                {
                    OperandResult.val.lValue = Operand1.val.lValue > Operand2.val.lValue;
                }
                else if (Operand2.TokenType == TOKEN_STRING)
                {
                    OperandResult.val.lValue =  DRMCRT_wcsncmp( Operand1.val.stringValue.pwszString, 
                                                         Operand2.val.stringValue.pwszString,
                                                         min( Operand1.val.stringValue.cchString, Operand2.val.stringValue.cchString) ) > 0;
                }
                else
                {
                    OperandResult.val.lValue = DRM_UI64Les( Operand2.val.u64DateTime, Operand1.val.u64DateTime );
                }
                break;
            case TOKEN_LESSEQ:
                if (Operand1.TokenType == TOKEN_LONG)
                {
                    OperandResult.val.lValue = Operand1.val.lValue <= Operand2.val.lValue;
                }
                else if (Operand2.TokenType == TOKEN_STRING)
                {
                    OperandResult.val.lValue =  DRMCRT_wcsncmp( Operand1.val.stringValue.pwszString, 
                                                         Operand2.val.stringValue.pwszString,
                                                         min( Operand1.val.stringValue.cchString, Operand2.val.stringValue.cchString) ) <= 0;
                }
                else
                {
                    OperandResult.val.lValue =   DRM_UI64Les( Operand1.val.u64DateTime, Operand2.val.u64DateTime ) 
                                              || DRM_UI64Eql( Operand1.val.u64DateTime, Operand2.val.u64DateTime );
                }
                break;
            case TOKEN_GREATEQ:
                if (Operand1.TokenType == TOKEN_LONG)
                {
                    OperandResult.val.lValue = Operand1.val.lValue >= Operand2.val.lValue;
                }
                else if (Operand2.TokenType == TOKEN_STRING)
                {
                    OperandResult.val.lValue =  DRMCRT_wcsncmp( Operand1.val.stringValue.pwszString, 
                                                         Operand2.val.stringValue.pwszString,
                                                         min( Operand1.val.stringValue.cchString, Operand2.val.stringValue.cchString) ) >= 0;
                }
                else
                {
                    OperandResult.val.lValue =   DRM_UI64Les( Operand2.val.u64DateTime, Operand1.val.u64DateTime ) 
                                              || DRM_UI64Eql( Operand1.val.u64DateTime, Operand2.val.u64DateTime );
                }
                break;
            case TOKEN_EQ:
                if (Operand1.TokenType == TOKEN_LONG)
                {
                    OperandResult.val.lValue = Operand1.val.lValue == Operand2.val.lValue;
                }
                else if (Operand2.TokenType == TOKEN_STRING)
                {
                    OperandResult.val.lValue =  DRMCRT_wcsncmp( Operand1.val.stringValue.pwszString, 
                                                         Operand2.val.stringValue.pwszString,
                                                         min( Operand1.val.stringValue.cchString, Operand2.val.stringValue.cchString) ) == 0;
                }
                else
                {
                    OperandResult.val.lValue =  DRM_UI64Eql( Operand1.val.u64DateTime, Operand2.val.u64DateTime );
                }
                break;
            case TOKEN_NOTEQ:
                if (Operand1.TokenType == TOKEN_LONG)
                {
                    OperandResult.val.lValue = Operand1.val.lValue != Operand2.val.lValue;
                }
                else if (Operand2.TokenType == TOKEN_STRING)
                {
                    OperandResult.val.lValue =  DRMCRT_wcsncmp( Operand1.val.stringValue.pwszString, 
                                                         Operand2.val.stringValue.pwszString,
                                                         min( Operand1.val.stringValue.cchString, Operand2.val.stringValue.cchString) ) != 0;
                }
                else
                {
                    OperandResult.val.lValue =  !DRM_UI64Eql( Operand1.val.u64DateTime, Operand2.val.u64DateTime );
                }
                break;
            }
        }
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
    case TOKEN_COMMA:
        /* It can occur only inside a function argument list.  */
        /* We define comma to be a no-op. Thus 2,3 will end up 2 3 on operand stack. */
        /* A comma has the lowest precedence just above ; and hence the expression */
        /* before comma is evaluated before proceeding. */
        /* Just make sure there are at least 2 operands for so we know they exist. */
        if( pEEContext->ExprEvalData.dwOperandStack < 2 )
        {
            ChkDR( CPRMEXP_MISSING_OPERAND );
        }
        break;        
    case TOKEN_FUNCTION:
        {
            /* Pop the number from arity stack to determine actual number of arguments. */
            DRM_DWORD dwIndex;
            DRM_LONG  lNumArgs = 0, lExpectedArgs = Arity((DRM_EXPR_FUNCTION_TYPE)pOperator->val.fnValue);

            /* Search the stack array for the TOKEN_FUNCTIONSYNC token.               */
            for( dwIndex = pEEContext->ExprEvalData.dwOperandStack; dwIndex > 0; dwIndex-- )
            {
                if ( pEEContext->ExprEvalData.rgOperandTokenStack[dwIndex-1].TokenType == TOKEN_UNARYSYNC)
                {
                    dr = CPRMEXP_INCORRECT_NUM_ARGS;
                    goto ErrorExit;
                }

                if( pEEContext->ExprEvalData.rgOperandTokenStack[dwIndex-1].TokenType == TOKEN_FUNCTIONSYNC )
                {
                    /* We got all the arguments. Exit */
                    break;
                }

                lNumArgs++;
            }
            if (lNumArgs != lExpectedArgs)
            {
                /* Mismatch in # of expected and actual arguments. */
                dr = CPRMEXP_INCORRECT_NUM_ARGS;
                goto ErrorExit;
            }
            
            if (!pEEContext->ExprEvalData.fShortCircuit)
            {                
                dr = FunctionGetValue(pOperator, lNumArgs, &(pEEContext->ExprEvalData.rgOperandTokenStack[dwIndex]), &OperandResult, pEEContext );
                if ( DRM_FAILED( dr ) )
                {
                    goto ErrorExit; /* dr should indicate the reason for the failure. */
                }
            }
            /* Now pop all of the operands off the stack. */
            /* We could short circuit the stack logic and just overwrite the OperandStack counter variable */
            /* pEEContext->ExprEvalData.dwOperandStack -= (lNumArgs + 1); */
            for( ;lNumArgs > 0; lNumArgs-- )
            {
                ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
            }
            /* All function arguments have been poped.  Now pop the TOKEN_FUNCTIONSYNC */
            ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );

            ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
        }
    case TOKEN_AND:
    case TOKEN_OR:
        /* we turn the mode back on. */
        pEEContext->ExprEvalData.fShortCircuit = FALSE;
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );  /* The right side operand of comparison */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );  /* The left side operand of comparison */
        if (Operand1.TokenType != TOKEN_LONG)
        {
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }
        if (pOperator->TokenType == TOKEN_AND && Operand1.val.lValue == 0)
        {
            OperandResult.val.lValue = 0;
        }
        else if (pOperator->TokenType == TOKEN_OR && Operand1.val.lValue != 0)
        {
            OperandResult.val.lValue = 1;
        }
        else
        {
            if (Operand2.TokenType == TOKEN_VARIABLE)
            {
                ChkDR(EvalVariable(&Operand2, pEEContext));
            }
            if (Operand2.TokenType != TOKEN_LONG)
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
            OperandResult.val.lValue = Operand2.val.lValue != 0;
        }
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
    case TOKEN_ANDSKIP:
    case TOKEN_ORSKIP:
        /* We pop two operands. We should be in skip mode now. We don't turn it on. */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );  /* The right side operand of comparison */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );  /* The left side operand of comparison */

        /* Popping both operands verify that there are two operands on stack. */
        /* We simply ignore the operands. We don't check the type for skipped section. */
        /* We can't check the type anyway without evaluating it and we don't want to evaluate. */
        /* For example, 1 || securestate.playcount. We don't know the type of variable until */
        /* evaluated. */
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &Operand1) );
        break;
    case TOKEN_COLONSKIP:
        /* We need matchig TIF */
        if (pEEContext->ExprEvalData.dwOperatorStack == 0
         || pEEContext->ExprEvalData.rgOperatorTokenStack [pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType != TOKEN_IFSKIP)
        {
            dr = CPRMEXP_UNMATCHED;
            goto ErrorExit;
        }
        /* Discard the operator */
        ChkDR(TokenStackPop (pEEContext->ExprEvalData.rgOperatorTokenStack,&(pEEContext->ExprEvalData.dwOperatorStack), &Operand1 ) );

        ChkDR(TokenStackPop (pEEContext->ExprEvalData.rgOperandTokenStack, &(pEEContext->ExprEvalData.dwOperandStack), &OperandResult ) );
        ChkDR(TokenStackPop (pEEContext->ExprEvalData.rgOperandTokenStack, &(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
        ChkDR(TokenStackPop (pEEContext->ExprEvalData.rgOperandTokenStack, &(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );
        ChkDR(TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &(pEEContext->ExprEvalData.dwOperandStack), &Operand1) );
        break;
    case TOKEN_IFSKIP:
    case TOKEN_IF:
        dr = CPRMEXP_UNMATCHED; 
        break;
    case TOKEN_COLON:
        /* We need matchig TOKEN_IF */
        if (0 == pEEContext->ExprEvalData.dwOperatorStack || 
            pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType != TOKEN_IF)
        {
            dr = CPRMEXP_UNMATCHED;
            goto ErrorExit;
        }
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperatorTokenStack,&(pEEContext->ExprEvalData.dwOperatorStack), &Operand1 ) );
        /* We pop three operands and do the right thing. */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &OperandResult ) );
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );

        /* Operand1 should be an integer. Other two can be any type. */
        if (Operand1.TokenType == TOKEN_VARIABLE)
        {
            ChkDR(EvalVariable(&Operand1, pEEContext));
        }
        if (Operand1.TokenType != TOKEN_LONG)
        {
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }

        if (Operand1.val.lValue == 0)
        {
            /* Use the else part, which is oprnd3. */
            ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );            
        }
        else
        {
            ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &Operand2) );
        }
        pEEContext->ExprEvalData.fShortCircuit = FALSE; /* We are getting out of conditional expression. Turn back evaluation on. */
        break;
    case TOKEN_SEMICOLON:
        /* Pop the two operands and push the second operand back. */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &Operand2) );
        break;
    case TOKEN_OPEN:
        dr = CPRMEXP_UNMATCHED; 
        break;
    default:
        ;
    }

ErrorExit:
    return(dr);
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmexprfunc.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmexpreval.h>
#include <drmlicstore.h>
#include <drmsyncstore.h>
#include "drmexprfunc.h"

ENTER_PK_NAMESPACE_CODE;

/* Put the function names in a table with arity values */
typedef struct tagDRM_EXPR_FUNCTIONS
{
    const DRM_CONST_STRING *pdstrFunction;
    DRM_LONG Arity;
    DRM_EXPR_FUNCTION_TYPE FnType;
} DRM_EXPR_FUNCTIONS;

static const DRM_EXPR_FUNCTIONS g_FncsArity[] = 
{
    { &g_dstrExprFuncDateAdd,        3, FN_DATEADD        },
    { &g_dstrExprFuncDateDiff,       3, FN_DATEDIFF       },
    { &g_dstrExprFuncMin,            2, FN_MIN            },
    { &g_dstrExprFuncMax,            2, FN_MAX            },    
    { &g_dstrExprFuncDatePart,       2, FN_DATEPART       },
    { &g_dstrExprFuncVersionCompare, 2, FN_VERSIONCOMPARE },
    { &g_dstrExprFuncDeleteLicense,  0, FN_DELETELICENSE  },
    { &g_dstrExprFuncExists,         1, FN_EXISTS         },
};

DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL IsValidFunction(
    const DRM_CONST_STRING *pStringToken,
          DRM_DWORD        *pfnType)
{    
    DRM_UINT i;
    for( i = 0; i < NO_OF( g_FncsArity ); i++ )
    {
        if( DRM_UTL_DSTRStringsEqual( pStringToken, g_FncsArity[i].pdstrFunction ) )
        {
            *pfnType = g_FncsArity[i].FnType;
            return TRUE;
        }
    }
    return FALSE;
}


DRM_API DRM_NO_INLINE DRM_LONG DRM_CALL Arity(DRM_EXPR_FUNCTION_TYPE fnType)
{
    DRM_UINT i;
    for( i = 0; i < NO_OF( g_FncsArity ); i++ )
    {
        if( g_FncsArity[i].FnType == fnType )
        {
            return g_FncsArity[i].Arity;
        }
    }
    /* We shouldn't get here -- if we did then this wasn't a valid function. 
    Callers should call IsValidFunction to validate the name first */
    /* ASSERT( 0 ) */
    return -1;    
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL FunctionGetValue(
    TOKEN*             pOperator,
    DRM_LONG           cArgs,
    TOKEN              rgArgs[],
    TOKEN             *pOperandResult,
    EXPR_EVAL_CONTEXT *pEEContext )
{
    DRM_RESULT           dr              = DRM_SUCCESS;
    DRM_LONG             lArity          = 0;    
    DRMSYSTEMTIME        date;
    DRMFILETIME          filetime;
    DRM_LICEVAL_CONTEXT *pcontextLicEval = (DRM_LICEVAL_CONTEXT *) pEEContext->pvOpaqueData;
    DRM_LONG             lCounter        = 0;
    DRM_INT64            i64Temp;

    DRMASSERT( pOperator->TokenType == TOKEN_FUNCTION );    
    lArity = Arity((DRM_EXPR_FUNCTION_TYPE)pOperator->val.fnValue);
    if (lArity != cArgs)
    {
        dr = CPRMEXP_INCORRECT_NUM_ARGS;
        goto ErrorExit;
    }

    if( pOperator->val.fnValue != FN_EXISTS )
    {
        /* For all functions other than FN_EXISTS we have to ensure that all varibles used actually do exist */
        /* Evaluate arguments that are variables before applying the function. */
        for (lCounter = 0; lCounter < lArity; lCounter++)
        {
            if (rgArgs[lCounter].TokenType == TOKEN_VARIABLE)
            {
                /* Get the variable and replace current rgArgs with it. */
                TOKEN Token = { TOKEN_VARIABLE };
                ChkDR( pEEContext->GetVariable( &(rgArgs[lCounter].val.stringValue), &(Token), pEEContext->pvOpaqueData ) );
                rgArgs[lCounter] = Token;
            }
        }
    }

    /* Everything looks ok. Now, write code for each function. */
    switch( pOperator->val.fnValue )
    {
    case FN_EXISTS:
        {
            TOKEN Token = { TOKEN_VARIABLE };
            if (rgArgs[lCounter].TokenType != TOKEN_VARIABLE)
            {
                dr = CPRMEXP_VARIABLE_EXPECTED;
                goto ErrorExit;
            }
            pOperandResult->TokenType = TOKEN_LONG;
            if( DRM_FAILED( pEEContext->GetVariable( &(rgArgs[lCounter].val.stringValue), &(Token), pEEContext->pvOpaqueData ) ) )
            {
                pOperandResult->val.lValue = 0;
            }
            else
            {
                pOperandResult->val.lValue = 1;
            }
        }
        dr = DRM_SUCCESS;
        break;
    case FN_DATEADD:
        if (rgArgs[0].TokenType != TOKEN_STRING || rgArgs[1].TokenType != TOKEN_LONG ||
            rgArgs[2].TokenType != TOKEN_DATETIME)
        {
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }
        pOperandResult->TokenType = TOKEN_DATETIME;
        if( rgArgs[0].val.stringValue.cchString > 1 )
        {
            dr = CPRMEXP_INVALID_ARGUMENT;
            goto ErrorExit;
        }
        if( rgArgs[0].val.stringValue.pwszString[0] == g_wchd )
        {
            i64Temp = DRM_I64(10000000);
            i64Temp = DRM_I64Mul( i64Temp, DRM_I64( 24uL * 60uL * 60uL ) );
        }
        else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchh )
        {
            i64Temp = DRM_I64(10000000);
            i64Temp = DRM_I64Mul( i64Temp, DRM_I64( 60 * 60 ) );
        }
        else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchn )
        {
            i64Temp = DRM_I64(10000000);
            i64Temp = DRM_I64Mul( i64Temp, DRM_I64( 60 ) );
        }
        else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchs )
        {
            i64Temp = DRM_I64( 10000000 );
        }
        else
        {
            dr = CPRMEXP_INVALID_ARGUMENT;
            goto ErrorExit;
        }
        i64Temp = DRM_I64Mul( i64Temp, DRM_I64(rgArgs[1].val.lValue) );
        pOperandResult->val.u64DateTime = DRM_UI64Add( *(DRM_UINT64*)&i64Temp, rgArgs[2].val.u64DateTime );
        break;
    case FN_DATEDIFF:
        {
            DRM_UINT64  u64AbsDiff;
            DRM_LONG lSign;

            if ( rgArgs[0].TokenType != TOKEN_STRING 
              || rgArgs[1].TokenType != TOKEN_DATETIME 
              || rgArgs[2].TokenType != TOKEN_DATETIME )
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
            if ( DRM_UI64Les( rgArgs[1].val.u64DateTime, rgArgs[2].val.u64DateTime ) )
            {
                u64AbsDiff = DRM_UI64Sub( rgArgs[2].val.u64DateTime, rgArgs[1].val.u64DateTime );
                lSign      = 1;
            }
            else
            {
                u64AbsDiff = DRM_UI64Sub( rgArgs[1].val.u64DateTime, rgArgs[2].val.u64DateTime );
                lSign      = -1;
            }            
            pOperandResult->TokenType = TOKEN_LONG;
            if( rgArgs[0].val.stringValue.cchString > 1 )
            {
                dr = CPRMEXP_INVALID_ARGUMENT;
                goto ErrorExit;
            }
            if( rgArgs[0].val.stringValue.pwszString[0] == g_wchd )
            {
                i64Temp = DRM_I64( 10000000 );
                i64Temp = DRM_I64Mul( i64Temp, DRM_I64( 24uL * 60uL * 60uL ) );
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchh )
            {
                i64Temp = DRM_I64( 10000000 );
                i64Temp = DRM_I64Mul( i64Temp, DRM_I64( 60 * 60 ) );
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchn )
            {
                i64Temp = DRM_I64( 10000000 );
                i64Temp = DRM_I64Mul( i64Temp, DRM_I64( 60 ) );
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchs )
            {
                i64Temp = DRM_I64( 10000000 );
            }
            else
            {
                dr = CPRMEXP_INVALID_ARGUMENT;
                goto ErrorExit;
            }
            pOperandResult->val.lValue = lSign * (DRM_LONG) DRM_I64ToUI32( DRM_I64Div( DRM_UI2I64( u64AbsDiff) , i64Temp) );
            break;
        }
    case FN_MIN:
        if (rgArgs[0].TokenType != TOKEN_LONG || rgArgs[1].TokenType != TOKEN_LONG)
        {
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }
        pOperandResult->TokenType = TOKEN_LONG;
        pOperandResult->val.lValue = min(rgArgs[0].val.lValue, rgArgs[1].val.lValue);
        break;
    case FN_MAX:
        if (rgArgs[0].TokenType != TOKEN_LONG || rgArgs[1].TokenType != TOKEN_LONG)
        {
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }
        pOperandResult->TokenType = TOKEN_LONG;
        pOperandResult->val.lValue = max(rgArgs[0].val.lValue, rgArgs[1].val.lValue);
        break;
    case FN_DATEPART:
        if (rgArgs[0].TokenType != TOKEN_STRING || rgArgs[1].TokenType != TOKEN_DATETIME)
        {
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }
        pOperandResult->TokenType = TOKEN_LONG;
        UI64_TO_FILETIME( rgArgs[1].val.u64DateTime, filetime );
        if (Oem_Clock_FileTimeToSystemTime(&filetime, &date))
        {
            if( rgArgs[0].val.stringValue.cchString > 1 )
            {
                dr = CPRMEXP_INVALID_ARGUMENT;
                goto ErrorExit;
            }
            if( rgArgs[0].val.stringValue.pwszString[0] == g_wchy )
            {
                pOperandResult->val.lValue = date.wYear;
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchm )
            {
                pOperandResult->val.lValue = date.wMonth;
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchd )
            {
                pOperandResult->val.lValue = date.wDay;
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchh )
            {
                pOperandResult->val.lValue = date.wHour;
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchn )
            {
                pOperandResult->val.lValue = date.wMinute;
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchs )
            {
                pOperandResult->val.lValue = date.wSecond;
            }
            else
            {
                dr = CPRMEXP_INVALID_ARGUMENT;
                goto ErrorExit;
            }
        }
        else
        {
            dr = CPRMEXP_INVALID_CONSTANT;
            goto ErrorExit;
        }
        break;
    case FN_VERSIONCOMPARE:
        {
            DRM_UINT64 ver1, ver2;
            DRM_INT64  i64;
            DRM_WORD rgwVersion[VERSION_LEN];

            if (rgArgs[0].TokenType != TOKEN_STRING || rgArgs[1].TokenType != TOKEN_STRING)
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
            pOperandResult->TokenType = TOKEN_LONG;
            
            ChkDR( DRM_UTL_GetVersionFromString(rgArgs[0].val.stringValue.pwszString, rgArgs[0].val.stringValue.cchString, rgwVersion) );
            i64 = DRM_I64Asgn( (((DRM_DWORD)rgwVersion[0]) << 16) | rgwVersion[1],
                           (((DRM_DWORD)rgwVersion[2]) << 16) | rgwVersion[3] );

            MEMCPY( &ver1, &i64, SIZEOF( DRM_INT64 ) );

            ChkDR( DRM_UTL_GetVersionFromString(rgArgs[1].val.stringValue.pwszString, rgArgs[1].val.stringValue.cchString, rgwVersion) );
            i64 = DRM_I64Asgn( (((DRM_DWORD)rgwVersion[0]) << 16) | rgwVersion[1],
                           (((DRM_DWORD)rgwVersion[2]) << 16) | rgwVersion[3] );

            MEMCPY( &ver2, &i64, SIZEOF( DRM_INT64 ) );

            if ( DRM_UI64Les( ver1, ver2 ) )
            {
                pOperandResult->val.lValue = -1;
            }
            else if ( DRM_UI64Eql( ver1, ver2 ) )
            {
                pOperandResult->val.lValue = 0;
            }
            else
            {
                pOperandResult->val.lValue = 1;
            }
        }
        break;
    case FN_DELETELICENSE:

        if ( pcontextLicEval == NULL )
        {
            dr = CPRMEXP_INVALID_CONTEXT;
            goto ErrorExit;
        }

        pOperandResult->TokenType = TOKEN_LONG;

        /* Just return success and set the delayed delete flag. */
        pOperandResult->val.lValue = 1;
        pcontextLicEval->fDeleteLicense = TRUE;
        break;
    default:
        dr = CPRMEXP_UNSUPPORTED_FUNCTION; /* This case will happen if we recognize a function name but not support it. */
    }

ErrorExit:
    return(dr);
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmhash.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmhash.h>

ENTER_PK_NAMESPACE_CODE;


/*********************************************************************
**
**  Function:  DRM_SHA_Init
**
**  Synopsis:  Start a clean new instance of Sha
**
**  Arguments:  
**     [f_pShaContext] : Pointer to context to hold current state of sha
**     [f_eAlgorithm]  : Enum specifying the hash algorithm to initialize
**
**  Returns: 
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument is NULL or invalid
**
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SHA_Init(
    __inout_ecount( 1 ) DRM_SHA_CONTEXT               *f_pShaContext,
    __in                eDRM_SHA_SUPPORTED_ALGORITHMS  f_eAlgorithm )
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg( f_pShaContext != NULL );       
    
    f_pShaContext->fInitialized = FALSE;
    
    switch( f_eAlgorithm )
    {
    case eDRM_SHA_1:
        ChkDR( DRM_SHA1_Init( &f_pShaContext->context.sha1Context ) );
        break;
    case eDRM_SHA_256:
        ChkDR( DRM_SHA256_Init( &f_pShaContext->context.sha256Context ) );
        break;
    default:
        ChkArg( FALSE );
        break;                        
    }
    f_pShaContext->eAlgorithm = f_eAlgorithm;

    f_pShaContext->fInitialized = TRUE;
    
ErrorExit:
    return dr;    
}


/*********************************************************************
**
**  Function:  DRM_SHA_Update
**
**  Synopsis:  Update a SHA context with an array of bytes
**
**  Arguments:  
**     [f_pbData]      : Array of bytes to add to the sha computation
**     [f_cbData]      : Length of pbData in bytes
**     [f_pShaContext] : Running sha context
**
**  Returns: 
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument is NULL or invalid
**
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SHA_Update(
    __in_bcount( f_cbData )const DRM_BYTE         *f_pbData,
    __in                         DRM_DWORD         f_cbData,
    __inout_ecount( 1 )          DRM_SHA_CONTEXT  *f_pShaContext )
{
    return DRM_SHA_UpdateOffset( f_pbData, 0, f_cbData, f_pShaContext );        
}


/*********************************************************************
**
**  Function:  DRM_SHA_UpdateOffset
**
**  Synopsis:  Update a SHA context with an array of bytes and offset
**
**  Arguments:  
**     [f_pbData]      : Array of bytes to add to the sha computation
**     [f_ibData]      : Index into pbData to start
**     [f_cbData]      : Length of pbData in bytes
**     [f_pShaContext] : Running sha context
**
**  Returns: 
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument is NULL or invalid
**
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SHA_UpdateOffset(
    __in_bcount( f_cbData ) const DRM_BYTE         *f_pbData,
    __in                          DRM_DWORD         f_ibData,
    __in                          DRM_DWORD         f_cbData,
    __inout_ecount( 1 )           DRM_SHA_CONTEXT  *f_pShaContext )
{
    DRM_RESULT dr = DRM_SUCCESS;    
    
    ChkArg( f_pShaContext != NULL );
    ChkArg( f_pShaContext->fInitialized );
    
    switch( f_pShaContext->eAlgorithm )
    {
    case eDRM_SHA_1:
        ChkDR( DRM_SHA1_UpdateOffset( f_pbData, 
                                      f_ibData, 
                                      f_cbData, 
                                     &f_pShaContext->context.sha1Context ) );
        break;
    case eDRM_SHA_256:
        ChkDR( DRM_SHA256_UpdateOffset( &f_pShaContext->context.sha256Context,
                                         f_pbData,
                                         f_cbData,
                                         f_ibData ) );
        break;
    default:
        ChkDR( DRM_E_UNSUPPORTEDALGORITHM );
        break;                        
    }
    
ErrorExit:
    return dr;
}
   
    
/*********************************************************************
**
**  Function:  DRM_SHA_Finalize
**
**  Synopsis:  Finalize a SHA algorithm
**
**  Arguments:  
**     [f_pShaContext] : Running sha context
**     [f_cbDigest]    : Length of f_pbDigest
**     [f_pbDigest]    : Resultant sha digest from sha operation
**
**  Returns: 
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument is NULL or invalid
**      DRM_E_BUFFERTOOSMALL
**          f_pbDigest is not large enough for the digest
**
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SHA_Finalize(
    __in_ecount( 1 )            DRM_SHA_CONTEXT *f_pShaContext,
    __in                        DRM_DWORD        f_cbDigest,
    __inout_bcount( f_cbDigest) DRM_BYTE        *f_pbDigest )
{
    DRM_RESULT dr = DRM_SUCCESS;    
    
    ChkArg( f_pShaContext != NULL );
    ChkArg( f_pShaContext->fInitialized );
    
    switch( f_pShaContext->eAlgorithm )
    {
    case eDRM_SHA_1:
        ChkBOOL( f_cbDigest >= DRM_SHA1_DIGEST_LEN, DRM_E_BUFFERTOOSMALL );
        ChkDR( DRM_SHA1_Finalize( &f_pShaContext->context.sha1Context,                                     
                                   f_pbDigest ) );
        break;
    case eDRM_SHA_256:
        ChkBOOL( f_cbDigest >= SIZEOF( DRM_SHA256_Digest ), DRM_E_BUFFERTOOSMALL );   
        ChkDR( DRM_SHA256_Finalize( &f_pShaContext->context.sha256Context,
                                    ( DRM_SHA256_Digest * )f_pbDigest ) );
        break;
    default:
        ChkArg( FALSE );
        break;                        
    }
        
ErrorExit:
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmexprvariable.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmexpreval.h>
#include <drmliceval.h>
#include <drmlicenseparser.h>
#include <drmheaderparser.h>
#include <drmlicreason.h>

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
    #define C_SECONDS_IN_ROLLBACK_GRACE_PERIOD 30
#endif

DRM_API DRM_RESULT DRM_CALL VariableDRMGetorSet       (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_API DRM_RESULT DRM_CALL VariableDRMKGetorSet      (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_API DRM_RESULT DRM_CALL VariableMachineGetorSet   (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_API DRM_RESULT DRM_CALL VariableAPPGetorSet       (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_API DRM_RESULT DRM_CALL VariableSecStateGetorSet  (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_API DRM_RESULT DRM_CALL VariableLicenseGetorSet   (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_API DRM_RESULT DRM_CALL VariableContentGetorSet   (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_API DRM_RESULT DRM_CALL VariableDeviceGetorSet    (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_API DRM_RESULT DRM_CALL VariablePMLicenseGetorSet (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);

#if DRM_SUPPORT_SECURE_CLOCK
DRM_API DRM_RESULT DRM_CALL VariableSecureTimeGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
#endif

#if DRM_SUPPORT_PLAYLIST_BURN
DRM_API DRM_RESULT DRM_CALL VariablePlaylistBurnGetorSet  (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
#endif

#if DRM_SUPPORT_SST_REDUNANCY
DRM_API DRM_RESULT DRM_CALL VariableSSTRedundancyGetorSet (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
#endif

typedef DRM_RESULT  ( DRM_CALL *pfnGetorSetVariable)(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);

typedef struct tagDRM_VARIABLE_NAMESPACES
{
    const DRM_CONST_STRING *pdstrNamespace;
    pfnGetorSetVariable GetorSetVariable;    
} DRM_VARIABLE_NAMESPACES;

static const DRM_VARIABLE_NAMESPACES g_VariableNamespaces[] = 
{
    { &g_dstrDRM_PREFIX,          VariableDRMGetorSet       },
    { &g_dstrDRMK_PREFIX,         VariableDRMKGetorSet      },
    { &g_dstrMACHINE_PREFIX,      VariableMachineGetorSet   },
    { &g_dstrAPP_PREFIX,          VariableAPPGetorSet       },
    { &g_dstrSECSTATE_PREFIX,     VariableSecStateGetorSet  },
    { &g_dstrLICENSE_PREFIX,      VariableLicenseGetorSet   },
    { &g_dstrCONTENT_PREFIX,      VariableContentGetorSet   },
    { &g_dstrDEVICE_PREFIX,       VariableDeviceGetorSet    },
    { &g_dstrPMLICENSE_PREFIX,    VariablePMLicenseGetorSet },

#if DRM_SUPPORT_SECURE_CLOCK
    { &g_dstrSECURETIME_PREFIX,   VariableSecureTimeGetorSet },
#endif

#if DRM_SUPPORT_PLAYLIST_BURN
    { &g_dstrPLAYLISTBURN_PREFIX, VariablePlaylistBurnGetorSet },
#endif

#if DRM_SUPPORT_SST_REDUNANCY
    { &g_dstrSSTREDUNDANCY_PREFIX, VariableSSTRedundancyGetorSet },
#endif

};

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL GlobalSetVariable(
    const DRM_CONST_STRING *pdstrToken, 
    const TOKEN            *pNewValue, 
          TOKEN            *pResult, 
          DRM_VOID         *pvOpaqueData)
{
    DRM_UINT i,j;    

    /* Find the period first and use that to  */
    for( j=0; j<pdstrToken->cchString; j++ )
    {
        if( pdstrToken->pwszString[j] == g_wchPeriod )
        {
            j++;
            break;
        }
    }
    if( j < pdstrToken->cchString )
    {
        DRM_CONST_STRING dstrToken = EMPTY_DRM_STRING; 
        dstrToken.pwszString = pdstrToken->pwszString + j;
        dstrToken.cchString  = pdstrToken->cchString  - j;

            for( i = 0; i < NO_OF( g_VariableNamespaces ); i++ )
        {
            if( j == g_VariableNamespaces[i].pdstrNamespace->cchString &&
                0 == DRMCRT_wcsncmp(pdstrToken->pwszString, g_VariableNamespaces[i].pdstrNamespace->pwszString, j) )
            {                
                return g_VariableNamespaces[i].GetorSetVariable((const DRM_CONST_STRING *)&dstrToken, (TOKEN *)pNewValue, pResult, pvOpaqueData, TRUE ) ;
            }
        }
    }
    return CPRMEXP_INVALID_VARIABLE;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL GlobalGetVariable(
    const DRM_CONST_STRING  *pdstrToken, 
    TOKEN                   *pResult, 
    DRM_VOID                *pvOpaqueData )
{
    DRM_UINT i,j;    

    /* Find the g_wchPeriod first and use that to  */
    for( j=0; j<pdstrToken->cchString; j++ )
    {
        if( pdstrToken->pwszString[j] == g_wchPeriod )
        {
            j++;
            break;
        }
    }
    if( j < pdstrToken->cchString )
    {
        DRM_CONST_STRING dstrToken;
        dstrToken.pwszString = pdstrToken->pwszString + j;
        dstrToken.cchString = pdstrToken->cchString - j;
        for( i = 0; i < NO_OF( g_VariableNamespaces ); i++ )
        {
            if( j == g_VariableNamespaces[i].pdstrNamespace->cchString &&
                0 == DRMCRT_wcsncmp(pdstrToken->pwszString, g_VariableNamespaces[i].pdstrNamespace->pwszString, j) )
            {                
                return g_VariableNamespaces[i].GetorSetVariable(&dstrToken, NULL, pResult, pvOpaqueData, FALSE ) ;
            }
        }
    }
    return CPRMEXP_INVALID_VARIABLE;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL VariableDRMKGetorSet(
    const DRM_CONST_STRING  *pdstrToken, 
    TOKEN                   *pNewValue, 
    TOKEN                   *pResult, 
    DRM_VOID                *pvOpaqueData, 
    DRM_BOOL                 fSet )
{
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    if ( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarVersion, pdstrToken ) )
    {
        if( fSet )
        {
            return CPRMEXP_UPDATE_UNSUPPORTED;
        }
        if( pLicEval->dstrDRMKVer.pwszString && pLicEval->dstrDRMKVer.cchString )
        {
            pResult->TokenType = TOKEN_STRING;
            pResult->val.stringValue.pwszString = pLicEval->dstrDRMKVer.pwszString;
            pResult->val.stringValue.cchString = pLicEval->dstrDRMKVer.cchString;
        }
        else
        {
            return CPRMEXP_RETRIEVAL_FAILURE;
        }
    }
    else if ( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarParameter, pdstrToken ) )
    {
        if( fSet )
        {
            if( pNewValue->TokenType != TOKEN_STRING )
            {
                return CPRMEXP_WRONG_TYPE_OPERAND;
            }
            pLicEval->wszDRMKParam.pwszString = pNewValue->val.stringValue.pwszString;
            pLicEval->wszDRMKParam.cchString  = pNewValue->val.stringValue.cchString;
        }
        else if( NULL == pLicEval->wszDRMKParam.pwszString || 0 == pLicEval->wszDRMKParam.cchString )
        {
            return CPRMEXP_RETRIEVAL_FAILURE;
        }

        pResult->TokenType = TOKEN_STRING;
        pResult->val.stringValue.pwszString = pLicEval->wszDRMKParam.pwszString;
        pResult->val.stringValue.cchString = pLicEval->wszDRMKParam.cchString;
    }
    else
    {        
        return CPRMEXP_INVALID_VARIABLE;
    }

    return DRM_SUCCESS;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL VariableDRMGetorSet(
    const DRM_CONST_STRING  *pdstrToken, 
    TOKEN                   *pNewValue, 
    TOKEN                   *pResult, 
    DRM_VOID                *pvOpaqueData, 
    DRM_BOOL                 fSet )
{
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarReason, pdstrToken ) )
    {
        if( !fSet )
        {
            return CPRMEXP_RETRIEVAL_FAILURE;
        }
        if( pNewValue->TokenType != TOKEN_LONG )
        {
            return CPRMEXP_WRONG_TYPE_OPERAND;
        }

        pResult->TokenType = TOKEN_LONG;
        pLicEval->lReasonForFail = pResult->val.lValue = pNewValue->val.lValue;
    }
    else if ( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarVersion, pdstrToken ) )
    {
        if( fSet )
        {
            return CPRMEXP_UPDATE_UNSUPPORTED;
        }
        if( pLicEval->dstrDRMVer.pwszString && pLicEval->dstrDRMVer.cchString )
        {
            pResult->TokenType = TOKEN_STRING;
            pResult->val.stringValue.pwszString = pLicEval->dstrDRMVer.pwszString;
            pResult->val.stringValue.cchString = pLicEval->dstrDRMVer.cchString;
        }
        else
        {
            return CPRMEXP_RETRIEVAL_FAILURE;
        }

    }
    else if ( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarBBMSDRMVersion, pdstrToken ) )
    {
        if( fSet )
        {
            return CPRMEXP_UPDATE_UNSUPPORTED;
        }
        if( pLicEval->dstrBBVer.pwszString && pLicEval->dstrBBVer.cchString )
        {
            pResult->TokenType = TOKEN_STRING;
            pResult->val.stringValue.pwszString = pLicEval->dstrBBVer.pwszString;
            pResult->val.stringValue.cchString = pLicEval->dstrBBVer.cchString;
        }
        else
        {
            return CPRMEXP_RETRIEVAL_FAILURE;
        }
    }
    else
    {
        return CPRMEXP_INVALID_VARIABLE;
    }

    return DRM_SUCCESS;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL VariableMachineGetorSet(
    const DRM_CONST_STRING  *pdstrToken, 
    TOKEN                   *pNewValue, 
    TOKEN                   *pResult, 
    DRM_VOID                *pvOpaqueData, 
    DRM_BOOL                 fSet )
{
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    if( fSet )
    {
        return CPRMEXP_UPDATE_UNSUPPORTED;
    }

    if ( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarDateTime, pdstrToken ) )
    {
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
        DRM_RESULT dr = DRM_SUCCESS;
        TOKEN token;
#endif
        DRMFILETIME filetime = {0};

        if ( pLicEval->fIgnoreTimeBoundLicense )
        {
            pLicEval->lReasonForFail = LR_LICENSE_CLOCK_NOT_SET;
            return CPRMEXP_CLOCK_REQUIRED;
        }

        if (pLicEval->eTimeBasedState != LICEVAL_GRACEPERIODREFERENCED )
        {
            pLicEval->eTimeBasedState = LICEVAL_MACHINEDATETIMEREFERENCED;
        }
        
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
        dr = VariableSecStateGetorSet( &g_dstrSavedDateTime, NULL, &token, pvOpaqueData, FALSE );
#endif
        pResult->TokenType = TOKEN_DATETIME;
        Oem_Clock_GetSystemTimeAsFileTime(pLicEval->pcontextBBX->pOEMContext, &filetime);
        FILETIME_TO_UI64( filetime, pResult->val.u64DateTime );
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
        if( dr == DRM_SUCCESS )
        {
            /* Compare for the grace period */
            if( DRM_UI64Les( pResult->val.u64DateTime, token.val.u64DateTime ) )
            {
                pResult->val.u64DateTime = DRM_UI64Sub( token.val.u64DateTime, pResult->val.u64DateTime );

                if( DRM_UI64Les( pResult->val.u64DateTime, DRM_UI64(C_SECONDS_IN_ROLLBACK_GRACE_PERIOD * C_TICS_PER_SECOND) ) )
                {
                    pResult->TokenType       = TOKEN_DATETIME;
                    pResult->val.u64DateTime = token.val.u64DateTime;
                }
            }
        }
#endif
    }
    else
    {
        return CPRMEXP_INVALID_VARIABLE;
    }
    return DRM_SUCCESS;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL VariableAPPGetorSet(
    const DRM_CONST_STRING  *pdstrToken, 
    TOKEN                   *pNewValue, 
    TOKEN                   *pResult, 
    DRM_VOID                *pvOpaqueData, 
    DRM_BOOL                 fSet )
{
    DRM_RESULT dr                 = DRM_SUCCESS;
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    pResult->TokenType = TOKEN_LONG;

    if( fSet )
    {
        /* Set not allowed */
        dr = CPRMEXP_UPDATE_UNSUPPORTED;
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarCount, pdstrToken ) )
    {
        if( pLicEval->fLegacyAppInfoValid )
        {
            pResult->val.lValue = 2;
        }
        else
        {
            pResult->val.lValue = 1;
        }            
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarMinSecLevel, pdstrToken ) )
    {
        pResult->val.lValue = pLicEval->certinfoSDK.appSec;
        if( pLicEval->fLegacyAppInfoValid )
        {
            if( pLicEval->certinfoAppLegacy.appSec < pLicEval->certinfoSDK.appSec )
            {
                pResult->val.lValue = pLicEval->certinfoAppLegacy.appSec;
            }
        }
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarSecLevel, pdstrToken ) )
    {
        pResult->val.lValue = pLicEval->certinfoSDK.appSec;
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarAppSecLevel, pdstrToken ) )
    {
        if( pLicEval->fLegacyAppInfoValid )
        {
            pResult->val.lValue = pLicEval->certinfoAppLegacy.appSec;
        }
        else
        {
            pResult->val.lValue = pLicEval->certinfoSDK.appSec;
        }
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarSubjID, pdstrToken ) )
    {
        pResult->val.lValue = pLicEval->certinfoSDK.appcd_subject;
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarAppSubjID, pdstrToken ) )
    {
        if( pLicEval->fLegacyAppInfoValid )
        {
            pResult->val.lValue = pLicEval->certinfoAppLegacy.appcd_subject;
        }
        else
        {
            pResult->val.lValue = pLicEval->certinfoSDK.appcd_subject;
        }        
    }
    else
    {
        dr  = CPRMEXP_RETRIEVAL_FAILURE;
    }

    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL VariableSecStateGetorSet(
    const DRM_CONST_STRING  *pdstrToken, 
    TOKEN                   *pNewValue, 
    TOKEN                   *pResult, 
    DRM_VOID                *pvOpaqueData, 
    DRM_BOOL                 fSet )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_LICEVAL_CONTEXT  *pLicEval  = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;
    DRM_SECSTORE_CONTEXT *pbContext = NULL;
    DRM_CONST_STRING      dstrToken = EMPTY_DRM_STRING;

    dstrToken.pwszString = pdstrToken->pwszString;
    dstrToken.cchString  = pdstrToken->cchString;

    if ( fSet && pLicEval->fIsReadOnlyMode )
    {
        goto ErrorExit; /* ignore setting the secstore if fIsReadOnlyMode is set */
    }

    if( g_dstrExprVarGlobal.cchString < dstrToken.cchString &&
        DRMCRT_wcsncmp( g_dstrExprVarGlobal.pwszString, dstrToken.pwszString, g_dstrExprVarGlobal.cchString ) == 0 )
    {
        /* Move the pointer past the globalstate string */
        dstrToken.pwszString += g_dstrExprVarGlobal.cchString;
        dstrToken.cchString  -= g_dstrExprVarGlobal.cchString;
        
        
        /* Look for both savedatetime and saveddatetime due to a difference in older WMRM versions */
        if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarSaveDateTime, &dstrToken ) )
        {
            dstrToken.pwszString = g_dstrExprVarSavedDateTime.pwszString;
            dstrToken.cchString = g_dstrExprVarSavedDateTime.cchString;
        }

        /* It is a global state variable.  If this is a set call we have to check to see if set is available right now */
        if( fSet )
        {
            if( !pLicEval->fGlobalSecStoreWritable )
            {
                dr = CPRMEXP_UPDATE_FAILURE;
                goto ErrorExit;
            }
            else if( ( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarSavedDateTime, &dstrToken ) )&&
                    pNewValue->TokenType != TOKEN_DATETIME )
            {
                /* saveddatetime MUST be a DATE token */
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
        }
        pbContext = pLicEval->pcontextSSTGlobal;
    }
#if DRM_SUPPORT_SECURE_CLOCK
    else if( g_dstrSECURETIME_PREFIX.cchString < dstrToken.cchString 
          && DRMCRT_wcsncmp( g_dstrSECURETIME_PREFIX.pwszString, dstrToken.pwszString, g_dstrSECURETIME_PREFIX.cchString ) == 0 )

    {
        /* Move the pointer past the securetime string */
        dstrToken.pwszString += g_dstrSECURETIME_PREFIX.cchString;
        dstrToken.cchString  -= g_dstrSECURETIME_PREFIX.cchString;
        dr = VariableSecureTimeGetorSet( &dstrToken, pNewValue, pResult, pvOpaqueData, fSet);
        goto ErrorExit;
    }
#endif
    else
    {
        pbContext = pLicEval->pcontextSSTLicense;
    }

    if( NULL == pbContext )
    {
        dr = CPRMEXP_RETRIEVAL_FAILURE;
    }
    else if( fSet )
    {
        TOKEN tempToken;

        if( pNewValue->TokenType == TOKEN_STRING )
        {
            /* String types can not be assigned to secure store variables */
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }
        MEMCPY( &tempToken, pNewValue, SIZEOF( TOKEN ) );

        if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarDRMReason, &dstrToken ) )
        {
            pLicEval->lReasonForFail = pNewValue->val.lValue;
        }
        else
        {
            dr = DRM_SST_SetTokenValue( pbContext, &dstrToken, &tempToken);
            if( DRM_FAILED( dr ) )
            {
                dr = CPRMEXP_UPDATE_FAILURE;
                goto ErrorExit;
            }
        }
        if( pResult )
        {
            MEMCPY( pResult, pNewValue, SIZEOF( TOKEN ) );
        }
    }
    else
    {
        dr = DRM_SST_GetTokenValue( pbContext, &dstrToken, pResult);
        if( dr == DRM_S_FALSE )
        {
            dr = CPRMEXP_RETRIEVAL_FAILURE;
        }
        ChkDR( dr );
    }

ErrorExit:
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL VariableLicenseGetorSet(
    const DRM_CONST_STRING  *pdstrToken, 
    TOKEN                   *pNewValue, 
    TOKEN                   *pResult, 
    DRM_VOID                *pvOpaqueData, 
    DRM_BOOL                 fSet )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    if( fSet )
    {
        /* Set not allowed */
        return CPRMEXP_UPDATE_UNSUPPORTED;
    }
    pResult->TokenType = TOKEN_STRING;
    if( NULL == pLicEval->dstrContentLicense.pwszString ||
        0 == pLicEval->dstrContentLicense.cchString ||
        DRM_FAILED( DRM_LIC_GetAttribute( &(pLicEval->dstrContentLicense), pdstrToken, DRM_LICENSE_ATTRIB_OTHER, NULL, &(pResult->val.stringValue), g_wchPeriod ) )
        )
    {
        dr = CPRMEXP_RETRIEVAL_FAILURE;
    }
    
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL VariableContentGetorSet(
    const DRM_CONST_STRING  *pdstrToken, 
    TOKEN                   *pNewValue, 
    TOKEN                   *pResult, 
    DRM_VOID                *pvOpaqueData, 
    DRM_BOOL                 fSet )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    /* Use content header parsing to extract a property */
    if( fSet )
    {        
        return CPRMEXP_UPDATE_UNSUPPORTED;
    }
    pResult->TokenType = TOKEN_STRING;
    if( NULL == pLicEval->dstrContentHeader.pwszString ||
        0 == pLicEval->dstrContentHeader.cchString ||
        DRM_FAILED( DRM_HDR_GetAttribute( &(pLicEval->dstrContentHeader), pdstrToken, DRM_HEADER_ATTRIB_OTHER, &(pResult->val.stringValue), g_wchPeriod ) )
        )    
    {
        dr = CPRMEXP_RETRIEVAL_FAILURE;
    }
    
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL VariableDeviceGetorSet(
    const DRM_CONST_STRING  *pdstrToken, 
    TOKEN                   *pNewValue, 
    TOKEN                   *pResult, 
    DRM_VOID                *pvOpaqueData, 
    DRM_BOOL                 fSet )
{
    /* We are depricating the device namespace */
#if !DRM_SUPPORT_DEVICE_NAMESPACE
    return DRM_E_NOTIMPL;
#else

    DRM_LICEVAL_CONTEXT* pContext = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    DRMASSERT( pContext != NULL );
    if( pContext == NULL )
    {
        return DRM_E_INVALIDARG;
    }

    /* device-registered flag */
    if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarDevReg, pdstrToken ) )
    {
        if( fSet )
        {
            if( pNewValue->TokenType != TOKEN_LONG )
            {
                return CPRMEXP_WRONG_TYPE_OPERAND;                
            }
            pContext->fDeviceRegistered = pNewValue->val.lValue;
        }
        pResult->TokenType  = TOKEN_LONG;
        pResult->val.lValue = pContext->fDeviceRegistered;
    }
    else
    {
        return CPRMEXP_RETRIEVAL_FAILURE;
    }

    return DRM_SUCCESS;

#endif

}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL VariablePMLicenseGetorSet(
    const DRM_CONST_STRING  *pdstrToken, 
    TOKEN                   *pNewValue, 
    TOKEN                   *pResult, 
    DRM_VOID                *pvOpaqueData, 
    DRM_BOOL                 fSet )
{
#if !DRM_SUPPORT_PMLICENSE
    return DRM_E_NOTIMPL;
#else
    DRM_LICEVAL_CONTEXT* pContext = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    DRMASSERT( pContext != NULL );
    if( pContext == NULL )
    {
        return DRM_E_INVALIDARG;
    }

    if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarRights, pdstrToken ) )
    {
        if( fSet )
        {
            if( pNewValue->TokenType != TOKEN_LONG )
            {
                return CPRMEXP_WRONG_TYPE_OPERAND;                
            }
            pContext->lPMRights = pNewValue->val.lValue;
        }
        pResult->TokenType = TOKEN_LONG;
        pResult->val.lValue    = pContext->lPMRights;
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarExpiryDate, pdstrToken ) )
    {
        DRMFILETIME filetime;
        if( fSet )
        {            
            if( pNewValue->TokenType != TOKEN_DATETIME )
            {
                return CPRMEXP_WRONG_TYPE_OPERAND;                
            }
            UI64_TO_FILETIME( pNewValue->val.u64DateTime, filetime );
            if (!Oem_Clock_FileTimeToSystemTime(&filetime, &pContext->PMExpiryDate))
            {
                return CPRMEXP_UPDATE_FAILURE;
            }            
        }
        pResult->TokenType = TOKEN_DATETIME;
        if (!Oem_Clock_SystemTimeToFileTime(&pContext->PMExpiryDate, &filetime))
        {
            return CPRMEXP_RETRIEVAL_FAILURE; /* Should not happen. */            
        }
        FILETIME_TO_UI64(filetime, pResult->val.u64DateTime)
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarAppSecLevel, pdstrToken ) )
    {
        if( fSet )
        {
            if( pNewValue->TokenType != TOKEN_LONG )
            {
                return CPRMEXP_WRONG_TYPE_OPERAND;                
            }
            pContext->lPMAppSec = pNewValue->val.lValue;
        }
        pResult->TokenType = TOKEN_LONG;
        pResult->val.lValue    = pContext->lPMAppSec;
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarVersion, pdstrToken ) )
    {
        if( fSet )
        {
            return CPRMEXP_UPDATE_UNSUPPORTED;
        }

        if (pContext->pwszPMLicVersion && pContext->pwszPMLicVersion->cchString > 0)
        {
            pResult->TokenType = TOKEN_STRING;
            pResult->val.stringValue.cchString = pContext->pwszPMLicVersion->cchString;
            pResult->val.stringValue.pwszString = pContext->pwszPMLicVersion->pwszString;
        }
        else
        {
            return CPRMEXP_RETRIEVAL_FAILURE;             
        }
    }

    else
    {
        return CPRMEXP_RETRIEVAL_FAILURE;
    }

    return DRM_SUCCESS;
#endif
}

#if DRM_SUPPORT_SECURE_CLOCK
DRM_API DRM_RESULT DRM_CALL VariableSecureTimeGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;


    if( fSet )
    {        
        ChkDR(CPRMEXP_UPDATE_UNSUPPORTED);
    }
    
    if( pLicEval == NULL )
    {
        ChkDR(CPRMEXP_RETRIEVAL_FAILURE);
    }

    if( !pLicEval->fSecureTimeDataValid )
    {        
        ChkDR(CPRMEXP_RETRIEVAL_FAILURE);
    }

    /* fInGracePeriod variable*/
    /*Set the flag in lic Eval context if this function was ever called, to know that if Grace period expression exists in license.
     * It is called before validation of variables, but it is fine since the function will error out if variables doesn't match.
    */
    pLicEval->eTimeBasedState = LICEVAL_GRACEPERIODREFERENCED;

    if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarInGracePeriod, pdstrToken ) )
    {
        pResult->TokenType  = TOKEN_LONG;
        pResult->val.lValue = (DRM_LONG)pLicEval->fInGracePeriod;
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarGpStartTime, pdstrToken ) )
    {
        pResult->TokenType  = TOKEN_DATETIME;
        MEMCPY(&pResult->val.u64DateTime, &pLicEval->u64GPStartTime, SIZEOF( pResult->val.u64DateTime ) ) ;
    }
    else
    {
        ChkDR(CPRMEXP_RETRIEVAL_FAILURE);
    }
    
ErrorExit:
    return dr;
  
}
#endif


#if DRM_SUPPORT_PLAYLIST_BURN
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL VariablePlaylistBurnGetorSet(
    const DRM_CONST_STRING  *pdstrToken, 
    TOKEN                   *pNewValue, 
    TOKEN                   *pResult, 
    DRM_VOID                *pvOpaqueData, 
    DRM_BOOL                 fSet )
{
    DRM_LICEVAL_CONTEXT* pContext = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    DRMASSERT( pContext != NULL );
    if( pContext == NULL )
    {
        return DRM_E_INVALIDARG;
    }

    if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarIncrementCount, pdstrToken ) )
    {
        if( fSet )
        {
            if( pNewValue->TokenType != TOKEN_LONG )
            {
                return CPRMEXP_WRONG_TYPE_OPERAND;                
            }
            pContext->cPlaylistBurnIncrement = pNewValue->val.lValue;
        }
        pResult->TokenType  = TOKEN_LONG;
        pResult->val.lValue = pContext->cPlaylistBurnIncrement;
    }
    else
    {
        return CPRMEXP_RETRIEVAL_FAILURE;
    }

    return DRM_SUCCESS;
}
#endif

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmexprfunc.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_EXPR_FUNCTION_H__
#define __DRM_EXPR_FUNCTION_H__

ENTER_PK_NAMESPACE;

/* The public entry point */
DRM_API DRM_RESULT DRM_CALL FunctionGetValue(
    IN  TOKEN             *pOperator, 
    IN  DRM_LONG           cArgs, 
    IN  TOKEN              rgArgs[], 
    OUT TOKEN             *pOperandResult, 
    IN  EXPR_EVAL_CONTEXT *pEEContext );

DRM_API DRM_LONG DRM_CALL Arity(DRM_EXPR_FUNCTION_TYPE fnType);

DRM_API DRM_BOOL DRM_CALL IsValidFunction(
    IN const DRM_CONST_STRING       *pdstrToken, 
    IN       DRM_DWORD              *pfnType);


EXIT_PK_NAMESPACE;

#endif /*__DRM_EXPR_FUNCTION_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmhdrbuilder.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmutilities.h>
#include <drmxmlbuilder.h>
#include <drmsha1.h>
#include <drmlicense.h>
#include <drmhdrbuilder.h>
#include <drmkeygenerator.h>

ENTER_PK_NAMESPACE_CODE;


/*************************************************************************
** Macros
**************************************************************************/
#define Tracked_N_ChkDR(hb,expr) {                         \
    if ( (hb)->dwItemsTracked == (hb)->dwItemsAdded ) \
    {                          \
        ChkDR((expr));         \
        ++(hb)->dwItemsAdded;  \
    }                          \
    ++(hb)->dwItemsTracked;    \
}


/*************************************************************************
** local constants
**************************************************************************/
/* default tag data */

static const DRM_WORD _cbXmlBuilderCtx=8192;    /* initial XML builder context size */

/*************************************************************************
** static functions
**************************************************************************/


/* 
**
*/
static DRM_VOID
_ChangeState(
    _HBContext *pHB,
    _EHBContextState eState)
{
    pHB->eState = eState;
    pHB->dwItemsAdded = pHB->dwItemsTracked = 0;
}


/*
** Add the following node/subnode to the request:
**
**  <SIGNATURE>
**    <HASHALGORITHM type=\"SHA\"></HASHALGORITHM>
**    <SIGNALGORITHM type=\"MSDRM\"></SIGNALGORITHM>
**    <VALUE>QrUgBBheJVzAOOw2kbo*1sqJkwft4oXKNBPv56PpUhho5fS6XK6sTg==</VALUE>
**  </SIGNATURE>
*/
static DRM_RESULT _SignTheHeader(
    _HBContext         *pHB,
    DRM_CRYPTO_CONTEXT *pCryptoContext,
    DRM_CONST_STRING   *pdstrPrivKey,
    DRM_STRING         *pdstrDataNodeFragment)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg(pHB);

    /* open <SIGNATURE> node */
    Tracked_N_ChkDR(pHB, DRM_XMB_OpenNode(pHB->pbXmlContext, &g_dstrTagSignature));
        
    /* add <HASHALGORITHM> node */
    Tracked_N_ChkDR(pHB, DRM_XMB_OpenNode(pHB->pbXmlContext, &g_dstrTagHashAlg));
    Tracked_N_ChkDR(pHB, DRM_XMB_AddAttribute(pHB->pbXmlContext, &g_dstrAttributeType, &g_dstrSHA));
    Tracked_N_ChkDR(pHB, DRM_XMB_CloseCurrNode(pHB->pbXmlContext, NULL));

    /* add <SIGNALGORITHM> node */
    Tracked_N_ChkDR(pHB, DRM_XMB_OpenNode(pHB->pbXmlContext, &g_dstrTagSignAlg));
    Tracked_N_ChkDR(pHB, DRM_XMB_AddAttribute(pHB->pbXmlContext, &g_dstrAttributeType, &g_dstrMSDRM));
    Tracked_N_ChkDR(pHB, DRM_XMB_CloseCurrNode(pHB->pbXmlContext, NULL));

    /* add <VALUE> node */
    {
        DRM_BYTE    rgbSignature[__CB_DECL( DRM_ECC160_SIGNATURE_LEN )] = { 0 };
        DRM_DWORD   cchEncoded  = 0;
        PRIVKEY     oPrivKey    = { 0 };
        DRM_DWORD   dwPrivKey   = SIZEOF(PRIVKEY);
        DRM_DWORD   cbSignature = DRM_ECC160_SIGNATURE_LEN;
        DRM_CONST_STRING dstrSignature = EMPTY_DRM_STRING;

        /* decode the signing key */
        ChkDR(DRM_B64_DecodeW(pdstrPrivKey, &dwPrivKey, (DRM_BYTE *)&oPrivKey, 0));

        /* sign the <DATA> node */        
        ChkDR( DRM_PK_Sign( pCryptoContext->rgbCryptoContext, 
                            eDRM_ECC_P160,
                            DRM_ECC160_PRIVATE_KEY_LEN,
                            ( const DRM_BYTE * )&oPrivKey, 
                            CB_DSTR( pdstrDataNodeFragment ),
                            PB_DSTR( pdstrDataNodeFragment ),
                            &cbSignature,
                            rgbSignature ) );                    

        /* Base64 encode the signature */

        cchEncoded = CCH_BASE64_EQUIV( cbSignature );
        if ( (cchEncoded + 1) * SIZEOF(DRM_WCHAR) > SIZEOF( pHB->rgbLocalStack ) )
        {
            ChkDR(DRM_E_OUTOFMEMORY);       /* LOCALSTACKSIZE too small */
        }
        ZEROMEM(pHB->rgbLocalStack, (cchEncoded+1) * SIZEOF(DRM_WCHAR) );
        ChkDR(DRM_B64_EncodeW( rgbSignature, 
                               DRM_ECC160_SIGNATURE_LEN, 
                  (DRM_WCHAR *)pHB->rgbLocalStack, 
                              &cchEncoded, 
                              0));
        dstrSignature.pwszString = (DRM_WCHAR *)pHB->rgbLocalStack;
        dstrSignature.cchString = cchEncoded;

        Tracked_N_ChkDR(pHB, DRM_XMB_OpenNode(pHB->pbXmlContext, &g_dstrTagValue));
        Tracked_N_ChkDR(pHB, DRM_XMB_AddData(pHB->pbXmlContext, &dstrSignature));
        Tracked_N_ChkDR(pHB, DRM_XMB_CloseCurrNode(pHB->pbXmlContext, NULL));
    }

    /* close SIGNATURE node */
    Tracked_N_ChkDR(pHB, DRM_XMB_CloseCurrNode(pHB->pbXmlContext, NULL));

ErrorExit:
    return dr;
}



DRM_API DRM_RESULT DRM_CALL DRM_HB_CreateHeader(
    __in_bcount_opt( *pcbHBContext ) DRM_BYTE *pbHBContext,
    IN     DRM_CONTENT_SET_PROPERTY  eHeaderType,
    IN OUT DRM_DWORD                *pcbHBContext )
{
    DRM_RESULT  dr        = DRM_SUCCESS;
    _HBContext *pHB       = NULL;
    DRM_DWORD   cbContext = 0;
    DRM_DWORD   cbTotal   = 0;
    DRM_DWORD   cbAligned = 0;
    DRM_DWORD   cbAdjust  = 0;

    ChkArg( pcbHBContext );
    ChkArg( eHeaderType == DRM_CSP_V2_HEADER 
         || eHeaderType == DRM_CSP_V2_4_HEADER
         || eHeaderType == DRM_CSP_V4_HEADER );
    
    /* check given context size */
    cbContext = SIZEOF(_HBContext) - 1 + _cbXmlBuilderCtx;
    if ( pbHBContext == NULL || *pcbHBContext < cbContext )
    {
        /* minimum context size to start with */
        *pcbHBContext= cbContext;
        dr = DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }

    /* Initialize Context 
    ** note: pbXmlContext is physically located at end of pbBlackboxContext.
    */
    ZEROMEM(pbHBContext, *pcbHBContext);
    pHB = (_HBContext*)pbHBContext;
    pHB->wContextSize = (DRM_WORD)*pcbHBContext;

    /* init initial state */
    _ChangeState(pHB, eHBCreating);

    cbTotal = *pcbHBContext - SIZEOF(_HBContext) + 1;

    ChkDR(DRM_UTL_EnsureDataAlignment((DRM_BYTE*)pHB->rgbXmlContext, 
                                       cbTotal, 
                                       (DRM_BYTE**)&pHB->pbXmlContext, 
                                       &cbAligned, 
                                       SIZEOF(DRM_DWORD), 
                                       &cbAdjust));

    pHB->wContextSize -= cbAdjust;
    
    pHB->eHeaderType = eHeaderType;
    
    /* Init XML Builder 
    ** Add document root tag: <WRMHEADER version=X.0.0.0"> 
    */
    ChkDR(DRM_XMB_CreateDocument(cbAligned, 
                                 pHB->pbXmlContext, 
                                &g_dstrTagWrmHeader));
                                 
    if ( pHB->eHeaderType == DRM_CSP_V2_HEADER 
      || pHB->eHeaderType == DRM_CSP_V2_4_HEADER )
    {
       ChkDR(DRM_XMB_AddAttribute(pHB->pbXmlContext, &g_dstrAttributeVersion, &g_dstrAttributeVersion2Value));
    }
    else if ( pHB->eHeaderType == DRM_CSP_V4_HEADER )
    {
       ChkDR(DRM_XMB_AddAttribute(pHB->pbXmlContext, &g_dstrAttributeHeaderXmlnsName, &g_dstrAttributeHeaderXmlnsValue));
       ChkDR(DRM_XMB_AddAttribute(pHB->pbXmlContext, &g_dstrAttributeVersion, &g_dstrAttributeVersion4Value));
    }
   

    /* open <DATA> node to the root node  */
    ChkDR(DRM_XMB_OpenNode(pHB->pbXmlContext, &g_dstrTagData));

    /* change state */
    _ChangeState(pHB, eHBInited);

ErrorExit:
    return dr;
}


/*
**
*/
DRM_API DRM_RESULT DRM_CALL DRM_HB_ReallocHeader(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbOldHBContext,
    IN DRM_DWORD cbNewHBContext,
    __in_bcount( cbNewHBContext ) DRM_BYTE *pbNewHBContext)
{
    DRM_RESULT  dr     = DRM_SUCCESS;
    _HBContext *pOldHB = (_HBContext*)pbOldHBContext;
    _HBContext *pNewHB = (_HBContext*)pbNewHBContext;

    ChkArg(pbOldHBContext && pbNewHBContext  && pOldHB->eState!=eHBCreating
        && cbNewHBContext >= SIZEOF(_HBContext)   /* Prevent potential overflow */
        && cbNewHBContext > pOldHB->wContextSize);

    /* copy old context to new buffer */
    ZEROMEM(pbNewHBContext,  cbNewHBContext);
    pNewHB->wContextSize   = cbNewHBContext;
    pNewHB->dwItemsAdded   = pOldHB->dwItemsAdded;
    pNewHB->eState         = pOldHB->eState;
    pNewHB->fKIDAdded      = pOldHB->fKIDAdded;
    pNewHB->fLAINFOAdded   = pOldHB->fLAINFOAdded;
    pNewHB->fChecksumAdded = pOldHB->fChecksumAdded;
    
    ChkDR(DRM_XMB_ReallocDocument(pOldHB->pbXmlContext, 
        cbNewHBContext-SIZEOF(_HBContext)+1, pNewHB->pbXmlContext));

ErrorExit:
    return dr;
}


/*
**
*/
DRM_API DRM_RESULT DRM_CALL DRM_HB_GetContextSize(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    OUT DRM_DWORD *pcbHBContext)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _HBContext *pHB=(_HBContext*)pbHBContext;
    
    ChkArg(pbHBContext && pcbHBContext);  /* && pHB->eState!=eHBCreating); */

    /* current context size */
    *pcbHBContext = pHB->wContextSize;

ErrorExit:
    return dr;
}


/*
** 
*/
DRM_API DRM_RESULT DRM_CALL DRM_HB_CloseHeader(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    IN  DRM_CRYPTO_CONTEXT *pCryptoContext,
    IN  DRM_CONST_STRING   *pdstrPrivKey,      /* base64 encoded */
    __deref_out_bcount( *pcbHeaderXML ) DRM_BYTE **ppbHeaderXML,
    OUT DRM_DWORD          *pcbHeaderXML)
{
    DRM_RESULT  dr                   = DRM_SUCCESS;
    _HBContext *pHB                  = (_HBContext*)pbHBContext;    
    DRM_STRING  dstrDataNodeFragment = EMPTY_DRM_STRING;


    ChkArg( pbHBContext  != NULL );
    ChkArg( pcbHeaderXML != NULL );
    ChkArg( ppbHeaderXML != NULL );

    if ( pdstrPrivKey != NULL )
    {
        ChkArg( pCryptoContext != NULL );
    }
    
    if (pHB->eState!=eHBAddedData && pHB->eState!=eHBSigning)
    {
        if (!pHB->fKIDAdded)
        {
            ChkDR(DRM_E_NOKIDINHEADER);
        }
        else if (!pHB->fLAINFOAdded)
        {
            ChkDR(DRM_E_NOLAINFOINHEADER);
        }
        else if (!pHB->fChecksumAdded)
        {
            ChkDR(DRM_E_NOCHECKSUMINHEADER);
        }
        else
        {
            ChkDR(DRM_E_CH_INVALID_HEADER);
        }
    }

    if ( pHB->eState!= eHBSigning )
    {
        _ChangeState(pHB, eHBSigning);
    }

    /* close <DATA> node and get the XML fragment of it */
    Tracked_N_ChkDR(pHB, DRM_XMB_CloseCurrNode(pHB->pbXmlContext, &dstrDataNodeFragment));
    
    /* Sign the <DATA> node if a crypto context and private key were provided */
    if ( ( pHB->eHeaderType == DRM_CSP_V2_HEADER || pHB->eHeaderType == DRM_CSP_V2_4_HEADER)
      && ( pCryptoContext != NULL ) 
      && ( pdstrPrivKey->pwszString != NULL ) 
      && ( pdstrPrivKey->cchString > 0 ) )
    {
        ChkDR(_SignTheHeader(pHB, pCryptoContext, pdstrPrivKey, &dstrDataNodeFragment));
    }
    
    Tracked_N_ChkDR(pHB, DRM_XMB_CloseDocument(pHB->pbXmlContext, &pHB->szXMLString));

    *ppbHeaderXML = PB_DSTR( &pHB->szXMLString );
    *pcbHeaderXML = CB_DSTR( &pHB->szXMLString );
    
    /* make sure the context will not be used to call the API again */
    _ChangeState(pHB, eHBCreated);
    
ErrorExit:
    return dr;
}


/*
**
*/
DRM_API DRM_RESULT DRM_CALL DRM_HB_SetAttribute(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    IN const DRM_CONST_STRING *pdstrAttrName,
    IN const DRM_CONST_STRING *pdstrAttrValue)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _HBContext *pHB=(_HBContext*)pbHBContext;
    
    ChkArg(pbHBContext);
    ChkDRMString(pdstrAttrName);
    ChkDRMString(pdstrAttrValue);
    ChkArg( pHB->eState == eHBInited ||
            pHB->eState == eHBAddingData ||
            pHB->eState == eHBAddedData );

    /* Add <ACTION> node */
    if ( pHB->eState!=eHBAddingData )
    {
        _ChangeState(pHB, eHBAddingData);
    }

    Tracked_N_ChkDR(pHB, DRM_XMB_OpenNode(pHB->pbXmlContext, pdstrAttrName));
    Tracked_N_ChkDR(pHB, DRM_XMB_AddData(pHB->pbXmlContext, pdstrAttrValue));
    Tracked_N_ChkDR(pHB, DRM_XMB_CloseCurrNode(pHB->pbXmlContext, NULL));

    _ChangeState(pHB, eHBAddedData);
    
ErrorExit:
    return dr;
}

/*
**
*/
DRM_API DRM_RESULT DRM_CALL DRM_HB_OpenNode(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    IN const DRM_CONST_STRING *pdstrNodeName )
{
    DRM_RESULT dr   = DRM_SUCCESS;
    _HBContext *pHB = (_HBContext*) pbHBContext;
    
    ChkArg( pbHBContext != NULL);
    ChkArg( pdstrNodeName !=NULL );

    ChkDR( DRM_XMB_OpenNode( pHB->pbXmlContext, pdstrNodeName) );

ErrorExit:
    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_HB_CloseCurrNode(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _HBContext *pHB = (_HBContext*) pbHBContext;

    ChkArg( pbHBContext != NULL );
    ChkDR( DRM_XMB_CloseCurrNode( pHB->pbXmlContext, NULL ) );

ErrorExit:
    return dr;
}

/*
**
*/
DRM_API DRM_RESULT DRM_CALL DRM_HB_AddData(
    __in_bcount( __CB_DECL( SIZEOF( _HBContext ) ) ) DRM_BYTE *pbHBContext,
    IN const DRM_CONST_STRING *pdstrXMLData )
{
    DRM_RESULT dr   = DRM_SUCCESS;
    _HBContext *pHB = (_HBContext*) pbHBContext;
    
    ChkArg( pbHBContext != NULL);
    ChkArg( pdstrXMLData !=NULL );

    ChkDR( DRM_XMB_AddData(pHB->pbXmlContext, pdstrXMLData) );
ErrorExit:
    return dr;
}


/*
**
*/
DRM_API DRM_RESULT DRM_CALL DRM_HB_SetKeyID(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    IN const DRM_CONST_STRING *pdstrKID)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _HBContext *pHB=(_HBContext*)pbHBContext;
    
    ChkArg(pbHBContext);
    ChkDRMString(pdstrKID);
    ChkArg ( pHB->eState == eHBInited || pHB->eState == eHBAddingData ||
        pHB->eState == eHBAddedData );

    if ( pHB->fKIDAdded )
    {
        ChkDR(DRM_E_DUPLICATEDHEADERATTRIBUTE);
    }

    /* Validate supplied KID, as well as store it for use in checksum calculation */
    ChkDR( DRM_UTL_DecodeKID( pdstrKID, &pHB->KID ) );

    /* Set the attribute */
    ChkDR(DRM_HB_SetAttribute(pbHBContext, &g_dstrTagKID, pdstrKID));
    
    pHB->fKIDAdded = TRUE;

ErrorExit:
    return dr;
}

/*
**
*/
DRM_API DRM_RESULT DRM_CALL DRM_HB_SetLicAcqUrl(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    IN const DRM_CONST_STRING *pdstrURL)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _HBContext *pHB=(_HBContext*)pbHBContext;
    
    ChkArg(pbHBContext);
    ChkDRMString(pdstrURL);
    ChkArg ( pHB->eState == eHBInited || pHB->eState == eHBAddingData ||
        pHB->eState == eHBAddedData );

    if ( pHB->fLAINFOAdded )
    {
        ChkDR(DRM_E_DUPLICATEDHEADERATTRIBUTE);
    }
    ChkDR(DRM_HB_SetAttribute(pbHBContext, &g_dstrTagLAINFO, pdstrURL));
    pHB->fLAINFOAdded = TRUE;
    
ErrorExit:
    return dr;
}


/*
** Perform checksum algo to the given content key and set the check to header
*/
DRM_API DRM_RESULT DRM_CALL DRM_HB_SetChecksum(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    IN const DRM_CONST_STRING *pdstrContentKey)
{
    DRM_RESULT dr = DRM_SUCCESS;
    _HBContext      *pHB        = (_HBContext*)pbHBContext;
    DRM_DWORD        cchEncoded = 0;
    DRM_BYTE         rgbKeyContent [__CB_DECL(DRMCIPHERKEYLEN_MAX)] = { 0 };
    DRM_DWORD        cbContentKey = DRMCIPHERKEYLEN_MAX;
    DRM_CONST_STRING dstrChecksum = EMPTY_DRM_STRING;
    
    ChkArg(pbHBContext);
    ChkDRMString(pdstrContentKey);
    ChkArg ( pHB->eState == eHBInited || pHB->eState == eHBAddingData ||
        pHB->eState == eHBAddedData );

    ChkBOOL( !pHB->fChecksumAdded, DRM_E_DUPLICATEDHEADERATTRIBUTE);
    ChkBOOL( pHB->fKIDAdded, DRM_E_NOKIDINHEADER ); /* KID is now required due to AES checksum algorithm */

    ChkDR(DRM_B64_DecodeW(pdstrContentKey, &cbContentKey, rgbKeyContent, 0));

    if( cbContentKey  == DRMCIPHERKEYLEN_RC4 )
    {
        DRM_SHA_CONTEXT  shaVal     = DRM_SHA_CONTEXT_DEFAULT;
        DRM_BYTE         res           [__CB_DECL(DRM_SHA1_DIGEST_LEN + 1)]     = { 0 };
        DRM_INT          lCount     = 0;

        /* Run SHA on key SHA_ITERATIONS times. */
        /* First copy key into res. */    
        DRMASSERT ( cbContentKey < DRM_SHA1_DIGEST_LEN+1 ); /* Make sure we don't exceed buffer capacity in res. */    
        ZEROMEM(res, DRM_SHA1_DIGEST_LEN+1);
        ChkBOOL( (__CB_DECL(DRM_SHA1_DIGEST_LEN + 1) >= cbContentKey), DRM_E_BUFFERTOOSMALL); 
        MEMCPY (res, rgbKeyContent, cbContentKey);
        for (lCount = 0; lCount < SHA_ITERATIONS; lCount++)
        {
            ChkDR( DRM_SHA_Init( &shaVal, eDRM_SHA_1 ) );
            ChkDR( DRM_SHA_Update(res, DRM_SHA1_DIGEST_LEN+1, &shaVal ) );
            ChkDR( DRM_SHA_Finalize( &shaVal, DRM_SHA1_DIGEST_LEN, res ) );
        }

        /* take first CHECKSUM_LENGTH bytes of res and use it to encode. */
        cchEncoded = CCH_BASE64_EQUIV( CHECKSUM_LENGTH );
        ChkBOOL( (cchEncoded * SIZEOF(DRM_WCHAR)) < LOCALSTACKSIZE , DRM_E_OUTOFMEMORY); /* LOCALSTACKSIZE too small */
        ZEROMEM(pHB->rgbLocalStack, cchEncoded * SIZEOF(DRM_WCHAR));
        ChkDR(DRM_B64_EncodeW(res, CHECKSUM_LENGTH, (DRM_WCHAR*)pHB->rgbLocalStack, &cchEncoded, 0));
    }
    else if( cbContentKey == DRM_AES_KEYSIZE_128 )
    {
        DRM_AES_KEY aesKey = {0};
        DRM_BYTE    rgbBlock[SIZEOF(DRM_KID)];
        
        ChkDR( Oem_Aes_SetKey( rgbKeyContent, &aesKey ) );
        MEMCPY( rgbBlock, pHB->KID.rgb, SIZEOF( DRM_KID ) );
        dr = DRM_Aes_EcbEncryptData(&aesKey, rgbBlock, SIZEOF( DRM_KID ) );
        Oem_Aes_ZeroKey( &aesKey );
        ChkDR( dr );
        
        cchEncoded = CCH_BASE64_EQUIV( DRM_AES_CK_CHECKSUM_LENGTH );
        ChkBOOL( (cchEncoded * SIZEOF(DRM_WCHAR)) < LOCALSTACKSIZE, DRM_E_OUTOFMEMORY); /* LOCALSTACKSIZE too small */
        ZEROMEM(pHB->rgbLocalStack, cchEncoded * SIZEOF(DRM_WCHAR));
        ChkDR(DRM_B64_EncodeW(rgbBlock, DRM_AES_CK_CHECKSUM_LENGTH, (DRM_WCHAR*)pHB->rgbLocalStack, &cchEncoded, 0));
    }
    else
    {
        ChkDR( DRM_E_CH_BAD_KEY );
    }
    
    /* set the attribute */   
    dstrChecksum.pwszString = (DRM_WCHAR*)pHB->rgbLocalStack;
    dstrChecksum.cchString = cchEncoded;
    ChkDR(DRM_HB_SetAttribute(pbHBContext, &g_dstrTagChecksum, &dstrChecksum));
    pHB->fChecksumAdded = TRUE;

ErrorExit:
    return dr;
}



EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmhmac.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <drmcommon.h>
#include <drmhmac.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

/*********************************************************************
**
**  Function:  HMACInit
**
**  Synopsis:  HMAC is a keyed-hash message authentication code.  It creates a
**             unique hash of data based on the data and an arbitrary key.
**
**  Arguments:  
**     [f_pContextHMAC] : Context structure to contain a running HMAC calculation.
**     [f_eAlgorithm]   : Specifies the SHA algorithm to perform HMAC over
**     [f_pbKey]        : Pointer a array of bytes to as the HMAC key.
**     [f_cbKey]        : Length of pbKey in bytes.
**
**  Returns: 
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument is NULL or invalid
**
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HMAC_Init(
    __inout_ecount( 1 )          DRM_HMAC_CONTEXT              *f_pContextHMAC,
    __in                         eDRM_SHA_SUPPORTED_ALGORITHMS  f_eShaAlgorithm,
    __in_bcount( f_cbKey ) const DRM_BYTE                      *f_pbKey,
    __in                         DRM_DWORD                      f_cbKey)
{
    DRM_RESULT dr             = DRM_SUCCESS;
    DRM_DWORD  cbShaBlockSize = 0;
    DRM_DWORD  iCount         = 0;

    ChkArg( f_pContextHMAC != NULL );
    ChkArg( f_cbKey        != 0 );
    ChkArg( f_pbKey        != NULL);
    
    f_pContextHMAC->fInitialized = FALSE;
    
    switch( f_eShaAlgorithm )
    {
    case eDRM_SHA_1:
        cbShaBlockSize = DRM_SHA1_BLOCK_SIZE;
        break;
    case eDRM_SHA_256:
        cbShaBlockSize = SHA256_BLOCK_SIZE_IN_BYTES;
        break;
    default:
        ChkArg( FALSE );
        break;                        
    }

    /*
    ** Only use the first SHA_BLOCK_SIZE bytes 
    */
    if( f_cbKey > cbShaBlockSize )
    {        
        f_cbKey = cbShaBlockSize;
    }

    ZEROMEM( f_pContextHMAC, SIZEOF( *f_pContextHMAC ) );

    for( iCount = 0; iCount < f_cbKey; iCount++ )
    {
        PUT_BYTE( f_pContextHMAC->rgbBuffer, iCount, GET_BYTE( f_pbKey, iCount ) ^ 0x36 );
    }
    for( ; iCount < cbShaBlockSize ; iCount++ )
    {
        PUT_BYTE( f_pContextHMAC->rgbBuffer, iCount, 0 ^ 0x36 );
    }

    ChkDR( DRM_SHA_Init( &( f_pContextHMAC->shaContext ), f_eShaAlgorithm ) );
    ChkDR( DRM_SHA_Update( f_pContextHMAC->rgbBuffer, cbShaBlockSize, &( f_pContextHMAC->shaContext ) ) );

    /*
    ** Update the internal context buffer so we don't have to hold onto the key. 
    */
    for( iCount = 0; iCount < f_cbKey; iCount++ )
    {
        PUT_BYTE( f_pContextHMAC->rgbBuffer, iCount, GET_BYTE( f_pbKey, iCount ) ^ 0x5C );
    }
    for( ; iCount < cbShaBlockSize ; iCount++ )
    {
        PUT_BYTE( f_pContextHMAC->rgbBuffer, iCount, 0 ^ 0x5C );
    }
    
    f_pContextHMAC->fInitialized = TRUE;

ErrorExit:
    return dr;
}


/*********************************************************************
**
**  Function:  DRM_HMAC_Update
**
**  Synopsis:  Update the HMAC with the specified data
**
**  Arguments:  
**     [f_pContextHMAC] : Valid DRM_HMAC_CONTEXT create with DRM_HMAC_Init
**     [f_pbData]       : Data to add the the secure hash
**     [f_cbData]       : Length of pbData in bytes
**
**  Returns: 
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument is NULL or invalid
**
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HMAC_Update(
    __inout_ecount( 1 )           DRM_HMAC_CONTEXT  *f_pContextHMAC,
    __in_bcount( f_cbData ) const DRM_BYTE          *f_pbData,
    __in                          DRM_DWORD          f_cbData  )
{
    return DRM_HMAC_UpdateOffset( f_pContextHMAC, f_pbData, 0, f_cbData ); 
}

/*********************************************************************
**
**  Function:  DRM_HMAC_UpdateOffset
**
**  Synopsis:  Update the HMAC with the specified data, using an 
**             offset (index)
**
**  Arguments:  
**     [f_pContextHMAC] : Valid DRM_HMAC_CONTEXT create with DRM_HMAC_Init
**     [f_pbData]       : Data to add the the secure hash
**     [f_ibData]       : Offset of data buffer from f_pbData
**     [f_cbData]       : Length of pbData in bytes
**
**  Returns: 
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument is NULL or invalid
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HMAC_UpdateOffset(
    __inout_ecount( 1 )                 DRM_HMAC_CONTEXT  *f_pContextHMAC,
    __in_bcount( f_cbData + f_ibData )  const DRM_BYTE    *f_pbData,
    __in                                DRM_DWORD          f_ibData,
    __in                                DRM_DWORD          f_cbData  )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pContextHMAC != NULL );
    ChkArg( f_pContextHMAC->fInitialized );
    
    if( f_cbData > 0 )
    {        
        ChkArg( f_pbData != NULL );
        ChkDR( DRM_SHA_UpdateOffset( f_pbData, 
                                     f_ibData, 
                                     f_cbData, 
                                    &( f_pContextHMAC->shaContext ) ) );
    }

ErrorExit:
    return dr;

}

/*********************************************************************
**
**  Function:  DRM_HMAC_Finalize
**
**  Synopsis:  Closes the MHAC context and returns the computed secure hash.
**
**  Arguments:  
**     [f_pContextHMAC] : Valid DRM_HMAC_CONTEXT created with DRM_HMAC_Init
**     [f_pbKeyedHash]  : Pointer to byte array that will recieve the secure hash
**     [f_cbKeyedHash]  : Length of pbKeyedHash in bytes
**
**  Returns: 
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument is NULL or invalid
**
**  Notes:  cbKeyedHash must be less than or equal to SHA_DIGEST_LEN and greater than 0.
**
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HMAC_Finalize(
    __inout_ecount( 1 )           DRM_HMAC_CONTEXT  *f_pContextHMAC,
    __out_bcount( f_cbKeyedHash ) DRM_BYTE          *f_pbKeyedHash,
    __in                          DRM_DWORD          f_cbKeyedHash )
{
    return DRM_HMAC_FinalizeOffset( f_pContextHMAC, f_pbKeyedHash, 0, f_cbKeyedHash );
}

/*********************************************************************
**
**  Function:  DRM_HMAC_FinalizeOffset
**
**  Synopsis:  Closes the MHAC context and returns the computed secure hash,
**             using an offset (index)
**
**  Arguments:  
**     [f_pContextHMAC] : Valid DRM_HMAC_CONTEXT created with DRM_HMAC_Init
**     [f_pbKeyedHash]  : Pointer to byte array that will recieve the secure hash
**     [f_ibKeyedHash]  : Offset of keyed hash buffer from pbKeyedHash
**     [f_cbKeyedHash]  : Length of pbKeyedHash in bytes
**
**  Returns: 
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument is NULL or invalid
**
**  Notes:  cbKeyedHash must be less than or equal to SHA_DIGEST_LEN and greater than 0.
**
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HMAC_FinalizeOffset(
    __inout_ecount( 1 )                             DRM_HMAC_CONTEXT  *f_pContextHMAC,
    __out_bcount( f_cbKeyedHash + f_ibKeyedHash )   DRM_BYTE          *f_pbKeyedHash,
    __in                                            DRM_DWORD          f_ibKeyedHash,
    __in                                            DRM_DWORD          f_cbKeyedHash )
{
    DRM_RESULT dr             = DRM_SUCCESS;
    DRM_DWORD  cbShaDigestLen = 0;
    DRM_DWORD  cbShaBlockSize = 0;

    ChkArg( f_pContextHMAC != NULL );
    ChkArg( f_pContextHMAC->fInitialized );
    ChkArg( f_pbKeyedHash  != NULL );
    ChkArg( f_cbKeyedHash  != 0 );
    
    switch( f_pContextHMAC->shaContext.eAlgorithm )
    {
    case eDRM_SHA_1:
        cbShaDigestLen = DRM_SHA1_DIGEST_LEN;
        cbShaBlockSize = DRM_SHA1_BLOCK_SIZE;
        f_cbKeyedHash = min( f_cbKeyedHash, ( DRM_DWORD )DRM_SHA1_DIGEST_LEN );
        break;
    case eDRM_SHA_256:
        cbShaDigestLen = SHA256_DIGEST_SIZE_IN_BYTES;
        cbShaBlockSize = SHA256_BLOCK_SIZE_IN_BYTES;
        f_cbKeyedHash = min( f_cbKeyedHash, ( DRM_DWORD )SHA256_DIGEST_SIZE_IN_BYTES );
        break;
    default:
        ChkArg( FALSE );
        break;                        
    }

    /*
    ** Finish the first SHA operation. 
    */
    ChkDR( DRM_SHA_Finalize( &( f_pContextHMAC->shaContext ), cbShaDigestLen, f_pContextHMAC->shaDigest ) );

    /*
    ** Start second SHA operation 
    */
    ChkDR( DRM_SHA_Init( &( f_pContextHMAC->shaContext ), f_pContextHMAC->shaContext.eAlgorithm ) );
    ChkDR( DRM_SHA_Update( f_pContextHMAC->rgbBuffer, cbShaBlockSize, &( f_pContextHMAC->shaContext ) ) );
    ChkDR( DRM_SHA_Update( f_pContextHMAC->shaDigest, cbShaDigestLen, &( f_pContextHMAC->shaContext ) ) );
    ChkDR( DRM_SHA_Finalize( &( f_pContextHMAC->shaContext ), cbShaDigestLen, f_pContextHMAC->shaDigest ) );
    
    DRM_BYT_CopyBytes( f_pbKeyedHash, f_ibKeyedHash, f_pContextHMAC->shaDigest, 0, f_cbKeyedHash );         

ErrorExit:
    if ( f_pContextHMAC != NULL ) 
    {
        OEM_SECURE_ZERO_MEMORY( f_pContextHMAC->rgbBuffer, SIZEOF(f_pContextHMAC->rgbBuffer) );
    }
    return dr;

}


/*********************************************************************
**
**  Function:  DRM_HMAC_CreateMAC
**
**  Synopsis:  Creates a MAC using a key provided by the caller.
**
**  Arguments:  
**     [f_eAlgorithm] : Specifies the SHA algorithm to perform HMAC over
**     [f_pbKey]      : Key to create MAC
**     [f_cbKey]      : Length of pbKey
**     [f_pbData]     : Data to create the MAC over
**     [f_ibData]     : Offset of data buffer from f_pbData
**     [f_cbData]     : Length of f_pbData in DRM_BYTEs
**     [f_cbMAC]      : Length of f_pbMAC in DRM_BYTEs
**     [f_ibMAC]      : Offset of MAC buffer from f_pbData
**     [f_pbMAC]      : Buffer where the signature will be returned.
**
**  Notes:  Use DRM_HMAC_VerifyMAC to verify a signature created with DRM_HMAC_CreateMAC.
**
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HMAC_CreateMAC(
    __in                                      eDRM_SHA_SUPPORTED_ALGORITHMS  f_eAlgorithm,                                        
    __in_bcount( f_cbKey )              const DRM_BYTE                      *f_pbKey,
    __in                                      DRM_DWORD                      f_cbKey,
    __in_bcount( f_cbData + f_ibData )  const DRM_BYTE                      *f_pbData,
    __in                                      DRM_DWORD                      f_ibData,  
    __in                                      DRM_DWORD                      f_cbData,      
    __out_bcount( f_cbMAC + f_ibMAC )         DRM_BYTE                      *f_pbMAC,
    __in                                      DRM_DWORD                      f_ibMAC,
    __in                                      DRM_DWORD                      f_cbMAC )
{
    DRM_RESULT       dr    = DRM_SUCCESS;
    DRM_HMAC_CONTEXT hmac  = DRM_HMAC_CONTEXT_DEFAULT;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMHMAC, PERF_FUNC_DRM_HMAC_CreateMAC );     

    ChkDR( DRM_HMAC_Init( &hmac, f_eAlgorithm, f_pbKey, f_cbKey ) );
    ChkDR( DRM_HMAC_UpdateOffset( &hmac, f_pbData, f_ibData, f_cbData ) ); 
    ChkDR( DRM_HMAC_FinalizeOffset( &hmac, f_pbMAC, f_ibMAC, f_cbMAC ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*********************************************************************
**
**  Function:  DRM_HMAC_VerifyMAC
**
**  Synopsis:  Verifies a MAC created with DRM_HMAC_CreateMAC.
**
**  Arguments:  
**     [f_eAlgorithm] : Specifies the SHA algorithm to perform HMAC over
**     [f_pbKey]      : Key used to create MAC
**     [f_cbKey]      : Length of pbKey
**     [f_pbData]     : Data to verify
**     [f_ibData]     : Offset of data buffer from f_pbData
**     [f_cbData]     : Length of f_pbData in DRM_BYTEs
**     [f_cbMAC]      : Length of f_pbMAC in DRM_BYTEs
**     [f_ibMAC]      : Offset of MAC buffer from f_pbData
**     [f_pbMAC]      : Buffer containing the signature to verify
**
**  Notes:  Use DRM_HMAC_CreateMAC to create a MAC
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HMAC_VerifyMAC(
    __in                                      eDRM_SHA_SUPPORTED_ALGORITHMS  f_eAlgorithm,                                        
    __in_bcount( f_cbKey )              const DRM_BYTE                      *f_pbKey,
    __in                                      DRM_DWORD                      f_cbKey,
    __in_bcount( f_cbData + f_ibData )  const DRM_BYTE                      *f_pbData,
    __in                                      DRM_DWORD                      f_ibData,   
    __in                                      DRM_DWORD                      f_cbData,     
    __in_bcount( f_cbMAC + f_ibMAC )    const DRM_BYTE                      *f_pbMAC,
    __in                                      DRM_DWORD                      f_ibMAC,
    __in                                      DRM_DWORD                      f_cbMAC )
{
    DRM_RESULT       dr   = DRM_SUCCESS;
    DRM_BYTE         rgbMAC[__CB_DECL( DRM_SHA_DIGEST_LEN_MAX )] = { 0 };    

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMHMAC, PERF_FUNC_DRM_HMAC_VerifyMAC );

    ChkBOOL( f_cbMAC <= DRM_SHA_DIGEST_LEN_MAX, DRM_E_INVALID_SIGNATURE );

    ChkDR( DRM_HMAC_CreateMAC( f_eAlgorithm,
                               f_pbKey,
                               f_cbKey,
                               f_pbData,
                               f_ibData,
                               f_cbData,                               
                               rgbMAC,                               
                               0,
                               f_cbMAC ) );

    ChkBOOL( DRM_BYT_CompareBytes( rgbMAC, 0, f_pbMAC, f_ibMAC, f_cbMAC ) == 0,
             DRM_E_INVALID_SIGNATURE );    

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmhds.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/



/*
** NOTES:
** - init muti-access in _SlotContext and _ChildBlockHDR using ui64TimeStamp.
** - Delete a Namespace may conflict with an opened Namespace.
*/

/*
** Rules:
** - parent of any FreeBlock is SRN (ROOTPARENTNUM, 0x00)
** - parent of any Namespace Root block is SRN (ROOTPARENTNUM, ie: 0x00)
** - The NamespaceStore's Root block will not be free'd even when it is empty.
** - The Namespace Root block of any Namespaces will not be free'd even when it is empty.
** - When deleting a namespace and its blocks, ALL of the blocks including the Root will be free'd.
** ? Each block header contains the namespace's HashKey that it belongs for error checking.
**
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmsha1.h>
#include <drmdatastore.h>
#include <drmhds.h>
#include "drmhds_impl.h"
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;


/* undefine to print trace messages for lock/unlock functions */
/* #define _TRACELOCK 1 */


#define ISOVERSIZESLOT(slotsize, cfg) \
    ((SIZEOF(_SlotHeader)+(slotsize))>(cfg)->nImagesize_ChildBlockPayload?TRUE:FALSE)

static const DRM_WORD  NsStoreNumofChildren=16;
static const DRM_BYTE  BLOCK_SIGNATURE [] =
{
    TWO_BYTES(0xFF, 0xFE), TWO_BYTES(0xFD, 0xFC)
};

static const DRM_CHAR  DEFAULTNS_HASHKEY1 [] = { TWO_BYTES( 'D', 'R'), TWO_BYTES( 'M', '_'),  TWO_BYTES( 'H', 'D'), TWO_BYTES( 'S', '_'), TWO_BYTES( 'H', 'A'), TWO_BYTES( 'S', 'H'), TWO_BYTES( 'K', 'E'), TWO_BYTES( 'Y', '1') };
static const DRM_CHAR  DEFAULTNS_HASHKEY2 [] = { TWO_BYTES( 'D', 'R'), TWO_BYTES( 'M', '_'),  TWO_BYTES( 'H', 'D'), TWO_BYTES( 'S', '_'), TWO_BYTES( 'H', 'A'), TWO_BYTES( 'S', 'H'), TWO_BYTES( 'K', 'E'), TWO_BYTES( 'Y', '2') };

#define DRM_HDS_FILE_VERSION_0   0x000A0000
#define DRM_HDS_FILE_VERSION_1   0x000A0001
#define DRM_HDS_FILE_VERSION_2   0x000A0002
#define HDS_FILEHEADERSIZE          4096


/**********************************************************************
**
** Function :   DRM_HDS_InitializeDST
**
** Synopsis :   Initializes function pointers and other members of the DST
**              structure for use with an HDS implementation.
**
** Arguments :
**      [f_pDst] : Returns the initialized DST structure.
**
** Returns :
**      DRM_SUCCESS      - Success.
**      DRM_E_INVALIDARG - An argument was NULL or improperly initialized.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_InitializeDST( __out DRM_DST *f_pDst )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pDst != NULL );

    f_pDst->eImplementationType                          = eDRM_DST_HDS;
    f_pDst->oDataStoreInterface.pfnInit                  = DRM_HDS_Init;
    f_pDst->oDataStoreInterface.pfnUninit                = DRM_HDS_Uninit;
    f_pDst->oDataStoreInterface.pfnCreateStore           = DRM_HDS_CreateStore;
    f_pDst->oDataStoreInterface.pfnOpenStore             = DRM_HDS_OpenStore;
    f_pDst->oDataStoreInterface.pfnCloseStore            = DRM_HDS_CloseStore;
    f_pDst->oDataStoreInterface.pfnCommitStore           = DRM_HDS_CommitStore;
    f_pDst->oDataStoreInterface.pfnCleanupStore          = DRM_HDS_CleanupStore;
    f_pDst->oDataStoreInterface.pfnOpenNamespace         = DRM_HDS_OpenNamespace;
    f_pDst->oDataStoreInterface.pfnDeleteNamespace       = DRM_HDS_DeleteNamespace;
    f_pDst->oDataStoreInterface.pfnCloseNamespace        = DRM_HDS_CloseNamespace;
    f_pDst->oDataStoreInterface.pfnCommitNamespace       = DRM_HDS_CommitNamespace;
    f_pDst->oDataStoreInterface.pfnMakeSlotHint          = DRM_HDS_MakeSlotHint;
    f_pDst->oDataStoreInterface.pfnOpenSlot              = DRM_HDS_OpenSlot;
    f_pDst->oDataStoreInterface.pfnCloseSlot             = DRM_HDS_CloseSlot;
    f_pDst->oDataStoreInterface.pfnDeleteSlot            = DRM_HDS_DeleteSlot;
    f_pDst->oDataStoreInterface.pfnInitSlotEnum          = DRM_HDS_InitSlotEnum;
    f_pDst->oDataStoreInterface.pfnSlotEnumNext          = DRM_HDS_SlotEnumNext;
    f_pDst->oDataStoreInterface.pfnSlotEnumReloadCurrent = DRM_HDS_SlotEnumReloadCurrent;
    f_pDst->oDataStoreInterface.pfnSlotEnumDeleteCurrent = DRM_HDS_SlotEnumDeleteCurrent;
    f_pDst->oDataStoreInterface.pfnBlockScanDelete       = DRM_HDS_BlockScanDelete;
    f_pDst->oDataStoreInterface.pfnSlotResize            = DRM_HDS_SlotResize;
    f_pDst->oDataStoreInterface.pfnSlotSeek              = DRM_HDS_SlotSeek;
    f_pDst->oDataStoreInterface.pfnSlotRead              = DRM_HDS_SlotRead;
    f_pDst->oDataStoreInterface.pfnSlotWrite             = DRM_HDS_SlotWrite;

ErrorExit:
    return dr;
}


/* forward declaration */
static DRM_RESULT _HdsRemoveSlot(
    _SlotContext    *pSlotCtx,
    _ERemoveSlotMode eMode);

static DRM_RESULT _HdsBlockNum2FilePos(
    IN  _HdsContext *pHDS,
    IN  DRM_DWORD    nBlkNum,
    OUT DRM_DWORD   *pnFilePos);

static DRM_RESULT _HdsPreAlloc(
    IN  _HdsContext *f_pHDS,
    IN  DRM_DWORD    f_PreAllocFileSizeInKB,
    IN  DRM_BOOL     f_fUpToSpecifiedSize,
    OUT DRM_DWORD   *f_pnNextBlockNum);



/*
** Validate an _NSEntry from disk
*/
static DRM_NO_INLINE DRM_RESULT _HdsValidateNSEntryFromDisk(
    _HdsContext *f_pHDS,
    _NSEntry    *f_pNsEntry )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwFilePos  = 0;
    DRM_DWORD dwFileSize = 0;

    DRMASSERT( f_pHDS     != NULL
        &&     f_pNsEntry != NULL );

    /* verify # of child blocks in Alloc table */
    if(  f_pNsEntry->wMaxNumChildren == 0
      || f_pNsEntry->wMaxNumChildren > DRM_HDS_MAXIMUM_CHILDREN
      || f_pNsEntry->nNSRBlockNum    == 0
      || f_pNsEntry->wBloomBytesM    > HDS_CHILDBLOCK_BLOOM_MAX_M
      || f_pNsEntry->wBloomK         > HDS_CHILDBLOCK_BLOOM_MAX_K )
    {
        ChkDR( DRM_E_DSTCORRUPTED );
    }

    /* validate root block# */
    ChkDR(_HdsBlockNum2FilePos(f_pHDS, f_pNsEntry->nNSRBlockNum, &dwFilePos));
    ChkBOOL(Oem_File_GetSize(f_pHDS->fp, &dwFileSize), DRM_E_DSTCORRUPTED);
    ChkBOOL((dwFilePos < dwFileSize), DRM_E_DSTCORRUPTED);

ErrorExit:

    return dr;
}

/*
** Compute the block# from a block's given file pos.
*/
static DRM_RESULT _HdsFilePos2BlockNum(
    IN  _HdsContext *f_pHDS,
    IN  DRM_DWORD    f_dwFilePos,
    OUT DRM_DWORD   *f_pnBlockNum)
{
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_DWORD  nBlockNum = 0;

    ChkArg(ISVALIDCONTEXT(f_pHDS, eHdsContextSignature));

    DRMASSERT(f_pHDS->fInited == TRUE
           && f_pnBlockNum    != NULL);

    if ( f_dwFilePos < HDS_FILEHEADERSIZE )
    {
        DRMASSERT(FALSE);
    }

    nBlockNum = (f_dwFilePos - HDS_FILEHEADERSIZE) / f_pHDS->oSRN.dwBlockSize;

    ++nBlockNum;    /* any block other than SRN starts from 1 */

    /* mask the block# according the BlockNumType */
    switch(f_pHDS->oSRN.eBlockNumType)
    {
        case eDRM_DSTBLKNUM_WORD:
            nBlockNum &= 0x0000FFFF;
            break;
        default:
            break;
    }

    *f_pnBlockNum = nBlockNum;

ErrorExit:
    return dr;
}

/*
** Compute the file pos of a given block
*/
static DRM_NO_INLINE DRM_RESULT _HdsBlockNum2FilePos(
    IN  _HdsContext *f_pHDS,
    IN  DRM_DWORD    f_nBlkNum,
    OUT DRM_DWORD   *f_pnFilePos)
{
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_DWORD  dwFilePos = 0;

    ChkArg(ISVALIDCONTEXT(f_pHDS, eHdsContextSignature));

    DRMASSERT(f_pHDS->fInited == TRUE
           && f_pnFilePos     != NULL);

    dwFilePos = HDS_FILEHEADERSIZE;
    dwFilePos += (f_nBlkNum-1) * f_pHDS->oSRN.dwBlockSize;
    *f_pnFilePos = dwFilePos;

ErrorExit:
    return dr;
}


/**********************************************************************
** Function:    _HdsLockSRN
** Synopsis:    Accquire lock to the Super Root Node
** Arguments:   [pHDS] --
**              [eMode] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsLockSRN(
    _HdsContext *pHDS,
    DRM_DWORD    eMode)
{
#if DRM_SUPPORT_MULTI_THREADING

    DRM_RESULT dr=DRM_SUCCESS;

#ifdef _TRACELOCK
    TRACE(("LockSRN issued: %c%c\n",
           (eMode & eDRM_DST_LOCKEXCLUSIVE)? 'X' : 'S',
           (eMode & eDRM_DST_LOCKWAIT)? 'W' : ' '));
#endif
    /*
    **  All calls to lock the SRN should wait regardless of the wait mode passed
    **  into the various API.  It makes sense that the caller wants control over
    **  whether to wait for a slot lock since those locks are long lasting (and
    **  under control of the calling application).  But the user doesn't want
    **  control over a frequently grabbed, internal, short-term lock like the
    **  SRN.  Doing so will result is random failures that the caller won't be
    **  able to understand.
    */
    if ( !Oem_File_Lock( pHDS->fp,
                        ((eMode & eDRM_DST_LOCKEXCLUSIVE) != 0),
                        0,
                        HDS_FILEHEADERSIZE,
                        TRUE ) )
    {
        ChkDR(DRM_E_DSTLOCKFAILED);
    }
#ifdef _TRACELOCK
    TRACE(("LockSRN obtained\n"));
#endif
ErrorExit:
    return dr;

#else
    return DRM_SUCCESS;
#endif
}


/**********************************************************************
** Function:    _HdsUnlockSRN
** Synopsis:    Release lock to a specific store block
** Arguments:   [pHDS] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsUnlockSRN(
    _HdsContext *pHDS)
{
#if DRM_SUPPORT_MULTI_THREADING

    DRM_RESULT dr=DRM_SUCCESS;

    if ( pHDS->fp == OEM_INVALID_HANDLE_VALUE )
    {
        ChkDR(DRM_E_DSTLOCKFAILED);
    }

#ifdef _TRACELOCK
    TRACE(("\tUnlockSRN issued \n"));
#endif
    if (!Oem_File_Unlock(pHDS->fp, 0, HDS_FILEHEADERSIZE))
    {
        ChkDR(DRM_E_DSTLOCKFAILED);
    }

ErrorExit:
    return dr;

#else
    return DRM_SUCCESS;
#endif
}

/**********************************************************************
** Function:    _HdsLockStore
** Synopsis:    Accquire lock for the store
** Arguments:   [pHDS] --
**              [fExclusive] --
** Returns:     DRM_SUCCESS on success
** Notes:       It is essentially the same as _HdsLockSlot where we are
**              grabbing a lock on a bigger slot (all the blocks)
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsLockStore(
    _HdsContext *pHDS,
    DRM_DWORD    eMode)
{
#if DRM_SUPPORT_MULTI_THREADING

    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  dwSRN = HDS_FILEHEADERSIZE;

#ifdef _TRACELOCK
    TRACE(("LockStore issued: %c\n", (eMode & eDRM_DST_LOCKEXCLUSIVE) != 0 ? 'X' : 'S'));
#endif

    /* lock the whole file from SRN */
    if (!Oem_File_Lock(
            pHDS->fp,
            ((eMode & eDRM_DST_LOCKEXCLUSIVE) != 0),
            dwSRN,
            0xFFFFFFFF-dwSRN,
            ((eMode & eDRM_DST_LOCKWAIT) != 0) ) )
    {
        ChkDR(DRM_E_DSTLOCKFAILED);
    }
#ifdef _TRACELOCK
    TRACE(("LockStore obtained\n"));
#endif

ErrorExit:
    return dr;
#else
    return DRM_SUCCESS;
#endif
}


/**********************************************************************
** Function:    _HdsUnlockStore
** Synopsis:    Release lock for the store
** Arguments:   [pHDS] --
**
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_RESULT _HdsUnlockStore(
    _HdsContext *pHDS )
{
#if DRM_SUPPORT_MULTI_THREADING
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  dwSRN = HDS_FILEHEADERSIZE;

    /* unlock the whole file from SRN */
#ifdef _TRACELOCK
    TRACE(("\tUnlockStore issued\n"));
#endif
    if (!Oem_File_Unlock(pHDS->fp, dwSRN, 0xFFFFFFFF-dwSRN))
    {
        ChkDR(DRM_E_DSTLOCKFAILED);
    }

ErrorExit:
    return dr;
#else
    return DRM_SUCCESS;
#endif
}

/**********************************************************************
** Function:    _HdsLockSlot
** Synopsis:    Accquire lock to a specific slot
** Arguments:   [pSlotCtx] --
**              [eMode] --
** Returns:     DRM_SUCCESS on success
** Notes:       The slot header will only be locked for SHARED. THis is
**              necessary for making Search to work.
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsLockSlot(
    _SlotContext *pSlotCtx,
    DRM_DWORD     eMode)
{
#if DRM_SUPPORT_MULTI_THREADING

    DRM_RESULT dr           = DRM_SUCCESS;
    DRM_DWORD  dwFilePos    = 0;
    DRM_LONG   dwLockSize   = 0;

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pSlotCtx->pNS->pHDS,
        pSlotCtx->pCurrChildBlock->nBlockNum, &dwFilePos));

    /* adjust filepos relative to the block */
    dwFilePos += pSlotCtx->pNS->nChildBlockPayloadPos;
    dwFilePos += pSlotCtx->dwSlotPosInBlock;
    dwFilePos += SIZEOF(_SlotHeader);

    if ( ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        dwLockSize = SIZEOF(DRM_DWORD);
    }
    else
    {
        dwLockSize = pSlotCtx->oSlotHeader.dwSlotSize;
    }

#ifdef _TRACELOCK
    TRACE(("LockSlot issued:  %c%c - pos %d,  size %d\n",
           (eMode & eDRM_DST_LOCKEXCLUSIVE)? 'X' : 'S',
           (eMode & eDRM_DST_LOCKWAIT)? 'W' : ' ',
           dwFilePos,
           dwLockSize));
#endif

    /* lock slot content */
    if ( !Oem_File_Lock( pSlotCtx->pNS->pHDS->fp,
                        ((eMode & eDRM_DST_LOCKEXCLUSIVE) != 0),
                        dwFilePos,
                        dwLockSize,
                        ( (eMode & eDRM_DST_LOCKWAIT) != 0 ) ) )
    {
        ChkDR(DRM_E_DSTLOCKFAILED);
    }
    pSlotCtx->eLockMode = (DRM_DST_LOCKMODE)(eMode & eDRM_DST_LOCKMODE_MASK);

#ifdef _TRACELOCK
    TRACE(("LockSlot obtained\n"));
#endif

ErrorExit:
    return dr;

#else

    pSlotCtx->eLockMode = (DRM_DST_LOCKMODE)(eMode & eDRM_DST_LOCKMODE_MASK);
    return DRM_SUCCESS;

#endif
}


/**********************************************************************
** Function:    _HdsUnlockSlot
** Synopsis:    release lock to a specific slot
** Arguments:   [pSlotCtx] --
**              [fExclusive] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsUnlockSlot(
    _SlotContext *pSlotCtx)
{
#if DRM_SUPPORT_MULTI_THREADING

    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  dwFilePos=0;
    DRM_LONG   dwLockSize=0;

    DRMASSERT(pSlotCtx!=NULL);

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pSlotCtx->pNS->pHDS,
        pSlotCtx->pCurrChildBlock->nBlockNum, &dwFilePos));

    /* adjust filepos relative to the block */
    dwFilePos += pSlotCtx->pNS->nChildBlockPayloadPos;
    dwFilePos += pSlotCtx->dwSlotPosInBlock;
    dwFilePos += SIZEOF(_SlotHeader);

    if ( ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        dwLockSize = SIZEOF(DRM_DWORD);
    }
    else
    {
        dwLockSize = pSlotCtx->oSlotHeader.dwSlotSize;
    }

#ifdef _TRACELOCK
    TRACE(("\tUnlockSlot issued:  pos %d,  size %d\n", dwFilePos, dwLockSize));
#endif

    if ( !Oem_File_Unlock( pSlotCtx->pNS->pHDS->fp,
                          dwFilePos,
                          dwLockSize ) )
    {
        ChkDR(DRM_E_DSTLOCKFAILED);
    }

ErrorExit:

    return dr;

#else
    return DRM_SUCCESS;
#endif
}


/**********************************************************************
** Function:    _HdsLockBlock2DeleteSlot
** Synopsis:    lock block payload from the given slot to end of block.
**              It is essentially the same as _HdsLockSlot where we are
**              grabbing a lock on a bigger slot.
** Arguments:   [pSlotCtx] --
**              [fExclusive] --
** Returns:     DRM_SUCCESS on success
** Notes:       To remove a slot from a block, it is necessary to lock
**              the slot to end of block (to do adjustments).
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsLockBlock2DeleteSlot(
    _SlotContext *pSlotCtx,
    DRM_DWORD     eMode)
{
#if DRM_SUPPORT_MULTI_THREADING

    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  dwFilePos=0;
    DRM_LONG   dwLockSize=0;

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pSlotCtx->pNS->pHDS,
        pSlotCtx->pCurrChildBlock->nBlockNum, &dwFilePos));

    /* adjust filepos relative to the block */
    dwLockSize = dwFilePos + pSlotCtx->pNS->pHDS->oSRN.dwBlockSize;
    dwFilePos += (pSlotCtx->pNS->nChildBlockPayloadPos + pSlotCtx->dwSlotPosInBlock);
    dwLockSize -= dwFilePos;

#ifdef _TRACELOCK
    TRACE(("LockSlot2RestOfBlock issued:  %c%c - pos %d,  size %d\n",
          (eMode & eDRM_DST_LOCKEXCLUSIVE)? 'X' : 'S',
          (eMode & eDRM_DST_LOCKWAIT)? 'W' : ' ',
          dwFilePos,
          dwLockSize));
#endif

    /* lock it */
    if ( !Oem_File_Lock(
            pSlotCtx->pNS->pHDS->fp,
            ((eMode & eDRM_DST_LOCKEXCLUSIVE) != 0),
            dwFilePos,
            dwLockSize,
            ((eMode & eDRM_DST_LOCKWAIT) != 0) ) )
    {
        ChkDR(DRM_E_DSTLOCKFAILED);
    }
#ifdef _TRACELOCK
    TRACE(("LockSlot2RestOfBlock obtained\n"));
#endif

ErrorExit:
    return dr;

#else

    return DRM_SUCCESS;

#endif
}


static DRM_NO_INLINE DRM_RESULT _HdsUnlockBlock2DeleteSlot(
    _SlotContext *pSlotCtx)
{
#if DRM_SUPPORT_MULTI_THREADING

    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  dwFilePos=0;
    DRM_LONG   dwLockSize=0;
    DRM_BOOL   fResult = FALSE;

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pSlotCtx->pNS->pHDS,
        pSlotCtx->pCurrChildBlock->nBlockNum, &dwFilePos));

    /* adjust filepos relative to the block */
    dwLockSize = dwFilePos + pSlotCtx->pNS->pHDS->oSRN.dwBlockSize;
    dwFilePos += (pSlotCtx->pNS->nChildBlockPayloadPos+pSlotCtx->dwSlotPosInBlock);
    dwLockSize -= dwFilePos;

#ifdef _TRACELOCK
    TRACE(("_HdsUnlockBlock2DeleteSlot issued:  - pos %d,  size %d\n", dwFilePos,
        dwLockSize));
#endif

    /* unlock it, do not return even if this fail */
    fResult = Oem_File_Unlock(pSlotCtx->pNS->pHDS->fp, dwFilePos, dwLockSize);

    if ( !fResult )
    {
        dr = DRM_E_DSTLOCKFAILED;
    }

ErrorExit:
    return dr;

#else

    return DRM_SUCCESS;

#endif
}


/**********************************************************************
** Function:    _Hds_malloc
** Synopsis:    HDS Component memory allocation redirector
** Arguments:   [pHDS] --
**              [cbBuffer] --
**              [ppbBuffer] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _Hds_malloc(
    _HdsContext *pHDS,
    DRM_DWORD    cbBuffer,
    DRM_VOID   **ppbBuffer)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRMASSERT(pHDS && ppbBuffer && cbBuffer);

    ChkDR(DRM_STK_Alloc(&pHDS->oHeap, cbBuffer, ppbBuffer));
    ZEROMEM( (DRM_BYTE*)*ppbBuffer, cbBuffer );

ErrorExit:
    return dr;
}


/**********************************************************************
** Function:    _Hds_free
** Synopsis:    HDS Component memory allocation redirector
** Arguments:   [pHDS] --
**              [pBuffer] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _Hds_free(
    _HdsContext *pHDS,
    DRM_VOID    *pBuffer)
{
    DRMASSERT(pHDS!=NULL);

    if (pBuffer==NULL)
    {
        return DRM_SUCCESS;
    }

    return DRM_STK_Free(&pHDS->oHeap, pBuffer);
}



/**********************************************************************
** Function:    _GetTimeStamp
** Synopsis:    Generate 8-byte timestamp
** Arguments:   [pdwStamp] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_UINT64 _GetTimeStamp( DRM_VOID *pOEMContext )
{
    DRM_UINT64  u64      = { 0 };
    DRMFILETIME filetime = { 0, 0 };

    Oem_Clock_GetSystemTimeAsFileTime( pOEMContext, &filetime );

    FILETIME_TO_UI64( filetime, u64 );

    return u64;
}

/*
** generate hash keys for namespace name
*/
static DRM_NO_INLINE DRM_VOID _GenNamespaceKeys(
    IN DRM_MD5_CTX *pcontextMD5,
    IN const DRM_CHAR* pbNamespace,
    IN DRM_WORD cbNamespace,
    OUT DRM_BYTE bNsHashKey   [__CB_DECL(DRM_HDS_HASHKEY_SIZE)],
    OUT DRM_BYTE bNsUniqueKey [__CB_DECL(DRM_HDS_UNIQUEKEY_SIZE)])
{
    DRM_MD5_Init(pcontextMD5 );
    DRM_MD5_Update(pcontextMD5, pbNamespace, cbNamespace);
    DRM_MD5_Update(pcontextMD5, DEFAULTNS_HASHKEY1, SIZEOF(DEFAULTNS_HASHKEY1) );
    DRM_MD5_Final( pcontextMD5 );

    MEMCPY(bNsHashKey, pcontextMD5->digest, DRM_HDS_HASHKEY_SIZE);

    DRM_MD5_Init(pcontextMD5 );
    DRM_MD5_Update(pcontextMD5, pbNamespace, cbNamespace);
    DRM_MD5_Update(pcontextMD5, DEFAULTNS_HASHKEY2, SIZEOF(DEFAULTNS_HASHKEY2) );
    DRM_MD5_Final( pcontextMD5 );

    MEMCPY(bNsUniqueKey, pcontextMD5->digest, DRM_HDS_HASHKEY_SIZE);
}



/**********************************************************************
** Function:    _GenSRNHash
** Synopsis:    Generate hash of the Super Root Node
** Arguments:   [pLSContext] --
**              [hash] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsGenSRNHash(
    IN  _HdsContext *f_pHDS,
    OUT DRM_BYTE     f_hash [__CB_DECL(MD5DIGESTLEN)])
{
    DRM_RESULT dr     = DRM_SUCCESS;
    DRM_DWORD  dwByte = 0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsGenSRNHash);

    ChkArg(ISVALIDCONTEXT(f_pHDS, eHdsContextSignature));

    DRMASSERT(f_pHDS->fInited == TRUE);

    DRM_MD5_Init( &f_pHDS->contextMD5 );

    BYTES_TO_DWORD( dwByte, ((DRM_BYTE*)&(f_pHDS->oSRN.dwSRNSize)) );
    DRM_MD5_Update(&f_pHDS->contextMD5, (DRM_BYTE*)&dwByte, SIZEOF(DRM_DWORD));

    BYTES_TO_DWORD( dwByte, ((DRM_BYTE*)&(f_pHDS->oSRN.dwBlockSize)) );
    DRM_MD5_Update(&f_pHDS->contextMD5, (DRM_BYTE*)&dwByte, SIZEOF(DRM_DWORD));

    BYTES_TO_DWORD( dwByte, ((DRM_BYTE*)&(f_pHDS->oSRN.eBlockNumType)) );
    DRM_MD5_Update(&f_pHDS->contextMD5, (DRM_BYTE*)&dwByte, SIZEOF(DRM_DWORD));

    BYTES_TO_DWORD( dwByte, ((DRM_BYTE*)&(f_pHDS->oSRN.nFreeListHead)) );
    DRM_MD5_Update(&f_pHDS->contextMD5, (DRM_BYTE*)&dwByte, SIZEOF(DRM_DWORD));

    BYTES_TO_DWORD( dwByte, ((DRM_BYTE*)&(f_pHDS->oSRN.nNsStoreRootBlockNum)) );
    DRM_MD5_Update(&f_pHDS->contextMD5, (DRM_BYTE*)&dwByte, SIZEOF(DRM_DWORD));

    DRM_MD5_Final( &f_pHDS->contextMD5 );
    MEMCPY( f_hash, f_pHDS->contextMD5.digest, SIZEOF( f_pHDS->contextMD5.digest ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*
**
*/
static DRM_NO_INLINE DRM_RESULT _HdsInitBlockBuffer(
    IN  _NsContext    *f_pNS,
    OUT _CommBlockHDR *f_pBlock,
    IN  DRM_DWORD      f_nParentBlockNum,
    IN  _EBlockType    f_eBlockType)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg(ISVALIDCONTEXT(f_pNS, eCfgContextSignature));

    DRMASSERT(f_pNS->fInited == TRUE
           && f_pBlock       != NULL);

    /* set up the block */
    f_pBlock->File._image.nParentBlockNum = f_nParentBlockNum;
    f_pBlock->File._image.ui64TimeStamp   = _GetTimeStamp(f_pNS->pHDS->pOEMContext);

    PUT_BYTE( &f_pBlock->File._image.bBlockType, 0, f_eBlockType );

    if (f_eBlockType==eCHILDBLOCK)
    {
        _ChildBlockHDR *pChild = (_ChildBlockHDR*)f_pBlock;

        ChkArg(f_pNS->nImagesize_ChildAllocTable <= SIZEOF( pChild->File._image.bChildAllocTable ));

        pChild->nCurrSlotPos = MAXSLOTPOS;
        pChild->nNextSlotPos = MAXSLOTPOS;
        pChild->nPayloadSize = f_pNS->nImagesize_ChildBlockPayload;
        pChild->File._image.nFreeMem = f_pNS->nImagesize_ChildBlockPayload;
        ZEROMEM(pChild->File._image.bBloomData, SIZEOF(pChild->File._image.bBloomData));
        ZEROMEM(pChild->File._image.bChildAllocTable, f_pNS->nImagesize_ChildAllocTable);
    }
    else   /* eDATABLOCK or eFREEBLOCK */
    {
        _DataBlockHDR *pData = (_DataBlockHDR*)f_pBlock;
        pData->nPayloadSize = f_pNS->pHDS->nImagesize_DataBlockPayload;
        pData->File._image.nCascadingBlockNum = 0;
    }

ErrorExit:
    return dr;
}

/*
** create a buffer big enough for a store block
*/
static DRM_NO_INLINE DRM_RESULT _HdsAllocBlockBuffer(
    IN  _NsContext     *f_pNS,
    IN  _EBlockType     f_eBlockType,
    OUT _CommBlockHDR **f_ppBlock)
{
    DRM_RESULT dr          = DRM_SUCCESS;
    DRM_DWORD  cbBlocksize = 0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsAllocBlockBuffer);
    DRM_PROFILING_DETAIL_LEVEL(6);

    ChkArg(ISVALIDCONTEXT(f_pNS, eCfgContextSignature));

    DRMASSERT( f_pNS->fInited
            && f_ppBlock != NULL
            && ( f_eBlockType==eCHILDBLOCK || f_eBlockType==eDATABLOCK ) );

    /* allocate buffer for the block */
    if ( f_eBlockType==eCHILDBLOCK )
    {
        cbBlocksize = GetMemsize_ChildBlock(f_pNS);
    }
    else /* eDATABLOCK */
    {
        cbBlocksize = GetMemsize_DataBlock();
    }

    ChkDR(_Hds_malloc(f_pNS->pHDS, cbBlocksize, (DRM_VOID**)f_ppBlock));
    ChkDR(_HdsInitBlockBuffer(f_pNS, *f_ppBlock, 0, f_eBlockType));

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


#define _MEMBER_ENCODE(pb, ib, x) \
    DRM_BYT_CopyBytes(pb, ib, (DRM_BYTE*)&x, 0, SIZEOF(x)); \
    ib += SIZEOF(x)

#define _MEMBER_DECODE(pb, ib, x) \
    DRM_BYT_CopyBytes((DRM_BYTE*)&x, 0, pb, ib, SIZEOF(x)); \
    ib += SIZEOF(x)

static DRM_NO_INLINE DRM_BOOL _WriteSRN(
    _HdsContext *pHDS)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cbWritten = 0;
    DRM_BOOL   fOK       = TRUE;
    DRM_BYTE  *pbBuffer  = NULL;
    DRM_DWORD  cbBuffer  = 0;
    DRM_DWORD  ibBuffer  = 0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__WriteSRN);

    FIX_ENDIAN_QWORD( pHDS->oSRN.ui64Timestamp );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwSRNSize );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwBlockSize );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nFreeListHead );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nNsStoreRootBlockNum );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nHighestFormattedBlockNum );
    FIX_ENDIAN_DWORD( pHDS->oSRN.eBlockNumType );

    /* this must be updated when the structure of SRN is modified */
    cbBuffer = SIZEOF(DRM_UINT64) + 6 * SIZEOF(DRM_DWORD) + MD5DIGESTLEN;
    dr = _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* encode structure to byte array */
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.bSRNHash);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.dwSRNSize);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.dwBlockSize);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.eBlockNumType);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.ui64Timestamp);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.nFreeListHead);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.nNsStoreRootBlockNum);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.nHighestFormattedBlockNum);

    /* write to file */
    if ( !Oem_File_Write( pHDS->fp, pbBuffer, cbBuffer, &cbWritten )
      || cbWritten != cbBuffer)
    {
        fOK = FALSE;
    }

ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);

    FIX_ENDIAN_QWORD( pHDS->oSRN.ui64Timestamp );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwSRNSize );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwBlockSize );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nFreeListHead );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nNsStoreRootBlockNum );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nHighestFormattedBlockNum );
    FIX_ENDIAN_DWORD( pHDS->oSRN.eBlockNumType );

    DRM_PROFILING_LEAVE_SCOPE;

    return fOK;
}


static DRM_NO_INLINE DRM_BOOL _ReadSRN(
    _HdsContext *pHDS)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cbRead = 0;
    DRM_BOOL   fOK = TRUE;
    DRM_BYTE  *pbBuffer  = NULL;
    DRM_DWORD  cbBuffer  = 0;
    DRM_DWORD  ibBuffer  = 0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__ReadSRN);

    /* this must be updated when the structure of SRN is modified */
    cbBuffer = SIZEOF(DRM_UINT64) + 6 * SIZEOF(DRM_DWORD) + MD5DIGESTLEN;
    dr = _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* read byte array from file */
    if ( !Oem_File_Read( pHDS->fp, pbBuffer, cbBuffer, &cbRead )
      || cbRead != cbBuffer)
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* decode structure members from byte array */
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.bSRNHash);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.dwSRNSize);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.dwBlockSize);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.eBlockNumType);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.ui64Timestamp);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.nFreeListHead);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.nNsStoreRootBlockNum);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.nHighestFormattedBlockNum);

ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_QWORD( pHDS->oSRN.ui64Timestamp );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwSRNSize );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwBlockSize );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nFreeListHead );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nNsStoreRootBlockNum );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nHighestFormattedBlockNum );
    FIX_ENDIAN_DWORD( pHDS->oSRN.eBlockNumType );

    DRM_PROFILING_LEAVE_SCOPE;

    return fOK;
}

static DRM_NO_INLINE DRM_BOOL _WriteCommonBlockHeader(
    _HdsContext   *pHDS,
    _CommBlockHDR *pBlock,
    DRM_DWORD      cbToWrite,
    DRM_DWORD     *pcbWritten)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cbWritten = 0;
    DRM_BOOL   fOK = TRUE;
    DRM_DWORD  ibBuffer = 0;
    DRM_DWORD  cbBuffer = 0;
    DRM_BYTE  *pbBuffer = NULL;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__WriteCommonBlockHeader);

    DRMASSERT( pBlock != NULL );

    FIX_ENDIAN_QWORD( pBlock->File._image.ui64TimeStamp );
    FIX_ENDIAN_DWORD( pBlock->File._image.nParentBlockNum );

    /* this must be updated when the structure of _CommBlockHDR is modified */
    cbBuffer = SIZEOF(DRM_UINT64) + MD5DIGESTLEN + SIZEOF(DRM_DWORD) + 1;
    dr = _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* encode structure to byte array */
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pBlock->File._image.ui64TimeStamp);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pBlock->File._image.bBlockHash );
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pBlock->File._image.nParentBlockNum );
    DRM_BYT_CopyBytes(pbBuffer, ibBuffer, &(pBlock->File._image.bBlockType), 0, 1);
    ibBuffer += 1;

    /* write byte array to file */
    if ( !Oem_File_Write( pHDS->fp, pbBuffer, cbBuffer, &cbWritten )
      || cbWritten != cbBuffer)
    {
        fOK = FALSE;
    }

ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_QWORD( pBlock->File._image.ui64TimeStamp );
    FIX_ENDIAN_DWORD( pBlock->File._image.nParentBlockNum );

    if ( pcbWritten!= NULL )
    {
        *pcbWritten = cbWritten;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return fOK;
}

static DRM_NO_INLINE DRM_BOOL _ReadCommonBlockHeader(
    _HdsContext   *pHDS,
    _CommBlockHDR *pBlock,
    DRM_DWORD      cbToRead,
    DRM_DWORD     *pcbRead )
{
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_BOOL   fOK = TRUE;
    DRM_DWORD  cbRead   = 0;
    DRM_DWORD  ibBuffer = 0;
    DRM_DWORD  cbBuffer = 0;
    DRM_BYTE  *pbBuffer = NULL;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__ReadCommonBlockHeader);

    DRMASSERT( pBlock != NULL );

    /* this must be updated when the structure of _CommBlockHDR is modified */
    cbBuffer = SIZEOF(DRM_UINT64) + MD5DIGESTLEN + SIZEOF(DRM_DWORD) + 1;
    dr = _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* read byte array from file */
    if ( !Oem_File_Read( pHDS->fp, pbBuffer, cbBuffer, &cbRead )
      || cbRead != cbBuffer)
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* decode structur member from file */
    _MEMBER_DECODE(pbBuffer, ibBuffer, pBlock->File._image.ui64TimeStamp);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pBlock->File._image.bBlockHash );
    _MEMBER_DECODE(pbBuffer, ibBuffer, pBlock->File._image.nParentBlockNum );
    DRM_BYT_CopyBytes(&(pBlock->File._image.bBlockType), 0, pbBuffer, ibBuffer, 1);

    ibBuffer += 1;

ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_QWORD( pBlock->File._image.ui64TimeStamp );
    FIX_ENDIAN_DWORD( pBlock->File._image.nParentBlockNum );

    if ( pcbRead!= NULL )
    {
        *pcbRead = cbRead;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return fOK;
}

static DRM_NO_INLINE DRM_BOOL _ReadChildBlockHeader(
    _NsContext     *pNS,
    _ChildBlockHDR *pChild )
{
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_BOOL   fOK = TRUE;
    DRM_DWORD  cbRead   = 0;
    DRM_DWORD  ibBuffer = 0;
    DRM_BYTE  *pbBuffer = NULL;
    DRM_DWORD  dwSize = 0;
    _HdsContext *pHDS = NULL;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__ReadChildBlockHeader);

    ChkArg( pNS != NULL
        && pChild != NULL );

    /* this must be updated when the structure of _ChildBlockHDR is modified */

    dwSize = pNS->nImagesize_ChildBlockHDR;
    pHDS = pNS->pHDS;

    dr = _Hds_malloc(pHDS, dwSize, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* read byte array from file */
    if ( !Oem_File_Read( pHDS->fp, pbBuffer, dwSize, &cbRead )
      || cbRead != dwSize)
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* decode nFreeMem structure member from byte array */
    _MEMBER_DECODE(pbBuffer, ibBuffer, pChild->File._image.nFreeMem);

    /* load the child allocation table */
    ChkOverflow( ibBuffer + pNS->nImagesize_ChildAllocTable, ibBuffer );
    ChkBOOL( dwSize >= ibBuffer + pNS->nImagesize_ChildAllocTable, DRM_E_DSTCORRUPTED );
    DRM_BYT_CopyBytes(&(pChild->File._image.bChildAllocTable),
                      0,
                      pbBuffer,
                      ibBuffer,
                      pNS->nImagesize_ChildAllocTable );
    ibBuffer += pNS->nImagesize_ChildAllocTable;

    /* load the Bloom filter data if present */
    ChkOverflow( ibBuffer + pNS->wBloomBytesM, ibBuffer );
    if( dwSize >= ibBuffer + pNS->wBloomBytesM )
    {
        DRM_BYT_CopyBytes(&(pChild->File._image.bBloomData),
                      0,
                      pbBuffer,
                      ibBuffer,
                      pNS->wBloomBytesM);
        ibBuffer += pNS->wBloomBytesM;
    }

ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_DWORD( pChild->File._image.nFreeMem );

    DRM_PROFILING_LEAVE_SCOPE;

    return fOK;
}

static DRM_NO_INLINE DRM_BOOL _WriteChildBlockHeader(
    _NsContext     *pNS,
    _ChildBlockHDR *pChild )
{
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_BOOL   fOK       = FALSE;
    DRM_DWORD  cbWritten = 0;
    DRM_DWORD  ibBuffer  = 0;
    DRM_BYTE  *pbBuffer  = NULL;
    DRM_DWORD  dwSize = 0;
    _HdsContext *pHDS = NULL;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__WriteChildBlockHeader);

    ChkArg( pNS != NULL
        && pChild != NULL );

    dwSize = pNS->nImagesize_ChildBlockHDR;
    pHDS = pNS->pHDS;

    FIX_ENDIAN_DWORD( pChild->File._image.nFreeMem );

    if( dwSize < SIZEOF(pChild->File._image.nFreeMem) )
    {
        goto ErrorExit;
    }

    /* this must be updated when the structure of _ChildBlockHDR is modified */
    ChkDR( _Hds_malloc(pHDS, dwSize, (DRM_VOID **) &pbBuffer) );

    /* encode structure member to byte array */
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pChild->File._image.nFreeMem);

    DRM_BYT_CopyBytes(pbBuffer,
                      ibBuffer,
                      &(pChild->File._image.bChildAllocTable),
                      0,
                      pNS->nImagesize_ChildAllocTable );
    ibBuffer += pNS->nImagesize_ChildAllocTable;

    /* only store the Bloom filter data if there's room */
    if( dwSize - ibBuffer >= pNS->wBloomBytesM )
    {
        DRM_BYT_CopyBytes(pbBuffer,
                          ibBuffer,
                          &(pChild->File._image.bBloomData),
                          0,
                          pNS->wBloomBytesM);
        ibBuffer += pNS->wBloomBytesM;
    }

    /* write byte array to file */
    if ( !Oem_File_Write( pHDS->fp, pbBuffer, dwSize, &cbWritten )
      || cbWritten != dwSize)
    {
        goto ErrorExit;
    }
    fOK = TRUE;

ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_DWORD( pChild->File._image.nFreeMem );

    DRM_PROFILING_LEAVE_SCOPE;

    return fOK;
}

static DRM_NO_INLINE DRM_BOOL _ReadDataBlockHeader(
    _HdsContext   *pHDS,
    _DataBlockHDR *pBlock )
{
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_BOOL   fOK = TRUE;
    DRM_DWORD  cbRead    = 0;
    DRM_DWORD  ibBuffer  = 0;
    DRM_DWORD  cbBuffer  = 0;
    DRM_BYTE  *pbBuffer  = NULL;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__ReadDataBlockHeader);

    DRMASSERT( pBlock != NULL );

    /* this must be updated when the structure of _DataBlockHDR is modified */
    cbBuffer = SIZEOF(pBlock->File._image.nCascadingBlockNum);
    dr = _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* read byte array from file */
    if ( !Oem_File_Read( pHDS->fp, pbBuffer, cbBuffer, &cbRead )
      || cbRead != cbBuffer)
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* decode structure member from byte array */
    _MEMBER_DECODE(pbBuffer, ibBuffer, pBlock->File._image.nCascadingBlockNum);

ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_DWORD( pBlock->File._image.nCascadingBlockNum );

    DRM_PROFILING_LEAVE_SCOPE;

    return fOK;
}

static DRM_NO_INLINE DRM_BOOL _WriteDataBlockHeader(
    _HdsContext   *pHDS,
    _DataBlockHDR *pBlock )
{
    DRM_BOOL   fOK = FALSE;
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_DWORD  cbWritten = 0;
    DRM_DWORD  ibBuffer  = 0;
    DRM_DWORD  cbBuffer  = 0;
    DRM_BYTE  *pbBuffer  = NULL;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__WriteDataBlockHeader);

    ChkArg( pHDS != NULL
       && pBlock != NULL );

    /* this must be updated when the structure of _DataBlockHDR is modified */
    cbBuffer = SIZEOF(pBlock->File._image.nCascadingBlockNum);
    ChkDR( _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer) );

    FIX_ENDIAN_DWORD( pBlock->File._image.nCascadingBlockNum );
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pBlock->File._image.nCascadingBlockNum);
    if ( !Oem_File_Write( pHDS->fp, pbBuffer, cbBuffer, &cbWritten )
      || cbWritten != cbBuffer)
    {
        goto ErrorExit;
    }

    fOK = TRUE;

ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_DWORD( pBlock->File._image.nCascadingBlockNum );

    DRM_PROFILING_LEAVE_SCOPE;

    return fOK;
}

/**********************************************************************
** Function:    GetPutBlock
** Synopsis:
** Arguments:   [pHDS] -- pointer to LicenseStore Context structure
**              [nBlkNum] --block number
**              [ppBlock] --buffer to receive the new block, if *ppBlock is NULL,
**                         a new buffer will be allocated from the context.
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/

#define GPBH_GENERIC_ONLY   TRUE
#define GPBH_ANY_HEADER     FALSE

#define GPBH_OPERATION_READ  TRUE
#define GPBH_OPERATION_WRITE  FALSE

static DRM_NO_INLINE DRM_RESULT
_HdsGetPutBlockHDR(
    IN     _NsContext     *f_pNS,
    IN     DRM_DWORD       f_nBlkNum,
    IN OUT _CommBlockHDR **f_ppBlock,
    IN     DRM_BOOL        f_fGenericHeaderOnly,
    IN     DRM_BOOL        f_fGet)
{
    DRM_RESULT   dr        = DRM_SUCCESS;
    DRM_DWORD    dwFilePos = 0;
    _HdsContext *pHDS      = NULL;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsGetPutBlockHDR);

    /* Seek to the begining of the block and read the data. */
    ChkArg(ISVALIDCONTEXT(f_pNS, eCfgContextSignature));

    DRMASSERT(f_pNS->fInited == TRUE
           && f_ppBlock      != NULL
           && f_nBlkNum       > 0);

    pHDS = f_pNS->pHDS;

#if DRM_SUPPORT_BLOCK_HEADER_CACHING
    if( f_fGet )
    {
        if( f_fGenericHeaderOnly )
        {
            /* They only want the generic header, so we don't need to lookup the block type */
            dr = Oem_Hds_CheckBlockHeaderCache( f_nBlkNum,
                            f_pNS->pHDS->fp,
                            NULL,
                            (*f_ppBlock)->File.bFileImage,
                            SIZEOF( _CommBlockFileHDR ) );
            if( DRM_SUCCEEDED( dr ) )
            {
                /* Found it, was in the cache. We're done. */
                goto ErrorExit;
            }
            else if( dr == DRM_E_DST_BLOCK_CACHE_MISS )
            {
                /* Bad luck, it's not in the cache. We'll just have to load it from disk */
                dr = DRM_SUCCESS;
            }
            ChkDR( dr );
        }
        else
        {
            DRM_DWORD dwBlockHeaderMetadata = 0;

            /* Need the block type before we can try loading the block itself */
            dr = Oem_Hds_CheckBlockHeaderCache( f_nBlkNum,
                            f_pNS->pHDS->fp,
                            &dwBlockHeaderMetadata,
                            NULL,
                            0 );

            if( dr == DRM_E_DST_BLOCK_CACHE_MISS )
            {
                /* Bad luck, it's not in the cache. We'll just have to load it from disk */
                ChkDR( DRM_SUCCESS );
            }
            else if( DRM_SUCCEEDED(dr) )
            {
                /* Sweet, we got a hit in the cache. */
                _EBlockType eBlockType;
                DRM_DWORD cbCachedBlockHeaderSize = 0;

                /* The least significant byte holds the block type */
                eBlockType = (_EBlockType)(dwBlockHeaderMetadata & 0xFF);

                if( eBlockType == eCHILDBLOCK )
                {
                    cbCachedBlockHeaderSize = GetMemsize_ChildBlock(f_pNS);
                }
                else if( eBlockType == eDATABLOCK || eBlockType == eFREEBLOCK )
                {
                    cbCachedBlockHeaderSize = GetMemsize_DataBlock();
                }
                else
                {
                    ChkDR( DRM_E_DST_BLOCK_CACHE_CORRUPT );
                }
                cbCachedBlockHeaderSize -= ( SIZEOF( _CommBlockHDR ) - SIZEOF( _CommBlockFileHDR ) );

                /* Allocate a new block buffer if not given */
                if ( *f_ppBlock == NULL )
                {
                    ChkDR(_HdsAllocBlockBuffer(f_pNS, eBlockType, f_ppBlock));
                    ChkMem( *f_ppBlock );
                }

/*
** Suppress Microsoft's PREfast static analysis tool's erroneous buffer overrun warning
** for the enclosed statement.  There is no buffer overflow.
*/
#if defined(_PREFAST_)
#pragma prefast(push)
#pragma prefast(disable:26000)
#endif
                dr = Oem_Hds_CheckBlockHeaderCache( f_nBlkNum,
                             f_pNS->pHDS->fp,
                            &dwBlockHeaderMetadata,
                             (*f_ppBlock)->File.bFileImage,
                             cbCachedBlockHeaderSize );
#if defined(_PREFAST_)
#pragma prefast(pop)
#endif

                if( eBlockType == eCHILDBLOCK )
                {
                    ((_ChildBlockHDR*)(*f_ppBlock))->nCurrSlotPos = MAXSLOTPOS;
                    ((_ChildBlockHDR*)(*f_ppBlock))->nNextSlotPos = MAXSLOTPOS;
                    ((_ChildBlockHDR*)(*f_ppBlock))->nPayloadSize = f_pNS->nImagesize_ChildBlockPayload;
                }
                else if( eBlockType == eDATABLOCK || eBlockType == eFREEBLOCK )
                {
                    ((_DataBlockHDR*)(*f_ppBlock))->nPayloadSize = pHDS->nImagesize_DataBlockPayload;
                }

                /* So although it was in the cache, it may have been removed since we checked.
                ** need to make sure we handle that eventuality properly */
                if( dr == DRM_E_DST_BLOCK_CACHE_MISS )
                {
                    /* Bad luck, it's been removed from the cache. We'll just have to load it from disk */
                    dr = DRM_SUCCESS;
                }
                else if( DRM_SUCCEEDED(dr) )
                {
                    goto ErrorExit;
                }

                ChkDR( dr );
            }
            ChkDR( dr );
        }
    }
#endif

    ChkDR(_HdsBlockNum2FilePos(pHDS, f_nBlkNum, &dwFilePos));

    /* read/write the file block header */
    if ( f_fGet )
    {
        _CommBlockHDR tmpBlock;
        DRM_DWORD     dwFileSize = 0;

        /* verify the file position:
        ** file header must be less than or equal to file size - block size
        */
        ChkBOOL(Oem_File_GetSize(pHDS->fp, &dwFileSize), DRM_E_DSTCORRUPTED);
        ChkBOOL((dwFilePos <= (dwFileSize - pHDS->oSRN.dwBlockSize)), DRM_E_DSTCORRUPTED);

        if (!Oem_File_SetFilePointer(pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
        {
            ChkDR(DRM_E_FILEREADERROR);
        }

        if( !_ReadCommonBlockHeader( pHDS, &tmpBlock, pHDS->nImagesize_FileBlockHDR, NULL ) )
        {
            ChkDR(DRM_E_FILEREADERROR);
        }

        /* allocate new buffer if not given */
        if ( *f_ppBlock == NULL )
        {
            ChkDR(_HdsAllocBlockBuffer(f_pNS, (_EBlockType)tmpBlock.File._image.bBlockType, f_ppBlock));
        }
        /* verify if the given buffer is the correct type */
        else if ( GET_BYTE( &(*f_ppBlock)->File._image.bBlockType, 0 ) != GET_BYTE( &tmpBlock.File._image.bBlockType, 0 )
               &&  ! ( (*f_ppBlock)->File._image.bBlockType == eDATABLOCK
                    && tmpBlock.File._image.bBlockType    == eFREEBLOCK
                    || (*f_ppBlock)->File._image.bBlockType == eFREEBLOCK
                    && tmpBlock.File._image.bBlockType    == eDATABLOCK ) )
        {
            ChkDR(DRM_E_DSTBLOCKMISMATCH);
        }

        /* copy block header to new buffer */
        MEMCPY((*f_ppBlock)->File.bFileImage, tmpBlock.File.bFileImage, pHDS->nImagesize_FileBlockHDR);
    }
    else
    {
        _CommBlockHDR tmpBlock;

#if DRM_SUPPORT_BLOCK_HEADER_CACHING
        if( f_fGenericHeaderOnly )
        {
            /* Update the block header cache with the new generic header. If they gave a
            ** full header, we'll update the cache further down */
            ChkDR( Oem_Hds_UpdateBlockHeaderCache( f_nBlkNum,
                         f_pNS->pHDS->fp,
                        (*f_ppBlock)->File._image.bBlockType,
                        (*f_ppBlock)->File.bFileImage,
                        SIZEOF( _CommBlockFileHDR ) ) );
            dr = DRM_SUCCESS;
        }
#endif

        if (!Oem_File_SetFilePointer(pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
        {
            ChkDR(DRM_E_FILEREADERROR);
        }

        MEMCPY(tmpBlock.File.bFileImage, (*f_ppBlock)->File.bFileImage, SIZEOF(tmpBlock.File.bFileImage));

        if(!_WriteCommonBlockHeader(pHDS, &tmpBlock, pHDS->nImagesize_FileBlockHDR, NULL ) )
        {
            ChkDR(DRM_E_FILEWRITEERROR);
        }
    }

    if ( f_fGenericHeaderOnly )
    {
        goto ErrorExit;
    }

    switch ( GET_BYTE( &(*f_ppBlock)->File._image.bBlockType, 0 ) )
    {
        case eCHILDBLOCK:
            {
                /* read/write _ChildBlockHDR */
                _ChildBlockHDR *pChild = (_ChildBlockHDR*)(*f_ppBlock);
                if ( f_fGet )
                {
                    if (!_ReadChildBlockHeader(f_pNS, pChild))
                    {
                        ChkDR(DRM_E_FILEREADERROR);
                    }
                    pChild->nCurrSlotPos = MAXSLOTPOS;
                    pChild->nNextSlotPos = MAXSLOTPOS;
                    pChild->nPayloadSize = f_pNS->nImagesize_ChildBlockPayload;
                }
                else
                {
#if DRM_SUPPORT_BLOCK_HEADER_CACHING
                    /* Update the block header cache with the new child block header */
                    ChkDR( Oem_Hds_UpdateBlockHeaderCache( f_nBlkNum,
                                 f_pNS->pHDS->fp,
                                (*f_ppBlock)->File._image.bBlockType,
                                (*f_ppBlock)->File.bFileImage,
                                GetMemsize_ChildBlock(f_pNS) - ( SIZEOF( _CommBlockHDR ) - SIZEOF( _CommBlockFileHDR ) ) ) );
                    dr = DRM_SUCCESS;
#endif

                    if (!_WriteChildBlockHeader(f_pNS, pChild) )
                    {
                        ChkDR(DRM_E_FILEWRITEERROR);
                    }
                }
            }
            break;

        case eDATABLOCK:
        case eFREEBLOCK:
            {
                /* read the HDSData */
                _DataBlockHDR *pData = (_DataBlockHDR*)(*f_ppBlock);
                if ( f_fGet )
                {
                    if (!_ReadDataBlockHeader(pHDS, pData ) )
                    {
                        ChkDR(DRM_E_FILEREADERROR);
                    }
                    pData->nPayloadSize = pHDS->nImagesize_DataBlockPayload;
                }
                else
                {
#if DRM_SUPPORT_BLOCK_HEADER_CACHING
                    /* Update the block header cache with the new data block header */
                    ChkDR( Oem_Hds_UpdateBlockHeaderCache( f_nBlkNum,
                                 f_pNS->pHDS->fp,
                                (*f_ppBlock)->File._image.bBlockType,
                                (*f_ppBlock)->File.bFileImage,
                                GetMemsize_DataBlock() - ( SIZEOF( _CommBlockHDR ) - SIZEOF( _CommBlockFileHDR ) ) ) );
                    dr = DRM_SUCCESS;
#endif
                    if (!_WriteDataBlockHeader(pHDS, pData ) )
                    {
                        ChkDR(DRM_E_FILEWRITEERROR);
                    }
                }
            }
            break;

        case eINVALIDBLOCK:
        default:
            ChkDR(DRM_E_DSTCORRUPTED);
    }

ErrorExit:

    if( DRM_SUCCEEDED( dr )
      && f_fGet )
    {
        (*f_ppBlock)->nBlockNum = f_nBlkNum;
        (*f_ppBlock)->pNS       = f_pNS;
    }

#if !_DATASTORE_WRITE_THRU
    if ( DRM_SUCCEEDED(dr) && !f_fGet )
    {
        if ( !Oem_File_FlushBuffers(pHDS->fp) )
        {
            dr = DRM_E_FILEWRITEERROR;
        }
    }
#endif

    DRM_PROFILING_USER_DATA_1(f_nBlkNum);
    DRM_PROFILING_USER_DATA_2((DRM_DWORD)f_fGet);
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/**********************************************************************
** Function:    _GenBlockHash
** Synopsis:    Generate hash of the given block
** Arguments:   [pLSContext] --
**              [pBlock] --
**              [blockHash] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT
_HdsGenBlockHash(
    IN     _HdsContext   *f_pHDS,
    IN     _NsContext    *f_pNS,
    IN     _CommBlockHDR *f_pBlock,
       OUT DRM_BYTE       f_Hash [__CB_DECL(MD5DIGESTLEN)])
{
    DRM_RESULT dr                                         = DRM_SUCCESS;
    DRM_BYTE   rgbBlockType[__CB_DECL(SIZEOF(DRM_DWORD))] = {0};

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsGenBlockHash);

    if ( GET_BYTE(&f_pBlock->File._image.bBlockType, 0 ) == eCHILDBLOCK )
    {
        ChkArg(ISVALIDCONTEXT(f_pNS, eCfgContextSignature));

        DRMASSERT(f_pNS->fInited == TRUE);
    }

    DRMASSERT(f_pBlock!=NULL);
    DRM_MD5_Init(&f_pHDS->contextMD5 );

    /* _CommBlockHDR header */
    FIX_ENDIAN_DWORD( f_pBlock->File._image.nParentBlockNum );
    FIX_ENDIAN_QWORD( f_pBlock->File._image.ui64TimeStamp );
    PUT_BYTE( rgbBlockType, 0, GET_BYTE( &f_pBlock->File._image.bBlockType, 0 ) );
    DRM_MD5_Update( &f_pHDS->contextMD5, (DRM_BYTE*)&f_pBlock->File._image.nParentBlockNum, SIZEOF(DRM_DWORD));
    DRM_MD5_Update( &f_pHDS->contextMD5, (DRM_BYTE*)&f_pBlock->File._image.ui64TimeStamp,   SIZEOF(DRM_UINT64));
    DRM_MD5_Update( &f_pHDS->contextMD5, rgbBlockType,                           SIZEOF(DRM_DWORD));
    FIX_ENDIAN_DWORD( f_pBlock->File._image.nParentBlockNum );
    FIX_ENDIAN_QWORD( f_pBlock->File._image.ui64TimeStamp );

    switch (GET_BYTE(&f_pBlock->File._image.bBlockType, 0 ))
    {
        case eCHILDBLOCK:
            {
                /* _ChildBlockHDR header */
                _ChildBlockHDR *pChild = (_ChildBlockHDR*)f_pBlock;
                FIX_ENDIAN_DWORD( pChild->File._image.nFreeMem );
                DRM_MD5_Update(&f_pHDS->contextMD5, (DRM_BYTE*)&pChild->File._image.nFreeMem, SIZEOF(DRM_DWORD));
                DRM_MD5_Update(&f_pHDS->contextMD5, pChild->File._image.bChildAllocTable, f_pNS->nImagesize_ChildAllocTable);
                FIX_ENDIAN_DWORD( pChild->File._image.nFreeMem );
            }
            break;
        case eDATABLOCK:
        case eFREEBLOCK:
            {
                /* _DataBlockHDR header */
                _DataBlockHDR *pData = (_DataBlockHDR*)f_pBlock;
                FIX_ENDIAN_DWORD( pData->File._image.nCascadingBlockNum );
                DRM_MD5_Update(&f_pHDS->contextMD5, (DRM_BYTE*)&pData->File._image.nCascadingBlockNum, SIZEOF(DRM_DWORD));
                FIX_ENDIAN_DWORD( pData->File._image.nCascadingBlockNum );
            }
            break;
        default:
            ChkDR(DRM_E_DSTCORRUPTED);
    }
    DRM_MD5_Final( &f_pHDS->contextMD5 );

    MEMCPY( f_Hash, f_pHDS->contextMD5.digest, MD5DIGESTLEN );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/**********************************************************************
** Function:    _LoadFileBlock
** Synopsis:    Load/read a specific block from file
** Arguments:   [f_pHDS]    -- pointer to LicenseStore Context structure
**              [f_nBlkNum] -- block number
**              [f_ppBlock] -- buffer to receive the new block
** Returns:     DRM_SUCCESS on success
** Notes:       Caller is responsible to call Oem_MemFree(*ppBlock);
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsLoadBlockHDR(
    IN     _NsContext     *f_pNS,
    IN     DRM_DWORD       f_nBlkNum,
       OUT _CommBlockHDR **f_ppBlock)
{
    DRM_RESULT dr                                = DRM_SUCCESS;
    DRM_BYTE   rgbHash [__CB_DECL(MD5DIGESTLEN)] = {0};
    DRM_BOOL   fAllocBuff                        = TRUE;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsLoadBlockHDR);

    ChkArg(ISVALIDCONTEXT(f_pNS, eCfgContextSignature));

    DRMASSERT(f_pNS->fInited == TRUE
           && f_ppBlock      != NULL);

    if ( *f_ppBlock != NULL)
    {
        fAllocBuff = FALSE;
    }

    ChkDR(_HdsGetPutBlockHDR(f_pNS, f_nBlkNum, f_ppBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));
    ChkDR(_HdsGenBlockHash(f_pNS->pHDS, f_pNS, *f_ppBlock, rgbHash));
    if (MEMCMP((*f_ppBlock)->File._image.bBlockHash, rgbHash, MD5DIGESTLEN ) != 0)
    {
        ChkDR(DRM_E_HASHMISMATCH);
    }

ErrorExit:
    if ( DRM_FAILED(dr) && fAllocBuff && *f_ppBlock != NULL )
    {
        _Hds_free(f_pNS->pHDS, *f_ppBlock);
        *f_ppBlock = NULL;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/**********************************************************************
** Function:    _WriteFileBlock
** Synopsis:    write the given block to file
** Arguments:   [pLSContext] -- pointer to LicenseStore Context structure
**              [pBlock] --buffer containing the file block content.
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsWriteBlockHDR(
    IN OUT _CommBlockHDR *pBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;

    ChkBOOL( pBlock != NULL, DRM_E_FILEWRITEERROR );

    pBlock->File._image.ui64TimeStamp = _GetTimeStamp(pBlock->pNS->pHDS->pOEMContext);    /* update timestamp */
    ChkDR(_HdsGenBlockHash(pBlock->pNS->pHDS, pBlock->pNS, pBlock, pBlock->File._image.bBlockHash));
    ChkDR(_HdsGetPutBlockHDR(pBlock->pNS, pBlock->nBlockNum, &pBlock, GPBH_ANY_HEADER, GPBH_OPERATION_WRITE));

ErrorExit:
    return dr;
}

/*
** Copy block
*/
static DRM_NO_INLINE DRM_RESULT _HdsCopyBlockBuffer(
    OUT _CommBlockHDR *pDestBlock,
    IN _CommBlockHDR *pSrcBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsCopyBlockBuffer);

    if (pDestBlock == pSrcBlock)
    {
       goto ErrorExit;
    }

    DRMASSERT( pDestBlock != NULL
            && pSrcBlock  != NULL
            && GET_BYTE( &pDestBlock->File._image.bBlockType, 0 ) == GET_BYTE( &pSrcBlock->File._image.bBlockType, 0 ) );

    if ( GET_BYTE( &pSrcBlock->File._image.bBlockType, 0 ) == eCHILDBLOCK )
    {
        MEMCPY((DRM_BYTE*)pDestBlock,
               (DRM_BYTE*)pSrcBlock,
               GetMemsize_ChildBlock(pSrcBlock->pNS));
    }
    else if ( GET_BYTE( &pSrcBlock->File._image.bBlockType, 0 ) == eDATABLOCK )
    {
        _DataBlockHDR *pDataSrc = (_DataBlockHDR*)pSrcBlock;
        _DataBlockHDR *pDataDest = (_DataBlockHDR*)pDestBlock;


        MEMCPY(pDestBlock, pSrcBlock, SIZEOF(_CommBlockHDR));
        pDataDest->nPayloadSize = pDataSrc->nPayloadSize;
        MEMCPY(pDataDest->File.bFileImage,
               pDataSrc->File.bFileImage,
               pSrcBlock->pNS->pHDS->nImagesize_DataBlockHDR);
    }
    else
    {
        MEMCPY(pDestBlock, pSrcBlock, SIZEOF(_CommBlockHDR));
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*
**
*/
static DRM_RESULT _HdsGetPutChildBlockNum(
    IN     _NsContext *pNS,
    IN     DRM_BYTE   *pbChildAllocTable,
    IN     DRM_DWORD   nIndex,
    IN OUT DRM_DWORD  *pnChildBlkNum,
    IN     DRM_BOOL    fGet)
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsGetPutChildBlockNum);

    DRMASSERT(pNS && pNS->fInited && pbChildAllocTable && pnChildBlkNum
        && nIndex < pNS->wMaxNumChildren);

    switch (pNS->pHDS->oSRN.eBlockNumType)
    {
        case eDRM_DSTBLKNUM_DWORD:
            if ( fGet )
            {
                *pnChildBlkNum = ((DRM_DWORD*)pbChildAllocTable)[nIndex];
                FIX_ENDIAN_DWORD( *pnChildBlkNum );
            }
            else
            {
                DRM_DWORD *rgdwTab = (DRM_DWORD*)pbChildAllocTable;
                DRM_DWORD dwIndex  = *pnChildBlkNum;
                FIX_ENDIAN_DWORD( dwIndex );
                rgdwTab[nIndex] = dwIndex;
            }
            break;
        case eDRM_DSTBLKNUM_WORD:
            if ( fGet )
            {
                DRM_WORD wNum=((DRM_WORD*)pbChildAllocTable)[nIndex];
                FIX_ENDIAN_WORD( wNum );
                *pnChildBlkNum = (DRM_DWORD)wNum;
            }
            else
            {
                DRM_WORD *rgwTab = (DRM_WORD*)pbChildAllocTable;
                DRM_WORD wNum    = (DRM_WORD)*pnChildBlkNum;

                DRMASSERT( ((*pnChildBlkNum) & 0xFFFF0000) == 0 );

                FIX_ENDIAN_WORD( wNum );
                rgwTab[nIndex] = wNum;
            }
            break;
        default:
            dr = DRM_E_DSTBLOCKMISMATCH;
            break;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/* Natural logarithm of 2 multiplied by 8 bits in a byte */
#define _HDS_BLOOM_8_TIMES_LN_OF_2 (8 * 0.693147181)

/* Log base 10 of the target probability of false positives divided by log of 0.6185
** log(0.001) / log(0.6185) = */
#define _HDS_BLOOM_LOG_OF_TARGET_PROB_DIV_BY_LOG_POINT_6185 14.37743575

static DRM_NO_INLINE DRM_VOID
_HdsCalcOptimalBloom(
    IN  DRM_WORD  wBloomN,
    OUT DRM_WORD *pwBloomBytesM,
    OUT DRM_WORD *pwBloomK )
{

    *pwBloomBytesM = min((DRM_WORD)((wBloomN * _HDS_BLOOM_LOG_OF_TARGET_PROB_DIV_BY_LOG_POINT_6185 + 8) / 8), HDS_CHILDBLOCK_BLOOM_MAX_M );
    *pwBloomK = min((DRM_WORD)(((double)*pwBloomBytesM * _HDS_BLOOM_8_TIMES_LN_OF_2) / (double)wBloomN), HDS_CHILDBLOCK_BLOOM_MAX_K );
    return;
}

/**********************************************************************
** Function:    AddHashToBloom
** Synopsis:
** Arguments:   [pbDRMData] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/

static DRM_NO_INLINE DRM_RESULT
_HdsAddHashToBloom(
    IN _NsContext *f_pNS,
    IN const DRM_BYTE f_rgbHashKey [__CB_DECL(DRM_HDS_HASHKEY_SIZE)],
    IN OUT _ChildBlockHDR *f_pChildHDR )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_WORD i = 0;
    DRM_WORD iBit = 0;
    DRM_WORD iByte = 0;
    _ChildBlockFileHDR *pHDR = (_ChildBlockFileHDR*)&f_pChildHDR->File;
    DRM_BYTE rgbHashKey[__CB_DECL(DRM_HDS_HASHKEY_SIZE)];
    DRM_BYTE iHash = 0;

    ChkArg( pHDR != NULL );
    ChkArg( f_pNS != NULL );
    ChkArg( f_pNS->wBloomBytesM <= HDS_CHILDBLOCK_BLOOM_MAX_M );
    ChkArg( f_pNS->wBloomK <= HDS_CHILDBLOCK_BLOOM_MAX_K );

    MEMCPY( rgbHashKey, f_rgbHashKey, DRM_HDS_HASHKEY_SIZE );

    for( i = 0; i < f_pNS->wBloomK; i++ )
    {
        iBit  = rgbHashKey[iHash++];
        if( f_pNS->wBloomBytesM > 32 )
        {
            /* If we've got more than 32 bytes (ie 256 bits) then we need to grab two bytes
            ** since just the one can't index this many bytes
            */
            ChkBOOL( iHash < SIZEOF( rgbHashKey ), DRM_E_ARITHMETIC_OVERFLOW ); /* Keep PREfast happy */
            iBit += rgbHashKey[iHash++] << 8;
        }
        iBit %= f_pNS->wBloomBytesM * 8;
        iByte = iBit / 8;
        iBit %= 8;
        pHDR->bBloomData[iByte] |= 1 << iBit;

        if( iHash >= DRM_HDS_HASHKEY_SIZE )
        {
            iHash = 0;
            DRM_MD5_Init( &f_pNS->pHDS->contextMD5 );
            DRM_MD5_Update( &f_pNS->pHDS->contextMD5, rgbHashKey, DRM_HDS_HASHKEY_SIZE);
            DRM_MD5_Final( &f_pNS->pHDS->contextMD5 );
            MEMCPY( rgbHashKey, f_pNS->pHDS->contextMD5.digest, MD5DIGESTLEN );
        }
    }

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    CheckHashInBloom
** Synopsis:
** Arguments:   [pbDRMData] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT
_HdsCheckHashInBloom(
    IN _NsContext *f_pNS,
    IN const DRM_BYTE f_rgbHashKey [__CB_DECL(DRM_HDS_HASHKEY_SIZE)],
    IN OUT _ChildBlockHDR *f_pChildHDR,
    OUT DRM_BOOL *f_pfResult )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD i = 0;
    DRM_WORD iBit = 0;
    DRM_WORD iByte = 0;
    _ChildBlockFileHDR *pHDR = (_ChildBlockFileHDR*)&f_pChildHDR->File;
    DRM_BYTE rgbHashKey[__CB_DECL(DRM_HDS_HASHKEY_SIZE)];
    DRM_BYTE iHash = 0;

    ChkArg( pHDR != NULL
        && f_pfResult != NULL );
    ChkArg( f_pNS != NULL );
    ChkArg( f_pNS->wBloomBytesM <= HDS_CHILDBLOCK_BLOOM_MAX_M );
    ChkArg( f_pNS->wBloomK <= HDS_CHILDBLOCK_BLOOM_MAX_K );

    *f_pfResult = TRUE;

    if( f_pNS->wBloomBytesM == 0 )
    {
        /* There is no Bloom data at all */
        goto ErrorExit;
    }

    MEMCPY( rgbHashKey, f_rgbHashKey, DRM_HDS_HASHKEY_SIZE );

    for( i = 0; i < f_pNS->wBloomK; i++ )
    {
        iBit  = rgbHashKey[iHash++];
        if( f_pNS->wBloomBytesM > 32 )
        {
            /* If we've got more than 32 bytes (ie 256 bits) then we need to grab two bytes
            ** since just the one can't index this many bytes
            */
            ChkBOOL( iHash < SIZEOF( rgbHashKey ), DRM_E_ARITHMETIC_OVERFLOW ); /* Keep PREfast happy */
            iBit += rgbHashKey[iHash++] << 8;
        }
        iBit %= f_pNS->wBloomBytesM * 8;
        iByte = iBit / 8;
        iBit %= 8;

        if( (pHDR->bBloomData[iByte] & (1 << iBit)) == 0 )
        {
            *f_pfResult = FALSE;
            break;
        }

        if( iHash >= DRM_HDS_HASHKEY_SIZE )
        {
            iHash = 0;
            DRM_MD5_Init( &f_pNS->pHDS->contextMD5 );
            DRM_MD5_Update( &f_pNS->pHDS->contextMD5, rgbHashKey, DRM_HDS_HASHKEY_SIZE);
            DRM_MD5_Final( &f_pNS->pHDS->contextMD5 );
            MEMCPY( rgbHashKey, f_pNS->pHDS->contextMD5.digest, MD5DIGESTLEN );
        }
    }

ErrorExit:
    return dr;
}


/**********************************************************************
** Function:    HashKeyToIndex
** Synopsis:
** Arguments:   [pbDRMData] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT
_HdsHashKeyToIndex(
    IN _NsContext *pNS,
    IN const DRM_BYTE HashKey [__CB_DECL(DRM_HDS_HASHKEY_SIZE)],
    IN DRM_DWORD nBlkNum,
    OUT DRM_DWORD *pnIndex)
{
#if DRM_SUPPORT_TRACING
    DRM_RESULT dr = DRM_SUCCESS;
#endif
    DRM_DWORD nFilePos;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsHashKeyToIndex);

    DRMASSERT(pNS && pNS->fInited && pnIndex);
    _HdsBlockNum2FilePos(pNS->pHDS, nBlkNum, &nFilePos);

    DRM_MD5_Init( &pNS->pHDS->contextMD5 );
    DRM_MD5_Update( &pNS->pHDS->contextMD5, HashKey, DRM_HDS_HASHKEY_SIZE);
    FIX_ENDIAN_DWORD( nFilePos );
    DRM_MD5_Update( &pNS->pHDS->contextMD5, (DRM_BYTE*)&nFilePos, SIZEOF(DRM_DWORD) );
    DRM_MD5_Final( &pNS->pHDS->contextMD5 );

    /* mod the first 4 bytes of the hash value with number of children per parent block */
    BYTES_TO_DWORD( *pnIndex, pNS->pHDS->contextMD5.digest );
    *pnIndex %= (DRM_DWORD)pNS->wMaxNumChildren;

/*  TRACE(("HashKeyToIndex %d, blocknum %d\n", *pnIndex, nBlkNum)); */

    DRM_PROFILING_LEAVE_SCOPE;

    return DRM_SUCCESS;
}


/**********************************************************************
** Function:    GoDownOneLevel
** Synopsis:    Traverse to a child block according to the given CID and SKUID.
** Arguments:   [pHDS] --
**              [pCurrBlock] -- NULL indicates no parent "child" node. the RootNode will
**                 used as the parent.
**              [rgbCID]
**              [rgbSKUID]
**              [pBlock] -- retrieved child block
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT
_HdsHashToChildBlock(
    IN  _NsContext     *pNS,
    IN  _CommBlockHDR  *pParentBlock,  /* NULL if start from NSRoot of current Namespace */
    IN  const DRM_BYTE  bHashKey [__CB_DECL(DRM_HDS_HASHKEY_SIZE)],
    OUT _CommBlockHDR **ppChildBlock,
    OUT DRM_BOOL       *pfResult,
    OUT DRM_DWORD      *pdwChildIndex)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  nBlockNum=0;
    DRM_DWORD  nIndex=0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsHashToChildBlock);

    DRMASSERT(pNS && bHashKey && pNS->fInited && ppChildBlock && pfResult);

    *pfResult=FALSE;

    if ( pParentBlock == NULL )   /* start from Root of current Namespace */
    {
        nBlockNum = pNS->nCfgRootBlockNum;
    }
    else
    {
        /* compute the child's hash index */
        ChkDR(_HdsHashKeyToIndex(pNS, bHashKey, pParentBlock->nBlockNum, &nIndex));
        ChkDR(_HdsGetPutChildBlockNum(pNS, ((_ChildBlockHDR*)pParentBlock)->File._image.bChildAllocTable,
            nIndex, &nBlockNum, TRUE));
        if ( nBlockNum == 0 )
        {
            goto ErrorExit;  /* not found */
        }
    }

    ChkDR(_HdsLoadBlockHDR(pNS, nBlockNum, ppChildBlock));
    if ( GET_BYTE( &(*ppChildBlock)->File._image.bBlockType, 0) == eCHILDBLOCK )
    {
        *pfResult = TRUE;
        if ( pdwChildIndex )
        {
            *pdwChildIndex = nIndex;
        }
    }
    else
    {
        dr = DRM_E_DSTCORRUPTED;
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*
**
*/
static DRM_NO_INLINE DRM_RESULT
_HdsExpandStore(
    IN  _HdsContext *pHDS,
    IN  DRM_DWORD    nGrowNumofBlocks,
    OUT DRM_DWORD   *pnNextBlockNum)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  dwFilePos=0, dwTmpPos=0, nBlockNum=0;
    DRM_DWORD  dwNumberOfBytesIO=0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsExpandStore);

    ChkArg(pnNextBlockNum != NULL);

    if (!Oem_File_GetSize(pHDS->fp, &dwFilePos))
    {
        ChkDR(DRM_E_FILESEEKERROR);
    }

    ChkDR(_HdsFilePos2BlockNum(pHDS, dwFilePos, &nBlockNum));

    /* verify block num */
    ChkDR(_HdsBlockNum2FilePos(pHDS, nBlockNum, &dwTmpPos));
    if ( dwTmpPos != dwFilePos )
    {
        /* max block number reached */
        TRACE( ("_HdsExpandStore(): Data store is full.\n" ));
        ChkDR(DRM_E_DSTSTOREFULL);
    }

    /* expand the file:
    ** - seek to block-size -SIZEOF(BLOCK_SIGNATURE) bytes after current EOF,
    ** - write the BLOCK_SIGNATURE at the position,
    ** - flush the file
    */
    if (!Oem_File_SetFilePointer(
                pHDS->fp,
                (nGrowNumofBlocks * pHDS->oSRN.dwBlockSize) - SIZEOF(BLOCK_SIGNATURE),
                OEM_FILE_END,
                NULL))
    {
        ChkDR(DRM_E_DSTSTOREFULL);
    }
    if (!Oem_File_Write(pHDS->fp, (DRM_VOID*)BLOCK_SIGNATURE, SIZEOF(BLOCK_SIGNATURE),
        &dwNumberOfBytesIO) || dwNumberOfBytesIO!=SIZEOF(BLOCK_SIGNATURE))
    {
        ChkDR(DRM_E_FILEWRITEERROR);
    }

    *pnNextBlockNum = nBlockNum;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#define GPBP_OPERATION_READ  TRUE
#define GPBP_OPERATION_WRITE FALSE

/*
** Get the specified size of payload at the specified pos of the block's child payload
*/
static DRM_NO_INLINE DRM_RESULT _HdsGetPutBlockPayload(
    IN _CommBlockHDR *pBlock,
    IN DRM_DWORD nPos,   /* position relative to given block's payload, starts from 0 */
    IN DRM_DWORD nSize,
    IN OUT DRM_VOID *pBuff,
    IN DRM_BOOL fGet)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD dwFilePos=0;
    DRM_DWORD ioCount=0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsGetPutBlockPayload);

    DRMASSERT( pBlock && pBuff );
    if( nSize == 0 )
    {
        /* No data read or written */
        goto ErrorExit;
    }

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pBlock->pNS->pHDS, pBlock->nBlockNum, &dwFilePos));

    /* adjust filepos relative to the block */
    switch (GET_BYTE( &pBlock->File._image.bBlockType, 0 ))
    {
        case eCHILDBLOCK:
            {
                _ChildBlockHDR *pChild=(_ChildBlockHDR*)pBlock;
                DRMASSERT( (nPos+nSize)<=pChild->nPayloadSize );
                dwFilePos += pBlock->pNS->nChildBlockPayloadPos + nPos;
            }
            break;
        case eDATABLOCK:
            {
                _DataBlockHDR *pData=(_DataBlockHDR*)pBlock;
                DRMASSERT( (nPos+nSize)<=pData->nPayloadSize );
                dwFilePos += pBlock->pNS->pHDS->nDataBlockPayloadPos + nPos;
            }
            break;
        case eFREEBLOCK:
            break;
        default:
            DRMASSERT(FALSE);
    }

    /* seek to the appropriate file position */
    if (Oem_File_SetFilePointer(pBlock->pNS->pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
    {
        DRM_BOOL fIO;

        if ( fGet )
        {
            /* Note: we do not verify file position here because we already
            **       verified the block header position is at least
            **       filesize - block size.
            */
            fIO = Oem_File_Read(pBlock->pNS->pHDS->fp, pBuff, nSize, &ioCount);
        }
        else
        {
            fIO = Oem_File_Write(pBlock->pNS->pHDS->fp, pBuff, nSize, &ioCount);
        }

        if (fIO)
        {

#if !_DATASTORE_WRITE_THRU
            if ( !fGet )
            {
                ChkBOOL( Oem_File_FlushBuffers(pBlock->pNS->pHDS->fp), DRM_E_FILEWRITEERROR );
            }
#endif
            goto ErrorExit;
        }
    }

    if ( fGet )
    {
        ChkDR(DRM_E_FILEREADERROR);
    }
    else
    {
        ChkDR(DRM_E_FILEWRITEERROR);
    }

ErrorExit:

    DRM_PROFILING_USER_DATA_1(pBlock->nBlockNum);
    DRM_PROFILING_USER_DATA_2((DRM_DWORD)fGet);
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/**********************************************************************
** Function:    _HdsUpdateSRN
** Synopsis:
** Arguments:   [pbHdsContext] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsUpdateSRN(
    IN _HdsContext *f_pHDS)
{
    DRM_RESULT dr                                 = DRM_SUCCESS;
    DRM_BYTE   bSRNHash [__CB_DECL(MD5DIGESTLEN)] = {0};
    DRM_DWORD  dwFileSize                         = 0;
    DRM_DWORD  dwNumberOfBytesIO                  = 0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsUpdateSRN);

    /* update hash of the root node */
    ChkArg(ISVALIDCONTEXT(f_pHDS, eHdsContextSignature));

    DRMASSERT( f_pHDS->fInited == TRUE
            && f_pHDS->fp      != OEM_INVALID_HANDLE_VALUE );

    /* read the SRN Hash in file and make sure it is the same as we have now
    ** if not, someone has been updated the SRN and we should not update ours to the file.
    */
    if (Oem_File_GetSize(f_pHDS->fp, &dwFileSize))
    {
        if ( dwFileSize < HDS_FILEHEADERSIZE )
        {
            /* expand the file to accomodate file header */
            if (!Oem_File_SetFilePointer(f_pHDS->fp, HDS_FILEHEADERSIZE-SIZEOF(BLOCK_SIGNATURE), OEM_FILE_BEGIN, NULL))
            {
                ChkDR(DRM_E_FILESEEKERROR);
            }
            if (!Oem_File_Write(f_pHDS->fp, (DRM_VOID*)BLOCK_SIGNATURE, SIZEOF(BLOCK_SIGNATURE), &dwNumberOfBytesIO)
                || dwNumberOfBytesIO!=SIZEOF(BLOCK_SIGNATURE))
            {
                ChkDR(DRM_E_FILEWRITEERROR);
            }

            goto CommitStore;  /* this is a new file */
        }

        if (Oem_File_SetFilePointer(f_pHDS->fp, SIZEOF(DRM_DWORD), OEM_FILE_BEGIN, NULL))
        {
            /* verify hash value of SRN */
            if (Oem_File_Read(f_pHDS->fp, bSRNHash, MD5DIGESTLEN, &dwNumberOfBytesIO) &&
                dwNumberOfBytesIO == MD5DIGESTLEN)
            {
                if (MEMCMP(bSRNHash, f_pHDS->oSRN.bSRNHash, MD5DIGESTLEN) == 0 )
                {
                    goto CommitStore;
                }
                else
                {
                    TRACE(("DRM_HDS_UpdateSRN(): Super root node's hash value mismatched\n"));
                    ChkDR(DRM_E_HDSSRNCORRUPTED);
                }
            }
        }
    }
    ChkDR(DRM_E_FILESEEKERROR);

CommitStore:

    /* update the SRN in the file */
    f_pHDS->oSRN.ui64Timestamp = _GetTimeStamp(f_pHDS->pOEMContext);
    ChkDR(_HdsGenSRNHash(f_pHDS, f_pHDS->oSRN.bSRNHash));

    /* Seek to the begining of the file and write out updated SRN data. */
    if (Oem_File_SetFilePointer(f_pHDS->fp, 0, OEM_FILE_BEGIN, NULL))
    {
        DRM_DWORD dwStoreVersion = f_pHDS->dwStoreVersion;
        FIX_ENDIAN_DWORD( dwStoreVersion );
        if (Oem_File_Write(f_pHDS->fp, (DRM_VOID*)&dwStoreVersion, SIZEOF(DRM_DWORD),
            &dwNumberOfBytesIO) && dwNumberOfBytesIO == SIZEOF(DRM_DWORD))
        {
            if (_WriteSRN(f_pHDS))
            {
#if !_DATASTORE_WRITE_THRU
                ChkBOOL( Oem_File_FlushBuffers(f_pHDS->fp), DRM_E_FILEWRITEERROR );
#endif
                goto ErrorExit;
            }
        }
    }
    ChkDR(DRM_E_FILEWRITEERROR);

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/*
**
*/
static DRM_NO_INLINE DRM_RESULT _HdsLoadSRN(
    IN _HdsContext *pHDS)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  dwStoreVersion = 0;
    DRM_DWORD  nFileSize=0;
    DRM_BYTE   rgbHash [__CB_DECL(MD5DIGESTLEN)];
    DRM_DWORD  dwNumberOfBytesIO;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsLoadSRN);

    DRMASSERT(pHDS!=NULL);

    /* read store version # */
    if (!Oem_File_SetFilePointer(pHDS->fp, 0, OEM_FILE_BEGIN, NULL) ||
        !Oem_File_Read(pHDS->fp, &dwStoreVersion, SIZEOF(DRM_DWORD), &dwNumberOfBytesIO) ||
        dwNumberOfBytesIO!=SIZEOF(DRM_DWORD))
    {
        ChkDR(DRM_E_FILEREADERROR);
    }
    FIX_ENDIAN_DWORD( dwStoreVersion );

    /* verify the version # and set file header size appropriately */
    pHDS->dwStoreVersion = dwStoreVersion;
    switch (dwStoreVersion)
    {
        case DRM_HDS_FILE_VERSION_0:
            break;

        case DRM_HDS_FILE_VERSION_1:
            break;

        case DRM_HDS_FILE_VERSION_2:
            break;

        default:
            TRACE( ("HDS file version incorrect. Can't handle this file.\n" ));
            ChkDR(DRM_E_HDSINVALIDSTORE);
    }

    /* Read the SRN */
    ZEROMEM(&pHDS->oSRN, SIZEOF(_SRN));
    if (!Oem_File_SetFilePointer(pHDS->fp, SIZEOF(DRM_DWORD), OEM_FILE_BEGIN, NULL) || /* skip size of version DWORD */
        !_ReadSRN(pHDS) ) /* read the SRN data from file */
    {
        ChkDR(DRM_E_FILEREADERROR);
    }

    /* check SRN and block size */
    if( pHDS->oSRN.dwSRNSize   != SIZEOF(_SRN)
     || pHDS->oSRN.dwBlockSize == 0 )
    {
        /* Incorrect Super root node size */
        ChkDR(DRM_E_HDSINVALIDSTORE);
    }

    if (!Oem_File_GetSize(pHDS->fp, &nFileSize))
    {
        ChkDR(DRM_E_FILESEEKERROR);
    }

    if ( nFileSize < HDS_FILEHEADERSIZE
        || ((nFileSize - HDS_FILEHEADERSIZE) % pHDS->oSRN.dwBlockSize) != 0 )
    {
        ChkDR(DRM_E_DSTCORRUPTED);
    }

    if ( pHDS->oSRN.eBlockNumType != eDRM_DSTBLKNUM_DWORD
      && pHDS->oSRN.eBlockNumType != eDRM_DSTBLKNUM_WORD )
    {
        ChkDR(DRM_E_DSTCORRUPTED);
    }

    /* verify the hash value */
    ChkDR(_HdsGenSRNHash(pHDS, rgbHash));
    if (MEMCMP(rgbHash, pHDS->oSRN.bSRNHash, SIZEOF( pHDS->oSRN.bSRNHash ) ) != 0)
    {
        ChkDR(DRM_E_HASHMISMATCH);      /* SRN Hash failed! */
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/**********************************************************************
** Function:    _HdsAllocBlock
** Synopsis:    Allocate a File Block.
** Arguments:   [f_pNS] --
**              [f_nParentBlockNum] -- parent block num of of the new block
**              [f_ppBlock]         -- buffer to receive the new block
**              [f_eBlockType]      -- type of the block
** Returns:     DRM_SUCCESS on success
** Notes:       A recycle free block list is kept in the root node. _AllocFileBlock will first
**              check if any free block is available.
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT
_HdsAllocBlock(
    IN     _NsContext     *f_pNS,
    IN     DRM_DWORD       f_nParentBlockNum,
       OUT _CommBlockHDR **f_ppBlock,
    IN     _EBlockType     f_eBlockType)
{
    DRM_RESULT    dr                                = DRM_SUCCESS;
    DRM_BOOL      fAllocBuff                        = FALSE;
    _HdsContext  *pHDS                              = NULL;
    DRM_BYTE     *pCopyBuffer                       = NULL;
    DRM_DWORD     dwFilePos                         = 0;
    DRM_BYTE      rgbHash [__CB_DECL(MD5DIGESTLEN)] = {0};
    _CommBlockHDR tmpBlock                          = {0};

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsAllocBlock);

    ChkArg(ISVALIDCONTEXT(f_pNS, eCfgContextSignature));

    DRMASSERT(f_pNS->fInited == TRUE
           && f_ppBlock      != NULL
           && (f_eBlockType==eCHILDBLOCK || f_eBlockType==eDATABLOCK));

    pHDS = f_pNS->pHDS;
    if ( *f_ppBlock == NULL )
    {
        fAllocBuff = TRUE;
        ChkDR(_HdsAllocBlockBuffer(f_pNS, f_eBlockType, f_ppBlock));
    }

    /* flush SRN in context */
    ChkDR(_HdsLoadSRN(pHDS));

    /* check if there is any recycle blocks kept in RootNode */
    if ( pHDS->oSRN.nFreeListHead == 0 )
    {
        ChkDR(_HdsPreAlloc(pHDS, pHDS->nGrowbySizeinKB, FALSE, NULL));
    }


    /* Free list in SRN must have some free block(s) now
    */

    /* Seek to the begining of the free block and read the generic header. */
    ChkDR(_HdsBlockNum2FilePos(pHDS, pHDS->oSRN.nFreeListHead, &dwFilePos));

    if (!Oem_File_SetFilePointer(pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
    {
        ChkDR(DRM_E_FILEREADERROR);
    }
    if( !_ReadCommonBlockHeader( pHDS, &tmpBlock, pHDS->nImagesize_FileBlockHDR, NULL ) )
    {
        ChkDR(DRM_E_FILEREADERROR);
    }

    if ( GET_BYTE( &(tmpBlock.File._image.bBlockType), 0 ) != eFREEBLOCK )  /* verify if the given buffer is the correct type */
    {
        ChkDR(DRM_E_DSTBLOCKMISMATCH);
    }

    /* copy block header to new buffer */
    MEMCPY((*f_ppBlock)->File.bFileImage, tmpBlock.File.bFileImage, pHDS->nImagesize_FileBlockHDR);

    /* read the rest of the free block */
    if (!_ReadDataBlockHeader(pHDS, ((_DataBlockHDR*)(*f_ppBlock)) ) )
    {
        ChkDR(DRM_E_FILEREADERROR);
    }

    /* everything is alright */
    ((_DataBlockHDR*)(*f_ppBlock))->nPayloadSize = pHDS->nImagesize_DataBlockPayload;
    (*f_ppBlock)->nBlockNum = pHDS->oSRN.nFreeListHead;
    (*f_ppBlock)->pNS = f_pNS;

    /* validate the block's hash value */
    ChkDR(_HdsGenBlockHash(f_pNS->pHDS, f_pNS, *f_ppBlock, rgbHash));
    if (MEMCMP((*f_ppBlock)->File._image.bBlockHash, rgbHash, SIZEOF( rgbHash ) ) != 0)
    {
        ChkDR(DRM_E_HASHMISMATCH);
    }

    /* update free list and commit changes of root node to file */
    pHDS->oSRN.nFreeListHead = ((_DataBlockHDR*)(*f_ppBlock))->File._image.nCascadingBlockNum;
    ChkDR(_HdsUpdateSRN(pHDS));

    /* set up the block */
    ChkDR(_HdsInitBlockBuffer(f_pNS, *f_ppBlock, f_nParentBlockNum, f_eBlockType));

    /* wipe the whole block with NULL char */
    {
        DRM_DWORD nIndex = 0;
        DRM_DWORD dwAmount = 0;

        if ( f_eBlockType == eCHILDBLOCK )
        {
            dwAmount = (*f_ppBlock)->pNS->nImagesize_ChildBlockPayload - SIZEOF(BLOCK_SIGNATURE);
        }
        else  /* eBlockType == eDATABLOCK */
        {
            dwAmount = (*f_ppBlock)->pNS->pHDS->nImagesize_DataBlockPayload - SIZEOF(BLOCK_SIGNATURE);
        }

        ChkDR(_Hds_malloc((*f_ppBlock)->pNS->pHDS, DRM_HDS_COPY_BUFFER_SIZE, (DRM_VOID**)&pCopyBuffer));
        ChkMem( pCopyBuffer );
        ZEROMEM( pCopyBuffer, DRM_HDS_COPY_BUFFER_SIZE );

        for (nIndex=0; nIndex<dwAmount;)
        {
            ChkDR(_HdsGetPutBlockPayload((*f_ppBlock), nIndex, min(DRM_HDS_COPY_BUFFER_SIZE, dwAmount-nIndex),
                pCopyBuffer, GPBP_OPERATION_WRITE));
            nIndex += min(DRM_HDS_COPY_BUFFER_SIZE, dwAmount-nIndex);
        }

        _Hds_free((*f_ppBlock)->pNS->pHDS, pCopyBuffer);
        pCopyBuffer = NULL;

        /* write the block signature at end of block */
        ChkDR(_HdsGetPutBlockPayload((*f_ppBlock), dwAmount, SIZEOF(BLOCK_SIGNATURE),
            (DRM_VOID*)BLOCK_SIGNATURE, GPBP_OPERATION_WRITE));
    }

    /* update the new block */
    ChkDR(_HdsWriteBlockHDR(*f_ppBlock));

    /* make sure the new block is written to disk before the parent block */
    ChkBOOL( Oem_File_FlushBuffers(pHDS->fp), DRM_E_FILEWRITEERROR );

ErrorExit:
    if ( pCopyBuffer != NULL )
    {
        _Hds_free((*f_ppBlock)->pNS->pHDS, pCopyBuffer);
    }

    if ( DRM_FAILED(dr) && fAllocBuff && *f_ppBlock!=NULL )
    {
        _Hds_free(pHDS, *f_ppBlock);
        *f_ppBlock = NULL;
    }

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/**********************************************************************
** Function:    _HdsFreeBlock
** Synopsis:    Free an allocated File Block.
** Arguments:   [pHDS] --
**              [pBlock] --block to be free'd
** Returns:     DRM_SUCCESS on success
** Notes:       A recycle free block list is kept in the root node. All free'd blocks
**              are put in a linked list.
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsFreeBlock(
    IN OUT _CommBlockHDR *pBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _DataBlockHDR *pDataBlock=NULL;
    DRM_BYTE *pCopyBuffer=NULL;
    DRM_DWORD nIndex=0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsFreeBlock);

    DRMASSERT(pBlock && pBlock->pNS && pBlock->pNS->fInited);

    /* flush SRN in context */
    ChkDR(_HdsLoadSRN(pBlock->pNS->pHDS));

    /* wipe the block buffer */
    ZEROMEM(pBlock->File.bFileImage, pBlock->pNS->pHDS->nImagesize_FileBlockHDR);
    _HdsInitBlockBuffer(pBlock->pNS, pBlock, 0, eDATABLOCK);

    /* optional: wipe the whole block with NULL char */
    {
        DRM_DWORD dwAmount = pBlock->pNS->pHDS->nImagesize_DataBlockPayload - SIZEOF(BLOCK_SIGNATURE);

        ChkDR(_Hds_malloc(pBlock->pNS->pHDS, DRM_HDS_COPY_BUFFER_SIZE, (DRM_VOID**)&pCopyBuffer));
        ChkMem( pCopyBuffer );
        ZEROMEM((DRM_BYTE *) pCopyBuffer, DRM_HDS_COPY_BUFFER_SIZE);

        for (nIndex=0; nIndex<dwAmount;)
        {
            ChkDR(_HdsGetPutBlockPayload(pBlock, nIndex, min(DRM_HDS_COPY_BUFFER_SIZE, dwAmount-nIndex),
                pCopyBuffer, GPBP_OPERATION_WRITE));
            nIndex += min(DRM_HDS_COPY_BUFFER_SIZE, dwAmount-nIndex);
        }

        _Hds_free(pBlock->pNS->pHDS, pCopyBuffer);
        pCopyBuffer = NULL;

        /* write the block signature at end of block */
        ChkDR(_HdsGetPutBlockPayload(pBlock, dwAmount, SIZEOF(BLOCK_SIGNATURE),
            (DRM_VOID*)BLOCK_SIGNATURE, GPBP_OPERATION_WRITE));
    }

    PUT_BYTE( &pBlock->File._image.bBlockType, 0, eFREEBLOCK );

    /* chain to SRN's freelist */
    pDataBlock = (_DataBlockHDR*)pBlock;
    pDataBlock->File._image.nCascadingBlockNum = pBlock->pNS->pHDS->oSRN.nFreeListHead;
    pBlock->pNS->pHDS->oSRN.nFreeListHead = pBlock->nBlockNum;

    /* update block to file */
    ChkDR(_HdsWriteBlockHDR(pBlock));

    /* commit changes of root node to file */
    ChkDR(_HdsUpdateSRN(pBlock->pNS->pHDS));


ErrorExit:
    if ( pCopyBuffer )
    {
        _Hds_free(pBlock->pNS->pHDS, pCopyBuffer);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/**********************************************************************
** Function:    _HdsLocateFreeBlockForSlot
** Synopsis:    Locate a block with timestamp >= given timestamp and have
**              enough space to store the license.
** Arguments:   [pHDS] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT
_HdsLocateFreeBlockForSlot(
    IN  _NsContext    *pNS,
    IN  const DRM_BYTE bHashKey [__CB_DECL(DRM_HDS_HASHKEY_SIZE)],
    IN  DRM_DWORD      cbSlot,
    OUT _SlotContext  *pSlotCtx,
    IN  DRM_UINT64     ui64TimeStamp)
{
    DRM_RESULT     dr=DRM_SUCCESS;
    DRM_BOOL       fResult=FALSE;
    _CommBlockHDR *pParentBlock=NULL;

#ifdef _DEBUG
    DRM_DWORD nNumLevels=0;
#endif

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsLocateFreeBlockForSlot);

    DRMASSERT(pNS && bHashKey && pNS->fInited && pSlotCtx &&
        pSlotCtx->eStatus!=eSlotCtxUninit && cbSlot);

    /* pSlotCtx might have something we can start with */
    if ( pSlotCtx->eStatus==eSlotCtxReady &&   /* pSlotCtx has info we can use */
        MEMCMP(bHashKey, pSlotCtx->oSlotHeader.oHashkey.rgb, DRM_HDS_HASHKEY_SIZE)==0 )   /* make sure key1 is the same */
    {
        ChkDR(_HdsAllocBlockBuffer(pNS, eCHILDBLOCK, &pParentBlock));
        if ( pSlotCtx->nBlockWithLargestFreeSpace!=0 )
        {
            if ( pSlotCtx->dwLargestSpace >= cbSlot )
            {
                ChkDR(_HdsLoadBlockHDR(pNS, pSlotCtx->nBlockWithLargestFreeSpace,
                    &pSlotCtx->pCurrChildBlock));
                goto ErrorExit;
            }
            else
            {
                /* let's start with this block */
                ChkDR(_HdsLoadBlockHDR(pNS, pSlotCtx->nBlockWithLargestFreeSpace, &pParentBlock));
            }
        }
        else
        {
            /* start with current child block in pSlotCtx */
            ChkDR(_HdsCopyBlockBuffer(pParentBlock, pSlotCtx->pCurrChildBlock));
        }
    }

    while (TRUE)
    {
        /* find a child block according to bHashKey and parentBlockNum */
        ChkDR(_HdsHashToChildBlock(pNS, pParentBlock, bHashKey, &pSlotCtx->pCurrChildBlock,
            &fResult, NULL));
#ifdef _DEBUG
        ++nNumLevels;
#endif
        if ( !fResult )
        {
            /* no children block found, let's create one */
            DRM_DWORD nIndex=0;

            ChkDR(_HdsHashKeyToIndex(pNS, bHashKey, pParentBlock->nBlockNum, &nIndex));
            ChkDR(_HdsAllocBlock(pNS, pParentBlock->nBlockNum, &pSlotCtx->pCurrChildBlock, eCHILDBLOCK));
            pSlotCtx->eStatus = eSlotCtxReady;

            /* assign new block num to parent block and update the parent block to file */
            ChkDR(_HdsGetPutChildBlockNum(pNS, ((_ChildBlockHDR*)pParentBlock)->File._image.bChildAllocTable,
                nIndex, &(pSlotCtx->pCurrChildBlock->nBlockNum), FALSE));

            ChkDR(_HdsWriteBlockHDR(pParentBlock));                         /* write Block HDR */
            break;
        }

        /* found one, check if we can use it */
        else if ( ((_ChildBlockHDR*)(pSlotCtx->pCurrChildBlock))->File._image.nFreeMem >= cbSlot &&   /* check avail space */
                  DRM_UI64Les( ui64TimeStamp, pSlotCtx->pCurrChildBlock->File._image.ui64TimeStamp ) )    /* time stamp later than what we need */
        {
            pSlotCtx->eStatus = eSlotCtxReady;
            break;
        }

        /* keep digging along the path */
        if ( pParentBlock == NULL )
        {
            ChkDR(_HdsAllocBlockBuffer(pNS, eCHILDBLOCK, &pParentBlock));
        }

        ChkDR(_HdsCopyBlockBuffer(pParentBlock, (pSlotCtx->pCurrChildBlock)));
    }

#ifdef _DEBUG
    /*TRACE(("[Levels traversed down=%d]\n", nNumLevels)); */
#endif

ErrorExit:
    if (pParentBlock)
    {
        _Hds_free(pNS->pHDS, pParentBlock);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/**********************************************************************
** Function:    CreateOversizedSlot
** Synopsis:    store an oversized license over 1+ cascading _DATANODE's
** Arguments:   [pHDS] --
**              [pBlock] --
**              [pbLicense] --
**              [cbLicense] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT
_HdsCreateOversizedSlot(
    IN _NsContext *pNS,
    IN DRM_DWORD nParentBlockNum,
    IN DRM_DWORD cbSlot,
    OUT _CommBlockHDR *pFirstDataBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nBytesLeft=0;
    _CommBlockHDR *pDataBlock=NULL;
    _CommBlockHDR *pTmpBlock=NULL;
    DRM_BOOL fCopied=FALSE;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsCreateOversizedSlot);

    DRMASSERT(pNS && pNS->fInited && cbSlot>0 && pFirstDataBlock);

    /* allocate working buffer */
    ChkDR(_HdsAllocBlockBuffer(pNS, eDATABLOCK, &pDataBlock));
    ChkDR(_HdsAllocBlockBuffer(pNS, eDATABLOCK, &pTmpBlock));

    /* allocate the first _DataBlockHDR */
    ChkDR(_HdsAllocBlock(pNS, nParentBlockNum, &pDataBlock, eDATABLOCK));

    /* divide the slot content into packets and store the packets in _DataBlockHDR's */
    nBytesLeft = cbSlot;
    while (nBytesLeft > 0)
    {
        if ( nBytesLeft <= pNS->pHDS->nImagesize_DataBlockPayload )
        {
            /* we are done */
            ((_DataBlockHDR*)pDataBlock)->File._image.nCascadingBlockNum = 0;
            ChkDR(_HdsWriteBlockHDR(pDataBlock));
            if ( !fCopied )
            {
                ChkDR(_HdsCopyBlockBuffer(pFirstDataBlock, pDataBlock));
            }
            break;
        }
        else
        {
            /* switch buffer and allocate a new block, update the block to file and keep on */
            ChkDR(_HdsAllocBlock(pNS, pDataBlock->nBlockNum, &pTmpBlock, eDATABLOCK));
            ((_DataBlockHDR*)pDataBlock)->File._image.nCascadingBlockNum = pTmpBlock->nBlockNum;
            ChkDR(_HdsWriteBlockHDR(pDataBlock));
            if ( !fCopied )
            {
                fCopied = TRUE;
                ChkDR(_HdsCopyBlockBuffer(pFirstDataBlock, pDataBlock));
            }

            nBytesLeft -= pNS->pHDS->nImagesize_DataBlockPayload;
            _HdsCopyBlockBuffer(pDataBlock, pTmpBlock);
        }
    }

    ChkBOOL( Oem_File_FlushBuffers(pNS->pHDS->fp), DRM_E_FILEWRITEERROR );

ErrorExit:
    /* free these have to be in reverse order of alloc */
    if (pTmpBlock)
    {
        _Hds_free(pNS->pHDS, pTmpBlock);
    }
    if (pDataBlock)
    {
        _Hds_free(pNS->pHDS, pDataBlock);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/**********************************************************************
** Function:    _HdsOpenSlotFromHint
** Synopsis:
** Arguments:   [f_pNS]         --
**              [f_bHashkey]    -- hashkey to be searched
**              [f_pUniquekey]  -- uniquekey to be searched
**              [f_pSlotHint]   -- hint to be used for finding slot
**              [f_fIsDataSlot] --
**              [f_pcbSlotSize] -- slot size
**              [f_pSlotCtx]    -- slot context to be returned
** Returns:     DRM_SUCCESS on success
** Notes:       Slot content is preceded with a _SlotHeader structure in the payload
**              of _ChildBlockHDR. _SlotHeader.dwSlotSize indicates the actual size of the
**              slot.
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsOpenSlotFromHint(
    IN       _NsContext       *f_pNS,
    IN const DRM_DST_KEY      *f_pHashkey,
    IN const DRM_DST_KEY      *f_pUniquekey,
    IN       _SlotHint         *f_pSlotHint,
    IN       DRM_BOOL           f_fIsDataSlot,
    IN OUT   DRM_DWORD         *f_pcbSlotSize,
       OUT   _SlotContext      *f_pSlotCtx)
{
    DRM_RESULT          dr              = DRM_SUCCESS;
    _CommBlockHDR      *pBlock          = NULL;
    _SlotHeader         oHeader         = {0};
    _ESlotSearchMode    eSearchMode     = f_fIsDataSlot? eSearchDataSlot : eSearchNamespace;
    DRM_BOOL            fAcceptSlot     = FALSE;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsOpenSlotFromHint);

    ChkArg(ISVALIDCONTEXT(f_pNS, eCfgContextSignature)
        && f_pHashkey  != NULL
        && !DRM_UTL_IsZeros(f_pHashkey->rgb, DRM_HDS_HASHKEY_SIZE)
        && f_pSlotHint != NULL );

    if( DRM_UTL_IsZeros((DRM_BYTE*)f_pSlotHint, SIZEOF(_SlotHint)) )
    {
        /* The struct is blank, we can't open with it. It's normal for us to
        ** be called with a blank struct, and ChkArg spits out TRACEs, so avoiding
        ** ChkArg here
        */
        ChkDR( DRM_E_INVALIDARG );
    }

    DRMASSERT(f_pNS->fInited          == TRUE
           && f_pNS->pHDS             != NULL
           && f_pNS->pHDS->fp         != OEM_INVALID_HANDLE_VALUE
           && f_pSlotCtx              != NULL
           && f_pUniquekey            != NULL
           && f_pNS->nCfgRootBlockNum  > 0);

    f_pSlotCtx->nBlockWithLargestFreeSpace = 0;
    f_pSlotCtx->dwLargestSpace = 0;
    *f_pcbSlotSize = 0;

    ChkDR(_HdsLoadBlockHDR(f_pNS, f_pSlotHint->nBlockNum, &pBlock));

    ChkDR(_HdsGetPutBlockPayload(pBlock, f_pSlotHint->nSlotPosInBlock,
        SIZEOF(_SlotHeader), (DRM_BYTE*)&oHeader, GPBP_OPERATION_READ));
    FIX_ENDIAN_DWORD( oHeader.dwSlotSize );
    FIX_ENDIAN_DWORD( oHeader.dwAttributes );

    if ((oHeader.dwAttributes & eSlotIsHidden) != 0)
    {
        fAcceptSlot = (eSearchMode == eSearchHiddenOnly);
    }
    else
    {
        fAcceptSlot = (eSearchMode == eSearchSlotDontCare
                || (eSearchMode == eSearchNamespace &&  (oHeader.dwAttributes & eSlotIsNamespace))
                || (eSearchMode == eSearchDataSlot  && !(oHeader.dwAttributes & eSlotIsNamespace)));

    }

    if ( !fAcceptSlot )
    {
        ChkDR(DRM_E_DSTSLOTNOTFOUND);
    }

    /* check the keys */
    if (!((MEMCMP(oHeader.oHashkey.rgb,   f_pHashkey->rgb,   DRM_HDS_HASHKEY_SIZE)   == 0)
    &&  (f_pUniquekey == NULL || MEMCMP(oHeader.oUniquekey.rgb, f_pUniquekey->rgb, DRM_HDS_UNIQUEKEY_SIZE) == 0)))
    {
        ChkDR(DRM_E_DSTSLOTNOTFOUND);
    }


    /* prepare for return */

    /* fill in the fields in _SlotContext */
    MEMCPY(&f_pSlotCtx->oFileBlock, pBlock, SIZEOF(_CommBlockHDR));
    ChkDR(_HdsCopyBlockBuffer(f_pSlotCtx->pCurrChildBlock, pBlock));  /* copy curr block to slot context */

    MEMCPY(&f_pSlotCtx->oSlotHeader, &oHeader, SIZEOF(_SlotHeader));
    f_pSlotCtx->dwSlotPosInBlock = f_pSlotHint->nSlotPosInBlock;
    f_pSlotCtx->dwSeekPointer = 0;

    /* check if we need to load _DataBlockHDR */
    if ( !ISOVERSIZESLOT(oHeader.dwSlotSize, f_pSlotCtx->pNS) )
    {
        f_pSlotCtx->pCurrDataBlock = NULL;
    }
    else
    {
        /* get _DataBlockHDR block # */
        ChkDR(_HdsGetPutBlockPayload(pBlock, f_pSlotHint->nSlotPosInBlock+SIZEOF(_SlotHeader),
            SIZEOF(DRM_DWORD), (DRM_BYTE*)&(f_pSlotCtx->dwFirstDataBlockNum), GPBP_OPERATION_READ));
        FIX_ENDIAN_DWORD( f_pSlotCtx->dwFirstDataBlockNum );
        /* load the first _DataBlockHDR */
        ChkDR(_HdsLoadBlockHDR(f_pSlotCtx->pNS, f_pSlotCtx->dwFirstDataBlockNum, &f_pSlotCtx->pCurrDataBlock));
        f_pSlotCtx->dwNumofDataBlockVisited = 0;
    }

    *f_pcbSlotSize = oHeader.dwSlotSize;
    f_pSlotCtx->eStatus = eSlotCtxReady;

ErrorExit:

    if ( pBlock != NULL )
    {
        _Hds_free(f_pNS->pHDS, pBlock);
    }

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/**********************************************************************
** Function:    SearchSlotInBlock
** Synopsis:    search a license in the block at next searchable position.
** Arguments:   [pCurrBlock] -- block to search in
**              [bHashKey] --hashkey to be searched
**              [pbUniqueKey] --uniquekey to be searched
**              [pcbSlotSize] -- slot size
**              [pSlotCtx] -- slot context to be returned
**              [pfResult] --TRUE if a matching slot is found
** Returns:     DRM_SUCCESS on success
** Notes:       Slot content is preceded with a _SlotHeader structure in the payload
**              of _ChildBlockHDR. _SlotHeader.dwSlotSize indicates the actual size of the
**              slot.
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsSearchSlotInBlock(
    IN  _CommBlockHDR           *pCurrBlock,
    IN  const DRM_DST_KEY       *pHashkey,
    IN  const DRM_DST_KEY       *pUniquekey,
    IN  _ESlotSearchMode         eSearchMode,
    OUT _SlotContext            *pSlotCtx,  /* user given Dataslot context buffer */
    OUT DRM_BOOL                *pfResult)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nBytesToSearch=0;
    DRM_DWORD nBytesToSkip=0;
    _ChildBlockHDR *pChild=(_ChildBlockHDR*)pCurrBlock;
    _SlotHeader oHeader = {0};
    DRM_BOOL fBloomResult = FALSE;
    DRM_BYTE *pbBlockBuffer = NULL;
    DRM_DWORD ibBlockBufferBase = 0;
    DRM_DWORD cbBlockBuffer = 0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsSearchSlotInBlock);

    /* Note: It is safe not to issue any lock when search each slot header in
    ** the block. It is because the caller function should already lock the SRN
    ** either shared or exclusive before calling this function. Functions which
    ** writing to the slot header(s) must issued exclusive lock to the SRN. So
    ** if we reach this point, there are no thread(s) or process(es) writing to
    ** the slot header(s).
    */

    DRMASSERT( pCurrBlock && pSlotCtx && pfResult
        && pSlotCtx->eStatus>=eSlotCtxInited && pSlotCtx->pCurrChildBlock
        && GET_BYTE( &pSlotCtx->pCurrChildBlock->File._image.bBlockType, 0 ) == eCHILDBLOCK);

    *pfResult = FALSE;
    ZEROMEM(&oHeader, SIZEOF(_SlotHeader));
    nBytesToSearch = pSlotCtx->pNS->nImagesize_ChildBlockPayload - pChild->File._image.nFreeMem;
    if ( nBytesToSearch == 0 )
    {
        goto ErrorExit;
    }

    if( pHashkey != NULL )
    {
        /* If they're searching for a specific hashkey, check the Bloom filter
           to see if the slot exists in this block */
        ChkDR( _HdsCheckHashInBloom( pSlotCtx->pNS, pHashkey->rgb, pChild, &fBloomResult ) );
        if( !fBloomResult )
        {
            /* Slot doesn't exist in this block */
            goto ErrorExit;
        }
        /* Filter returned that there is a probability that the slot exists in this block */
    }

    /* walk the payload of child node to find matching HashKey and UniqueKey. Each license are stored
    ** one by one in the payload ...
    */
    if ( pChild->nNextSlotPos == MAXSLOTPOS )
    {
        pChild->nNextSlotPos = 0;
    }

    if( DRM_HDS_COPY_BUFFER_SIZE >= nBytesToSearch - pChild->nNextSlotPos )
    {
        ChkDR(_Hds_malloc(pCurrBlock->pNS->pHDS, DRM_HDS_COPY_BUFFER_SIZE, (DRM_VOID**)&pbBlockBuffer));
        ChkMem( pbBlockBuffer );

        cbBlockBuffer = min( DRM_HDS_COPY_BUFFER_SIZE, nBytesToSearch - pChild->nNextSlotPos );

        dr = _HdsGetPutBlockPayload((_CommBlockHDR*)pChild, pChild->nNextSlotPos,
            cbBlockBuffer, pbBlockBuffer, GPBP_OPERATION_READ);
        if( dr == DRM_E_FILEREADERROR )
        {
            /* If there's a slot in the current block that is locked exclusively, we can't cache the whole block.
                    ** So we'll just fall back to loading each individual slot header one at a time as even if a slot is locked
                    ** the slot header won't be
                    */
            _Hds_free(pCurrBlock->pNS->pHDS, pbBlockBuffer);
            pbBlockBuffer = NULL;
            cbBlockBuffer = 0;
            dr = DRM_SUCCESS;
        }
        else
        {
            ChkDR( dr );
            ibBlockBufferBase = pChild->nNextSlotPos;
        }
    }

    for (; pChild->nNextSlotPos<nBytesToSearch; pChild->nNextSlotPos+=nBytesToSkip)
    {
        DRM_BOOL fAcceptSlot = FALSE;

        /* read the _SlotHeader structure */

        if(  cbBlockBuffer > SIZEOF( _SlotHeader )
         && (ibBlockBufferBase + cbBlockBuffer) >= (pChild->nNextSlotPos + SIZEOF( _SlotHeader )) )
        {
            DRM_BYT_CopyBytes( (DRM_BYTE*)&oHeader,
                                0, pbBlockBuffer,
                                pChild->nNextSlotPos - ibBlockBufferBase,
                                SIZEOF( _SlotHeader ) );
        }
        else
        {
            ChkDR(_HdsGetPutBlockPayload((_CommBlockHDR*)pChild, pChild->nNextSlotPos,
                SIZEOF(_SlotHeader), (DRM_BYTE*)&oHeader, GPBP_OPERATION_READ));
        }
        FIX_ENDIAN_DWORD( oHeader.dwSlotSize );
        FIX_ENDIAN_DWORD( oHeader.dwAttributes );

        if ((oHeader.dwAttributes & eSlotIsHidden) != 0)
        {
            fAcceptSlot = (eSearchMode == eSearchHiddenOnly);
        }
        else
        {
            fAcceptSlot = (eSearchMode == eSearchSlotDontCare
                       || (eSearchMode == eSearchNamespace &&  (oHeader.dwAttributes & eSlotIsNamespace))
                       || (eSearchMode == eSearchDataSlot  && !(oHeader.dwAttributes & eSlotIsNamespace)));

        }

        if (fAcceptSlot)
        {
            /* check the keys */
            if ((pHashkey   == NULL || MEMCMP(oHeader.oHashkey.rgb,   pHashkey->rgb,   DRM_HDS_HASHKEY_SIZE)   == 0)
            &&  (pUniquekey == NULL || MEMCMP(oHeader.oUniquekey.rgb, pUniquekey->rgb, DRM_HDS_UNIQUEKEY_SIZE) == 0))
            {
                if( pbBlockBuffer != NULL )
                {
                    _Hds_free(pCurrBlock->pNS->pHDS, pbBlockBuffer);
                    pbBlockBuffer = NULL;
                }
                goto PrepareSlot;  /* we get a match */
            }
        }

        /* skip this slot */
        if ( ISOVERSIZESLOT(oHeader.dwSlotSize, pSlotCtx->pNS) )
        {
            nBytesToSkip = SIZEOF(_SlotHeader) + SIZEOF(DRM_DWORD);
        }
        else
        {
            nBytesToSkip = SIZEOF(_SlotHeader) + oHeader.dwSlotSize;
        }
    }

    /* slot not found !! */
    goto ErrorExit;

PrepareSlot:
    /* prepare for return */

    /* fill in the fields in _SlotContext */
    MEMCPY(&pSlotCtx->oFileBlock, &pChild->oBlockHeader, SIZEOF(_CommBlockHDR));
    ChkDR(_HdsCopyBlockBuffer(pSlotCtx->pCurrChildBlock, pCurrBlock));  /* copy curr block to slot context */

    MEMCPY(&pSlotCtx->oSlotHeader, &oHeader, SIZEOF(_SlotHeader));
    pSlotCtx->dwSlotPosInBlock = pChild->nNextSlotPos;
    pSlotCtx->dwSeekPointer = 0;

    /* check if we need to load _DataBlockHDR */
    if ( !ISOVERSIZESLOT(oHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        pSlotCtx->pCurrDataBlock = NULL;
    }
    else
    {
        /* For oversized slots, load the first data block number */
        _CommBlockHDR *pChild = pSlotCtx->pCurrChildBlock;

        ChkDR(_HdsGetPutBlockPayload((_CommBlockHDR*)pChild,
                                     pSlotCtx->dwSlotPosInBlock + SIZEOF(_SlotHeader),
                                     SIZEOF(DRM_DWORD),
                                     (DRM_BYTE*)&(pSlotCtx->dwFirstDataBlockNum), TRUE));
        FIX_ENDIAN_DWORD( pSlotCtx->dwFirstDataBlockNum );

        /* load the first _DataBlockHDR */
        ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS,
                               pSlotCtx->dwFirstDataBlockNum,
                               &pSlotCtx->pCurrDataBlock));
        pSlotCtx->dwNumofDataBlockVisited = 0;
    }

    /* update slot pointer in child block */
    pChild->nCurrSlotPos = pChild->nNextSlotPos; /* set pointer to current Slot */

    /* move next pointer to next slot */
    if ( ISOVERSIZESLOT(oHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        pChild->nNextSlotPos += SIZEOF(_SlotHeader) + SIZEOF(DRM_DWORD);
    }
    else
    {
        pChild->nNextSlotPos += SIZEOF(_SlotHeader) + oHeader.dwSlotSize;
    }

    pSlotCtx->eStatus = eSlotCtxReady;
    *pfResult = TRUE;
ErrorExit:
    if( pbBlockBuffer != NULL )
    {
        _Hds_free(pCurrBlock->pNS->pHDS, pbBlockBuffer);
        pbBlockBuffer = NULL;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/**********************************************************************
** Function:    SearchSlotInFile
** Synopsis:
** Arguments:   [pHDS] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT
_HdsSearchSlotInFile(
    IN  _NsContext              *pNS,
    IN  const DRM_DST_KEY       *pHashkey,
    IN  const DRM_DST_KEY       *pUniquekey,
    IN  _ESlotSearchMode         eSearchMode,
    OUT DRM_DWORD                *pcbSlotSize, /* current dataslot size, can be NULL */
    OUT _SlotContext            *pSlotCtx,    /* user given Dataslot context buffer */
    OUT DRM_BOOL                *pfResult)
{
    DRM_RESULT     dr=DRM_SUCCESS;
    _CommBlockHDR *pParentBlock=NULL;
    DRM_DWORD      dwChildIndex=0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsSearchSlotInFile);

    DRMASSERT( pNS && pHashkey && pSlotCtx && pfResult );

    pSlotCtx->nBlockWithLargestFreeSpace = 0;
    pSlotCtx->dwLargestSpace = 0;
    while (TRUE)
    {
        /* locate a child block which might contain the slot */
        *pfResult = FALSE;
        ChkDR(_HdsHashToChildBlock(pNS, pParentBlock, pHashkey->rgb,
            &pSlotCtx->pCurrChildBlock, pfResult, &dwChildIndex));
        pSlotCtx->eStatus = eSlotCtxInited;
        if ( !*pfResult )
        {
            break;
        }

#ifdef _CHKHDS_
        if ( pParentBlock!=NULL )
        {
            printf("\t[Hashing]\tBlock%5d - Alloctable[%d]\n",
                pParentBlock->nBlockNum, dwChildIndex);
        }
#endif
        /* cache the result of this search path for later use */
        if ( ((_ChildBlockHDR*)pSlotCtx->pCurrChildBlock)->File._image.nFreeMem > pSlotCtx->dwLargestSpace )
        {
            pSlotCtx->nBlockWithLargestFreeSpace = pSlotCtx->pCurrChildBlock->nBlockNum;
            pSlotCtx->dwLargestSpace = ((_ChildBlockHDR*)pSlotCtx->pCurrChildBlock)->File._image.nFreeMem;
        }

        /* search the possible slot in the block */
        ChkDR(_HdsSearchSlotInBlock(pSlotCtx->pCurrChildBlock, pHashkey, pUniquekey,
            eSearchMode, pSlotCtx, pfResult));

        if ( *pfResult )
        {
            if ( pcbSlotSize )
            {
                *pcbSlotSize = pSlotCtx->oSlotHeader.dwSlotSize;
            }
#ifdef _CHKHDS_
            printf("\t[Found in]\tBlock%5d\n", pSlotCtx->pCurrChildBlock->nBlockNum);
#endif
            break;
        }

        /* keep digging along the hash path */
        if ( pParentBlock == NULL )
        {
            /* allocate buffer for the process */
            ChkDR(_HdsAllocBlockBuffer(pNS, eCHILDBLOCK, &pParentBlock));
        }
        _HdsCopyBlockBuffer(pParentBlock, pSlotCtx->pCurrChildBlock);
    }

ErrorExit:
    if ( pParentBlock )
    {
        _Hds_free(pNS->pHDS, pParentBlock);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/**********************************************************************
** Function:    _HdsAllocSlotInFile
** Synopsis:    Allocate a slot of specified size in the file.
** Arguments:   [pHDS] --
**              [pbLicense] --
**              [cbLicense] --size must be at least the size of DRM_LICENSE_V1
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsAllocSlotInFile(
    IN  _NsContext     *pNS,
    IN  const DRM_BYTE  bHashKey   [__CB_DECL(DRM_HDS_HASHKEY_SIZE)],
    IN  const DRM_BYTE  bUniqueKey [__CB_DECL(DRM_HDS_UNIQUEKEY_SIZE)],
    IN  DRM_BOOL        fIsDataSlot,
    OUT DRM_DWORD       cbSlot,   /* current dataslot size */
    OUT _SlotContext   *pSlotCtx)  /* user given Dataslot context buffer */
{
    DRM_RESULT      dr=DRM_SUCCESS;
    DRM_DWORD       dwPhysicalSize=0, dwSlotPos=0;
    _ChildBlockHDR *pChild=NULL;
    _SlotHeader     oHeader = { 0 };

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsAllocSlotInFile);

    DRMASSERT(pNS && bHashKey && bUniqueKey && pNS->fInited && cbSlot && pSlotCtx);

    /* compute the space needed in _ChildBlockHDR */
    if ( ISOVERSIZESLOT(cbSlot, pNS) )
    {
        dwPhysicalSize = SIZEOF(_SlotHeader)+SIZEOF(DRM_DWORD);
    }
    else
    {
        dwPhysicalSize = SIZEOF(_SlotHeader)+cbSlot;
    }

    /***************************************************************************
    **** Note: exclusive access to SRN guard the concurrency of this action. ***
    **** Caller of this function is expect to lock SRN for exclusive access. ***
    ****************************************************************************
    */

    /* locate a _ChildBlock for this slot */
    ChkDR(_HdsLocateFreeBlockForSlot(pNS, bHashKey, dwPhysicalSize, pSlotCtx, DRM_UI64( 0 ) ));
    pChild = (_ChildBlockHDR*)(pSlotCtx->pCurrChildBlock);

    /* init slot content */
    dwSlotPos = pNS->nImagesize_ChildBlockPayload -pChild->File._image.nFreeMem;
    oHeader.dwSlotSize = cbSlot;
    MEMCPY(oHeader.oHashkey.rgb, bHashKey, DRM_HDS_HASHKEY_SIZE);
    MEMCPY(oHeader.oUniquekey.rgb, bUniqueKey, DRM_HDS_UNIQUEKEY_SIZE);
    if( !fIsDataSlot )
    {
        oHeader.dwAttributes |= eSlotIsNamespace;
    }

    /* store _SlotHeader of the slot */
    FIX_ENDIAN_DWORD( oHeader.dwSlotSize );
    FIX_ENDIAN_DWORD( oHeader.dwAttributes );
    dr = _HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, dwSlotPos, SIZEOF(_SlotHeader),
        (DRM_BYTE *)&oHeader, GPBP_OPERATION_WRITE);
    FIX_ENDIAN_DWORD( oHeader.dwSlotSize );
    FIX_ENDIAN_DWORD( oHeader.dwAttributes );
    ChkDR( dr );

    /* allocate _DataBlock if necessary */
    if ( !ISOVERSIZESLOT(cbSlot, pNS) )
    {
        pSlotCtx->pCurrDataBlock = NULL;
    }
    else
    {
        ChkDR(_HdsCreateOversizedSlot(pNS, pSlotCtx->pCurrChildBlock->nBlockNum, cbSlot,
            pSlotCtx->pCurrDataBlock));
        pSlotCtx->dwNumofDataBlockVisited = 0;
        pSlotCtx->dwFirstDataBlockNum = pSlotCtx->pCurrDataBlock->nBlockNum;

        /* store the datablock# to this slot */
        FIX_ENDIAN_DWORD( pSlotCtx->pCurrDataBlock->nBlockNum );
        dr = _HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, dwSlotPos+SIZEOF(_SlotHeader),
            SIZEOF(DRM_DWORD), (DRM_BYTE *)&(pSlotCtx->pCurrDataBlock->nBlockNum), GPBP_OPERATION_WRITE);
        FIX_ENDIAN_DWORD( pSlotCtx->pCurrDataBlock->nBlockNum );
        ChkDR( dr );
    }

    /* init pSlotCtx */
    MEMCPY(&pSlotCtx->oFileBlock, &pChild->oBlockHeader, SIZEOF(_CommBlockHDR));
    MEMCPY(&pSlotCtx->oSlotHeader, &oHeader, SIZEOF(_SlotHeader));
    pSlotCtx->dwSlotPosInBlock = dwSlotPos;
    pSlotCtx->dwSeekPointer = 0;
    pSlotCtx->eLockMode = eDRM_DST_LOCKEXCLUSIVE;

    /* set the slot content to NULL. We are overloading the function here.  */
    /* oversize slot payload is always NULL by default */
    if ( !ISOVERSIZESLOT(cbSlot, pNS) )
    {
        _HdsRemoveSlot(pSlotCtx, eRemoveSlotSetNull);
        pSlotCtx->oSlotHeader.dwAttributes = 0;     /* _HdsRemoveSlot() sets dwAttributes to hidden, we have to revert it here. */
        pSlotCtx->dwSeekPointer = 0;                /* reset seek pointer */
    }

    ChkDR( _HdsAddHashToBloom( pNS, bHashKey, pChild ) );

    /* update freemem in block and write the block to file */
    pChild->File._image.nFreeMem -= dwPhysicalSize;
    ChkDR(_HdsWriteBlockHDR(pSlotCtx->pCurrChildBlock));

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*
 *
 * NAMESPACE CACHE FUNCTIONS
 *
 */

/* Note that we're thread safe under the
 * protection of the HDS critical section
 * for all these 3 functions.
 */

/* Deletes the specified namespace from the cache */
static DRM_NO_INLINE DRM_RESULT _HdsDeleteNSCacheEntry(
                    _HdsContext       *pHDS,
              const DRM_DST_NAMESPACE *pNamespace )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  i = 0;

    ChkArg( pHDS != NULL
        && pNamespace != NULL );

    for( i = 0; i < DRM_HDS_NAMESPACECACHE_MAX_ENTRIES; i++ )
    {
        if( (pHDS->namespaceCache[i].dwCacheFlags & DRM_HDS_NAMESPACECACHE_FLAG_VALID) == 0 )
        {
            continue;
        }

        /* The entry is valid, check if it's what we're looking for
        */
        if( MEMCMP( &pHDS->namespaceCache[i].nsEntry.bNSName, pNamespace->rgbOpaqueData, DRM_HDS_NSNAME_SIZE ) != 0 )
        {
            continue;
        }

        /* Got it, let's clear it
        */
        ZEROMEM( &pHDS->namespaceCache[i], SIZEOF( _NamespaceCacheEntry ) );
        break;
    }

ErrorExit:
    return dr;
}


/* Retrieves the specified namespace entry from the cache */
static DRM_NO_INLINE DRM_RESULT _HdsLookupNSCacheEntry(
                    _HdsContext       *pHDS,
              const DRM_DST_NAMESPACE *pNamespace,
                    _NSEntry         **pNsEntry)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  i = 0;

    ChkArg( pHDS != NULL
        && pNamespace != NULL
        && pNsEntry   != NULL );

    *pNsEntry = NULL;

    for( i = 0; i < DRM_HDS_NAMESPACECACHE_MAX_ENTRIES; i++ )
    {
        if( (pHDS->namespaceCache[i].dwCacheFlags & DRM_HDS_NAMESPACECACHE_FLAG_VALID) == 0 )
        {
            continue;
        }

        /* The entry is valid, check if it's what we're looking for
        */
        if( MEMCMP( &pHDS->namespaceCache[i].nsEntry.bNSName, pNamespace->rgbOpaqueData, DRM_HDS_NSNAME_SIZE ) != 0 )
        {
            continue;
        }

        /* Sweet, it's in the cache, let's use it.
        */
        *pNsEntry = &pHDS->namespaceCache[i].nsEntry;
        break;
    }

ErrorExit:
    return dr;
}

/* Adds the specified namespace entry to the cache */
static DRM_NO_INLINE DRM_RESULT _HdsAddNSCacheEntry(
                    _HdsContext       *pHDS,
                    _NSEntry          *pNsEntry)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  i = 0;
    DRM_DWORD  iFree = DRM_HDS_NAMESPACECACHE_MAX_ENTRIES;

    ChkArg( pHDS != NULL
        && pNsEntry   != NULL );

    for( i = 0; i < DRM_HDS_NAMESPACECACHE_MAX_ENTRIES; i++ )
    {
        if( (pHDS->namespaceCache[i].dwCacheFlags & DRM_HDS_NAMESPACECACHE_FLAG_VALID) != 0 )
        {
            /* If you are getting an assert here it means your namespace cache is
               too small to fit all the namespaces in the system. It is safe to remove
               this assert, but you will miss perf gains unless you increase the cache
               size. */
            DRMASSERT( !(i == DRM_HDS_NAMESPACECACHE_MAX_ENTRIES && iFree == DRM_HDS_NAMESPACECACHE_MAX_ENTRIES) );
            if( MEMCMP( &pHDS->namespaceCache[i].nsEntry.bNSName, pNsEntry->bNSName, DRM_HDS_NSNAME_SIZE ) != 0 )
            {
                continue;
            }
            else
            {
                /* Entry already exists */
                goto ErrorExit;
            }
        }

        if( iFree == DRM_HDS_NAMESPACECACHE_MAX_ENTRIES )
        {
            iFree = i;
        }
    }

    if( iFree < DRM_HDS_NAMESPACECACHE_MAX_ENTRIES )
    {
        MEMCPY( &pHDS->namespaceCache[iFree].nsEntry, pNsEntry, SIZEOF( _NSEntry ) );
        pHDS->namespaceCache[iFree].dwCacheFlags = DRM_HDS_NAMESPACECACHE_FLAG_VALID;
    }

ErrorExit:
    return dr;
}


/*
** Note: when pNamespace is NULL, it is the CFG of the namespace store.
*/
static DRM_NO_INLINE DRM_RESULT _HdsInitNsContext(
    IN  _HdsContext             *pHDS,
    OUT _NsContext              *pCfg,
    IN  const DRM_DST_NAMESPACE *pNamespace,
    IN  DRM_DWORD                nCfgRootBlockNum,
    IN  DRM_WORD                 wMaxNumChildren,
    IN  DRM_WORD                 wBloomBytesM,
    IN  DRM_WORD                 wBloomK )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _ChildBlockHDR *pChild = NULL; /* declared solely for SIZEOF below */

    DRMASSERT(pHDS && pHDS->fInited && pCfg && wMaxNumChildren > 0 && wMaxNumChildren <= DRM_HDS_MAXIMUM_CHILDREN );

    ChkArg( wMaxNumChildren <= DRM_HDS_MAXIMUM_CHILDREN );

    /* initialize the computed info for this namespace in the context */
    ZEROMEM(pCfg, SIZEOF(_NsContext));
    pCfg->wContextSize = SIZEOF(_NsContext);
    pCfg->eContextSignature = eCfgContextSignature;
    pCfg->pHDS = pHDS;
    if ( pNamespace != NULL )
    {
        DRMSIZEASSERT( SIZEOF( pCfg->oNamespace ), SIZEOF( *pNamespace ) );
        MEMCPY( &pCfg->oNamespace, pNamespace, SIZEOF( *pNamespace ) );
    }

    pCfg->fInited                      = TRUE;
    pCfg->nCfgRootBlockNum             = nCfgRootBlockNum;
    pCfg->wMaxNumChildren              = wMaxNumChildren;
    pCfg->nImagesize_ChildAllocTable   = wMaxNumChildren * pHDS->oSRN.eBlockNumType;
    pCfg->nImagesize_ChildBlockHDR     = SIZEOF(pChild->File._image.nFreeMem)
                                       + pCfg->nImagesize_ChildAllocTable
                                       + 1 /* bReserved */;

    if( pNamespace == NULL
     && pHDS->dwStoreVersion == DRM_HDS_FILE_VERSION_1 )
    {
        pCfg->nImagesize_ChildBlockHDR += HDS_CHILDBLOCK_PRERELEASE_BLOOM_M;
        pCfg->wBloomBytesM = HDS_CHILDBLOCK_PRERELEASE_BLOOM_M;
        pCfg->wBloomK = HDS_CHILDBLOCK_PRERELEASE_BLOOM_K;
    }
    else
    {
        /* only if we're not using an old HDS will there be Bloom data */
        pCfg->nImagesize_ChildBlockHDR += wBloomBytesM;
        pCfg->wBloomBytesM = wBloomBytesM;
        pCfg->wBloomK = wBloomK;
    }

    pCfg->nChildBlockPayloadPos        = pHDS->nImagesize_FileBlockHDR + pCfg->nImagesize_ChildBlockHDR;
    pCfg->nImagesize_ChildBlockPayload = pHDS->oSRN.dwBlockSize - pCfg->nChildBlockPayloadPos;

    /* Not enough room in each block for any data */
    ChkBOOL((pHDS->oSRN.dwBlockSize > pCfg->nChildBlockPayloadPos), DRM_E_HDSINVALIDSTORE);

ErrorExit:

    return dr;
}

/*
**
*/
static DRM_NO_INLINE DRM_RESULT
_HdsInitSlotContext(
    _NsContext *pNS,
    OUT DRM_BYTE *pbSlotContext,      /* user given Dataslot context buffer */
    IN DRM_DWORD cbSlotContext)    /* Dataslot context size */
{
    DRM_RESULT dr=DRM_SUCCESS;
    _SlotContext *pSlotCtx=NULL;

    DRMASSERT(pNS && pbSlotContext && cbSlotContext);

    ZEROMEM(pbSlotContext, cbSlotContext);

    pSlotCtx = (_SlotContext*)pbSlotContext;

    pSlotCtx->eContextSignature = eSlotContextSignature;
    pSlotCtx->pNS = pNS;
    pSlotCtx->eStatus = eSlotCtxInited;
    pSlotCtx->dwContextSize = cbSlotContext;
    pSlotCtx->pCurrChildBlock = (_CommBlockHDR *)pSlotCtx->bBuff;
    pSlotCtx->pCurrDataBlock  = (_CommBlockHDR *) (pSlotCtx->bBuff + __CB_DECL(GetMemsize_ChildBlock(pNS)));
    ChkDR(_HdsInitBlockBuffer(pNS, pSlotCtx->pCurrChildBlock, 0, eCHILDBLOCK));
    ChkDR(_HdsInitBlockBuffer(pNS, pSlotCtx->pCurrDataBlock, 0, eDATABLOCK));

ErrorExit:
    return dr;
}

/*
** Create or open dataslot using given key1 and key2
*/
static DRM_NO_INLINE DRM_RESULT _HdsOpenSlot(
    IN       _NsContext        *f_pNS,
    IN const DRM_DST_KEY       *f_pHashKey,
    IN const DRM_DST_KEY       *f_pUniqueKey,
    IN       DRM_BOOL           f_fIsDataSlot,
    IN       DRM_DWORD          f_dwMode,
    IN       DRM_BOOL           f_fRelockSRNExclusiveOnCreate,
    IN OUT   DRM_DWORD         *f_pcbSlotSize,
       OUT   _SlotContext      *f_pSlotCtx )
{
    DRM_RESULT dr      = DRM_SUCCESS;
    DRM_BOOL   fResult = FALSE;
    DRM_DWORD  cbSlot  = 0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsOpenSlot);

    DRMASSERT( (( f_dwMode & eDRM_DST_CREATE_NEW ) != 0)
            ^ (( f_dwMode & eDRM_DST_OPEN_EXISTING ) != 0)
            ^ (( f_dwMode & eDRM_DST_OPEN_ALWAYS   ) != 0 ) );

    ChkArg(ISVALIDCONTEXT(f_pNS, eCfgContextSignature)
        && f_pHashKey != NULL
        && !DRM_UTL_IsZeros(f_pHashKey->rgb, DRM_HDS_HASHKEY_SIZE));

    DRMASSERT(f_pNS->fInited          == TRUE
           && f_pNS->pHDS             != NULL
           && f_pNS->pHDS->fp         != OEM_INVALID_HANDLE_VALUE
           && f_pSlotCtx              != NULL
           && f_pUniqueKey            != NULL
           && f_pNS->nCfgRootBlockNum  > 0);

    /* Save the slot size they gave us in case _HdsSearchSlotInFile overwrites it */
    cbSlot = *f_pcbSlotSize;

    ChkDR(_HdsSearchSlotInFile(f_pNS, f_pHashKey, f_pUniqueKey,
        f_fIsDataSlot? eSearchDataSlot : eSearchNamespace, f_pcbSlotSize, f_pSlotCtx, &fResult));
    if ( !fResult )
    {
        if( f_dwMode & eDRM_DST_OPEN_EXISTING )
        {
            *f_pcbSlotSize = cbSlot;
            ChkDR(DRM_E_DSTSLOTNOTFOUND);
        }

        if ( (f_dwMode & eDRM_DST_LOCKEXCLUSIVE) == 0 )
        {
            ChkDR(DRM_E_DSTEXCLUSIVELOCKONLY);
        }

        /* If they didn't already have the SRN exclusively locked, we need to do so now
        ** as we're creating a slot
        */
        if( f_fRelockSRNExclusiveOnCreate )
        {
#if DRM_SUPPORT_MULTI_THREADING
            _HdsUnlockSRN(f_pNS->pHDS);

            /* Lock SRN EXCLUSIVE among other processes. */
            ChkDR(_HdsLockSRN(f_pNS->pHDS, f_dwMode | eDRM_DST_LOCKEXCLUSIVE))
#endif
        }

        *f_pcbSlotSize = cbSlot;
        ChkDR(_HdsAllocSlotInFile(f_pNS, f_pHashKey->rgb, f_pUniqueKey->rgb, f_fIsDataSlot, cbSlot, f_pSlotCtx));
        f_pSlotCtx->eLockMode = (DRM_DST_LOCKMODE)(f_dwMode & eDRM_DST_LOCKMODE_MASK);

        /* this will not be blocked because this is a new slot and we have SRN exclusive lock */
        ChkDR(_HdsLockSlot(f_pSlotCtx, f_dwMode & eDRM_DST_LOCKMODE_MASK));

        if( !(f_dwMode & eDRM_DST_CREATE_NEW) )
        {
            /* Return S_FALSE to indicate we created the slot */
            dr = DRM_S_FALSE;
        }
    }
    else
    {
        if( f_dwMode & eDRM_DST_CREATE_NEW )
        {
            *f_pcbSlotSize = cbSlot;
            ChkDR(DRM_E_DSTSLOTEXIST);
        }
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*
** Verify the given slot context to make sure the Child and Data block are consistent.
*/
static DRM_NO_INLINE DRM_RESULT
_HdsVerifySlotContext(
    IN OUT _SlotContext *pSlotCtx,
    OUT DRM_BOOL *pfValid)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _CommBlockHDR *pBlock=NULL;
    _CommBlockHDR *pCurrBlock = NULL;
    _SlotHeader slotHeader;
    _CommBlockHDR *pTmpBlock=NULL;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsVerifySlotContext);

    DRMASSERT(pSlotCtx && pSlotCtx->eStatus==eSlotCtxReady && pfValid);
    *pfValid = FALSE;

    /* load generic block header */
    pBlock = &pSlotCtx->oFileBlock;
    pCurrBlock = pSlotCtx->pCurrChildBlock;

    /* load generic block header */
    ChkDR(_HdsGetPutBlockHDR(pSlotCtx->pNS, pSlotCtx->oFileBlock.nBlockNum, &pBlock, GPBH_GENERIC_ONLY, GPBH_OPERATION_READ));

    /* verify the generic header */
    if ( DRM_UI64Eql( pSlotCtx->oFileBlock.File._image.ui64TimeStamp, pCurrBlock->File._image.ui64TimeStamp )
      && MEMCMP(pSlotCtx->oFileBlock.File._image.bBlockHash, pCurrBlock->File._image.bBlockHash, SIZEOF( pCurrBlock->File._image.bBlockHash ))==0 )
    {
       *pfValid = TRUE;
        goto ErrorExit;
    }

    /* the current block has been updated/written since last read */

    /* check if it is still a CHILD block or belong to the same parent */
    if ( GET_BYTE( &pSlotCtx->oFileBlock.File._image.bBlockType, 0 ) != GET_BYTE( &pCurrBlock->File._image.bBlockType, 0 )
      || pSlotCtx->oFileBlock.File._image.nParentBlockNum            != pCurrBlock->File._image.nParentBlockNum )
    {
        goto ReloadChildBlock;
    }

    /* load the child block in a tmp buffer */
    ChkDR(_HdsAllocBlockBuffer(pSlotCtx->pNS, eCHILDBLOCK, &pTmpBlock));
    ChkDR(_HdsGetPutBlockHDR(pSlotCtx->pNS, pSlotCtx->oFileBlock.nBlockNum, &pTmpBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));

    /* try to load the current slot header from file */
    dr = _HdsGetPutBlockPayload(pTmpBlock, pSlotCtx->dwSlotPosInBlock,
        SIZEOF(_SlotHeader), &slotHeader, GPBP_OPERATION_READ);
    FIX_ENDIAN_DWORD( slotHeader.dwSlotSize );
    FIX_ENDIAN_DWORD( slotHeader.dwAttributes );
    if ( DRM_SUCCEEDED(dr) )
    {
        if (MEMCMP(&slotHeader, &pSlotCtx->oSlotHeader, SIZEOF(_SlotHeader))==0 )
        {
            /* the current slot is intact, update the block buffer and continue */
            ChkDR(_HdsGetPutBlockHDR(pSlotCtx->pNS, pSlotCtx->oFileBlock.nBlockNum, &pCurrBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));
            *pfValid = TRUE;
            goto ErrorExit;
        }
    }

ReloadChildBlock:
{

#if DRM_SUPPORT_MULTI_THREADING
    /*
    ** This might happen if slot has changed since it was opened by this thread.
    */
    dr = DRM_S_FALSE;
    goto ErrorExit;
#else

    /* reload and initialize the slot context using the hashkey and uniquekey in
       current slot context */

    /*
    _NsContext *pNS = pSlotCtx->pNS;
    _SlotHeader oSlotHeader = pSlotCtx->oSlotHeader;
    DRM_DWORD dwSeekPointer = pSlotCtx->dwSeekPointer;
    _SlotContext *pSlotContext=NULL;

    ChkDR(_HdsOpenExistingSlot(pNS,&oSlotHeader.oHashkey, TRUE, &oSlotHeader.oUniquekey, NULL, pSlotCtx));

    pSlotCtx->dwSeekPointer = dwSeekPointer;
    *pfValid = TRUE;
    */
#endif
}

ErrorExit:
    if ( pTmpBlock )
    {
        _Hds_free(pSlotCtx->pNS->pHDS, pTmpBlock);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/*
**
*/
static DRM_NO_INLINE DRM_RESULT DRM_CALL
_HdsReadWriteSlot(
    IN _SlotContext *pSlotCtx,
    IN const DRM_DWORD cbData,  /* count in bytes to read/write */
    __out_bcount_part( cbData, *pcbIO ) DRM_BYTE  *pbData,      /* buffer for read/write */
    OUT DRM_DWORD *pcbIO,       /* actual amount of count in bytes read/written */
    IN DRM_BOOL fGet)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD cbIO=0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsReadWriteSlot);

    DRMASSERT(pSlotCtx && pSlotCtx->eStatus==eSlotCtxReady && pbData);

    if ( pcbIO != NULL )
    {
        *pcbIO = 0;
    }

    if ( !ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        /* calc the position relative to the _ChildBlockHDR */
        DRM_DWORD wPos = pSlotCtx->dwSlotPosInBlock + SIZEOF(_SlotHeader) + pSlotCtx->dwSeekPointer;
        if ( (pSlotCtx->dwSeekPointer + cbData) > pSlotCtx->oSlotHeader.dwSlotSize )
        {
            cbIO = pSlotCtx->oSlotHeader.dwSlotSize - pSlotCtx->dwSeekPointer;
        }
        else
        {
            cbIO = cbData;
        }

        ChkDR(_HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, wPos, cbIO, pbData, fGet));
    }
    else    /* Slot data is contained in a chain of _DataBlockHDR's */
    {
        DRM_DWORD nRelativeSeekPtr=0;
        DRM_DWORD nBytesLeft=0;
        DRM_DWORD nNextBlockNum=0;
        DRM_BYTE *pBuff=NULL;

        /* calc which _DataBlockHDR we need to load that contains the position of seekpointer */
        DRM_DWORD nthBlock = pSlotCtx->dwSeekPointer / pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload;

        /* load the appropriate data block */
        if ( nthBlock > pSlotCtx->dwNumofDataBlockVisited )
        {
            while ( nthBlock > pSlotCtx->dwNumofDataBlockVisited )
            {
                nNextBlockNum = ((_DataBlockHDR*)pSlotCtx->pCurrDataBlock)->File._image.nCascadingBlockNum;
                ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, nNextBlockNum, &pSlotCtx->pCurrDataBlock));
                ++pSlotCtx->dwNumofDataBlockVisited;
            }
        }
        else if ( nthBlock < pSlotCtx->dwNumofDataBlockVisited )
        {
            /* start from the first data block in the chain */
            nNextBlockNum = pSlotCtx->dwFirstDataBlockNum;
            ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, nNextBlockNum, &pSlotCtx->pCurrDataBlock));
            pSlotCtx->dwNumofDataBlockVisited = 0;

            while (pSlotCtx->dwNumofDataBlockVisited < nthBlock )
            {
                nNextBlockNum = ((_DataBlockHDR*)(pSlotCtx->pCurrDataBlock))->File._image.nCascadingBlockNum;
                ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, nNextBlockNum, &pSlotCtx->pCurrDataBlock));
                ++pSlotCtx->dwNumofDataBlockVisited;
            }
        }

        /* calc # of bytes to read/write */
        if ( (pSlotCtx->dwSeekPointer + cbData) > pSlotCtx->oSlotHeader.dwSlotSize )
        {
            cbIO = pSlotCtx->oSlotHeader.dwSlotSize - pSlotCtx->dwSeekPointer;
        }
        else
        {
            cbIO = cbData;
        }

        /* calc relative pos of dwSeekPointer in this _DataBlockHDR */
        nRelativeSeekPtr = pSlotCtx->dwSeekPointer - (nthBlock * pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload);
        pBuff = pbData;
        nBytesLeft=cbIO;

        /* read/write slot content to buffer */
        ChkDR(_HdsGetPutBlockPayload(pSlotCtx->pCurrDataBlock, nRelativeSeekPtr,
            min(nBytesLeft, pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload - nRelativeSeekPtr), pBuff, fGet));
        pBuff      += __CB_DECL(min(nBytesLeft, pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload - nRelativeSeekPtr));
        nBytesLeft -=           min(nBytesLeft, pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload - nRelativeSeekPtr);

        /* more data is contained along the _DataBlockHDR's chain */
        while (nBytesLeft > 0)
        {
            nNextBlockNum = ((_DataBlockHDR*)pSlotCtx->pCurrDataBlock)->File._image.nCascadingBlockNum;
            ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, nNextBlockNum, &pSlotCtx->pCurrDataBlock));
            ++pSlotCtx->dwNumofDataBlockVisited;
            ChkDR(_HdsGetPutBlockPayload(pSlotCtx->pCurrDataBlock, 0,
                min(nBytesLeft, pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload), pBuff, fGet));

            /* check if we are done */
            if ( nBytesLeft <= pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload )
            {
                break;
            }

            pBuff      += __CB_DECL(pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload);
            nBytesLeft -=           pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload;
        }
    }

    pSlotCtx->dwSeekPointer += cbIO;
    if ( pcbIO )
    {
        *pcbIO = cbIO;
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#define ADJUST_PAYLOAD_TO_END   0xFFFFFFFF

/*
** Adjust content of Child payload from SrcPos to DestPos,
** _ChildBlockHDR's nFreeMem is adjusted appropriately.
*/
static DRM_NO_INLINE DRM_RESULT _HdsAdjustChildPayload(
    _CommBlockHDR *f_pblockheader,
    DRM_DWORD      f_oFileDest,
    DRM_DWORD      f_oFileSrc,
    DRM_DWORD      f_cbMove)
{
    DRM_RESULT      dr        = DRM_SUCCESS;
    DRM_DWORD       oFileCurr = 0;
    DRM_DWORD       cbMove    = 0;
    DRM_DWORD       cb        = 0;
    DRM_BYTE       *pbBuffer  = NULL;
    _ChildBlockHDR *pblockheaderChild = (_ChildBlockHDR *) f_pblockheader;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsAdjustChildPayload);

    DRMASSERT(f_pblockheader!=NULL);

    /* nothing to do */

    if (f_oFileDest == f_oFileSrc)
    {
        goto ErrorExit;
    }

    ChkDR(_Hds_malloc(f_pblockheader->pNS->pHDS, DRM_HDS_COPY_BUFFER_SIZE, (DRM_VOID **) &pbBuffer));

    if (f_cbMove == ADJUST_PAYLOAD_TO_END)
    {
        cbMove = pblockheaderChild->nPayloadSize
               - pblockheaderChild->File._image.nFreeMem
               - f_oFileSrc;
    }
    else
    {
        cbMove = f_cbMove;
    }

    if (f_oFileSrc > f_oFileDest)   /* Shrinking the payload */
    {
        /* copy it */
        for (oFileCurr  = 0;
             oFileCurr  < cbMove;
             oFileCurr += min(cbMove - oFileCurr, DRM_HDS_COPY_BUFFER_SIZE))
        {
            cb = min(cbMove - oFileCurr, DRM_HDS_COPY_BUFFER_SIZE);

            ChkDR(_HdsGetPutBlockPayload(f_pblockheader,
                                         oFileCurr + f_oFileSrc,
                                         cb,
                                         pbBuffer,
                                         GPBP_OPERATION_READ));

            ChkDR(_HdsGetPutBlockPayload(f_pblockheader,
                                         oFileCurr + f_oFileDest,
                                         cb,
                                         pbBuffer,
                                         GPBP_OPERATION_WRITE));
        }

        /* wipe the space left behind */

        if (f_cbMove == ADJUST_PAYLOAD_TO_END)
        {
            DRM_DWORD oFileWipeEnd = pblockheaderChild->nPayloadSize
                                   - pblockheaderChild->File._image.nFreeMem;

            ZEROMEM(pbBuffer, DRM_HDS_COPY_BUFFER_SIZE);

            for (oFileCurr = f_oFileDest + cbMove;
                 oFileCurr < oFileWipeEnd;
                 oFileCurr += min(oFileWipeEnd - oFileCurr, DRM_HDS_COPY_BUFFER_SIZE))
            {
                ChkDR(_HdsGetPutBlockPayload(f_pblockheader, oFileCurr, min(oFileWipeEnd-oFileCurr, DRM_HDS_COPY_BUFFER_SIZE), pbBuffer, FALSE));
            }

            /* update nFreeMem in block .. only valid if we are moving the tail*/

            pblockheaderChild->File._image.nFreeMem += f_oFileSrc - f_oFileDest;
        }
    }
    else    /* enlarging the payload (wSrcPos < wDestPos) */
    {
        ChkArg(f_cbMove != ADJUST_PAYLOAD_TO_END);

        if (cbMove > (pblockheaderChild->nPayloadSize - f_oFileDest))
        {
            TRACE(("_ChildBlockHDR does not have enough room for the move.\n"));
            DRMASSERT(FALSE);
        }

        /* copy from the end */
        for (oFileCurr  = cbMove;
             oFileCurr  > 0;
             oFileCurr -= cb)
        {

            cb = min(oFileCurr, DRM_HDS_COPY_BUFFER_SIZE);

            ChkDR(_HdsGetPutBlockPayload(f_pblockheader,
                                         oFileCurr + f_oFileSrc - cb,
                                         cb,
                                         pbBuffer,
                                         GPBP_OPERATION_READ));

            ChkDR(_HdsGetPutBlockPayload(f_pblockheader,
                                         oFileCurr + f_oFileDest - cb,
                                         cb,
                                         pbBuffer,
                                         GPBP_OPERATION_WRITE));
        }

        /* wipe the enlarged area of the payload */
        cb = f_oFileDest - f_oFileSrc;

        ZEROMEM(pbBuffer, DRM_HDS_COPY_BUFFER_SIZE);

        for (oFileCurr = 0;
             oFileCurr < cb;
             oFileCurr += min(cb - oFileCurr, DRM_HDS_COPY_BUFFER_SIZE))
        {
            ChkDR(_HdsGetPutBlockPayload(f_pblockheader,
                                         oFileCurr + f_oFileSrc,
                                         min(cb - oFileCurr, DRM_HDS_COPY_BUFFER_SIZE),
                                         pbBuffer,
                                         GPBP_OPERATION_WRITE));
        }

        /* update nFreeMem in block */
        if (pblockheaderChild->File._image.nFreeMem > (f_oFileDest - f_oFileSrc))
        {
            pblockheaderChild->File._image.nFreeMem -= f_oFileDest - f_oFileSrc;
        }
        else
        {
            pblockheaderChild->File._image.nFreeMem = 0;
        }
    }

ErrorExit:
    if (pbBuffer != NULL)
    {
        _Hds_free(f_pblockheader->pNS->pHDS, pbBuffer);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/**********************************************************************
** Function:    FindLeftmostLeafBlock
** Synopsis:    find the leftmost block which does any children blocks
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT
_HdsFindLeftmostLeafBlock(
    IN _CommBlockHDR *pRefBlock,
    OUT DRM_DWORD *pnLeafBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nChildBlkNum=0;
    DRM_DWORD nIndex=0;
    _CommBlockHDR *pTmpBlock=NULL;
    _CommBlockHDR *pCurrBlock=NULL;
    _NsContext *pNS=NULL;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsFindLeftmostLeafBlock);

    DRMASSERT(pRefBlock && pnLeafBlock);

    pNS = pRefBlock->pNS;
    *pnLeafBlock = pRefBlock->nBlockNum;  /* init to itself first */
    ChkDR(_HdsAllocBlockBuffer(pNS, eCHILDBLOCK, &pTmpBlock));
    pCurrBlock = pRefBlock;

    /* for loop for each level of the tree */
    while (TRUE)
    {
        /* find the first occupied slot at this level */
        for (nIndex=0; nIndex < pCurrBlock->pNS->wMaxNumChildren; nIndex++)
        {
            ChkDR(_HdsGetPutChildBlockNum(pNS, ((_ChildBlockHDR*)pCurrBlock)->File._image.bChildAllocTable,
                nIndex, &nChildBlkNum, TRUE));
            if ( nChildBlkNum != 0 )  /* child node exists */
            {
                if ( pCurrBlock == pRefBlock )
                {
                    pCurrBlock = pTmpBlock;
                }

                /* load the child block */
                ChkDR(_HdsLoadBlockHDR(pNS, nChildBlkNum, &pCurrBlock));
                *pnLeafBlock = pCurrBlock->nBlockNum;
                break;
            }
        }

        /* no occupied slot found in this level, that means this block is a leaf block */
        if ( nIndex >= pCurrBlock->pNS->wMaxNumChildren )
        {
            break;
        }
    }

ErrorExit:
    if ( pTmpBlock )
    {
        _Hds_free(pNS->pHDS, pTmpBlock);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*
**
*/
static DRM_NO_INLINE DRM_RESULT _HdsCopySlot_Child2Child(
    IN _CommBlockHDR *pDestBlock,
    IN DRM_DWORD dwPosInDestBlock,
    IN _CommBlockHDR *pSourceBlock,
    IN DRM_DWORD dwPosInSrcBlock,
    IN DRM_DWORD dwSize)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _NsContext *pNS=NULL;
    DRM_DWORD nIndex;
    DRM_BYTE *pCopyBuffer=NULL;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsCopySlot_Child2Child);

    DRMASSERT(pDestBlock && pSourceBlock
        && GET_BYTE( &pDestBlock->File._image.bBlockType, 0 )   == (DRM_BYTE)eCHILDBLOCK
        && GET_BYTE( &pSourceBlock->File._image.bBlockType, 0 ) == (DRM_BYTE)eCHILDBLOCK);

    pNS = pSourceBlock->pNS;

    ChkDR(_Hds_malloc(pNS->pHDS, DRM_HDS_COPY_BUFFER_SIZE, (DRM_VOID**)&pCopyBuffer));
    for (nIndex=0; nIndex < dwSize; )
    {
        ChkDR(_HdsGetPutBlockPayload(pSourceBlock, nIndex+dwPosInSrcBlock,  min(DRM_HDS_COPY_BUFFER_SIZE, dwSize-nIndex), pCopyBuffer, GPBP_OPERATION_READ));
        ChkDR(_HdsGetPutBlockPayload(pDestBlock,   nIndex+dwPosInDestBlock, min(DRM_HDS_COPY_BUFFER_SIZE, dwSize-nIndex), pCopyBuffer, GPBP_OPERATION_WRITE));

        nIndex += min(DRM_HDS_COPY_BUFFER_SIZE, dwSize-nIndex);
    }

ErrorExit:
    if ( pCopyBuffer != NULL )
    {
        _Hds_free(pNS->pHDS, pCopyBuffer);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*
** Copy the payload of the source child block to the destination child block
*/
static DRM_NO_INLINE DRM_RESULT _HdsCopyChildPayload(
    OUT _CommBlockHDR *pDestBlock,
    IN _CommBlockHDR *pSourceBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nBytesToSkip=0;
    DRM_DWORD nNextSlotPos=0, nBytesToSearch=0;
    _SlotHeader oHeader;
    _CommBlockHDR *pDataBlock=NULL;
    _ChildBlockHDR *pChildDest = (_ChildBlockHDR*)pDestBlock;
    _ChildBlockHDR *pChildSrc = (_ChildBlockHDR*)pSourceBlock;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsCopyChildPayload);

    DRMASSERT(pDestBlock && pSourceBlock);

    /* copy payload */
    ChkDR(_HdsCopySlot_Child2Child(pDestBlock, 0, pSourceBlock, 0,
        pDestBlock->pNS->nImagesize_ChildBlockPayload));

    /* update freemem */
    pChildDest->File._image.nFreeMem = pChildSrc->File._image.nFreeMem;

    /* copy Bloom filter data */
    MEMCPY( pChildDest->File._image.bBloomData, pChildSrc->File._image.bBloomData, SIZEOF( pChildSrc->File._image.bBloomData ) );

    /* walk each slot in the pDestBlock, adopt, if any, all data blocks to pDestBlock */
    nBytesToSearch = pDestBlock->pNS->nImagesize_ChildBlockPayload - ((_ChildBlockHDR*)pDestBlock)->File._image.nFreeMem;
    if ( nBytesToSearch == 0 )
    {
        goto ErrorExit;
    }

    /* walk the payload of child node to find matching HashKey and UniqueKey. Each license are stored
    ** one by one in the payload ...
    */
    ChkDR(_HdsAllocBlockBuffer(pSourceBlock->pNS, eDATABLOCK, &pDataBlock));
    for (; nNextSlotPos<nBytesToSearch; nNextSlotPos+=nBytesToSkip)
    {
        /* read the _SlotHeader structure */
        ChkDR(_HdsGetPutBlockPayload(pDestBlock, nNextSlotPos,
            SIZEOF(_SlotHeader), (DRM_BYTE*)&oHeader, GPBP_OPERATION_READ));
        FIX_ENDIAN_DWORD( oHeader.dwSlotSize );
        FIX_ENDIAN_DWORD( oHeader.dwAttributes );

        /* skip this license if not oversized */
        if ( !ISOVERSIZESLOT(oHeader.dwSlotSize, pDestBlock->pNS) )
        {
            nBytesToSkip = SIZEOF(_SlotHeader) + oHeader.dwSlotSize;
        }
        else
        {
            /* load the data block, update its parent block # to pDestBlock's block # */
            DRM_DWORD dwDataBlockNum=0;
            ChkDR(_HdsGetPutBlockPayload(pDestBlock, nNextSlotPos+SIZEOF(_SlotHeader),
                SIZEOF(DRM_DWORD), (DRM_BYTE*)&dwDataBlockNum, GPBP_OPERATION_READ));
            FIX_ENDIAN_DWORD( dwDataBlockNum );
            ChkDR(_HdsLoadBlockHDR(pSourceBlock->pNS, dwDataBlockNum, &pDataBlock));

            /* update parent block # */
            pDataBlock->File._image.nParentBlockNum = pDestBlock->nBlockNum;
            ChkDR(_HdsWriteBlockHDR(pDataBlock));

            nBytesToSkip = SIZEOF(_SlotHeader)+SIZEOF(DRM_DWORD);
        }
    }

ErrorExit:
    if (pDataBlock)
    {
        _Hds_free(pSourceBlock->pNS->pHDS, pDataBlock);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/**********************************************************************
** Function:    _HdsDefragmentFile
** Synopsis:    Defragment the file from the given block
** Arguments:   [pRefBlock] --
** Returns:     DRM_SUCCESS on success
** Notes:       We cannot simply free a block even if it's empty. If we do so, the
**              structure of its subtree will be modified and all of the licenses stored
**              in this subtree will no longer be able to be retrieved. Instead, we
**              traverse to the leftmost leaf block of this subtree and move its
**              content to the given block. Then we can free that emptied leaf
**              block. This way, since the leaf block does not have any children,
**              its subtree can be freed.
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT
_HdsDefragmentFile(
    IN _CommBlockHDR *pRefBlock,
    OUT DRM_BOOL *pfRefBlockFreed)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nParentBlock=0;
    DRM_DWORD nLeafBlock=0;
    DRM_DWORD nIndex=0;
    _CommBlockHDR *pLeafBlock=NULL;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsDefragmentFile);

    DRMASSERT(pRefBlock && pRefBlock->pNS && pRefBlock->pNS->fInited);

    if ( ((_ChildBlockHDR*)pRefBlock)->File._image.nFreeMem < (pRefBlock->pNS->nImagesize_ChildBlockPayload) )
    {
        goto ErrorExit;     /* this block is not empty! */
    }

    /* find the leftmost leaf node in the 'hash path' */
    ChkDR(_HdsAllocBlockBuffer(pRefBlock->pNS, eCHILDBLOCK, &pLeafBlock));
    ChkDR(_HdsFindLeftmostLeafBlock(pRefBlock, &nLeafBlock));

    if ( pfRefBlockFreed )
    {
        *pfRefBlockFreed = FALSE;
    }

    /* ref block is a leaf */
    if ( nLeafBlock == pRefBlock->nBlockNum )
    {
        if ( pRefBlock->File._image.nParentBlockNum == ROOTPARENTNUM )
        {
            goto ErrorExit;     /* This is the root node of namespace, leave it */
        }

        nParentBlock = pRefBlock->File._image.nParentBlockNum;
        _HdsFreeBlock(pRefBlock);
        if ( pfRefBlockFreed )
        {
            *pfRefBlockFreed = TRUE;
        }
        goto UpdateParentBlock;
    }

    ChkDR(_HdsLoadBlockHDR(pRefBlock->pNS, nLeafBlock, &pLeafBlock)); /* load the leaf block */
    ChkDR(_HdsCopyChildPayload(pRefBlock, pLeafBlock));    /* copy its content to the ref block */
    ChkDR(_HdsWriteBlockHDR(pRefBlock));  /* update ref block */

    /* get the parent block num of the leaf block and free the leaf block */
    nParentBlock = pLeafBlock->File._image.nParentBlockNum;
    _HdsFreeBlock(pLeafBlock);  /* delete the ref block in file */

UpdateParentBlock:

    /* update the leaf block's parent's alloctable so that it won't point to the leaf node */
    _HdsInitBlockBuffer(pRefBlock->pNS, pLeafBlock, 0, eCHILDBLOCK);
    ChkDR(_HdsLoadBlockHDR(pRefBlock->pNS, nParentBlock, &pLeafBlock));

    /* walk the allocTable to find the slot contains the leaf block # */
    for (nIndex=0; nIndex<pLeafBlock->pNS->wMaxNumChildren; nIndex++)
    {
        DRM_DWORD nChildBlkNum;
        ChkDR(_HdsGetPutChildBlockNum(pRefBlock->pNS, ((_ChildBlockHDR*)pLeafBlock)->File._image.bChildAllocTable,
            nIndex, &nChildBlkNum, TRUE));
        if ( nChildBlkNum == nLeafBlock )
        {
            nChildBlkNum = 0;
            ChkDR(_HdsGetPutChildBlockNum(pRefBlock->pNS, ((_ChildBlockHDR*)pLeafBlock)->File._image.bChildAllocTable,
                nIndex, &nChildBlkNum, FALSE));

            ChkDR(_HdsWriteBlockHDR(pLeafBlock));
            goto ErrorExit;
        }
    }

    ChkDR(DRM_E_DSTCORRUPTED);     /* something must be wrong */

ErrorExit:
    _Hds_free(pRefBlock->pNS->pHDS, pLeafBlock);

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*
**
*/
static DRM_NO_INLINE DRM_RESULT _HdsSlotRead(
    IN     _SlotContext *f_pSlotCtx,
    IN     DRM_DWORD     f_cbData,
       OUT DRM_BYTE     *f_pbData,
       OUT DRM_DWORD    *f_pcbRead)
{
    DRM_RESULT dr              = DRM_SUCCESS;
    DRM_BOOL   fSlotCtxIsValid = FALSE;

    ChkArg(ISVALIDCONTEXT(f_pSlotCtx, eSlotContextSignature));

    DRMASSERT(f_pSlotCtx->pNS           != NULL
           && f_pSlotCtx->pNS->pHDS     != NULL
           && f_pSlotCtx->pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE);

    ChkDR(_HdsVerifySlotContext(f_pSlotCtx, &fSlotCtxIsValid));
    if (f_pSlotCtx->eStatus!=eSlotCtxReady || !fSlotCtxIsValid)
    {
        ChkDR(DRM_E_DSTSLOTNOTFOUND);
    }
    ChkDR(_HdsReadWriteSlot(f_pSlotCtx, f_cbData, f_pbData, f_pcbRead, TRUE));

ErrorExit:
    return dr;
}


/*
**
*/
static DRM_NO_INLINE DRM_RESULT _HdsSlotWrite(
    IN       _SlotContext  *f_pSlotCtx,
    IN       DRM_DWORD      f_cbData,
    IN const DRM_BYTE      *f_pbData,
       OUT   DRM_DWORD     *f_pcbWritten)
{
    DRM_RESULT dr              = DRM_SUCCESS;
    DRM_BOOL   fSlotCtxIsValid = FALSE;

    ChkArg(ISVALIDCONTEXT(f_pSlotCtx, eSlotContextSignature));

    DRMASSERT(f_pSlotCtx->pNS           != NULL
           && f_pSlotCtx->pNS->pHDS     != NULL
           && f_pSlotCtx->pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE );

    ChkDR(_HdsVerifySlotContext(f_pSlotCtx, &fSlotCtxIsValid));
    if (f_pSlotCtx->eStatus!=eSlotCtxReady || !fSlotCtxIsValid)
    {
        ChkDR(DRM_E_DSTSLOTNOTFOUND);
    }

    /* slot must be locked EXCLUSIVE */
    if ( (f_pSlotCtx->eLockMode & eDRM_DST_LOCKEXCLUSIVE) == 0 )
    {
        ChkDR(DRM_E_DSTNOTLOCKEDEXCLUSIVE);
    }

    /* NOTE: We cast away the const-ness here because we know _HdsReadWriteSlot
    ** is safe when the operation is Write */
    ChkDR(_HdsReadWriteSlot(f_pSlotCtx, f_cbData, (DRM_BYTE*)f_pbData, f_pcbWritten, FALSE));

ErrorExit:
    return dr;
}


/**********************************************************************
** Function:    _HdsRemoveSlot
** Synopsis:    Remove the slot from the block. If it is oversized, the
**              associated _DataBlocks are also removed.
** Arguments:   [pSlotCtx] --
**              [fPermanent] -- TRUE if to remove the slot permanently,
**                              FALSE if just to set it as 'hidden'
** Returns:     DRM_SUCCESS on success
** Notes:       It is the callers responsibility to lock the block for
**              EXCLUSIVE.
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsRemoveSlot(
    _SlotContext    *pSlotCtx,
    _ERemoveSlotMode eMode)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD   wDestPos=pSlotCtx->dwSlotPosInBlock;
    DRM_DWORD   wSrcPos=0;

    if ( eMode == eRemoveSlotPermanent )
    {
        /* remove _DataBlockHDR's, if necessary */
        if ( !ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
        {
            /* lock the associated block */
            wSrcPos = pSlotCtx->dwSlotPosInBlock + SIZEOF(_SlotHeader) +
                pSlotCtx->oSlotHeader.dwSlotSize;
        }
        else
        {
            DRM_DWORD nDataBlockNum = pSlotCtx->dwFirstDataBlockNum;

            wSrcPos = pSlotCtx->dwSlotPosInBlock + SIZEOF(_SlotHeader) + SIZEOF(DRM_DWORD);
            while (nDataBlockNum > 0)
            {
                ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, nDataBlockNum, &pSlotCtx->pCurrDataBlock));
                nDataBlockNum = ((_DataBlockHDR*)(pSlotCtx->pCurrDataBlock))->File._image.nCascadingBlockNum;
                ChkDR(_HdsFreeBlock(pSlotCtx->pCurrDataBlock));
            }
        }

        /* remove slot in _ChildBlockHDR */
        ChkDR(_HdsAdjustChildPayload(pSlotCtx->pCurrChildBlock, wDestPos, wSrcPos, ADJUST_PAYLOAD_TO_END));
        ChkDR(_HdsWriteBlockHDR(pSlotCtx->pCurrChildBlock));
    }
    else if ( eMode == eRemoveSlotSetNull )
    {
        if ( !ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
        {
            /* trash content of slot to NULL */
            DRM_BYTE *pbCopyBuffer=NULL;
            DRM_DWORD  cbWrite=0, cbWritten=0;

            dr = _Hds_malloc(pSlotCtx->pNS->pHDS, DRM_HDS_COPY_BUFFER_SIZE, (DRM_VOID**)&pbCopyBuffer);
            if ( DRM_SUCCEEDED(dr) )
            {
                ChkMem( pbCopyBuffer );
                pSlotCtx->dwSeekPointer=0;
                while (pSlotCtx->dwSeekPointer < pSlotCtx->oSlotHeader.dwSlotSize )
                {
                    cbWrite = min(DRM_HDS_COPY_BUFFER_SIZE, pSlotCtx->oSlotHeader.dwSlotSize-pSlotCtx->dwSeekPointer);
                    dr = _HdsSlotWrite(pSlotCtx, cbWrite, pbCopyBuffer, &cbWritten);
                    if ( DRM_FAILED(dr) )
                    {
                        break;
                    }
                    else if ( cbWrite != cbWritten )
                    {
                        dr = DRM_E_FILEWRITEERROR;
                        break;
                    }
                }

                _Hds_free(pSlotCtx->pNS->pHDS, pbCopyBuffer);
            }
        }
        else
        {
            /* delete all _DataBlock and set Datablock number to 0 in slot */
            DRM_DWORD nDataBlockNum = pSlotCtx->dwFirstDataBlockNum;

            /*wSrcPos = pSlotCtx->dwSlotPosInBlock + SIZEOF(_SlotHeader) + SIZEOF(DRM_DWORD);*/
            while (nDataBlockNum > 0)
            {
                ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, nDataBlockNum, &pSlotCtx->pCurrDataBlock));
                nDataBlockNum = ((_DataBlockHDR*)(pSlotCtx->pCurrDataBlock))->File._image.nCascadingBlockNum;
                ChkDR(_HdsFreeBlock(pSlotCtx->pCurrDataBlock));
            }

            /* make sure the flag is hidden */
            pSlotCtx->oSlotHeader.dwAttributes |= eSlotIsHidden;
            FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
            FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
            ChkDR( _HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, pSlotCtx->dwSlotPosInBlock,
                                           SIZEOF(_SlotHeader), &pSlotCtx->oSlotHeader, GPBP_OPERATION_WRITE) );
            FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
            FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );

            /* update _DataBlock number in Slot */
            pSlotCtx->dwFirstDataBlockNum = 0;
            ChkDR( _HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, pSlotCtx->dwSlotPosInBlock+SIZEOF(_SlotHeader),
                                          SIZEOF(DRM_DWORD), &pSlotCtx->dwFirstDataBlockNum, GPBP_OPERATION_WRITE));
        }
    }
    else if ( eMode == eRemoveSlotSetHidden )
    {
        /* set the flag to hidden */
        pSlotCtx->oSlotHeader.dwAttributes |= eSlotIsHidden;
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
        ChkDR( _HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, pSlotCtx->dwSlotPosInBlock,
                                      SIZEOF(_SlotHeader), &pSlotCtx->oSlotHeader, GPBP_OPERATION_WRITE));
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
    }

ErrorExit:

    return dr;
}

/*
** Duplicate the given Slot Context structure.
** Caller is responsible to _PrivateStackFree the resulting duplicate if buffer
** is not pre-allocated.
*/
static DRM_RESULT
_HdsDupSlotContext(
    IN const _SlotContext *pSrcContext,
    OUT _SlotContext **ppDstContext)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _SlotContext *pDupCtx=NULL;

    DRMASSERT(pSrcContext && ppDstContext);
    if ( *ppDstContext==NULL )
    {
        ChkDR(_Hds_malloc(pSrcContext->pNS->pHDS, pSrcContext->dwContextSize, (DRM_VOID**)&pDupCtx));
    }
    else
    {
        pDupCtx = *ppDstContext;
        ZEROMEM(pDupCtx, pSrcContext->dwContextSize);
    }

    MEMCPY(pDupCtx, pSrcContext, pSrcContext->dwContextSize);
    pDupCtx->pCurrChildBlock = (_CommBlockHDR *)pDupCtx->bBuff;
    if ( pSrcContext->pCurrDataBlock )
    {
        pDupCtx->pCurrDataBlock = (_CommBlockHDR *)(pDupCtx->bBuff + __CB_DECL(GetMemsize_ChildBlock(pSrcContext->pNS)));
    }

ErrorExit:
    if ( DRM_FAILED(dr) )
    {
        _Hds_free(pSrcContext->pNS->pHDS, pDupCtx);
    }
    else
    {
        *ppDstContext = pDupCtx;
    }

    return dr;
}


/*
** upon success, ppNewSlotCtx contains a new slot. Caller is responsible
** for freeing the buffer. Upon success, the new slot will have the same lock
** as the source slot.
*/
static DRM_NO_INLINE DRM_RESULT _HdsCopyAndLockNewSlot(
    IN  _SlotContext  *pSlotCtx,
    IN  DRM_DWORD      cbNewSize,
    OUT _SlotContext **ppNewSlotCtx)
{
    DRM_RESULT    dr=DRM_SUCCESS;
    DRM_DWORD     cbSlotContext=0;
    DRM_BYTE     *pbCopyBuffer=NULL;
    _HdsContext  *pHDS=NULL;
    _NsContext   *pNS=NULL;
    _SlotContext *pNewSlotCtx=NULL;
    _SlotHeader   oTmpHeader;
    DRM_DWORD     cbRead=0, cbWritten=0;

    DRMASSERT(pSlotCtx && ppNewSlotCtx);
    pHDS = pSlotCtx->pNS->pHDS;
    pNS  = pSlotCtx->pNS;

    /* alloc copy buffer & context for new slot */
    ChkOverflowSLOTCONTEXTLEN(pNS);
    cbSlotContext = CALC_SLOTCONTEXTLEN(pNS);
    ChkDR(_Hds_malloc(pHDS, cbSlotContext, (DRM_VOID **)&pNewSlotCtx));
    ChkDR(_HdsInitSlotContext(pNS, (DRM_BYTE*)pNewSlotCtx, cbSlotContext));

    /* Copy key from original slot and create new slot with temp keys.
    ** if this succeed, an EXCLUSIVE lock is issued for the new slot */
    MEMCPY(&oTmpHeader, &pSlotCtx->oSlotHeader, SIZEOF(_SlotHeader));
    ChkDR(_HdsOpenSlot(
        pNewSlotCtx->pNS,
        &oTmpHeader.oHashkey,
        &oTmpHeader.oUniquekey,
        TRUE,
        eDRM_DST_CREATE_NEW | pSlotCtx->eLockMode,
        FALSE,
       &cbNewSize,
        pNewSlotCtx));

    /* copy content from original slot to new slot
    ** NOTE: This copy process can be enhanced for oversized slot:
    ** it may be more efficient to simple detach the head of DataBlock list
    ** to the new slot.
    */
    ChkDR(_Hds_malloc(pHDS, DRM_HDS_COPY_BUFFER_SIZE, (DRM_VOID**)&pbCopyBuffer));
    ChkMem( pbCopyBuffer );
    pSlotCtx->dwSeekPointer=0;
    pNewSlotCtx->dwSeekPointer=0;
    while (pNewSlotCtx->dwSeekPointer < min(cbNewSize, pSlotCtx->oSlotHeader.dwSlotSize))
    {
        dr = _HdsSlotRead(pSlotCtx, min(cbNewSize-pSlotCtx->dwSeekPointer, DRM_HDS_COPY_BUFFER_SIZE), pbCopyBuffer, &cbRead);
        if ( DRM_SUCCEEDED(dr) )
        {
            dr = _HdsSlotWrite(pNewSlotCtx, cbRead, pbCopyBuffer, &cbWritten);
            if ( DRM_SUCCEEDED(dr) )
            {
                if ( cbRead == cbWritten)
                {
                    continue;
                }
                else if (cbRead != DRM_HDS_COPY_BUFFER_SIZE)
                {
                    break;
                }
                else /* (cbRead != cbWritten) */
                {
                    dr = DRM_E_FILEWRITEERROR;
                }
            }
        }
        break;
    }

    if (DRM_FAILED(dr))
    {
        _HdsUnlockSlot(pNewSlotCtx);  /* some error occured, unlock the slot */
    }

ErrorExit:
    if( pbCopyBuffer != NULL )
    {
        _Hds_free(pHDS, pbCopyBuffer);
    }
    if ( DRM_FAILED(dr)
      && pNewSlotCtx != NULL )
    {
        _Hds_free(pHDS, pNewSlotCtx);
    }
    else
    {
        *ppNewSlotCtx = pNewSlotCtx;
    }
    return dr;
}


/**********************************************************************
** Function:    _HdsRelocateSlotAndKeepCurrLock
** Synopsis:    Relocate a slot
** Arguments:   [pSlotCtx] -- Slot context of interest
**              [cbSize] -- new size
** Returns:     DRM_SUCCESS on success
** Notes:       The slot must be locked exclusive before calling
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsRelocateSlotAndKeepCurrLock(
    IN _SlotContext *pSlotCtx,
    IN DRM_DWORD     cbSize)
{
    DRM_RESULT    dr=DRM_SUCCESS;
    _SlotContext *pNewSlotCtx=NULL;
    _HdsContext  *pHDS=NULL;
    _NsContext   *pNS=NULL;

    DRMASSERT(pSlotCtx != NULL
          &&  pSlotCtx->pNS != NULL
          &&  pSlotCtx->pNS->pHDS != NULL
          &&  pSlotCtx->eStatus == eSlotCtxReady
          &&  cbSize > 0
          &&  (pSlotCtx->eLockMode & eDRM_DST_LOCKEXCLUSIVE) != 0 );

    pHDS = pSlotCtx->pNS->pHDS;
    pNS  = pSlotCtx->pNS;

    ChkDR(_HdsRemoveSlot(pSlotCtx, eRemoveSlotSetHidden));  /* set slot as 'hidden' */
    dr = _HdsCopyAndLockNewSlot(pSlotCtx, cbSize, &pNewSlotCtx);
    if ( DRM_SUCCEEDED(dr) )
    {
        DRM_BOOL fResult=FALSE;

        /* set old slot to null first */
        _HdsRemoveSlot(pSlotCtx, eRemoveSlotSetNull);

        /* remove old slot permanently if we can lock the block. It's okay to
        ** leave it as 'hidden'. we can pick it up when doing store cleanup. */
        _HdsUnlockSlot(pSlotCtx);       /* igmore return values */
        _HdsUnlockSlot(pNewSlotCtx);
        if ( DRM_SUCCEEDED(_HdsLockBlock2DeleteSlot(
                pSlotCtx,
                eDRM_DST_LOCKEXCLUSIVE ) ) )
        {
            _HdsRemoveSlot(pSlotCtx, eRemoveSlotPermanent);
            _HdsUnlockBlock2DeleteSlot(pSlotCtx);
        }

        /* re-initialize the new slot. This is necessary because _HdsRemoveSlot()
        ** may move the location of the new slot
        */
        ChkOverflowSLOTCONTEXTLEN( pNS );
        ChkDR(_HdsInitSlotContext(pNS, (DRM_BYTE*)pSlotCtx, CALC_SLOTCONTEXTLEN(pNS)));

        ChkDR(_HdsSearchSlotInFile(pNS, &pNewSlotCtx->oSlotHeader.oHashkey,
            &pNewSlotCtx->oSlotHeader.oUniquekey, eSearchDataSlot, NULL, pSlotCtx, &fResult));
        DRMASSERT(fResult); /* this should not happen, something must be wrong */

        /* issue lock to the relocated slot */
        dr = _HdsLockSlot(pSlotCtx, eDRM_DST_LOCKEXCLUSIVE | eDRM_DST_LOCKWAIT);
    }
    else
    {
        /* try recovering ... try unhide the slot */
        pSlotCtx->oSlotHeader.dwAttributes &= ~eSlotIsHidden;

        /* we do not care if this success or not. that's all we can do ... */
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
        _HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, pSlotCtx->dwSlotPosInBlock,
            SIZEOF(_SlotHeader), &pSlotCtx->oSlotHeader, GPBP_OPERATION_WRITE);
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );

        /* Report the error from above */
        ChkDR( dr );
    }

ErrorExit:

    _Hds_free(pHDS, pNewSlotCtx);
    return dr;
}


/*
**
*/
static DRM_NO_INLINE DRM_RESULT
_HdsDeleteSubTree(
    _NsContext *f_pNS,
    DRM_DWORD   f_nSubtreeRootBlockNum)
{
    DRM_RESULT     dr            = DRM_SUCCESS;
    DRM_DWORD      nIndex        = 0;
    _CommBlockHDR *pCurrBlock    = NULL;
    DRM_DWORD      nBlkNum       = f_nSubtreeRootBlockNum;
    DRM_DWORD      nParentBlkNum = 0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsDeleteSubTree);

    ChkArg(ISVALIDCONTEXT(f_pNS, eCfgContextSignature));
    DRMASSERT(f_pNS->fInited == TRUE);

    ChkDR(_HdsAllocBlockBuffer(f_pNS, eCHILDBLOCK, &pCurrBlock));

UPLEVEL:

    _HdsInitBlockBuffer(f_pNS, pCurrBlock, 0, eCHILDBLOCK);
    ChkDR(_HdsLoadBlockHDR(f_pNS, nBlkNum, &pCurrBlock));
    if (nParentBlkNum == 0 )    /* this should be run the first time */
    {
        nParentBlkNum = pCurrBlock->nBlockNum;
        DRMASSERT(nParentBlkNum!=0);  /* the root block of any Config sub-tree should NOT have parent block num == 0 */
    }

DOWNLEVEL:

    for (nIndex=0; nIndex < pCurrBlock->pNS->wMaxNumChildren; nIndex++)
    {
        ChkDR(_HdsGetPutChildBlockNum(f_pNS, ((_ChildBlockHDR*)pCurrBlock)->File._image.bChildAllocTable,
            nIndex, &nBlkNum, TRUE));
        if ( nBlkNum != 0 )  /* child node exists */
        {
            /* update child alloc table */
            DRM_DWORD n=0;
            ChkDR(_HdsGetPutChildBlockNum(f_pNS, ((_ChildBlockHDR*)pCurrBlock)->File._image.bChildAllocTable,
                nIndex, &n, FALSE));
            ChkDR(_HdsWriteBlockHDR(pCurrBlock));

            /* load the child block */
            ChkDR(_HdsLoadBlockHDR(f_pNS, nBlkNum, &pCurrBlock));
            goto DOWNLEVEL;
        }
    }

    if ( pCurrBlock->nBlockNum == nParentBlkNum )   /* terminating condition */
    {
        ChkDR(_HdsFreeBlock(pCurrBlock));
        goto ErrorExit; /* this is the root */
    }

    nBlkNum = pCurrBlock->File._image.nParentBlockNum;
    ChkDR(_HdsFreeBlock(pCurrBlock));
    goto UPLEVEL;

ErrorExit:
    if ( f_pNS )
    {
        _Hds_free(f_pNS->pHDS, pCurrBlock);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*
**
*/
static DRM_NO_INLINE DRM_RESULT
_HdsTraverseNextRightSiblingBlock(
    IN _NsContext *pNS,
    IN _CommBlockHDR * pCurrBlock,
    OUT DRM_DWORD *pnNextSiblingBlkNum)    /* 0 if no more child can be found */
{
    DRM_RESULT dr=DRM_SUCCESS;
    _CommBlockHDR *pParentBlock=NULL;
    DRM_DWORD nIndex=0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsTraverseNextRightSiblingBlock);

    DRMASSERT(pNS && pCurrBlock && pnNextSiblingBlkNum);
    *pnNextSiblingBlkNum = 0;

    /* get ChildAllocTable of the parent node */
    if ( pCurrBlock->File._image.nParentBlockNum == ROOTPARENTNUM )
    {
        goto ErrorExit;     /* Currblock is the root, that's it */
    }

    ChkDR(_HdsAllocBlockBuffer(pNS, eCHILDBLOCK, &pParentBlock));
    ChkDR(_HdsLoadBlockHDR(pNS, pCurrBlock->File._image.nParentBlockNum, &pParentBlock));

    /* search index of the current child in parent's ChildAlloc table */
    for (nIndex=0; nIndex<(DRM_DWORD)pNS->wMaxNumChildren; nIndex++)
    {
        DRM_DWORD nChildNum;
        ChkDR(_HdsGetPutChildBlockNum(pNS, ((_ChildBlockHDR*)pParentBlock)->File._image.bChildAllocTable,
            nIndex, &nChildNum, TRUE));

        if ( nChildNum == pCurrBlock->nBlockNum ) /* found current child */
        {
            /* search for next child */
            ++nIndex;
            for (; nIndex<(DRM_DWORD)pNS->wMaxNumChildren; nIndex++)
            {
                ChkDR(_HdsGetPutChildBlockNum(pNS, ((_ChildBlockHDR*)pParentBlock)->File._image.bChildAllocTable,
                    nIndex, &nChildNum, TRUE));
                if ( nChildNum!= 0 )    /* found one */
                {
                    *pnNextSiblingBlkNum = nChildNum;
                    break;
                }
            }
            goto ErrorExit;
        }
    }

    /* cannot find current child from parent, this should never happen */
    ChkDR(DRM_E_DSTCORRUPTED);  /* internal error */

ErrorExit:
    if (pParentBlock)
    {
        _Hds_free(pNS->pHDS, pParentBlock);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/**********************************************************************
** Function:    _HdsTraverseBlocksInPostOrder
** Synopsis:
** Arguments:   [pNS] --
**              [pCurrBlock] --
**              [pNextBlock] --
**              [pResult]
** Returns:     DRM_SUCCESS on success
** Notes:       From the given current block, traverse the tree in POST ORDER fashion.
** Algorithm:
**    PostOrder(CFG, Current, Next)
**    {
**        if ( Current == NULL )
**            Next = CFG->Root;
**        else
**        {
**            Next = NextRightSibling(Current);
**            if ( Next == NULL )
**            {
**                Next = Current->Parent;
**                if ( Next == NULL )
**                    return FALSE;  // that's it
**                else
**                    return TRUE;
**            }
**        }
**        Next = LeftmostLeaf(Next);
**        return TRUE;
**    }
**
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT
_HdsTraverseBlocksInPostOrder(
    IN _NsContext *pNS,
    IN _CommBlockHDR *pCurrBlock,
    OUT _CommBlockHDR *pNextBlock,
    OUT DRM_BOOL *pResult)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nBlockNum=0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsTraverseBlocksInPostOrder);

    DRMASSERT( pNS && pNextBlock && pResult);
    *pResult = FALSE;

    if ( pCurrBlock == NULL )   /* start from Root of current Namespace */
    {
        nBlockNum = pNS->nCfgRootBlockNum;
    }
    else
    {
        ChkDR(_HdsTraverseNextRightSiblingBlock(pNS, pCurrBlock, &nBlockNum));
        if ( nBlockNum == 0 )   /* no more sibling found */
        {
            /* no more sibling found, load the parent, if any, and return
            ** if no more sibling found and the parent is root, that's it
            */
            if ( pCurrBlock->File._image.nParentBlockNum == ROOTPARENTNUM )
            {
                *pResult = FALSE;   /* current block is the root */
            }
            else
            {   /* load parent block and return */
                ChkDR(_HdsLoadBlockHDR(pNS, pCurrBlock->File._image.nParentBlockNum,
                    &pNextBlock));
                *pResult = TRUE;
            }

            goto ErrorExit;
        }
    }

    ChkDR(_HdsLoadBlockHDR(pNS, nBlockNum, &pNextBlock));
    ChkDR(_HdsFindLeftmostLeafBlock(pNextBlock, &nBlockNum));
    if ( nBlockNum != pNextBlock->nBlockNum )
        ChkDR(_HdsLoadBlockHDR(pNS, nBlockNum, &pNextBlock));

    *pResult = TRUE;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*
** Get/Put the "attributes" field in the header of the specific slot
*/
static DRM_RESULT _HdsGetPutSlotAttributes(
    IN _NsContext              *pNS,
    IN const DRM_DST_KEY       *pHashKey,
    IN const DRM_DST_KEY       *pUniqueKey,
    IN DRM_BOOL                 fIsDataSlot,
    IN OUT DRM_UINT            *pfAttributes,
    IN DRM_BOOL                 fGet)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _SlotContext *pSlotCtx=NULL;
    DRM_BOOL fResult=FALSE;
    DRM_DWORD cbSlotContext=0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDSIMPL, PERF_FUNC__HdsGetPutSlotAttributes);

    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature));
    DRMASSERT(pNS->fInited && pNS->pHDS && pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE
        && pHashKey && pUniqueKey && pfAttributes);

    DRMASSERT(pNS->nCfgRootBlockNum>0);

    /* locate and open the slot */
    ChkOverflowSLOTCONTEXTLEN(pNS);
    cbSlotContext = CALC_SLOTCONTEXTLEN(pNS);
    ChkDR( _Hds_malloc(pNS->pHDS, cbSlotContext, (DRM_VOID **)&pSlotCtx) );
    ChkDR( _HdsInitSlotContext(pNS, (DRM_BYTE*)pSlotCtx, cbSlotContext) );
    ChkDR( _HdsSearchSlotInFile(pNS, pHashKey, pUniqueKey,
        fIsDataSlot? eSearchDataSlot : eSearchNamespace, NULL,
        pSlotCtx, &fResult) );
    if ( !fResult )
    {
        ChkDR(DRM_E_DSTSLOTNOTFOUND);
    }

    if ( fGet )
    {
        ChkDR(_HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, pSlotCtx->dwSlotPosInBlock,
            SIZEOF(_SlotHeader), &pSlotCtx->oSlotHeader, GPBP_OPERATION_READ));
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
        *pfAttributes = pSlotCtx->oSlotHeader.dwAttributes;

        /* Strip off private attributes */
        *pfAttributes &= ~(eSlotIsHidden|eSlotIsNamespace);
    }
    else
    {
        /* update the flag and flush to disk */
        DRM_DWORD dwAttributes = (pSlotCtx->oSlotHeader.dwAttributes) & (eSlotIsNamespace|eSlotIsHidden);

        /* Set to new public attributes.  Turn off private attributes */
        pSlotCtx->oSlotHeader.dwAttributes = *pfAttributes & ~(eSlotIsNamespace|eSlotIsHidden);

        /* OR back in private attributes */
        pSlotCtx->oSlotHeader.dwAttributes |= dwAttributes;
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
        ChkDR(_HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, pSlotCtx->dwSlotPosInBlock,
            SIZEOF(_SlotHeader), &pSlotCtx->oSlotHeader, GPBP_OPERATION_WRITE));
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
    }

ErrorExit:
    if ( pSlotCtx )
    {
        _Hds_free(pNS->pHDS, pSlotCtx);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/*
**
*/
static DRM_NO_INLINE DRM_RESULT _HdsInitSlotEnum(
    IN  _NsContext            *pNS,
    IN  const DRM_DST_KEY     *pHashKey,
    IN  DRM_DST_LOCKMODE       eLockMode,
    OUT _EnumContext          *pEnum)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_BOOL   fResult=FALSE;

    /* init Enum context */
    ZEROMEM(pEnum, CALC_MAXENUMCONTEXTLEN);
    pEnum->wContextSize = CALC_MAXENUMCONTEXTLEN;
    pEnum->pNS = pNS;
    pEnum->fInited = TRUE;
    pEnum->eContextSignature = eEnumContextSignature;
    pEnum->fCurrBlockIsValid = FALSE;
    pEnum->eLockMode = eLockMode;

    /* locate and prepare pEnum->oCurrBlock, if possible, for EnumNext() */
    ChkDR(_HdsInitBlockBuffer(pEnum->pNS, &pEnum->oCurrBlock, 0, eCHILDBLOCK));
    if ( pHashKey != NULL )     /* Hashkey is given, do query on the Hashkey */
    {
        DRM_DWORD      cbSlotCtx;
        _SlotContext *pSlotCtx=NULL;

        /* find the first block containing the Hashkey */
        pEnum->fIsQuery = TRUE;
        MEMCPY(pEnum->oHashKey.rgb, pHashKey->rgb, DRM_HDS_HASHKEY_SIZE);

        /* allocate temp slotcontext */
        ChkOverflowSLOTCONTEXTLEN(pNS);
        cbSlotCtx = CALC_SLOTCONTEXTLEN(pNS);
        ChkDR(_Hds_malloc(pNS->pHDS, cbSlotCtx, (DRM_VOID**)&pSlotCtx));
        dr = _HdsInitSlotContext(pNS, (DRM_BYTE *)pSlotCtx, cbSlotCtx);
        if ( DRM_SUCCEEDED(dr) )
        {
            /* search the first slot matching given hashkey */
            dr = _HdsSearchSlotInFile(pNS, pHashKey, NULL, eSearchSlotDontCare, NULL,
                pSlotCtx, &fResult);
            if ( DRM_SUCCEEDED(dr) )
            {
                if ( !fResult )
                {
                    dr = DRM_E_DSTSLOTNOTFOUND;
                }
                else
                {
                    dr = _HdsCopyBlockBuffer(&pEnum->oCurrBlock, pSlotCtx->pCurrChildBlock);
                    if ( DRM_SUCCEEDED(dr) )
                    {
                        ((_ChildBlockHDR*)(&pEnum->oCurrBlock))->nCurrSlotPos = MAXSLOTPOS;
                        ((_ChildBlockHDR*)(&pEnum->oCurrBlock))->nNextSlotPos = MAXSLOTPOS;
                    }
                }
            }
        }

        _Hds_free(pNS->pHDS, pSlotCtx);
        ChkDR(dr);
    }
    else
    {
        /* find the first block in postorder */
        pEnum->fIsQuery = FALSE;
        ChkDR(_HdsTraverseBlocksInPostOrder(pNS, NULL, &pEnum->oCurrBlock, &fResult));
        if ( !fResult )
        {
            ChkDR(DRM_E_DSTSLOTNOTFOUND);
        }
    }

    pEnum->fCurrBlockIsValid = TRUE;
    MEMCPY(&pEnum->oFileBlock, &pEnum->oCurrBlock, SIZEOF(_CommBlockHDR));

ErrorExit:
    return dr;
}

static DRM_NO_INLINE DRM_RESULT _HdsReadNsEntryFromDisk(
    IN  _HdsContext      *pHDS,
    IN  _SlotContext     *pNsSlotCtx,
    IN  DRM_DWORD         cbNsSlotSize,
    OUT _NSEntry        **ppNsDiskEntry )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cbRead = 0;

    ChkArg( pHDS != NULL );
    ChkArg( pNsSlotCtx != NULL );
    ChkArg( cbNsSlotSize > 0 );
    ChkArg( ppNsDiskEntry != NULL );

    *ppNsDiskEntry = NULL;
    ChkDR(_Hds_malloc(pHDS, cbNsSlotSize, (DRM_VOID**)ppNsDiskEntry));

    ChkDR(_HdsSlotRead(pNsSlotCtx, cbNsSlotSize, (DRM_BYTE *)*ppNsDiskEntry, &cbRead));

    ChkBOOL( cbRead == cbNsSlotSize, DRM_E_FILEREADERROR );

    FIX_ENDIAN_WORD( (*ppNsDiskEntry)->wMaxNumChildren );
    FIX_ENDIAN_DWORD((*ppNsDiskEntry)->nNSRBlockNum );
    if( cbNsSlotSize >= SIZEOF( _NSEntry ) + DRM_HDS_NSNAME_SIZE )
    {
        /* The slot does have the Bloom parameters, so let's use them */
        FIX_ENDIAN_WORD( (*ppNsDiskEntry)->wBloomBytesM );
        FIX_ENDIAN_WORD( (*ppNsDiskEntry)->wBloomK );
    }
    else if( pHDS->dwStoreVersion == DRM_HDS_FILE_VERSION_0 )
    {
        /* There was no Bloom filter in this version of the HDS format */
        (*ppNsDiskEntry)->wBloomBytesM = 0;
        (*ppNsDiskEntry)->wBloomK = 0;
    }
    else if( pHDS->dwStoreVersion == DRM_HDS_FILE_VERSION_1 )
    {
        /* Default to original hardcoded Bloom values */
        (*ppNsDiskEntry)->wBloomBytesM = HDS_CHILDBLOCK_PRERELEASE_BLOOM_M;
        (*ppNsDiskEntry)->wBloomK = HDS_CHILDBLOCK_PRERELEASE_BLOOM_K;
    }
    else
    {
        ChkDR( DRM_E_DSTCORRUPTED );
    }
    ChkDR(_HdsValidateNSEntryFromDisk( pHDS, *ppNsDiskEntry ) );

ErrorExit:
    if( DRM_FAILED( dr )
     &&  ppNsDiskEntry != NULL
     && *ppNsDiskEntry != NULL )
    {
        _Hds_free( pHDS, *ppNsDiskEntry );
        *ppNsDiskEntry = NULL;
    }
    return dr;
}


/*
**
*/
static DRM_NO_INLINE DRM_RESULT
_HdsCleanupNamespace(
    IN _NsContext *f_pNS)
{
    DRM_RESULT     dr         = DRM_SUCCESS;
    DRM_BOOL       fResult    = TRUE;
    _CommBlockHDR *pCurrBlock = NULL;
    _CommBlockHDR *pNextBlock = NULL;

    ChkArg(ISVALIDCONTEXT(f_pNS, eCfgContextSignature));
    DRMASSERT(f_pNS->fInited  == TRUE
           && f_pNS->pHDS     != NULL
           && f_pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE);

    ChkDR(_HdsAllocBlockBuffer(f_pNS, eCHILDBLOCK, &pCurrBlock));
    ChkDR(_HdsAllocBlockBuffer(f_pNS, eCHILDBLOCK, &pNextBlock));

    /* traverse the namespace in POST ORDER and process each block */
    ChkDR(_HdsTraverseBlocksInPostOrder(f_pNS, NULL,  pCurrBlock, &fResult));
    while (fResult)
    {
        DRM_BOOL fEmpty = FALSE;

        if ( ((_ChildBlockHDR*)pCurrBlock)->File._image.nFreeMem == f_pNS->nImagesize_ChildBlockPayload )
        {
            fEmpty = TRUE;
        }

        ChkDR(_HdsTraverseBlocksInPostOrder(f_pNS, pCurrBlock, pNextBlock, &fResult)); /* traverse next */
        if ( fEmpty )
        {
            /* perform defragment now.  note: pCurrBlock might get free'd */
            ChkDR(_HdsDefragmentFile(pCurrBlock, NULL));

            if( fResult )
            {
                /* Refresh the block allocation table in the next block as it could
                ** have changed during the defrag
                */
                ChkDR(_HdsLoadBlockHDR(f_pNS, pNextBlock->nBlockNum, &pNextBlock));
            }
        }
        if ( !fResult )
        {
            goto ErrorExit;  /* that's it */
        }

        /* If it was freed then the block type will have been changed to FREEBLOCK
        ** and will cause the CopyBlockBuffer function below to assert, so we need
        ** to just change it back to CHILDBLOCK.
        */
        pCurrBlock->File._image.bBlockType = eCHILDBLOCK;

        /* the block becomes the current block */
        ChkDR(_HdsCopyBlockBuffer(pCurrBlock, pNextBlock));
    }

ErrorExit:
    if ( pNextBlock )
    {
        _Hds_free(f_pNS->pHDS, pNextBlock);
    }
    if ( pCurrBlock )
    {
        _Hds_free(f_pNS->pHDS, pCurrBlock);
    }

    return dr;
}



/*
**
*/
static DRM_NO_INLINE DRM_RESULT _HdsCloseSlot(
    IN _SlotContext *f_pSlotCtx)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg(ISVALIDCONTEXT(f_pSlotCtx, eSlotContextSignature));

    DRMASSERT(f_pSlotCtx->pNS           != NULL
           && f_pSlotCtx->pNS->pHDS     != NULL
           && f_pSlotCtx->pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE);

#if DBG
    /* trash the slot context and return */
    MEMSET(f_pSlotCtx, 0xdb, f_pSlotCtx->dwContextSize);
#endif

    /* to indicate the slot is closed */
    f_pSlotCtx->eStatus = eSlotCtxUninit;
ErrorExit:
    return dr;
}


/**********************************************************************
** Function:    _HdsSlotEnumNext
** Synopsis:
** Arguments:   [pEnumContext] -- Enum Context init'd by DRM_HDS_InitSlotEnum()
**              [pSlotContext] -- Slot Context of the current slot
**              [pHashKey] -- Hashkey of the current slot
**              [pUniqueKey] -- Uniquekey of the current slot
**              [pcbSlotSize] -- size of the current slot
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsSlotEnumNext(
    IN  _EnumContext      *pEnum,
    OUT _SlotContext      *pSlotCtx,
    OUT DRM_DST_KEY       *pHashKey,
    OUT DRM_DST_KEY       *pUniqueKey,
    OUT DRM_DWORD         *pcbSlotSize)
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_BOOL         fResult=FALSE;
    DRM_DST_KEY     *pQueriedHashkey=NULL;
    _CommBlockHDR   *pNextBlock=NULL;
    _CommBlockHDR   *pTmpBlock=NULL;

    DRMASSERT(pEnum && pEnum->pNS);
    ChkArg(ISVALIDCONTEXT(pEnum, eEnumContextSignature));
    ChkArg(ISVALIDCONTEXT(pEnum->pNS, eCfgContextSignature));
    DRMASSERT(pEnum->pNS->fInited && pEnum->pNS->pHDS && pSlotCtx
        && pEnum->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /*
    ** Verify validity of the current block of the slot context
    */
    {
        _CommBlockHDR *pBlock = &pEnum->oFileBlock;
        _CommBlockHDR *pCurrBlock = &pEnum->oCurrBlock;

        /* load generic block header */
        ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum, &pBlock,
            GPBH_GENERIC_ONLY, GPBH_OPERATION_READ));

        /* verify the generic header */
        if ( !DRM_UI64Eql(pEnum->oFileBlock.File._image.ui64TimeStamp, pCurrBlock->File._image.ui64TimeStamp) ||
           MEMCMP(pEnum->oFileBlock.File._image.bBlockHash, pCurrBlock->File._image.bBlockHash, SIZEOF(pCurrBlock->File._image.bBlockHash))!=0 )
        {
            /* the current block has been updated/written since last read */
            _SlotHeader slotHeader;
            DRM_DWORD   dwCurrPos = 0;

            /* check if it is still a CHILD block or belong to the same parent */
            if ( GET_BYTE( &pEnum->oFileBlock.File._image.bBlockType, 0 ) != GET_BYTE( &pCurrBlock->File._image.bBlockType, 0 )
              || pEnum->oFileBlock.File._image.nParentBlockNum            != pCurrBlock->File._image.nParentBlockNum )
            {
                /* there is nothing we can do when the current block is
                ** totally invalid
                */
                ChkDR(DRM_E_NOMORE);
            }

            /* check if query started yet */
            if ( ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos == MAXSLOTPOS )
            {
                /* query has not been started, reload the current block from file and keep on */
                ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum,
                    &pCurrBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));
                goto Verified_Okay;
            }

            /* load the child block in a tmp buffer */
            ChkDR(_HdsAllocBlockBuffer(pEnum->pNS, eCHILDBLOCK, &pTmpBlock));
            ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum,
                &pTmpBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));

            /* load the current slot header from file */
            ChkDR(_HdsGetPutBlockPayload(pTmpBlock, ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos,
                SIZEOF(_SlotHeader), &slotHeader, GPBP_OPERATION_READ));
            FIX_ENDIAN_DWORD( slotHeader.dwAttributes );
            FIX_ENDIAN_DWORD( slotHeader.dwSlotSize );
            if (MEMCMP(&slotHeader, &pEnum->oSlotHeader, SIZEOF(_SlotHeader))==0 )
            {
                /* the current slot is intact, update the block buffer and continue */
                DRM_DWORD _dwCurrPos = ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos;
                DRM_DWORD _dwNextPos = ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos;

                ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum, &pCurrBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));
                ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos = _dwCurrPos;
                ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos = _dwNextPos;
                goto Verified_Okay;
            }

            /* walk the new block, try seek to >=  the current slot position. */
            dwCurrPos = ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos;
            if ( pEnum->fIsQuery )
            {
                pQueriedHashkey = &pEnum->oHashKey;
            }

            ChkDR(_HdsInitSlotContext(pEnum->pNS, (DRM_BYTE*)pSlotCtx, CALC_MAXSLOTCONTEXTLEN));
            while (TRUE)
            {
                /* search current block at next postion */
                ChkDR(_HdsSearchSlotInBlock(pTmpBlock, pQueriedHashkey, NULL,
                    eSearchSlotDontCare, pSlotCtx, &fResult));
                if ( !fResult )
                {
                    /* the current block has less slots than before, restart query at next block, if any */
                    goto Verified_Okay;
                }
                if ( ((_ChildBlockHDR*)pTmpBlock)->nCurrSlotPos >= dwCurrPos )
                {
                    /* walk to position >= current slot position in old block. restart query from here in new block*/
                    ((_ChildBlockHDR*)pTmpBlock)->nNextSlotPos = ((_ChildBlockHDR*)pTmpBlock)->nCurrSlotPos;
                    ChkDR(_HdsCopyBlockBuffer(&pEnum->oCurrBlock, pTmpBlock));

                    goto Verified_Okay;
                }
            }
        }
    }

Verified_Okay:

    if ( pEnum->fIsQuery )
    {
        pQueriedHashkey = &pEnum->oHashKey;
    }

    ChkDR(_HdsInitSlotContext(pEnum->pNS, (DRM_BYTE*)pSlotCtx, CALC_MAXSLOTCONTEXTLEN));
    ChkDR(_HdsAllocBlockBuffer(pEnum->pNS, eCHILDBLOCK, &pNextBlock));
    while (TRUE)
    {
        /* search current block at next postion */
        ChkDR(_HdsSearchSlotInBlock(&pEnum->oCurrBlock, pQueriedHashkey, NULL,
            eSearchSlotDontCare, pSlotCtx, &fResult));
        if ( fResult )
        {
            if ( pHashKey )
            {
                MEMCPY(pHashKey->rgb, pSlotCtx->oSlotHeader.oHashkey.rgb, DRM_HDS_HASHKEY_SIZE);
            }
            if ( pUniqueKey )
            {
                MEMCPY(pUniqueKey->rgb, pSlotCtx->oSlotHeader.oUniquekey.rgb, DRM_HDS_UNIQUEKEY_SIZE);
            }
            if ( pcbSlotSize )
            {
               *pcbSlotSize = pSlotCtx->oSlotHeader.dwSlotSize;
            }

            pSlotCtx->eStatus = eSlotCtxReady;
            break;
        }

        /* keep digging */
        if ( pEnum->fIsQuery )
        {
            ChkDR(_HdsHashToChildBlock(pEnum->pNS, &pEnum->oCurrBlock, pEnum->oHashKey.rgb,
                &pNextBlock, &fResult, NULL));
        }
        else
        {
            ChkDR(_HdsTraverseBlocksInPostOrder(pEnum->pNS, &pEnum->oCurrBlock,
                pNextBlock, &fResult));
        }

        if ( !fResult )
        {
            /* no more block found */
            dr = DRM_E_NOMORE;
            goto ErrorExit;
        }

        /* the block becomes the current block */
        ChkDR(_HdsCopyBlockBuffer(&pEnum->oCurrBlock, pNextBlock));
    }

    MEMCPY(&pEnum->oFileBlock, &pEnum->oCurrBlock, SIZEOF(_CommBlockHDR));
    MEMCPY(&pEnum->oSlotHeader, &pSlotCtx->oSlotHeader, SIZEOF(_SlotHeader));

ErrorExit:

    if ( pNextBlock )
    {
        _Hds_free(pEnum->pNS->pHDS, pNextBlock);
    }
    if ( pTmpBlock )
    {
        _Hds_free(pEnum->pNS->pHDS, pTmpBlock);
    }
    return dr;
}



/**********************************************************************
** Function:    _HdsCleanupStore
** Synopsis:
** Arguments:   [pHDS] --
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsCleanupStore(
    _HdsContext *pHDS)
{
    DRM_RESULT            dr=DRM_SUCCESS;
    DRM_DWORD             cbEntry=0;
    _EnumContext         *pEnumContext=NULL;
    _NsContext           *pNsStoreCTX=NULL;
    _NsContext           *pNsCtx=NULL;
    DRM_DST_SLOT_CONTEXT *pSlotContext=NULL;
    DRM_DST_NAMESPACE    *pNamespace=NULL;
    _NSEntry             *pNsStoreEntry=NULL;

    /* no namespace store exist ==> no namespace found */
    DRMASSERT(pHDS && pHDS->oSRN.nNsStoreRootBlockNum>0);

    /* allocate memory */
    ChkDR(_Hds_malloc(pHDS, DRM_HDS_ENUM_CONTEXT_LEN,      (DRM_VOID**)&pEnumContext));
    ChkDR(_Hds_malloc(pHDS, DRM_HDS_NAMESPACE_CONTEXT_LEN, (DRM_VOID**)&pNsStoreCTX));
    ChkDR(_Hds_malloc(pHDS, DRM_HDS_NAMESPACE_CONTEXT_LEN, (DRM_VOID**)&pNsCtx));
    ChkDR(_Hds_malloc(pHDS, SIZEOF(DRM_DST_SLOT_CONTEXT),  (DRM_VOID**)&pSlotContext));
    ChkDR(_Hds_malloc(pHDS, SIZEOF(DRM_DST_NAMESPACE),     (DRM_VOID**)&pNamespace));

    /* Enum each namespace, call cleanupNamespace */
    ChkDR(_HdsInitNsContext(pHDS, pNsStoreCTX, NULL, pHDS->oSRN.nNsStoreRootBlockNum,
        NsStoreNumofChildren, 0, 0));
    ChkDR(_HdsInitSlotEnum(pNsStoreCTX, NULL, eDRM_DST_LOCKSHARED, pEnumContext));
    while (TRUE)
    {
        dr = _HdsSlotEnumNext(pEnumContext, (_SlotContext*)pSlotContext, NULL, NULL, &cbEntry);
        if (dr == DRM_E_NOMORE)
        {
            dr = DRM_SUCCESS;
            break;
        }
        ChkDR(dr);

        ChkDR( _HdsReadNsEntryFromDisk( pHDS, (_SlotContext*)pSlotContext, cbEntry, &pNsStoreEntry ) );

        ChkDR(_HdsCloseSlot((_SlotContext*)pSlotContext));

        /* cleanup this namespace */
        MEMCPY(pNamespace->rgbOpaqueData, pNsStoreEntry->bNSName, DRM_HDS_NSNAME_SIZE);
        ChkDR(_HdsInitNsContext(pHDS, pNsCtx, pNamespace, pNsStoreEntry->nNSRBlockNum,
            pNsStoreEntry->wMaxNumChildren, pNsStoreEntry->wBloomBytesM, pNsStoreEntry->wBloomK));
        ChkDR(_HdsCleanupNamespace(pNsCtx));
        ChkDR(_Hds_free(pHDS, pNsStoreEntry));
        pNsStoreEntry = NULL;
    }

ErrorExit:
    /* free the local memory in reverse order */
    _Hds_free(pHDS, pNsStoreEntry);
    _Hds_free(pHDS, pNamespace);
    _Hds_free(pHDS, pSlotContext);
    _Hds_free(pHDS, pNsCtx);
    _Hds_free(pHDS, pNsStoreCTX);
    _Hds_free(pHDS, pEnumContext);
    return dr;
}


/**********************************************************************
** Function:    _HdsSlotResize
** Synopsis:
** Arguments:   [pSlotCtx]  -- slot context
**              [cbNewSize] -- new size to be used
** Returns:     DRM_SUCCESS on success
** Notes:       The resized slot will have the same type of lock as before.
***********************************************************************
*/
static DRM_RESULT _HdsSlotResize(
    IN _SlotContext *pSlotCtx,
    IN DRM_DWORD     cbNewSize)
{
    DRM_RESULT     dr=DRM_SUCCESS;
    DRM_DWORD      dwOldSize=0;

    DRMASSERT(pSlotCtx && cbNewSize && pSlotCtx->pNS && pSlotCtx->pNS->pHDS);
    dwOldSize=pSlotCtx->oSlotHeader.dwSlotSize;
    if ( cbNewSize == dwOldSize )    /* same size, do nothing */
    {
        goto ErrorExit;
    }

    /* slot must be locked EXCLUSIVE */
    if ( (pSlotCtx->eLockMode & eDRM_DST_LOCKEXCLUSIVE) == 0 )
    {
        ChkDR(DRM_E_DSTNOTLOCKEDEXCLUSIVE);
    }

    /*************************************************************************
    ** all other cases will involve copying or moving slot content
    */
    ChkDR(_HdsRelocateSlotAndKeepCurrLock(pSlotCtx, cbNewSize));
    pSlotCtx->dwSeekPointer = 0;

ErrorExit:
    if( DRM_SUCCEEDED( dr ) )
    {
        /* On success the size of the slot should be the user given size */
        pSlotCtx->oSlotHeader.dwSlotSize = cbNewSize;
    }
    return dr;
}

static DRM_NO_INLINE DRM_VOID _ZeroHDSContextIgnoringCritSec(
    _HdsContext *f_pcontextHDS)
{
    f_pcontextHDS->dwContextSize               = 0;
    f_pcontextHDS->fInited                     = FALSE;
    f_pcontextHDS->eContextSignature           = 0;
    f_pcontextHDS->fp                          = OEM_INVALID_HANDLE_VALUE;
    f_pcontextHDS->nImagesize_FileBlockHDR     = 0;
    f_pcontextHDS->nImagesize_DataBlockHDR     = 0;
    f_pcontextHDS->nImagesize_DataBlockPayload = 0;
    f_pcontextHDS->nDataBlockPayloadPos        = 0;

    ZEROMEM(&f_pcontextHDS->oHeap,    SIZEOF(f_pcontextHDS->oHeap));
    ZEROMEM(&f_pcontextHDS->oSRN,     SIZEOF(f_pcontextHDS->oSRN));
    ZEROMEM(&f_pcontextHDS->contextMD5, SIZEOF(f_pcontextHDS->contextMD5));
}


static DRM_NO_INLINE DRM_RESULT _HdsCreateNameSpaceStore(
    IN _HdsContext *pHDS)
{
    DRM_RESULT     dr   = DRM_SUCCESS;
    _NsContext     oNsStoreCFG;
    _CommBlockHDR *pNsStoreBlock = NULL;

    /* if namespace store does not exist */
    if ( pHDS->oSRN.nNsStoreRootBlockNum == 0 )
    {
        /* NamespaceStore root block does not exist, create one and update SRN */
        ChkDR(_HdsInitNsContext(pHDS, &oNsStoreCFG, NULL, 0, NsStoreNumofChildren, 0, 0));
        ChkDR(_HdsLoadSRN(pHDS));   /* update SRN in memory */

        ChkDR(_HdsAllocBlock(&oNsStoreCFG, ROOTPARENTNUM, &pNsStoreBlock, eCHILDBLOCK));
        pHDS->oSRN.nNsStoreRootBlockNum = pNsStoreBlock->nBlockNum;

        ChkDR(_HdsUpdateSRN(pHDS));

        /* we do not create namespace too often, let's flush it now */
        if ( !Oem_File_FlushBuffers(pHDS->fp) )
        {
            ChkDR(DRM_E_FILEWRITEERROR);
        }
    }

ErrorExit:

    _Hds_free(pHDS, pNsStoreBlock);
    return dr;
}


static DRM_NO_INLINE DRM_RESULT _HdsCreateNamespace(
    IN       _HdsContext       *pHDS,
    IN const DRM_DST_NAMESPACE *pNamespace,
    IN const DRM_WORD           wMaxNumChildren, /* wMaxNumChildren must be <= DRM_HDS_MAXIMUM_CHILDREN */
    IN       DRM_DWORD          dwExpectedSlotSize,
    IN       DRM_BOOL           fWait)
{
    DRM_RESULT        dr               = DRM_SUCCESS;
    DRM_DWORD         cbNsStoreSlot    = 0;
    _NsContext        oNsStoreCFG      = {0};
    _SlotContext     *pNsStoreSlotCtx  = NULL;
    _NSEntry         *pNsStoreEntry    = NULL;
    _CommBlockHDR    *pNsRootBlock     = NULL;
    DRM_BOOL          fCreated         = FALSE;
    _NsContext        oNsCtx           = {0};
    DRM_WORD          wBloomBytesM     = 0;
    DRM_WORD          wBloomK          = 0;

    ChkArg( pHDS        != NULL
        &&  pNamespace  != NULL
        &&  pHDS->fp    != OEM_INVALID_HANDLE_VALUE
        &&  wMaxNumChildren > 0
        &&  wMaxNumChildren <= DRM_HDS_MAXIMUM_CHILDREN );

    /* flush SRN in context */
    ChkDR(_HdsLoadSRN(pHDS));

    /* First, set up a HDS Config for accessing the NamespaceStore
    ** ===========================================================
    */
    ChkDR(_HdsCreateNameSpaceStore(pHDS));


    /* Second, set up tmp Config for the new namespace, allocate and set up
    ** the Root block for the new namespace
    ** Note, parent of NamespaceRoot block is always 'ROOTPARENTNUM'
    ** ============================================================
    */
    _HdsCalcOptimalBloom( (DRM_DWORD)(( pHDS->oSRN.dwBlockSize - SIZEOF( _CommBlockFileHDR ) ) / ( dwExpectedSlotSize + SIZEOF( _SlotHeader ) ) ), &wBloomBytesM, &wBloomK );
    ChkDR(_HdsInitNsContext(pHDS, &oNsCtx, pNamespace, 0, wMaxNumChildren, wBloomBytesM, wBloomK));
    ChkDR(_HdsAllocBlock(&oNsCtx, ROOTPARENTNUM, &pNsRootBlock, eCHILDBLOCK));

    /* Third, alloc buffer and setup _SlotContext to store the given
    ** namespace in NamespaceStore
    ** ==============================================================
    */
    {
        DRM_DST_KEY oNsHashKey;
        DRM_DST_KEY oNsUniqueKey;
        DRM_DWORD   cbNsStoreSlotCtx = 0;

        ChkOverflowSLOTCONTEXTLEN(&oNsStoreCFG);
        ChkDR(_HdsInitNsContext(pHDS, &oNsStoreCFG, NULL, pHDS->oSRN.nNsStoreRootBlockNum,
                                NsStoreNumofChildren, 0, 0));     /* set up the Config for NamespaceStore */

        cbNsStoreSlotCtx = CALC_SLOTCONTEXTLEN(&oNsStoreCFG);  /* size of slot context */
        ChkDR(_Hds_malloc(pHDS, cbNsStoreSlotCtx, (DRM_VOID**)&pNsStoreSlotCtx));
        ChkDR(_HdsInitSlotContext(&oNsStoreCFG, (DRM_BYTE *)pNsStoreSlotCtx, cbNsStoreSlotCtx));

        /* prepare the namespace content and store it in NamespaceStore
        ** ===================================================================
        */
        _GenNamespaceKeys (&pHDS->contextMD5,
               (DRM_CHAR *) pNamespace->rgbOpaqueData,
                            SIZEOF( DRM_DST_KEY ),
                            oNsHashKey.rgb,
                            oNsUniqueKey.rgb);  /* gen key for given namespace */
        cbNsStoreSlot = SIZEOF(_NSEntry) + DRM_HDS_NSNAME_SIZE;    /* size of the namespace slot in NamespaceStore */
        dr = _HdsOpenSlot(
                &oNsStoreCFG,
                &oNsHashKey,
                &oNsUniqueKey,
                FALSE,
                eDRM_DST_CREATE_NEW | eDRM_DST_LOCKEXCLUSIVE | (fWait? eDRM_DST_LOCKWAIT : 0),
                FALSE,
               &cbNsStoreSlot,
                pNsStoreSlotCtx );
        if ( DRM_SUCCEEDED(dr) )
        {
            /* store the namespace into NamespaceStore */
            DRM_DWORD cbWritten=0;

            fCreated = TRUE;

            /* set up tmp Config for the new namespace and allocate and set up
            ** the Root block for the new namespace
            ** Note, parent of NamespaceRoot block is always 'ROOTPARENTNUM'*/

            /* allocate buffer and prepare the namespace slot */
            ChkDR(_Hds_malloc(pHDS, cbNsStoreSlot, (DRM_VOID**)&pNsStoreEntry));
            pNsStoreEntry->nNSRBlockNum = pNsRootBlock->nBlockNum;
            pNsStoreEntry->wMaxNumChildren = wMaxNumChildren;
            pNsStoreEntry->wBloomBytesM = wBloomBytesM;
            pNsStoreEntry->wBloomK = wBloomK;
            MEMCPY(pNsStoreEntry->bNSName, pNamespace->rgbOpaqueData, DRM_HDS_NSNAME_SIZE);

            ChkDR( _HdsValidateNSEntryFromDisk( pHDS, pNsStoreEntry ) );

            /* write the namespace slot in NsStore */
            FIX_ENDIAN_WORD( pNsStoreEntry->wMaxNumChildren );
            FIX_ENDIAN_DWORD( pNsStoreEntry->nNSRBlockNum );
            FIX_ENDIAN_WORD( pNsStoreEntry->wBloomBytesM );
            FIX_ENDIAN_WORD( pNsStoreEntry->wBloomK );
            ChkDR( _HdsSlotWrite(pNsStoreSlotCtx, cbNsStoreSlot, (DRM_BYTE *)pNsStoreEntry, &cbWritten) );
            FIX_ENDIAN_WORD( pNsStoreEntry->wMaxNumChildren );
            FIX_ENDIAN_DWORD( pNsStoreEntry->nNSRBlockNum );
            FIX_ENDIAN_WORD( pNsStoreEntry->wBloomBytesM );
            FIX_ENDIAN_WORD( pNsStoreEntry->wBloomK );

            /* we do not create namespace too often, let's flush it now */
            if ( !Oem_File_FlushBuffers(pHDS->fp) )
            {
                ChkDR( DRM_E_FILEWRITEERROR );
            }

            ChkDR( _HdsAddNSCacheEntry( pHDS, pNsStoreEntry ) );

        }
        else if ( dr == DRM_E_DSTSLOTEXIST )
        {
            TRACE(("DRM_HDS_CreateNamespace(): namespace '%s' already exist.\n", pNamespace->rgbOpaqueData));
            dr = DRM_E_DSTNAMESPACEEXIST;
        }
    }

ErrorExit:

    if ( DRM_FAILED(dr)  &&  pNsRootBlock != NULL )
    {
        /* we have error, remove the allocated slot */
        _HdsFreeBlock((_CommBlockHDR *)pNsRootBlock);
    }

    if ( fCreated )
    {
        _HdsUnlockSlot(pNsStoreSlotCtx);
        _HdsCloseSlot(pNsStoreSlotCtx);
    }

    _Hds_free(pHDS, pNsStoreEntry);
    _Hds_free(pHDS, pNsStoreSlotCtx);
    _Hds_free(pHDS, pNsRootBlock);
    return dr;
}

static DRM_NO_INLINE DRM_RESULT _HdsOpenExistingNamespace(
    IN       _HdsContext               *pHDS,
    IN const DRM_DST_NAMESPACE         *pNamespace,
    OUT      DRM_DST_NAMESPACE_CONTEXT *pcontextNS) /* user given NS context buffer, NULL to get size */
{
    DRM_RESULT    dr=DRM_SUCCESS;
    DRM_DST_KEY   oNsHashKey;
    DRM_DST_KEY   oNsUniqueKey;
    DRM_DWORD     cbNsStoreSlotCtx=0;
    DRM_DWORD     cbNsSlotSize=0;
    _NsContext    oNsStoreCFG;
    _SlotContext *pNsStoreSlotCtx=NULL;
    _NSEntry     *pNsEntry=NULL;
    _NSEntry     *pNsDiskEntry=NULL;
    _NsContext   *pNsCFG=NULL;

    DRMASSERT(pHDS && pNamespace && pcontextNS && pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /* First, set up a HDS Config (oNsStoreCFG) for accessing the NamespaceStore
    */
    ChkDR(_HdsInitNsContext(pHDS, &oNsStoreCFG, NULL, pHDS->oSRN.nNsStoreRootBlockNum,
        NsStoreNumofChildren, 0, 0));

    /* Second, alloc buffer and setup _SlotContext (pNsStoreSlotCtx) to store the given
    ** namespace in NamespaceStore
    */
    cbNsStoreSlotCtx = CALC_MAXSLOTCONTEXTLEN;
    ChkDR(_Hds_malloc(pHDS, cbNsStoreSlotCtx, (DRM_VOID**)&pNsStoreSlotCtx));
    ChkDR(_HdsInitSlotContext(&oNsStoreCFG, (DRM_BYTE *)pNsStoreSlotCtx, cbNsStoreSlotCtx));

    /* Third, check the namespace cache to try to avoid hitting the HDS
    */
    ChkDR( _HdsLookupNSCacheEntry( pHDS, pNamespace, &pNsEntry ) );

    if( pNsEntry == NULL )
    {
        /* Fourth, prepare the namespace key and search it in NamespaceStore
        */
        _GenNamespaceKeys (&pHDS->contextMD5,
               (DRM_CHAR *) pNamespace->rgbOpaqueData,
                            SIZEOF( DRM_DST_KEY ),
                            oNsHashKey.rgb,
                            oNsUniqueKey.rgb);
        dr = _HdsOpenSlot(&oNsStoreCFG, &oNsHashKey, &oNsUniqueKey, FALSE, eDRM_DST_OPEN_EXISTING, FALSE,
            &cbNsSlotSize, pNsStoreSlotCtx);
        if ( DRM_SUCCEEDED(dr) )
        {
            ChkDR( _HdsReadNsEntryFromDisk( pHDS, pNsStoreSlotCtx, cbNsSlotSize, &pNsDiskEntry ) );

            ChkDR(_HdsCloseSlot(pNsStoreSlotCtx));

            pNsEntry = pNsDiskEntry;

            /* Now we should cache the entry if there's room.
            */
            ChkDR( _HdsAddNSCacheEntry( pHDS, pNsEntry ) );
        }
        else if ( dr == DRM_E_DSTSLOTNOTFOUND )
        {
            ChkDR(DRM_E_DSTNAMESPACENOTFOUND);
        }
        else
        {
            ChkDR(dr);
        }
    }

    pNsCFG = (_NsContext *)pcontextNS;
    ChkDR(_HdsInitNsContext(pHDS, pNsCFG, pNamespace, pNsEntry->nNSRBlockNum, pNsEntry->wMaxNumChildren, pNsEntry->wBloomBytesM, pNsEntry->wBloomK));

#ifdef _CHKHDS_
        printf("\n\t[Namespace Info]\n");
        printf("\t[# of Children blocks]\t\t%d\n", pNsEntry->wMaxNumChildren);
        printf("\t[Namespace Root block#]\t\t%d\n", pNsEntry->nNSRBlockNum);
        printf("\t[Bloom filter size in bytes (m)]\t\t%d\n", pNsEntry->wBloomBytesM);
        printf("\t[Bloom filter coefficient (k)]\t\t%d\n", pNsEntry->wBloomK);
        printf("\t[Generic block header size]\t%d\n", pHDS->nImagesize_FileBlockHDR);
        printf("\t[CHILD block header size]\t%d\n", pNsCFG->nImagesize_ChildBlockHDR);
        printf("\t[CHILD alloctable size]\t\t%d\n", pNsCFG->nImagesize_ChildAllocTable);
        printf("\t[CHILD block payload size]\t%d\n", pNsCFG->nImagesize_ChildBlockPayload);
        printf("\t[CHILD block payload pos]\t%d\n", pNsCFG->nChildBlockPayloadPos);
#endif

ErrorExit:
    if ( pNsDiskEntry )
    {
        _Hds_free(pHDS, pNsDiskEntry);
    }
    if ( pNsStoreSlotCtx )
    {
        _Hds_free(pHDS, pNsStoreSlotCtx);
    }
    return dr;
}


static DRM_NO_INLINE DRM_RESULT _HdsFormatExpandedSpace(
    IN  _HdsContext *f_pHDS,
    IN  DRM_DWORD    f_nBeginBlockNum,
    IN  DRM_DWORD    f_nNumBlocks)
{
    DRM_RESULT     dr     = DRM_SUCCESS;
    _CommBlockHDR *pBlock = NULL;
    DRM_DWORD      i;

    ChkArg( f_pHDS != NULL
        && f_nNumBlocks > 0 );

    ChkDR(_Hds_malloc(f_pHDS, GetMemsize_DataBlock(), (DRM_VOID**)&pBlock));

    /* format the expanded space in blocks, start from last block */
    for (i = (f_nBeginBlockNum + f_nNumBlocks - 1); i >= f_nBeginBlockNum; i--)
    {
        DRM_DWORD      dwFilePos  = 0;
        _DataBlockHDR *pDataBlock = (_DataBlockHDR*)pBlock;

        /* initialize the tmp block */
        pBlock->nBlockNum = i;
        pBlock->File._image.nParentBlockNum = 0;
        pBlock->File._image.ui64TimeStamp   = _GetTimeStamp(f_pHDS->pOEMContext);

        PUT_BYTE( &pBlock->File._image.bBlockType, 0, eFREEBLOCK );

        pDataBlock->nPayloadSize = f_pHDS->nImagesize_DataBlockPayload;
        pDataBlock->File._image.nCascadingBlockNum = f_pHDS->oSRN.nFreeListHead;

        /* chain the block to SRN's freelist */
        f_pHDS->oSRN.nFreeListHead = pBlock->nBlockNum;
        if ( f_pHDS->oSRN.nHighestFormattedBlockNum < pBlock->nBlockNum )
        {
            f_pHDS->oSRN.nHighestFormattedBlockNum = pBlock->nBlockNum;
        }

        ChkDR(_HdsGenBlockHash(f_pHDS, NULL, pBlock, pBlock->File._image.bBlockHash));

        /* update block to file */
        ChkDR(_HdsBlockNum2FilePos(f_pHDS, i, &dwFilePos));
        if ( Oem_File_SetFilePointer(f_pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL)
          && _WriteCommonBlockHeader(f_pHDS, pBlock, f_pHDS->nImagesize_FileBlockHDR, NULL)
          && _WriteDataBlockHeader(f_pHDS, pDataBlock) )
        {
            /* commit changes of root node to file */
            ChkDR(_HdsUpdateSRN(f_pHDS));
        }
        else
        {
            ChkDR(DRM_E_FILEWRITEERROR);
        }
    }


ErrorExit:

    _Hds_free(f_pHDS, pBlock);
    return dr;
}

/* number of blocks to format in the expanded/raw store space.
** this number must be >= 1
*/
#define NUMBLOCKSTOFORMAT  1

static DRM_NO_INLINE DRM_RESULT _HdsPreAlloc(
    IN  _HdsContext *f_pHDS,
    IN  DRM_DWORD    f_PreAllocFileSizeInKB,
    IN  DRM_BOOL     f_fUpToSpecifiedSize,
    OUT DRM_DWORD   *f_pnNextBlockNum)
{
    DRM_RESULT     dr   = DRM_SUCCESS;
    DRM_DWORD      dwFileSize = 0;
    DRM_DWORD      nNumBlocks    = 0;
    DRM_DWORD      nNextBlockNum = 0;
    DRM_DWORD      nLastBlockNum = 0;

    /* calc # of blocks to be appended at end of file, then append them */
    if (!Oem_File_GetSize(f_pHDS->fp, &dwFileSize))
    {
        ChkDR(DRM_E_FILEREADERROR);
    }

    /* get the block number of the last block */
    ChkDR(_HdsFilePos2BlockNum(f_pHDS, dwFileSize, &nLastBlockNum));
    --nLastBlockNum;

    /* check if we need to expand the file */
    if ( f_pHDS->oSRN.nHighestFormattedBlockNum > 0
      && f_pHDS->oSRN.nHighestFormattedBlockNum < nLastBlockNum )
    {
        /* unformated store space exist, format the next NUMBLOCKSTOFORMAT blocks  */
        nNextBlockNum = f_pHDS->oSRN.nHighestFormattedBlockNum + 1;
        nNumBlocks = nLastBlockNum - f_pHDS->oSRN.nHighestFormattedBlockNum;
    }
    else
    {
        /* expand the store */

        /* make sure the prealloc size is bigger than the current file size */
        if ( f_fUpToSpecifiedSize )
        {
            ChkArg( dwFileSize < (f_PreAllocFileSizeInKB * 1024) );
        }

        nNumBlocks = (f_PreAllocFileSizeInKB * 1024) / f_pHDS->oSRN.dwBlockSize;

        /* make sure # of blocks to prealloc is not zero */
        if (nNumBlocks == 0)
        {
            nNumBlocks = 1;
        }

        /* expand the file by n blocks */
        ChkDR(_HdsExpandStore(f_pHDS, nNumBlocks, &nNextBlockNum));

    }

    /* format NUMBLOCKSTOFORMAT blocks */
    if ( nNumBlocks > NUMBLOCKSTOFORMAT )
    {
        nNumBlocks = NUMBLOCKSTOFORMAT;
    }

    /* format at most NUMBLOCKSTOFORMAT blocks in the raw space  */
    ChkDR(_HdsFormatExpandedSpace(f_pHDS, nNextBlockNum, nNumBlocks));

    /* flush SRN in context */
    ChkDR( _HdsLoadSRN(f_pHDS) );

    if ( f_pnNextBlockNum != NULL )
    {
        *f_pnNextBlockNum = nNextBlockNum;
    }
ErrorExit:

    return dr;
}


/**********************************************************************
** Function:    _HdsLockRestOfBlock2DeleteSlot
** Synopsis:    lock block payload from the given slot to end of block.
**              It is essentially the same as _HdsLockSlot where we are
**              grabbing a lock on a bigger slot.
** Arguments:   [pSlotCtx] --
**              [fExclusive] --
** Returns:     DRM_SUCCESS on success
** Notes:       To remove a slot from a block, it is necessary to lock
**              the slot to end of block (to do adjustments).
***********************************************************************
*/
static DRM_RESULT _HdsLockRestOfBlock2DeleteSlot(
    _SlotContext *pSlotCtx,
    DRM_DWORD     eMode)
{
#if DRM_SUPPORT_MULTI_THREADING

    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  dwFilePos    = 0;
    DRM_LONG   dwLockSize   = 0;
    DRM_DWORD  nBytesToSkip = 0;

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pSlotCtx->pNS->pHDS, pSlotCtx->pCurrChildBlock->nBlockNum, &dwFilePos));

    /* skip current slot */
    if ( ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        nBytesToSkip = SIZEOF(_SlotHeader) + SIZEOF(DRM_DWORD);
    }
    else
    {
        nBytesToSkip = SIZEOF(_SlotHeader) + pSlotCtx->oSlotHeader.dwSlotSize;
    }

    /* adjust filepos relative to the block */
    dwLockSize = dwFilePos + pSlotCtx->pNS->pHDS->oSRN.dwBlockSize;
    dwFilePos += (pSlotCtx->pNS->nChildBlockPayloadPos + pSlotCtx->dwSlotPosInBlock + nBytesToSkip);
    dwLockSize -= dwFilePos;

#ifdef _TRACELOCK
    TRACE(("_HdsLockRestOfBlock2DeleteSlot issued:  %c%c - pos %d,  size %d\n",
          (eMode & eDRM_DST_LOCKEXCLUSIVE)? 'X' : 'S',
          (eMode & eDRM_DST_LOCKWAIT)? 'W' : ' ',
          dwFilePos,
          dwLockSize));
#endif

    /* lock it */
    if ( !Oem_File_Lock(pSlotCtx->pNS->pHDS->fp,
                       ((eMode & eDRM_DST_LOCKEXCLUSIVE) != 0),
                       dwFilePos,
                       dwLockSize,
                       ((eMode & eDRM_DST_LOCKWAIT) != 0) ) )
    {
        ChkDR(DRM_E_DSTLOCKFAILED);
    }
#ifdef _TRACELOCK
    TRACE(("_HdsLockRestOfBlock2DeleteSlot obtained\n"));
#endif

ErrorExit:
    return dr;

#else   /* !DRM_SUPPORT_MULTI_THREADING */

    return DRM_SUCCESS;

#endif
}


static DRM_NO_INLINE DRM_RESULT _HdsUnlockRestOfBlock2DeleteSlot(
    _SlotContext *pSlotCtx)
{
#if DRM_SUPPORT_MULTI_THREADING

    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  dwFilePos    = 0;
    DRM_LONG   dwLockSize   = 0;
    DRM_DWORD  nBytesToSkip = 0;
    DRM_BOOL   fResult = FALSE;

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pSlotCtx->pNS->pHDS, pSlotCtx->pCurrChildBlock->nBlockNum, &dwFilePos));

    /* skip current slot */
    if ( ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        nBytesToSkip = SIZEOF(_SlotHeader) + SIZEOF(DRM_DWORD);
    }
    else
    {
        nBytesToSkip = SIZEOF(_SlotHeader) + pSlotCtx->oSlotHeader.dwSlotSize;
    }

    /* adjust filepos relative to the block */
    dwLockSize = dwFilePos + pSlotCtx->pNS->pHDS->oSRN.dwBlockSize;
    dwFilePos += (pSlotCtx->pNS->nChildBlockPayloadPos+pSlotCtx->dwSlotPosInBlock + nBytesToSkip);
    dwLockSize -= dwFilePos;

#ifdef _TRACELOCK
    TRACE(("_HdsUnlockRestOfBlock2DeleteSlot issued:  - pos %d,  size %d\n", dwFilePos,
        dwLockSize));
#endif

    /* unlock it, do not return even if this fail */
    fResult = Oem_File_Unlock(pSlotCtx->pNS->pHDS->fp, dwFilePos, dwLockSize);

    if ( !fResult )
    {
        dr = DRM_E_DSTLOCKFAILED;
    }

ErrorExit:
    return dr;

#else   /* !DRM_SUPPORT_MULTI_THREADING */

    return DRM_SUCCESS;

#endif
}




/**********************************************************************
** Function:    _HdsSlotEnumDeleteCurrent
** Synopsis:
** Arguments:   [pEnumContext] -- Enum Context init'd by DRM_HDS_InitSlotEnum()
**              [pSlotContext] -- Slot Context of the current slot
** Returns:     DRM_SUCCESS on success
** Notes:
***********************************************************************
*/
static DRM_NO_INLINE DRM_RESULT _HdsSlotEnumDeleteCurrent(
    IN  _EnumContext *pEnum,
    OUT _SlotContext *pSlotCtx)
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_BOOL         fRestOfBlockLocked = FALSE;
    _CommBlockHDR   *pTmpBlock = NULL;

    DRMASSERT(pEnum && pEnum->pNS);
    ChkArg(ISVALIDCONTEXT(pEnum, eEnumContextSignature));
    ChkArg(ISVALIDCONTEXT(pEnum->pNS, eCfgContextSignature));
    DRMASSERT(pEnum->pNS->fInited && pEnum->pNS->pHDS && pSlotCtx
        && pEnum->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /*
    ** Verify validity of the current block of the slot context
    */
    {
        _CommBlockHDR *pBlock = &pEnum->oFileBlock;
        _CommBlockHDR *pCurrBlock = &pEnum->oCurrBlock;

        /* check if query started yet */
        if ( ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos == MAXSLOTPOS )
        {
            /* query has not been started, cannot proceed */
            ChkDR(DRM_E_DSTSLOTNOTFOUND);
        }

        /* load generic block header */
        ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum, &pBlock, GPBH_GENERIC_ONLY, GPBH_OPERATION_READ));

        /* verify the generic header */
        if ( !DRM_UI64Eql(pEnum->oFileBlock.File._image.ui64TimeStamp, pCurrBlock->File._image.ui64TimeStamp)
          || MEMCMP(pEnum->oFileBlock.File._image.bBlockHash, pCurrBlock->File._image.bBlockHash, SIZEOF(pCurrBlock->File._image.bBlockHash))!=0 )
        {
            /* the current block has been updated/written since last read */
            _SlotHeader slotHeader;

            /* check if it is still a CHILD block or belong to the same parent */
            if ( GET_BYTE( &pEnum->oFileBlock.File._image.bBlockType, 0 ) != GET_BYTE( &pCurrBlock->File._image.bBlockType, 0 )
              || pEnum->oFileBlock.File._image.nParentBlockNum            != pCurrBlock->File._image.nParentBlockNum )
            {
                /* there is nothing we can do when the current block is totally invalid
                */
                ChkDR(DRM_E_DSTSLOTNOTFOUND);
            }

            /* load the child block in a tmp buffer */
            ChkDR(_HdsAllocBlockBuffer(pEnum->pNS, eCHILDBLOCK, &pTmpBlock));
            ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum,
                &pTmpBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));

            /* load the current slot header from file */
            ChkDR(_HdsGetPutBlockPayload(pTmpBlock, ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos,
                SIZEOF(_SlotHeader), &slotHeader, GPBP_OPERATION_READ));
            FIX_ENDIAN_DWORD( slotHeader.dwAttributes );
            FIX_ENDIAN_DWORD( slotHeader.dwSlotSize );
            if (MEMCMP(&slotHeader, &pEnum->oSlotHeader, SIZEOF(_SlotHeader))==0 )
            {
                /* the current slot is intact, update the block buffer and continue */
                DRM_DWORD _dwCurrPos = ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos;
                DRM_DWORD _dwNextPos = ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos;

                ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum, &pCurrBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));
                ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos = _dwCurrPos;
                ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos = _dwNextPos;
                goto Verified_Okay;
            }

            ChkDR(DRM_E_DSTSLOTNOTFOUND);
        }
    }

Verified_Okay:

    /* we have exclusive lock of the slot already. Let's lock the rest of the block */
    if ( DRM_SUCCEEDED(_HdsLockRestOfBlock2DeleteSlot(pSlotCtx, eDRM_DST_LOCKEXCLUSIVE)) )
    {
        fRestOfBlockLocked = TRUE;
        ChkDR( _HdsRemoveSlot(pSlotCtx, eRemoveSlotPermanent) );
    }

ErrorExit:

    if ( fRestOfBlockLocked )
    {
        _HdsUnlockRestOfBlock2DeleteSlot(pSlotCtx);
    }

    if ( pTmpBlock )
    {
        _Hds_free(pEnum->pNS->pHDS, pTmpBlock);
    }

    if ( DRM_SUCCEEDED(dr) )
    {
        _HdsUnlockSlot(pSlotCtx);
        _HdsCloseSlot(pSlotCtx);
    }
    return dr;
}


static DRM_NO_INLINE DRM_RESULT _HdsBlockScanInit(
    IN        _NsContext      *f_pContextNS,
    IN const DRM_DST_KEY       f_rgKeyHash [],
    IN const DRM_DWORD         f_cKeysHash,
    IN const DRM_DST_KEY      *f_pkeyUnique,
    IN const DRM_DST_LOCKMODE  f_lockmode,
    OUT _BlockScanContext     *f_pcontextBlockScan)
{
    DRM_RESULT dr = DRM_SUCCESS;

    /* init Enum context */

    ZEROMEM(f_pcontextBlockScan, SIZEOF(_BlockScanContext));
    f_pcontextBlockScan->cbContext         = SIZEOF(_BlockScanContext);
    f_pcontextBlockScan->pcontextNS        = f_pContextNS;
    f_pcontextBlockScan->fInited           = TRUE;
    f_pcontextBlockScan->eContextSignature = eEnumContextSignature;
    f_pcontextBlockScan->fCurrBlockIsValid = FALSE;
    f_pcontextBlockScan->lockmode          = f_lockmode;
    f_pcontextBlockScan->pkeyHash          = f_rgKeyHash;
    f_pcontextBlockScan->cKeysHash         = f_cKeysHash;
    f_pcontextBlockScan->iKeyCurrent       = 0;

    /* locate and prepare pEnum->oCurrBlock, if possible, for EnumNext() */

    ChkDR(_HdsInitBlockBuffer(f_pcontextBlockScan->pcontextNS,
                              (_CommBlockHDR*)&f_pcontextBlockScan->blockheaderCurrent,
                              0,
                              eCHILDBLOCK));

    /* save the hash key in the blockscan context */

    MEMCPY(f_pcontextBlockScan->keyUnique.rgb, f_pkeyUnique->rgb, SIZEOF( DRM_DST_KEY ));

ErrorExit:
    return dr;
}

static DRM_NO_INLINE DRM_BOOL _IsMatchingKey(
    IN       DRM_DST_KEY *f_pkey,
    IN const DRM_DST_KEY  f_rgkeys [],
    IN       DRM_DWORD    f_cKeys,
    IN       DRM_DWORD    f_iHint)
{
    DRM_BOOL  fMatch = FALSE;
    DRM_DWORD iKey   = 0;

    if (f_iHint >= f_cKeys)
    {
        f_iHint = 0;
    }

    for (iKey = f_iHint; iKey < f_cKeys; iKey++)
    {
        if (MEMCMP(f_pkey, f_rgkeys + iKey, SIZEOF(DRM_DST_KEY)) == 0)
        {
            fMatch = TRUE;
            goto MatchFound;
        }
    }

    if (f_iHint > 0)
    {
        for (iKey = 0; iKey < f_iHint; iKey++)
        {
            if (MEMCMP(f_pkey, f_rgkeys + iKey, SIZEOF(DRM_DST_KEY)) == 0)
            {
                fMatch = TRUE;
                break;
            }
        }
    }

MatchFound:
    return fMatch;
}

#define COA_BLOCK_NOT_SET 0xFFFFFFFF

static DRM_NO_INLINE DRM_RESULT _CoalesceBlock(_CommBlockHDR   *f_pblockheader,
                                 _SlotContext    *f_pcontextSlotLock,
                                 DRM_DST_KEY     *f_pkeyUnique,
                                 DRM_DST_LOCKMODE f_lockmode,
                                 DRM_BOOL        *f_fLocked)
{
    DRM_RESULT      dr                   = DRM_SUCCESS;
    DRM_BOOL        fFound               = TRUE;
    DRM_BOOL        fMove                = FALSE;
    DRM_DWORD       ibSource             = COA_BLOCK_NOT_SET;
    DRM_DWORD       ibNext               = COA_BLOCK_NOT_SET;
    DRM_DWORD       ibDest               = COA_BLOCK_NOT_SET;
    _SlotContext   *pcontextSlot         = NULL;
    const DRM_DWORD cbSlotContext        = CALC_SLOTCONTEXTLEN(f_pblockheader->pNS);

    ChkOverflowSLOTCONTEXTLEN( f_pblockheader->pNS );

    /* allocate temporary slotcontext */

    ChkDR(_Hds_malloc(f_pblockheader->pNS->pHDS,
                      cbSlotContext,
       (DRM_VOID **) &pcontextSlot));

    ((_ChildBlockHDR *) f_pblockheader)->nNextSlotPos = 0;

   *f_fLocked = FALSE;

    while (fFound)
    {
        ChkDR(_HdsInitSlotContext(f_pblockheader->pNS,
                     (DRM_BYTE *) pcontextSlot,
                                  cbSlotContext));

        /* get the next hidden block for this HASHKEY */

        ChkDR(_HdsSearchSlotInBlock(f_pblockheader,
                                    NULL,
                                    f_pkeyUnique,
                                    eSearchHiddenOnly,
                                    pcontextSlot,
                                   &fFound));

        if (fFound)
        {
            fMove = TRUE;

            /* if this is the first of >= 1 adjacent blocks, cache the offset of the beginning  */

            if (ibDest == COA_BLOCK_NOT_SET)
            {
                ibDest = pcontextSlot->dwSlotPosInBlock;

                /* save the first slot to be affected by the move */

                MEMCPY(f_pcontextSlotLock, pcontextSlot, cbSlotContext);
                /* Set the pointers within the copied context that refer back to the source context,
                   since we will be freeing the source context at the end of this function */
                f_pcontextSlotLock->pCurrChildBlock = (_CommBlockHDR *)f_pcontextSlotLock->bBuff;
                f_pcontextSlotLock->pCurrDataBlock  = (_CommBlockHDR *) (f_pcontextSlotLock->bBuff + __CB_DECL(GetMemsize_ChildBlock(f_pblockheader->pNS)));


                ChkDR(_HdsLockBlock2DeleteSlot(f_pcontextSlotLock, f_lockmode));

               *f_fLocked = TRUE;
            }

            /* if this isn't contiguous with the last hidden block then close that previous hole
            ** and continue from where we are
            */

            else if (pcontextSlot->dwSlotPosInBlock != ibNext)
            {
                DRM_DWORD cbMove = pcontextSlot->dwSlotPosInBlock - ibNext;

                ChkDR(_HdsAdjustChildPayload(pcontextSlot->pCurrChildBlock,
                                             ibDest,
                                             ibSource,
                                             cbMove));

                /* the new destination is the end of the blocks just moved */

                ibDest += cbMove;
            }

            /* remove _DataBlockHDR's, if necessary */

            if (ISOVERSIZESLOT(pcontextSlot->oSlotHeader.dwSlotSize,
                               pcontextSlot->pNS))
            {
                DRM_DWORD nBlockData = pcontextSlot->dwFirstDataBlockNum;

                ibSource = pcontextSlot->dwSlotPosInBlock
                         + SIZEOF(_SlotHeader)
                         + SIZEOF(DRM_DWORD);

                while (nBlockData > 0)
                {
                    ChkDR(_HdsLoadBlockHDR(pcontextSlot->pNS,
                                           nBlockData,
                                          &pcontextSlot->pCurrDataBlock));

                    nBlockData = ((_DataBlockHDR *)(pcontextSlot->pCurrDataBlock))->File._image.nCascadingBlockNum;

                    ChkDR(_HdsFreeBlock(pcontextSlot->pCurrDataBlock));
                }
            }
            else
            {
                ibSource = pcontextSlot->dwSlotPosInBlock
                         + pcontextSlot->oSlotHeader.dwSlotSize
                         + SIZEOF(_SlotHeader);
            }

            ibNext = ibSource;
        } /* endif found a hidden slot */
    }

    /* if we have an unprocessed move do it now */

    if (fMove)
    {
        /* move up the remaining space and update the free space */

        ChkDR(_HdsAdjustChildPayload(f_pblockheader,
                                     ibDest,
                                     ibSource,
                                     ADJUST_PAYLOAD_TO_END));

        /* remove slot in _ChildBlockHDR */

        ChkDR(_HdsWriteBlockHDR     (f_pblockheader));
    }

ErrorExit:

    if (pcontextSlot != NULL)
    {
        _Hds_free(f_pblockheader->pNS->pHDS, pcontextSlot);
    }

    return dr;
}


/* Lock Order:
** - Slot: to lock a slot SHARED/EXCLUSIVE among other processes
** - CS:  to guard exclusive access to file handle and local stack allocator
**        among other threads
** - SRN: to lock the SRN SHARED/EXCLUSIVE among other processes
*/


#if DRM_SUPPORT_MULTI_THREADING

/* Required because some of the DEFINE_LOCK_VARS variables aren't always used. */
#if defined (_MSC_VER)
#pragma warning(disable:4189) /* local variable is initialized but not referenced */
#endif

    #define DEFINE_LOCK_VARS \
        DRM_BOOL fStoreLocked=FALSE;\
        DRM_BOOL fSRNLocked=FALSE;\
        DRM_BOOL fCSEntered=FALSE;

    #define ENTER_HDS_CS(p)  {\
        Oem_CritSec_Enter(&((p)->oCS));\
        fCSEntered = TRUE;\
    }

    #define LEAVE_HDS_CS(p)  {\
        if ( fCSEntered )\
        {\
            Oem_CritSec_Leave(&((p)->oCS));\
            fCSEntered = FALSE;\
        }\
    }

    #define LOCK_SRN( hds, mode )\
        ChkDR(_HdsLockSRN((hds), (mode)))\
        fSRNLocked = TRUE;

    #define UNLOCK_SRN(hds)  {\
        if (fSRNLocked)\
        {\
            _HdsUnlockSRN((hds));\
            fSRNLocked = FALSE;\
        }\
    }

    #define ENTER_CS_AND_LOCK_SRN(hds, mode)\
        ENTER_HDS_CS((hds));\
        LOCK_SRN( (hds), (mode) );

    #define UNLOCK_SRN_AND_LEAVE_CS(hds)\
        UNLOCK_SRN((hds));\
        LEAVE_HDS_CS((hds));

    #define LOCK_STORE(hds, mode)\
        ChkDR( _HdsLockStore( (hds), (mode) ) );\
        fStoreLocked = TRUE;

    #define UNLOCK_STORE(hds) {\
        if ( fStoreLocked )\
        {\
            _HdsUnlockStore((hds));\
            fStoreLocked = FALSE;\
        }\
    }

#else

    #define DEFINE_LOCK_VARS
    #define ENTER_HDS_CS(p)
    #define LEAVE_HDS_CS(p)
    #define LOCK_SRN( hds, mode )
    #define UNLOCK_SRN(hds)
    #define ENTER_CS_AND_LOCK_SRN(hds, mode)
    #define UNLOCK_SRN_AND_LEAVE_CS(hds)
    #define LOCK_STORE(hds, mode)
    #define UNLOCK_STORE(hds)

#endif




/******************************************************************************
** File Flushing scheme:
*******************************************************************************
** For performance, the following file flushing scheme is applied:
** If _DATASTORE_WRITE_THRU is #define'd, all write operation will be flushed to
** disk immediately. If not, only when expanding file or creating new namespace
** will cause flush. Caller is responsible to call DRM_HDS_CommitStore or
** DRM_HDS_CommitNamespace to flush the store at higher level.
*******************************************************************************
*/



/******************************************************************************
** Store locking scheme:
*******************************************************************************
** Function             Access       CS   Lock (temp)      Lock (Persistent)
*******************************************************************************
** Init                 n/a          n/a  n/a              n/a
** Uninit               n/a          n/a  n/a              n/a
** Commit store         n/a           Y   n/a              n/a
** Cleanup store        file          Y   SRN Exclusive    n/a
** Checkpoint           SRN           N   SRN Exclusive    n/a
** Create store         file          Y   file Exclusive   n/a
** Open store           SRN           Y   SRN Shared       n/a
** Close store          n/a           Y   n/a              n/a
** Commit Namespace     n/a          n/a  n/a              n/a
** Create Namespace     SRN,BLOCKS    Y   SRN Exclusive    n/a
** Open Namespace       SRN,BLOCKS    Y   SRN Shared       n/a
** Close Namespace      n/a          n/a  n/a              n/a
** Delete Namespace     SRN,BLOCKS    Y   Store Exclusive  n/a
** Create Slot          SRN,BLOCKS    Y   SRN Exclusive    Slot Shared/Exclusive
** Open Slot            SRN,BLOCKS    Y   SRN Shared       Slot Shared/Exclusive
** Close Slot           n/a          n/a  n/a              n/a
** Seek Slot            n/a          n/a  n/a              Slot Shared/Exclusive
** Read Slot            n/a          n/a  n/a              Slot Shared/Exclusive
** Write Slot           n/a          n/a  n/a              Slot Shared/Exclusive
** Resize Slot          SRN,BLOCKS    Y   SRN Exclusive    Slot Shared/Exclusive
** Delete Slot          SRN,BLOCKS    Y   SRN Exclusive
** Init enum Slot       SRN,BLOCKS    Y   SRN Shared       Slot Shared/Exclusive
** Enum next Slot       SRN,BLOCKS    Y   SRN Shared       Slot Shared/Exclusive
**
** Note:
** -  Store level locks (SHARED and EXCLUSIVE) are issued at this file
**    only.
** -  Block level locks (SHARED and EXCLUSIVE) are issued at hds_impl.c
**    as needed
*******************************************************************************
*/



/**********************************************************************
** API functions
***********************************************************************
*/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_Init(
    __inout DRM_DST_CONTEXT *f_pContextDST )
{
    DRM_RESULT   dr=DRM_SUCCESS;
    _HdsContext *pHDS=(_HdsContext*)f_pContextDST;

    ChkArg(f_pContextDST != NULL);

    ZEROMEM(pHDS, SIZEOF(_HdsContext));
    pHDS->fp = OEM_INVALID_HANDLE_VALUE;

#if DRM_SUPPORT_MULTI_THREADING
    Oem_CritSec_Initialize(&pHDS->oCS);
    pHDS->fCSInited = TRUE;
#endif

ErrorExit:
    return dr;
}



DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_Uninit(
    __inout DRM_DST_CONTEXT *f_pContextDST )
{
    DRM_RESULT   dr=DRM_SUCCESS;

#if DRM_SUPPORT_MULTI_THREADING
    _HdsContext *pHDS=(_HdsContext*)f_pContextDST;

    ChkArg(pHDS != NULL);

    if( pHDS->fCSInited )
    {
        /* delete ciritical section */
        Oem_CritSec_Delete(&pHDS->oCS);
        pHDS->fCSInited = FALSE;
    }
#else
    ChkArg(f_pContextDST != NULL);
#endif

ErrorExit:
    return dr;
}




DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_CommitStore(
    __inout DRM_DST_CONTEXT *f_pContextDST )
{
    DRM_RESULT dr = DRM_SUCCESS;

    /*
    ** Note:
    ** if _DATASTORE_WRITE_THRU is defined, file buffers are already flushed.
    ** There is no need to flush again.
    */


    _HdsContext *pHDS=(_HdsContext*)f_pContextDST;
#if !_DATASTORE_WRITE_THRU
    DEFINE_LOCK_VARS
#endif

    ChkArg(ISVALIDCONTEXT(pHDS, eHdsContextSignature));
    DRMASSERT(f_pContextDST != NULL
          &&  pHDS->fInited
          &&  pHDS->fp != OEM_INVALID_HANDLE_VALUE);

#if !_DATASTORE_WRITE_THRU
    /* enter CS to get exclusive access to file handle */
    ENTER_HDS_CS(pHDS);

    if (!Oem_File_FlushBuffers(pHDS->fp))
    {
        dr = DRM_E_FILEWRITEERROR;
    }
#endif

ErrorExit:
#if !_DATASTORE_WRITE_THRU
    if( pHDS != NULL )
    {
        LEAVE_HDS_CS(pHDS);
    }
#endif

    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_CleanupStore(
    __inout DRM_DST_CONTEXT *f_pContextDST,
    __in    DRM_BOOL         f_fWait )
{
    DRM_RESULT   dr=DRM_SUCCESS;
    _HdsContext *pHDS = (_HdsContext*)f_pContextDST;
    DEFINE_LOCK_VARS

    ChkArg(ISVALIDCONTEXT(pHDS, eHdsContextSignature));
    DRMASSERT(f_pContextDST
           && pHDS->fInited
           && pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /*
    ** First, lock the store for EXCLUSIVE. So if there are any slots locked,
    ** this call will fail, or wait until all locks are released
    */
    LOCK_STORE( pHDS, eDRM_DST_LOCKEXCLUSIVE | (f_fWait ? eDRM_DST_LOCKWAIT : 0) );
    ENTER_CS_AND_LOCK_SRN(pHDS, eDRM_DST_LOCKEXCLUSIVE | (f_fWait ? eDRM_DST_LOCKWAIT : 0) );

    dr = _HdsCleanupStore(pHDS);
    if ( DRM_SUCCEEDED(dr) )
    {
        if (!Oem_File_FlushBuffers(pHDS->fp))
        {
            dr = DRM_E_FILEWRITEERROR;
        }
    }

ErrorExit:
    UNLOCK_SRN_AND_LEAVE_CS(pHDS);
    UNLOCK_STORE(pHDS);
    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_CreateStore(
    __in_opt                           DRM_VOID          *f_pvOEMContext,
    __in_bcount( f_cbStoreData ) const DRM_BYTE          *f_pbStoreData,
    __in                               DRM_DWORD          f_cbStoreData,
    __in                         const DRM_DWORD          f_dwBlockSize,/* block size is limited up to 64K */
    __in                               DRM_DST_BLKNUMTYPE f_eBlNumType,
    __in                               DRM_BOOL           f_fTruncateExist,
    __in                         const DRM_DWORD          f_dwInitSizeInKB,
    __out                              DRM_DST_CONTEXT   *f_pContextDST )
{
    DRM_RESULT       dr            = DRM_SUCCESS;
    DRM_DWORD        nMinBlockSize = 0;
    _CommBlockHDR   *tmpBlock      = NULL;
    _ChildBlockHDR  *tmpChild      = NULL;
    _HdsContext     *pHDS          = NULL;
    DRM_DWORD        i             = 0;
    DRM_DWORD        dwAttributes  = OEM_ATTRIBUTE_NORMAL;
    const DRM_WCHAR *wszHdsName    = ( const DRM_WCHAR * )f_pbStoreData;
    DRM_DWORD        cbLen         = 0;
    DRM_DWORD        dwFileSize    = 0;
    DRM_DWORD        dwCreationDisposition = 0;
    DEFINE_LOCK_VARS

    /* Lock order:
    **   - CS
    **   - Whole Store
    */

    ChkArg(f_pbStoreData != NULL
           && f_cbStoreData > 0
           && f_dwBlockSize != 0
           && f_pContextDST != NULL);

    DRMASSERT(f_eBlNumType == eDRM_DSTBLKNUM_WORD
           || f_eBlNumType == eDRM_DSTBLKNUM_DWORD);

// Xbox LIVE specific: disabling conversion warning (C4242) after review.
//
    #pragma warning( disable:4242 )
    cbLen = DRMCRT_wcslen( wszHdsName );
    #pragma warning( default:4242 )
//
// End Xbox LIVE specific
//

    /* check store name
    ** Note: we expect the filename is NULL terminated.
    */
    for (i=0; i < cbLen ; i++)
    {
        if (f_pbStoreData[i] == g_wchNull)   /* empty filename is not allowed */
        {
            DRMASSERT(FALSE);
        }
        if (wszHdsName[i] != g_wchSpace)
        {
            break;
        }
    }

    /* verify required min block size:
    ** SIZEOF generic header + SIZEOF child header + 1 Alloc table elem + 1 slotheader + SIZEOF datablock#
    */
    nMinBlockSize = SIZEOF(tmpBlock->File.bFileImage)        /* minimum _CommBlockHDR size */
                  + SIZEOF(tmpChild->File.bFileImage)        /* minimum _ChildBlockHDR size */
                  + (DRM_WORD)f_eBlNumType                    /* 1 element in alloctable */
                  + SIZEOF(_SlotHeader)                      /* 1 _SlotHeader */
                  + SIZEOF(DRM_DWORD);                       /* Block num of _DataBlockHDR */
    if (f_dwBlockSize < nMinBlockSize)
    {
        TRACE(("Block size too small. Minimum size is %d.\n", nMinBlockSize));
        ChkDR(DRM_E_BUFFERTOOSMALL);    /* DRM_E_HDSBLOCKTOOSMALL */
    }

    {
        /* The few fields of RootNode is const, we cannot assign values
        ** to them. Instead, we init values to a tmp and use memcpy to
        ** the structure.
        ** Note: the reason for const of the first 4 fields is to prevent
        ** accidental alteration of the values in the program. If so, the
        ** compiler will catch it.
        */
        _SRN tmpSRN;

        ZEROMEM(&tmpSRN, SIZEOF (tmpSRN));

        tmpSRN.dwSRNSize     = SIZEOF(_SRN);
        tmpSRN.dwBlockSize   = f_dwBlockSize;
        tmpSRN.eBlockNumType = f_eBlNumType;

        pHDS=(_HdsContext*)f_pContextDST;

        MEMCPY(&pHDS->oSRN, &tmpSRN, SIZEOF(_SRN));
        ZEROMEM(pHDS->oSRN.bSRNHash, SIZEOF( pHDS->oSRN.bSRNHash ) );

        /* The following logic ensures:
        ** - if the store file exists, it is opened, locked exclusive and
        **   truncated (if requested)
        ** - if the store file does not exist, it is created and locked exclusive.
        ** - All of the above are thread safe.
        */

#if _DATASTORE_WRITE_THRU
        dwAttributes |= OEM_FILE_FLAG_WRITE_THROUGH;
#endif

        pHDS->pOEMContext = f_pvOEMContext;

        if ( f_fTruncateExist )
        {
            dwCreationDisposition = OEM_TRUNCATE_EXISTING;
        }
        else
        {
            dwCreationDisposition = OEM_OPEN_EXISTING;
        }

        /* try Open the exist store */
        pHDS->fp = Oem_File_Open(f_pvOEMContext, wszHdsName, OEM_GENERIC_READ|OEM_GENERIC_WRITE,
            OEM_FILE_SHARE_READ|OEM_FILE_SHARE_WRITE, dwCreationDisposition, dwAttributes);

        if( pHDS->fp != OEM_INVALID_HANDLE_VALUE )
        {
            ChkBOOL( Oem_File_GetSize(pHDS->fp, &dwFileSize), DRM_E_FILEREADERROR );
        }

        if (pHDS->fp == OEM_INVALID_HANDLE_VALUE)
        {
            /* store does not exist */
            pHDS->fp = Oem_File_Open(f_pvOEMContext, wszHdsName, OEM_GENERIC_READ|OEM_GENERIC_WRITE,
                OEM_FILE_SHARE_READ|OEM_FILE_SHARE_WRITE, OEM_CREATE_NEW, dwAttributes);
            if (pHDS->fp == OEM_INVALID_HANDLE_VALUE)
            {
                ChkDR(DRM_E_FILEWRITEERROR);
            }

            /* get EXCLUSIVE lock, do not wait */
            LOCK_STORE( pHDS, eDRM_DST_LOCKEXCLUSIVE );
            ENTER_CS_AND_LOCK_SRN( pHDS, eDRM_DST_LOCKEXCLUSIVE );
        }
        else
        {
            ChkBOOL( Oem_File_GetSize(pHDS->fp, &dwFileSize), DRM_E_FILEREADERROR );

            if( dwFileSize > 0 && !f_fTruncateExist )
            {
                ChkDR( DRM_E_DSTEXISTS );
            }

            /* get EXCLUSIVE lock, do not wait */
            LOCK_STORE( pHDS, eDRM_DST_LOCKEXCLUSIVE );
            ENTER_CS_AND_LOCK_SRN( pHDS, eDRM_DST_LOCKEXCLUSIVE );

            /* truncate exist file */
            if (!Oem_File_SetFilePointer(pHDS->fp, 0, OEM_FILE_BEGIN, NULL))
            {
                ChkDR(DRM_E_FILESEEKERROR);
            }
            Oem_File_SetEndOfFile(pHDS->fp);
        }

        pHDS->dwContextSize = HDS_CONTEXT_LENGTH(SIZEOF(_SRN));
        pHDS->eContextSignature = eHdsContextSignature;
        pHDS->dwStoreVersion = DRM_HDS_FILE_VERSION_2;
        pHDS->fInited = TRUE;

        /* init internal stack info */
        ChkOverflow( pHDS->dwContextSize, pHDS->dwContextSize - SIZEOF(_HdsContext) );
        ChkDR( DRM_STK_Init( &pHDS->oHeap,
                   (DRM_BYTE*)pHDS + SIZEOF(_HdsContext),
                              pHDS->dwContextSize - SIZEOF(_HdsContext) ) );

        ChkDR(_HdsUpdateSRN(pHDS));
        if ( !Oem_File_FlushBuffers(pHDS->fp) )
        {
            dr = DRM_E_FILEWRITEERROR;
        }

        // prealloc file size
        if ( f_dwInitSizeInKB > 0 )
        {
            /* ignore the error. */
            (void)_HdsPreAlloc( pHDS, f_dwInitSizeInKB, TRUE, NULL);
        }
    }

ErrorExit:

    UNLOCK_SRN_AND_LEAVE_CS( pHDS );
    UNLOCK_STORE( pHDS );

    if ( pHDS != NULL )
    {
        if (pHDS->fp != OEM_INVALID_HANDLE_VALUE)
        {
            Oem_File_Close(pHDS->fp);
        }

        /* we don't need it now, clear it */
        _ZeroHDSContextIgnoringCritSec(pHDS);
    }

    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_OpenStore(
    __in_opt                     DRM_VOID        *f_pvOEMContext,
    __in_bcount( f_cbStoreData ) DRM_BYTE        *f_pbStoreData,
    __in                         DRM_DWORD        f_cbStoreData,
    __in                         DRM_DWORD        f_dwGrowBySizeinKB,
    __out                        DRM_DST_CONTEXT *f_pContextDST )
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    _HdsContext     *pHDS         = (_HdsContext *)f_pContextDST;
    _CommBlockHDR   *tmpBlock     = NULL;
    _DataBlockHDR   *dataBlock    = NULL;
    OEM_FILEHDL      fp           = OEM_INVALID_HANDLE_VALUE;
    DRM_DWORD        dwAttributes = OEM_ATTRIBUTE_NORMAL;
    const DRM_WCHAR *wszHdsName   = ( const DRM_WCHAR * )f_pbStoreData;
    DRM_DWORD        dwFileSize   = 0;
    DEFINE_LOCK_VARS

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDS, PERF_FUNC_DRM_HDS_OpenStore2);

    ChkArg( f_pbStoreData != NULL );
    ChkArg( f_pContextDST != NULL );

    pHDS->pOEMContext = f_pvOEMContext;

#if _DATASTORE_WRITE_THRU
    dwAttributes |= OEM_FILE_FLAG_WRITE_THROUGH;
#endif

    /* initialize context */
#ifdef _CHKHDS_
    /* chkhds utility opens the store in read only mode */
    fp = Oem_File_Open(f_pvOEMContext, wszHdsName, OEM_GENERIC_READ,OEM_FILE_SHARE_READ,
        OEM_OPEN_EXISTING, dwAttributes);
#else
    fp = Oem_File_Open(f_pvOEMContext, wszHdsName, OEM_GENERIC_READ|OEM_GENERIC_WRITE,
        OEM_FILE_SHARE_READ|OEM_FILE_SHARE_WRITE, OEM_OPEN_EXISTING, dwAttributes);
#endif
    if ( OEM_INVALID_HANDLE_VALUE==fp )
    {
        pHDS->fp = OEM_INVALID_HANDLE_VALUE;
        ChkDR(DRM_E_FILENOTFOUND);
    }

    ChkBOOL( Oem_File_GetSize(fp, &dwFileSize), DRM_E_FILEREADERROR );
    if( dwFileSize == 0 )
    {
        /* Treat a zero-size file as if it wasn't there, it must be re-created */
        ChkDR( DRM_E_FILENOTFOUND );
    }

    _ZeroHDSContextIgnoringCritSec(pHDS);

    pHDS->fp                = fp;
    pHDS->dwContextSize     = HDS_CONTEXT_LENGTH(SIZEOF(_SRN));
    pHDS->fInited           = TRUE;
    pHDS->nGrowbySizeinKB   = f_dwGrowBySizeinKB;
    pHDS->eContextSignature = eHdsContextSignature;

    /* Lock SRN SHARED among other processes */
    ENTER_CS_AND_LOCK_SRN(pHDS, (eDRM_DST_LOCKSHARED | eDRM_DST_LOCKWAIT));

    /* init internal stack info */
    ChkOverflow( pHDS->dwContextSize, pHDS->dwContextSize - SIZEOF(_HdsContext) );
    ChkDR( DRM_STK_Init( &pHDS->oHeap,
               (DRM_BYTE*)pHDS + SIZEOF(_HdsContext),
                          pHDS->dwContextSize - SIZEOF(_HdsContext) ) );

    ChkDR(_HdsLoadSRN(pHDS));

    /* compute handy info */
    pHDS->nImagesize_FileBlockHDR = SIZEOF(tmpBlock->File._image.ui64TimeStamp)
                                  + SIZEOF(tmpBlock->File._image.bBlockHash)
                                  + SIZEOF(tmpBlock->File._image.nParentBlockNum)
                                  + 1; /* SIZEOF(tmpBlock->File._image.bBlockType) */;
    pHDS->nImagesize_DataBlockHDR = SIZEOF(dataBlock->File._image.nCascadingBlockNum);
    pHDS->nDataBlockPayloadPos    = pHDS->nImagesize_FileBlockHDR
                                  + pHDS->nImagesize_DataBlockHDR;
    if( pHDS->oSRN.dwBlockSize <= pHDS->nDataBlockPayloadPos )
    {
        /* Not enough room in each block for any data */
        ChkDR(DRM_E_HDSINVALIDSTORE);
    }

    pHDS->nImagesize_DataBlockPayload = pHDS->oSRN.dwBlockSize - pHDS->nDataBlockPayloadPos;

ErrorExit:

    UNLOCK_SRN_AND_LEAVE_CS(pHDS);

    if (DRM_FAILED(dr))
    {
        if ( pHDS != NULL )
        {
            _ZeroHDSContextIgnoringCritSec(pHDS);
        }
        if ( fp != OEM_INVALID_HANDLE_VALUE)
        {
            Oem_File_Close( fp );
        }
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/*
**
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_CloseStore(
    __inout DRM_DST_CONTEXT *f_pContextDST )
{
    DRM_RESULT   dr = DRM_SUCCESS;
    _HdsContext *pHDS=(_HdsContext*)f_pContextDST;
    DEFINE_LOCK_VARS

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDS, PERF_FUNC_DRM_HDS_CloseStore);

    ChkArg(pHDS && ISVALIDCONTEXT(pHDS, eHdsContextSignature));
    DRMASSERT(f_pContextDST && pHDS->fInited);


    /* Lock Order:
    ** - CS:  to guard exclusive access to file handle
    */
    ENTER_HDS_CS(pHDS);

    if ( pHDS->fp != OEM_INVALID_HANDLE_VALUE )
    {
        Oem_File_Close( pHDS->fp );
        pHDS->fp = OEM_INVALID_HANDLE_VALUE;
    }

    _ZeroHDSContextIgnoringCritSec(pHDS);

ErrorExit:

    if( pHDS != NULL )
    {
        LEAVE_HDS_CS(pHDS);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}



/*
**
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_CommitNamespace(
    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS )
{
    DRM_RESULT  dr = DRM_SUCCESS;
    _NsContext *pUserNsCFG = (_NsContext *)f_pContextNS;

    ChkArg( f_pContextNS != NULL
        &&  ISVALIDCONTEXT(pUserNsCFG, eCfgContextSignature));

    /* we do not need to do any locking, DRM_HDS_CommitStore will do it
    */
    ChkDR(DRM_HDS_CommitStore( (DRM_DST_CONTEXT *)(pUserNsCFG->pHDS) ));

ErrorExit:

    return dr;
}




/******************************************************************************
**
** Function :   DRM_HDS_OpenNamespace
**
** Synopsis :   Opens/creates a namespace
**
** Arguments :  f_pContextDST - HDS context
**              f_pNamespace  - Namespace identifier to be opened/created
**              f_eOpenMode   - eDRM_DST_CREATE_NEW / eDRM_DST_OPEN_EXISTING
**              f_wMaxNumChildren - Number of children if a new namespace is to
**                                  be created
**              f_dwExpectedSlotSize - Expected size in bytes of slots in this namespace.
**                                     Used for the Bloom filter optimization. Best guess
**                                     is adequate.
**              f_pContextNS  - Namespace context
**
** Returns :    DRM_E_DSTNAMESPACENOTFOUND - if namespace is not found and
**                  request is only to open existing existing namespace
**
** Notes :
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_OpenNamespace(
    __inout                            DRM_DST_CONTEXT           *f_pContextDST,
    __in    const                      DRM_DST_NAMESPACE         *f_pNamespace,
    __in                               DRM_DST_OPENMODE           f_eOpenMode,
    __in                               DRM_WORD                   f_wMaxNumChildren,
    __in                               DRM_DWORD                  f_dwExpectedSlotSize,
    __out                              DRM_DST_NAMESPACE_CONTEXT *f_pContextNS )
{
    DRM_RESULT   dr     = DRM_E_DSTNAMESPACENOTFOUND;
    _HdsContext *pHDS   = (_HdsContext*)f_pContextDST;
    DEFINE_LOCK_VARS

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDS, PERF_FUNC_DRM_HDS_OpenNamespace);

    DRMASSERT( ( f_eOpenMode & eDRM_DST_CREATE_NEW ) != 0
            || ( f_eOpenMode & eDRM_DST_OPEN_EXISTING ) != 0
            || ( f_eOpenMode & eDRM_DST_OPEN_ALWAYS   ) != 0 );
    DRMASSERT( f_pContextDST != NULL );

    /* Lock SRN EXCLUSIVE */
    ENTER_CS_AND_LOCK_SRN(pHDS, (f_eOpenMode | eDRM_DST_LOCKEXCLUSIVE));

    dr = DRM_E_DSTNAMESPACENOTFOUND;
    if ( (pHDS->oSRN.nNsStoreRootBlockNum > 0) )
    {
        /* open existing */
        dr = _HdsOpenExistingNamespace(pHDS, f_pNamespace, f_pContextNS);
        if ( DRM_SUCCEEDED(dr) )
        {
            goto ErrorExit;
        }
    }

    /* namespace not found and caller ask to create new */
    if ( dr == DRM_E_DSTNAMESPACENOTFOUND
		 && (    (f_eOpenMode & eDRM_DST_CREATE_NEW) != 0
		      || (f_eOpenMode & eDRM_DST_OPEN_ALWAYS)   != 0 ) )
    {
        ChkDR( _HdsCreateNamespace(
                    pHDS,
                    f_pNamespace,
                    f_wMaxNumChildren,
                    f_dwExpectedSlotSize,
                    (f_eOpenMode & eDRM_DST_LOCKWAIT)!=0 ) );

        dr = _HdsOpenExistingNamespace(pHDS, f_pNamespace, f_pContextNS);
    }

ErrorExit:

    UNLOCK_SRN_AND_LEAVE_CS(pHDS);

    if( dr == DRM_E_DSTNAMESPACENOTFOUND )
    {
        TRACE(("_HdsOpenExistingNamespace(): namespace '%s' does not exist.\n", f_pNamespace->rgbOpaqueData));
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/*
**
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_CloseNamespace(
    IN DRM_DST_NAMESPACE_CONTEXT *f_pContextNS)
{
    DRM_RESULT    dr              = DRM_SUCCESS;
    _NsContext   *pUserNsCFG      = (_NsContext *)f_pContextNS;
#if DBG
    _HdsContext  *pHDS            = NULL;
    _SlotContext *pNsStoreSlotCtx = NULL;
#endif
    DEFINE_LOCK_VARS


    ChkArg(f_pContextNS != NULL
        && ISVALIDCONTEXT(pUserNsCFG, eCfgContextSignature));

    DRMASSERT(pUserNsCFG->fInited
           && pUserNsCFG->pHDS
           && pUserNsCFG->pHDS->fp != OEM_INVALID_HANDLE_VALUE );

#if DBG
{
    /* let's check if the namespace is valid
    ** this may be redandunt so just do it in DBG build
    */

    DRM_DST_KEY   oNsHashKey;
    DRM_DST_KEY   oNsUniqueKey;
    DRM_BOOL      fResult=FALSE;
    DRM_DWORD     cbNsStoreSlotCtx=0;
    _NsContext    oNsStoreCFG;

    pHDS = pUserNsCFG->pHDS;

    /* lock SRN SHARED among other processes */
    ENTER_CS_AND_LOCK_SRN(pHDS, (eDRM_DST_LOCKSHARED | eDRM_DST_LOCKWAIT));

    /* First, set up a NS context for accessing the NamespaceStore */
    ChkDR(_HdsInitNsContext(pUserNsCFG->pHDS, &oNsStoreCFG, NULL,
        pUserNsCFG->pHDS->oSRN.nNsStoreRootBlockNum, NsStoreNumofChildren, 0, 0));

    /* Second, alloc buffer and setup _SlotContext (pNsStoreSlotCtx) to store
    ** the given namespace in NamespaceStore
    */
    ChkOverflowSLOTCONTEXTLEN(&oNsStoreCFG);
    cbNsStoreSlotCtx = CALC_SLOTCONTEXTLEN(&oNsStoreCFG);  /* size of slot context */
    ChkDR(_Hds_malloc(pUserNsCFG->pHDS, cbNsStoreSlotCtx, (DRM_VOID**)&pNsStoreSlotCtx));
    ChkDR(_HdsInitSlotContext(&oNsStoreCFG, (DRM_BYTE *)pNsStoreSlotCtx,
        cbNsStoreSlotCtx));

    /* Last, search if the namespace is still exist in file */
    _GenNamespaceKeys(&pUserNsCFG->pHDS->contextMD5, (DRM_CHAR *)pUserNsCFG->oNamespace,
        DRM_HDS_NSNAME_SIZE, oNsHashKey.rgb, oNsUniqueKey.rgb);
    ChkDR(_HdsSearchSlotInFile(&oNsStoreCFG, &oNsHashKey, &oNsUniqueKey, eSearchNamespace,
        NULL, pNsStoreSlotCtx, &fResult));
    if ( !fResult )
    {
        TRACE(("DRM_HDS_CloseNamespace(): namespace '%s' does not exist.\n", pUserNsCFG->oNamespace));
        ChkDR(DRM_E_DSTNAMESPACENOTFOUND);
    }
}
#endif /* DBG */

    /* wipe the context */
    ZEROMEM(f_pContextNS, SIZEOF(_NsContext));

ErrorExit:

#if DBG
    if ( DRM_FAILED( dr ) && dr != DRM_E_INVALIDARG )
    {
        DRMASSERT( FALSE );

        dr = DRM_SUCCESS;
    }

    if ( pNsStoreSlotCtx )
    {
        _Hds_free(pHDS, pNsStoreSlotCtx);
    }

    UNLOCK_SRN_AND_LEAVE_CS(pHDS);
#endif

    return dr;
}

/*
**  This function is not being used anywhere. It was included for completeness
**  of the HDS API. It will be updated if needed.
**
**  IMPORTANT
**  NOTE: If this function ever needs to be used, the namespace cache should be
**        disabled on concurrent context systems. If a namespace is deleted in one
**        context, the entry will still be in the cache of the other context. This
**        shouldn't be a major issue because you're going to error out even without
**        the cache if you try to access a deleted namespace. But it needs to be
**        considered.
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_DeleteNamespace(
    __inout    DRM_DST_CONTEXT   *f_pContextDST,
    __inout    DRM_DST_NAMESPACE *f_pNS,
    __in       DRM_BOOL           f_fWait )
{
    DRM_RESULT         dr               = DRM_SUCCESS;
    DRM_DST_KEY        oNsHashKey       = {0};
    DRM_DST_KEY        oNsUniqueKey     = {0};
    DRM_BOOL           fResult          = FALSE;
    _HdsContext       *pHDS             = (_HdsContext*)f_pContextDST;
    _NsContext         oNsStoreCFG      = {0};
    _SlotContext      *pNsStoreSlotCtx  = NULL;
    DRM_DWORD          cbNsStoreSlotCtx = 0;
    DRM_DWORD          cbNsSlotSize     = 0;
    _NsContext        *pcontextNS       = NULL;
    _NSEntry          *pNsEntry         = NULL;
    DEFINE_LOCK_VARS

    ChkArg(f_pContextDST != NULL
        && f_pNS         != NULL
        && ISVALIDCONTEXT(pHDS, eHdsContextSignature));

    DRMASSERT(pHDS->fInited
          &&  pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /*
    ** Lock STORE EXCLUSIVE among other processes. So if there are any
    ** locked slots, this call will fail, or wait until all locks are released
    */
    LOCK_STORE( pHDS,  eDRM_DST_LOCKEXCLUSIVE | (f_fWait ? eDRM_DST_LOCKWAIT : 0) );
    ENTER_CS_AND_LOCK_SRN(pHDS, eDRM_DST_LOCKEXCLUSIVE | (f_fWait ? eDRM_DST_LOCKWAIT : 0) );

    /*  First, set up a HDS Config (oNsStoreCFG) for accessing the NamespaceStore
    */
    ChkDR(_HdsInitNsContext(pHDS, &oNsStoreCFG, NULL, pHDS->oSRN.nNsStoreRootBlockNum,
        NsStoreNumofChildren, 0, 0));

    /* Second, alloc buffer and setup _SlotContext (pNsStoreSlotCtx) to store the given
    ** namespace in NamespaceStore
    */
    ChkOverflowSLOTCONTEXTLEN(&oNsStoreCFG);
    cbNsStoreSlotCtx = CALC_SLOTCONTEXTLEN(&oNsStoreCFG);  /* size of slot context */
    ChkDR(_Hds_malloc(pHDS, cbNsStoreSlotCtx, (DRM_VOID**)&pNsStoreSlotCtx));
    ChkDR(_HdsInitSlotContext(&oNsStoreCFG, (DRM_BYTE *)pNsStoreSlotCtx, cbNsStoreSlotCtx));

    /* Third, delete the namespace from our cache
    */
    ChkDR( _HdsDeleteNSCacheEntry( pHDS, f_pNS ) );

    /* Fourth, prepare the namespace key and search it in NamespaceStore
    */
    _GenNamespaceKeys (&pHDS->contextMD5,
           (DRM_CHAR *) f_pNS->rgbOpaqueData,
                        DRM_HDS_NSNAME_SIZE,
                        oNsHashKey.rgb,
                        oNsUniqueKey.rgb);
    ChkDR(_HdsSearchSlotInFile(&oNsStoreCFG, &oNsHashKey, &oNsUniqueKey, eSearchNamespace,
        &cbNsSlotSize, pNsStoreSlotCtx, &fResult));
    if ( !fResult )
    {
        TRACE(("DRM_HDS_DeleteNamespace(): namespace '%s' does not exist.\n", f_pNS->rgbOpaqueData));
        ChkDR(DRM_E_DSTNAMESPACENOTFOUND);
    }
    else
    {
        DRM_DST_KEY   oHashKey;
        DRM_DST_KEY oUniqueKey;

        ChkDR( _HdsReadNsEntryFromDisk( pHDS, pNsStoreSlotCtx, cbNsSlotSize, &pNsEntry ) );

        /* setup cfg context for the namespace */
        ChkDR(_Hds_malloc(pHDS, SIZEOF(_NsContext), (DRM_VOID**)&pcontextNS));
        ChkDR(_HdsInitNsContext(pHDS, pcontextNS, f_pNS, pNsEntry->nNSRBlockNum,
            pNsEntry->wMaxNumChildren, pNsEntry->wBloomBytesM, pNsEntry->wBloomK));

        /* delete the namespace's subtree */
        ChkDR(_HdsDeleteSubTree(pcontextNS, pNsEntry->nNSRBlockNum));

        /* delete the Config's slot in NamespaceStore */
        /*ChkDR(_HdsCloseSlot(pNsStoreSlotCtx)); */

        MEMCPY(oHashKey.rgb,   oNsHashKey.rgb,   DRM_HDS_HASHKEY_SIZE);
        MEMCPY(oUniqueKey.rgb, oNsUniqueKey.rgb, DRM_HDS_UNIQUEKEY_SIZE);

        ChkDR( _HdsRemoveSlot(pNsStoreSlotCtx, eRemoveSlotPermanent ) );
    }

ErrorExit:
    if ( pcontextNS )
    {
        _Hds_free(pHDS, pcontextNS);
    }
    if ( pNsEntry )
    {
        _Hds_free(pHDS, pNsEntry);
    }
    if ( pNsStoreSlotCtx )
    {
        _Hds_free(pHDS, pNsStoreSlotCtx);
    }

    UNLOCK_SRN_AND_LEAVE_CS(pHDS);
    UNLOCK_STORE(pHDS);
    return dr;
}

/*
**
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_DeleteSlot(
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS, /* Namespace context returned from DRM_HDS_OpenNamespace */
    __in const DRM_DST_KEY               *f_pHashKey,
    __in const DRM_DST_KEY               *f_pUniqueKey,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __in       DRM_BOOL                   f_fWait )
{
    DRM_RESULT         dr                                          = DRM_SUCCESS;
    _NsContext        *pNS                                         = (_NsContext*)f_pContextNS;
    _SlotContext      *pSlotCtx                                    = NULL;
    DRM_BOOL           fValid                                      = FALSE;
    DRM_BOOL           fBlockLocked                                = FALSE;
    DRM_DWORD          cbSlotSize                                  = 0;
    DRM_BYTE           rgbBuff [__CB_DECL(CALC_MAXSLOTCONTEXTLEN)] = {0};
    DEFINE_LOCK_VARS

    ChkArg(f_pContextNS != NULL
        && ISVALIDCONTEXT(pNS, eCfgContextSignature));

    DRMASSERT(pNS->fInited
          &&  f_pHashKey    != NULL
          &&  f_pUniqueKey  != NULL
          &&  pNS->pHDS     != NULL
          &&  pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE);

    /* initialize slot context structure */

    pSlotCtx = (_SlotContext *) rgbBuff;

    ChkOverflowSLOTCONTEXTLEN( pNS );
    ChkDR(_HdsInitSlotContext(pNS, (DRM_BYTE*)pSlotCtx, CALC_SLOTCONTEXTLEN(pNS)));

    while ( TRUE )
    {
        /* Lock SRN SHARED among other processes. */
        ENTER_CS_AND_LOCK_SRN( pNS->pHDS, eDRM_DST_LOCKSHARED | eDRM_DST_LOCKWAIT );

        if ( f_pSlotHint != NULL )
        {
            dr = _HdsOpenSlotFromHint(pNS, f_pHashKey, f_pUniqueKey, (_SlotHint*)f_pSlotHint, TRUE, &cbSlotSize, pSlotCtx);
        }

        if ( f_pSlotHint == NULL
            || DRM_FAILED ( dr ) )
        {
            ChkDR( _HdsOpenSlot(pNS, f_pHashKey, f_pUniqueKey, TRUE, eDRM_DST_OPEN_EXISTING, FALSE, &cbSlotSize, pSlotCtx) );
        }

        /*
        ** drop all the locks and CS so we can re-lock for exclusive
        */
        UNLOCK_SRN_AND_LEAVE_CS( pNS->pHDS );

        /* we got the lock to the slot, let's verify the sanity of the slot
        ** we need to enter CS and lock SRN again */
        ENTER_CS_AND_LOCK_SRN( pNS->pHDS, eDRM_DST_LOCKEXCLUSIVE | (f_fWait ? eDRM_DST_LOCKWAIT : 0) );

        ChkDR( _HdsLockBlock2DeleteSlot(
                    pSlotCtx,
                    eDRM_DST_LOCKEXCLUSIVE | (f_fWait ? eDRM_DST_LOCKWAIT : 0) ) );
        fBlockLocked = TRUE;

        ChkDR(_HdsVerifySlotContext(pSlotCtx, &fValid));

        if ( fValid )
        {
            break;
        }

        /* slot context verified failed, try again */
        (void)_HdsUnlockBlock2DeleteSlot(pSlotCtx);
        fBlockLocked = FALSE;

        /* drop all the locks and CS again */
        UNLOCK_SRN_AND_LEAVE_CS( pNS->pHDS );
    }

    /*
    **  We currently have the lock on the block as well as CS and SRN lock
    */
    ChkDR( _HdsRemoveSlot(pSlotCtx, eRemoveSlotPermanent) );

    if ( f_pSlotHint != NULL )
    {
        ZEROMEM ( f_pSlotHint, DRM_HDS_SLOT_HINT_LEN );
    }

ErrorExit:

    if ( fBlockLocked )
    {
        /* error occured during verifying slot context, return error */
        (void)_HdsUnlockBlock2DeleteSlot(pSlotCtx);
    }

    if (pNS != NULL)
    {
        UNLOCK_SRN_AND_LEAVE_CS(pNS->pHDS);
    }
    return dr;
}

/* Initialize a slot hint based on the slot context passed */
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_MakeSlotHint(
    __in    DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out   DRM_DST_SLOT_HINT     *f_pSlotHint )
{
    DRM_RESULT    dr        = DRM_SUCCESS;
    _SlotContext *pSlotCtx  = (_SlotContext*)f_pContextSlot;
    _SlotHint    *pHint     = (_SlotHint*)f_pSlotHint;

    ChkArg(ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    DRMASSERT(f_pContextSlot != NULL
          &&  f_pSlotHint    != NULL
          &&  pSlotCtx->pNS != NULL
          &&  pSlotCtx->pNS->pHDS != NULL
          &&  pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    pHint->nBlockNum = pSlotCtx->oFileBlock.nBlockNum;
    pHint->nSlotPosInBlock = pSlotCtx->dwSlotPosInBlock;

ErrorExit:
    if( DRM_FAILED( dr )
        && pHint != NULL )
    {
        ZEROMEM( pHint, SIZEOF( _SlotHint ) );
    }

    return dr;
}

/*
** Create or open dataslot using given key1 and key2
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_OpenSlot(
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,/* Namespace context returned from DRM_HDS_OpenNamespace */
    __in       DRM_DWORD                  f_dwMode,
    __in const DRM_DST_KEY               *f_pHashKey,
    __in const DRM_DST_KEY               *f_pUniqueKey,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __inout    DRM_DWORD                 *f_pcbSlotSize,/* current dataslot size */
    __out      DRM_DST_SLOT_CONTEXT      *f_pContextSlot )/* user given Dataslot context buffer */
{
    DRM_RESULT    dr=DRM_SUCCESS;
    _NsContext   *pNS=(_NsContext*)f_pContextNS;
    _SlotContext *pSlotCtx=NULL;
    DRM_BOOL      fSlotLocked = FALSE;
    DRM_BOOL      fValid      = FALSE;
    DEFINE_LOCK_VARS

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDS, PERF_FUNC_DRM_HDS_OpenSlot);

    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature)
        && f_pHashKey != NULL
        && f_pUniqueKey != NULL
        && !DRM_UTL_IsZeros(( DRM_BYTE * )f_pHashKey, DRM_HDS_HASHKEY_SIZE));
    DRMASSERT(f_pContextNS != NULL
          && f_pContextSlot != NULL
          && pNS->fInited
          && pNS->nCfgRootBlockNum > 0
          && pNS->pHDS != NULL
          && pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE
          && ((f_dwMode & eDRM_DST_CREATE_NEW) || (f_dwMode & eDRM_DST_OPEN_EXISTING) || (f_dwMode & eDRM_DST_OPEN_ALWAYS)) );

    /* check slot size */
    if ( (DRM_DWORD)(SIZEOF(_SlotHeader) + (*f_pcbSlotSize)) < (*f_pcbSlotSize) )
    {
        /* (*f_pcbSlotSize) is a negative number */
        ChkDR(DRM_E_INVALID_DSTSLOTSIZE);
    }

    /* initialize slot context structure */
    ChkDR(_HdsInitSlotContext(pNS, (DRM_BYTE*)f_pContextSlot, CALC_MAXSLOTCONTEXTLEN));
    pSlotCtx = (_SlotContext*)f_pContextSlot;

    while ( TRUE )
    {
        /* Lock SRN SHARED among other processes. */
        ENTER_CS_AND_LOCK_SRN(pNS->pHDS, (f_dwMode & (~eDRM_DST_LOCKEXCLUSIVE)));


        /* Try opening the slot with the provided hint if we were given one */
        ChkDR( DRM_SUCCESS );
        if ( f_pSlotHint != NULL )
        {
            dr = _HdsOpenSlotFromHint(pNS, f_pHashKey, f_pUniqueKey, (_SlotHint*)f_pSlotHint, TRUE, f_pcbSlotSize, pSlotCtx);

            /* slot exists but caller ask to create new only */
            if ( DRM_SUCCEEDED(dr)  &&  (f_dwMode & eDRM_DST_CREATE_NEW) != 0 )
            {
                ChkDR(DRM_E_DSTSLOTEXIST);
            }
        }

        /* If the slot hint open failed or if we weren't given a hint at all, try doing a regular open  */
        if( DRM_FAILED( dr ) || f_pSlotHint == NULL )
        {
            ChkDR( _HdsOpenSlot(pNS, f_pHashKey, f_pUniqueKey, TRUE, f_dwMode, TRUE, f_pcbSlotSize, pSlotCtx ) );
        }

        /* MUST persist dr from _HdsOpenSlot for the block below the following block */
        if ( f_pSlotHint != NULL )
        {
            DRM_HDS_MakeSlotHint(f_pContextSlot, f_pSlotHint);
        }

        /* If the slot was created, we're done */
        if (  ( ( f_dwMode & eDRM_DST_CREATE_NEW    ) != 0 ) && DRM_SUCCEEDED( dr )
           || ( ( f_dwMode & eDRM_DST_OPEN_ALWAYS   ) != 0 ) && dr == DRM_S_FALSE )
        {
            fSlotLocked = TRUE;
            break;
        }

        /* here, a slot exists and caller is asking to open existing ...
        ** drop all the locks and CS to allow concurrency to occur
        ** while waiting for the slot lock
        */
        UNLOCK_SRN_AND_LEAVE_CS(pNS->pHDS);

        /* issue specific slot lock */
        ChkDR(_HdsLockSlot(pSlotCtx, f_dwMode));
        fSlotLocked = TRUE;

        /* we got the lock to the slot, let's verify the sanity of the slot
        ** we need to enter CS and lock SRN again */
        ENTER_CS_AND_LOCK_SRN(pNS->pHDS, (f_dwMode & (~eDRM_DST_LOCKEXCLUSIVE)));

        ChkDR(_HdsVerifySlotContext(pSlotCtx, &fValid));

        /* drop all the locks and CS again */
        UNLOCK_SRN_AND_LEAVE_CS(pNS->pHDS);

        if ( fValid )
        {
            break;
        }

        /* slot context verified failed, try again */
        (void)_HdsUnlockSlot(pSlotCtx);
        fSlotLocked = FALSE;
    }

ErrorExit:
    if ( pNS != NULL  &&  pNS->pHDS != NULL )
    {
        if ( DRM_FAILED(dr)  &&  fSlotLocked )
        {
            /* error occured during verifying slot context, return error */
            _HdsUnlockSlot(pSlotCtx);
        }

        UNLOCK_SRN_AND_LEAVE_CS(pNS->pHDS);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*
**
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_CloseSlot(
    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot )
{
    DRM_RESULT    dr       = DRM_SUCCESS;
    _SlotContext *pSlotCtx = (_SlotContext*)f_pContextSlot;
    DEFINE_LOCK_VARS

    ChkArg(f_pContextSlot != NULL
        && ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));

    DRMASSERT(pSlotCtx->pNS
           && pSlotCtx->pNS->pHDS
           && pSlotCtx->pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE);

    if (pSlotCtx->eStatus == eSlotCtxUninit)
    {
        ChkDR(DRM_E_DSTSLOTNOTFOUND);
    }

    ChkDR(_HdsUnlockSlot(pSlotCtx));
    ChkDR(_HdsCloseSlot(pSlotCtx));

ErrorExit:
    return dr;
}


/*
**
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_SlotSeek(
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in      DRM_LONG               f_lOffset,
    __in      DRM_DST_SEEKMODE       f_eOrigin,
    __out_opt DRM_DWORD             *f_pdwSeekPointer )/* optional parameter, can be NULL */
{
    DRM_RESULT    dr       = DRM_SUCCESS;
    _SlotContext *pSlotCtx = (_SlotContext*)f_pContextSlot;

    ChkArg(f_pContextSlot != NULL
        && ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));

    DRMASSERT(pSlotCtx->pNS           != NULL
           && pSlotCtx->pNS->pHDS     != NULL
           && pSlotCtx->pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE);

    /* Note:
    ** - We do not need to enter CS because we do not need access to file handle
    **   and Local stack
    ** - this slot is either locked for SHARED or EXCLUSIVE. We do not need to
    **   worry if it is changed after it is opened
    */
    if (pSlotCtx->eStatus!=eSlotCtxReady)
    {
        ChkDR(DRM_E_DSTSLOTNOTFOUND);
    }
    switch ( f_eOrigin )
    {
        case eDRM_DST_SEEKCUR:
            if ( f_lOffset > 0 )
            {
                if ( (pSlotCtx->dwSeekPointer+f_lOffset) > pSlotCtx->oSlotHeader.dwSlotSize )
                {
                    ChkDR(DRM_E_DSTSEEKERROR);
                }
                pSlotCtx->dwSeekPointer += f_lOffset;
            }
            else
            {
                if ( pSlotCtx->dwSeekPointer < (DRM_UINT)DRMCRT_abs(f_lOffset) )
                {
                    ChkDR(DRM_E_DSTSEEKERROR);
                }
                pSlotCtx->dwSeekPointer -= DRMCRT_abs(f_lOffset);
            }
            break;
        case eDRM_DST_SEEKEND:
            if ( f_lOffset > 0 || (DRM_UINT)DRMCRT_abs(f_lOffset) > pSlotCtx->oSlotHeader.dwSlotSize )
            {
                ChkDR(DRM_E_DSTSEEKERROR);
            }
            pSlotCtx->dwSeekPointer = pSlotCtx->oSlotHeader.dwSlotSize - DRMCRT_abs(f_lOffset);
            break;
        case eDRM_DST_SEEKSET:
            if ( f_lOffset < 0 || f_lOffset > (DRM_LONG) pSlotCtx->oSlotHeader.dwSlotSize )
            {
                ChkDR(DRM_E_DSTSEEKERROR);
            }
            pSlotCtx->dwSeekPointer = f_lOffset;
            break;
        default:
            ChkDR(DRM_E_INVALIDARG);
    }

ErrorExit:
    if ( DRM_SUCCEEDED(dr) && f_pdwSeekPointer)
    {
        *f_pdwSeekPointer = pSlotCtx->dwSeekPointer;
    }
    return dr;
}



/*
**
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_SlotRead(
    __inout                  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                     DRM_DWORD              f_cbData,
    __out_bcount( f_cbData ) DRM_BYTE              *f_pbData,
    __out_opt                DRM_DWORD             *f_pcbRead )
{
    DRM_RESULT    dr=DRM_SUCCESS;
    DRM_BOOL      fValidHDSContext = FALSE;
    _SlotContext *pSlotCtx=(_SlotContext*)f_pContextSlot;

    DEFINE_LOCK_VARS

    if ( f_pcbRead != NULL )
    {
        *f_pcbRead = 0;
    }

    ChkArg(ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    DRMASSERT(f_pContextSlot != NULL
          &&  pSlotCtx->pNS  != NULL
          &&  pSlotCtx->pNS->pHDS != NULL
          &&  pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /* Note:
    ** - this slot is either locked for SHARED or EXCLUSIVE. We do not need to
    **   worry if it is changed after it is opened
    */

    /* Lock Order:
    ** - CS:  to guard exclusive access to file handle
    */
    ENTER_HDS_CS(pSlotCtx->pNS->pHDS);

    fValidHDSContext = ( f_pContextSlot != NULL
                     &&  pSlotCtx->pNS != NULL
                     &&  pSlotCtx->pNS->pHDS != NULL
                     &&  pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE );

    ChkDR(_HdsReadWriteSlot(pSlotCtx, f_cbData, f_pbData, f_pcbRead, TRUE));

ErrorExit:

    if( fValidHDSContext == TRUE )
    {
        LEAVE_HDS_CS(pSlotCtx->pNS->pHDS);
    }

    return dr;
}



/*
**
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_SlotWrite(
    __inout                       DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                          DRM_DWORD              f_cbData,
    __in_bcount( f_cbData ) const DRM_BYTE              *f_pbData,
    __out                         DRM_DWORD             *f_pcbWritten )
{
    DRM_RESULT    dr=DRM_SUCCESS;
    DRM_BOOL      fValidHDSContext = FALSE;
    _SlotContext *pSlotCtx=(_SlotContext*)f_pContextSlot;
    DEFINE_LOCK_VARS

    ChkArg(ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    DRMASSERT(f_pContextSlot != NULL
          &&  pSlotCtx->pNS != NULL
          &&  pSlotCtx->pNS->pHDS != NULL
          &&  pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /* Note:
    ** - this slot is locked for EXCLUSIVE. We do not need to
    **   worry if it is changed after it is opened
    */

    /* slot must be locked EXCLUSIVE */
    if ( (pSlotCtx->eLockMode & eDRM_DST_LOCKEXCLUSIVE) == 0 )
    {
        ChkDR(DRM_E_DSTNOTLOCKEDEXCLUSIVE);
    }

    /* Lock Order:
    ** - CS:  to guard exclusive access to file handle
    */
    ENTER_HDS_CS(pSlotCtx->pNS->pHDS);

    fValidHDSContext = ( f_pContextSlot != NULL
                     &&  pSlotCtx->pNS  != NULL
                     &&  pSlotCtx->pNS->pHDS != NULL
                     &&  pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE );

    /* NOTE: We cast away the const-ness here because we know _HdsReadWriteSlot
    ** is safe when the operation is Write
    */
    ChkDR(_HdsReadWriteSlot(pSlotCtx, f_cbData, (DRM_BYTE*)f_pbData, f_pcbWritten, FALSE));

    /*
    ** Note:
    ** we do not need to flush if _DATASTORE_WRITE_THRU is defined. file buffers
    ** are already flushed.
    ** if _DATASTORE_WRITE_THRU is not defined, caller should call DRM_HDS_Commit*
    ** to flush file buffer at higher level
    */

ErrorExit:

    if( fValidHDSContext == TRUE )
    {
        LEAVE_HDS_CS(pSlotCtx->pNS->pHDS);
    }

    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_SlotResize(
    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in     DRM_DWORD              f_cbSize )
{
    DRM_RESULT     dr=DRM_SUCCESS;
    _SlotContext  *pSlotCtx=(_SlotContext*)f_pContextSlot;
    DEFINE_LOCK_VARS

    ChkArg(ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    DRMASSERT(f_pContextSlot != NULL
          &&  pSlotCtx->pNS  != NULL
          &&  pSlotCtx->pNS->pHDS != NULL
          &&  pSlotCtx->pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE
          &&  f_cbSize > 0);

    /* we do not need to verify slot content since we must have either shared
    ** or exclusive lock on the slot
    */
    if (pSlotCtx->eStatus!=eSlotCtxReady)
    {
        ChkDR(DRM_E_DSTSLOTNOTFOUND);
    }

    /* Lock SRN EXCLUSIVE to prevent other process from change the file*/
    ENTER_CS_AND_LOCK_SRN(pSlotCtx->pNS->pHDS, (pSlotCtx->eLockMode | eDRM_DST_LOCKEXCLUSIVE));

    ChkDR(_HdsSlotResize(pSlotCtx, f_cbSize));

ErrorExit:
    if ( pSlotCtx!=NULL  &&  pSlotCtx->pNS!=NULL )
    {
        UNLOCK_SRN_AND_LEAVE_CS(pSlotCtx->pNS->pHDS);
    }
    return dr;
}



DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_InitSlotEnum(
    __in           DRM_DST_NAMESPACE_CONTEXT *f_pContextNS, /* Namespace context returned from DRM_HDS_OpenNamespace */
    __in_opt const DRM_DST_KEY               *f_pHashKey,
    __in           DRM_DST_LOCKMODE           f_eLockMode,
    __out          DRM_DST_ENUM_CONTEXT      *f_pContextEnum )
{
    DRM_RESULT    dr    = DRM_SUCCESS;
    _NsContext   *pNS   = (_NsContext   *) f_pContextNS;
    _EnumContext *pEnum = (_EnumContext *) f_pContextEnum;
    DEFINE_LOCK_VARS

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDS, PERF_FUNC_DRM_HDS_InitSlotEnum);

    ChkArg( f_pContextNS != NULL );
    ChkArg( f_pContextEnum != NULL );

    ChkArg( pNS->pHDS != NULL );
    ChkArg( pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE );
    ChkArg( ISVALIDCONTEXT(pNS, eCfgContextSignature) );
    ChkArg( ISVALIDCONTEXT(pNS->pHDS, eHdsContextSignature) );

    /* Lock SRN SHARED among other processes. */
    ENTER_CS_AND_LOCK_SRN(pNS->pHDS, (f_eLockMode & (~eDRM_DST_LOCKEXCLUSIVE)));

    /* _HdsInitSlotEnum prepares the enum context. It will not block so we are okay */
    ChkDR(_HdsInitSlotEnum(pNS, f_pHashKey, f_eLockMode, pEnum));

ErrorExit:

    if ( pNS != NULL )
    {
        UNLOCK_SRN_AND_LEAVE_CS(pNS->pHDS);  /* unlock SRN */
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_SlotEnumReloadCurrent(
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,       /* setup by DRM_HDS_InitSlotEnum() */
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,       /* user given Dataslot context buffer */
    __out_opt  DRM_DST_KEY           *f_pHashKey,           /* optional parameter */
    __out_opt  DRM_DST_KEY           *f_pUniqueKey,         /* optional parameter */
    __out_opt  DRM_DWORD             *f_pcbSlot )           /* current dataslot size, optional parameter */
{
    DRM_RESULT     dr         = DRM_SUCCESS;
    _EnumContext  *pEnum      = (_EnumContext *)f_pContextEnum;
    _CommBlockHDR *pCurrBlock = NULL;

    ChkArg(pEnum != NULL
       &&  pEnum->pNS != NULL
       &&  ISVALIDCONTEXT(pEnum,      eEnumContextSignature)
       &&  ISVALIDCONTEXT(pEnum->pNS, eCfgContextSignature));
    DRMASSERT(pEnum->pNS->fInited
          &&  pEnum->pNS->pHDS  != NULL
          &&  pEnum->pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE
          &&  f_pContextSlot != NULL);

    if ( !pEnum->fCurrBlockIsValid )
    {
        dr = DRM_E_NOMORE;
        goto ErrorExit;
    }
    pCurrBlock = &pEnum->oCurrBlock;

    /* use next positon as current position */
    ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos = ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos;

    dr = DRM_HDS_SlotEnumNext(f_pContextEnum, f_pContextSlot, f_pHashKey, f_pUniqueKey, f_pcbSlot);

ErrorExit:
    return dr;
}



/******************************************************************************
** Function:   DRM_HDS_SlotEnumDeleteCurrent
** Synopsis:   delete the current enumerated slot
** Arguments:  f_pContextEnum - HDS enum context
**             f_pContextSlot - HDS slot context of the current enumerated slot
** Returns:
** Notes:
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_SlotEnumDeleteCurrent(
    __inout   DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot )
{
    DRM_RESULT    dr       = DRM_SUCCESS;
    _EnumContext *pEnum    = (_EnumContext *) f_pContextEnum;
    _SlotContext *pSlotCtx = (_SlotContext *) f_pContextSlot;
    DEFINE_LOCK_VARS

    ChkArg(pEnum        != NULL
       &&  pEnum->pNS   != NULL
       &&  f_pContextSlot != NULL
       &&  ISVALIDCONTEXT(pEnum,      eEnumContextSignature)
       &&  ISVALIDCONTEXT(pEnum->pNS, eCfgContextSignature)
       &&  ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));

    DRMASSERT(pEnum->pNS->fInited
          &&  pEnum->pNS->pHDS        != NULL
          &&  pEnum->pNS->pHDS->fp    != OEM_INVALID_HANDLE_VALUE
          &&  pSlotCtx->pNS
          &&  pSlotCtx->pNS->pHDS
          &&  pSlotCtx->pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE);

    if (pSlotCtx->eStatus != eSlotCtxReady
     || !pEnum->fCurrBlockIsValid)
    {
        ChkDR(DRM_E_DSTSLOTNOTFOUND);
    }

    /* Lock SRN SHARED among other processes. */
    ENTER_CS_AND_LOCK_SRN(pEnum->pNS->pHDS, (pEnum->eLockMode & (~eDRM_DST_LOCKEXCLUSIVE)));

    dr = _HdsSlotEnumDeleteCurrent(pEnum, pSlotCtx);

ErrorExit:

    UNLOCK_SRN_AND_LEAVE_CS(pEnum->pNS->pHDS);
    return dr;
}



DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_SlotEnumNext(
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,/* setup by DRM_HDS_InitSlotEnum() */
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,/* user given Dataslot context buffer */
    __out_opt  DRM_DST_KEY           *f_pHashKey,    /* optional parameter */
    __out_opt  DRM_DST_KEY           *f_pUniqueKey,  /* optional parameter */
    __out_opt  DRM_DWORD             *f_pcbSlot )    /* current dataslot size, optional parameter */
{
    DRM_RESULT    dr = DRM_SUCCESS;
    _EnumContext *pEnum    = (_EnumContext *) f_pContextEnum;
    _SlotContext *pSlotCtx = (_SlotContext *) f_pContextSlot;
    DRM_BOOL      fValid   = FALSE;
    DRM_BOOL      fSlotLocked = FALSE;
    DEFINE_LOCK_VARS

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMHDS, PERF_FUNC_DRM_HDS_SlotEnumNext);

    ChkArg(pEnum != NULL
       &&  pEnum->pNS != NULL
       &&  ISVALIDCONTEXT(pEnum,      eEnumContextSignature)
       &&  ISVALIDCONTEXT(pEnum->pNS, eCfgContextSignature));
    DRMASSERT(pEnum->pNS->fInited
          &&  pEnum->pNS->pHDS  != NULL
          &&  pEnum->pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE
          &&  f_pContextSlot != NULL);

    if ( !pEnum->fCurrBlockIsValid )
    {
        dr = DRM_E_NOMORE;
        goto ErrorExit;
    }

    while (TRUE)
    {
        /* Lock SRN SHARED among other processes. */
        ENTER_CS_AND_LOCK_SRN(pEnum->pNS->pHDS, (pEnum->eLockMode & (~eDRM_DST_LOCKEXCLUSIVE)));

        /* locate and open the slot */
        ChkDR(_HdsSlotEnumNext(pEnum, pSlotCtx, f_pHashKey, f_pUniqueKey, f_pcbSlot));

        /* drop all the locks and CS to allow concurrency to occur
        ** while waiting for the slot lock */
        UNLOCK_SRN_AND_LEAVE_CS(pEnum->pNS->pHDS);

        /* issue specific slot lock */
        ChkDR(_HdsLockSlot(pSlotCtx, pEnum->eLockMode));
        fSlotLocked = TRUE;

        /* we got the lock to the slot, let's verify the sanity of the slot
        ** we need to enter CS and lock SRN again */
        ENTER_CS_AND_LOCK_SRN(pEnum->pNS->pHDS, (pEnum->eLockMode & (~eDRM_DST_LOCKEXCLUSIVE)));

        ChkDR(_HdsVerifySlotContext(pSlotCtx, &fValid));

        /* drop all the locks and CS again */
        UNLOCK_SRN_AND_LEAVE_CS(pEnum->pNS->pHDS);

        if ( fValid )
        {
            break;
        }

        /* slot context verified failed, try again */
        (void)_HdsUnlockSlot(pSlotCtx);
        fSlotLocked = FALSE;
    }

ErrorExit:

    if ( pEnum != NULL  && pEnum->pNS )
    {
        if ( DRM_FAILED(dr)  &&  fSlotLocked )
        {
            /* error occured during verifying slot context, return error */
            _HdsUnlockSlot(pSlotCtx);
        }
        UNLOCK_SRN_AND_LEAVE_CS(pEnum->pNS->pHDS);
    }

    if (DRM_FAILED(dr))
    {
        /* trash the slot context and return */
        ZEROMEM(pSlotCtx, pSlotCtx->dwContextSize);
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDS_BlockScanDelete(
    __inout                    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS,
    __in_ecount( f_cKeysHash ) DRM_DST_KEY                *f_rgKeyHash,
    __in                       DRM_DWORD                   f_cKeysHash,
    __in                       DRM_DST_KEY                *f_pkeyUnique,
    __in                       DRM_BOOL                    f_fWait )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _NsContext        *pcontextNS = (_NsContext *)f_pContextNS;
    _BlockScanContext  oContextBS = { 0 };
    DRM_DST_LOCKMODE   lockmode   = eDRM_DST_LOCKEXCLUSIVE;
    DRM_BOOL           fOK               = FALSE;
    DRM_BOOL           fLocked           = FALSE;
    DRM_DST_KEY       *pkeyUnique        = NULL;
    _CommBlockHDR     *pblockheaderNext  = NULL;
    _SlotContext      *pcontextSlot      = NULL;
    _SlotContext      *pcontextSlotLock  = NULL;
    DRM_DWORD          cbSlotContext     = 0;
    DEFINE_LOCK_VARS;

    ChkArg(f_pContextNS        != NULL );

    ChkArg(pcontextNS->pHDS     != NULL
       &&  pcontextNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE);

    ChkArg(f_pkeyUnique    != NULL
        && f_rgKeyHash != NULL
        && f_cKeysHash  > 0);

    ChkArg(ISVALIDCONTEXT(pcontextNS,       eCfgContextSignature)
       &&  ISVALIDCONTEXT(pcontextNS->pHDS, eHdsContextSignature));

    if (f_fWait)
    {
        lockmode = (DRM_DST_LOCKMODE)(lockmode | eDRM_DST_LOCKWAIT);
    }

    /* Lock SRN SHARED among other processes. */

    ENTER_CS_AND_LOCK_SRN(pcontextNS->pHDS, eDRM_DST_LOCKSHARED);

    ChkDR(_HdsBlockScanInit  (pcontextNS, f_rgKeyHash, f_cKeysHash, f_pkeyUnique, lockmode, &oContextBS));

    pkeyUnique = &oContextBS.keyUnique;

    ChkOverflowSLOTCONTEXTLEN(oContextBS.pcontextNS);
    cbSlotContext = CALC_SLOTCONTEXTLEN(oContextBS.pcontextNS);
    ChkDR(_Hds_malloc(oContextBS.pcontextNS->pHDS, cbSlotContext, (DRM_VOID **) &pcontextSlot));
    ChkDR(_Hds_malloc(oContextBS.pcontextNS->pHDS, cbSlotContext, (DRM_VOID **) &pcontextSlotLock));

    ChkDR(_HdsAllocBlockBuffer(oContextBS.pcontextNS, eCHILDBLOCK, &pblockheaderNext));

    while (dr != DRM_E_NOMORE)
    {
        DRM_BOOL fAnyDeletedFromBlock = FALSE;
        DRM_BOOL fFound               = TRUE;

        fLocked = FALSE;

        /* unlock the SHARED from above or the EXCLUSIVE (below) upon loop */

        UNLOCK_SRN_AND_LEAVE_CS(pcontextNS->pHDS);

        /* Lock SRN exclusively among other processes. */

        ENTER_CS_AND_LOCK_SRN(pcontextNS->pHDS, eDRM_DST_LOCKEXCLUSIVE | eDRM_DST_LOCKWAIT);

        /* open the next block and continue */

        if( oContextBS.fCurrBlockIsValid )
        {
            ChkDR( _HdsTraverseBlocksInPostOrder( oContextBS.pcontextNS,
                                       (_CommBlockHDR*)&oContextBS.blockheaderCurrent,
                                        pblockheaderNext,
                                       &fOK ) );
        }
        else
        {
            ChkDR( _HdsTraverseBlocksInPostOrder( oContextBS.pcontextNS,
                                        NULL,
                                        pblockheaderNext,
                                       &fOK ) );
            oContextBS.fCurrBlockIsValid = fOK;
        }

        if (fOK)
        {
            /* the child block becomes the current block */

            ChkDR(_HdsCopyBlockBuffer((_CommBlockHDR*)&oContextBS.blockheaderCurrent, pblockheaderNext));

            MEMCPY(&oContextBS.blockheader, &oContextBS.blockheaderCurrent, SIZEOF(_CommBlockHDR));
        }
        else
        {
            UNLOCK_SRN_AND_LEAVE_CS(oContextBS.pcontextNS->pHDS)

            /* no more blocks found */
            dr = DRM_E_NOMORE;
        }

        while (fOK && fFound)
        {
            ChkDR(_HdsInitSlotContext(oContextBS.pcontextNS,
                         (DRM_BYTE *) pcontextSlot,
                                      cbSlotContext));

            /* search current block for any matching UNIQUEs under the HASH */

            ChkDR(_HdsSearchSlotInBlock((_CommBlockHDR*)&oContextBS.blockheaderCurrent,
                                         NULL,
                                         pkeyUnique,
                                         eSearchSlotDontCare,
                                         pcontextSlot,
                                        &fFound));
            if (fFound)
            {
                if (_IsMatchingKey(&pcontextSlot->oSlotHeader.oHashkey,
                                    oContextBS.pkeyHash,
                                    oContextBS.cKeysHash,
                                    oContextBS.iKeyCurrent))
                {
                    /* mark the slot as hidden and record that we dirtied this block */

                    ChkDR(_HdsRemoveSlot(pcontextSlot,
                                         eRemoveSlotSetHidden));

                    fAnyDeletedFromBlock = TRUE;
                    oContextBS.iKeyCurrent++;
                    oContextBS.cKeysFound++;

                    /* if we've already found all the keys we can complete this loop and exit both loops */

                    if (oContextBS.cKeysFound == oContextBS.cKeysHash)
                    {
                        fFound = FALSE;
                        dr     = DRM_E_NOMORE;
                    }
                }
            }
        }

        /* if any hidden slots were found for this HASKEY then remove those slots */

        if (fAnyDeletedFromBlock)
        {
            ChkDR( _CoalesceBlock((_CommBlockHDR*)&oContextBS.blockheaderCurrent,
                                                    pcontextSlotLock,
                                                    pkeyUnique,
                                                    oContextBS.lockmode,
                                                   &fLocked) );
            if (fLocked)
            {
                ChkDR(_HdsUnlockBlock2DeleteSlot(pcontextSlotLock));
                fLocked = FALSE;
            }
        }
    } /* end block loop */

    if (dr == DRM_E_NOMORE)
    {
        dr = DRM_SUCCESS;
    }
ErrorExit:

    if (pblockheaderNext != NULL)
    {
        _Hds_free(oContextBS.pcontextNS->pHDS, pblockheaderNext);
    }

    if (pcontextSlotLock != NULL)
    {
        if (fLocked)
        {
            _HdsUnlockBlock2DeleteSlot(pcontextSlotLock);
        }

        _Hds_free(oContextBS.pcontextNS->pHDS, pcontextSlotLock);
    }

    if (pcontextSlot != NULL)
    {
        _Hds_free(oContextBS.pcontextNS->pHDS, pcontextSlot);
    }

    if (pcontextNS != NULL)
    {
        UNLOCK_SRN_AND_LEAVE_CS(pcontextNS->pHDS);  /* unlock SRN */
    }

    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmhdrparser.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmheaderparser.h>
#include <drmxmlparser.h>

ENTER_PK_NAMESPACE_CODE;

/**********************************************************************
**
** Function:    DRM_HDR_GetHeaderVersion
**
** Synopsis:    This function returns version of XML header 
**
** Arguments:
** [f_pdstrContentHeader] -- Pointer to a content header
** [f_peProperty]         -- Pointer to header type to store retrieved value
**
** Returns:     DRM_SUCCESS                  if version header was successfully detected
**              DRM_E_CH_UNSUPPORTED_VERSION if unsupported version of the header was found
**              DRM_E_CH_VERSION_MISSING     if version of header is missing
**              DRM_E_CH_INVALID_HEADER      if no WRMHEADER was found or header is too big
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDR_GetHeaderVersion( 
    IN const DRM_CONST_STRING         *f_pdstrContentHeader,
       OUT   eDRM_HEADER_VERSION      *f_peVersion)
{
    DRM_RESULT       dr = DRM_SUCCESS;    
    DRM_CONST_STRING dstrData = EMPTY_DRM_STRING;

    ChkArg( f_pdstrContentHeader != NULL );
    ChkArg( f_peVersion != NULL );

    *f_peVersion = DRM_HEADER_VERSION_UNKNOWN;

    /* Make sure that header has valid size */
    ChkBOOL( f_pdstrContentHeader->cchString * SIZEOF( DRM_WCHAR ) <= DRM_HEADER_MAX_SIZE_IN_BYTES, DRM_E_CH_INVALID_HEADER );

    /* Ensure the outter tag is WRMHEADER */
    if( DRM_FAILED( DRM_XML_GetNode( f_pdstrContentHeader, &g_dstrTagWrmHeader, NULL, NULL, 0, NULL, &dstrData ) ) )
    {
        ChkDR( DRM_E_CH_INVALID_HEADER );
    }

    /* Make sure there is a version number */
    if( DRM_FAILED( DRM_XML_GetNodeAttribute( f_pdstrContentHeader, &g_dstrAttributeVersion, &dstrData ) ) ||
        dstrData.cchString == 0 )
    {
        ChkDR( DRM_E_CH_VERSION_MISSING );
    }

    /* Let's check version number */
    if ( DRM_UTL_DSTRStringsEqual( &dstrData, &g_dstrAttributeVersion2Value ) )
    {
        *f_peVersion = DRM_HEADER_VERSION_2;
        /* Get the data section. */
        if( DRM_FAILED( DRM_XML_GetSubNode( f_pdstrContentHeader, &g_dstrTagData, NULL, NULL, 0, &dstrData, NULL, 1 ) ) )
        {
           ChkDR( DRM_E_CH_INVALID_HEADER );
        }
        if( DRM_SUCCEEDED( DRM_XML_GetSubNode( &dstrData, &g_dstrTagV4DATA, NULL, NULL, 0, &dstrData, NULL, 1 ) ) )
        {
           *f_peVersion = DRM_HEADER_VERSION_2_4;
        }
    }
    else if ( DRM_UTL_DSTRStringsEqual( &dstrData, &g_dstrAttributeVersion4Value ) )
    {
        *f_peVersion = DRM_HEADER_VERSION_4;
    }
    else 
    {
        ChkDR( DRM_E_CH_UNSUPPORTED_VERSION ); 
    }

ErrorExit:
    return dr;
}

/**********************************************************************
**
** Function:    _BasicHeaderChecks
**
** Synopsis:    This function performs basic checks of XML content header
**
** Arguments:
** [f_pdstrContentHeader] -- Pointer to a content header
**
** Returns:     DRM_SUCCESS                  if all basic checks passes successfully.
**              DRM_E_CH_INVALID_HEADER      if no WRMHEADER was found or no DATA section in the header
**              DRM_E_CH_VERSION_MISSING     if version of header is missing
**              DRM_E_CH_UNSUPPORTED_VERSION if unsupported header version is provided
**              DRM_E_CH_KID_MISSING         if KID tag is missing
**              DRM_E_CH_LAINFO_MISSING      if LAINFO tag is missing
**              DRM_E_CH_LAURL_MISSING       if LAURL tag is missing
**              DRM_E_CH_CHECKSUM_MISSING    if CHECKSUM tag is missing
**              DRM_E_LOGICERR               on any other error  
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BasicHeaderChecks( 
    IN const DRM_CONST_STRING         *f_pdstrContentHeader,
       OUT   DRM_CONST_STRING         *f_pdstrData )
{
    DRM_RESULT       dr = DRM_E_LOGICERR;    
    DRM_CONST_STRING dstrValue = EMPTY_DRM_STRING;
    DRM_CONTENT_SET_PROPERTY eHeaderType = DRM_CSP_HEADER_NOT_SET;

    ChkArg( f_pdstrContentHeader != NULL );
    ChkArg( f_pdstrData != NULL );

    /* Ensure the outer tag is WRMHEADER */
    if( DRM_FAILED( DRM_XML_GetNode( f_pdstrContentHeader, &g_dstrTagWrmHeader, NULL, NULL, 0, NULL, f_pdstrData ) ) )
    {
        ChkDR( DRM_E_CH_INVALID_HEADER );
    }

    /* Make sure there is a version number */
    if( DRM_FAILED( DRM_XML_GetNodeAttribute( f_pdstrContentHeader, &g_dstrAttributeVersion, f_pdstrData ) ) ||
        f_pdstrData->cchString == 0 )
    {
        ChkDR( DRM_E_CH_VERSION_MISSING );
    }

    /* Make sure we understand the version of the header */
    if( DRM_UTL_DSTRStringsEqual( &g_dstrAttributeVersion2Value, f_pdstrData ) )
    {
        /* Could be V2.4 but this type of validation is sufficient for basic check */
        eHeaderType = DRM_CSP_V2_HEADER;
    }
    else if ( DRM_UTL_DSTRStringsEqual( &g_dstrAttributeVersion4Value, f_pdstrData ) )
    {
        eHeaderType = DRM_CSP_V4_HEADER;
    }
    else
    {
        ChkDR( DRM_E_CH_UNSUPPORTED_VERSION );
    }

    /* Get the data section. */
    if( DRM_FAILED( DRM_XML_GetSubNode( f_pdstrContentHeader, &g_dstrTagData, NULL, NULL, 0, f_pdstrData, NULL, 1 ) ) )
    {
        ChkDR( DRM_E_CH_INVALID_HEADER );
    }

    /* Get the KID */
    if( DRM_FAILED( DRM_XML_GetSubNodeByPath( f_pdstrData, &g_dstrTagKID, NULL, NULL, NULL, &dstrValue, g_wchForwardSlash ) ) )
    {
        ChkDR( DRM_E_CH_KID_MISSING );
    }


    if ( eHeaderType == DRM_CSP_V2_HEADER )
    {
        /* Get the LAINFO */
        if( DRM_FAILED( DRM_XML_GetSubNodeByPath( f_pdstrData, &g_dstrTagLAINFO, NULL, NULL, NULL, &dstrValue, g_wchForwardSlash ) ) )
        {
            ChkDR( DRM_E_CH_LAINFO_MISSING );
        }
    }

    /* Get the Checksum */
    if( DRM_FAILED( DRM_XML_GetSubNodeByPath( f_pdstrData, &g_dstrTagChecksum, NULL, NULL, NULL, &dstrValue, g_wchForwardSlash ) ) )
    {
        ChkDR( DRM_E_CH_CHECKSUM_MISSING );
    }

    /* Enough fields were present.  Basic checks pass */
    dr = DRM_SUCCESS;
ErrorExit:
    return dr;
}


/**********************************************************************
**
** Function:    DRM_HDR_GetAttribute
**
** Synopsis:    This function retrieves attribute from XML content header
**
** Arguments:
** [pdstrContentHeader] -- Pointer to a content header
** [pdstrAttrName]      -- Attribute name
** [eAttribute]         -- alternative representation of attribute name (instead of pdstrAttrName) 
** [pdstrValue]         -- value of requested attribute
** [chXPathSeparator]   -- separator value
**
** Returns:     DRM_SUCCESS                  if attribute was retrived successfully
**              DRM_E_CH_INVALID_HEADER      if no WRMHEADER was found or no DATA section in the header
**              DRM_E_CH_VERSION_MISSING     if version of header is missing
**              DRM_E_CH_UNSUPPORTED_VERSION if unsupported header version is provided
**              DRM_E_CH_KID_MISSING         if KID tag is missing
**              DRM_E_CH_LAINFO_MISSING      if LAINFO tag is missing
**              DRM_E_CH_CHECKSUM_MISSING    if CHECKSUM tag is missing
**              DRM_E_INVALIDARG             if attribute specified incorrectly  
**              DRM_E_INVALIDXMLTAG          if XML error is detected
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_HDR_GetAttribute(
    IN const DRM_CONST_STRING       *pdstrContentHeader,
    IN const DRM_CONST_STRING       *pdstrAttrName,
    IN       eDRM_HEADER_ATTRIBUTES  eAttribute,
    OUT      DRM_CONST_STRING       *pdstrValue,
    IN       DRM_WCHAR               chXPathSeparator)
{
    DRM_RESULT               dr             = DRM_SUCCESS;    
    const DRM_CONST_STRING  *pdstrString    = NULL;
    DRM_CONST_STRING         dstrData       = EMPTY_DRM_STRING;
    eDRM_HEADER_VERSION      eHeaderVersion = DRM_HEADER_VERSION_UNKNOWN;
    
    ChkDRMString( pdstrContentHeader );
    ChkArg( pdstrValue != NULL );

    if( chXPathSeparator == 0 )
    {
        chXPathSeparator = g_wchForwardSlash;
    }

    if( (eAttribute != DRM_HEADER_ATTRIB_OTHER) && ( NULL != pdstrAttrName ) )
    {
        /* If caller wants a known attribute -- we don't allow an attribute string */
        ChkDR( DRM_E_INVALIDARG );
    }
    
    ChkDR( _BasicHeaderChecks( pdstrContentHeader, &dstrData ) );

    /* V4 header and V2.4 header keeps LA_URL, LUI_URL and DS_ID data in different XML sections */
    /* Lets check for XML tag and then for header's version */
    if ( eAttribute == DRM_HEADER_ATTRIB_LICENSE_ACQ_V4_URL 
      || eAttribute == DRM_HEADER_ATTRIB_LICENSE_UI_URL 
      || eAttribute == DRM_HEADER_ATTRIB_DOMAIN_SERVICE_ID )
    {
        ChkDR( DRM_HDR_GetHeaderVersion( pdstrContentHeader, &eHeaderVersion) );
        if (eHeaderVersion == DRM_HEADER_VERSION_2_4)
        {
            /* For V2.4 header it is necessary to get data from V4DATA section */
            ChkDR( DRM_XML_GetSubNode( &dstrData, &g_dstrTagV4DATA, NULL, NULL, 0, &dstrData, NULL, 1 ) );
        }
    }

    switch( eAttribute )
    {
    case DRM_HEADER_ATTRIB_VERSION:
        pdstrString = &g_dstrAttributeVersion;
        dr = DRM_XML_GetNodeAttribute( pdstrContentHeader, pdstrString, pdstrValue );        
        goto ErrorExit;
    case DRM_HEADER_ATTRIB_KID:
        pdstrString = &g_dstrTagKID;
        break;
    case DRM_HEADER_ATTRIB_LAINFO:
        pdstrString = &g_dstrTagLAINFO;
        break;
    case DRM_HEADER_ATTRIB_CHECKSUM:
        pdstrString = &g_dstrTagChecksum;
        break;
    case DRM_HEADER_ATTRIB_SECURITYVERSION:
        pdstrString = &g_dstrTagSecurityVersion;
        break;
    case DRM_HEADER_ATTRIB_OTHER:
        ChkArg( pdstrAttrName );
        pdstrString = pdstrAttrName;        
        break;
    case DRM_HEADER_ATTRIB_LICENSE_ACQ_V4_URL:
        pdstrString = &g_dstrTagLAURL;
        break;
    case DRM_HEADER_ATTRIB_LICENSE_UI_URL:
        pdstrString = &g_dstrTagLUIURL;
        break;
    case DRM_HEADER_ATTRIB_DOMAIN_SERVICE_ID:
        pdstrString = &g_dstrTagDSID;
        break;
    default:
        return DRM_E_INVALIDARG;
    }

    /* For V2.4 header and LA_URL, LUI_URL and DS_ID tags, dstrData points to V4DATA section of the content header */
    /* In all other cases dstrData points to DATA section of content header */
    ChkDR( DRM_XML_GetSubNodeByPath( &dstrData, pdstrString, NULL, NULL, NULL, pdstrValue, chXPathSeparator ) );
    dr = DRM_SUCCESS;

ErrorExit:
    return( dr );
}

/**********************************************************************
**
** Function:    DRM_HDR_GetUplink
**
** Synopsis:    This function returns value of DATA\UPLINKS tag (uplink KID of a specific level)
**
** Arguments:
** [pdstrContentHeader] -- Pointer to a content header
** [dwUplinkNumber]     -- Uplink KID level
** [pdstrKid]           -- requiested uplink KID 
**
** Returns:     DRM_SUCCESS             if uplink KID was retrived successfully
**              DRM_E_INVALIDARG        if input parameter specified incorrectly  
**              DRM_E_INVALIDXMLTAG     if XML error in content header is detected
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDR_GetUplink(
    IN const DRM_CONST_STRING *pdstrContentHeader,
    IN       DRM_DWORD         dwUplinkNumber,
    OUT      DRM_CONST_STRING *pdstrKid )
{
    DRM_RESULT dr = DRM_SUCCESS;    
    DRM_CONST_STRING dstrString = EMPTY_DRM_STRING;

    ChkDRMString( pdstrContentHeader );
    ChkArg( pdstrKid != NULL );

    ChkDR( DRM_XML_GetSubNodeByPath( pdstrContentHeader, &g_dstrXPathHeaderUplinks, NULL, NULL, &dstrString, NULL, g_wchForwardSlash ) );
    ChkDR( DRM_XML_GetSubNode( &dstrString, &g_dstrTagUplink, NULL, NULL, dwUplinkNumber, NULL, pdstrKid, 1) );
ErrorExit:
    return dr;
}

/**********************************************************************
**
** Function:    DRM_HDR_Verify
**
** Synopsis:    This function verifies content header
**
** Arguments:
** [pdstrContentHeader] -- Pointer to a content header
** [pdstrPubKey]        -- Public key  
** [pContext]           -- Cryptographic context
** [plResult]           -- Result of verification (0 or 1) 
**
** Returns:     DRM_SUCCESS                  if uplink KID was retrived successfully
**              DRM_E_CH_INVALID_HEADER      if no WRMHEADER was found or no DATA section in the header
**              DRM_E_CH_VERSION_MISSING     if version of header is missing
**              DRM_E_CH_UNSUPPORTED_VERSION if unsupported header version is provided
**              DRM_E_CH_KID_MISSING         if KID tag is missing
**              DRM_E_CH_LAINFO_MISSING      if LAINFO tag is missing
**              DRM_E_CH_CHECKSUM_MISSING    if CHECKSUM tag is missing
**              DRM_E_CH_UNABLE_TO_VERIFY    if signature decoding fails 
**              DRM_E_INVALIDARG             if attribute specified incorrectly  
**              DRM_E_INVALIDXMLTAG          if XML error is detected
**              DRM_E_LOGICERR               on any other error  
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDR_Verify(
    IN const DRM_CONST_STRING   *pdstrContentHeader,
    IN const DRM_CONST_STRING   *pdstrPubKey,
    IN       DRM_CRYPTO_CONTEXT *pContext,
    OUT      DRM_LONG           *plResult)
{
    DRM_RESULT          dr                   = DRM_E_LOGICERR;    
    DRM_CONST_STRING    dstrSig              = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrEncodedChecksum  = EMPTY_DRM_STRING;
    DRM_DWORD           dwDecodedChecksumLen = 0;
    DRM_CONST_STRING    dstrData             = EMPTY_DRM_STRING;    
    DRM_DWORD           dwSize               = SIZEOF( PUBKEY );    
    eDRM_HEADER_VERSION eHeaderVersion       = DRM_HEADER_VERSION_UNKNOWN;
    
    ChkDRMString( pdstrContentHeader );
    ChkArg( plResult != NULL );

    ChkDR( _BasicHeaderChecks( pdstrContentHeader, &dstrData ) );
    ChkDR( DRM_HDR_GetHeaderVersion( pdstrContentHeader, &eHeaderVersion ) );

    /* Get checksum and validate the length */
    ChkDR( DRM_XML_GetSubNode( pdstrContentHeader, &g_dstrTagData, NULL, NULL, 0, &dstrData, NULL, 1 ) );
    ChkDR( DRM_XML_GetSubNodeByPath( &dstrData, &g_dstrTagChecksum, NULL, NULL, NULL, &dstrEncodedChecksum, g_wchForwardSlash ) );
    dr = DRM_B64_DecodeW( &dstrEncodedChecksum, &dwDecodedChecksumLen, NULL, 0 );
    /* expecting DRM_E_BUFFERTOOSMALL because dwDecodedChecksumLen is 0 */ 
    ChkBOOL( dr == DRM_E_BUFFERTOOSMALL && 
             dwDecodedChecksumLen == CHECKSUM_LENGTH, DRM_E_CH_INVALID_CHECKSUM );   
    
    if ( eHeaderVersion == DRM_HEADER_VERSION_4 )
    {
        /* verification of V4 header is done - it has no signature section */
        *plResult = 1;
    }
    else 
    {       
       ChkDRMString( pdstrPubKey );
       ChkArg( pContext != NULL );
       ChkDR( DRM_B64_DecodeW( pdstrPubKey, &dwSize, (DRM_BYTE *)&(pContext->pubKey), 0 ) );    

       /* verification of V2 header - signature section */
       if( DRM_FAILED( DRM_XML_GetSubNodeByPath( pdstrContentHeader, &g_dstrXPathSigValue, NULL, NULL, NULL, &dstrSig, g_wchForwardSlash ) ) )
       {
           ChkDR( DRM_E_CH_INVALID_HEADER );
       }
 
       dwSize = DRM_ECC160_SIGNATURE_LEN;
       if( DRM_FAILED(DRM_B64_DecodeW(&dstrSig, &dwSize, pContext->signature, 0 ) ) )
       {
          ChkDR( DRM_E_CH_UNABLE_TO_VERIFY );
       }

       if ( DRM_SUCCEEDED( DRM_PK_Verify( pContext->rgbCryptoContext, 
                                          eDRM_ECC_P160,
                                          DRM_ECC160_PUBLIC_KEY_LEN,
                                          ( const DRM_BYTE * )&(pContext->pubKey), 
                                          CB_DSTR(&dstrData),
                                          PB_DSTR(&dstrData), 
                                          DRM_ECC160_SIGNATURE_LEN,
                                          pContext->signature) ) )                                           
       {
          *plResult = 1;
       }
       else
       {
          *plResult = 0;
       }
    }
    dr = DRM_SUCCESS;

ErrorExit:
    return( dr );
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmlicacqreq.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#if DRM_SUPPORT_DLA
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmlicacq.h>
#include <drmxmlbuilder.h>
#include <drmxmlparser.h>
#include <drmlicense.h>
#include <drmsha1.h>
#include <drmstrsafe.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

/*************************************************************************
** static functions
**************************************************************************/

static DRM_DWORD _NumberWidth(DRM_DWORD dwNumber)
{
    DRM_DWORD cchNumber = 1;
    
    while (dwNumber > 10)
    {
        dwNumber /= 10;
        cchNumber++;
    }
    
    return cchNumber;
}

static DRM_DWORD _RequiredCharsForCLIENTINFOBlock (DRM_DWORD  levelAppSecurity,
                                                   DRM_DWORD  idSubject,
                                                   DRM_DWORD  cchSecurityVersion,
                                                   DRM_DWORD  cchClientVersion,
                                                   DRM_DWORD  cchDevcert,
                                                   DRM_DWORD  idSubject2,
                                                   DRM_DWORD  cchDrmkversion,
                                                   DRM_DWORD  cchRevInfo)
{
    DRM_DWORD cchRequired = 0;
    
    /* <CLIENTINFO> */
    
    cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagClientInfo.cchString, 0, 0, 0);
    
    /* <CLIENTID> */
    
    cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagClientID.cchString,    
                                                 CCH_BASE64_EQUIV (SIZEOF (CLIENTID)), 0, 0);
    
    /* <CLIENTVERSION> */
    
    cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagClientVersion    .cchString, 
                                                 cchClientVersion, 0, 0);
    
    /* <SECURITYVERSION> */
    
    cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrTagSecurityVersion.cchString,      
                                                 cchSecurityVersion, 0, 0);
    
    /* <APPSECURITY> */
    
    cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagAppSecurity.cchString,      
                                   _NumberWidth (levelAppSecurity), 0, 0);
    
    /* <SUBJECTID1> */
    
    cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagSubjectID1.cchString,       
                                   _NumberWidth (idSubject), 0, 0);
    
    /* <SUBJECTID2> */

    if ( idSubject2 > 0 )
    {
        cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagSubjectID2.cchString,    
                                       _NumberWidth (idSubject2), 0, 0);
    }
    else
    {
        cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagSubjectID2.cchString,    
                                                     0, 0, 0);
    }
    
   
    /* <DRMKVERSION> */

    if ( cchDrmkversion > 0 )
    {
        cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagDrmkVersion.cchString,    
                                                     cchDrmkversion, 0, 0);
    }
    else
    {
        cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagDrmkVersion.cchString,    
                                                     0, 0, 0);
    }


    /* <DEVCERT> if it is there */


    if (cchDevcert != 0)
    {
        cchRequired += DRM_XMB_RequiredCharsForTag (g_dstrTagDevCert.cchString, 
                                                    CCH_BASE64_ENC_LARGE_WCH(cchDevcert), 0, 0);
    }


    /* <REVINFO>, always enforce even if there is no blob in HDS */
    cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagRevInfo.cchString, cchRevInfo, 0, 0);
    
    return cchRequired;
}

/******************************************************************************
 *                PRIVATE FUNCTION _RequiredCharsForRequest 
 *
 * calculate buffer requirement to build the license request
 *****************************************************************************/

static DRM_DWORD _RequiredCharsForRequest (IN DRM_LICENSE_CHALLENGE *f_plicensechallenge)
{
    DRM_DWORD cchRequired = 0;
    
    cchRequired  = DRM_XMB_RequiredCharsForTag (g_dstrTagLicenseRequest    .cchString, 
                                                0,
                                                g_dstrAttributeVersion      .cchString,
                                                g_dstrAttributeVersion2Value.cchString);
    
    cchRequired += DRM_XMB_RequiredCharsForTag (g_dstrTagV1Challenge.cchString,
                                                CCH_CDATA_REQUIRED (&f_plicensechallenge->dstrV1Challenge),
                                                0,
                                                0);
 
    if (f_plicensechallenge->cUplinks > 0)
    {        
        DRM_DWORD cchUplink  = 0;
        
        cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrTagUplinks.cchString, 0, 0, 0);

        cchUplink    = DRM_XMB_RequiredCharsForTag (g_dstrTagUplink.cchString, 
                                                    CCH_BASE64_EQUIV (SIZEOF (DRM_LICENSE_STATE_DATA)),
                                                    g_dstrTagKID.cchString, 
                                                    CCH_BASE64_EQUIV (SIZEOF (DRM_KID)));
        
        cchRequired += CCH_BASE64_ENC_LARGE_WCH(f_plicensechallenge->cUplinks * cchUplink);
    } /* end if cUplinks > 0 */

    if (f_plicensechallenge->cRights > 0)
    {
        DRM_DWORD iRight = 0;
        
        cchRequired += DRM_XMB_RequiredCharsForTag (g_dstrTagActionList.cchString, 0, 0, 0);

        for (iRight = 0; 
             iRight < f_plicensechallenge->cRights; 
             iRight++)
        {
            cchRequired += DRM_XMB_RequiredCharsForTag (g_dstrTagAction.cchString,
                                                        f_plicensechallenge->ppdstrRights [iRight]->cchString,
                                                        0,
                                                        0);
        }                                                     
    } /* end if cRights > 0 */

    if (f_plicensechallenge->dstrClientIdentity.cchString != 0)
    {
        cchRequired += f_plicensechallenge->dstrClientIdentity.cchString;
    }
    else
    {
        /*
        ** In any failure case I assume max length for the version. 
        */
        
        DRM_DWORD dwVerLen = 0;
        if ( !DRM_SUCCEEDED( DRM_STR_StringCchLengthW( f_plicensechallenge->pwszBBVer, VER_STRING_MAX_LEN, &dwVerLen ) ) )
        {
            dwVerLen = VER_STRING_MAX_LEN + 1;
        }
        
        cchRequired += _RequiredCharsForCLIENTINFOBlock (f_plicensechallenge->levelAppSecurity,
                                                         f_plicensechallenge->idSubject,
                                                         dwVerLen,
                                                         g_dstrReqTagWMDRMPDClientVersionData.cchString,
                                                         f_plicensechallenge->dstrDeviceCert.cchString,
                                                         0,
                                                         0,
                                                         f_plicensechallenge->dstrRevInfo.cchString);
    }
    
    /* the header is added as a formed XML node */
    
    cchRequired += f_plicensechallenge->dstrHeader.cchString;

    return cchRequired;
}

/******************************************************************************
 *                PRIVATE FUNCTION _WriteUplinkNode
 *
 * write the <UPLINKS> section and its subnodes
 *****************************************************************************/

static DRM_RESULT _WriteUplinkNode (IN DRM_LICENSE_CHALLENGE *f_plicensechallenge)
{
    DRM_DWORD iUplink = 0;
    DRM_RESULT dr     = DRM_SUCCESS;
    
    ChkDR(DRM_XMB_WriteTag (f_plicensechallenge->pbXML,     /* <UPLINKS> */
                            &g_dstrTagUplinks,
                             NULL,
                             NULL,
                             NULL,
                             wttOpen));
    
    for (iUplink = 0; 
         iUplink < f_plicensechallenge->cUplinks;  
         iUplink++)
    {
        DRM_DWORD        cchEncoded    = CCH_BASE64_EQUIV(SIZEOF (DRM_LICENSE_STATE_DATA));
        DRM_CONST_STRING dstrStateData = EMPTY_DRM_STRING;

        dstrStateData.pwszString = (DRM_WCHAR *) f_plicensechallenge->rgbStack;
        dstrStateData.cchString  =  cchEncoded;

        ChkDR(DRM_B64_EncodeW((DRM_BYTE *) (f_plicensechallenge->rglicensestatedata + iUplink), 
                               SIZEOF (DRM_LICENSE_STATE_DATA), 
                              (DRM_WCHAR *) f_plicensechallenge->rgbStack, 
                              &cchEncoded, 
                               DRM_BASE64_ENCODE_WMDRM));
                                
        ChkDR(DRM_XMB_WriteTag(f_plicensechallenge->pbXML,             /* <UPLINK KID = "B64">B64B64B64</UPLINK> */  
                              &g_dstrTagUplink,
                              &dstrStateData, 
                              &g_dstrTagKID, 
                               f_plicensechallenge->rgdstrUplinkKID + iUplink,
                               wttClosed));
    }

    ChkDR(DRM_XMB_EncryptAndCloseCurrNode(f_plicensechallenge->pbXML, 
                                         &(f_plicensechallenge->pcontextBBX->CryptoContext),
                                          f_plicensechallenge->pcontextBBX->pOEMContext,
                                         &g_pubkeyLicenseServer, 
                                          NULL)); /* </UPLINKS> */ 
    
ErrorExit:

    return dr;    
}

/******************************************************************************
 *                PRIVATE FUNCTION _WriteActionsNode
 *
 * write the <ACTIONS> section and its subnodes
 *****************************************************************************/

static DRM_RESULT _WriteActionsNode (IN DRM_LICENSE_CHALLENGE *f_plicensechallenge)
{
    DRM_DWORD  iRight = 0;
    DRM_RESULT dr     = DRM_SUCCESS;
    
    ChkDR(DRM_XMB_WriteTag (f_plicensechallenge->pbXML,      /* <ACTIONLIST> */
                            &g_dstrTagActionList,
                             NULL,
                             NULL,
                             NULL,
                             wttOpen));

    for (iRight = 0; 
         iRight < f_plicensechallenge->cRights;
         iRight++)
    {
        ChkDR(DRM_XMB_WriteTag (f_plicensechallenge->pbXML, /* <ACTION> */
                                &g_dstrTagAction,
                                 f_plicensechallenge->ppdstrRights [iRight],
                                 NULL,
                                 NULL,
                                 wttClosed));
    }

    ChkDR(DRM_XMB_CloseCurrNode (f_plicensechallenge->pbXML, NULL)); /* </ACTIONLIST> */
                                      
ErrorExit:

    return dr;                                      
}

/*
** Add the following node/subnode to the request:
**
** <CLIENTINFO>
**    <CLIENTID>...</CLIENTID>
**    <CLIENTVERSION>...</CLIENTVERSION>
**    <SECURITYVERSION>...</SECURITYVERSION>
**    <APPSECURITY>...</APPSECURITY>
**    <SUBJECTID1>...</SUBJECTID1>
**    <SUBJECTID2>...</SUBJECTID2>
**    <DRMKVERSION>...</DRMKVERSION>
**    <DEVCERT>...</DEVCERT> optional
** </CLIENTINFO>
*/

static DRM_RESULT _AddClientInfo (IN DRM_LICENSE_CHALLENGE *f_plicensechallenge)
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_DWORD        cchEncoded   = CCH_BASE64_EQUIV (SIZEOF (CLIENTID));
    DRM_DWORD        cbXml        = 0;
    DRM_CONST_STRING dstrScratch  = EMPTY_DRM_STRING;
    

    ChkArg (f_plicensechallenge != NULL);

    DRMCASSERT (SIZEOF (f_plicensechallenge->rgbStack) >= CCH_BASE64_EQUIV (SIZEOF (CLIENTID)));
    cbXml = f_plicensechallenge->cbXML;

    dstrScratch.pwszString = f_plicensechallenge->pwszBBVer;
    ChkDR( DRM_STR_StringCchLengthW( f_plicensechallenge->pwszBBVer, VER_STRING_MAX_LEN, &dstrScratch.cchString ) )

    cchEncoded = SIZEOF( f_plicensechallenge->rgbStack  );

    ChkDR( DRM_LA_GetClientInfo(&f_plicensechallenge->clientid,
                                 f_plicensechallenge->rgbStack,
                                &cchEncoded,
          (DRM_CONST_STRING *)  &g_dstrReqTagWMDRMPDClientVersionData,
                                &dstrScratch,
                                 f_plicensechallenge->levelAppSecurity,
                                 f_plicensechallenge->idSubject,
                                 0,
                                 NULL,
                                (f_plicensechallenge->dstrDeviceCert.cchString != 0)? &f_plicensechallenge->dstrDeviceCert : NULL,
                                 f_plicensechallenge->pbXML,
                                &cbXml,
                                &(f_plicensechallenge->pcontextBBX->CryptoContext),
                                 f_plicensechallenge->pcontextBBX->pOEMContext,
                                 FALSE,
                                 (f_plicensechallenge->dstrRevInfo.cchString != 0)? &f_plicensechallenge->dstrRevInfo : NULL));

ErrorExit:
    return dr;
}

/**************************************************************************
**                  PUBLIC FUNCTION DRM_LA_CreateChallenge
***************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LA_CreateChallenge (
    IN DRM_LICENSE_CHALLENGE *f_plicensechallenge,
    OUT      DRM_CHAR        *f_pszChallenge,
    IN OUT   DRM_DWORD       *f_pcchChallenge)
{
    DRM_RESULT   dr    = DRM_SUCCESS;
    DRM_DWORD    cbXML = 0;
    _XMBContext *pbXML = NULL;
    DRM_STRING   dstr  = EMPTY_DRM_STRING;    

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMLICACQREQ, PERF_FUNC_DRM_LA_CreateChallenge);
    
    ChkArg (f_plicensechallenge != NULL
        &&  f_pcchChallenge     != NULL);

    if (f_plicensechallenge->dstrHeader.cchString != 0)
    {
        ChkDRMString (&f_plicensechallenge->dstrHeader);
    }

    if (f_plicensechallenge->dstrV1Challenge.cchString != 0)
    {
        ChkDRMString (&f_plicensechallenge->dstrV1Challenge);
    }
    else
    {
        ASSIGN_DRM_STRING (f_plicensechallenge->dstrV1Challenge, g_dstrDefaultV1Data);
    }

    if (f_plicensechallenge->dstrDeviceCert.cchString != 0)
    {
        ChkDRMString (&f_plicensechallenge->dstrDeviceCert);
    }

    /* calculate the required size for the challenge XML and express as bytes */

    cbXML = _RequiredCharsForRequest (f_plicensechallenge) * SIZEOF (DRM_WCHAR)
          + g_cbXMLBuilderMinimum;

    /* verify that the XML context is WCHAR-aligned and adjust the requirement if it isn't */

    /* check buffer sizes; adjust for possible buffer realignment */

    if   (f_pszChallenge ==  NULL 
      || *f_pcchChallenge <  CCH_BASE64_EQUIV (cbXML))
    {        
        *f_pcchChallenge = CCH_BASE64_EQUIV (cbXML);
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    ChkDR(DRM_UTL_EnsureDataAlignment ((DRM_BYTE*)f_pszChallenge, 
                                       cbXML, 
                                       (DRM_BYTE**)&pbXML, 
                                      &cbXML, 
                                       SIZEOF (DRM_DWORD), 
                                       NULL));

    /* Initialize Context */

    ZEROMEM(pbXML, cbXML);
    
    f_plicensechallenge->pbXML = pbXML;
    f_plicensechallenge->cbXML = cbXML;

    /* Init XML Builder 
    ** Add document root tag: <LicenseRequest version=2.0.0.0"> */
    
    ChkDR(DRM_XMB_CreateDocument(f_plicensechallenge->cbXML,  f_plicensechallenge->pbXML, &g_dstrTagLicenseRequest));
    ChkDR(DRM_XMB_AddAttribute  (f_plicensechallenge->pbXML, &g_dstrAttributeVersion,   &g_dstrAttributeVersion2Value));
    ChkDR(DRM_XMB_WriteCDATATag (f_plicensechallenge->pbXML, &g_dstrTagV1Challenge,     &f_plicensechallenge->dstrV1Challenge, NULL, NULL, wttClosed));
    
    if (f_plicensechallenge->cUplinks > 0)
    {
        ChkDR(_WriteUplinkNode(f_plicensechallenge));
    } 

    if (f_plicensechallenge->cRights > 0)
    {
        ChkDR(_WriteActionsNode(f_plicensechallenge));
    }                                  

    if (f_plicensechallenge->dstrClientIdentity.cchString != 0)
    {
        ChkDR(DRM_XMB_AppendNode(f_plicensechallenge->pbXML, &f_plicensechallenge->dstrClientIdentity));
    }
    else
    {
        ChkDR(_AddClientInfo(f_plicensechallenge));
    }

    if (f_plicensechallenge->dstrHeader.cchString != 0)
    {
        ChkDR(DRM_XMB_AppendNode(f_plicensechallenge->pbXML, &f_plicensechallenge->dstrHeader));
    }


    ChkDR(DRM_XMB_CloseDocument (f_plicensechallenge->pbXML, &dstr));

    TRACE(("\nRequest: %S\n\n", dstr.pwszString));

    /* construct challenge buffer */

    if( CB_DSTR(&dstr) > *f_pcchChallenge )
    {
        /* This should never happen, but PREfast complains, plus it's good to be paranoid */
        *f_pcchChallenge = CCH_BASE64_EQUIV( CB_DSTR(&dstr) );
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }
    MEMMOVE( f_pszChallenge, PB_DSTR(&dstr), CB_DSTR(&dstr) );    
    ChkDR(DRM_B64_EncodeA((DRM_BYTE*)f_pszChallenge,  
                          CB_DSTR(&dstr), 
                          f_pszChallenge, 
                          f_pcchChallenge, 
                          DRM_BASE64_ENCODE_WMDRM));

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}

/**************************************************************************
**                  PUBLIC FUNCTION DRM_LA_GetClientInfo
***************************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_LA_GetClientInfo (
    IN       CLIENTID               *f_pclientid,
    __in_bcount( *f_pcbStack ) DRM_BYTE *f_pbStack,
    IN OUT   DRM_DWORD              *f_pcbStack,
    IN       DRM_CONST_STRING       *f_pdstrClientVersionData,
    IN       DRM_CONST_STRING       *f_pdstrSecurityVersionData,
    IN       DRM_DWORD               f_AppSecurityData,
    IN       DRM_DWORD               f_SubjectId1,
    IN       DRM_DWORD               f_SubjectId2,
    IN       DRM_CONST_STRING       *f_pdstrDRMKVersion,
    IN       DRM_CONST_STRING       *f_pdstrDevcert,
    IN OUT   _XMBContext            *f_pbXML,
    IN OUT   DRM_DWORD              *f_pcbXML,
    IN       DRM_CRYPTO_CONTEXT     *f_contextCRYP,
    IN       DRM_VOID               *f_pOEMContext,
    IN       DRM_BOOL                f_fCreateNewDoc,
    IN       DRM_CONST_STRING       *f_pdstrRevInfo)
{
    DRM_RESULT  dr                   =  DRM_SUCCESS;
    DRM_DWORD   cbXML                =  0;
    DRM_DWORD   cchDevcert           =  0;
    DRM_DWORD   cbDRMKVersion        =  0;
    DRM_DWORD   cchRevInfo           =  0;
    DRM_WCHAR  *pszScratch           = (DRM_WCHAR *) f_pbStack;
    DRM_DWORD   cchEncoded           = CCH_BASE64_EQUIV (SIZEOF(CLIENTID));
    DRM_CONST_STRING dstrScratch     = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMLICACQREQ, PERF_FUNC_DRM_LA_GetClientInfo);

    ChkArg (f_pclientid         != NULL
        &&  f_pcbStack          != NULL
        &&  f_pcbXML            != NULL
        &&  f_AppSecurityData   > 0
        &&  f_SubjectId1        > 0);

    ChkArg( *f_pcbStack >= cchEncoded * SIZEOF( DRM_WCHAR ) );

    ChkDRMString(f_pdstrClientVersionData);
    ChkDRMString(f_pdstrSecurityVersionData);
    
    if ( f_pdstrRevInfo != NULL )
    {
        ChkDRMString(f_pdstrRevInfo);
        cchRevInfo = f_pdstrRevInfo->cchString;
    }

    if ( f_pdstrDRMKVersion != NULL )
    {
        ChkDRMString(f_pdstrDRMKVersion);
        cbDRMKVersion = f_pdstrDRMKVersion->cchString;
    }
    
    if ( f_pdstrDevcert != NULL )
    {
        ChkDRMString(f_pdstrDevcert);
        cchDevcert = f_pdstrDevcert->cchString;
    }

    /* calculate the required size for the challenge XML and express as bytes */

    cbXML += _RequiredCharsForCLIENTINFOBlock (f_AppSecurityData,
                                               f_SubjectId1,
                                               f_pdstrSecurityVersionData->cchString,
                                               f_pdstrClientVersionData->cchString,
                                               cchDevcert, 
                                               f_SubjectId2,
                                               cbDRMKVersion,
                                               cchRevInfo) * SIZEOF(DRM_WCHAR);

    if ( f_fCreateNewDoc )
    {
        cbXML += g_cbXMLBuilderMinimum;   
    }


    if ( f_pbStack == NULL 
    ||   *f_pcbStack <   CCH_BASE64_EQUIV (SIZEOF (CLIENTID))
    ||   f_pbXML == NULL
    ||   *f_pcbXML < cbXML)
    {

        *f_pcbStack = CCH_BASE64_EQUIV (SIZEOF (CLIENTID));
        *f_pcbXML = cbXML;
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    cbXML = *f_pcbXML;

    if ( f_fCreateNewDoc )
    {
        ChkDR(DRM_UTL_EnsureDataAlignment ((DRM_BYTE*)f_pbXML, 
                                            cbXML, 
                                           (DRM_BYTE**)&f_pbXML, 
                                           &cbXML, 
                                            SIZEOF (DRM_DWORD), 
                                            NULL));
        
        ZEROMEM(f_pbXML, cbXML);
        /* Init XML Builder 
        ** Add document root tag: <CLIENTINFO> */
        
        ChkDR(DRM_XMB_CreateDocument(cbXML,  f_pbXML, &g_dstrReqTagClientInfo));
    }
    else
    {
        ChkDR(DRM_XMB_WriteTag (f_pbXML,             
                                &g_dstrReqTagClientInfo,
                                 NULL,
                                 NULL,
                                 NULL,
                                 wttOpen));
    }

    /*      <CLIENTID> */
    
    ChkDR(DRM_B64_EncodeW((DRM_BYTE*) f_pclientid, 
                           SIZEOF(CLIENTID), 
                           pszScratch, 
                          &cchEncoded,
                           DRM_BASE64_ENCODE_WMDRM));
                           
    dstrScratch.pwszString = pszScratch;
    dstrScratch.cchString  = cchEncoded;
    
    ChkDR(DRM_XMB_WriteTag (f_pbXML, 
                            &g_dstrReqTagClientID,
                            &dstrScratch,
                             NULL,
                             NULL,
                             wttClosed));            

     /*      <REVINFO> */
    ChkDR(DRM_XMB_WriteTag (f_pbXML, 
                            &g_dstrReqTagRevInfo,
                            f_pdstrRevInfo,
                             NULL,
                             NULL,
                             wttClosed));            

    /*      <CLIENTVERSION> */

    ChkDR(DRM_XMB_WriteTag (f_pbXML, 
                            &g_dstrReqTagClientVersion,
                             f_pdstrClientVersionData,
                             NULL,
                             NULL,
                             wttClosed));            

    /*      <SECURITYVERSION> */
    
    
    ChkDR(DRM_XMB_WriteTag (f_pbXML, 
                            &g_dstrTagSecurityVersion,
                             f_pdstrSecurityVersionData,
                             NULL,
                             NULL,
                             wttClosed));            

    /*      <APPSECURITY> */
   
    ChkDR( DRM_STR_NumberToString (f_AppSecurityData, (DRM_WCHAR*)dstrScratch.pwszString, 20, 0, 10, &dstrScratch.cchString ) );
   
    ChkDR(DRM_XMB_WriteTag (f_pbXML, 
                            &g_dstrReqTagAppSecurity,
                            &dstrScratch,
                             NULL,
                             NULL,
                             wttClosed));            

    /*      <SUBJECTID1> */

    ChkDR( DRM_STR_NumberToString (f_SubjectId1, (DRM_WCHAR*)dstrScratch.pwszString, 20, 0, 10, &dstrScratch.cchString) );

    ChkDR(DRM_XMB_WriteTag (f_pbXML, 
                            &g_dstrReqTagSubjectID1,
                            &dstrScratch,
                             NULL,
                             NULL,
                             wttClosed));            

    /*      <SUBJECTID2> */

    if (f_SubjectId2 != 0)
    {
        ChkDR( DRM_STR_NumberToString (f_SubjectId2, (DRM_WCHAR*)dstrScratch.pwszString, 20, 0, 10, &dstrScratch.cchString) );

        ChkDR(DRM_XMB_WriteTag (f_pbXML, 
                                &g_dstrReqTagSubjectID2,
                                &dstrScratch,
                                 NULL,
                                 NULL,
                                 wttClosed));            


    }
    else
    {
        ChkDR(DRM_XMB_WriteTag (f_pbXML, 
                                &g_dstrReqTagSubjectID2,
                                 NULL,
                                 NULL,
                                 NULL,
                                 wttClosed));            
    }

    /*      <DRMKVERSION> */

    ChkDR(DRM_XMB_WriteTag (f_pbXML, 
                            &g_dstrReqTagDrmkVersion,
                             f_pdstrDRMKVersion,
                             NULL,
                             NULL,
                             wttClosed));            

    /*      <DEVCERT> */

    if ( f_pdstrDevcert != NULL )
    {        
        ChkDR(DRM_XMB_OpenNode               (f_pbXML,&g_dstrTagDevCert));
        ChkDR(DRM_XMB_AddData                (f_pbXML, f_pdstrDevcert));
        ChkDR(DRM_XMB_EncryptAndCloseCurrNode(f_pbXML, f_contextCRYP, f_pOEMContext, &g_pubkeyLicenseServer, NULL));
    }

    /* </CLIENTINFO> */

    if ( f_fCreateNewDoc )
    {
        ChkDR(DRM_XMB_CloseDocument (f_pbXML, (DRM_STRING *)&dstrScratch));
        *f_pcbXML = CB_DSTR( &dstrScratch );
        
        /*arrange the bytes to original position*/
        if ((DRM_BYTE*)f_pbXML != PB_DSTR( &dstrScratch ) )
        {
            MEMCPY((DRM_BYTE*)f_pbXML, dstrScratch.pwszString, CB_DSTR(&dstrScratch));
        }        
    }
    else
    {
        ChkDR(DRM_XMB_CloseCurrNode (f_pbXML, NULL));    
    }
    

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}

EXIT_PK_NAMESPACE_CODE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmkeygen.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmsha1.h>
#include <drmkeygenerator.h>

ENTER_PK_NAMESPACE_CODE;

DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateKeyseed(
    IN                                 DRM_VOID  *f_pOEMContext,
    __out_ecount_opt( *f_pcchKeyseed ) DRM_WCHAR *f_pwszKeyseed,
    IN OUT                             DRM_DWORD *f_pcchKeyseed )
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_BYTE rgbKeyseed [__CB_DECL(DRM_KEYSEED_BASE64_LEN)];
    DRM_INT i=0;

    ChkArg(f_pcchKeyseed);
    if ( *f_pcchKeyseed<(DRM_KEYSEED_BASE64_LEN+1) || f_pwszKeyseed==NULL )
    {
        dr = DRM_E_BUFFERTOOSMALL;
        *f_pcchKeyseed = DRM_KEYSEED_BASE64_LEN+1;
        goto ErrorExit;
    }
    *f_pcchKeyseed = DRM_KEYSEED_BASE64_LEN+1;
    ChkDR(Oem_Random_GetBytes(f_pOEMContext, rgbKeyseed, DRM_KEYSEED_BASE64_LEN));

    ZEROMEM((DRM_BYTE*)f_pwszKeyseed, *f_pcchKeyseed * SIZEOF(DRM_WCHAR));
    for (i = 0; i < DRM_KEYSEED_BASE64_LEN; i++)
    {
        /* convert each byte into an alpha numberic character (62 available) */
        DRM_BYTE val = (GET_BYTE(rgbKeyseed, i)) % 62;

        if (val < 10)
        {
            val += NATIVE_WCHAR(g_wch0);
        }
        else if (val < 36)
        {
            val += NATIVE_WCHAR(g_wcha) - 10;
        }
        else
        {
            val += NATIVE_WCHAR(g_wchA) - 36;
        }
        f_pwszKeyseed[i] = WCHAR_CAST(val);
    }

ErrorExit:

    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateKeyID(
    IN                               DRM_VOID  *f_pOEMContext,
    __out_ecount_opt( *f_pcchKeyID ) DRM_WCHAR *f_pwszKeyID,           /* base64 encoded string */
    IN OUT                           DRM_DWORD *f_pcchKeyID )
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_GUID   keyGuid;
    DRM_DWORD  cchEncoded = CCH_BASE64_EQUIV(SIZEOF(DRM_GUID));

    ChkArg( f_pcchKeyID != 0 );

    if ( *f_pcchKeyID<( cchEncoded+1)
      || f_pwszKeyID==NULL )
    {
        *f_pcchKeyID=cchEncoded+1;
        dr =DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }

    /*
    ** generate random bytes for KeyID (used to generate a GUID)
    */
    ChkDR(Oem_Random_GetBytes(f_pOEMContext, (DRM_BYTE*)&keyGuid, SIZEOF(DRM_GUID)));

    /* base64 encode */
    ZEROMEM((DRM_BYTE*)f_pwszKeyID, *f_pcchKeyID * SIZEOF(DRM_WCHAR));
    ChkDR(DRM_B64_EncodeW((DRM_BYTE *)&keyGuid, SIZEOF(DRM_GUID), f_pwszKeyID, &cchEncoded, 0));
    *f_pcchKeyID=cchEncoded;

ErrorExit:
    return dr;
}


static DRM_RESULT DRM_CALL _GeneratePlayReadyContentKey(
    __in_bcount(f_cbKeySeed) const      DRM_BYTE  *f_pbKeySeed,
    __in const                          DRM_DWORD  f_cbKeySeed,
    IN                                  DRM_KID   *f_pKID,
    IN                                  DRM_SUPPORTED_CIPHERS f_eCipherType,
    __out_bcount(f_cbContentKey)        DRM_BYTE  *f_pbContentKey,
    IN                                  DRM_DWORD  f_cbContentKey )
{
    DRM_SHA_CONTEXT  sha1 = DRM_SHA_CONTEXT_DEFAULT;
    DRM_SHA_CONTEXT  sha2 = DRM_SHA_CONTEXT_DEFAULT;
    DRM_RESULT       dr   = DRM_SUCCESS;
    DRM_DWORD        i    = 0;
    DRM_BYTE         rgbHashA[SHA256_DIGEST_SIZE_IN_BYTES] = {0};
    DRM_BYTE         rgbHashB[SHA256_DIGEST_SIZE_IN_BYTES] = {0};
    DRM_BYTE         rgbHashC[SHA256_DIGEST_SIZE_IN_BYTES] = {0};

    ChkArg( f_pKID != NULL );
    ChkArg( f_pbKeySeed != NULL );
    ChkArg( f_pbContentKey != NULL );
    ChkArg( f_eCipherType == eDRM_AES_COUNTER_CIPHER );
    ChkArg( f_cbContentKey == DRM_AES_KEYSIZE_128 ); /* Currently only a 128bit AES content key is valid */

    /* Perform first hash (A) */
    ChkDR( DRM_SHA_Init( &sha1, eDRM_SHA_256 ) );
    ChkDR( DRM_SHA_Update( f_pbKeySeed, f_cbKeySeed, &sha1 ) ); /* Explicitly use key seed length (f_cbKeySeed) */
    ChkDR( DRM_SHA_Update( f_pKID->rgb, SIZEOF( f_pKID->rgb ), &sha1 ) );
    MEMCPY( &sha2, &sha1, SIZEOF( DRM_SHA_CONTEXT ) ); /* Optimization: Save off current SHA state for use in hash B */
    ChkDR( DRM_SHA_Finalize( &sha1, SHA256_DIGEST_SIZE_IN_BYTES, rgbHashA ) );

    /* Perform second hash (B) */
    ChkDR( DRM_SHA_Update( f_pbKeySeed, f_cbKeySeed, &sha2 ) ); /* Explicitly use key seed length (f_cbKeySeed) */
    MEMCPY( &sha1, &sha2, SIZEOF( DRM_SHA_CONTEXT ) ); /* Optimization: Save off current SHA state for use in hash C */
    ChkDR( DRM_SHA_Finalize( &sha2, SHA256_DIGEST_SIZE_IN_BYTES, rgbHashB ) );

    /* Perform third hash (C) */
    ChkDR( DRM_SHA_Update( f_pKID->rgb, SIZEOF( f_pKID->rgb ), &sha1 ) );
    ChkDR( DRM_SHA_Finalize( &sha1, SHA256_DIGEST_SIZE_IN_BYTES, rgbHashC ) );

    /* Final step is to XOR resulting hashes to get the content key
    **
    ** Note that this loop may be optimized if we XOR 32bits or 64bits
    ** at a time instead of just 1 byte at a time, but if the output
    ** content key buffer isn't aligned we could have alignment issues
    ** on some platforms so for now this optimization is not done.
    */
    for( i = 0; i < DRM_AES_KEYSIZE_128; i++ )
    {
        f_pbContentKey[i] = rgbHashA[i] ^ rgbHashA[i + DRM_AES_KEYSIZE_128]
                        ^ rgbHashB[i] ^ rgbHashB[i + DRM_AES_KEYSIZE_128]
                        ^ rgbHashC[i] ^ rgbHashC[i + DRM_AES_KEYSIZE_128];
    }

ErrorExit:
    return dr;
}



static DRM_RESULT DRM_CALL _GenerateLegacyContentKey(
    __in_ecount( f_cchKeySeed ) const     DRM_WCHAR *f_pwszKeySeed,          /* base64 encoded string */
    __in                                  DRM_DWORD  f_cchKeySeed,
    __in                                  DRM_DWORD  f_cbContentKey,
    __in_ecount( f_cchKeyID ) const       DRM_WCHAR *f_pwszKeyID,            /* base64 encoded string */
    __in                                  DRM_DWORD  f_cchKeyID,
    __out_ecount_opt( *f_pcchContentKey ) DRM_WCHAR *f_pwszContentKey,       /* base64 encoded string */
    __inout                               DRM_DWORD *f_pcchContentKey)
{
    DRM_RESULT       dr     = DRM_SUCCESS;
    DRM_SHA_CONTEXT  shaVal = DRM_SHA_CONTEXT_DEFAULT;
    DRM_BYTE res       [__CB_DECL(DRM_SHA1_DIGEST_LEN + 1)];
    DRM_BYTE res1      [__CB_DECL(DRM_SHA1_DIGEST_LEN + 1)];
    DRM_BYTE res2      [__CB_DECL(DRM_SHA1_DIGEST_LEN + 1)];
    DRM_DWORD cchb64 = CCH_BASE64_EQUIV(f_cbContentKey);
    DRM_UINT  i      = 0;
    /*
    ** The size of the following scratch buffer has been doubled to accomodate
    ** longer Key Seeds. However, it is possible that the key seed is so long
    ** that this buffer might not be big enough to accomodate the entire seed.
    */
    DRM_BYTE rgbKeyseed[__CB_DECL(DRM_KEYSEED_BASE64_LEN*SIZEOF(DRM_WCHAR))];

    ChkArg( f_pwszKeySeed    != NULL
         && f_pwszKeyID      != NULL
         && f_cchKeyID       != 0
         && f_pcchContentKey != NULL );
    ChkArg( f_cbContentKey < DRM_SHA1_DIGEST_LEN );
    ChkArg( f_cchKeySeed <= SIZEOF(rgbKeyseed) );

    /*
    **  We should actually limit this to just 24 bytes; but for historical
    **  reasons, we have some providers using slightly longer KIDs. Reusing the
    **  keyseed buffer allows for slightly longer KIDs while still checking for
    **  KIDs that are too large
    */
    ChkArg( f_cchKeyID < NO_OF(rgbKeyseed) );

    /* check buffer length */
    if ( *f_pcchContentKey < cchb64
      || f_pwszContentKey == NULL )
    {
        *f_pcchContentKey=cchb64;
        dr=DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }

    for( i=0; i<f_cchKeySeed; i++ )
    {
        PUT_BYTE(rgbKeyseed, i,  (DRM_BYTE) NATIVE_WCHAR (f_pwszKeySeed [i]));
    }

    /* init buffer */
    ZEROMEM((DRM_BYTE*)f_pwszContentKey, *f_pcchContentKey*SIZEOF(DRM_WCHAR));

    /* generate key */
    ChkDR( DRM_SHA_Init( &shaVal, eDRM_SHA_1 ) );
    ChkDR( DRM_SHA_Update(rgbKeyseed, f_cchKeySeed, &shaVal) );
    ChkDR( DRM_SHA_Finalize(&shaVal, DRM_SHA1_DIGEST_LEN, res) );

    for( i=0; i<f_cchKeyID; i++ )
    {
        PUT_BYTE(rgbKeyseed, i, (DRM_BYTE) NATIVE_WCHAR (f_pwszKeyID [i]));
    }

    ChkDR( DRM_SHA_Init( &shaVal, eDRM_SHA_1 ) );
    ChkDR( DRM_SHA_Update( res, 6, &shaVal ) );  /* Copy first 48 bits of res */
    ChkDR( DRM_SHA_Update( rgbKeyseed, f_cchKeyID, &shaVal ) );
    ChkDR( DRM_SHA_Finalize( &shaVal, DRM_SHA1_DIGEST_LEN, res1 ) );

    ChkDR( DRM_SHA_Init( &shaVal, eDRM_SHA_1 ) );
    ChkDR( DRM_SHA_UpdateOffset( res, 6, 6, &shaVal ) );  /* Copy 2nd set of 48 bits of res */
    ChkDR( DRM_SHA_Update( rgbKeyseed, f_cchKeyID, &shaVal ) );
    ChkDR( DRM_SHA_Finalize( &shaVal, DRM_SHA1_DIGEST_LEN, res2 ) );

    ChkDR( DRM_SHA_Init( &shaVal, eDRM_SHA_1 ) );
    DRM_SHA_UpdateOffset(res, 12, 6, &shaVal);  /* Copy third set of 48 bits of res */
    ChkDR( DRM_SHA_Update( rgbKeyseed, f_cchKeyID, &shaVal ) );
    ChkDR( DRM_SHA_Finalize( &shaVal, DRM_SHA1_DIGEST_LEN, res ) );

    /* Reuse res to hold the final result. */
    for (i = 0; i < DRM_SHA1_DIGEST_LEN; i++)
    {
        DRM_BYTE b = GET_BYTE(res, i);
        b ^= GET_BYTE(res1, i) ^ GET_BYTE(res2, i);
        PUT_BYTE(res, i, b);
    }

    ChkDR(DRM_B64_EncodeW(res, f_cbContentKey, f_pwszContentKey, f_pcchContentKey, 0));

ErrorExit:

    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateContentKeyBinary(
    __in_bcount( f_cbKeySeed )             DRM_BYTE  *f_pbKeySeed,
    IN                                     DRM_DWORD  f_cbKeySeed,
    IN                                     DRM_KID   *f_pKID,
    IN                                     DRM_SUPPORTED_CIPHERS f_eCipherType,
    __out_bcount(f_cbContentKey)           DRM_BYTE  *f_pbContentKey,
    IN                                     DRM_DWORD  f_cbContentKey,
    __out_bcount_opt( f_cbScratchKeySeed ) DRM_BYTE  *f_pbScratchKeySeed,
    IN                                     DRM_DWORD  f_cbScratchKeySeed)
{
    DRM_RESULT       dr   = DRM_SUCCESS;

    ChkArg( f_pKID != NULL );
    ChkArg( f_pbContentKey != NULL );

    if( f_eCipherType == eDRM_RC4_CIPHER || f_eCipherType == eDRM_DES_CIPHER )
    {
        DRM_CONST_STRING dstr = EMPTY_DRM_STRING;
        DRM_WCHAR rgwcKeyID[DRM_KEYSEED_BASE64_LEN] = {0};
        DRM_WCHAR rgwcContentKey[CCH_BASE64_EQUIV(max(DES_KEYSIZE, DRMCIPHERKEYLEN_RC4))] = {0};
        DRM_DWORD cchKID = 0;
        DRM_DWORD cchSeed = 0;
        DRM_DWORD cchContentKey = 0;

        ChkArg( (f_eCipherType == eDRM_RC4_CIPHER && f_cbContentKey == DRMCIPHERKEYLEN_RC4)
             || (f_eCipherType == eDRM_DES_CIPHER && f_cbContentKey == DES_KEYSIZE) );
        ChkArg( f_pbScratchKeySeed != NULL );

        /* Size of the scratch buffer passed in should be big enough to accomodate the
        ** Base-64 encoded KeySeed in widechar format.
        */
        ChkArg(CCH_BASE64_EQUIV(f_cbKeySeed) * SIZEOF( DRM_WCHAR ) <= f_cbScratchKeySeed );

        cchSeed = ( f_cbScratchKeySeed / SIZEOF(DRM_WCHAR) );
        ChkDR( DRM_B64_EncodeW( f_pbKeySeed, f_cbKeySeed, (DRM_WCHAR *)f_pbScratchKeySeed, &cchSeed, 0 ) );

        cchKID = NO_OF( rgwcKeyID );
        ChkDR( DRM_B64_EncodeW( f_pKID->rgb, SIZEOF( f_pKID->rgb ), rgwcKeyID, &cchKID, 0 ) );
        ChkBOOL( cchKID <= NO_OF( rgwcKeyID ), DRM_E_BUFFERTOOSMALL );

        cchContentKey = NO_OF( rgwcContentKey );
        ChkDR( _GenerateLegacyContentKey( (DRM_WCHAR *)f_pbScratchKeySeed, cchSeed, f_cbContentKey, rgwcKeyID, cchKID, rgwcContentKey, &cchContentKey ) );

        dstr.pwszString = rgwcContentKey;
        dstr.cchString = cchContentKey;
        ChkDR( DRM_B64_DecodeW( &dstr, &f_cbContentKey, f_pbContentKey, 0 ) );
        ChkFAIL( f_cbContentKey == DRMCIPHERKEYLEN_RC4 );
    }
    else if( f_eCipherType == eDRM_AES_COUNTER_CIPHER )
    {
        ChkDR( _GeneratePlayReadyContentKey(f_pbKeySeed, f_cbKeySeed, f_pKID, f_eCipherType, f_pbContentKey, f_cbContentKey) );
    }
    else
    {
        /* Unsupported cipher type */
        ChkArg( FALSE );
    }

ErrorExit:
    return dr;

}

DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateContentKeyB64(
    __in_ecount( f_cchKeySeed ) const      DRM_WCHAR *f_pwszKeySeed,          /* base64 encoded string */
    IN                                     DRM_DWORD  f_cchKeySeed,
    __in_ecount( f_cchKeyID ) const        DRM_WCHAR *f_pwszKeyID,            /* base64 encoded string */
    IN                                     DRM_DWORD  f_cchKeyID,
    IN                                     DRM_SUPPORTED_CIPHERS f_eCipherType,
    IN                                     DRM_DWORD  f_cbContentKey,
    __out_ecount_opt(*f_pcchContentKey)    DRM_WCHAR *f_pwszContentKey,
    IN                                     DRM_DWORD *f_pcchContentKey,
    __out_bcount_opt( f_cbScratchKeySeed ) DRM_BYTE  *f_pbScratchKeySeed,
    IN                                     DRM_DWORD  f_cbScratchKeySeed)
{
    DRM_RESULT       dr   = DRM_SUCCESS;

    ChkArg( f_pwszKeySeed != NULL );
    ChkArg( f_pwszKeyID != NULL );
    ChkArg( f_pcchContentKey != NULL );

    if( f_eCipherType == eDRM_RC4_CIPHER || f_eCipherType == eDRM_DES_CIPHER )
    {
        /* Real KIDs should be smaller than this but according to source code comments there are legacy KIDs that
        ** can be this large.
        */
        ChkArg( f_cchKeyID <= DRM_KEYSEED_BASE64_LEN );

        ChkArg( (f_eCipherType == eDRM_RC4_CIPHER && f_cbContentKey == DRMCIPHERKEYLEN_RC4)
             || (f_eCipherType == eDRM_DES_CIPHER && f_cbContentKey == DES_KEYSIZE) );

        ChkDR( _GenerateLegacyContentKey( f_pwszKeySeed,
                                        f_cchKeySeed,
                                        f_cbContentKey,
                                        f_pwszKeyID,
                                        f_cchKeyID,
                                        f_pwszContentKey,
                                        f_pcchContentKey) );
    }
    else if( f_eCipherType == eDRM_AES_COUNTER_CIPHER )
    {
        DRM_CONST_STRING dstr = EMPTY_DRM_STRING;
        DRM_KID  kid = {0};
        DRM_BYTE rgbContentKey[DRMCIPHERKEYLEN_MAX] = {0};
        DRM_DWORD cbDecode = 0;

        ChkArg( f_cbContentKey <= DRMCIPHERKEYLEN_MAX );
        ChkArg( f_pbScratchKeySeed != NULL );

        /* Size of the scratch buffer passed in should be big enough to accomodate the
        ** Base-64 decoded KeySeed.
        */
        ChkArg( CB_BASE64_DECODE (f_cchKeySeed) <= f_cbScratchKeySeed );

        /* For PlayReady content keys, force that the base64 KID is the correct length */
        ChkArg( f_cchKeyID == CCH_BASE64_EQUIV( SIZEOF( DRM_KID ) ) );

        /* Check that the buffer is big enough. This would happen later in the B64 encode,
        ** but doing it now as well means we skip having to generate the content key twice
        */
        if( *f_pcchContentKey < CCH_BASE64_EQUIV( f_cbContentKey ) )
        {
            *f_pcchContentKey = CCH_BASE64_EQUIV( f_cbContentKey );
            ChkDR( DRM_E_BUFFERTOOSMALL );
        }

        dstr.pwszString = f_pwszKeySeed;
        dstr.cchString = f_cchKeySeed;
        cbDecode = f_cbScratchKeySeed;

        ChkDR( DRM_B64_DecodeW( &dstr, &cbDecode, f_pbScratchKeySeed, 0) );
        ChkArg( cbDecode <= f_cbScratchKeySeed );

        dstr.pwszString = f_pwszKeyID;
        dstr.cchString = f_cchKeyID;
        ChkDR( DRM_UTL_DecodeKID( &dstr, &kid ) );

        ChkDR( _GeneratePlayReadyContentKey(f_pbScratchKeySeed, cbDecode, &kid, f_eCipherType, rgbContentKey, f_cbContentKey) );

        ChkDR( DRM_B64_EncodeW( rgbContentKey, f_cbContentKey, f_pwszContentKey, f_pcchContentKey, 0 ) );
    }
    else
    {
        /* Unsupported cipher type */
        ChkArg( FALSE );
    }

ErrorExit:
    return dr;
}



DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateSigningKeys(
    IN                                 DRM_CRYPTO_CONTEXT *f_pCrypto,
    __out_ecount_opt( *f_pcchPrivKey ) DRM_WCHAR          *f_pwszPrivKey,  /* base64 encoded string */
    IN OUT                             DRM_DWORD          *f_pcchPrivKey,
    __out_ecount_opt( *f_pcchPubKey )  DRM_WCHAR          *f_pwszPubKey,   /* base64 encoded string */
    IN OUT                             DRM_DWORD          *f_pcchPubKey)
{
    DRM_RESULT dr        = DRM_SUCCESS;
    PUBKEY     pub       = { 0 };
    PRIVKEY    priv      = { 0 };
    DRM_DWORD  cbPubKey  = DRM_ECC160_PUBLIC_KEY_LEN;
    DRM_DWORD  cbPrivKey = DRM_ECC160_PRIVATE_KEY_LEN;
    DRM_DWORD  cchPubEncoded  = CCH_BASE64_EQUIV( DRM_ECC160_PUBLIC_KEY_LEN );
    DRM_DWORD  cchPrivEncoded = CCH_BASE64_EQUIV( DRM_ECC160_PRIVATE_KEY_LEN );

    if ( *f_pcchPrivKey <  cchPrivEncoded + 1
      || *f_pcchPubKey  <  cchPubEncoded  + 1
      ||  f_pwszPrivKey == NULL
      ||  f_pwszPubKey  == NULL )
    {
        *f_pcchPrivKey = cchPrivEncoded + 1;
        *f_pcchPubKey  = cchPubEncoded  + 1;
        dr = DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }

    ZEROMEM((DRM_BYTE*) f_pwszPrivKey, *f_pcchPrivKey * SIZEOF(DRM_WCHAR));
    ZEROMEM(( DRM_BYTE*) f_pwszPubKey,  *f_pcchPubKey  * SIZEOF(DRM_WCHAR));

    /* generate the key pair */
    ChkDR(DRM_PK_GenKeyPair( f_pCrypto->rgbCryptoContext,
                             eDRM_ECC_P160,
                             eDRM_RSA_UNKNOWN,
                             &cbPubKey,
                             ( DRM_BYTE * )&pub,
                             &cbPrivKey,
                             ( DRM_BYTE * )&priv ) );

    /* base64 encode */
    ChkDR(DRM_B64_EncodeW((DRM_BYTE *)&pub,  cbPubKey,  f_pwszPubKey,  f_pcchPubKey,  0));
    ChkDR(DRM_B64_EncodeW((DRM_BYTE *)&priv, cbPrivKey, f_pwszPrivKey, f_pcchPrivKey, 0));
    *f_pcchPubKey  += 1;
    *f_pcchPrivKey += 1;

ErrorExit:
    return dr;
}




EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmint64.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <drmcommon.h>

ENTER_PK_NAMESPACE_CODE;

#if DRM_NO_NATIVE_64_TYPES

static const  DRM_INT64   g_one  = {1, 0};
static const  DRM_UINT64  g_uone = {1, 0};


static DRM_UINT64 _RemoveSign(const DRM_INT64 a, long * sa)
{   
    DRM_UINT64 aa;
    unsigned long int *pa, *pb;

    pa  = (unsigned long int *)&(a.val);
    pb  = (unsigned long int *)&(aa.val);
    *pb = *pa; 
    *(pb+1) = *(pa+1);
    *sa  = ((*(pa+1)) & 0x80000000);
    if (*sa) {
        *pb     = ~(*pb);
        *(pb+1) = ~(*(pb+1));
        aa = DRM_UI64Add(aa, g_uone);
    }                  
    return aa;
}

static void _SetBit(unsigned long int * pData, int loc)
{   
    long bit = 1;
    bit = bit << loc;
    *pData |= bit;
}

DRM_API DRM_INT64 DRM_CALL DRM_I64Add(const DRM_INT64 a, const DRM_INT64 b)
{ 
    /* Same as DRM_UI64Add */
    DRM_INT64 c;
    unsigned short int *upa, *upb, *upc;
    unsigned long int temp, carry, i;
    upa = (unsigned short int *)&(a.val);
    upb = (unsigned short int *)&(b.val);
    upc = (unsigned short int *)&(c.val);
    carry = 0;

#if TARGET_LITTLE_ENDIAN    
    for (i=0;i<4;i++) 
    {
        temp  = (carry + *upa) + *upb;
        carry = temp >> 16;
        *upc  = (unsigned short)temp;
        upa++; upb++; upc++;
    } 
#else         
    temp  = carry + *(upa+1) + *(upb+1);
    carry = temp >> 16;
    *(upc+1)  = temp;
    
    temp  = carry + *upa + *upb;
    carry = temp >> 16;
    *upc  = temp;
    
    temp  = carry + *(upa+3) + *(upb+3);
    carry = temp >> 16;
    *(upc+3)  = temp;
    
    temp  = carry + *(upa+2) + *(upb+2);
    carry = temp >> 16;
    *(upc+2)  = temp;
#endif

    return c;
}


DRM_API DRM_INT64 DRM_CALL DRM_I64Sub(const DRM_INT64 a, const DRM_INT64 b)
{   
    DRM_INT64 nb;
    unsigned long int *pa, *pb;
    pa  = (unsigned long int *)&(nb.val);
    pb  = (unsigned long int *)&(b.val);
    *pa = ~(*pb); 
    pa++; pb++; 
    *pa = ~(*pb);
    return DRM_I64Add(a, DRM_I64Add(nb, g_one)) ;

}

DRM_API DRM_INT64 DRM_CALL DRM_I64Mul(const DRM_INT64 a, const DRM_INT64 b)
{   
    DRM_INT64  c;
    DRM_UINT64 aa, bb, cc;
    unsigned long int *pa, *pb;
    long sa, sb;

    aa = _RemoveSign(a,&sa) ;
    bb = _RemoveSign(b,&sb) ;

    cc = DRM_UI64Mul(aa, bb);
    if (sa ^ sb) {
        pa  = (unsigned long int *)&(cc.val);
        *pa     = ~(*pa);
        *(pa+1) = ~(*(pa+1));
        cc = DRM_UI64Add(cc, g_uone);
    }

    pa  = (unsigned long int *)&(cc.val);
    pb  = (unsigned long int *)&(c.val);
    *pb = *pa; 
    *(pb+1) = *(pa+1);

    return c;
}


DRM_API DRM_INT64 DRM_CALL DRM_I64Div(const DRM_INT64 a, const DRM_INT64 b)
{   
    DRM_INT64 c;
    DRM_UINT64 aa, bb, cc;
    unsigned long int *pa, *pb;
    long sa, sb;

    aa = _RemoveSign(a,&sa) ;
    bb = _RemoveSign(b,&sb) ;

    cc = DRM_UI64Div(aa, bb);
    if (sa ^ sb) {
        pa  = (unsigned long int *)&(cc.val);
        *pa     = ~(*pa);
        *(pa+1) = ~(*(pa+1));
        cc = DRM_UI64Add(cc, g_uone);
    }

    pa  = (unsigned long int *)&(cc.val);
    pb  = (unsigned long int *)&(c.val);
    *pb = *pa; 
    *(pb+1) = *(pa+1);

    return c;
}


DRM_API DRM_INT64 DRM_CALL DRM_I64Mod(const DRM_INT64 a, const DRM_INT64 b)
{   
    DRM_INT64 c;
    DRM_UINT64 aa, bb, cc;
    unsigned long int *pa, *pb;
    long sa, sb;

    aa = _RemoveSign(a,&sa) ;
    bb = _RemoveSign(b,&sb) ;

    cc = DRM_UI64Mod(aa, bb);

    if (sa) {
        pa  = (unsigned long int *)&(cc.val);
        *pa     = ~(*pa);
        *(pa+1) = ~(*(pa+1));
        cc = DRM_UI64Add(cc, g_uone);
    }

    pa  = (unsigned long int *)&(cc.val);
    pb  = (unsigned long int *)&(c.val);
    *pb = *pa; 
    *(pb+1) = *(pa+1);

    return c;
}


DRM_API DRM_INT64 DRM_CALL DRM_I64And(const DRM_INT64 a, const DRM_INT64 b)
{   
    DRM_INT64 c;
    long int *pa, *pb, *pc;
    pa = (long int *)&(a.val);
    pb = (long int *)&(b.val);
    pc = (long int *)&(c.val);

    *pc = *pa & *pb;
    pc++; pa++; pb++;
    *pc = *pa & *pb;
    return c;
}


DRM_API DRM_INT64 DRM_CALL DRM_I64ShR(const DRM_INT64 a, const unsigned int b)
{
    DRM_INT64 c;
    unsigned long int *upa, *upc, td;
    long int *pa, *pc;
    upa = (unsigned long int *)&(a.val);
    upc = (unsigned long int *)&(c.val);
    pa  = (long int *)&(a.val);
    pc  = (long int *)&(c.val);

    if (b > 63) {
        if ( *(pa+1) < 0 ) {
            *upc++ = 0xFFFFFFFF;
            *upc   = 0xFFFFFFFF;
        } else {
            *upc++ = 0;
            *upc = 0;
        }
    }
    else if (b > 31){
        *pc = *(pa+1) >> (b - 32);
        pc++; 
        *pc = *(pa+1)<0 ? 0xFFFFFFFF : 0;
    }
    else if (b > 0) {
        *upc = *upa >> b;
        td  = *(upa+1) << (32 - b);
        *upc |= td;
        pc++; pa++;
        *pc = *pa >> b;
    }
    else {
        *upc = *upa ;
        upc++; upa++;
        *upc = *upa ;
    }
    return c;



}


DRM_API DRM_INT64 DRM_CALL DRM_I64ShL(const DRM_INT64 a, const unsigned int b)
{ 
    DRM_INT64 c;
    unsigned long int *pa, *pc, td;
    pa = (unsigned long int *)&(a.val);
    pc = (unsigned long int *)&(c.val);

    if (b > 63) {
        *pc = 0;
        pc++; 
        *pc = 0;
    }
    else if (b > 31){
        *pc = 0;
        pc++; 
        *pc = *pa << (b - 32);
    }
    else if (b >0) {
        *pc = *pa << b;
        td  = *pa >> (32 - b);
        pc++; pa++;
        *pc = *pa << b;
        *pc |= td;
    }
    else {
        *pc = *pa ;
        pc++; pa++;
        *pc = *pa ;
    }
    return c;
}


DRM_API int DRM_CALL DRM_I64Eql(const DRM_INT64 a, const DRM_INT64 b)
{ 
    long int *pa, *pb;
    pa = (long int *)&(a.val);
    pb = (long int *)&(b.val);

    return ((*pa == *pb)&&(*(pa+1) == *(pb+1)));

}


DRM_API int DRM_CALL DRM_I64Les(const DRM_INT64 a, const DRM_INT64 b)
{
    long int *pa = (long int *) &(a.val);
    long int *pb = (long int *) &(b.val);

    if (*(pa+1) == *(pb+1))
    {
        /* high 32-bits are equal,
        ** so just compare low 32-bits
        */
        return (*(unsigned long int *)pa < *(unsigned long int *)pb);
    }
    else 
    {
        if ((*(pa+1)) & 0x80000000)
        {
            if((*(pb+1)) & 0x80000000)
            {
                /* a and b are both negative,
                ** so compare high bytes using 'greater than'
                */
                return (*(unsigned long int *)(pa+1) > *(unsigned long int *)(pb+1));
            }
            else
            {
                /* a is negative, b is positive,
                ** so a is less than b
                */
                return 1;
            }
        }
        else
        {
            if((*(pb+1)) & 0x80000000)
            {
                /* a is positive, b is negative, 
                ** so a is not less than b
                */
                return 0;
            }
            else
            {
                /* a and b are both positive and not equal,
                ** so just compare the high bytes
                */
                return (*(pa+1) < *(pb+1));
            }
        }
    }
}


DRM_API DRM_INT64 DRM_CALL DRM_I64(const long int b)
{   
    DRM_INT64 c;
    long int *pa;
    pa = (long int *)&(c.val);
    *pa = b;
    pa++;
    if( b & 0x80000000 )
    {
        /* Make sure we sign extend correctly */
        *pa = 0xFFFFFFFF;
    }
    else
    {
        *pa = 0;
    }
    
    return c;
}         


DRM_API DRM_INT64 DRM_CALL DRM_I64Asgn(const long int a, const long int b)
{
    DRM_INT64 c;
    long int *pa;
    pa = (long int *)&(c.val);
    *pa = b;
    pa++;
    *pa = a;
    
    return c;
}


DRM_API DRM_INT64 DRM_CALL DRM_UI2I64(const DRM_UINT64 b)
{   
    DRM_INT64 c;
    long int *pa, *pb;
    pa = (long int *)&(c.val);
    pb = (long int *)&(b.val);
    *pa = *pb;
    pa++; pb++;
    *pa = *pb;
    
    return c;
}


DRM_API unsigned long int DRM_CALL DRM_I64ToUI32(const DRM_INT64 b)
{   
    unsigned long int *pa;
    pa = (unsigned long int *)&(b.val);
    
    return *pa;
}


DRM_API DRM_UINT64 DRM_CALL DRM_UI64Add(const DRM_UINT64 a, const DRM_UINT64 b)
{
    DRM_UINT64 c;
    unsigned short int *upa, *upb, *upc;
    unsigned long int temp, carry, i;
    upa = (unsigned short int *)&(a.val);
    upb = (unsigned short int *)&(b.val);
    upc = (unsigned short int *)&(c.val);
    carry = 0;

#if TARGET_LITTLE_ENDIAN    
    for (i=0;i<4;i++) {
        temp  = carry + *upa + *upb;
        carry = temp >> 16;
        *upc  = (unsigned short)temp;
        upa++; upb++; upc++;
    } 
#else         
    temp  = carry + *(upa+1) + *(upb+1);
    carry = temp >> 16;
    *(upc+1)  = temp;
    
    temp  = carry + *upa + *upb;
    carry = temp >> 16;
    *upc  = temp;
    
    temp  = carry + *(upa+3) + *(upb+3);
    carry = temp >> 16;
    *(upc+3)  = temp;
    
    temp  = carry + *(upa+2) + *(upb+2);
    carry = temp >> 16;
    *(upc+2)  = temp;
#endif    
    
    return c;
}


DRM_API DRM_UINT64 DRM_CALL DRM_UI64Sub(const DRM_UINT64 a, const DRM_UINT64 b)
{   
    DRM_UINT64 nb;
    unsigned long int *pa, *pb;
    pa  = (unsigned long int *)&(nb.val);
    pb  = (unsigned long int *)&(b.val);
    *pa = ~(*pb);
    pa++; pb++; 
    *pa = ~(*pb);
    return DRM_UI64Add(a, DRM_UI64Add(nb, g_uone)) ;
}


DRM_API DRM_UINT64 DRM_CALL DRM_UI64Mul(const DRM_UINT64 a, const DRM_UINT64 b)
{   
    DRM_UINT64  c       = DRM_UI64LITERAL( 0, 0 );
    DRM_BOOL    fZero   = TRUE;
    DRM_LONG    i       = 0; 
    DRM_LONG    j       = 0; 
    DRM_LONG    carry   = 0; 
    DRM_LONG    temp    = 0;
    DRM_BYTE    aa[8], bb[8], cc[8];
               
    
    DWORD_TO_LITTLEENDIAN_BYTES( aa, 0, a.val[0] );
    DWORD_TO_LITTLEENDIAN_BYTES( aa, 4, a.val[1] );
    DWORD_TO_LITTLEENDIAN_BYTES( bb, 0, b.val[0] );
    DWORD_TO_LITTLEENDIAN_BYTES( bb, 4, b.val[1] );


    for (i = 0; i < NO_OF(a.val); i++)
    {
        if (a.val [i] != 0
        ||  b.val [i] != 0)
        {
            fZero = FALSE;
            break;
        }
    }
    
    if (fZero)
    {
        for (i = 0; i < NO_OF(c.val); i++)
        {
            c.val [i] = 0;
        }
        
        return c;
    }
     
    carry = 0;

    for (i = 0; i < 8; i++) 
    {
        temp = carry;
        for (j=0;j<=i;j++) 
        {    
            temp += aa[j] * bb[(i-j)];
        }

        carry = temp >> 8;
        cc[i] = (DRM_BYTE)(temp & 0xFF);
    }

    LITTLEENDIAN_BYTES_TO_DWORD( c.val[0], cc, 0 );
    LITTLEENDIAN_BYTES_TO_DWORD( c.val[1], cc, 4 );

    return c;
}

#define TEST_TOP_BIT(x) (x.val[1]&0x80000000)
#define TEST_BIT(x,b) ( x.val[(b)>>5]&(1<<((b)&0x1f)) )


DRM_API DRM_UINT64 DRM_CALL DRM_UI64Div(const DRM_UINT64 a, const DRM_UINT64 b)
{
    DRM_UINT64 c, aa, bb;
    unsigned long int *pc, *pb, td;

    pb = (unsigned long int *)&(b.val);
    pc = (unsigned long int *)&(c.val);

    aa = a;
    bb = b;
    *pc = 0; *(pc+1) = 0;
    if (DRM_UI64Les(a, b) || ((*pb==0) && (*(pb+1)==0)) ) 
        return c;

    while(!DRM_UI64Les(aa,bb)) { 
        td = 1;
        if ( !TEST_TOP_BIT(b) ) {
            while(1) {
                if ( TEST_BIT(b,64-td) )
                    break;  /* b > aa if a has top bit on and b will shift a bit off msb */
                if ( DRM_UI64Les(aa,DRM_UI64ShL(b,td)) )
                    break;
                td++;
            }
        }
        td--;

        if (td > 31)
            _SetBit(pc+1, td-32);
        else
            _SetBit(pc, td);

        aa = DRM_UI64Sub(aa,DRM_UI64ShL(b,td));
    }
    return c;
}


DRM_API DRM_UINT64 DRM_CALL DRM_UI64Mod(const DRM_UINT64 a, const DRM_UINT64 b)
{
    DRM_UINT64 aa, bb;
    unsigned long int td, *pb;

    pb = (unsigned long int *)&(b.val);

    aa = a;
    bb = b;
    if (DRM_UI64Les(aa, bb)) {
        return aa;
    }
    if ( (*pb==0) && (*(pb+1)==0) )
        return b;

    while(!DRM_UI64Les(aa,bb)) { 
        td = 1;
        if ( !TEST_TOP_BIT(b) ) {
            while(1) {
                if ( TEST_BIT(b,64-td) )
                    break;  /* b > aa if a has top bit on and b will shift a bit off msb */
                if ( DRM_UI64Les(aa,DRM_UI64ShL(b,td)) )
                    break;
                td++;
            }
        }
        td--;

        aa = DRM_UI64Sub(aa,DRM_UI64ShL(b,td));
    }
    return aa;
}


DRM_API DRM_UINT64 DRM_CALL DRM_UI64And(const DRM_UINT64 a, const DRM_UINT64 b)
{   
    DRM_UINT64 c;
    long int *pa, *pb, *pc;
    pa = (long int *)&(a.val);
    pb = (long int *)&(b.val);
    pc = (long int *)&(c.val);

    *pc = *pa & *pb;
    pc++; pa++; pb++;
    *pc = *pa & *pb;
    return c;
}


DRM_API DRM_UINT64 DRM_CALL DRM_UI64ShR(const DRM_UINT64 a,const unsigned int b)
{
    DRM_UINT64 c;
    unsigned long int *pa, *pc, td;
    pa = (unsigned long int *)&(a.val);
    pc = (unsigned long int *)&(c.val);

    if (b > 63) {
        *pc = 0;
        pc++; 
        *pc = 0;
    }
    else if (b > 31){
        *pc = *(pa+1) >> (b - 32);
        pc++; 
        *pc = 0;
    }
    else if (b > 0) {
        *pc = *pa >> b;
        td  = *(pa+1) << (32 - b);
        *pc |= td;
        pc++; pa++;
        *pc = *pa >> b;
    }
    else {
        *pc = *pa ;
        pc++; pa++;
        *pc = *pa ;
    }
    return c;

}


DRM_API DRM_UINT64 DRM_CALL DRM_UI64ShL(const DRM_UINT64 a,const unsigned int b)
{   
    DRM_UINT64 c;
    unsigned long int *pa, *pc, td;
    pa = (unsigned long int *)&(a.val);
    pc = (unsigned long int *)&(c.val);

    if (b > 63) {
        *pc = 0;
        pc++; 
        *pc = 0;
    }
    else if (b > 31){
        *pc = 0;
        pc++; 
        *pc = *pa << (b - 32);
    }
    else if (b >0) {
        *pc = *pa << b;
        td  = *pa >> (32 - b);
        pc++; pa++;
        *pc = *pa << b;
        *pc |= td;
    }
    else {
        *pc = *pa ;
        pc++; pa++;
        *pc = *pa ;
    }
    return c;
}


DRM_API int DRM_CALL DRM_UI64Eql(const DRM_UINT64 a, const DRM_UINT64 b)
{   
    long int *pa, *pb;
    pa = (long int *)&(a.val);
    pb = (long int *)&(b.val);

    return ((*pa == *pb)&&(*(pa+1) == *(pb+1)));
}


DRM_API int DRM_CALL DRM_UI64Les(const DRM_UINT64 a, const DRM_UINT64 b)
{   
    unsigned long int *pa, *pb;
    pa = (unsigned long int *)&(a.val);
    pb = (unsigned long int *)&(b.val);

    if (*(pa+1) != *(pb+1))
        return (*(pa+1) < *(pb+1));
    else
        return (*pa < *pb);
}


DRM_API DRM_UINT64 DRM_CALL DRM_UI64(const unsigned long int b)
{   
    DRM_UINT64 c;
    unsigned long int *pa;
    pa = (unsigned long int *)&(c.val);
    *pa = b;
    pa++;
    *pa = 0;
    
    return c;
}

DRM_API DRM_UINT64 DRM_CALL DRM_UI64HL(const unsigned long int a, const unsigned long int b)
{   
    DRM_UINT64 c;
    unsigned long int *pa;
    pa = (unsigned long int *)&(c.val);
    *pa = b;
    pa++;
    *pa = a;    
    return c;
}

DRM_API unsigned long int DRM_CALL DRM_UI64High32( DRM_UINT64 a )
{   
    unsigned long int *pa;
    pa = (unsigned long int *)&(a.val);    
    pa++;
    return *pa;
}

DRM_API unsigned long int DRM_CALL DRM_UI64Low32( DRM_UINT64 a )
{   
    unsigned long int *pa;
    pa = (unsigned long int *)&(a.val);    
    return *pa;
}

#endif

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmlicacqresp.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmlicenseparser.h>
#include <drmxmlbuilder.h>
#include <drmxmlparser.h>
#include <drmblackbox.h>
#include <drmlicacq.h>
#include <drmexpreval.h>
#include <drmsha1.h>
#include <drmcrt.h>
#if DRM_SUPPORT_APP_REVOCATION || DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_REVOCATION
#include <drmmanager.h>
#include <drmrevocation.h>
#endif
#include <drmsyncstore.h>
#include <drmlicreason.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

/*
**
*/
DRM_API DRM_RESULT DRM_CALL DRM_LA_EvaluateLicense(   
    IN     DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN     DRM_DST             *f_pDatastore,
    OUT    DRM_CONST_STRING    *f_pdstrLIData )
{
    DRM_BYTE         rgbLicensePassword [__CB_DECL(DRM_SHA1_DIGEST_LEN)] = { 0x00 };
    DRM_BOOL         fOK       = FALSE;
    DRM_RESULT       dr        = DRM_SUCCESS;
    DRM_LONG         lReasonForFailure  = 0;
    
    ChkArg (f_pcontextLEVL != NULL
        &&  f_pDatastore   != NULL);

    if ( f_pcontextLEVL->fLicenseIsXMR )
    {   
        ChkArg( f_pcontextLEVL->plicenseXMR != NULL );
    }
    else
    {
        ChkDRMString( &f_pcontextLEVL->dstrContentLicense );
    }

    /*
    **  Cache the reason for failure in case we fail before any of the
    **  DRM_LEVL_PerformOperations
    */
    lReasonForFailure = f_pcontextLEVL->lReasonForFail;
    
    /*
    **  Clear the output
    */
    f_pdstrLIData->cchString = 0;
    f_pdstrLIData->pwszString = NULL;

#if DRM_SUPPORT_APP_REVOCATION
    if ( !f_pcontextLEVL->fLicenseIsXMR )
    {   
        DRM_BOOL fUpdatedRevocationList = FALSE;

        fUpdatedRevocationList = f_pcontextLEVL->idCRLsCurrent.fUpdatedRevocationList;

        ChkDR(DRM_RVK_PerformAppRevocationCheck(&f_pcontextLEVL->pcontextBBX->CryptoContext,
                                                 f_pcontextLEVL->pContextRev,
                                                &f_pcontextLEVL->dstrContentLicense,
                                                &f_pcontextLEVL->appcert,
                                                 f_pcontextLEVL->pbRevocationBuffer,
                                                 f_pcontextLEVL->cbRevocationBuffer,
                                                &f_pcontextLEVL->idCRLsCurrent));

        f_pcontextLEVL->idCRLsCurrent.fUpdatedRevocationList = (fUpdatedRevocationList || f_pcontextLEVL->idCRLsCurrent.fUpdatedRevocationList);
    }
#endif /* DRM_SUPPORT_APP_REVOCATION */

    /* construct lic password */
    ChkDR(DRM_SST_CreateLicenseStatePassword(&f_pcontextLEVL->LID, rgbLicensePassword, f_pcontextLEVL->pcontextBBX));
    ChkDR(DRM_SST_OpenKeyTokens( f_pcontextLEVL->pcontextSSTLicense, 
                                &f_pcontextLEVL->LID, 
                                 NULL,
                                 rgbLicensePassword, 
                                 DRM_SECURE_STORE_OPEN_ALWAYS, 
                                 SECURE_STORE_LICENSE_DATA,
                                 f_pDatastore));

    /* call License Eval */
    f_pcontextLEVL->cPlaylistBurnIncrement = 0;
    f_pcontextLEVL->fReserved              = FALSE;
    f_pcontextLEVL->dwFlags                = LICEVAL_STORE_CHECK_SETTINGS;
    
    dr = DRM_LEVL_PerformOperations( f_pcontextLEVL, 
                                     DRM_LICENSE_EVAL_STORE, 
                                     DRM_LICENSE_EVAL_CAN_DO_OPERATION, 
                                     NULL,
                                    &fOK, 
                                     NULL, 
                                     f_pDatastore,
                                     NULL,
                                     NULL );
    /*
    **  Cache the reason for failure. We want to return this, and not the reason
    **  for failure we get from ONSELECT
    */
    lReasonForFailure = f_pcontextLEVL->lReasonForFail;
    ChkDR( dr );
    
    /* check to see if the license is selectable */
    if ( fOK )
    {
        /* save the content header */
        DRM_CONST_STRING dstrTemp = f_pcontextLEVL->dstrContentHeader;

        /* set content header NULL to avoid KID matching */
        f_pcontextLEVL->dstrContentHeader.pwszString = NULL;
        f_pcontextLEVL->dstrContentHeader.cchString = 0;
        dr = DRM_LEVL_PerformOperations( f_pcontextLEVL, 
                                         DRM_LICENSE_EVAL_SELECT, 
                                         DRM_LICENSE_EVAL_CAN_DO_OPERATION, 
                                         NULL, 
                                         &fOK, 
                                         NULL, 
                                         f_pDatastore,
                                         NULL,
                                         NULL );

        /* restore the content header */
        f_pcontextLEVL->dstrContentHeader = dstrTemp;
        ChkDR(dr);
    }

    if ( !fOK )
    {
        /*
        **  We need to make sure that the reason for failure is set correctly.
        **  This is a workaround to compensate for the fact that v9
        **  licenses do not set the reason correctly sometimes.
        */
        if ( f_pcontextLEVL->lReasonForFail == 0 )
        {
            /* No reason given by license. Try parsing to get the reason, if we can. */
            (void) DRM_LEVL_GetLicenseReasonForUnusable( f_pcontextLEVL,
                                                         &f_pcontextLEVL->lReasonForFail );
        }
        
        /* for the following cases, do not save the license to store. */
        if (   f_pcontextLEVL->lReasonForFail == LR_LICENSE_EXPIRED 
            || f_pcontextLEVL->lReasonForFail == LR_LICENSE_STORE_NOT_ALLOWED 
            || f_pcontextLEVL->lReasonForFail == LR_LICENSE_CERT_EXPIRED)
        {
            lReasonForFailure = f_pcontextLEVL->lReasonForFail;
            dr = DRM_E_FAILED_TO_STORE_LICENSE; /* License store not allowed  */
        }
    }

    /* ignore the error code here */
    (void)DRM_SST_CloseKey(f_pcontextLEVL->pcontextSSTLicense, f_pDatastore, NULL, NULL);

ErrorExit:
    if ( f_pcontextLEVL != NULL )
    {
        f_pcontextLEVL->lReasonForFail = lReasonForFailure;
    }
    
    return dr;
}

#define CCH_SYMSIG_TAG  ( 2  + g_dstrTagSymSig.cchString               /* <SYMSIGNATURE> */                   \
                             + CCH_BASE64_EQUIV( DRM_SHA1_DIGEST_LEN ) /* B64-encoded symmetric signature */  \
                         + 3 + g_dstrTagSymSig.cchString)              /* </SYMSIGNATURE> */                  \

#define CCH_SYMVAL_TAG  ( 2  + g_dstrTagSymValue.cchString             /* <SYMVALUE> */                                               \
                             + CCH_BASE64_EQUIV( 20 )                  /* B64-encoded symmetrically encrypted content key.        */  \
                                                                       /* This value will be updated during processing            */  \
                                                                       /* as it could be different sizes depending on the license */  \
                         + 3 + g_dstrTagSymValue.cchString)            /* </SYMVALUE> */                                              \


static DRM_RESULT DRM_CALL _UpdateLicenseWithSymmetricSignature(
    IN OUT   DRM_STRING          *f_pdstrLicense,
    IN const DRM_CONST_STRING    *f_pdstrData,
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN const DRM_SLK             *f_pslk )
{    
    DRM_BYTE          rgbSymmSignature[__CB_DECL(DRM_SHA1_DIGEST_LEN)] = { 0 };
    DRM_CONST_STRING *pdstrLicense       = (DRM_CONST_STRING*) f_pdstrLicense;
    DRM_CONST_STRING  dstrString         = EMPTY_DRM_STRING;
    DRM_RESULT        dr                 = DRM_SUCCESS; 
    DRM_WCHAR        *pwszInsertionPoint = NULL;
    DRM_DWORD         cch                = 0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMLICACQRESP, PERF_FUNC__UpdateLicenseWithSymmetricSignature);
    
    /*   1.  If a sym sig already exists try to verify it with the current slk
    **   2.  If sym sig doesn't exist, Verify the signature assymetrically
    **   3.  Then create new symsig
    */

    if( f_pslk != NULL
     && DRM_SUCCEEDED( DRM_XML_GetSubNodeByPath( pdstrLicense, 
                                                &g_dstrXPathSymSig, 
                                                 NULL, 
                                                 NULL, 
                                                 NULL,
                                                &dstrString, 
                                                 g_wchForwardSlash ) ) )
    {
        cch = SIZEOF( rgbSymmSignature );
        ChkDR( DRM_B64_DecodeW( &dstrString, &cch, rgbSymmSignature, 0 ) );

        if( cch != DRM_SHA1_DIGEST_LEN
         || DRM_FAILED( DRM_BBX_SymmetricVerify( f_pcontextLEVL->pcontextBBX,
                                                 PB_DSTR( f_pdstrData ),
                                                 CB_DSTR( f_pdstrData ),
                                                 f_pslk,
                                                 rgbSymmSignature ) ) )
        {
            ChkDR( DRM_E_INVALIDLICENSE );
        }

        /* Set the insertion point to just at the begining of the <SYMSIG tag */
        pwszInsertionPoint = (DRM_WCHAR*) (dstrString.pwszString - ( 2 + g_dstrTagSymSig.cchString ));
    }
    else
    {
        DRM_LONG lResult = 0;

        ChkDR( DRM_LIC_VerifySignature( pdstrLicense, f_pcontextLEVL->pcontextBBX, &lResult ) );
        if( lResult != 1 )
        {
            ChkDR( DRM_E_INVALIDLICENSE );
        }
        ChkDR( DRM_LIC_VerifyCertChain( pdstrLicense, TRUE, f_pcontextLEVL, &lResult ) );
        if( lResult != 1 )
        {
            ChkDR( DRM_E_INVALIDLICENSE );
        }

        /* We are inserting immediatly after the closing tag of the DATA node */
        pwszInsertionPoint  = (DRM_WCHAR*) (f_pdstrData->pwszString + f_pdstrData->cchString);
        ChkDR( DRM_UTL_StringInsertBlankSubString( f_pdstrLicense, 
                                       (DRM_DWORD)(f_pdstrData->pwszString - f_pdstrLicense->pwszString ) + f_pdstrData->cchString, 
                                                   CCH_SYMSIG_TAG ) );

        
    }

    *pwszInsertionPoint  = g_wchLessThan;
     pwszInsertionPoint += 1;
    ChkDR( DRM_STR_StringCchCopyNW( pwszInsertionPoint, g_dstrTagSymSig.cchString + 1, g_dstrTagSymSig.pwszString, g_dstrTagSymSig.cchString ) );
     pwszInsertionPoint += g_dstrTagSymSig.cchString;
    *pwszInsertionPoint  = g_wchGreaterThan;
     pwszInsertionPoint += 1;

    ChkDR( DRM_BBX_SymmetricSign( f_pcontextLEVL->pcontextBBX, 
                                  PB_DSTR( f_pdstrData ),
                                  CB_DSTR( f_pdstrData ),
                      (DRM_BYTE*) pwszInsertionPoint) );
    
    cch = CCH_BASE64_EQUIV( DRM_SHA1_DIGEST_LEN );
    ChkDR( DRM_B64_EncodeW( (DRM_BYTE*)pwszInsertionPoint,
                            DRM_SHA1_DIGEST_LEN,
                            pwszInsertionPoint,
                           &cch,
                            0 ) );

     pwszInsertionPoint += cch;
    *pwszInsertionPoint  = g_wchLessThan;
     pwszInsertionPoint += 1;
    *pwszInsertionPoint  = g_wchForwardSlash;
     pwszInsertionPoint += 1;
    ChkDR( DRM_STR_StringCchCopyNW( pwszInsertionPoint, g_dstrTagSymSig.cchString + 1, g_dstrTagSymSig.pwszString, g_dstrTagSymSig.cchString ) );
     pwszInsertionPoint += g_dstrTagSymSig.cchString;
    *pwszInsertionPoint  = g_wchGreaterThan;
     pwszInsertionPoint += 1;

ErrorExit:
    
     DRM_PROFILING_LEAVE_SCOPE;
    
     return dr;
}

static DRM_RESULT DRM_CALL _UpdateLicenseWithSymmetricKey(
    IN OUT   DRM_STRING          *f_pdstrLicense,
    IN const DRM_CONST_STRING    *f_pdstrData,
    IN const DRM_CONST_STRING    *f_pdstrEnablingBits,
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN const DRM_SLK             *f_pslk )
{
    DRM_RESULT       dr                 = DRM_SUCCESS;
    DRM_CONST_STRING dstrString         = EMPTY_DRM_STRING;
    DRM_CONST_STRING *pdstrLicense      = (DRM_CONST_STRING*) f_pdstrLicense;
    DRM_DWORD        cch                = 0;
    DRM_DWORD        cbSymmKey          = 0;
    DRM_WCHAR       *pwszInsertionPoint = NULL;    
    DRM_BINDING_INFO bindinfo = { 0 };    

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMLICACQRESP, PERF_FUNC__UpdateLicenseWithSymmetricKey);    

    bindinfo.m_fXMRLicense = FALSE;

    /*
    **   Using the blackbox create a symmerticly decryptable content key for the license
    **   1.  if a symvalue exists extract it with the current slk and rebind
    **   2.  else asymmetrically extract and rebind.
    */
        
    if( f_pslk != NULL
     && DRM_SUCCEEDED( DRM_XML_GetSubNodeByPath( pdstrLicense, 
                                                &g_dstrXPathSymValue, 
                                                 NULL, 
                                                 NULL, 
                                                 NULL,
                                                &dstrString, 
                                                 g_wchForwardSlash ) ) )
    {
        cbSymmKey = SIZEOF( bindinfo.m_BindingInfo.m_XML.m_rgbContentKey );
        ChkDR( DRM_B64_DecodeW( &dstrString, &cbSymmKey, bindinfo.m_BindingInfo.m_XML.m_rgbContentKey, 0 ) );

        ChkDR( DRM_BBX_RebindSymmetricKey( f_pcontextLEVL->pcontextBBX, 
                                           f_pslk, 
                                           bindinfo.m_BindingInfo.m_XML.m_rgbContentKey, 
                                           0, 
                                           cbSymmKey, 
                                           NULL ) );
        
        /* Set the insertion point to just at the begining of the <SYMVALUE tag */
        pwszInsertionPoint = (DRM_WCHAR*) (dstrString.pwszString - ( 2 + g_dstrTagSymValue.cchString ));
    }
    else
    {
        DRM_DWORD cbKey = SIZEOF( bindinfo.m_BindingInfo.m_XML.m_rgbContentKey );

        /* Get the PUBKEY this license is bound to */
        ChkDR( DRM_LIC_GetEnablingBits( (DRM_CONST_STRING*) f_pdstrLicense,
                                        0,
                                       &bindinfo.m_BindingInfo.m_XML.m_dwAlgorithm,
                                       &bindinfo.m_BindingInfo.m_XML.m_oPublKey,
                                        bindinfo.m_BindingInfo.m_XML.m_rgbContentKey,
                                       &cbKey,
                                       &bindinfo.m_BindingInfo.m_XML.m_oLsPublKey,
                                        bindinfo.m_BindingInfo.m_XML.m_rgbSignature,
                                        NULL,
                                       &f_pcontextLEVL->pcontextBBX->CryptoContext ) );

        /* Convert the asymmertic key to a symmetric key.  This happens in place. */
        ChkDR( DRM_BBX_AsymmetricToSymmetricKeyXML( f_pcontextLEVL->pcontextBBX, 
                                                    &bindinfo,                                                
                                                    &cbSymmKey ) );

        cch = (CCH_SYMVAL_TAG - CCH_BASE64_EQUIV( 20 )) + CCH_BASE64_EQUIV(cbSymmKey);

        /* We are inserting immediatly before the closing tag of the LICENSORINFO tag */
        pwszInsertionPoint  = (DRM_WCHAR*) (f_pdstrData->pwszString + f_pdstrData->cchString);
        ChkDR( DRM_UTL_StringInsertBlankSubString( f_pdstrLicense, 
                                       (DRM_DWORD)(f_pdstrData->pwszString - f_pdstrLicense->pwszString ) + f_pdstrData->cchString, 
                                                   cch ) );
    }    
    
    /* Create the symmetric encrypted content key node and data */
    *pwszInsertionPoint = g_wchLessThan;
     pwszInsertionPoint++;
    ChkDR( DRM_STR_StringCchCopyNW( pwszInsertionPoint, g_dstrTagSymValue.cchString + 1, g_dstrTagSymValue.pwszString, g_dstrTagSymValue.cchString ) );
     pwszInsertionPoint += g_dstrTagSymValue.cchString;
    *pwszInsertionPoint = g_wchGreaterThan;
     pwszInsertionPoint++;

    cch = CCH_BASE64_EQUIV( cbSymmKey );
    ChkDR( DRM_B64_EncodeW( bindinfo.m_BindingInfo.m_XML.m_rgbContentKey,
                            cbSymmKey,
                            pwszInsertionPoint,
                           &cch,
                            0 ) );
    
     pwszInsertionPoint += cch;
    *pwszInsertionPoint  = g_wchLessThan;
     pwszInsertionPoint += 1;
    *pwszInsertionPoint  = g_wchForwardSlash;
     pwszInsertionPoint += 1;
    
    ChkDR( DRM_STR_StringCchCopyNW( pwszInsertionPoint,  g_dstrTagSymValue.cchString + 1, g_dstrTagSymValue.pwszString, g_dstrTagSymValue.cchString ) );
     pwszInsertionPoint += g_dstrTagSymValue.cchString;    
    *pwszInsertionPoint  = g_wchGreaterThan;
     pwszInsertionPoint += 1;

ErrorExit:
    
     DRM_PROFILING_LEAVE_SCOPE;
     
     return dr;
}

/*********************************************************************
**
**  Function:  _UpdateLicenseWithSymmetricData
**
**  Synopsis:  Given a license update it with a symmetrical signature and symmetrically encrypted content key.
**             This drastically improves binding and playback performance by offloading those assymetricall
**             operations to a one time hit here.
**
**  Arguments:  
**     [f_pdstrLicense]  -- License to add symmetrical data to
**     [f_cchLicenseMax] -- Maximum license size that can fix in the f_pdstrLicense buffer
**     [f_pcontextLEVL]  -- Pointer to a license evaluator context.
*********************************************************************/

static DRM_RESULT DRM_CALL _UpdateLicenseWithSymmetricData( 
    IN OUT   DRM_STRING          *f_pdstrLicense,
    IN       DRM_DWORD            f_cchLicenseMax,
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN const DRM_SLK             *f_pslk )
{
    DRM_RESULT       dr               = DRM_SUCCESS;
    DRM_CONST_STRING dstrEnablingBits = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrData         = EMPTY_DRM_STRING;
    DRM_BOOL         fChainedLicense  = FALSE;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMLICACQRESP, PERF_FUNC__UpdateLicenseWithSymmetricData);

    if( f_pdstrLicense->cchString + CCH_SYMSIG_TAG + CCH_SYMVAL_TAG > f_cchLicenseMax )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    /*
    ** Steps:
    **   1.  Find the enabling bits node for this license.
    **   2.  Update with symmetric signature    
    **   3.  Update the license with this information
    */

    /*
    ** The following XML will be added(or updated) to the license enabling bits section
    ** <SYMVALUE>B64-encoded symmetrically encrypted content key</SYMVALUE>
    ** <SYMSIGNATURE>B64-encoded symmetric signature</SYMSIGNATURE>
    */
    
    /* If there is an uplink kid node we don't rebind the content key */
    dr = DRM_LIC_GetAttribute( (DRM_CONST_STRING*)f_pdstrLicense, 
                                NULL,
                                DRM_LICENSE_ATTRIB_CHAINEDKID,                                
                               &dstrData, 
                               &dstrEnablingBits,
                                0);
    if( DRM_SUCCEEDED( dr ) )
    {
        fChainedLicense = TRUE;
    }

    /* dstrData points at the LICENSEORINFO node in the license -- populated by the previous call to GetAttribute */

    if( fChainedLicense )
    {
        ChkDR( DRM_XML_GetSubNode( &dstrData, 
                                   &g_dstrChainedEnablingBits, 
                                    NULL, 
                                    NULL, 
                                    0, 
                                   &dstrEnablingBits, 
                                    NULL, 
                                    1) );
    }
    else
    {
        ChkDR( DRM_XML_GetSubNode( &dstrData, 
                                   &g_dstrTagEnablingbits, 
                                    NULL, 
                                    NULL, 
                                    0, 
                                   &dstrEnablingBits, 
                                    NULL, 
                                    1) );
    }

    if( !fChainedLicense
     || f_pslk != NULL )
    {
        ChkDR( _UpdateLicenseWithSymmetricKey( f_pdstrLicense,
                                              &dstrData,
                                              &dstrEnablingBits,
                                               f_pcontextLEVL,
                                               f_pslk ) );
    }

    ChkDR( _UpdateLicenseWithSymmetricSignature( f_pdstrLicense,
                                                &dstrData,
                                                 f_pcontextLEVL,
                                                 f_pslk ) );

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
DRM_BOOL _PrepareSLKFromLicense(
    IN      DRM_DST                              *f_pDatastore,
    IN      DRM_LICEVAL_CONTEXT                  *f_pcontextLEVL,
    IN      DRM_CHAR                             *f_pbResponse,
    IN      DRM_SUBSTRING                        *f_pdasstrLicenseList,
    OUT     DRM_SLKDATA                          *f_pslkdata)
{
    DRM_RESULT            dr                = DRM_SUCCESS;
    DRM_SUBSTRING         dasstrNodeData    = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING         dasstrTagData     = EMPTY_DRM_SUBSTRING;
    DRM_ID                idSLKNew = { 0 };
    DRM_DWORD             cbidSLK  = SIZEOF( idSLKNew );
    DRM_BYTE              rgbSLKKey[__CB_DECL( DRM_ECC160_CIPHERTEXT_LEN )] = { 0 };
    DRM_BOOL              fSLKValid = FALSE;

    
    dr = DRM_LA_GetSLK( f_pslkdata, f_pDatastore, f_pcontextLEVL );

    if ( DRM_SUCCEEDED( dr )
      && f_pslkdata->slk.cbKey == DES_KEYSIZE )
    {
        fSLKValid = TRUE;
    }
    
    ChkDR( DRM_XML_GetNodeA((DRM_CHAR*) f_pbResponse,
                           f_pdasstrLicenseList, 
                          &g_dastrTagSLK, 
                           NULL, 
                           NULL, 
                           0, 
                           NULL,
                          &dasstrTagData ) );

    /* Extract the SLK ID from the response */
    ChkDR( DRM_XML_GetNodeA( (DRM_CHAR*) f_pbResponse,
                          &dasstrTagData,
                          &g_dastrTagSLKID,
                           NULL,
                           NULL,
                           0,
                           NULL,
                          &dasstrNodeData ) );

    ChkDR( DRM_B64_DecodeA((DRM_CHAR *) f_pbResponse, 
                         &dasstrNodeData, 
                         &cbidSLK, 
                         (DRM_BYTE*)&idSLKNew, 
                          0) );
    
    if( !fSLKValid
      || MEMCMP( f_pslkdata->idSLK.rgb, idSLKNew.rgb, SIZEOF( idSLKNew ) ) != 0 )
    {
        /* New SLK.  Extract the SLK and decrypt */
        ChkDR( DRM_XML_GetNodeA( (DRM_CHAR*) f_pbResponse,
                               &dasstrTagData,
                               &g_dastrTagSLKDATA,
                                NULL,
                                NULL,
                                0,
                                NULL,
                               &dasstrNodeData ) );

        cbidSLK = SIZEOF( rgbSLKKey );
        ChkDR( DRM_B64_DecodeA((DRM_CHAR *) f_pbResponse, 
                             &dasstrNodeData, 
                             &cbidSLK, 
                              rgbSLKKey,
                              0) );

        ChkFAIL( cbidSLK == SIZEOF( rgbSLKKey ) );

        fSLKValid = TRUE;

        ChkDR( DRM_LA_UpdateSLK( &idSLKNew,
                               rgbSLKKey,
                               DRM_ECC160_CIPHERTEXT_LEN,
                               f_pDatastore,    
                               f_pcontextLEVL,
                               f_pslkdata ) );
    }
    
ErrorExit:
    /* Whether our output SLK is valid is all the caller cares about */
    return fSLKValid;
}

#endif

/******************************************************************************
** Function:    DRM_LA_ProcessResponse
** Synopsis:    Process license request response received from license server
** Arguments:   [f_pbResponse] -- Response string received from license server
**              [f_cbResponse] -- size of pbResponse in bytes.
**              [f_pLicEvalContext] --pointer to the context of license eval object
**              [f_pbLicenseStoreContext] --pointer to the context of license store object
**              [f_pInclusionListCallback]  -- pointer to the inclusion list callback structure
**              [f_pfnCallback] -- pointer to a callback function if the caller wants notification of successfull license stores
**              [f_pvCallbackContext] -- pointer to a context that will be passed to the callback function.
**              [f_pDatastore] --pointer to the current DST context that should be used
**              [f_pcontextViewRights] --pointer to a view rights context.  This is only used if Sync Support is enabled.
**              [f_rgbLicenseBuffer] -- Pointer to a buffer of size DRM_MAX_LICENSESIZE bytes.  This will be used as a temporary working buffer.
**              [f_plReason] -- to receive the reason code
** Returns:     DRM_SUCCESS on success, or failed with 
**              DRM_E_INVALIDARG,
**              DRM_E_INVALIDLICENSE, and
**              error codes from License store.
** Notes:       This function process each license(s) contained in the response 
**              received from the license server. It tries to evaluate each license to see
**              if it can store in the license store.
** Sample Response:
**
** <LICENSERESPONSE>
**     <LICENSE version="2.0.0.0">
**         {base64-encoded DRMv7 License}
**     </LICENSE>
**     ...
**     <LICENSE version="2.0.0.0">
**         {base64-encoded DRMv7 License}
**     </LICENSE>
** </LICENSERESPONSE>
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LA_ProcessResponse(
    __in_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN     DRM_DWORD                             f_cbResponse,
    IN     DRM_LICEVAL_CONTEXT                  *f_pcontextLEVL,
    IN     DRM_LICSTORE_CONTEXT                 *f_pcontextLSTXML,
    IN     DRM_LICSTORE_CONTEXT                 *f_pcontextLSTXMR,
    __in   DRM_LICSTOREENUM_CONTEXT             *f_pLicStoreEnumContext,
    IN     DRM_INCLUSION_LIST_CALLBACK_STRUCT   *f_pInclusionListCallback,
    IN     pfnLicenseResponseCallback            f_pfnCallback,
    IN     DRM_VOID                             *f_pvCallbackContext,
    IN     DRM_DST                              *f_pDatastore,
    IN     DRM_VIEW_RIGHTS_CONTEXT              *f_pcontextASD,
    __in_bcount( DRM_MAX_LICENSESIZE ) DRM_BYTE f_rgbLicenseBuffer[__CB_DECL(DRM_MAX_LICENSESIZE)],
    IN     DRM_SYNC_CONTEXT                     *f_pcontextSync,
       OUT DRM_LONG                             *f_plReason)
{
    DRM_RESULT            dr                = DRM_SUCCESS;
    DRM_RESULT            drReason          = DRM_SUCCESS;
    DRM_DWORD             iNode             = 0;
    DRM_DWORD             cStored           = 0;
    DRM_SUBSTRING         dasstrLicenseList = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING         dasstrLicenseData = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING         dasstrNodeData    = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING         dasstrTagData     = EMPTY_DRM_SUBSTRING;
    DRM_ANSI_CONST_STRING dastrLicenseData  = EMPTY_DRM_STRING;
    DRM_CONST_STRING      dstrLIData        = EMPTY_DRM_STRING;
#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
    DRM_SLKDATA           slkdata           = { 0 };
    DRM_BOOL              fSLKValid         = FALSE;
    DRM_BOOL              fTriedLoadingSLK  = FALSE;
#endif
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
    DRM_STACK_ALLOCATOR_CONTEXT stackClock  = { 0 };
#endif    

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMLICACQRESP, PERF_FUNC_DRM_LA_ProcessResponse);

    dastrLicenseData.cchString =              f_cbResponse;
    dastrLicenseData.pszString = (DRM_CHAR *) f_pbResponse;
                
    ChkArg( f_pcontextLEVL         != NULL );
    ChkArg( f_pcontextLSTXML       != NULL );
    ChkArg( f_pcontextLSTXMR       != NULL );
    ChkArg( f_pbResponse           != NULL );
    ChkArg( f_pDatastore           != NULL );
    ChkArg( f_rgbLicenseBuffer     != NULL );
    ChkArg( f_cbResponse           != 0    );
    ChkArg( f_pLicStoreEnumContext != NULL );

    if( f_pfnCallback != NULL )
    {
        /* The Inclusion List Callback struct is only needed if they want us to call them back */
        ChkArg( f_pInclusionListCallback != NULL );
    }

#if DRM_SUPPORT_LICENSE_SYNC
    ChkArg( f_pcontextASD  != NULL
         && f_pcontextSync != NULL );
#endif

    /* extract the license list */
    dasstrLicenseData.m_ich = 0;
    dasstrLicenseData.m_cch = f_cbResponse;    

    ChkDR(DRM_XML_GetNodeA((DRM_CHAR*) f_pbResponse,
                            &dasstrLicenseData, 
                            &g_adstrLicenseRespTag, 
                             NULL, 
                             NULL, 
                             0, 
                             NULL, 
                            &dasstrLicenseList));

    dasstrLicenseData.m_ich = 0;
    dasstrLicenseData.m_cch = f_cbResponse;
                                           
    /* for each license in dastrLicenseList, Add license to license store */
    for (iNode = 0; ; iNode++)
    {
        DRM_CONST_STRING dstrKID         = EMPTY_DRM_STRING;
        DRM_BYTE        *pbLicense       = NULL;
        DRM_DWORD        dwPriority      = 0;
#if SIXTEEN_BIT_ADDRESSING
        DRM_BYTE         bHead           = 0;
        DRM_BOOL         fDecryptOK      = FALSE;
#endif
        dr = DRM_XML_GetNodeA((DRM_CHAR*) f_pbResponse,
                             &dasstrLicenseList, 
                             &g_dastrTagLicense, 
                              NULL, 
                              NULL, 
                              iNode, 
                             &dasstrTagData, 
                             &dasstrNodeData);

        /* A <LICENSE> node was found. */
        
        if (DRM_SUCCEEDED(dr))
        {
            DRM_DWORD     cbVersionLicense     = 0;
            DRM_SUBSTRING dasstrVersionLicense = { 0 };

            /* Check the version information */
            dr = DRM_XML_GetNodeAttributeA((DRM_CHAR*) f_pbResponse,
                                           &dasstrTagData, 
                                           &g_adstrAttributeVersion, 
                                           &dasstrVersionLicense);

            if (DRM_FAILED(dr))
            {
                continue;
            }
            else if (DRM_UTL_DASSTRStringsEqual((DRM_CHAR *) f_pbResponse, 
                                               &dasstrVersionLicense, 
                                               &g_dastrPMLicenseVersionString))
            {
#if DRM_SUPPORT_V1_LICENSES
                /* It is a V1 license.  Callback to store it */
                if (f_pfnCallback)
                {
                    DRM_ANSI_CONST_STRING dastrV1License = EMPTY_DRM_STRING;
                    
                    /* NOTE:  This code will not work on 16 bit addressable systems
                    **        which is OK because the refcode doesn't natively support
                    **        V1 licenses anyway
                    */
                    dastrV1License.pszString = (DRM_CHAR*)f_pbResponse + dasstrNodeData.m_ich;
                    dastrV1License.cchString = dasstrNodeData.m_cch;

                    drReason = f_pfnCallback((DRM_VOID*)&dastrV1License, DRM_STORE_LICENSE_STORE_V1_LICENSE, f_pvCallbackContext);

                    if (DRM_SUCCEEDED(drReason))
                    {
                        cStored++;
                    }
                }
#endif
                continue;
            }
            else            
            {
#if DRM_SUPPORT_V1_LICENSES
                
                f_pcontextLEVL->fLicenseIsXMR = FALSE;
                if( DRM_UTL_DASSTRStringsEqual((DRM_CHAR *) f_pbResponse,
                                               &dasstrVersionLicense,
                                               &g_dastrXMRLicenseVersionString) )
                {
                    DRM_WCHAR wchKID[CCH_BASE64_EQUIV(SIZEOF(DRM_ID))*2] = {0}; /* Ensure we have enough room for a B64 encoded KID, and leave some wiggle room. */
                    DRM_DWORD cchKID                                     = NO_OF( wchKID );
                    DRM_STACK_ALLOCATOR_CONTEXT stackXMR                 = { 0 };

                    drReason = DRM_B64_DecodeA((DRM_CHAR *) f_pbResponse,
                                                &dasstrNodeData,
                                                &cbVersionLicense,
                                                NULL,
                                                DRM_BASE64_DECODE_IN_PLACE);

                    if (DRM_FAILED(drReason))
                    {
                        drReason = DRM_E_INVALIDLICENSE;
                        continue;
                    }

                    /* Make room to put the priority in front of the license for storage. */                    
                    pbLicense = f_pbResponse + dasstrNodeData.m_ich + __CB_DECL( SIZEOF( DRM_DWORD ) );
                    
                    ChkArg( f_cbResponse - dasstrNodeData.m_ich - SIZEOF( DRM_DWORD ) >= cbVersionLicense );
                    
                    MEMMOVE( pbLicense, f_pbResponse + dasstrNodeData.m_ich, cbVersionLicense );

                    ZEROMEM( f_pcontextLEVL->plicenseXMR, SIZEOF( *f_pcontextLEVL->plicenseXMR ) );

                    ChkDR( DRM_STK_Init( &stackXMR, f_rgbLicenseBuffer, DRM_MAX_LICENSESIZE ) );

                    drReason = DRM_XMR_UnpackLicense( pbLicense,
                                                      cbVersionLicense,
                                                     &stackXMR,
                                                      f_pcontextLEVL->plicenseXMR );
                    if (DRM_FAILED(drReason))
                    {
                        drReason = DRM_E_INVALIDLICENSE;
                        continue;
                    }

                    f_pcontextLEVL->fLicenseIsXMR = TRUE;

                    /* Parse the KID, LID, and priority from the license */
                    DRM_BYT_CopyBytes( f_pcontextLEVL->LID.rgb,
                                       0,
                                       f_pcontextLEVL->plicenseXMR->pbRightsIdBuffer,
                                       f_pcontextLEVL->plicenseXMR->iRightsId,
                                       SIZEOF( f_pcontextLEVL->LID.rgb ) );
                    DRM_BYT_CopyBytes( f_pcontextLEVL->KID.rgb,
                                       0,
                                       f_pcontextLEVL->plicenseXMR->containerOuter.containerKeys.ContentKey.pbguidKeyID,
                                       f_pcontextLEVL->plicenseXMR->containerOuter.containerKeys.ContentKey.iguidKeyID,
                                       SIZEOF( f_pcontextLEVL->KID.rgb ) );

                    ChkDR( DRM_B64_EncodeW( f_pcontextLEVL->KID.rgb, SIZEOF( f_pcontextLEVL->KID.rgb ), wchKID, &cchKID, 0 ) );
                    dstrKID.pwszString = wchKID;
                    dstrKID.cchString  = cchKID;

                    if( XMR_IS_PRIORITY_VALID( f_pcontextLEVL->plicenseXMR ) )
                    {
                        dwPriority = f_pcontextLEVL->plicenseXMR->containerOuter.containerGlobalPolicies.Priority.dwValue;
                    }
                    else
                    {
                        dwPriority = 0;
                    }

                    /* Subtract off the priority DWORD so that the pointer is adjusted correctly */
                    pbLicense -= SIZEOF( DRM_DWORD );
                }
                else
#endif
                {
                    /*
                    **  Check to see if there is an "encrypted" attribute.
                    **  If this value is 'false' then the license is directly inline.
                    **  If 'true' or non-existent then the license is B64 encoded and
                    **  privacy encrypted.
                    */

                    dr = DRM_XML_GetNodeAttributeA((DRM_CHAR*) f_pbResponse,
                                                   &dasstrTagData, 
                                                   &g_adstrAttributeEncrypted, 
                                                   &dasstrVersionLicense);

                    drReason = DRM_B64_DecodeA((DRM_CHAR *) f_pbResponse, 
                                                &dasstrNodeData, 
                                                &cbVersionLicense, 
                                                 NULL, 
                                                 DRM_BASE64_DECODE_IN_PLACE);

                    if (DRM_FAILED(drReason))
                    {
                        drReason = DRM_E_INVALIDLICENSE;
                        continue;
                    }            

                    if(  DRM_FAILED( dr )
                     || !DRM_UTL_DASSTRStringsEqual((DRM_CHAR *) f_pbResponse, 
                                                    &dasstrVersionLicense, 
                                                    &g_dastrAttributeFALSE))
                    {
                        /* Attribute doesn't exist or it isn't set to FALSE */

                        /* License is base64 decoded.  Now it should be decrypted. */

#if SIXTEEN_BIT_ADDRESSING
                        /* DecryptLicense expects an aligned CHAR* pointer, not a packed one; rather than
                        change its interface this code temporarily moves a packed buffer into alignment */

                        if ((dasstrNodeData.m_ich % CB_NATIVE_BYTE) != 0)
                        {
                            pbLicense = f_pbResponse + (dasstrNodeData.m_ich & ~CB_NATIVE_BYTE);
                            
                            DRM_16B_IncrementPackedPointer(pbLicense, dasstrNodeData.m_cch, &bHead);
                        }
                        else
                        {
                            pbLicense = f_pbResponse + __CB_DECL(dasstrNodeData.m_ich);
                        }
                        
                        if( cbVersionLicense                             > DRM_ECC160_CIPHERTEXT_LEN
                         && cbVersionLicense - DRM_ECC160_CIPHERTEXT_LEN > DRM_MAX_LICENSESIZE )
                        {
                            drReason = DRM_E_BUFFERTOOSMALL;
                            continue;
                        }
                        
                        fDecryptOK = DRM_BBX_DecryptLicense(pbLicense, cbVersionLicense, f_rgbLicenseBuffer + __CB_DECL( SIZEOF( DRM_DWORD) ), f_pcontextLEVL->pcontextBBX);

                        if ((dasstrNodeData.m_ich % CB_NATIVE_BYTE) != 0)
                        {
                            DRM_16B_DecrementPackedPointer(pbLicense, dasstrNodeData.m_cch, bHead);
                        }

                        if (! fDecryptOK)
                        {
                            drReason = DRM_E_INVALIDLICENSE;
                            continue;
                        }
#else                
                        /* must always add this offset when ANSI B64 decoding in place */

                        pbLicense = f_pbResponse + dasstrNodeData.m_ich;
                        if( cbVersionLicense                             > DRM_ECC160_CIPHERTEXT_LEN
                         && cbVersionLicense - DRM_ECC160_CIPHERTEXT_LEN > DRM_MAX_LICENSESIZE )
                        {
                            drReason = DRM_E_BUFFERTOOSMALL;
                            continue;
                        }

                        ChkArg( dasstrNodeData.m_ich + cbVersionLicense <= f_cbResponse );

                        if(! DRM_BBX_DecryptLicense(pbLicense, cbVersionLicense, f_rgbLicenseBuffer + __CB_DECL( SIZEOF( DRM_DWORD ) ), f_pcontextLEVL->pcontextBBX))
                        {
                            drReason = DRM_E_INVALIDLICENSE;
                            continue;
                        }
#endif
                        cbVersionLicense -= DRM_ECC160_CIPHERTEXT_LEN;
                    }
                    else
                    {
                        if( cbVersionLicense > DRM_MAX_LICENSESIZE )
                        {
                            drReason = DRM_E_BUFFERTOOSMALL;
                            continue;
                        }

                        /* License is inline.  Copy it to the license buffer */
                        DRM_BYT_CopyBytes( f_rgbLicenseBuffer + __CB_DECL( SIZEOF( DRM_DWORD ) ), 0, f_pbResponse, dasstrNodeData.m_ich, cbVersionLicense );
                    }
                    

#if DEBUG__SAVE_PROTOCOL_INFORMATION
                {
                    /* save the lic to a file */
                    OEM_FILEHDL fp=OEM_INVALID_HANDLE_VALUE;
                    DRM_DWORD dwNumberOfBytesWritten=0;

                    fp = Oem_File_Open(
                            NULL,
                            L"c:\\licresp.xml", 
                            OEM_GENERIC_READ|OEM_GENERIC_WRITE,
                            OEM_FILE_SHARE_READ|OEM_FILE_SHARE_WRITE, 
                            OEM_CREATE_NEW, 
                            OEM_ATTRIBUTE_NORMAL);
                    if ( fp != OEM_INVALID_HANDLE_VALUE )
                    {
                        Oem_File_Write(fp, f_rgbLicenseBuffer + __CB_DECL( SIZEOF( DRM_DWORD ) ), cbVersionLicense, &dwNumberOfBytesWritten);
                        Oem_File_Close(fp);
                    }
                }
#endif

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
                    DSTR_FROM_PB( &dstrKID, f_rgbLicenseBuffer + __CB_DECL( SIZEOF( DRM_DWORD ) ), cbVersionLicense );

                    /* Only bother with searching for the SLK if there's a SymSig XML node in the license */
                    if( DRM_SUCCEEDED( DRM_XML_GetSubNodeByPath( &dstrKID, 
                                                &g_dstrXPathSymSig, 
                                                 NULL, 
                                                 NULL, 
                                                 NULL,
                                                &dstrLIData, 
                                                 g_wchForwardSlash ) ) )
                    {
                        if( !fSLKValid && !fTriedLoadingSLK )
                        {
                            fSLKValid = _PrepareSLKFromLicense( f_pDatastore, f_pcontextLEVL, (DRM_CHAR*)f_pbResponse, &dasstrLicenseList, &slkdata );
                            fTriedLoadingSLK = TRUE;
                        }
                    }
            
                    ChkDR( _UpdateLicenseWithSymmetricData( (DRM_STRING*)&dstrKID, 
                                                             DRM_MAX_LICENSESIZE, 
                                                             f_pcontextLEVL, 
                                                             fSLKValid ? &slkdata.slk : NULL ) );
                    cbVersionLicense = CB_DSTR( &dstrKID );
#endif

                    DSTR_FROM_PB( &f_pcontextLEVL->dstrContentLicense,
                                  f_rgbLicenseBuffer + __CB_DECL( SIZEOF( DRM_DWORD ) ),
                                  cbVersionLicense );
                    f_pcontextLEVL->fUseCachedAttribs = FALSE;
                    
                    {
                        DRM_CONST_STRING dstrLIData = EMPTY_DRM_STRING;
                        
                        ChkDRContinue( DRM_LIC_GetAttribute( &f_pcontextLEVL->dstrContentLicense, 
                                                              NULL, 
                                                              DRM_LICENSE_ATTRIB_PRIORITY, 
                                                             &dstrLIData, 
                                                             &dstrKID, 
                                                              0 ) );    

                        ChkDRContinue( DRMCRT_wcsntol( dstrKID.pwszString, dstrKID.cchString, (DRM_LONG *) &dwPriority ) );

                        ChkDRContinue( DRM_LIC_GetAttribute( &f_pcontextLEVL->dstrContentLicense, 
                                                              NULL, 
                                                              DRM_LICENSE_ATTRIB_LID, 
                                                             &dstrLIData, 
                                                             &dstrKID, 
                                                              0 ) );                    
                        ChkDRContinue( DRM_UTL_StringToGuid( &dstrKID, (DRM_GUID*)f_pcontextLEVL->LID.rgb ) );

                        ChkDRContinue( DRM_LIC_GetAttribute( &f_pcontextLEVL->dstrContentLicense, 
                                                              NULL, 
                                                              DRM_LICENSE_ATTRIB_KID, 
                                                             &dstrLIData, 
                                                             &dstrKID, 
                                                              0 ) );
                        ChkDRContinue( DRM_UTL_DecodeKID( &dstrKID, &f_pcontextLEVL->KID ) );
                        /* Do not change dstrKID after this call.  Later code depends on it really pointing to the KID */
                        
                        f_pcontextLEVL->fUseCachedAttribs = TRUE;
                    }
                }
                
                drReason = DRM_LA_EvaluateLicense( f_pcontextLEVL, 
                                                   f_pDatastore,
                                                   &dstrLIData );

                if ( f_plReason != NULL )
                {
                    *f_plReason = f_pcontextLEVL->lReasonForFail;
                }

                /* if they gave us a callback then we need to send over the inclusion GUIDs */
                if ( DRM_SUCCEEDED( drReason )
                    && f_pfnCallback != NULL)
                {
                    ChkDR( DRM_LIC_GetInclusionList( &f_pcontextLEVL->dstrContentLicense, 
                                                     f_pInclusionListCallback->rgInclusionList,
                                                     f_pInclusionListCallback->rgfInclusionListValid,
                                                     0 ) );

                    drReason = f_pfnCallback( (DRM_VOID*)f_pInclusionListCallback, DRM_STORE_LICENSE_NOTIFY_INCLUSION_LIST, f_pvCallbackContext );
                }

                /* store the license if the license evaluated ok */
                if (DRM_SUCCEEDED(drReason) )
                {
#if DRM_SUPPORT_PLAYLIST_BURN
                    /* 
                    **  Save this data off early.  If SYNC is supported the lic eval context could get changed before
                    **  we notify for playlist burn 
                    */
                    DRM_DWORD cPlaylistBurnIncrement = f_pcontextLEVL->cPlaylistBurnIncrement;
#endif

                    if( f_pcontextLEVL->fLicenseIsXMR )
                    {
                        drReason = DRM_LST_AddLicense(f_pcontextLSTXMR,
                                                      cbVersionLicense,
                                                      pbLicense,
                                                     &f_pcontextLEVL->KID,
                                                     &f_pcontextLEVL->LID,
                                                      dwPriority);
                    }
                    else
                    {
                        drReason = DRM_LST_AddLicense(f_pcontextLSTXML,
                                                      CB_DSTR( &f_pcontextLEVL->dstrContentLicense ),
                                                      f_rgbLicenseBuffer,
                                                     &f_pcontextLEVL->KID,
                                                     &f_pcontextLEVL->LID,
                                                      dwPriority);
                    }

                    if (DRM_SUCCEEDED(drReason))
                    {
                        cStored++;

                        if (f_pfnCallback != NULL)
                        {
#if DRM_SUPPORT_PLAYLIST_BURN
                            if (cPlaylistBurnIncrement > 0)
                            {
                                DRM_PLAYLIST_NOTIFICATION_STRUCT burnUpdate;

                                burnUpdate.pdstrKID = &dstrKID;
                                burnUpdate.cPlaylistBurnIncrement = cPlaylistBurnIncrement;
                                f_pfnCallback( (DRM_VOID*) &burnUpdate, DRM_STORE_LICENSE_NOTIFY_PLAYLIST_BURN_UPDATE, f_pvCallbackContext);
                            }
#endif
                            f_pfnCallback( (DRM_VOID*) &dstrKID, DRM_STORE_LICENSE_NOTIFY_KID, f_pvCallbackContext);
                        }
                    }
                } /* end if EvaluateLicense () succeeded */

#if DRM_SUPPORT_LICENSE_SYNC
                /* don't stop the license processing loop on a synclist failure */
                ChkDRContinue( DRM_SNC_UpdateKID(f_pcontextSync, f_pcontextASD, &f_pcontextLEVL->KID, NULL, FALSE ) );
#endif

                ChkArg( f_cbResponse >= dasstrNodeData.m_ich + dasstrNodeData.m_cch );

                /* Fill the data back in with what could be valid base64.  If not the decoded license may
                    cause further calls into the xml parser to fail */
                
                DRM_BYT_SetBytes(f_pbResponse, 
                                 dasstrNodeData.m_ich, 
                                 dasstrNodeData.m_cch, 
                                 'a');
            }
        } /* end if got license tag */
        else
        {
            if (dr == DRM_E_XMLNOTFOUND)
            {
                /* no more license found */
                ChkDR(DRM_SUCCESS);  /* This sets 'dr' and keeps the PREfast tool happy. */
                break;
            }

            ChkDR(dr);  /* other errors */
        }
    } /* end for license */

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK

    ChkDR( DRM_STK_Init( &stackClock, f_rgbLicenseBuffer, DRM_MAX_LICENSESIZE ) );
    
    /* Explicitly make the global secure store writeabele */
    f_pcontextLEVL->fGlobalSecStoreWritable = TRUE;
    ChkDR(DRM_LIC_CheckClockRollback( f_pcontextLEVL,
                                      f_pcontextLSTXML,
                                      f_pcontextLSTXMR,
                                      f_pLicStoreEnumContext,
                                      f_pbResponse,
                                      f_cbResponse,
                                      f_pDatastore,
                                      &stackClock ));
#endif

ErrorExit:

    if (DRM_SUCCEEDED(dr))
    {   
        if (iNode == 1 && cStored == 0)
        {
            if (DRM_FAILED(drReason))
            {
                /* Only one license in response. No license was stored. */
                dr = drReason;
            }
            else
            {
                dr = DRM_E_FAILED_TO_STORE_LICENSE;
            }
        }
        else if (iNode > 1 && cStored == 0)
        {
            /* None were stored. Return usual error as done in past. */
            dr = DRM_E_FAILED_TO_STORE_LICENSE;
        }
        else if (iNode > 1 && cStored < iNode)
        {
            /* Multiple licenses in response. One or more licenses were not stored. */
            dr = DRM_E_NOT_ALL_STORED;
        }
    }
    
    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
/******************************************************************************
** Function:    DRM_LA_GetSLK
** Synopsis:    Retrieves the current SLK from the secure store
** Arguments:   [f_pSLK]         : Returns SLK Data containing the Session ID and symmetric session key
**              [f_pDatastore]   : Pointer to the current DST
**              [f_pcontextLEVL] : Pointer to the current liceval context
**
** Returns:     DRM_SUCCESS
**                  Success 
**              DRM_E_INVALIDARG
**                  f_pSLK is NULL
**              DRM_E_INVALID_SLK
**                  A matching session key was found, but contained invalid data
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LA_GetSLK(
    OUT     DRM_SLKDATA           *f_pSLK,
    IN      DRM_DST               *f_pDatastore,    
    IN      DRM_LICEVAL_CONTEXT   *f_pcontextLEVL )
{
    DRM_RESULT dr    = DRM_SUCCESS;
    DRM_DWORD  cbSLK = SIZEOF( DRM_SLKDATA );
    DRM_BYTE   rgbPasswordSST[__CB_DECL( DRM_SHA1_DIGEST_LEN )] = { 0 };

    ChkArg( f_pcontextLEVL != NULL );

    ChkDR( DRM_SST_CreateLicenseStatePassword( &g_idSLKSST, 
                                               rgbPasswordSST, 
                                               f_pcontextLEVL->pcontextBBX ) );
    
    ChkDR( DRM_SST_GetData( f_pcontextLEVL->pcontextSSTLicense, 
                            &g_idSLKSST, 
                            NULL,
                            rgbPasswordSST,
                            SECURE_STORE_GLOBAL_DATA,
                            f_pDatastore,
                            ( DRM_BYTE * )f_pSLK,
                            &cbSLK ) );

    ChkBOOL( cbSLK == SIZEOF( DRM_SLKDATA ), DRM_E_INVALID_SLK );

ErrorExit:
    return dr;
}

/******************************************************************************
** Function:    DRM_LA_UpdateSLK
** Synopsis:    Uses the SLK Data parameter to locate and update the session key
**              in the SST
**
** Arguments:   [f_pSLKID]       : Contains the new SLK ID
**              [f_pbSLKKey]     : Contains the encrypted SLK key from the license response
**              [f_cbKeyLength]  : Contains the length of f_pbSLKKey
**              [f_pDatastore]   : Pointer to the current DST
**              [f_pcontextLEVL] : Pointer to the current liceval context
**              [f_pSLK]         : Contains the current SLK ID information.
**                                 Returns SLK Data containing the Session ID and 
**                                 new symmetric session key
**
** Returns:     DRM_SUCCESS
**                  Success 
**              DRM_E_INVALIDARG
**                  A required argument is NULL or improperly initialized
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LA_UpdateSLK( 
    IN     DRM_ID               *f_pSLKID,
    __in_bcount( f_cbKeyLength ) DRM_BYTE *f_pbSLKKey,
    IN     DRM_DWORD             f_cbKeyLength,
    IN     DRM_DST              *f_pDatastore,    
    IN     DRM_LICEVAL_CONTEXT  *f_pcontextLEVL,
    OUT    DRM_SLKDATA          *f_pSLK )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE   rgbPasswordSST[__CB_DECL( DRM_SHA1_DIGEST_LEN )] = { 0 };

    ChkArg( f_pcontextLEVL != NULL );
    ChkArg( f_pSLK         != NULL );
    ChkArg( f_pSLKID       != NULL );

    ChkDR( DRM_BBX_RebindSLK( f_pcontextLEVL->pcontextBBX, 
                              f_pbSLKKey,
                              f_cbKeyLength,
                              &f_pSLK->slk ) );    

    MEMCPY( &f_pSLK->idSLK, f_pSLKID, SIZEOF( DRM_ID ) );
                                
    ChkDR( DRM_SST_CreateLicenseStatePassword( &g_idSLKSST, 
                                               rgbPasswordSST, 
                                               f_pcontextLEVL->pcontextBBX) );
    ChkDR( DRM_SST_SetData( f_pcontextLEVL->pcontextSSTLicense, 
                            &g_idSLKSST, 
                            NULL,
                            rgbPasswordSST,
                            SECURE_STORE_GLOBAL_DATA,
                            f_pDatastore,
                            ( DRM_BYTE * )f_pSLK,
                            SIZEOF( DRM_SLKDATA ) ) );
                             
ErrorExit:
    return dr;
}
#endif /* #if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS */
EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmlicacqv3.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmdatastore.h>
#include <drmutilities.h>
#include <drmxmlparser.h>
#include <drmxmlbuildera.h>
#include <drmheaderparser.h>
#include <drmcrt.h>
#include <drmaescommon.h>
#include <drmaes.h>
#include <drmpubkeydeviceexclusion.h>
#include <drmsoapxmlconstants.h>
#include <drmxmlsigconstants.h>
#include <drmxmlsig.h>
#include <drmsoapxmlutility.h>
#include <drmlicacqv3constants.h>
#include <drmlicacqv3.h>
#include <drmmanager.h>
#include <drmcontract.h>
#include <drmutf.h>
#include <oem.h>

#if DRM_SUPPORT_DOMAINS
#include <drmdomainstore.h>
#endif  /* DRM_SUPPORT_DOMAINS */

ENTER_PK_NAMESPACE_CODE;

/*********************************************************************
**
** Function: _DRMResultToANSIString
**
** Synopsis: Function that converts a DRM result into a string with the
**           format "0X08X" ( e.g. 0X00123456 )
**
** Arguments:
**
** [f_dwDR]                 -- The DRM result to be converted.
** [f_pchString]            -- Pointer to a variable that stored the size
**                             ( number of characters ) of the buffer during
**                             input, and receives the actual size of the
**                             result string during output.
** [f_pcchString]           -- Pointer to a buffer that receives the
**                             generated string.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the size of the buffer is
**                          not big enough.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _DRMResultToANSIString(
    IN DRM_RESULT f_dwDR,
    OUT DRM_CHAR *f_pchString,
    IN OUT DRM_DWORD *f_pcchString )
{
    DRM_RESULT dr = DRM_SUCCESS;
    /*
    ** Need to have space to hold 8 hex digits, 2 prefix characters.
    */
    DRM_DWORD cHexDigits = DRM_MAX_CCH_BASE16_DWORD_STRING + 2;
    DRM_DWORD dwValue = ( DRM_DWORD )f_dwDR;
    DRM_DWORD i = 0;
    DRM_DWORD dwTmp = 0;

    ChkArg( f_pchString != NULL );
    ChkArg( f_pcchString != NULL );

    /* Two for "0X", one for the trailing '\0'. */
    if ( *f_pcchString < cHexDigits )
    {
        *f_pcchString = cHexDigits;

        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    PUT_CHAR( f_pchString, 0, '0' );
    PUT_CHAR( f_pchString, 1, 'X' );

    for ( i = 8; i > 0; i-- )
    {
        dwTmp = dwValue % 16;

        if ( dwTmp >= 10 )
        {
            dwTmp = ( dwTmp - 10 ) + 'A';
        }
        else
        {
            dwTmp += '0';
        }

        PUT_CHAR( f_pchString, i + 1, ( DRM_CHAR )dwTmp );

        dwValue /= 16;
    }

    *f_pcchString = cHexDigits;

ErrorExit:

    return dr;
}

/*********************************************************************
**
** Function: _GetMaxChallengeTempBufferCount
**
** Synopsis: Function that calculates the maximum count ( number of
**           UTF8/ANSI or Unicode characters ) of the temporary buffer
**           during the construction of the license acquisition challenge
**           XML.
**
**           Temporary buffer is used to:
**           Convert between Unicode strings and UTF8/ANSI strings.
**           B64 encode/decode data.
**
** Arguments:
**
** [f_poLicChlgContext]     -- Pointer to a structure that contains all
**                             the information needed to build the license
**                             acquisition challenge XML.
**
** Returns:                 A long integer value that is the character
**                          count of the calculated maximum temporary
**                          buffer.
**
**********************************************************************/
static DRM_DWORD _GetMaxChallengeTempBufferCount(
    IN DRM_LICCHLG_CONTEXT_V3 *f_poLicChlgContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchMaxCount = DRM_MAX_CCH_BASE10_DWORD_STRING;
    DRM_DWORD cchCount = 0;
    DRM_DWORD i = 0;

    ChkArg( f_poLicChlgContext != NULL );

    /*
    ** Consider the content header since it needs to be converted from
    ** Unicode to UTF8/ANSI.
    */
    cchCount = f_poLicChlgContext->m_dstrContentHeader.cchString;

    cchMaxCount = max( cchMaxCount, cchCount );

    /*
    ** Consider all right ( action ) strings since they need to be converted
    ** from Unicode to UTF8/ANSI.
    */
    for ( i = 0; i < f_poLicChlgContext->m_cRights; i++ )
    {
        cchCount = f_poLicChlgContext->m_ppdstrRights[ i ]->cchString;

        cchMaxCount = max( cchMaxCount, cchCount );
    }

    /* Consider the B-64 encoded size of the raw license state data. */
    cchCount = CCH_BASE64_EQUIV( SIZEOF( DRM_LICENSE_STATE_DATA ) );

    cchMaxCount = max( cchMaxCount, cchCount );

#if DRM_SUPPORT_REVOCATION

    /*
    ** Consider the B64 encoded size of the revocation type ID ( GUID )
    ** and possibly other nodes that use GUID.
    */
    cchCount = CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) );

    cchMaxCount = max( cchMaxCount, cchCount );

#endif

ErrorExit:

    return cchMaxCount;
}

/*********************************************************************
**
** Function: _GetMaxAcknowledgementTempBufferCount
**
** Synopsis: Function that calculates the maximum count ( number of
**           UTF8/ANSI or Unicode characters ) of the temporary buffer
**           during the construction of the license acquisition
**           acknowledgement XML.
**
**           Temporary buffer is used to:
**           Convert between Unicode strings and UTF8/ANSI strings.
**           B64 encode/decode data.
**
** Arguments:
**
**                          N/A
**
** Returns:                 A long integer value that is the character
**                          count of the calculated maximum temporary
**                          buffer.
**
**********************************************************************/
static DRM_DWORD _GetMaxAcknowledgementTempBufferCount( DRM_VOID )
{
    DRM_DWORD cchMaxCount = DRM_MAX_CCH_BASE10_DWORD_STRING;
    DRM_DWORD cchCount = 0;

    /*
    ** Consider the B64 encoded size of the KID ( GUID ) in each license
    ** processing result.
    */
    cchCount = CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) );

    cchMaxCount = max( cchMaxCount, cchCount );

    return cchMaxCount;
}

/*********************************************************************
**
** Function: _CalcClientInfoCharCount
**
** Synopsis: Function that calculates the character count of the client
**           infomation XML segment in the license acquisition challenge
**           XML.
**
** Arguments:
**                          N/A
**
** Returns:                 A long integer value that is the character
**                          count of the client information XML segment.
**
**********************************************************************/
static DRM_DWORD _CalcClientInfoCharCount( DRM_VOID )
{
    DRM_DWORD cchCount = 0;

    /* <ClientInfo> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqClientInfoTag.cchString,
                                              0,
                                              0,
                                              0 );

    /* <ClientVersion> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqClientVersionTag.cchString,
                                              0,
                                              0,
                                              0 );

    /* Add the character count of client version. */
    cchCount += g_dstrReqTagPlayReadyClientVersionData.cchString;

    return cchCount;
}

#if DRM_SUPPORT_REVOCATION

/*********************************************************************
**
** Function: _CalcRevListInfoCharCount
**
** Synopsis: Function that calculates the character count of the
**           revocation version infomation XML segment in the license
**           acquisition challenge XML.
**
** Arguments:
**
** [f_poRevListInfo]        -- An array of structures that contain the
**                             revocation version information.
** [f_cRevListInfo]         -- Total number of elements in the revocation
**                             version information array mentioned above.
**
** Returns:                 A long integer value that is the character
**                          count of the revocation version information
**                          XML segment.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD _CalcRevListInfoCharCount(
    IN _REVLIST_INFO *f_poRevListInfo,
    IN DRM_DWORD f_cRevListInfo )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchCount = 0;
    DRM_DWORD i = 0;
    DRM_GUID oEmptyGUID = EMPTY_DRM_GUID;

    ChkArg( f_poRevListInfo != NULL );
    ChkArg( f_cRevListInfo > 0 );

    /* <RevocationLists> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqRevocationListsTag.cchString,
                                              0,
                                              0,
                                              0 );

    for ( i = 0; i < f_cRevListInfo; i++ )
    {
        if ( f_poRevListInfo[ i ].m_poGUID == NULL
          || MEMCMP( f_poRevListInfo[ i ].m_poGUID, &oEmptyGUID, SIZEOF( DRM_GUID ) ) == 0 )
        {
            continue;
        }

        if ( f_poRevListInfo[ i ].m_dwVersion == DRM_APP_REVOCATION_VERSION_NONE )
        {
            // Convert legacy "Empty" version number to the PlayReady style.
            f_poRevListInfo[ i ].m_dwVersion = 0;
        }

        /* <RevListInfo> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqRevListInfoTag.cchString,
                                                  0,
                                                  0,
                                                  0 );

        /* <ListID> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqRevListIDTag.cchString,
                                                  CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) ),
                                                  0,
                                                  0 );

        /* <Version> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqRevVersionTag.cchString,
                                                  DRM_SOAPXML_CalcDWORDCharCount( f_poRevListInfo[ i ].m_dwVersion ),
                                                  0,
                                                  0 );
    }

ErrorExit:

    return cchCount;
}

#endif

/*********************************************************************
**
** Function: _CalcDeviceCertCharCount
**
** Synopsis: Function that calculates the character count of a
**           device certificate.
**
** Arguments:
**
** [f_poOEMContext]         -- Pointer to an OEM specific context.
**
** Returns:                 A long integer value that is the character
**                          count of the device certificate.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD _CalcDeviceCertCharCount(
    IN DRM_VOID *f_poOEMContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchCount = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC__CalcDeviceCertCharCount );

    /* Intentionally pass in a NULL buffer to just retrieve the count. */
    ChkDR( DRM_SOAPXML_GetDeviceCert( f_poOEMContext, TRUE, NULL, &cchCount ) );

    /*
    ** Add one more DRM_BYTE to consider the possible realignment.
    */
    cchCount += SIZEOF( DRM_BYTE );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return cchCount;
}

#if DRM_SUPPORT_DOMAINS

/*********************************************************************
**
** Function: _CalcDomainCertsCharCount
**
** Synopsis: Function that calculates the character count of a XML segment
**           that contains a collection of domain certificates. Each domain
**           certificate is encapsulated under a <CertificateChain>
**           node.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context.
** [f_poServiceID]          -- Pointer to a service ID to specify domain
**                             certificates to be included into the
**                             challenge. If it is a blank then all domain
**                             certificates are included.
** [f_pcchDomainCerts]      -- Pointer to a variable that receives the
**                             character count of the domain certificate
**                             chains XML segment.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _CalcDomainCertsCharCount(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poServiceID,
    OUT DRM_DWORD *f_pcchDomainCerts )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DOMAINSTORE_ENUM_CONTEXT oDomainStoreEnumContext = { 0 };
    DRM_GUID oAccountID = EMPTY_DRM_GUID;
    DRM_GUID oServiceID = EMPTY_DRM_GUID;
    DRM_DWORD cbDomainCert = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC__CalcDomainCertsCharCount );

    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( f_poServiceID != NULL );
    ChkArg( f_pcchDomainCerts != NULL );

    *f_pcchDomainCerts = 0;

    ChkDR( DRM_DOMST_InitEnumCert( f_poDomainStoreContext,
                                   &oDomainStoreEnumContext ) );

    for ( ; ; )
    {
        dr = DRM_DOMST_EnumNextCert( &oDomainStoreEnumContext,
                                     &oAccountID,
                                     &oServiceID,
                                     NULL,
                                     &cbDomainCert );

        if ( dr == DRM_E_NOMORE )
        {
            dr = DRM_SUCCESS;

            break;
        }
        else
        {
            ChkDR( dr );
        }

        if ( cbDomainCert == 0 ||
             DRM_SOAPXML_IsBlankGUID( f_poServiceID ) ||
             MEMCMP( &oServiceID, f_poServiceID, SIZEOF( DRM_GUID ) ) != 0 )
        {
            /*
            ** Skip those domain certificates that do not belong
            ** to the passed in service ID.
            */
            continue;
        }

        cbDomainCert = CCH_BASE64_EQUIV( cbDomainCert );

        /*
        ** Add one more DRM_WORD to consider the possible realignment.
        */
        cbDomainCert += SIZEOF( DRM_WORD );

        *f_pcchDomainCerts += cbDomainCert;

        /* <CertificateChain> */
        *f_pcchDomainCerts += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqCertificateChainTag.cchString,
                                                            0,
                                                            0,
                                                            0 );
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#endif /* DRM_SUPPORT_DOMAINS */

/*********************************************************************
**
** Function: _CalcCertChainsCharCount
**
** Synopsis: Function that calculates the character count of the whole
**           certificate chains including device certificate and
**           a collection of domain certificates.
**
** Arguments:
** [f_poLicChlgContext]     -- Pointer to a structure that contains all
**                             the information needed to build the license
**                             acquisition challenge XML.
**
** Returns:                 A long integer value that is the character
**                          count of the whole certificate chains.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD _CalcCertChainsCharCount(
    IN DRM_LICCHLG_CONTEXT_V3 *f_poLicChlgContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchCount = 0;
    DRM_DWORD cchDeviceCert = 0;
    DRM_DWORD cchDomainCerts = 0;

    ChkArg( f_poLicChlgContext != NULL );

    /* <CertificateChains> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqCertificateChainsTag.cchString,
                                              0,
                                              0,
                                              0 );

    /* <CertificateChain> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqCertificateChainTag.cchString,
                                              0,
                                              0,
                                              0 );

    /* Add the character count of the device certificate. */
    cchDeviceCert = _CalcDeviceCertCharCount( f_poLicChlgContext->m_poOEMContext );

    /* Save the character count of the device certificate for future use. */
    f_poLicChlgContext->m_cchDeviceCert = cchDeviceCert;

    cchCount += cchDeviceCert;

#if DRM_SUPPORT_DOMAINS

    if( f_poLicChlgContext->m_poDomainStoreContext != NULL )
    {
        /* Add the character count of possible domain certificates. */
        ChkDR( _CalcDomainCertsCharCount( f_poLicChlgContext->m_poDomainStoreContext,
                                         &f_poLicChlgContext->m_oServiceID,
                                         &cchDomainCerts ) );

        /* Save the character count of the domain certificates for future use. */
        f_poLicChlgContext->m_cchDomainCerts = cchDomainCerts;

        cchCount += cchDomainCerts;
    }

#endif /* DRM_SUPPORT_DOMAINS */

ErrorExit:

    return cchCount;
}

/*********************************************************************
**
** Function: _CalcLicenseChallengeDataCharCount
**
** Synopsis: Function that calculates the character count of the data
**           portion XML segment of the license acquisition challenge
**           XML. The data portion may be encrypted by XML encryption.
**
** Arguments:
** [f_poLicChlgContext]     -- Pointer to a structure that contains all
**                             the information needed to build the license
**                             acquisition challenge XML.
**
** Returns:                 A long integer value that is the character
**                          count of the data portion XML segment.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD _CalcLicenseChallengeDataCharCount(
    IN DRM_LICCHLG_CONTEXT_V3 *f_poLicChlgContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchCount = 0;

    ChkArg( f_poLicChlgContext != NULL );

    /* <Data> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqDataTag.cchString,
                                              0,
                                              0,
                                              0 );

    /* Add the count of the certificate chains. */
    cchCount += _CalcCertChainsCharCount( f_poLicChlgContext );

    /* Add space used by XML builder context. */
    cchCount += g_cbXMLBuilderMinimumA;

    /*
    ** Add one more DRM_DWORD to ensure the size of buffer is
    ** big enough even after realighnment.
    */
    cchCount += SIZEOF( DRM_DWORD );

    /*
    ** Reserve space in order to pad the result XML string to
    ** the length of multiples of DRM_AES_BLOCKLEN (16).
    */
    cchCount += DRM_AES_BLOCKLEN;

ErrorExit:

    return cchCount;
}

/*********************************************************************
**
** Function: _CalcLicenseAcknowledgementDataCharCount
**
** Synopsis: Function that calculates the character count of the data
**           portion XML segment of the license acquisition acknowledgement
**           XML. The data portion may be encrypted by XML encryption.
**
** Arguments:
** [f_cchDeviceCert]        -- Size ( number of characters ) of a device
**                             certificate.
**
** Returns:                 A long integer value that is the character
**                          count of the data portion XML segment.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD _CalcLicenseAcknowledgementDataCharCount(
    IN DRM_DWORD f_cchDeviceCert )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchCount = 0;

    ChkArg( f_cchDeviceCert > 0 );

    /* <Data> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAckDataTag.cchString,
                                              f_cchDeviceCert,
                                              0,
                                              0 );

    /* <CertificateChain> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAckCertificateChainTag.cchString,
                                              f_cchDeviceCert,
                                              0,
                                              0 );

ErrorExit:

    return cchCount;
}

/*********************************************************************
**
** Function: _CalcLicenseChallengeCharCount
**
** Synopsis: Function that calculates the character count of a license
**           acquisition challenge XML.
**
** Arguments:
** [f_poLicChlgContext]     -- Pointer to a structure that contains all
**                             the information needed to build a license
**                             acquisition challenge XML.
**
** Returns:                 A long integer value that is the character
**                          count of the license acquisition challenge
**                          XML.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD _CalcLicenseChallengeCharCount(
    IN DRM_LICCHLG_CONTEXT_V3 *f_poLicChlgContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchCount = 0;
    DRM_DWORD cchSignatureXMLCount = 0;
    DRM_DWORD cchEncryptedCount = 0;
    DRM_DWORD cbEncryptedSize = 0;
    DRM_DWORD cchCustomData = 0;
    DRM_GUID oEmptyGUID = EMPTY_DRM_GUID;

    ChkArg( f_poLicChlgContext != NULL );

#if DRM_USE_SOAP

    /* Add the character count of the XML root header ( <?xml...> ). */
    cchCount += g_dastrXMLRootTag.cchString;

    /* Add the character count of the SOAP header. */
    cchCount += DRM_SOAPXML_CalcSOAPHeaderCharCount( );

#endif

    /* <AcquireLicense> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqRootTag.cchString,
                                              0,
                                              g_dastrLicAcqRootAttribName.cchString,
                                              g_dastrLicAcqRootAttribValue.cchString );

    /* <challenge> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqChallenge1Tag.cchString,
                                              0,
                                              0,
                                              0 );

    /* <Challenge> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqChallenge2Tag.cchString,
                                              0,
                                              g_dastrLicAcqChallenge2AttribName.cchString,
                                              g_dastrLicAcqChallenge2AttribValue.cchString );
    /* <LA> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqLATag.cchString,
                                              0,
                                              g_dastrLicAcqChallengeVAAttrib1Name.cchString,
                                              g_dastrLicAcqChallengeVAAttrib1Value.cchString );

    cchCount += DRM_XMB_RequiredCharsForAttributeA(
                                              g_dastrLicAcqChallengeVAAttrib2Name.cchString,
                                              g_dastrLicAcqChallengeVAAttrib2Value.cchString );

    cchCount += DRM_XMB_RequiredCharsForAttributeA(
                                              g_dastrSOAPPreserveSpaceAttribName.cchString,
                                              g_dastrSOAPPreserveSpaceAttribValue.cchString );

    /* <Version> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqVersionTag.cchString,
                                              g_dastrLicAcqVersionValue.cchString,
                                              0,
                                              0 );

    /* <ContentHeader> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqContentHeaderTag.cchString,
                                              0,
                                              0,
                                              0 );

    /* Add the character count of the content header. */
    cchCount += f_poLicChlgContext->m_dstrContentHeader.cchString;

    /* Add the character count of client information XML segment. */
    cchCount += _CalcClientInfoCharCount();

#if DRM_SUPPORT_REVOCATION

    /* Add the character count of revocation informartion XML segment. */
    cchCount += _CalcRevListInfoCharCount( f_poLicChlgContext->m_rgoRevListInfo,
                                           MAX_REVLIST_INFO );

#endif

    if ( f_poLicChlgContext->m_dastrCustomData.cchString > 0 )
    {
        /* <CustomData> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqCustomDataTag.cchString,
                                                  0,
                                                  0,
                                                  0 );

        /* Cet the size  (number of characters) of the XML encoded custom data. */
        ChkDR( DRM_SOAPXML_EncodeData( ( DRM_CHAR * )f_poLicChlgContext->m_dastrCustomData.pszString,
                                       f_poLicChlgContext->m_dastrCustomData.cchString,
                                       NULL,
                                       &cchCustomData ) );

        /* Add the character count of the custom data. */
        cchCount += cchCustomData;

        /* Possible alignment cost. */
        cchCount += SIZEOF( DRM_WORD );
    }

    if ( MEMCMP( &f_poLicChlgContext->m_oNonce, &oEmptyGUID, SIZEOF( DRM_GUID ) ) != 0 )
    {
        /* <LicenseNonce> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAcqLicenseNonceTag.cchString,
                                                  CCH_BASE64_EQUIV( SIZEOF( DRM_ID ) ),
                                                  0,
                                                  0 );
    }

    /*
    ** Calculate the character count of the data portion of the license acquisition
    ** challenge XML that might be XML encrypted.
    */
    cchEncryptedCount += _CalcLicenseChallengeDataCharCount( f_poLicChlgContext );

    cbEncryptedSize = cchEncryptedCount * SIZEOF( DRM_CHAR );

    /*
    ** Add the character counte of the encrypted data portion of the license
    ** acquisition challenge XML.
    */
    ChkDR( DRM_XMLSIG_GetEncryptedDataNodeCharCount( &f_poLicChlgContext->m_oXMLKey,
                                                     cbEncryptedSize,
                                                     &cchEncryptedCount ) );

    cchCount += cchEncryptedCount;

    /* Add the character count of the signature. */
    ChkDR( DRM_XMLSIG_GetSignatureNodeCharCount( &cchSignatureXMLCount ) );

    cchCount += cchSignatureXMLCount;

ErrorExit:

    return cchCount;
}

/*********************************************************************
**
** Function: _CalcLicenseAcknowledgementCharCount
**
** Synopsis: Function that calculates the character count of a license
**           acquisition acknowledgement XML.
**
** Arguments:
** [f_cchTransactionID]     -- Size (number of characters) of a transaction ID.
** [f_poLicAcks]            -- An array of license acknowlegement structures
**                             that store the results of license processing.
** [f_cLicAcks]             -- Total number of elements of the license
**                             acknowledgement structures in the array
**                             mentioned above.
** [f_cchDeviceCert]        -- Size ( number of characters ) of a device
**                             certificate.
** [f_poXMLKey]             -- Pointer to a DRM_XML_KEY structure that
**                             contains the key information to encrypt
**                             portion of the challenge data.
**
** Returns:                 A long integer value that is the character
**                          count of the license acquisition acknowledgement
**                          XML.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD _CalcLicenseAcknowledgementCharCount(
    IN DRM_DWORD f_cchTransactionID,
    IN DRM_LICENSE_ACK *f_poLicAcks,
    IN DRM_DWORD f_cLicAcks,
    IN DRM_DWORD f_cchDeviceCert,
    IN DRM_XML_KEY *f_poXMLKey )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchCount = 0;
    DRM_DWORD cchEncryptedCount = 0;
    DRM_DWORD cbEncryptedSize = 0;
    DRM_DWORD cchSignatureXMLCount = 0;
    DRM_DWORD i = 0;

    ChkArg( ( f_cLicAcks > 0 && f_poLicAcks != NULL ) ||
            f_cLicAcks == 0 );
    ChkArg( f_cchDeviceCert > 0 );
    ChkArg( f_poXMLKey != NULL );

#if DRM_USE_SOAP

    /* Add the character count of the XML root header ( <?xml...> ). */
    cchCount += g_dastrXMLRootTag.cchString;

    /* Add the character count of the SOAP header. */
    cchCount += DRM_SOAPXML_CalcSOAPHeaderCharCount( );

#endif

    /* <AcknowledgeLicense> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAckRootTag.cchString,
                                              0,
                                              g_dastrLicAckRootAttribName.cchString,
                                              g_dastrLicAckRootAttribValue.cchString );

    /* <challenge> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAckChallenge1Tag.cchString,
                                              0,
                                              0,
                                              0 );

    /* <Challenge> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAckChallenge2Tag.cchString,
                                              0,
                                              g_dastrLicAckChallenge2AttribName.cchString,
                                              g_dastrLicAckChallenge2AttribValue.cchString );

    /* <Ack> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAckAckTag.cchString,
                                              0,
                                              g_dastrLicAckAckAttrib1Name.cchString,
                                              g_dastrLicAckAckAttrib1Value.cchString );

    cchCount += DRM_XMB_RequiredCharsForAttributeA( g_dastrLicAckAckAttrib2Name.cchString,
                                                    g_dastrLicAckAckAttrib2Value.cchString );

    cchCount += DRM_XMB_RequiredCharsForAttributeA( g_dastrSOAPPreserveSpaceAttribName.cchString,
                                                    g_dastrSOAPPreserveSpaceAttribValue.cchString );

    /* <Version> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAckVersionTag.cchString,
                                              0,
                                              0,
                                              0 );

    /* <TransactionID> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAckTransactionIDTag.cchString,
                                              f_cchTransactionID,
                                              0,
                                              0 );

    /* <LicenseStorageResults> */
    cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAckLicenseStorageResultsTag.cchString,
                                              0,
                                              0,
                                              0 );

    for ( i = 0; i < f_cLicAcks; i++ )
    {
        /* <License> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAckLicenseTag.cchString,
                                                  0,
                                                  0,
                                                  0 );

        /* <KID> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAckKIDTag.cchString,
                                                  CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) ),
                                                  0,
                                                  0 );

        /* <LID> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAckLIDTag.cchString,
                                                  CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) ),
                                                  0,
                                                  0 );

        /* <Result> */
        cchCount += DRM_XMB_RequiredCharsForTagA( g_dastrLicAckResultTag.cchString,
                                                  DRM_SOAPXML_CalcDWORDCharCount( f_poLicAcks->m_dwResult ),
                                                  0,
                                                  0 );
    }

    /*
    ** Calculate the character count of the data portion of the license acquisition
    ** acknowledgement XML that might be XML encrypted.
    */
    cchEncryptedCount = _CalcLicenseAcknowledgementDataCharCount( f_cchDeviceCert );

    cbEncryptedSize = cchEncryptedCount * SIZEOF( DRM_CHAR );

    /*
    ** Add the character count of the encrypted data portion of the license
    ** acquisition acknowledgement XML.
    */
    ChkDR( DRM_XMLSIG_GetEncryptedDataNodeCharCount( f_poXMLKey,
                                                     cbEncryptedSize,
                                                     &cchEncryptedCount ) );

    cchCount += cchEncryptedCount;

    /* Add the character count of the signature XML segment. */
    ChkDR( DRM_XMLSIG_GetSignatureNodeCharCount( &cchSignatureXMLCount ) );

    cchCount += cchSignatureXMLCount;

ErrorExit:

    return cchCount;
}

#if DRM_SUPPORT_DOMAINS

/*********************************************************************
**
** Function: _BuildDomainCertsXML
**
** Synopsis: Function that constructs a domain certificate chains
**           XML segment that contains one or more domain certificates.
**
** Arguments:
**
** [f_poDomainStoreContext] -- Pointer to a domain store context.
** [f_poServiceID]          -- Pointer to a service ID to specify domain
**                             certificates to be included into the
**                             challenge. If it is a blank then all domain
**                             certificates are included.
** [f_poXMLContext]         -- Pointer to a XML builder context.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildDomainCertsXML(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poServiceID,
    IN OUT _XMBContextA *f_poXMLContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DOMAINSTORE_ENUM_CONTEXT oDomainStoreEnumContext = { 0 };
    DRM_GUID oAccountID = EMPTY_DRM_GUID;
    DRM_GUID oServiceID = EMPTY_DRM_GUID;
    DRM_DWORD cbDomainCert = 0;
    DRM_CHAR *pchXML = NULL;
    DRM_SUBSTRING dasstrReservedBuffer = EMPTY_DRM_SUBSTRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC__BuildDomainCertsXML );

    ChkArg( f_poDomainStoreContext != NULL );
    ChkArg( f_poServiceID != NULL );
    ChkArg( f_poXMLContext != NULL );

    ChkDR( DRM_XMB_GetXMLBaseA( f_poXMLContext, &pchXML ) );

    DRMASSERT( pchXML != NULL );

    ChkDR( DRM_DOMST_InitEnumCert( f_poDomainStoreContext,
                                   &oDomainStoreEnumContext ) );

    for ( ; ; )
    {
        dr = DRM_DOMST_EnumNextCert( &oDomainStoreEnumContext,
                                     &oAccountID,
                                     &oServiceID,
                                     NULL,
                                     &cbDomainCert );

        if ( dr == DRM_E_NOMORE )
        {
            dr = DRM_SUCCESS;

            break;
        }
        else
        {
            ChkDR( dr );
        }

        if ( cbDomainCert == 0 ||
             DRM_SOAPXML_IsBlankGUID( f_poServiceID ) ||
             MEMCMP( &oServiceID, f_poServiceID, SIZEOF( DRM_GUID ) ) != 0 )
        {
            /*
            ** Skip those domain certificates that do not belong
            ** to the passed in service ID.
            */
            continue;
        }

        /*
        ** Add and open <CertificateChain> node.
        **
        ** Output:
        ** <CertificateChain>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrLicAcqCertificateChainTag,
                                  NULL,
                                  NULL,
                                  NULL,
                                  wttOpen ) );

        ChkDR( DRM_XMB_ReserveSpaceA( f_poXMLContext,
                                      SIZEOF( DRM_WORD ),
                                      CCH_BASE64_EQUIV( cbDomainCert ),
                                      &dasstrReservedBuffer ) );

        /*
        ** The reserved the buffer should be big enough to store the all domain
        ** certificates. In case the buffer has more bytes needed by the domain
        ** certificates, those bytes should be set to ' ' so the server side XML
        ** parser can just ignore them.
        */
        MEMSET( pchXML + __CB_DECL( dasstrReservedBuffer.m_ich ),
                ' ',
                dasstrReservedBuffer.m_cch );

        ChkDR( DRM_DOMST_GetCert( f_poDomainStoreContext,
                                  &oAccountID,
                                  &oServiceID,
                                  ( DRM_BYTE * )pchXML + __CB_DECL( dasstrReservedBuffer.m_ich ),
                                  &cbDomainCert ) );

        DRMASSERT( CCH_BASE64_EQUIV( cbDomainCert ) == dasstrReservedBuffer.m_cch );

        ChkDR( DRM_B64_EncodeA( ( DRM_BYTE * )pchXML + __CB_DECL( dasstrReservedBuffer.m_ich ),
                                cbDomainCert,
                                pchXML + __CB_DECL( dasstrReservedBuffer.m_ich ),
                                &dasstrReservedBuffer.m_cch,
                                0 ) );

        /*
        ** Close <CertificateChain> node.
        **
        ** Output:
        ** <CertificateChain>
        **      ...
        ** </CertificateChain>
        */
        ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, NULL ) );
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#endif /* DRM_SUPPORT_DOMAINS */

/*********************************************************************
**
** Function: _BuildCertChainsXML
**
** Synopsis: Function that constructs a certificate chains XML segment
**           that contains both a device certificate and possible domain
**           certification( s ). The certificate chains XML segment
**           is part of the license acquisition challenge XML.
**
** Arguments:
**
** [f_poXMLContext]         -- Pointer to a XML builder context.
** [f_poLicChlgContext]     -- Pointer to a structure that contains all
**                             the information needed to build the license
**                             acquisition challenge XML.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildCertChainsXML(
    IN OUT _XMBContextA *f_poXMLContext,
    IN DRM_LICCHLG_CONTEXT_V3 *f_poLicChlgContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CHAR *pchXML = NULL;
    DRM_SUBSTRING dasstrReservedBuffer = EMPTY_DRM_SUBSTRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC__BuildCertChainsXML );

    ChkArg( f_poXMLContext != NULL );
    ChkArg( f_poLicChlgContext != NULL );

    ChkDR( DRM_XMB_GetXMLBaseA( f_poXMLContext, &pchXML ) );

    DRMASSERT( pchXML != NULL );

    /*
    ** Add and open <CertificateChains> node.
    **
    ** Output:
    ** <CertificateChains>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAcqCertificateChainsTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    /*
    ** Only build the device certificate XML segment when the device certificate
    ** is not empty. *f_poLicChlgContext should contain the known character count
    ** of the device certificate.
    */
    if ( f_poLicChlgContext->m_cchDeviceCert > 0 )
    {
        /*
        ** Add and open <CertificateChain> node.
        **
        ** Output:
        ** <CertificateChains>
        **      ...
        **      <CertificateChain>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrLicAcqCertificateChainTag,
                                  NULL,
                                  NULL,
                                  NULL,
                                  wttOpen ) );

        ChkDR( DRM_XMB_ReserveSpaceA( f_poXMLContext,
                                      SIZEOF( DRM_WORD ),
                                      f_poLicChlgContext->m_cchDeviceCert,
                                      &dasstrReservedBuffer ) );

        /*
        ** The reserved the buffer should be big enough to store the whole device
        ** certificates. In case the buffer has more bytes needed by the device
        ** certificate, those bytes should be set to ' ' so the server side XML
        ** parser can just ignore them.
        */
        MEMSET( pchXML + __CB_DECL( dasstrReservedBuffer.m_ich ),
                ' ',
                dasstrReservedBuffer.m_cch );

        ChkDR( DRM_SOAPXML_GetDeviceCert( f_poLicChlgContext->m_poOEMContext,
                                          TRUE,
                                          pchXML + __CB_DECL( dasstrReservedBuffer.m_ich ),
                                          &dasstrReservedBuffer.m_cch ) );

        /*
        ** Close <CertificateChain> node.
        **
        ** Output:
        ** <CertificateChains>
        **      <CertificateChain>
        **          device certificate
        **      </CertificateChain>
        */
        ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, NULL ) );
    }

#if DRM_SUPPORT_DOMAINS

    /*
    ** Only build the domain certificate XML segment when there is one or more
    ** domain certificate( s ). *f_poLicChlgContext should contain the known character
    ** count of the domain certificate( s ).
    **
    ** Output:
    ** <CertificateChains>
    **      ...
    **      <CertificateChain>
    **          domain certificate 1
    **      </CertificateChain>
    **      <CertificateChain>
    **          domain certificate 2
    **      </CertificateChain>
    **      ...
    */
    if ( f_poLicChlgContext->m_cchDomainCerts > 0 )
    {
        ChkArg( f_poLicChlgContext->m_poDomainStoreContext != NULL );
        ChkDR( _BuildDomainCertsXML( f_poLicChlgContext->m_poDomainStoreContext,
                                     &f_poLicChlgContext->m_oServiceID,
                                     f_poXMLContext ) );
    }

#endif /* DRM_SUPPORT_DOMAINS */

    /*
    ** Close <CertificateChains> node.
    **
    ** Output:
    ** <CertificateChains>
    **      ...
    ** </CertificateChains>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, NULL ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _BuildClientInfoXML
**
** Synopsis: Function that constructs a client information XML segment
**           that is part of the license acquisition challenge XML.
**
** Arguments:
**
** [f_poXMLContext]         -- Pointer to a XML builder context.
** [f_poStackAllocatorContext]
**                          -- Pointer to a stack allocator context.
** [f_cchBuffer]            -- Maxmimum size ( number of character count )
**                             of the temporary buffer uses in this
**                             function.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_NO_INLINE DRM_RESULT _BuildClientInfoXML(
    IN OUT _XMBContextA *f_poXMLContext,
    IN DRM_STACK_ALLOCATOR_CONTEXT *f_poStackAllocatorContext,
    IN DRM_DWORD f_cchBuffer )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CHAR* pchScratch = NULL;
    DRM_DWORD cchScratch = 0;
    DRM_ANSI_STRING dastrScratch = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC__BuildClientInfoXML );

    ChkArg( f_poXMLContext != NULL );
    ChkArg( f_poStackAllocatorContext != NULL );
    ChkArg( f_cchBuffer >= DRM_MAX_CCH_BASE10_DWORD_STRING );

    /* Allocate the temporary buffer. */
    ChkDR( DRM_STK_Alloc( f_poStackAllocatorContext, f_cchBuffer, ( DRM_VOID ** )&pchScratch ) );

    dastrScratch.pszString = pchScratch;

    /*
    ** Add and open <ClientInfo> node.
    **
    ** Output:
    ** <ClientInfo>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAcqClientInfoTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    cchScratch = g_dstrReqTagPlayReadyClientVersionData.cchString;

    ChkBOOL( cchScratch <= f_cchBuffer, DRM_E_INVALIDARG );

    /* Safe to use, input parameter is ASCII */
    DRM_UTL_DemoteUNICODEtoASCII( g_dstrReqTagPlayReadyClientVersionData.pwszString,
                                  pchScratch,
                                  cchScratch );

    dastrScratch.cchString = cchScratch;

    /*
    ** Add and close <ClientVersion> node.
    **
    ** Output:
    ** <ClientInfo>
    **      <ClientVersion>...</ClientVersion>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAcqClientVersionTag,
                              ( DRM_ANSI_CONST_STRING * )&dastrScratch,
                              NULL,
                              NULL,
                              wttClosed ) );

    /*
    ** Close <ClientVersion> node.
    **
    ** Output:
    ** <ClientInfo>
    **      ...
    ** </ClientInfo>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, NULL ) );

ErrorExit:

    /* Free the temporary buffer. */
    if ( f_poStackAllocatorContext != NULL && pchScratch != NULL )
    {
        DRM_STK_Free( f_poStackAllocatorContext, pchScratch );
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#if DRM_SUPPORT_REVOCATION

/*********************************************************************
**
** Function: _BuildRevListInfoXML
**
** Synopsis: Function that constructs a revocation version information
**           XML segment that is part of the license acquisition
**           challenge XML.
**
** Arguments:
**
** [f_poXMLContext]         -- Pointer to a XML builder context.
** [f_poStackAllocatorContext]
**                          -- Pointer to a stack allocator context.
** [f_poRevListInfo]        -- An array of structure that contains the
**                             revocation version information.
** [f_cRevListInfo]         -- Total number of elements in the revocation
**                             version information array mentioned above.
** [f_cchBuffer]            -- Maxmimum size ( number of character count )
**                             of the temporary buffer uses in this
**                             function.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_NO_INLINE DRM_RESULT _BuildRevListInfoXML(
    IN OUT _XMBContextA *f_poXMLContext,
    IN DRM_STACK_ALLOCATOR_CONTEXT *f_poStackAllocatorContext,
    IN _REVLIST_INFO *f_poRevListInfo,
    IN DRM_DWORD f_cRevListInfo,
    IN DRM_DWORD f_cchBuffer )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_WCHAR rgwchScratch[ DRM_MAX_CCH_BASE10_DWORD_STRING + 1 ] = { 0 };
    DRM_CHAR* pchScratch = NULL;
    DRM_DWORD cchScratch = 0;
    DRM_ANSI_STRING dastrScratch = EMPTY_DRM_STRING;
    DRM_DWORD i = 0;
    DRM_GUID oEmptyGUID = EMPTY_DRM_GUID;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC__BuildRevListInfoXML );

    ChkArg( f_poXMLContext != NULL );
    ChkArg( f_poStackAllocatorContext != NULL );
    ChkArg( f_poRevListInfo != NULL );
    ChkArg( f_cRevListInfo > 0 );
    ChkArg( f_cchBuffer >= DRM_MAX_CCH_BASE10_DWORD_STRING );

    /* Allocate the temporary buffer. */
    ChkDR( DRM_STK_Alloc( f_poStackAllocatorContext, f_cchBuffer, ( DRM_VOID ** )&pchScratch ) );

    dastrScratch.pszString = pchScratch;

    /*
    ** Add and open <RevocationLists> node.
    **
    ** Output:
    ** <RevocationLists>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAcqRevocationListsTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    for ( i = 0; i < f_cRevListInfo; i++ )
    {
        if ( f_poRevListInfo[ i ].m_poGUID == NULL
          || MEMCMP( f_poRevListInfo[ i ].m_poGUID, &oEmptyGUID, SIZEOF( DRM_GUID ) ) == 0 )
        {
            continue;
        }

        if ( f_poRevListInfo[ i ].m_dwVersion == DRM_APP_REVOCATION_VERSION_NONE )
        {
            // Convert legacy "Empty" version number to the PlayReady style.
            f_poRevListInfo[ i ].m_dwVersion = 0;
        }

        /*
        ** Add and open <RevocationLists> node.
        **
        ** Output:
        ** <RevocationLists>
        **      ...
        **      <RevListInfo>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrLicAcqRevListInfoTag,
                                  NULL,
                                  NULL,
                                  NULL,
                                  wttOpen ) );

        cchScratch = CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) );

        ChkBOOL( cchScratch <= f_cchBuffer, DRM_E_INVALIDARG );

        DRMASSERT( f_poRevListInfo[ i ].m_poGUID != NULL );

        ChkDR( DRM_B64_EncodeA( ( DRM_BYTE * )f_poRevListInfo[ i ].m_poGUID,
                                SIZEOF( DRM_GUID ),
                                pchScratch,
                                &cchScratch,
                                0 ) );

        dastrScratch.cchString = cchScratch;

        /*
        ** Add and close <ListID> node.
        **
        ** Output:
        ** <RevocationLists>
        **      ...
        **      <RevListInfo>
        **          <ListID>...</ListID>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrLicAcqRevListIDTag,
                                  ( DRM_ANSI_CONST_STRING * )&dastrScratch,
                                  NULL,
                                  NULL,
                                  wttClosed ) );

        ChkDR( DRM_STR_NumberToString( f_poRevListInfo[ i ].m_dwVersion,
                                       rgwchScratch,
                                       DRM_MAX_CCH_BASE10_DWORD_STRING + 1,
                                       0, 10, &cchScratch ) );

        /* Safe to use, input parameter is ASCII */
        DRM_UTL_DemoteUNICODEtoASCII( rgwchScratch, pchScratch, cchScratch );

        dastrScratch.cchString = cchScratch;

        /*
        ** Add and close <Version> node.
        **
        ** Output:
        ** <RevocationLists>
        **      ...
        **      <RevListInfo>
        **          ...
        **          <Version>...</Version>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrLicAcqRevVersionTag,
                                  ( DRM_ANSI_CONST_STRING * )&dastrScratch,
                                  NULL,
                                  NULL,
                                  wttClosed ) );

        /*
        ** Close <RevListInfo> node.
        **
        ** Output:
        ** <RevocationLists>
        **      ...
        **      <RevListInfo>
        **          ...
        **      </RevListInfo>
        */
        ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, NULL ) );
    }

    /*
    ** Close <RevocationLists> node.
    **
    ** Output:
    ** <RevocationLists>
    **      ...
    ** <RevocationLists>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, NULL ) );

ErrorExit:

    /* Allocated the temporary buffer. */
    if ( f_poStackAllocatorContext != NULL && pchScratch != NULL )
    {
        DRM_STK_Free( f_poStackAllocatorContext, pchScratch );
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#endif

/*********************************************************************
**
** Function: _BuildLicenseChallengeDataXML
**
** Synopsis: Function that constructs the data portion of a license
**           acquisition challenge XML. The data portion may be
**           encrypted by XML encryption.
**
** Arguments:
**
** [f_poLicChlgContext]     -- Pointer to a structure that contains all
**                             the information needed to build the license
**                             acquisition challenge.
** [f_pdastrXML]            -- Pointer to a DRM UTF8/ANSI string that is used
**                             to receive a constructed XML string.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildLicenseChallengeDataXML(
    IN DRM_LICCHLG_CONTEXT_V3 *f_poLicChlgContext,
    OUT DRM_ANSI_STRING *f_pdastrXML )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContextA *poXMLContext = NULL;
    DRM_BYTE *pbXMLContext = NULL;
    DRM_DWORD cbXMLContext = 0;
    DRM_CHAR *pchXML = NULL;
    DRM_SUBSTRING dasstrXML = EMPTY_DRM_SUBSTRING;
    DRM_DWORD cchBuffer = 0;
    DRM_CHAR* pchScratch = NULL;
    DRM_ANSI_STRING dastrScratch = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC__BuildLicenseChallengeDataXML );

    ChkArg( f_poLicChlgContext != NULL );
    ChkDRMANSIString( f_pdastrXML );

    /* Calculate the maximum character count needed by temporary buffer. */
    cchBuffer = _GetMaxChallengeTempBufferCount( f_poLicChlgContext );

    ChkBOOL( cchBuffer >= DRM_MAX_CCH_BASE10_DWORD_STRING, DRM_E_INVALIDARG );

    /* Allocate the temporary buffer. */
    ChkDR( DRM_STK_Alloc( &f_poLicChlgContext->m_oStackAllocatorContext,
                          cchBuffer,
                          ( DRM_VOID ** )&pchScratch ) );

    dastrScratch.pszString = pchScratch;

    pbXMLContext = PB_DASTR( f_pdastrXML );
    cbXMLContext = CB_DASTR( f_pdastrXML );

    ChkDR( DRM_UTL_EnsureDataAlignment( pbXMLContext,
                                        cbXMLContext,
                                        ( DRM_BYTE ** )&poXMLContext,
                                        &cbXMLContext,
                                        SIZEOF( DRM_DWORD ),
                                        NULL ) );

    /*
    ** Add and open <Data> node.
    **
    ** Output:
    ** <Data>
    */
    ChkDR( DRM_XMB_CreateDocumentA( cbXMLContext,
                                    ( DRM_BYTE * )poXMLContext,
                                    &g_dastrLicAcqDataTag ) );

    ChkDR( DRM_XMB_GetXMLBaseA( poXMLContext, &pchXML ) );

    /*
    ** Construct the certificate chains XML segment.
    **
    ** Output:
    ** <Data>
    **      ...
    **      <CertificateChains>
    **          ...
    **      </CertificateChains>
    */
    ChkDR( _BuildCertChainsXML( poXMLContext, f_poLicChlgContext ) );

    /*
    ** Close <Data> node.
    **
    ** Output:
    ** <Data>
    **      ...
    ** </Data>
    */
    ChkDR( DRM_XMB_CloseDocumentA( poXMLContext, &dasstrXML ) );

    f_pdastrXML->pszString = pchXML;
    f_pdastrXML->cchString = dasstrXML.m_cch;

    ChkDR( DRM_SOAPXML_PadANSIString( f_pdastrXML, DRM_AES_BLOCKLEN ) );

    DRM_BYT_MoveBytes( pbXMLContext, 0, pchXML, 0, f_pdastrXML->cchString );

    f_pdastrXML->pszString = ( DRM_CHAR * )pbXMLContext;

ErrorExit:

    /* Free the temporary buffer. */
    if ( f_poLicChlgContext != NULL && pchScratch != NULL )
    {
        DRM_STK_Free( &f_poLicChlgContext->m_oStackAllocatorContext, pchScratch );
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _BuildLicenseAcknowledgementDataXML
**
** Synopsis: Function that constructs the data portion of a license
**           acquisition acknowledgement XML. The data portion
**           may be encrypted by XML encryption.
**
** Arguments:
**
** [f_poOEMContext]         -- Pointer to an optional OEM context structure.
** [f_cchDeviceCert]        -- Size ( number of characters ) of a device
**                             certificate.
** [f_pdastrXML]            -- Pointer to a DRM UTF8/ANSI string that is used
**                             to receive a constructed XML string.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildLicenseAcknowledgementDataXML(
    __in_opt DRM_VOID *f_poOEMContext,
    IN DRM_DWORD f_cchDeviceCert,
    OUT DRM_ANSI_STRING *f_pdastrXML )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContextA *poXMLContext = NULL;
    DRM_BYTE *pbXMLContext = NULL;
    DRM_DWORD cbXMLContext = 0;
    DRM_CHAR *pchXML = NULL;
    DRM_SUBSTRING dasstrXML = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrReservedBuffer = EMPTY_DRM_SUBSTRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC__BuildLicenseAcknowledgementDataXML );

    ChkArg( f_cchDeviceCert > 0 );
    ChkDRMANSIString( f_pdastrXML );

    pbXMLContext = PB_DASTR( f_pdastrXML );
    cbXMLContext = CB_DASTR( f_pdastrXML );

    ChkDR( DRM_UTL_EnsureDataAlignment( pbXMLContext,
                                        cbXMLContext,
                                        ( DRM_BYTE ** )&poXMLContext,
                                        &cbXMLContext,
                                        SIZEOF( DRM_DWORD ),
                                        NULL ) );

    /*
    ** Add and open <Data> node.
    **
    ** Output:
    ** <Data>
    */
    ChkDR( DRM_XMB_CreateDocumentA( cbXMLContext,
                                    ( DRM_BYTE * )poXMLContext,
                                    &g_dastrLicAckDataTag ) );

    ChkDR( DRM_XMB_GetXMLBaseA( poXMLContext, &pchXML ) );

    /*
    ** Add and open <CertificateChain> node.
    **
    ** Output:
    ** <Data>
    **      <CertificateChain>
    */
    ChkDR( DRM_XMB_WriteTagA( poXMLContext,
                              &g_dastrLicAckCertificateChainTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    ChkDR( DRM_XMB_ReserveSpaceA( poXMLContext,
                                  SIZEOF( DRM_WORD ),
                                  f_cchDeviceCert,
                                  &dasstrReservedBuffer ) );

    /*
    ** The reserved the buffer should be big enough to store the whole device
    ** certificates. In case the buffer has more bytes needed by the device
    ** certificate, those bytes should be set to ' ' so the server side XML
    ** parser can just ignore them.
    */
    MEMSET( pchXML + __CB_DECL( dasstrReservedBuffer.m_ich ),
            ' ',
            dasstrReservedBuffer.m_cch );

    /*
    ** Construct the device certificate XML segment.
    **
    ** Output:
    ** <Data>
    **      <CertificateChain>
    **          Device certificate
    */

    ChkDR( DRM_SOAPXML_GetDeviceCert(  f_poOEMContext,
                                       TRUE,
                                       pchXML + __CB_DECL( dasstrReservedBuffer.m_ich ),
                                       &dasstrReservedBuffer.m_cch ) );

    /*
    ** Close all nodes that are still open.
    **
    ** Output:
    ** <Data>
    **      ...
    ** </Data>
    */
    ChkDR( DRM_XMB_CloseDocumentA( poXMLContext, &dasstrXML ) );

    f_pdastrXML->pszString = pchXML;
    f_pdastrXML->cchString = dasstrXML.m_cch;

    ChkDR( DRM_SOAPXML_PadANSIString( f_pdastrXML, DRM_AES_BLOCKLEN ) );

    DRM_BYT_MoveBytes( pbXMLContext, 0, pchXML, 0, f_pdastrXML->cchString );

    f_pdastrXML->pszString = ( DRM_CHAR * )pbXMLContext;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _BuildLicenseChallengeXML
**
** Synopsis: Function that constructs a license acquisition challenge
**           XML string.
**
** Arguments:
**
** [f_poXMLContext]         -- Pointer to a XML builder context.
** [f_cbXMLContext]         -- Size ( number of bytes ) of internal buffer
**                             of a XML builder context.
** [f_poLicChlgContext]     -- Pointer to a structure that contains all
**                             the information needed to build the license
**                             acquisition challenge XML.
** [f_pdastrXML]            -- Pointer to a DRM UTF8/ANSI string that is used
**                             to receive a constructed license acquisition
**                             challenge XML string.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_NO_INLINE DRM_RESULT _BuildLicenseChallengeXML(
    IN OUT _XMBContextA *f_poXMLContext,
    IN DRM_DWORD f_cbXMLContext,
    IN DRM_LICCHLG_CONTEXT_V3 *f_poLicChlgContext,
    OUT DRM_ANSI_STRING *f_pdastrXML )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrEncryptedDataNode = EMPTY_DRM_SUBSTRING;
    DRM_ANSI_CONST_STRING dastrEncryptedXML = EMPTY_DRM_STRING;
    DRM_CHAR *pchXML = NULL;
    DRM_SUBSTRING dasstrXML = EMPTY_DRM_SUBSTRING;
    DRM_DWORD cchBuffer = 0;
    DRM_CHAR* pchScratch = NULL;
    DRM_DWORD cchScratch = 0;
    DRM_ANSI_STRING dastrScratch = EMPTY_DRM_STRING;
    DRM_SUBSTRING dasstrCustomData = EMPTY_DRM_SUBSTRING;
    DRM_DWORD cchCustomData = 0;
    DRM_GUID oEmptyGUID = EMPTY_DRM_GUID;
    DRM_SUBSTRING dasstrSignedNode = EMPTY_DRM_SUBSTRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC__BuildLicenseChallengeXML );

    ChkArg( f_poXMLContext != NULL );
    ChkArg( f_cbXMLContext > 0 );
    ChkArg( f_poLicChlgContext != NULL );
    ChkArg( f_poLicChlgContext->m_poBBXContext != NULL );
    ChkDRMString( &f_poLicChlgContext->m_dstrContentHeader );
    ChkArg( f_pdastrXML != NULL );

    /* Calculate the maximum character count needed by temporary buffer. */
    cchBuffer = _GetMaxChallengeTempBufferCount( f_poLicChlgContext );

    ChkBOOL( cchBuffer >= DRM_MAX_CCH_BASE10_DWORD_STRING, DRM_E_INVALIDARG );

    /* Allocate the temporary buffer. */
    ChkDR( DRM_STK_Alloc( &f_poLicChlgContext->m_oStackAllocatorContext,
                          cchBuffer,
                          ( DRM_VOID ** )&pchScratch ) );

    dastrScratch.pszString = pchScratch;

#if DRM_USE_SOAP

    /* Add SOAP headers. */
    ChkDR( DRM_SOAPXML_BuildSOAPHeaderXML( f_poXMLContext, f_cbXMLContext ) );

    /*
    ** Add and open <AcquireLicense> node.
    **
    ** Output:
    ** [<SOAP headers>]
    ** <AcquireLicense>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAcqRootTag,
                              NULL,
                              &g_dastrLicAcqRootAttribName,
                              &g_dastrLicAcqRootAttribValue,
                              wttOpen ) );

#else

    /*
    ** Add and open <AcquireLicense> node.
    **
    ** Output:
    ** <AcquireLicense>
    */
    ChkDR( DRM_XMB_CreateDocumentA( f_cbXMLContext,
                                    ( DRM_BYTE * )f_poXMLContext,
                                    &g_dastrLicAcqRootTag ) );

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrLicAcqRootAttribName,
                                  &g_dastrLicAcqRootAttribValue ) );

#endif

    ChkDR( DRM_XMB_GetXMLBaseA( f_poXMLContext, &pchXML ) );

    /*
    ** Add and open <challenge> node.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcquireLicense>
    **      <challenge>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAcqChallenge1Tag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    /*
    ** Add and open <Challenge> node.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcquireLicense>
    **      <challenge>
    **          <Challenge ...>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAcqChallenge2Tag,
                              NULL,
                              &g_dastrLicAcqChallenge2AttribName,
                              &g_dastrLicAcqChallenge2AttribValue,
                              wttOpen ) );

    /*
    ** Add and open <LA> node.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcquireLicense>
    **      <challenge>
    **          <Challenge ...>
    **              <LA ...>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAcqLATag,
                              NULL,
                              &g_dastrLicAcqChallengeVAAttrib1Name,
                              &g_dastrLicAcqChallengeVAAttrib1Value,
                              wttOpen ) );

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrLicAcqChallengeVAAttrib2Name,
                                  &g_dastrLicAcqChallengeVAAttrib2Value ) );


    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrSOAPPreserveSpaceAttribName,
                                  &g_dastrSOAPPreserveSpaceAttribValue ) );


    /*
    ** Add and close <version> node.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcquireLicense>
    **      <challenge>
    **          <Challenge ...>
    **              <LA ...>
    **                  <Version>...</Version>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAcqVersionTag,
                              &g_dastrLicAcqVersionValue,
                              NULL,
                              NULL,
                              wttClosed ) );

    cchScratch = f_poLicChlgContext->m_dstrContentHeader.cchString;

    ChkBOOL( cchScratch <= cchBuffer, DRM_E_INVALIDARG );

    /* Safe to use, input parameter is ASCII */
    DRM_UTL_DemoteUNICODEtoASCII( f_poLicChlgContext->m_dstrContentHeader.pwszString,
                                  pchScratch,
                                  cchScratch );

    dastrScratch.cchString = cchScratch;

    /*
    ** [<SOAP headers>] ( optional )
    ** Add and close <ContentHeader> node.
    **
    ** Output:
    ** <AcquireLicense>
    **      ...
    **      <challenge>
    **          <Challenge ...>
    **              <LA ...>
    **                  ...
    **                  <ContentHeader>...</ContentHeader>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAcqContentHeaderTag,
                              ( DRM_ANSI_CONST_STRING * )&dastrScratch,
                              NULL,
                              NULL,
                              wttClosed ) );

    /*
    ** Construct the client information XML segment.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcquireLicense>
    **      ...
    **      <challenge>
    **          <Challenge>
    **              <LA ...>
    **                  ...
    **                  <ClientInfo>
    **                      ...
    **                  </ClientInfo>
    */
    ChkDR( _BuildClientInfoXML( f_poXMLContext,
                                &f_poLicChlgContext->m_oStackAllocatorContext,
                                cchBuffer ) );

#if DRM_SUPPORT_REVOCATION

    /*
    ** Construct the revocation version information XML segment.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcquireLicense>
    **      ...
    **      <challenge>
    **          <Challenge ...>
    **              <LA ...>
    **                  ...
    **                  <RevocationLists>
    **                      ...
    **                  </RevocationLists>
    */
    ChkDR( _BuildRevListInfoXML( f_poXMLContext,
                                 &f_poLicChlgContext->m_oStackAllocatorContext,
                                 f_poLicChlgContext->m_rgoRevListInfo,
                                 MAX_REVLIST_INFO,
                                 cchBuffer ) );

#endif

    /* Estimate the size of the XML encoded custom data. */
    ChkDR( DRM_SOAPXML_EncodeData( ( DRM_CHAR * )f_poLicChlgContext->m_dastrCustomData.pszString,
                                   f_poLicChlgContext->m_dastrCustomData.cchString,
                                   NULL,
                                   &cchCustomData ) );

    if ( cchCustomData > 0  )
    {
        ChkDR( DRM_SOAPXML_EnsureTagValueNativeByteAligned( f_poXMLContext, 
                                                            &g_dastrLicAcqCustomDataTag ) );

        /*
        ** Add and open <CustomData> node.
        **
        ** Output:
        ** [<SOAP headers>] ( optional )
        ** <AcquireLicense>
        **      ...
        **      <challenge>
        **          <Challenge ...>
        **              <LA ...>
        **                  ...
        **                  <CustomData>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrLicAcqCustomDataTag,
                                  NULL,
                                  NULL,
                                  NULL,
                                  wttOpen ) );

        ChkDR( DRM_XMB_ReserveSpaceA( f_poXMLContext,
                                      SIZEOF( DRM_BYTE ),
                                      cchCustomData,
                                      &dasstrCustomData ) );

        ChkDR( DRM_SOAPXML_EncodeData( ( DRM_CHAR * )f_poLicChlgContext->m_dastrCustomData.pszString,
                                       f_poLicChlgContext->m_dastrCustomData.cchString,
                                       pchXML + __CB_DECL( dasstrCustomData.m_ich ),
                                       &cchCustomData ) );

        /*
        ** Close <CustomData> node.
        **
        ** Output:
        ** [<SOAP headers>] ( optional )
        ** <AcquireLicense>
        **      ...
        **      <challenge>
        **          <Challenge ...>
        **              <LA ...>
        **                  ...
        **                  <CustomData>...</CustomData>
        */
        ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, NULL ) );
    }

    if ( MEMCMP( &f_poLicChlgContext->m_oNonce, &oEmptyGUID, SIZEOF( DRM_GUID ) ) != 0 )
    {
        cchScratch = CCH_BASE64_EQUIV( SIZEOF( DRM_ID ) );

        ChkBOOL( cchScratch <= cchBuffer, DRM_E_INVALIDARG );

        ChkDR( DRM_B64_EncodeA( ( DRM_BYTE * )&f_poLicChlgContext->m_oNonce,
                                SIZEOF( DRM_ID ),
                                pchScratch,
                                &cchScratch,
                                0 ) );

        dastrScratch.cchString = cchScratch;

        /*
        ** Construct the license nonce XML segment.
        **
        ** Output:
        ** [<SOAP headers>] ( optional )
        ** <AcquireLicense>
        **      ...
        **      <challenge>
        **          <Challenge>
        **              <LA ...>
        **                  ...
        **                  <LicenseNonce>
        **                      ...
        **                  </LicenseNonce>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrLicAcqLicenseNonceTag,
                                  ( DRM_ANSI_CONST_STRING * )&dastrScratch,
                                  NULL,
                                  NULL,
                                  wttClosed ) );
    }

    ChkDR( DRM_XMB_GetCurrentBufferPointerA( f_poXMLContext,
                                             TRUE,
                                             ( DRM_CHAR ** )&dastrEncryptedXML.pszString ) );

    dastrEncryptedXML.cchString = _CalcLicenseChallengeDataCharCount( f_poLicChlgContext );

    /*
    ** Construct the data portion of the license acquisition challenge XML.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcquireLicense>
    **      ...
    **      <challenge>
    **          <Challenge ...>
    **              <LA ...>
    **                  ...
    **                  <Data>
    **                      ...
    **                  </Data>
    */
    ChkDR( _BuildLicenseChallengeDataXML( f_poLicChlgContext,
                                          ( DRM_ANSI_STRING * )&dastrEncryptedXML ) );

    /* AES encrypt the data portion of the license acquisition challenge XML. */
    ChkDR( DRM_SOAPXML_EncryptDataWithXMLKey( f_poLicChlgContext->m_poBBXContext->pOEMContext,
                                              &f_poLicChlgContext->m_oXMLKey,
                                              &dastrEncryptedXML,
                                              &f_poLicChlgContext->m_poBBXContext->CryptoContext) );

    /*
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcquireLicense>
    **      ...
    **      <challenge>
    **          <Challenge ...>
    **              <LA ...>
    **                  ...
    **                  <EncryptedData>
    **                      ...
    **                  </EncryptedData>
    */
    ChkDR( DRM_XMLSIG_BuildEncryptedDataNode( f_poXMLContext,
                                              &f_poLicChlgContext->m_oXMLKey,
                                              dastrEncryptedXML.cchString,
                                              &dasstrEncryptedDataNode ) );

    /*
    ** Close <LA> node
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, &dasstrSignedNode ) );

    /* The whole <LA> node (inclusive) is signed. */
    ChkDR( DRM_XMLSIG_BuildSignatureNode( f_poXMLContext,
                                          f_poLicChlgContext->m_poBBXContext,
                                          pchXML,
                                          &dasstrSignedNode ) );


    ChkDR( DRM_XMB_GetXMLBaseA( f_poXMLContext, &pchXML ) );

    /*
    ** Close all nodes that are still open.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcquireLicense>
    **      ...
    ** </AcquireLicense>
    */
    ChkDR( DRM_XMB_CloseDocumentA( f_poXMLContext, &dasstrXML ) );

    f_pdastrXML->pszString = pchXML;
    f_pdastrXML->cchString = dasstrXML.m_cch;

ErrorExit:

    /* Free the temporary buffer. */
    if ( f_poLicChlgContext != NULL && pchScratch != NULL )
    {
        DRM_STK_Free( &f_poLicChlgContext->m_oStackAllocatorContext, pchScratch );
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _BuildLicenseAcknowledgementXML
**
** Synopsis: Function that constructs a license acquisition acknowledgement
**           XML string.
**
** Arguments:
**
** [f_poXMLContext]         -- Pointer to a XML builder context.
** [f_cbXMLContext]         -- Size ( number of bytes ) of internal buffer
**                             of a XML builder context.
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_poStackAllocatorContext]
**                          -- Pointer to a stack allocator context.
** [f_pdastrTransactionID]  -- Pointer to a DRM ANSI string that contains a
**                             transaction ID.
** [f_poLicAcks]            -- An array of license acknowlegement structures
**                             that store the results of license processing.
** [f_cLicAcks]             -- Total number of elements of the license
**                             acknowledgement structures in the array
**                             mentioned above.
** [f_cchDeviceCert]        -- Size ( number of characters ) of a device
**                             certificate.
** [f_pdastrXML]            -- Pointer to a DRM UTF8/ANSI string that is used
**                             to receive a constructed XML string.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildLicenseAcknowledgementXML(
    IN OUT _XMBContextA *f_poXMLContext,
    IN DRM_DWORD f_cbXMLContext,
    IN DRM_BB_CONTEXT *f_poBBXContext,
    IN DRM_STACK_ALLOCATOR_CONTEXT *f_poStackAllocatorContext,
    IN DRM_ANSI_CONST_STRING *f_pdastrTransactionID,
    IN DRM_LICENSE_ACK *f_poLicAcks,
    IN DRM_DWORD f_cLicAcks,
    IN DRM_DWORD f_cchDeviceCert,
    IN DRM_XML_KEY *f_poXMLKey,
    OUT DRM_ANSI_STRING *f_pdastrXML )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrSignedNode = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrEncryptedDataNode = EMPTY_DRM_SUBSTRING;
    DRM_ANSI_CONST_STRING dastrEncryptedXML = EMPTY_DRM_STRING;
    DRM_CHAR *pchXML = NULL;
    DRM_SUBSTRING dasstrXML = EMPTY_DRM_SUBSTRING;
    DRM_DWORD cchBuffer = 0;
    DRM_CHAR* pchScratch = NULL;
    DRM_DWORD cchScratch = 0;
    DRM_ANSI_STRING dastrScratch = EMPTY_DRM_STRING;
    DRM_DWORD i = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC__BuildLicenseAcknowledgementXML );

    ChkArg( f_poXMLContext != NULL );
    ChkArg( f_cbXMLContext > 0 );
    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_poStackAllocatorContext != NULL );
    ChkDRMANSIString( f_pdastrTransactionID );
    ChkArg( ( f_cLicAcks > 0 && f_poLicAcks != NULL ) ||
            ( f_cLicAcks == 0 && f_poLicAcks == NULL ) );
    ChkArg( f_cchDeviceCert > 0 );
    ChkArg( f_poXMLKey != NULL );
    ChkArg( f_pdastrXML != NULL );

    /* Calculate the maximum character count needed by temporary buffer. */
    cchBuffer = _GetMaxAcknowledgementTempBufferCount();

    ChkBOOL( cchBuffer >= DRM_MAX_CCH_BASE10_DWORD_STRING, DRM_E_INVALIDARG );

    /* Allocate the temporary buffer. */
    ChkDR( DRM_STK_Alloc( f_poStackAllocatorContext, cchBuffer, ( DRM_VOID ** )&pchScratch ) );

    dastrScratch.pszString = pchScratch;

#if DRM_USE_SOAP

    /* Add SOAP headers. */
    ChkDR( DRM_SOAPXML_BuildSOAPHeaderXML( f_poXMLContext, f_cbXMLContext ) );

    /*
    ** Add and open <AcknowledgeLicense> node.
    **
    ** Output:
    ** [<SOAP headers>]
    ** <AcknowledgeLicense>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAckRootTag,
                              NULL,
                              &g_dastrLicAckRootAttribName,
                              &g_dastrLicAckRootAttribValue,
                              wttOpen ) );

#else

    /*
    ** Add and open <AcknowledgeLicense> node.
    **
    ** Output:
    ** <AcknowledgeLicense>
    */
    ChkDR( DRM_XMB_CreateDocumentA( f_cbXMLContext,
                                    ( DRM_BYTE * )f_poXMLContext,
                                    &g_dastrLicAckRootTag ) );

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrLicAckRootAttribName,
                                  &g_dastrLicAckRootAttribValue ) );

#endif

    /*
    ** Add and open <challenge> node.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcknowledgeLicense>
    **      <challenge>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAckChallenge1Tag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    /*
    ** Add and open <Challenge> node.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcknowledgeLicense>
    **      <challenge>
    **          <Challenge>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAckChallenge2Tag,
                              NULL,
                              &g_dastrLicAckChallenge2AttribName,
                              &g_dastrLicAckChallenge2AttribValue,
                              wttOpen ) );

    /*
    ** Add and open <Ack> node.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcknowledgeLicense>
    **      ...
    **      <challenge>
    **          <Challenge>
    **              <Ack ...>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAckAckTag,
                              NULL,
                              &g_dastrLicAckAckAttrib1Name,
                              &g_dastrLicAckAckAttrib1Value,
                              wttOpen ) );

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrLicAckAckAttrib2Name,
                                  &g_dastrLicAckAckAttrib2Value ) );


    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrSOAPPreserveSpaceAttribName,
                                  &g_dastrSOAPPreserveSpaceAttribValue ) );

    /*
    ** Add and close <Version> node.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcknowledgeLicense>
    **      <challenge>
    **          <Challenge>
    **              <Ack ...>
    **                  <Version>...</Version>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAckVersionTag,
                              &g_dastrLicAckVersionValue,
                              NULL,
                              NULL,
                              wttClosed ) );

    /*
    ** Add and close <TransactionID> node.
    **
    ** Output:
   ** [<SOAP headers>] ( optional )
    ** <AcknowledgeLicense>
    **      ...
    **      <challenge>
    **          <Challenge>
    **              <Ack>
    **                  <TransactionID>...</TransactionID>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAckTransactionIDTag,
                              f_pdastrTransactionID,
                              NULL,
                              NULL,
                              wttClosed ) );

    /*
    ** Add and open <LicenseStorageResults> node.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcknowledgeLicense>
    **      ...
    **      <challenge>
    **          <Challenge>
    **              <Ack>
    **                  ...
    **                  <LicenseStorageResults>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrLicAckLicenseStorageResultsTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    for ( i = 0; i < f_cLicAcks; i++ )
    {
        /*
        ** Add and open <Licenses> node.
        **
        ** Output:
        ** [<SOAP headers>] ( optional )
        ** <AcknowledgeLicense>
        **      ...
        **      <challenge>
        **          <Challenge>
        **              <Ack>
        **                  ...
        **                  <LicenseStorageResults>
        **                      ...
        **                      <License>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrLicAckLicenseTag,
                                  NULL,
                                  NULL,
                                  NULL,
                                  wttOpen ) );

        cchScratch = CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) );

        ChkBOOL( cchScratch <= cchBuffer, DRM_E_INVALIDARG );

        ChkDR( DRM_B64_EncodeA( ( DRM_BYTE * )&f_poLicAcks[ i ].m_oKID,
                                SIZEOF( DRM_GUID ),
                                pchScratch,
                                &cchScratch,
                                0 ) );

        dastrScratch.cchString = cchScratch;

        /*
        ** Add and close <KID> node.
        **
        ** Output:
        ** [<SOAP headers>] ( optional )
        ** <AcknowledgeLicense>
        **      ...
        **      <challenge>
        **          <Challenge>
        **              <Ack>
        **                  ...
        **                  <LicenseStorageResults>
        **                      ...
        **                      <License>
        **                          <KID>...</KID>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrLicAckKIDTag,
                                  ( DRM_ANSI_CONST_STRING * )&dastrScratch,
                                  NULL,
                                  NULL,
                                  wttClosed ) );

        cchScratch = CCH_BASE64_EQUIV( SIZEOF( DRM_GUID ) );

        ChkBOOL( cchScratch <= cchBuffer, DRM_E_INVALIDARG );

        ChkDR( DRM_B64_EncodeA( ( DRM_BYTE * )&f_poLicAcks[ i ].m_oLID,
                                SIZEOF( DRM_GUID ),
                                pchScratch,
                                &cchScratch,
                                0 ) );

        dastrScratch.cchString = cchScratch;

        /*
        ** Add and close <LID> node.
        **
        ** Output:
        ** [<SOAP headers>] ( optional )
        ** <AcknowledgeLicense>
        **      ...
        **      <challenge>
        **          <Challenge>
        **              <Ack>
        **                  ...
        **                  <LicenseStorageResults>
        **                      ...
        **                      <License>
        **                          ...
        **                          <LID>...</LID>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrLicAckLIDTag,
                                  ( DRM_ANSI_CONST_STRING * )&dastrScratch,
                                  NULL,
                                  NULL,
                                  wttClosed ) );

        cchScratch = cchBuffer;

        ChkDR( _DRMResultToANSIString( f_poLicAcks[ i ].m_dwResult, pchScratch, &cchScratch ) );

        dastrScratch.cchString = cchScratch;

        /*
        ** Add and close <Result> node.
        **
        ** Output:
        ** [<SOAP headers>] ( optional )
        ** <AcknowledgeLicense>
        **      ...
        **      <challenge>
        **          <Challenge>
        **              <Ack>
        **                  ...
        **                  <LicenseStorageResults>
        **                      ...
        **                      <License>
        **                          ...
        **                          <Result>...</Result>
        */
        ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                                  &g_dastrLicAckResultTag,
                                  ( DRM_ANSI_CONST_STRING * )&dastrScratch,
                                  NULL,
                                  NULL,
                                  wttClosed ) );

        /*
        ** Close <License> node.
        **
        ** Output:
        ** [<SOAP headers>] ( optional )
        ** <AcknowledgeLicense>
        **      ...
        **      <challenge>
        **          <Challenge>
        **              <Ack>
        **                  ...
        **                  <LicenseStorageResults>
        **                      ...
        **                      <License>
        **                          ...
        **                      </License>
        */
        ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, NULL ) );
    }

    /*
    ** Close <LicenseStorageResults> node.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcknowledgeLicense>
    **      ...
    **      <challenge>
    **          <Challenge>
    **              <Ack>
    **                  ...
    **                  <LicenseStorageResults>
    **                      ...
    **                  </LicenseStorageResults>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, NULL ) );

    ChkDR( DRM_XMB_GetCurrentBufferPointerA( f_poXMLContext,
                                             TRUE,
                                             ( DRM_CHAR ** )&dastrEncryptedXML.pszString ) );

    dastrEncryptedXML.cchString = _CalcLicenseAcknowledgementDataCharCount( f_cchDeviceCert );

    /*
    ** Construct the data portion of the license acquisition acknowledgement XML.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcknowledgeLicense>
    **      ...
    **      <challenge>
    **          <Challenge>
    **              <Ack>
    **                  ...
    **                  <Data>
    **                      <CertificateChain>
    **                          ...
    **                      </CertificateChain>
    **                  </Data>
    */
    ChkDR( _BuildLicenseAcknowledgementDataXML( f_poBBXContext->pOEMContext,
                                                f_cchDeviceCert,
                                                ( DRM_ANSI_STRING * )&dastrEncryptedXML ) );

    /* XML encrypt the data portion of the license acquisition acknowledgement XML. */
    ChkDR( DRM_SOAPXML_EncryptDataWithXMLKey( f_poBBXContext->pOEMContext,
                                              f_poXMLKey,
                                              &dastrEncryptedXML,
                                              &f_poBBXContext->CryptoContext) );


    /*
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcknowledgeLicense>
    **      ...
    **      <challenge>
    **          <Challenge>
    **              <Ack>
    **                  ...
    **                  <EncryptedData>
    **                      ...
    **                  </EncryptedData>
    */
    ChkDR( DRM_XMLSIG_BuildEncryptedDataNode( f_poXMLContext,
                                              f_poXMLKey,
                                              dastrEncryptedXML.cchString,
                                              &dasstrEncryptedDataNode ) );

    ChkDR( DRM_XMB_GetXMLBaseA( f_poXMLContext, &pchXML ) );

    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContext, &dasstrSignedNode ) );

    /*
    ** The whole <Ack> node ( inclusive ) is signed.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcknowledgeLicense>
    **      ...
    **      <challenge>
    **          <Challenge>
    **              <Ack>
    **                  ...
    **              </Ack>
    **              <Signature>
    **                  ...
    **              </Signature>
    */
    ChkDR( DRM_XMLSIG_BuildSignatureNode( f_poXMLContext,
                                          f_poBBXContext,
                                          pchXML,
                                          &dasstrSignedNode ) );

    ChkDR( DRM_XMB_GetXMLBaseA( f_poXMLContext, &pchXML ) );

    /*
    ** Close all nodes that are still open.
    **
    ** Output:
    ** [<SOAP headers>] ( optional )
    ** <AcknowledgeLicense>
    **      ...
    ** </AcknowledgeLicense>
    */
    ChkDR( DRM_XMB_CloseDocumentA( f_poXMLContext, &dasstrXML ) );

    f_pdastrXML->pszString = pchXML;
    f_pdastrXML->cchString = dasstrXML.m_cch;

ErrorExit:

    /* Free the temporary buffer. */
    if ( f_poStackAllocatorContext != NULL && pchScratch != NULL )
    {
        DRM_STK_Free( f_poStackAllocatorContext, pchScratch );
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_LA_ParseServiceID
**
** Synopsis: Function that parses out a service ID from
**           the content header.
**
** Arguments:
**
** [f_pdstrContentHeader]   -- Pointer to a DRM string that contains the
**                             content header.
** [f_pServiceID]           -- Pointer to a GUID to receive a parsed out
**                             service ID.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_CH_INVALID_HEADER if header has a service
**                          ID which is not a base-64 encoded GUID
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LA_ParseServiceID(
    IN  const DRM_CONST_STRING *f_pdstrContentHeader,
    OUT       DRM_GUID         *f_pServiceID )
{
    DRM_RESULT          dr              = DRM_SUCCESS;
    DRM_CONST_STRING    dstrServiceID   = EMPTY_DRM_STRING;
    DRM_DWORD           cbServiceID     = sizeof( *f_pServiceID );

    ChkArg( f_pdstrContentHeader != NULL );

    /* Try to extract the service ID from the content header. */
    dr = DRM_HDR_GetAttribute( f_pdstrContentHeader,
                                NULL,
                                DRM_HEADER_ATTRIB_DOMAIN_SERVICE_ID,
                               &dstrServiceID,
                                0 );

    if( dr != DRM_E_XMLNOTFOUND )
    {
        /* Service ID tag could be found or not, all other error should be thrown to caller */
        ChkDR( dr );

        ChkDR( DRM_B64_DecodeW( &dstrServiceID,
                                &cbServiceID,
                                ( DRM_BYTE * )f_pServiceID,
                                0 ) );

        ChkBOOL( cbServiceID == SIZEOF( DRM_GUID ), DRM_E_CH_INVALID_HEADER );
    }
    else
    {
        dr = DRM_SUCCESS;
    }

ErrorExit:
    return dr;
}

/*********************************************************************
**
** Function: DRM_LA_ParseLicenseAcquisitionURL
**
** Synopsis: Function that parses out a license acquisition URL from
**           the content header.
**
** Arguments:
**
** [f_pdstrContentHeader]   -- Pointer to a DRM string that contains the
**                             content header.
** [f_fSilent]              -- Whether silent or non silent URL license
**                             acquisition URL should be returned. TRUE for
**                             silent license acquisition URL and FALSE for
**                             non silent license acquisition URL.
** [f_pchURL]               -- Pointer to a buffer to receive a parsed out
**                             URL. If it is NULL, the function returns an
**                             error and the size of the required buffer
**                             is stored in *f_pcchURL.
** [f_pcchURL]              -- Pointer to a variable that contains the size
**                             ( in characters ) of the URL buffer during input
**                             and receives the size ( in characters ) of the
**                             URL during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_NO_URL if URL cannot be parsed out from
**                          the content header.
**
** Note: The function converts the URL in the content header from Unicode
** to UTF8/ANSI.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LA_ParseLicenseAcquisitionURL(
    IN     const DRM_CONST_STRING *f_pdstrContentHeader,
    IN           DRM_BOOL          f_fSilent,
    __out_ecount_opt( *f_pcchURL ) DRM_CHAR *f_pchURL,
    IN OUT       DRM_DWORD        *f_pcchURL )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrURL = EMPTY_DRM_STRING;
    DRM_DWORD cchTemp = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC__ParseLicenseAcquisitionURL );

    ChkDRMString( f_pdstrContentHeader );
    ChkArg( f_pcchURL != NULL );
    ChkArg( f_pchURL == NULL || *f_pcchURL > 0 );

    dr = DRM_HDR_GetAttribute( f_pdstrContentHeader,
                               NULL,
                               f_fSilent ? DRM_HEADER_ATTRIB_LICENSE_ACQ_V4_URL :
                                           DRM_HEADER_ATTRIB_LICENSE_UI_URL,
                               &dstrURL,
                               0 );

    if ( DRM_FAILED( dr ) )
    {
        ChkDR( DRM_E_NO_URL );
    }

    if ( f_pchURL == NULL || *f_pcchURL < dstrURL.cchString + 1 )
    {
        *f_pcchURL = dstrURL.cchString + 1;

        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    if ( dstrURL.cchString > 0 )
    {
        cchTemp = *f_pcchURL - 1;

        ChkDR( DRM_UTL_XMLDecodeUA( dstrURL.pwszString,
                                    dstrURL.cchString,
                                    f_pchURL,
                                    &cchTemp ) );

        DRMASSERT( cchTemp < *f_pcchURL );

        /*
        ** PreFAST tool can't verify above assert is always true.
        */
        ChkBOOL( cchTemp < *f_pcchURL, DRM_E_FAIL );

        f_pchURL[ cchTemp ] = 0;

        *f_pcchURL = cchTemp + 1;
    }
    else
    {
        f_pchURL[ 0 ] = 0;

        *f_pcchURL = 1;
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#if DRM_SUPPORT_LICENSE_SYNC

/*********************************************************************
**
** Function: _UpdateSyncStore
**
** Synopsis: Function that updates the content header related to a KID
**           in the sync store.
**           The license evaluation context in the passed in view rights
**           context should have the content header.
**
** Arguments:
**
** [f_poSyncStoreContext]   -- Pointer to an initialized sync store context.
** [f_poViewRightsContext]  -- Pointer to an initialized view rights context.
** [f_poKID]                -- Pointer to a KID whose content header is to
**                             be updated in the sync store.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_RESULT _UpdateSyncStore(
    IN DRM_SYNC_CONTEXT *f_poSyncStoreContext,
    IN DRM_VIEW_RIGHTS_CONTEXT *f_poViewRightsContext,
    IN DRM_KID *f_poKID )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_poSyncStoreContext != NULL );
    ChkArg( f_poViewRightsContext != NULL );
    ChkArg( f_poKID != NULL );

    ChkDR( DRM_SNC_UpdateKID( f_poSyncStoreContext,
                              f_poViewRightsContext,
                              f_poKID,
                              NULL,
                              FALSE ) );

ErrorExit:

    return dr;
}

#endif

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
/*********************************************************************
**
** Function: _ExtractSLKDataFromLicenseResponse
**
** Synopsis: Function that extracts SLK data from a PC response
**           string and then processes and returns the ID
**
** Arguments:
**
** [f_poLicRespContext]     -- Pointer to a data structure that contains
**                             information needed to process licenses.
** [f_pszResponse]          -- Pointer to a character buffer that contains
**                             the server response.
** [f_pdasstrResponse]      -- Pointer to a sub string that defines the License Acq string
**                             ( pre-B64 decoded ) within the server
**                             response buffer.
** [f_pSLKData]             -- Pointer to a variable that receives the SLK data
** [f_pfValidSLK]           -- Returns whether a valid SLK was found
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_INVALID_SLK if an invalid SLK was parsed from response
**
**********************************************************************/
static DRM_RESULT _ExtractSLKDataFromLicenseResponse(
    IN DRM_LICRESP_CONTEXT_V3 *f_poLicRespContext,
    IN DRM_CHAR *f_pszResponse,
    IN DRM_SUBSTRING *f_pdasstrResponse,
    OUT DRM_SLKDATA *f_pSLKData,
    OUT DRM_BOOL *f_pfValidSLK )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrSLKData = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrSLKNodeData = EMPTY_DRM_SUBSTRING;
    DRM_ID idSLKNew = { 0 };
    DRM_DWORD cbidSLK = SIZEOF( idSLKNew );
    DRM_BYTE rgbSLKKey[ __CB_DECL( ECC_P256_CIPHERTEXT_SIZE_IN_BYTES ) ] = { 0 };

    ChkArg( f_poLicRespContext != NULL );
    ChkArg( f_pszResponse != NULL );
    ChkArg( f_pdasstrResponse != NULL );
    ChkArg( f_pfValidSLK != NULL );
    ChkArg( f_pSLKData != NULL );

    *f_pfValidSLK = FALSE;

    /*
    ** Attempt to read an SLK node: For symmetrically optimized ILA licenses
    */
    dr = DRM_XML_GetSubNodeByPathA( f_pszResponse,
                                    f_pdasstrResponse,
                                    &g_dastrLicSLKPath,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &dasstrSLKData,
                                    g_chForwardSlash );
    if ( DRM_SUCCEEDED( dr ) )
    {
        ChkDR( DRM_XML_GetNodeA( f_pszResponse,
                                 &dasstrSLKData,
                                 &g_dastrTagSLKID,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                &dasstrSLKNodeData ) );

        ChkDR( DRM_B64_DecodeA( f_pszResponse,
                                &dasstrSLKNodeData,
                                &cbidSLK,
                                ( DRM_BYTE * )&idSLKNew,
                                0 ) );

        /*
        ** Update the SLK if the ID doesn't match the existing one
        */
        if ( DRM_FAILED( DRM_LA_GetSLK( f_pSLKData,
                                        f_poLicRespContext->m_poDatastore,
                                        f_poLicRespContext->m_poLicEvalContext ) ) ||
            MEMCMP( &idSLKNew, &f_pSLKData->idSLK, SIZEOF( DRM_ID ) ) != 0 )
        {
            ChkDR( DRM_XML_GetNodeA( f_pszResponse,
                                     &dasstrSLKData,
                                     &g_dastrTagSLKDATA,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     &dasstrSLKNodeData ) );

            cbidSLK = ECC_P256_CIPHERTEXT_SIZE_IN_BYTES;

            ChkDR( DRM_B64_DecodeA( f_pszResponse,
                                    &dasstrSLKNodeData,
                                    &cbidSLK,
                                    rgbSLKKey,
                                    0 ) );

            ChkBOOL( cbidSLK == ECC_P256_CIPHERTEXT_SIZE_IN_BYTES,
                     DRM_E_INVALID_SLK );

            ChkDR( DRM_LA_UpdateSLK( &idSLKNew,
                                     rgbSLKKey,
                                     ECC_P256_CIPHERTEXT_SIZE_IN_BYTES,
                                     f_poLicRespContext->m_poDatastore,
                                     f_poLicRespContext->m_poLicEvalContext,
                                     f_pSLKData ) );
        }

        *f_pfValidSLK = TRUE;
    }
    else if ( dr == DRM_E_XMLNOTFOUND )
    {
        dr = DRM_SUCCESS;
    }
    else
    {
        ChkDR( dr );
    }

ErrorExit:

    return dr;
}
#endif /* DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS */

#if DRM_SUPPORT_REVOCATION

/*********************************************************************
**
** Function: DRM_LA_ProcessRevocationPackage
**
** Synopsis: Function that extracts the revocation information from a
**           server response string and then processes and stores the
**           received revocation information.
**
** Arguments:
**
** [f_poLicRespContext]     -- Pointer to a data structure that contains
**                             information needed to process licenses.
** [f_pszResponse]          -- Pointer to a character buffer that contains
**                             the server response.
** [f_pcProcessed]          -- Pointer to a variable that receives the total number
**                             of revocation nodes processed.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_LRB_INVALID_REVOCATION_PACKAGE if XML structure
**                          of response is invalid
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LA_ProcessRevocationPackage(
    IN DRM_LICRESP_CONTEXT_V3 *f_poLicRespContext,
    IN DRM_ANSI_CONST_STRING *f_pdastrResponse,
    OUT DRM_DWORD *f_pcProcessed )
{
#if DRM_SUPPORT_REVOCATION
    DRM_RESULT    dr                    = DRM_SUCCESS;
    DRM_SUBSTRING dasstrRevInfo         = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrRevocation      = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrRevocationNode  = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrListId          = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrListData        = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrResponse        = EMPTY_DRM_SUBSTRING;
    DRM_BOOL      fFoundRevInfo = FALSE;
    DRM_BOOL      fRevInfoPass = FALSE;
    DRM_DWORD     iRevInfoNode = 0;
    DRM_DWORD     iNode = 0;
    DRM_GUID      guidCRL = {0};
    DRM_DWORD     cbCRL = SIZEOF( DRM_GUID );
    DRM_BYTE     *pbDecoded = NULL;
    DRM_DWORD     cbDecoded = 0;
    DRM_DWORD     cbAligned = 0;
    DRM_BYTE     *pbAligned = NULL;
    DRM_BOOL      fUpdated = FALSE;


    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC__ExtractRevInfoFromLicenseResponse );

    ChkArg( f_poLicRespContext != NULL );
    ChkArg( f_pdastrResponse != NULL );
    ChkArg( f_pdastrResponse->pszString != NULL );
    ChkArg( f_pcProcessed != NULL );

    *f_pcProcessed = 0;

    dasstrResponse.m_ich = 0;
    dasstrResponse.m_cch = f_pdastrResponse->cchString;

#if DRM_USE_SOAP
    dr = DRM_SOAPXML_SkipSOAPHeaders( ( DRM_CHAR * )f_pdastrResponse->pszString,
                                        &dasstrResponse );
    if( dr == DRM_E_SOAPXML_XML_FORMAT )
    {
        /* It's fine if there was no SOAP wrapper */
        dasstrResponse.m_ich = 0;
        dasstrResponse.m_cch = f_pdastrResponse->cchString;
        dr = DRM_SUCCESS;
    }
    else
    {
        ChkDR( dr );
    }
#endif /* DRM_USE_SOAP */

    /*
    ** Extract <RevInfo> node from
    ** <AcquireLicenseResponse>/<AcquireLicenseResult>/<LicenseResponse> node or by itself.
    */
    if ( DRM_FAILED( DRM_XML_GetSubNodeByPathA( f_pdastrResponse->pszString,
                                                &dasstrResponse,
                                                &g_dastrLicRevInfoPath,
                                                NULL,
                                                NULL,
                                                NULL,
                                                &dasstrRevInfo,
                                                g_chForwardSlash ) ) )
    {
        if ( DRM_FAILED( DRM_XML_GetNodeA( f_pdastrResponse->pszString,
                                           &dasstrResponse,
                                           &g_dastrRevInfo,
                                           NULL,
                                           NULL,
                                           0,
                                           NULL,
                                           &dasstrRevInfo ) ) )
        {
            /*
             *  Check if provided xml has required node
             */
            if ( DRM_FAILED( DRM_XML_GetNodeA( f_pdastrResponse->pszString,
                                               &dasstrResponse,
                                               &g_dastrAcquireLicenseResponseTag,
                                               NULL,
                                               NULL,
                                               0,
                                               NULL,
                                               &dasstrRevInfo ) ) )
            {
                dr = DRM_E_REVOCATION_INVALID_PACKAGE ;
            }
            else
            {
                dr = DRM_SUCCESS;
            }
            goto ErrorExit;
        }
    }

    /*
    ** Iterate through the list looking for CRLs:
    ** 1. On the first pass, store CRLs but skip over RevInfo blobs (while
    **    remembering where we found them)
    ** 2. When all the CRLs have been updated, go back and process the one
    **    RevInfo blob we might have found.
    */
    for ( iNode = 0; TRUE; iNode++ )
    {
        /* Read one <Revocation> node from the <RevInfo> node. */
        dr = DRM_XML_GetNodeA( f_pdastrResponse->pszString,
                               &dasstrRevInfo,
                               &g_dastrLicRevocationPath,
                               NULL,
                               NULL,
                               fRevInfoPass ? iRevInfoNode : iNode,
                               &dasstrRevocationNode,
                               &dasstrRevocation );

        if ( dr == DRM_E_XMLNOTFOUND )
        {
            if ( fRevInfoPass || !fFoundRevInfo )
            {
                ChkDR( DRM_SUCCESS );

                break;
            }
            else
            {
                fRevInfoPass = TRUE;
                continue;
            }
        }
        else
        {
            ChkDR( dr );
        }

        /* Get ListId information */
        ChkDR( DRM_XML_GetNodeA( f_pdastrResponse->pszString,
                                 &dasstrRevocation,
                                 &g_dastrLicListIdPath,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 &dasstrListId ) );

        /* Get ListData information */
        ChkDR( DRM_XML_GetNodeA( f_pdastrResponse->pszString,
                                 &dasstrRevocation,
                                 &g_dastrLicListDataPath,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 &dasstrListData ) );

        /* Process the revocation information. */
        ChkDR( DRM_B64_DecodeA( f_pdastrResponse->pszString,
                        &dasstrListId,
                        &cbCRL,
                        ( DRM_BYTE * )&guidCRL,
                        0 ) ) ;

        ChkBOOL( cbCRL == SIZEOF( DRM_GUID ), DRM_E_INVALID_REVOCATION_LIST );

        if( !fRevInfoPass && MEMCMP( &guidCRL, &g_guidRevocationTypeRevInfo, SIZEOF( DRM_GUID ) ) == 0 )
        {
            if( !fFoundRevInfo )
            {
                fFoundRevInfo = TRUE;
                iRevInfoNode = iNode;
            }
            continue;
        }
        else if( !fRevInfoPass && MEMCMP( &guidCRL, &g_guidRevocationTypeRevInfo2, SIZEOF( DRM_GUID ) ) == 0 )
        {
            fFoundRevInfo = TRUE;
            iRevInfoNode = iNode;
            continue;
        }

         /* pbAligned will point within the base64 revocation list we were passed,
           such that after base64 decoding the end of the decoded data will co-incide with
           the end of the buffer we were given, minus one byte.

           This is because we are giving the B64 decoder overlapping memory for source and destination,
           and we can't use the DECODE_IN_PLACE flag because this is ANSI where the offset may not coincide
           with a word boundary as required on 16-bit platforms.
         */

         pbDecoded = (DRM_BYTE*)f_pdastrResponse->pszString
                            + __CB_DECL( dasstrListData.m_ich + dasstrListData.m_cch - CB_BASE64_DECODE( dasstrListData.m_cch ) - 1 )
                            + ( ( dasstrListData.m_ich + dasstrListData.m_cch - CB_BASE64_DECODE( dasstrListData.m_cch ) ) % CB_NATIVE_BYTE );

        cbDecoded = CB_BASE64_DECODE( dasstrListData.m_cch ) + 1 - ( ( dasstrListData.m_ich + dasstrListData.m_cch - CB_BASE64_DECODE( dasstrListData.m_cch ) ) % CB_NATIVE_BYTE );

        /* Ensure the pointer is DRM_WCHAR aligned */
        ChkDR( DRM_UTL_EnsureDataAlignment( pbDecoded, cbDecoded, &pbAligned, &cbAligned, SIZEOF( DRM_WCHAR ), NULL ) );
        ChkBOOL( cbAligned >= CB_BASE64_DECODE( dasstrListData.m_cch ), DRM_E_BUFFERTOOSMALL );

        /* decode the XML for the new exclusion list in place */
        ChkDR( DRM_B64_DecodeA( f_pdastrResponse->pszString,
                               &dasstrListData,
                               &cbAligned,
                                pbAligned,
                                0 ) );

        dr = DRM_RVK_SetCRL( &f_poLicRespContext->m_poBBXContext->CryptoContext,
                              f_poLicRespContext->m_poRevStoreContext,
                             &guidCRL,
                              pbAligned,
                              cbAligned,
                              f_poLicRespContext->m_poLicEvalContext->pbRevocationBuffer,
                              f_poLicRespContext->m_poLicEvalContext->cbRevocationBuffer,
                             &fUpdated);

        /* Since we decoded in-place, we need to clean up otherwise the XML parsing may
         * not work properly later on. So we have to overwrite our binary with spaces.
         *
         * NOTE: This means that we CANNOT process the same revocation list in the same
         * license response buffer twice since we're overwriting the buffer we were given
         */
        DRM_BYT_SetBytes( (DRM_CHAR*)f_pdastrResponse->pszString, dasstrListData.m_ich, dasstrListData.m_cch, ' ');
        ChkDR( dr );

        (*f_pcProcessed)++;

        if( fRevInfoPass )
        {
            /* If we processed the revinfo then we're done */
            break;
        }
    }

ErrorExit:

    if ( fUpdated )
    {
        DRM_RVK_UpdateRevocationVersionsCache( f_poLicRespContext->m_poRevStoreContext,
                                              &f_poLicRespContext->m_poBBXContext->CryptoContext,
                                              &f_poLicRespContext->m_poLicEvalContext->idCRLsCurrent,
                                               f_poLicRespContext->m_poLicEvalContext->pbRevocationBuffer,
                                               f_poLicRespContext->m_poLicEvalContext->cbRevocationBuffer,
                                               NULL );
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
#else
    return DRM_SUCCESS;
#endif /* DRM_SUPPORT_REVOCATION */
}

#endif /* DRM_SUPPORT_REVOCATION */

/*********************************************************************
**
** Function: _ExtractLicensesFromLicenseResponse
**
** Synopsis: Function that extracts licenses from a server response
**           string and then processes and stores the licenses.
**
** Arguments:
**
** [f_poLicRespContext]     -- Pointer to a data structure that contains
**                             information needed to process licenses.
** [f_pszResponse]          -- Pointer to a character buffer that contains
**                             the server response.
** [f_pdasstrResponse]      -- Pointer to a sub string that defines the licenses
**                             string ( pre-B64 decoded ) within the server
**                             response buffer.
** [f_pSLKData]             -- Pointer to SLKData structure containing current
**                             session key information. May be NULL.
** [f_poLicAcks]            -- Array of structures that reveive the result of
**                             license processing and storage.
** [f_pcLicAcks]            -- Pointer to a variable that receives the total
**                             of elements used in the array mentioned above.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Note:                    Call is responsible to provide the array that is
**                          used to store the result of license processing and
**                          storage. The maximum number of licenses contained in
**                          a single license response is limited to a constant
**                          named DRM_E_LICACQ_TOO_MANY_LICENSES.
**
**********************************************************************/
static DRM_RESULT _ExtractLicensesFromLicenseResponse(
    IN DRM_LICRESP_CONTEXT_V3 *f_poLicRespContext,
    IN DRM_CHAR *f_pszResponse,
    IN DRM_SUBSTRING *f_pdasstrResponse,
    IN DRM_SLKDATA *f_pSLKData,
    __out_ecount_part( DRM_MAX_LICENSE_ACK, *f_pcLicAcks ) DRM_LICENSE_ACK *f_poLicAcks,
    OUT DRM_DWORD *f_pcLicAcks )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrLicenses = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrLicense  = EMPTY_DRM_SUBSTRING;
    DRM_DWORD iNode = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC__ExtractLicensesFromLicenseResponse );

    ChkArg( f_poLicRespContext != NULL );
    ChkArg( f_pszResponse != NULL );
    ChkArg( f_pdasstrResponse != NULL );
    ChkArg( f_poLicAcks != NULL );
    ChkArg( f_pcLicAcks != NULL );

    *f_pcLicAcks = 0;

    /*
    ** Extract <Licenses> node from
    ** <AcquireLicenseResponse>/<Response>/<AcquireLicenseResult>/<LicenseResponse> node.
    */
    ChkDR( DRM_XML_GetSubNodeByPathA( f_pszResponse,
                                      f_pdasstrResponse,
                                      &g_dastrLicLicensesPath,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &dasstrLicenses,
                                      g_chForwardSlash ) );

    for ( ; ; )
    {
        /* Read one <License> node from the <Licenses> node. */
        dr = DRM_XML_GetNodeA( f_pszResponse,
                               &dasstrLicenses,
                               &g_dastrLicLicensePath,
                               NULL,
                               NULL,
                               iNode,
                               NULL,
                               &dasstrLicense );

        if ( DRM_FAILED( dr ) )
        {
            if ( dr == DRM_E_XMLNOTFOUND )
            {
                ChkDR( DRM_SUCCESS );

                break;
            }
        }
        else
        {
            ChkDR( dr );
        }

        /* Add the license to the store etc. */
        if ( *f_pcLicAcks >= DRM_MAX_LICENSE_ACK )
        {
            ChkDR( DRM_E_LICACQ_TOO_MANY_LICENSES );
        }
        else
        {
            f_poLicAcks[ *f_pcLicAcks ].m_dwResult = DRM_E_FAIL;

            ChkDR( DRM_LA_ProcessLicenseV3( f_poLicRespContext,
                                            f_pszResponse,
                                            &dasstrLicense,
                                            f_pSLKData,
                                            &f_poLicAcks[ *f_pcLicAcks ] ) );

#if DRM_SUPPORT_LICENSE_SYNC

            /*
            ** Failure of sync store update is ignored and the license processing
            ** should continue.
            */
            ChkDRContinue( _UpdateSyncStore( f_poLicRespContext->m_poSyncContext,
                                             f_poLicRespContext->m_poViewRightsContext,
                                             &f_poLicAcks[ *f_pcLicAcks ].m_oKID ) );

#endif

            ( *f_pcLicAcks )++;

            iNode++;
        }
    }

ErrorExit:

    if ( DRM_FAILED( dr ) && f_pcLicAcks != NULL )
    {
        *f_pcLicAcks = 0;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_LA_ProcessResponseV3
**
** Synopsis: Function that extracts, processes and stores licenses
**           received from the server. It also returns a transaction
**           ID if found.
**
** Arguments:
**
** [f_poLicRespContext]     -- Pointer to a data structure that contains
**                             information needed to process licenses.
** [f_pdastrResponse]       -- Pointer to a DRM UTF8/ANSI string that contains
**                             the server response.
** [f_pbTransactionID]      -- Pointer to a buffer that is used to receive
**                             the extracted transaction ID.
** [f_pcbTransactionID]     -- Pointer to a variable that receives the size
**                             (number of bytes) of the extracted transaction ID.
** [f_poLicAcks]            -- Array of structures that reveives the result of
**                             license processing and storage.
** [f_pcLicAcks]            -- Pointer to a variable that receives the total
**                             of elements used in the array mentioned above.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the passed in DRM string to
**                          store the transaction ID is not NULL but is not big
**                          enough.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LA_ProcessResponseV3(
    IN DRM_LICRESP_CONTEXT_V3 *f_poLicRespContext,
    IN DRM_ANSI_CONST_STRING *f_pdastrResponse,
    __out_bcount( *f_pcbTransactionID ) DRM_BYTE *f_pbTransactionID,
    IN OUT DRM_DWORD *f_pcbTransactionID,
    __out_ecount_part( DRM_MAX_LICENSE_ACK, *f_pcLicAcks ) DRM_LICENSE_ACK *f_poLicAcks,
    OUT DRM_DWORD *f_pcLicAcks )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrResponse = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrTransactionID = EMPTY_DRM_SUBSTRING;
    DRM_SLKDATA *pSlkData = NULL;
#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
    DRM_SLKDATA slkData = { 0 };
    DRM_BOOL fValidSLK = FALSE;
#endif

    ChkArg( f_poLicRespContext != NULL );
    ChkDRMANSIString( f_pdastrResponse );
    ChkArg( f_pbTransactionID != NULL );
    ChkArg( f_pcbTransactionID != NULL );
    ChkArg( f_poLicAcks != NULL );
    ChkArg( f_pcLicAcks != NULL );

    dasstrResponse.m_ich = 0;
    dasstrResponse.m_cch = f_pdastrResponse->cchString;

#if DRM_USE_SOAP

    ChkDR( DRM_SOAPXML_SkipSOAPHeaders( ( DRM_CHAR * )f_pdastrResponse->pszString,
                                        &dasstrResponse ) );

#endif /* DRM_USE_SOAP */

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
    ChkDR( _ExtractSLKDataFromLicenseResponse( f_poLicRespContext,
                                               ( DRM_CHAR * )f_pdastrResponse->pszString,
                                               &dasstrResponse,
                                               &slkData,
                                               &fValidSLK ) );

    if ( fValidSLK )
    {
        pSlkData = &slkData;
    }
#endif /* DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS */

    /* Extract and process all the revocation information in the server response. */
    ChkDR( _ExtractLicensesFromLicenseResponse( f_poLicRespContext,
                                                ( DRM_CHAR * )f_pdastrResponse->pszString,
                                                &dasstrResponse,
                                                pSlkData,
                                                f_poLicAcks,
                                                f_pcLicAcks ) );

    /*
    ** Extract <TransactionID> node from
    ** <AcquireLicenseResponse>/<AcquireLicenseResult>/Response/<LicenseResponse>/<Acknowledgement> node.
    */
    dr = DRM_XML_GetSubNodeByPathA( f_pdastrResponse->pszString,
                                    &dasstrResponse,
                                    &g_dastrLicTransactionIDPath,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &dasstrTransactionID,
                                    g_chForwardSlash );

    if ( DRM_SUCCEEDED( dr ) )
    {
        if ( dasstrTransactionID.m_cch <= *f_pcbTransactionID )
        {
            DRM_BYT_CopyBytes( f_pbTransactionID,
                               0,
                               f_pdastrResponse->pszString,
                               dasstrTransactionID.m_ich,
                               dasstrTransactionID.m_cch );

            *f_pcbTransactionID = dasstrTransactionID.m_cch;
        }
        else
        {
            ChkDR( DRM_E_BUFFERTOOSMALL );
        }
    }
    else
    {
        *f_pcbTransactionID = 0;

        dr = DRM_SUCCESS;
    }

ErrorExit:

    if ( DRM_FAILED( dr ) && f_pcLicAcks != NULL )
    {
        *f_pcLicAcks = 0;
    }

    return dr;
}

/*********************************************************************
**
** Function: DRM_LA_CheckForCustomData
**
** Synopsis: Function that checks for custom data in a V3 LACQ response
**           If custom data is present, also verifies the response's signature
**
** Arguments:
**
** [f_pbResponse]           -- Pointer to a buffer that contains the response
**                             response from the server.
** [f_cbResponse]           -- Size ( number of bytes ) of the response from the
**                             server. It must be bigger than 0.
**
** Returns:                 DRM_SUCCESS if the license has no custom data
**                          DRM_S_MORE_DATA if custom data is available from
**                          the server AND the signature was verified successfully.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_XMLNOTFOUND if expected XML node is not found.
**                          Errors from DRM_XMLSIG_VerifySignature
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LA_CheckForCustomData(
    __in_bcount( f_cbResponse ) const DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse )
{
    DRM_RESULT              dr              = DRM_SUCCESS;
    DRM_BOOL                fHasCustomData  = FALSE;
    DRM_ANSI_CONST_STRING   dastrResponse   = EMPTY_DRM_STRING;
    DRM_SUBSTRING           dasstrResponse  = EMPTY_DRM_SUBSTRING;

    ChkArg( f_pbResponse != NULL );
    ChkArg( f_cbResponse > 0 );

    DASTR_FROM_PB( &dastrResponse, f_pbResponse, f_cbResponse );

    dasstrResponse.m_ich = 0;
    dasstrResponse.m_cch = dastrResponse.cchString;

#if DRM_USE_SOAP
    ChkDR( DRM_SOAPXML_SkipSOAPHeaders( ( DRM_CHAR * )dastrResponse.pszString,
                                         &dasstrResponse ) );
#endif

    /*
    ** Try to detect whether there is custom data from the server.
    */
    if ( DRM_E_BUFFERTOOSMALL == DRM_SOAPXML_ParseCustomDataForProtocol( f_pbResponse,
                                                                f_cbResponse,
                                                                DRM_SOAPXML_PROTOCOL_LIC_ACQ_RESPONSE,
                                                                NULL,
                                                                NULL ) )
    {
        /* Yes there is a custom data string from the server. */
        fHasCustomData = TRUE;
    }

ErrorExit:
    if ( DRM_SUCCEEDED( dr ) && fHasCustomData )
    {
        dr = DRM_S_MORE_DATA;
    }

    return dr;
}

/*********************************************************************
**
** Function: DRM_LA_GenerateChallengeV3
**
** Synopsis: Function that generates a license acquisition challenge XML to
**           be sent to the license server using the V3 protocol.
**
** Arguments:
**
** [f_poLicChlgContext]     -- Pointer to a structure that contains all
**                             the information needed to build the license
**                             acquisition challenge XML.
** [f_pbChallenge]          -- Pointer to a buffer to receive a generated challenge
**                             byte stream. If it is NULL, the function returns an
**                             error and the size of the required buffer is stored
**                             in *f_pcbChallenge.
** [f_pcbChallenge]         -- Pointer to a variable that contains the size ( in bytes
**                             of the challenge buffer during input and receives the
**                             size ( in bytes ) of the challenge buffer during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffers to retrieve
**                          the URL or challenge data are not big enough.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LA_GenerateChallengeV3(
    IN DRM_LICCHLG_CONTEXT_V3 *f_poLicChlgContext,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchXML = 0;
    _XMBContextA *poXMLContext = NULL;
    DRM_DWORD cbXMLContext = 0;
    DRM_ANSI_STRING dastrXML = EMPTY_DRM_STRING;

    ChkArg( f_poLicChlgContext != NULL );
    ChkArg( f_pcbChallenge != NULL );
    ChkArg( f_pbChallenge == NULL || *f_pcbChallenge > 0 );

    cchXML = _CalcLicenseChallengeCharCount( f_poLicChlgContext );

    /*
    ** Add one more DRM_DWORD to ensure the size of buffer is
    ** big enough even after realighnment.
    */
    cchXML += SIZEOF( DRM_DWORD );

    /* Add space used by XML builder context. */
    cchXML += g_cbXMLBuilderMinimumA;

    if ( f_pbChallenge == NULL || *f_pcbChallenge < cchXML )
    {
        *f_pcbChallenge = cchXML;

        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    ChkDR( DRM_SOAPXML_PrepareXMLContext( f_pbChallenge,
                                          cchXML,
                                          &poXMLContext,
                                          &cbXMLContext ) );

    ChkDR( _BuildLicenseChallengeXML( poXMLContext,
                                      cbXMLContext,
                                      f_poLicChlgContext,
                                      &dastrXML ) );

#if DRM_USE_SOAP

    ChkDR( DRM_SOAPXML_PrependXMLRoot( &dastrXML ) );

#endif

    ChkBOOL( dastrXML.cchString <= *f_pcbChallenge,
             DRM_E_BUFFERTOOSMALL );

    MEMCPY( f_pbChallenge, dastrXML.pszString, dastrXML.cchString );

    /* Return the actual size ( number of bytes ) of the generated challenge. */
    *f_pcbChallenge = dastrXML.cchString;

ErrorExit:

    return dr;
}

/*********************************************************************
**
** Function: DRM_LA_GenerateAckV3
**
** Synopsis: Function that generates a license acquisition acknowledgement
**           XML to be sent to the license server using the V3 protocol.
**
** Arguments:
**
** [f_poOEMContext]         -- Pointer to an OEM specific context.
** [f_poBBXContext]         -- Pointer to a black box context.
** [f_poStackAllocatorContext]
**                          -- Pointer to a stack allocator context.
** [f_poLicenseResponse]    -- Pointer to a structure that contains the license
**                             processing/storage result to send to the server.
** [f_pbChallenge]          -- Pointer to a buffer to receive a generated challenge
**                             byte stream. If it is NULL, the function returns an
**                             error and the size of the required buffer is stored
**                             in *f_pcbChallenge.
** [f_pcbChallenge]         -- Pointer to a variable that contains the size ( in bytes
**                             of the challenge buffer during input and receives the
**                             size ( in bytes ) of the challenge buffer during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the data is not big enough.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LA_GenerateAckV3(
    __in_opt DRM_VOID *f_poOEMContext,
    IN DRM_BB_CONTEXT *f_poBBXContext,
    IN DRM_STACK_ALLOCATOR_CONTEXT *f_poStackAllocatorContext,
    IN DRM_LICENSE_RESPONSE *f_poLicenseResponse,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchXML = 0;
    _XMBContextA *poXMLContext = NULL;
    DRM_DWORD cbXMLContext = 0;
    DRM_ANSI_CONST_STRING dastrTransactionID = EMPTY_DRM_STRING;
    DRM_DWORD cchDeviceCert = 0;
    DRM_ANSI_STRING dastrXML = EMPTY_DRM_STRING;
    DRM_XML_KEY oXMLKey = EMPTY_XML_KEY;

    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_poBBXContext->fInited );
    ChkArg( f_poStackAllocatorContext != NULL );
    ChkArg( f_poLicenseResponse != NULL );
    ChkArg( f_pcbChallenge != NULL );
    ChkArg( f_pbChallenge == NULL || *f_pcbChallenge > 0 );

    DASTR_FROM_PB( &dastrTransactionID,
                   f_poLicenseResponse->m_rgbTransactionID,
                   f_poLicenseResponse->m_cbTransactionID );

    cchDeviceCert = _CalcDeviceCertCharCount( f_poOEMContext );

    ChkDR( DRM_SOAPXML_InitXMLKey( f_poOEMContext,
                                   &oXMLKey,
                                   &f_poBBXContext->CryptoContext ) );

    cchXML = _CalcLicenseAcknowledgementCharCount( dastrTransactionID.cchString,
                                                   f_poLicenseResponse->m_rgoAcks,
                                                   f_poLicenseResponse->m_cAcks,
                                                   cchDeviceCert,
                                                   &oXMLKey );

    /*
    ** Add one more DRM_DWORD to ensure the size of buffer is
    ** big enough even after realighnment.
    */
    cchXML += SIZEOF( DRM_DWORD );

    /* Add space used by XML builder context. */
    cchXML += g_cbXMLBuilderMinimumA;

    if ( f_pbChallenge == NULL || *f_pcbChallenge < cchXML )
    {
        *f_pcbChallenge = cchXML;

        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    ChkDR( DRM_SOAPXML_PrepareXMLContext( f_pbChallenge,
                                          cchXML,
                                          &poXMLContext,
                                          &cbXMLContext ) );

    ChkDR( _BuildLicenseAcknowledgementXML( poXMLContext,
                                            cbXMLContext,
                                            f_poBBXContext,
                                            f_poStackAllocatorContext,
                                            &dastrTransactionID,
                                            f_poLicenseResponse->m_rgoAcks,
                                            f_poLicenseResponse->m_cAcks,
                                            cchDeviceCert,
                                            &oXMLKey,
                                            &dastrXML ) );

#if DRM_USE_SOAP

    ChkDR( DRM_SOAPXML_PrependXMLRoot( &dastrXML ) );

#endif

    ChkBOOL( dastrXML.cchString <= *f_pcbChallenge,
             DRM_E_BUFFERTOOSMALL );

    MEMCPY( f_pbChallenge, dastrXML.pszString, dastrXML.cchString );

    /* Return the actual size ( number of bytes ) of the generated challenge. */
    *f_pcbChallenge = dastrXML.cchString;

ErrorExit:

    return dr;
}

/*********************************************************************
**
** Function: Drm_LicenseAcq_GenerateAck
**
** Synopsis: API that generates a license acquisition acknowledgement
**           XML to be sent to the license server using the V3 protocol.
**
** Arguments:
**
** [f_poAppContext]         -- Pointer to a DRM App context initialized via
**                             Drm_Initialize.
** [f_poLicenseResponse]    -- Pointer to a structure that contains the license
**                             processing/storage result to send to the server.
** [f_pbChallenge]          -- Pointer to a buffer to receive a generated challenge
**                             byte stream. If it is NULL, the function returns an
**                             error and the size of the required buffer is stored
**                             in *f_pcbChallenge.
** [f_pcbChallenge]         -- Pointer to a variable that contains the size ( in bytes
**                             of the challenge buffer during input and receives the
**                             size ( in bytes ) of the challenge buffer during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the data is not big enough.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_LicenseAcq_GenerateAck(
    IN DRM_APP_CONTEXT *f_poAppContext,
    IN DRM_LICENSE_RESPONSE *f_poLicenseResponse,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_APP_CONTEXT_INTERNAL *poAppContextInternal =
        ( DRM_APP_CONTEXT_INTERNAL * )f_poAppContext;
    DRM_STACK_ALLOCATOR_CONTEXT oStackAllocatorContext = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC_Drm_LicenseAcq_GenerateAck );

    ChkArg( f_poAppContext != NULL );
    ChkArg( poAppContextInternal->fStoreOpened );
    ChkArg( f_poLicenseResponse != NULL );
    ChkArg( f_poLicenseResponse->m_eType == eV3Protocol );
    ChkArg( f_pcbChallenge != NULL );
    ChkArg( f_pbChallenge == NULL ||
            *f_pcbChallenge > 0 );

    /*
    ** Clear the previous response fields in the app context.
    */
    poAppContextInternal->fResponseSignatureChecked = FALSE;
    poAppContextInternal->dwLastResponseProtocol    = DRM_SOAPXML_PROTOCOL_UNKNOWN;

    oStackAllocatorContext.pbStack = poAppContextInternal->oDRMBuffer.oBuffers.rgbDRMLicense;
    oStackAllocatorContext.cbStack = SIZEOF( poAppContextInternal->oDRMBuffer.oBuffers.rgbDRMLicense );

    ChkDR( DRM_LA_GenerateAckV3( poAppContextInternal->pOEMContext,
                                 &poAppContextInternal->oBlackBoxContext,
                                 &oStackAllocatorContext,
                                 f_poLicenseResponse,
                                 f_pbChallenge,
                                 f_pcbChallenge ) );

ErrorExit:

    ChkECC( ECC_Drm_LicenseAcq_GenerateAck, dr );

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: Drm_LicenseAcq_ProcessAckResponse
**
** Synopsis: API that processes a license acquisition acknowledgement
**           response from the license server using the V3 protocol.
**
** Arguments:
**
** [f_poAppContext]         -- Pointer to a DRM App context initialized via
**                             Drm_Initialize.
** [f_pbResponse]           -- Pointer to a buffer that contains the acknowledgement
**                             response from the server.
** [f_cbResponse]           -- Size ( number of bytes ) of the response from the
**                             server. It must be bigger than 0.
** [f_pResult]              -- Optional pointer to a variable that receives the
**                             status code.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_S_MORE_DATA if custom data is available from
**                          the server.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_XMLNOTFOUND if expected XML node is not found.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_LicenseAcq_ProcessAckResponse(
    IN DRM_APP_CONTEXT *f_poAppContext,
    __in_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    OUT DRM_RESULT *f_pResult )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_APP_CONTEXT_INTERNAL *poAppContextInternal =
        ( DRM_APP_CONTEXT_INTERNAL * )f_poAppContext;
    DRM_ANSI_CONST_STRING dastrResponse = EMPTY_DRM_STRING;
    DRM_SUBSTRING dasstrResponse = EMPTY_DRM_SUBSTRING;
    DRM_BOOL fOverwriteResult = FALSE;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC_Drm_LicenseAcq_ProcessAckResponse );

    ChkArg( f_poAppContext != NULL );
    ChkArg( poAppContextInternal->fStoreOpened );
    ChkArg( f_pbResponse != NULL );
    ChkArg( f_cbResponse > 0 );

    fOverwriteResult = TRUE;

    DASTR_FROM_PB( &dastrResponse, f_pbResponse, f_cbResponse );

    dasstrResponse.m_ich = 0;
    dasstrResponse.m_cch = dastrResponse.cchString;
#if DRM_USE_SOAP

    ChkDR( DRM_SOAPXML_SkipSOAPHeaders( ( DRM_CHAR * )dastrResponse.pszString,
                                         &dasstrResponse ) );
#endif

    /* Try to detect whether there is custom data from the server. */
    dr = DRM_SOAPXML_ParseCustomDataForProtocol( f_pbResponse,
                                            f_cbResponse,
                                            DRM_SOAPXML_PROTOCOL_LIC_ACQ_ACK_RESPONSE,
                                            NULL,
                                            NULL );
    if ( DRM_E_BUFFERTOOSMALL == dr )
    {
        /* Yes there is a custom data string from the server. */
        dr = DRM_S_MORE_DATA;
    }
    else
    {
        dr = DRM_SUCCESS;
    }

ErrorExit:

    dr = DRM_SOAPXML_ParseStatusCodeAndChooseBest(f_pbResponse,
                                                  f_cbResponse,
                                                  dr,
                                                  fOverwriteResult ? f_pResult : NULL );

    ChkECC( ECC_Drm_LicenseAcq_ProcessAckResponse, dr );

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/********************************************************************************
** Function:    DRM_LA_ProcessLicenseV3
**
** Synopsis:    Process one license in XMR format. Parses a license
**              and tries to evaluate it to see if it can be stored
**              in the license store.
**
** Arguments:
** [f_poLicRespContext] -- Pointer to a data structure that contains
**                         information needed to process licenses.
** [f_pbResponse]       -- Response string received from license server
** [f_pdasstrLicense]   -- ANSI substring over response string that represents
**                         a single license's data.
** [f_pSLKID]           -- Contains the current SLK ID (optional)
** [f_poLicAck]         -- to receive the reason code
**
** Returns:     DRM_SUCCESS on success, or failed with
**              DRM_E_INVALIDARG,
**              DRM_E_LICENSEVERSIONNOTSUPPORTED,
**              DRM_E_INVALIDLICENSE, and
**              error codes from Licesne store.
********************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LA_ProcessLicenseV3(
    IN DRM_LICRESP_CONTEXT_V3 *f_poLicRespContext,
    __in_ecount( f_pdasstrLicense->m_ich + f_pdasstrLicense->m_cch ) DRM_CHAR *f_pszResponse,
    IN  DRM_SUBSTRING        *f_pdasstrLicense,
    IN  DRM_SLKDATA          *f_pSLKData,
    OUT DRM_LICENSE_ACK      *f_poLicAck )
{
    DRM_RESULT       dr                   = DRM_SUCCESS;
    DRM_RESULT       drReason             = DRM_SUCCESS;
    DRM_CONST_STRING dstrKID              = EMPTY_DRM_STRING;
    DRM_WCHAR        wchKID[CCH_BASE64_EQUIV( SIZEOF( DRM_ID ) ) * 2] = { 0 }; /* Ensure we have enough room for a B64 encoded KID, and leave some wiggle room. */
    DRM_DWORD        cchKID               = NO_OF( wchKID );
    DRM_DWORD        dwPriority           = 0;
#if SIXTEEN_BIT_ADDRESSING
    DRM_BYTE         bHead                = 0;
    DRM_BOOL         fDecryptOK           = FALSE;
#endif
    DRM_DWORD        cbVersionLicense     = 0;
    DRM_DWORD        cbAlignedLicenseSize = 0;
    DRM_DWORD        cbAlignment          = 0;
    DRM_BYTE         *pbLicenseXMR        = NULL;
    DRM_CONST_STRING dstrData             = EMPTY_DRM_STRING;
    DRM_STACK_ALLOCATOR_CONTEXT stack;
    DRM_LICEVAL_CONTEXT *poLicEvalContext = NULL;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_LICACQV3, PERF_FUNC_DRM_LA_ProcessLicenseV3 );

    ChkArg( f_poLicRespContext != NULL );
    ChkArg( f_pszResponse != NULL );
    ChkArg( f_pdasstrLicense != NULL );
    ChkArg( f_pdasstrLicense->m_cch > 0 );
    ChkArg( f_poLicAck != NULL );

    poLicEvalContext = f_poLicRespContext->m_poLicEvalContext;
    ChkArg( poLicEvalContext != NULL );

    drReason = DRM_B64_DecodeA( f_pszResponse,
                                f_pdasstrLicense,
                               &cbVersionLicense,
                                NULL,
                                DRM_BASE64_DECODE_IN_PLACE );

    if ( DRM_FAILED( drReason ) )
    {
        goto ErrorExit;
    }

    /*
    ** Make room to put the priority in front of the license for storage.
    */
    pbLicenseXMR = ( DRM_BYTE* )( f_pszResponse + f_pdasstrLicense->m_ich );

    ChkDR( DRM_UTL_EnsureDataAlignment( pbLicenseXMR,
                                        f_pdasstrLicense->m_cch,
                                       &pbLicenseXMR,
                                       &cbAlignedLicenseSize,
                                        SIZEOF( DRM_DWORD ),
                                       &cbAlignment ) );

    /*
    ** State that after DRM_DWORD right shift and alignment there is room to copy decoded license
    */
    DRMASSERT( SIZEOF( DRM_DWORD ) + cbAlignment + cbVersionLicense <= f_pdasstrLicense->m_cch );

    MEMMOVE( pbLicenseXMR + __CB_DECL( SIZEOF( DRM_DWORD ) ),
             f_pszResponse + f_pdasstrLicense->m_ich,
             cbVersionLicense );

    ZEROMEM( poLicEvalContext->plicenseXMR, SIZEOF( *poLicEvalContext->plicenseXMR ) );

    stack.nStackTop = 0;
    stack.cbStack   = __CB_DECL( DRM_MAX_LICENSESIZE );
    stack.pbStack   = f_poLicRespContext->m_pbLicenseBuffer;

    /*
    ** Clear all flags. Later, if the license is embeddable, we
    ** will set the following flag: DRM_LICENSE_ACK_FLAGS_EMBED
    */
    f_poLicAck->m_dwFlags = 0;

    drReason = DRM_XMR_UnpackLicense( pbLicenseXMR + __CB_DECL( SIZEOF( DRM_DWORD ) ),
                                      cbVersionLicense,
                                      &stack,
                                      poLicEvalContext->plicenseXMR );

    if ( DRM_FAILED( drReason ) || poLicEvalContext->plicenseXMR == NULL )
    {
        f_poLicAck->m_dwResult = DRM_E_INVALIDLICENSE;
        goto ErrorExit;
    }
    if ( poLicEvalContext->plicenseXMR->dwVersion != XMR_VERSION_3 )
    {
        f_poLicAck->m_dwResult = DRM_E_LICENSEVERSIONNOTSUPPORTED;
        goto ErrorExit;
    }

    poLicEvalContext->fLicenseIsXMR = TRUE;

    /*
    ** Parse the KID, LID, and priority from the license
    */
    DRM_BYT_CopyBytes( poLicEvalContext->LID.rgb,
                       0,
                       poLicEvalContext->plicenseXMR->pbRightsIdBuffer,
                       poLicEvalContext->plicenseXMR->iRightsId,
                       SIZEOF( poLicEvalContext->LID.rgb ) );

    DRM_BYT_CopyBytes( poLicEvalContext->KID.rgb,
                       0,
                       poLicEvalContext->plicenseXMR->containerOuter.containerKeys.ContentKey.pbguidKeyID,
                       poLicEvalContext->plicenseXMR->containerOuter.containerKeys.ContentKey.iguidKeyID,
                       SIZEOF( poLicEvalContext->KID.rgb ) );

    ChkDR( DRM_B64_EncodeW( poLicEvalContext->KID.rgb,
                            SIZEOF( poLicEvalContext->KID.rgb ),
                            wchKID,
                            &cchKID,
                            0 ) );

    dstrKID.pwszString = wchKID;
    dstrKID.cchString  = cchKID;

    MEMCPY( &f_poLicAck->m_oKID, poLicEvalContext->KID.rgb, DRM_ID_SIZE );

    MEMCPY( &f_poLicAck->m_oLID, poLicEvalContext->LID.rgb, DRM_ID_SIZE );

    if( XMR_IS_PRIORITY_VALID( poLicEvalContext->plicenseXMR ) )
    {
        dwPriority = poLicEvalContext->plicenseXMR->containerOuter.containerGlobalPolicies.Priority.dwValue;
    }
    else
    {
        dwPriority = 0;
    }

    drReason = DRM_LA_EvaluateLicense( poLicEvalContext, f_poLicRespContext->m_poDatastore, &dstrData );

    /*
    ** Store the license if the license evaluated ok
    */
    if ( DRM_SUCCEEDED( drReason ) )
    {
        /*
        ** Pre-optimized license
        */
        if ( poLicEvalContext->plicenseXMR->containerOuter.containerKeys.OptimizedContentKey.fValid )
        {
            /*
            ** Licenses that are pre-optimized without an SLK can be stored as-is
            */
            if ( poLicEvalContext->plicenseXMR->containerOuter.containerKeys.OptimizedContentKey.wKeyEncryptionCipherType
              == XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_AES_128_ECB_SLK )
            {
#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
                /*
                ** Domain-bound licenses should never use an SLK
                */
                /*
                ** SLK-optimized device-bound licenses can be re-bound to current BBX
                */
                if ( poLicEvalContext->plicenseXMR->containerOuter.containerGlobalPolicies.DomainID.fValid
                  || f_pSLKData == NULL )
                {
                    drReason = DRM_E_INVALIDLICENSE;
                }
                else
                {
                    drReason = DRM_BBX_RebindSymmetricKey( poLicEvalContext->pcontextBBX,
                                                           &f_pSLKData->slk,
                                                           poLicEvalContext->plicenseXMR->containerOuter.containerKeys.OptimizedContentKey.pbEncryptedKeyBuffer,
                                                           poLicEvalContext->plicenseXMR->containerOuter.containerKeys.OptimizedContentKey.iEncryptedKey,
                                                           poLicEvalContext->plicenseXMR->containerOuter.containerKeys.OptimizedContentKey.cbEncryptedKey,
                                                           poLicEvalContext->plicenseXMR );

                    poLicEvalContext->plicenseXMR->containerOuter.containerKeys.OptimizedContentKey.wKeyEncryptionCipherType =
                        XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_AES_128_ECB;
                }
#else  /* DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS */
                drReason = DRM_E_INVALIDLICENSE;
#endif /* DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS */
            }
            else if ( poLicEvalContext->plicenseXMR->containerOuter.containerKeys.OptimizedContentKey.wKeyEncryptionCipherType
                   != XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_AES_128_ECB )
            {
                drReason = DRM_E_INVALIDLICENSE;
            }
        }
        else if ( poLicEvalContext->plicenseXMR->containerOuter.containerKeys.ContentKey.wKeyEncryptionCipherType
               == XMR_ASYMMETRIC_ENCRYPTION_TYPE_ECC_256 )
        {
#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
            DRM_DWORD        cbSymmKey = 0;
            DRM_BINDING_INFO bindInfo  = { 0 };

            bindInfo.m_fXMRLicense = TRUE;

            bindInfo.m_BindingInfo.m_XMR.m_pxmrLicense    =  poLicEvalContext->plicenseXMR;
            bindInfo.m_BindingInfo.m_XMR.m_pxmrContentKey = &poLicEvalContext->plicenseXMR->containerOuter.containerKeys.ContentKey;
            bindInfo.m_BindingInfo.m_XMR.m_pxmrSignature  = &poLicEvalContext->plicenseXMR->containerOuter.signature;
            bindInfo.m_BindingInfo.m_XMR.m_pxmrDomainID   = &poLicEvalContext->plicenseXMR->containerOuter.containerGlobalPolicies.DomainID;

            /*
            ** Re-bind the license to a symmetric key
            */
            drReason = DRM_BBX_AsymmetricToSymmetricKeyXMR( poLicEvalContext->pcontextBBX,
                                                            &bindInfo,
                                                            pbLicenseXMR + __CB_DECL( SIZEOF( DRM_DWORD ) ),
                                                            f_pdasstrLicense->m_cch,
                                                            &cbVersionLicense,
                                                            &stack,
                                                            &cbSymmKey );

#endif /* DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS */
        }
        else if ( poLicEvalContext->plicenseXMR->containerOuter.containerKeys.ContentKey.wKeyEncryptionCipherType
               != XMR_ASYMMETRIC_ENCRYPTION_TYPE_CHAINED_LICENSE )
        {
            /*
            ** If not asymmetric or pre-optimized, must be chained
            */
            drReason = DRM_E_INVALIDLICENSE;
        }

        if ( DRM_SUCCEEDED( drReason ) )
        {
            if ( XMR_IS_GLOBAL_POLICIES_VALID( poLicEvalContext->plicenseXMR ) &&
                 XMR_IS_RIGHTS_VALID( poLicEvalContext->plicenseXMR ) &&
                 ( poLicEvalContext->plicenseXMR->containerOuter.containerGlobalPolicies.Rights.wValue &
                   XMR_RIGHTS_CANNOT_PERSIST ) == XMR_RIGHTS_CANNOT_PERSIST )
            {
                drReason = DRM_NST_AddLicense( f_poLicRespContext->m_poNonceStoreContext,
                                               cbVersionLicense,
                                               pbLicenseXMR,
                                               &poLicEvalContext->KID,
                                               &poLicEvalContext->LID,
                                               dwPriority );
            }
            else
            {

                drReason = DRM_LST_AddLicense( f_poLicRespContext->m_poLicStoreContext,
                                               cbVersionLicense,
                                               pbLicenseXMR,
                                               &poLicEvalContext->KID,
                                               &poLicEvalContext->LID,
                                               dwPriority );

                /*
                ** Once the license is added to the store, set the DRM_LICENSE_ACK_FLAGS_EMBED flag
                */
                if ( XMR_IS_EMBEDDING_BEHAVIOR_VALID( poLicEvalContext->plicenseXMR )
                    && ( poLicEvalContext->plicenseXMR->containerOuter.containerGlobalPolicies.EmbeddingBehavior.wValue == XMR_EMBEDDING_BEHAVIOR_COPY
                    || poLicEvalContext->plicenseXMR->containerOuter.containerGlobalPolicies.EmbeddingBehavior.wValue == XMR_EMBEDDING_BEHAVIOR_MOVE ) )
                {
                    f_poLicAck->m_dwFlags |= DRM_LICENSE_ACK_FLAGS_EMBED;
                }
            }
        }
    }

    f_poLicAck->m_dwResult = drReason;

ErrorExit:
    /*
    ** Fill the data back in with what could be valid base64.
    ** If not the decoded license may
    ** cause further calls into the xml parser to fail.
    */
    DRM_BYT_SetBytes( f_pszResponse,
                      f_pdasstrLicense->m_ich,
                      f_pdasstrLicense->m_cch,
                      'a' );

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmlicacqv3constants.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmlicacqv3constants.h>

ENTER_PK_NAMESPACE_CODE;

/*
** ---------------------------------------------------------
** XML strings used in the construction of license challenge
** ---------------------------------------------------------
*/
/* "AcquireLicense" */
const DRM_CHAR g_rgchLicAcqRootTag [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'q', 'u' ), TWO_BYTES( 'i', 'r' ), TWO_BYTES( 'e', 'L' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ), TWO_BYTES( 's', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqRootTag = { g_rgchLicAcqRootTag, 14 };


/* "challenge" */
const DRM_CHAR g_rgchLicAcqChallenge1Tag [] =
{
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'n', 'g' ),
    TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqChallenge1Tag = { g_rgchLicAcqChallenge1Tag, 9 };


/* "Challenge" */
const DRM_CHAR g_rgchLicAcqChallenge2Tag [] =
{
    TWO_BYTES( 'C', 'h' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'n', 'g' ),
    TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqChallenge2Tag = { g_rgchLicAcqChallenge2Tag, 9 };


/* "LA" */
const DRM_CHAR g_rgchLicAcqLATag [] =
{
    TWO_BYTES( 'L', 'A' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqLATag = { g_rgchLicAcqLATag, 2 };


/* "Version" */
const DRM_CHAR g_rgchLicAcqVersionTag [] =
{
    TWO_BYTES( 'V', 'e' ), TWO_BYTES( 'r', 's' ), TWO_BYTES( 'i', 'o' ), TWO_BYTES( 'n', '\0' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqVersionTag = { g_rgchLicAcqVersionTag, 7 };


/* "ContentHeader" */
const DRM_CHAR g_rgchLicAcqContentHeaderTag [] =
{
    TWO_BYTES( 'C', 'o' ), TWO_BYTES( 'n', 't' ), TWO_BYTES( 'e', 'n' ), TWO_BYTES( 't', 'H' ),
    TWO_BYTES( 'e', 'a' ), TWO_BYTES( 'd', 'e' ), TWO_BYTES( 'r', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqContentHeaderTag = { g_rgchLicAcqContentHeaderTag, 13 };


/* "ClientInfo" */
const DRM_CHAR g_rgchLicAcqClientInfoTag [] =
{
    TWO_BYTES( 'C', 'l' ), TWO_BYTES( 'i', 'e' ), TWO_BYTES( 'n', 't' ), TWO_BYTES( 'I', 'n' ),
    TWO_BYTES( 'f', 'o' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqClientInfoTag = { g_rgchLicAcqClientInfoTag, 10 };


/* "ClientVersion" */
const DRM_CHAR g_rgchLicAcqClientVersionTag [] =
{
    TWO_BYTES( 'C', 'l' ), TWO_BYTES( 'i', 'e' ), TWO_BYTES( 'n', 't' ), TWO_BYTES( 'V', 'e' ),
    TWO_BYTES( 'r', 's' ), TWO_BYTES( 'i', 'o' ), TWO_BYTES( 'n', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqClientVersionTag = { g_rgchLicAcqClientVersionTag, 13 };


/* "SecurityVersion" */
const DRM_CHAR g_rgchLicAcqSecurityVersionTag [] =
{
    TWO_BYTES( 'S', 'e' ), TWO_BYTES( 'c', 'u' ), TWO_BYTES( 'r', 'i' ), TWO_BYTES( 't', 'y' ),
    TWO_BYTES( 'V', 'e' ), TWO_BYTES( 'r', 's' ), TWO_BYTES( 'i', 'o' ), TWO_BYTES( 'n', '\0' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqSecurityVersionTag = { g_rgchLicAcqSecurityVersionTag, 15 };


/* "AppSecurity" */
const DRM_CHAR g_rgchLicAcqAppSecurityTag [] =
{
    TWO_BYTES( 'A', 'p' ), TWO_BYTES( 'p', 'S' ), TWO_BYTES( 'e', 'c' ), TWO_BYTES( 'u', 'r' ),
    TWO_BYTES( 'i', 't' ), TWO_BYTES( 'y', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqAppSecurityTag = { g_rgchLicAcqAppSecurityTag, 11 };


/* "SubjectID1" */
const DRM_CHAR g_rgchLicAcqSubjectID1Tag [] =
{
    TWO_BYTES( 'S', 'u' ), TWO_BYTES( 'b', 'j' ), TWO_BYTES( 'e', 'c' ), TWO_BYTES( 't', 'I' ),
    TWO_BYTES( 'D', '1' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqSubjectID1Tag = { g_rgchLicAcqSubjectID1Tag, 10 };


/* "SubjectID2" */
const DRM_CHAR g_rgchLicAcqSubjectID2Tag [] =
{
    TWO_BYTES( 'S', 'u' ), TWO_BYTES( 'b', 'j' ), TWO_BYTES( 'e', 'c' ), TWO_BYTES( 't', 'I' ),
    TWO_BYTES( 'D', '2' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqSubjectID2Tag = { g_rgchLicAcqSubjectID2Tag, 10 };


/* "DRMKVersion" */
const DRM_CHAR g_rgchLicAcqDRMKVersionTag [] =
{
    TWO_BYTES( 'D', 'R' ), TWO_BYTES( 'M', 'K' ), TWO_BYTES( 'V', 'e' ), TWO_BYTES( 'r', 's' ),
    TWO_BYTES( 'i', 'o' ), TWO_BYTES( 'n', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqDRMKVersionTag = { g_rgchLicAcqDRMKVersionTag, 11 };


/* "RevocationLists" */
const DRM_CHAR g_rgchLicAcqRevocationListsTag [] =
{
    TWO_BYTES( 'R', 'e' ), TWO_BYTES( 'v', 'o' ), TWO_BYTES( 'c', 'a' ), TWO_BYTES( 't', 'i' ),
    TWO_BYTES( 'o', 'n' ), TWO_BYTES( 'L', 'i' ), TWO_BYTES( 's', 't' ), TWO_BYTES( 's', '\0' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqRevocationListsTag = { g_rgchLicAcqRevocationListsTag, 15 };


/* "RevListInfo" */
const DRM_CHAR g_rgchLicAcqRevListInfoTag [] =
{
    TWO_BYTES( 'R', 'e' ), TWO_BYTES( 'v', 'L' ), TWO_BYTES( 'i', 's' ), TWO_BYTES( 't', 'I' ),
    TWO_BYTES( 'n', 'f' ), TWO_BYTES( 'o', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqRevListInfoTag = { g_rgchLicAcqRevListInfoTag, 11 };


/* "ListID" */
const DRM_CHAR g_rgchLicAcqRevListIDTag [] =
{
    TWO_BYTES( 'L', 'i' ), TWO_BYTES( 's', 't' ), TWO_BYTES( 'I', 'D' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqRevListIDTag = { g_rgchLicAcqRevListIDTag, 6 };


/* "Version" */
const DRM_CHAR g_rgchLicAcqRevVersionTag [] =
{
    TWO_BYTES( 'V', 'e' ), TWO_BYTES( 'r', 's' ), TWO_BYTES( 'i', 'o' ), TWO_BYTES( 'n', '\0' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqRevVersionTag = { g_rgchLicAcqRevVersionTag, 7 };


/* "Data" */
const DRM_CHAR g_rgchLicAcqDataTag [] =
{
    TWO_BYTES( 'D', 'a' ), TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqDataTag = { g_rgchLicAcqDataTag, 4 };


/* "CertificateChains" */
const DRM_CHAR g_rgchLicAcqCertificateChainsTag [] =
{
    TWO_BYTES( 'C', 'e' ), TWO_BYTES( 'r', 't' ), TWO_BYTES( 'i', 'f' ), TWO_BYTES( 'i', 'c' ),
    TWO_BYTES( 'a', 't' ), TWO_BYTES( 'e', 'C' ), TWO_BYTES( 'h', 'a' ), TWO_BYTES( 'i', 'n' ),
    TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqCertificateChainsTag = { g_rgchLicAcqCertificateChainsTag, 17 };


/* "CertificateChain" */
const DRM_CHAR g_rgchLicAcqCertificateChainTag [] =
{
    TWO_BYTES( 'C', 'e' ), TWO_BYTES( 'r', 't' ), TWO_BYTES( 'i', 'f' ), TWO_BYTES( 'i', 'c' ),
    TWO_BYTES( 'a', 't' ), TWO_BYTES( 'e', 'C' ), TWO_BYTES( 'h', 'a' ), TWO_BYTES( 'i', 'n' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqCertificateChainTag = { g_rgchLicAcqCertificateChainTag, 16 };


/* "UPLINKS" */
const DRM_CHAR g_rgchLicAcqUplinksTag [] =
{
    TWO_BYTES( 'U', 'P' ), TWO_BYTES( 'L', 'I' ), TWO_BYTES( 'N', 'K' ), TWO_BYTES( 'S', '\0' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqUplinksTag = { g_rgchLicAcqUplinksTag, 7 };


/* "UPLINK" */
const DRM_CHAR g_rgchLicAcqUplinkTag [] =
{
    TWO_BYTES( 'U', 'P' ), TWO_BYTES( 'L', 'I' ), TWO_BYTES( 'N', 'K' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqUplinkTag = { g_rgchLicAcqUplinkTag, 6 };


/* "KID" */
const DRM_CHAR g_rgchLicAcqKIDTag [] =
{
    TWO_BYTES( 'K', 'I' ), TWO_BYTES( 'D', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqKIDTag = { g_rgchLicAcqKIDTag, 3 };


/* "Category" */
const DRM_CHAR g_rgchLicAcqCategoryTag [] =
{
    TWO_BYTES( 'C', 'a' ), TWO_BYTES( 't', 'e' ), TWO_BYTES( 'g', 'o' ), TWO_BYTES( 'r', 'y' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqCategoryTag = { g_rgchLicAcqCategoryTag, 8 };


/* "Count" */
const DRM_CHAR g_rgchLicAcqCountTag [] =
{
    TWO_BYTES( 'C', 'o' ), TWO_BYTES( 'u', 'n' ), TWO_BYTES( 't', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqCountTag = { g_rgchLicAcqCountTag, 5 };


/* "Date" */
const DRM_CHAR g_rgchLicAcqDateTag [] =
{
    TWO_BYTES( 'D', 'a' ), TWO_BYTES( 't', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqDateTag = { g_rgchLicAcqDateTag, 4 };


/* "Vague" */
const DRM_CHAR g_rgchLicAcqVagueTag [] =
{
    TWO_BYTES( 'V', 'a' ), TWO_BYTES( 'g', 'u' ), TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqVagueTag = { g_rgchLicAcqVagueTag, 5 };


/* "CustomData" */
const DRM_CHAR g_rgchLicAcqCustomDataTag [] =
{
    TWO_BYTES( 'C', 'u' ), TWO_BYTES( 's', 't' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( 'D', 'a' ),
    TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqCustomDataTag = { g_rgchLicAcqCustomDataTag, 10 };


/* "LicenseNonce" */
const DRM_CHAR g_rgchLicAcqLicenseNonceTag [] =
{
    TWO_BYTES( 'L', 'i' ), TWO_BYTES( 'c', 'e' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', 'N' ),
    TWO_BYTES( 'o', 'n' ), TWO_BYTES( 'c', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqLicenseNonceTag = { g_rgchLicAcqLicenseNonceTag, 12 };



/* "xmlns" */
const DRM_CHAR g_rgchLicAcqRootAttribName [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqRootAttribName = { g_rgchLicAcqRootAttribName, 5 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols" */
const DRM_CHAR g_rgchLicAcqRootAttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ),
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ),
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ),
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ),
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ),
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqRootAttribValue = { g_rgchLicAcqRootAttribValue, 50 };


/* "xmlns" */
const DRM_CHAR g_rgchLicAcqChallenge2AttribName [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqChallenge2AttribName = { g_rgchLicAcqChallenge2AttribName, 5 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols/messages" */
const DRM_CHAR g_rgchLicAcqChallenge2AttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ),
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ),
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ),
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ),
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ),
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '/', 'm' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 's', 'a' ),
    TWO_BYTES( 'g', 'e' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqChallenge2AttribValue = { g_rgchLicAcqChallenge2AttribValue, 59 };


/* "xmlns" */
const DRM_CHAR g_rgchLicAcqChallengeVAAttrib1Name [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqChallengeVAAttrib1Name = { g_rgchLicAcqChallengeVAAttrib1Name, 5 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols" */
const DRM_CHAR g_rgchLicAcqChallengeVAAttrib1Value [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ),
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ),
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ),
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ),
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ),
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqChallengeVAAttrib1Value = { g_rgchLicAcqChallengeVAAttrib1Value, 50 };


/* "Id" */
const DRM_CHAR g_rgchLicAcqChallengeVAAttrib2Name [] =
{
    TWO_BYTES( 'I', 'd' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqChallengeVAAttrib2Name = { g_rgchLicAcqChallengeVAAttrib2Name, 2 };

/* "SignedData" */
const DRM_CHAR g_rgchLicAcqChallengeVAAttrib2Value [] =
{
    TWO_BYTES( 'S', 'i' ), TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'e', 'd' ), TWO_BYTES( 'D', 'a' ),
    TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqChallengeVAAttrib2Value = { g_rgchLicAcqChallengeVAAttrib2Value, 10 };


/* "1" */
const DRM_CHAR g_rgchLicAcqVersionValue [] =
{
    TWO_BYTES( '1', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqVersionValue = { g_rgchLicAcqVersionValue, 1 };



/*
** ---------------------------------------------------------------
** XML strings used in the construction of license acknowledgement
** ---------------------------------------------------------------
*/
/* "AcknowledgeLicense" */
const DRM_CHAR g_rgchLicAckRootTag [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'k', 'n' ), TWO_BYTES( 'o', 'w' ), TWO_BYTES( 'l', 'e' ),
    TWO_BYTES( 'd', 'g' ), TWO_BYTES( 'e', 'L' ), TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ),
    TWO_BYTES( 's', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckRootTag = { g_rgchLicAckRootTag, 18 };


/* "Version" */
const DRM_CHAR g_rgchLicAckVersionTag [] =
{
    TWO_BYTES( 'V', 'e' ), TWO_BYTES( 'r', 's' ), TWO_BYTES( 'i', 'o' ), TWO_BYTES( 'n', '\0' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckVersionTag = { g_rgchLicAckVersionTag, 7 };


/* "challenge" */
const DRM_CHAR g_rgchLicAckChallenge1Tag [] =
{
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'n', 'g' ),
    TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckChallenge1Tag = { g_rgchLicAckChallenge1Tag, 9 };


/* "Challenge" */
const DRM_CHAR g_rgchLicAckChallenge2Tag [] =
{
    TWO_BYTES( 'C', 'h' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'n', 'g' ),
    TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckChallenge2Tag = { g_rgchLicAckChallenge2Tag, 9 };


/* "Ack" */
const DRM_CHAR g_rgchLicAckAckTag [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'k', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckAckTag = { g_rgchLicAckAckTag, 3 };


/* "Data" */
const DRM_CHAR g_rgchLicAckDataTag [] =
{
    TWO_BYTES( 'D', 'a' ), TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckDataTag = { g_rgchLicAckDataTag, 4 };


/* "TransactionID" */
const DRM_CHAR g_rgchLicAckTransactionIDTag [] =
{
    TWO_BYTES( 'T', 'r' ), TWO_BYTES( 'a', 'n' ), TWO_BYTES( 's', 'a' ), TWO_BYTES( 'c', 't' ),
    TWO_BYTES( 'i', 'o' ), TWO_BYTES( 'n', 'I' ), TWO_BYTES( 'D', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckTransactionIDTag = { g_rgchLicAckTransactionIDTag, 13 };


/* "LicenseStorageResults" */
const DRM_CHAR g_rgchLicAckLicenseStorageResultsTag [] =
{
    TWO_BYTES( 'L', 'i' ), TWO_BYTES( 'c', 'e' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', 'S' ),
    TWO_BYTES( 't', 'o' ), TWO_BYTES( 'r', 'a' ), TWO_BYTES( 'g', 'e' ), TWO_BYTES( 'R', 'e' ),
    TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckLicenseStorageResultsTag = { g_rgchLicAckLicenseStorageResultsTag, 21 };


/* "License" */
const DRM_CHAR g_rgchLicAckLicenseTag [] =
{
    TWO_BYTES( 'L', 'i' ), TWO_BYTES( 'c', 'e' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '\0' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckLicenseTag = { g_rgchLicAckLicenseTag, 7 };


/* "KID" */
const DRM_CHAR g_rgchLicAckKIDTag [] =
{
    TWO_BYTES( 'K', 'I' ), TWO_BYTES( 'D', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckKIDTag = { g_rgchLicAckKIDTag, 3 };


/* "LID" */
const DRM_CHAR g_rgchLicAckLIDTag [] =
{
    TWO_BYTES( 'L', 'I' ), TWO_BYTES( 'D', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckLIDTag = { g_rgchLicAckLIDTag, 3 };


/* "Result" */
const DRM_CHAR g_rgchLicAckResultTag [] =
{
    TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckResultTag = { g_rgchLicAckResultTag, 6 };


/* "CertificateChain" */
const DRM_CHAR g_rgchLicAckCertificateChainTag [] =
{
    TWO_BYTES( 'C', 'e' ), TWO_BYTES( 'r', 't' ), TWO_BYTES( 'i', 'f' ), TWO_BYTES( 'i', 'c' ),
    TWO_BYTES( 'a', 't' ), TWO_BYTES( 'e', 'C' ), TWO_BYTES( 'h', 'a' ), TWO_BYTES( 'i', 'n' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckCertificateChainTag = { g_rgchLicAckCertificateChainTag, 16 };



/* "xmlns" */
const DRM_CHAR g_rgchLicAckRootAttribName [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckRootAttribName = { g_rgchLicAckRootAttribName, 5 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols" */
const DRM_CHAR g_rgchLicAckRootAttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ),
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ),
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ),
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ),
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ),
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckRootAttribValue = { g_rgchLicAckRootAttribValue, 50 };


/* "xmlns" */
const DRM_CHAR g_rgchLicAckChallenge2AttribName [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckChallenge2AttribName = { g_rgchLicAckChallenge2AttribName, 5 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols/messages" */
const DRM_CHAR g_rgchLicAckChallenge2AttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ),
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ),
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ),
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ),
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ),
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '/', 'm' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 's', 'a' ),
    TWO_BYTES( 'g', 'e' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckChallenge2AttribValue = { g_rgchLicAckChallenge2AttribValue, 59 };


/* "xmlns" */
const DRM_CHAR g_rgchLicAckAckAttrib1Name [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckAckAttrib1Name = { g_rgchLicAckAckAttrib1Name, 5 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols" */
const DRM_CHAR g_rgchLicAckAckAttrib1Value [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ),
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ),
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ),
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ),
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ),
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckAckAttrib1Value = { g_rgchLicAckAckAttrib1Value, 50 };


/* "Id" */
const DRM_CHAR g_rgchLicAckAckAttrib2Name [] =
{
    TWO_BYTES( 'I', 'd' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckAckAttrib2Name = { g_rgchLicAckAckAttrib2Name, 2 };

/* "SignedData" */
const DRM_CHAR g_rgchLicAckAckAttrib2Value [] =
{
    TWO_BYTES( 'S', 'i' ), TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'e', 'd' ), TWO_BYTES( 'D', 'a' ),
    TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckAckAttrib2Value = { g_rgchLicAckAckAttrib2Value, 10 };



/* "1" */
const DRM_CHAR g_rgchLicAckVersionValue [] =
{
    TWO_BYTES( '1', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckVersionValue = { g_rgchLicAckVersionValue, 1 };



/*
** -------------------------------------------------------------
** XML strings used in the parsing of license challenge response
** -------------------------------------------------------------
*/

/* "AcquireLicenseResult/Response/LicenseResponse" */
const DRM_CHAR g_rgchLicLicenseResponsePath [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'q', 'u' ), TWO_BYTES( 'i', 'r' ), TWO_BYTES( 'e', 'L' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ), TWO_BYTES( 's', 'e' ), TWO_BYTES( 'R', 'e' ),
    TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ),
    TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '/' ), TWO_BYTES( 'L', 'i' ),
    TWO_BYTES( 'c', 'e' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', 'R' ), TWO_BYTES( 'e', 's' ),
    TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicLicenseResponsePath = { g_rgchLicLicenseResponsePath, 45 };


/* "AcquireLicenseResult/Response/Signature" */
const DRM_CHAR g_rgchLicSignaturePath [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'q', 'u' ), TWO_BYTES( 'i', 'r' ), TWO_BYTES( 'e', 'L' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ), TWO_BYTES( 's', 'e' ), TWO_BYTES( 'R', 'e' ),
    TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ),
    TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '/' ), TWO_BYTES( 'S', 'i' ),
    TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'a', 't' ), TWO_BYTES( 'u', 'r' ), TWO_BYTES( 'e', '\0' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicSignaturePath = { g_rgchLicSignaturePath, 39 };


/* "AcquireLicenseResult/Response/LicenseResponse/Licenses" */
const DRM_CHAR g_rgchLicLicensesPath [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'q', 'u' ), TWO_BYTES( 'i', 'r' ), TWO_BYTES( 'e', 'L' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ), TWO_BYTES( 's', 'e' ), TWO_BYTES( 'R', 'e' ),
    TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ),
    TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '/' ), TWO_BYTES( 'L', 'i' ),
    TWO_BYTES( 'c', 'e' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', 'R' ), TWO_BYTES( 'e', 's' ),
    TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '/' ), TWO_BYTES( 'L', 'i' ),
    TWO_BYTES( 'c', 'e' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicLicensesPath = { g_rgchLicLicensesPath, 54 };


/* "License" */
const DRM_CHAR g_rgchLicLicensePath [] =
{
    TWO_BYTES( 'L', 'i' ), TWO_BYTES( 'c', 'e' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '\0' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicLicensePath = { g_rgchLicLicensePath, 7 };

/* "AcquireLicenseResult" */
const DRM_CHAR g_rgchAcquireLicenseResultTag [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'q', 'u' ), TWO_BYTES( 'i', 'r' ), TWO_BYTES( 'e', 'L' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ), TWO_BYTES( 's', 'e' ), TWO_BYTES( 'R', 'e' ),
    TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrAcquireLicenseResultTag = { g_rgchAcquireLicenseResultTag, 20 };

/* "AcquireLicenseResult/Response/LicenseResponse/RevInfo" */
const DRM_CHAR g_rgchLicRevInfoPath [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'q', 'u' ), TWO_BYTES( 'i', 'r' ), TWO_BYTES( 'e', 'L' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ), TWO_BYTES( 's', 'e' ), TWO_BYTES( 'R', 'e' ),
    TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ),
    TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '/' ), TWO_BYTES( 'L', 'i' ),
    TWO_BYTES( 'c', 'e' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', 'R' ), TWO_BYTES( 'e', 's' ),
    TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '/' ), TWO_BYTES( 'R', 'e' ),
    TWO_BYTES( 'v', 'I' ), TWO_BYTES( 'n', 'f' ), TWO_BYTES( 'o', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicRevInfoPath = { g_rgchLicRevInfoPath, 53 };

/* "RevInfo" */
const DRM_CHAR g_rgchRevInfo [] =
{
    TWO_BYTES( 'R', 'e' ), TWO_BYTES( 'v', 'I' ), TWO_BYTES( 'n', 'f' ), TWO_BYTES( 'o', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrRevInfo = { g_rgchRevInfo, 7 };


/* "Revocation" */
const DRM_CHAR g_rgchLicRevocationPath [] =
{
    TWO_BYTES( 'R', 'e' ), TWO_BYTES( 'v', 'o' ), TWO_BYTES( 'c', 'a' ), TWO_BYTES( 't', 'i' ),
    TWO_BYTES( 'o', 'n' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicRevocationPath = { g_rgchLicRevocationPath, 10 };


/* "ListID" */
const DRM_CHAR g_rgchLicListIdPath [] =
{
    TWO_BYTES( 'L', 'i' ), TWO_BYTES( 's', 't' ), TWO_BYTES( 'I', 'D' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicListIdPath = { g_rgchLicListIdPath, 6 };


/* "ListData" */
const DRM_CHAR g_rgchLicListDataPath [] =
{
    TWO_BYTES( 'L', 'i' ), TWO_BYTES( 's', 't' ), TWO_BYTES( 'D', 'a' ), TWO_BYTES( 't', 'a' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicListDataPath = { g_rgchLicListDataPath, 8 };


/* "AcquireLicenseResult/Response/LicenseResponse/Acknowledgement/TransactionID" */
const DRM_CHAR g_rgchLicTransactionIDPath [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'q', 'u' ), TWO_BYTES( 'i', 'r' ), TWO_BYTES( 'e', 'L' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ), TWO_BYTES( 's', 'e' ), TWO_BYTES( 'R', 'e' ),
    TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ),
    TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '/' ), TWO_BYTES( 'L', 'i' ),
    TWO_BYTES( 'c', 'e' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', 'R' ), TWO_BYTES( 'e', 's' ),
    TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '/' ), TWO_BYTES( 'A', 'c' ),
    TWO_BYTES( 'k', 'n' ), TWO_BYTES( 'o', 'w' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'd', 'g' ),
    TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'e', 'n' ), TWO_BYTES( 't', '/' ), TWO_BYTES( 'T', 'r' ),
    TWO_BYTES( 'a', 'n' ), TWO_BYTES( 's', 'a' ), TWO_BYTES( 'c', 't' ), TWO_BYTES( 'i', 'o' ),
    TWO_BYTES( 'n', 'I' ), TWO_BYTES( 'D', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicTransactionIDPath = { g_rgchLicTransactionIDPath, 75 };


/* "AcquireLicenseResult/Response/LicenseResponse/SLK" */
const DRM_CHAR g_rgchLicSLKPath [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'q', 'u' ), TWO_BYTES( 'i', 'r' ), TWO_BYTES( 'e', 'L' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ), TWO_BYTES( 's', 'e' ), TWO_BYTES( 'R', 'e' ),
    TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ),
    TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '/' ), TWO_BYTES( 'L', 'i' ),
    TWO_BYTES( 'c', 'e' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', 'R' ), TWO_BYTES( 'e', 's' ),
    TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '/' ), TWO_BYTES( 'S', 'L' ),
    TWO_BYTES( 'K', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicSLKPath= { g_rgchLicSLKPath, 49 };


/*
** ---------------------------------------------------------------
** XML strings used in the parsing of license acknowledge response
** ---------------------------------------------------------------
*/

/* "AcquireLicenseResponse" */
const DRM_CHAR g_rgchAcquireLicenseResponseTag [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'q', 'u' ), TWO_BYTES( 'i', 'r' ), TWO_BYTES( 'e', 'L' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ), TWO_BYTES( 's', 'e' ), TWO_BYTES( 'R', 'e' ),
    TWO_BYTES( 's', 'p' ), TWO_BYTES( 'o', 'n' ), TWO_BYTES( 's', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrAcquireLicenseResponseTag = { g_rgchAcquireLicenseResponseTag, 22 };


/* "AcknowledgeLicenseResult/Response/LAck" */
const DRM_CHAR g_rgchLicAcqLAckPath [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'k', 'n' ), TWO_BYTES( 'o', 'w' ), TWO_BYTES( 'l', 'e' ),
    TWO_BYTES( 'd', 'g' ), TWO_BYTES( 'e', 'L' ), TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ),
    TWO_BYTES( 's', 'e' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ),
    TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ),
    TWO_BYTES( 'e', '/' ), TWO_BYTES( 'L', 'A' ), TWO_BYTES( 'c', 'k' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqLAckPath = { g_rgchLicAcqLAckPath, 38 };


/* "AcknowledgeLicenseResult/Response/Signature" */
const DRM_CHAR g_rgchLicAckSignaturePath [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'k', 'n' ), TWO_BYTES( 'o', 'w' ), TWO_BYTES( 'l', 'e' ),
    TWO_BYTES( 'd', 'g' ), TWO_BYTES( 'e', 'L' ), TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ),
    TWO_BYTES( 's', 'e' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ),
    TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ),
    TWO_BYTES( 'e', '/' ), TWO_BYTES( 'S', 'i' ), TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'a', 't' ),
    TWO_BYTES( 'u', 'r' ), TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckSignaturePath = { g_rgchLicAckSignaturePath, 43 };



/*
** ----------------------------------------------
** XML strings used in the parsing of custom data
** ----------------------------------------------
*/
/* "AcquireLicenseResult/Response/LicenseResponse/CustomData" */
const DRM_CHAR g_rgchLicAcqCustomDataPath [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'q', 'u' ), TWO_BYTES( 'i', 'r' ), TWO_BYTES( 'e', 'L' ),
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ), TWO_BYTES( 's', 'e' ), TWO_BYTES( 'R', 'e' ),
    TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ), TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ),
    TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '/' ), TWO_BYTES( 'L', 'i' ),
    TWO_BYTES( 'c', 'e' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', 'R' ), TWO_BYTES( 'e', 's' ),
    TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 'e', '/' ), TWO_BYTES( 'C', 'u' ),
    TWO_BYTES( 's', 't' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( 'D', 'a' ), TWO_BYTES( 't', 'a' ),
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAcqCustomDataPath = { g_rgchLicAcqCustomDataPath, 56 };


/* "AcknowledgeLicenseResult/Response/LAck/CustomData" */
const DRM_CHAR g_rgchLicAckCustomDataPath [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'k', 'n' ), TWO_BYTES( 'o', 'w' ), TWO_BYTES( 'l', 'e' ),
    TWO_BYTES( 'd', 'g' ), TWO_BYTES( 'e', 'L' ), TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'n' ),
    TWO_BYTES( 's', 'e' ), TWO_BYTES( 'R', 'e' ), TWO_BYTES( 's', 'u' ), TWO_BYTES( 'l', 't' ),
    TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'p', 'o' ), TWO_BYTES( 'n', 's' ),
    TWO_BYTES( 'e', '/' ), TWO_BYTES( 'L', 'A' ), TWO_BYTES( 'c', 'k' ), TWO_BYTES( '/', 'C' ),
    TWO_BYTES( 'u', 's' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'm', 'D' ), TWO_BYTES( 'a', 't' ),
    TWO_BYTES( 'a', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrLicAckCustomDataPath = { g_rgchLicAckCustomDataPath, 49 };


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmlicparser.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmblackbox.h>
#include <drmlicenseparser.h>
#include <drmlicense.h>
#include <drmxmlparser.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

#define RESTRICTED_COUNT    3
const DRM_BYTE CERT_SUBJECT_RESTRICTED[RESTRICTED_COUNT][__CB_DECL(SUBJ_LEN)] = 
{
    {   TWO_BYTES(0, 0), TWO_BYTES(0, 2)    }, 
    {   TWO_BYTES(0, 0), TWO_BYTES(0, 3)    }, 
    {   TWO_BYTES(0, 0), TWO_BYTES(0, 4)    }
};

static const PUBKEY g_BrLicSrvPubl =
{
    {
        TWO_BYTES(0x34, 0x8b), TWO_BYTES(0x02, 0xae), TWO_BYTES(0xb6, 0x3a), TWO_BYTES(0x58, 0x8d),
        TWO_BYTES(0xb6, 0xf5), TWO_BYTES(0x38, 0x3b), TWO_BYTES(0x46, 0x47), TWO_BYTES(0xb2, 0xcd),
        TWO_BYTES(0xf5, 0x77), TWO_BYTES(0x67, 0x31), TWO_BYTES(0xaa, 0xe8), TWO_BYTES(0x33, 0x44),
        TWO_BYTES(0x44, 0xdb), TWO_BYTES(0x90, 0x95), TWO_BYTES(0xbb, 0x7f), TWO_BYTES(0xcc, 0x51),
        TWO_BYTES(0x80, 0x9d), TWO_BYTES(0x2d, 0x3a), TWO_BYTES(0x7f, 0xbd), TWO_BYTES(0x4c, 0x08)
    }
};

/******************************************************************************
** 
** Function :   DRM_LIC_GetAttribute
** 
** Synopsis :   Get an attribute from a license
** 
** Arguments :  pdstrLicense    - License string
**              pdstrAttrName   - Name of attribute
**              eAttribute      - Type of ettribute
**              pdstrLIData     - (Optional) LICENSORINFO\DATA section. If a 
**                                valid string, attribute will be searched 
**                                directly in this. On exit, the pointer will be 
**                                updated 
**              pdstrValue      - Value of attribute
**              chXPathSeparator- path separator to use
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LIC_GetAttribute(
    IN const DRM_CONST_STRING        *pdstrLicense, 
    IN const DRM_CONST_STRING        *pdstrAttrName,
    IN       eDRM_LICENSE_ATTRIBUTES  eAttribute,
    IN  OUT  DRM_CONST_STRING        *pdstrLIData,
        OUT  DRM_CONST_STRING        *pdstrValue,
    IN       DRM_WCHAR                chXPathSeparator)
{
    DRM_RESULT               dr = DRM_SUCCESS;    
    DRM_CONST_STRING        *pdstrSectionData   = NULL;    
    DRM_CONST_STRING         dstrSectionData    = EMPTY_DRM_STRING;
    DRM_CONST_STRING         dstrLicenseBody    = EMPTY_DRM_STRING;  
    const DRM_CONST_STRING  *pdstr              = NULL;
    DRM_BOOL                 fParseRevocationIndex = FALSE;

    ChkArg( pdstrLicense != NULL
         && pdstrValue   != NULL );
    
    if( chXPathSeparator == 0 )
    {
        chXPathSeparator = g_wchForwardSlash;
    }
    if ((eAttribute != DRM_LICENSE_ATTRIB_OTHER && 
         eAttribute != DRM_LICENSE_ATTRIB_REVOCATION &&
         eAttribute != DRM_LICENSE_ATTRIB_META_ATTRIBUTE ) && 
         NULL       != pdstrAttrName )
    {
        /* We allow user specified strings for META attributes, OTHER attribues and REVOCATION attributes */
        dr = DRM_E_INVALIDARG;
        goto ErrorExit;
    }

    if ( pdstrLIData == NULL )
    {
        pdstrSectionData = &dstrSectionData;
    }
    else
    {
        pdstrSectionData = pdstrLIData;
    }
    if ( pdstrLIData == NULL || pdstrLIData->cchString == 0 )
    {
        ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLIData, NULL, NULL, pdstrSectionData, NULL, g_wchForwardSlash ) );
    }

    switch( eAttribute )
    {

        case DRM_LICENSE_ATTRIB_VERSION:        
            /* skip <?xml version="1.0"?>, if any */
            ChkDR(DRM_XML_GetNode(pdstrLicense, &g_dstrLicense, NULL, NULL, 0, &dstrLicenseBody, NULL));

            /* get the attr value */
            dr = DRM_XML_GetNodeAttribute( &dstrLicenseBody, &g_dstrAttributeVersion, pdstrValue);
            goto ErrorExit;

        case DRM_LICENSE_ATTRIB_KID:
            pdstr = &g_dstrTagKID;
            break;

        case DRM_LICENSE_ATTRIB_LID:
            pdstr = &g_dstrTagLID;
            break;
            
        case DRM_LICENSE_ATTRIB_METERING_ID:
            pdstr = &g_dstrTagMID; 
            break;
            
        case DRM_LICENSE_ATTRIB_REVOCATION:
            /* What type of revocation are they asking for? */
            /* We special case app revocation... */
            ChkArg( pdstrAttrName ); /* An attribute name is required if revocation lists are needed */
            if( DRM_UTL_DSTRStringsEqual( &g_dstrAppRevocation, pdstrAttrName ) )
            {
                pdstr = &g_dstrAppRevocation;
                pdstrAttrName = NULL;
            }
            else
            {
                fParseRevocationIndex = TRUE;
                pdstr = &g_dstrTagRevocation;
            }
            break;

        case DRM_LICENSE_ATTRIB_ISSUEDATE:
            pdstr = &g_dstrIssueDate;
            break;

        case DRM_LICENSE_ATTRIB_CONTENTPUBKEY:
            pdstr = &g_dstrContentPubKey;
            break;

        case DRM_LICENSE_ATTRIB_PRIORITY:
            pdstr = &g_dstrPriority;
            break;

        case DRM_LICENSE_ATTRIB_CHAINEDKID:
            pdstr = &g_dstrUplinkKid;
            break;

        case DRM_LICENSE_ATTRIB_META_ATTRIBUTE:        
            /* We are at the Data section.  We need to move to the META section */        
            ChkDR( DRM_XML_GetSubNodeByPath( pdstrSectionData, &g_dstrMeta, NULL, NULL, pdstrValue, NULL, g_wchForwardSlash ) );
            pdstrSectionData = pdstrValue;
            /* Fall through as META and regular attribute are the same.  Only difference is that we needed to be at a different
            node for META, which we are now. */

        case DRM_LICENSE_ATTRIB_OTHER:
            ChkArg( pdstrAttrName != NULL );
            pdstr = pdstrAttrName;
            pdstrAttrName = NULL;
            break;
            
        case DRM_LICENSE_ATTRIB_REVINFO:
            pdstr = &g_dstrTagRevInfoVersion;
            break;

        case DRM_LICENSE_ATTRIB_SOURCEID:
            pdstr = &g_dstrTagSourceID;
            break;
            
        default:
            ChkDR (DRM_E_INVALIDARG);
    }
    if( pdstrAttrName == NULL )
    {
        ChkDR( DRM_XML_GetSubNodeByPath( pdstrSectionData, pdstr, NULL, NULL, NULL, pdstrValue, chXPathSeparator ) );
    }
    else
    {
        ChkDR( DRM_XML_GetSubNodeByPath( pdstrSectionData, pdstr, &g_dstrAttributeType, pdstrAttrName, NULL, pdstrValue, chXPathSeparator ) );
    }

    if( fParseRevocationIndex )
    {
        DRM_CONST_STRING dstrValue = *pdstrValue;

        /*
        **  The caller is asking for a revocation list version requirement.  We should have a string that looks like
        **  <INDEX>x<INDEX> and we want to return x.
        */
        ChkDR( DRM_XML_GetSubNode( &dstrValue, &g_dstrTagIndex, NULL, NULL, 0, NULL, pdstrValue, 0));        
    }

ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_LIC_GetEvent
** 
** Synopsis :   Parse and get details about an event from a license
** 
** Arguments :  pdstrLicense    - License string
**              pdstrEvent      - Name of event
**              pdstrTypeValue  - Type of event
**              pdstrLIData     - (Optional) LICENSORINFO\DATA section. If a 
**                                valid string, attribute will be searched 
**                                directly in this. On exit, the pointer will be 
**                                updated 
**              pdstrCondition  - Condition node from event
**              pdstrAction     - Action node from event
**              pdstrRestriction- Restriction node from event
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LIC_GetEvent(
    IN const DRM_CONST_STRING *pdstrLicense, 
    IN const DRM_CONST_STRING *pdstrEvent, 
    IN const DRM_CONST_STRING *pdstrTypeValue, 
    IN  OUT  DRM_CONST_STRING *pdstrLIData,
    OUT      DRM_CONST_STRING *pdstrCondition,     
    OUT      DRM_CONST_STRING *pdstrAction,
    OUT      DRM_CONST_STRING *pdstrRestriction)
{
    DRM_RESULT           dr                 = DRM_SUCCESS;
    DRM_CONST_STRING    *pdstrSectionData   = NULL;    
    DRM_CONST_STRING     dstrSectionData    = EMPTY_DRM_STRING;
    DRM_CONST_STRING     dstrListEvent      = EMPTY_DRM_STRING;

    if ( pdstrLIData == NULL)
    {
        pdstrSectionData = &dstrSectionData;
        ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLIData, NULL, NULL, pdstrSectionData, NULL, g_wchForwardSlash ) );    
    }
    else
    {
        pdstrSectionData = pdstrLIData;
        if ( pdstrSectionData->cchString == 0)
        {
            pdstrSectionData = pdstrLIData;
            ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLIData, NULL, NULL, pdstrSectionData, NULL, g_wchForwardSlash ) );    
        }
    }
    ChkDR( DRM_XML_GetSubNode( pdstrSectionData, 
                               pdstrEvent, 
                               pdstrTypeValue?&g_dstrAttributeType:NULL, 
                               pdstrTypeValue, 
                               0, 
                               &dstrListEvent, 
                               NULL, 
                               1 ) );
    if (NULL != pdstrCondition)
    {
        /* ONSTORE must use ACTION.CDATA not CONDITION.CDATA... */
        if( DRM_FAILED( DRM_XML_GetSubNodeByPath( &dstrListEvent, &g_dstrCondition, NULL, NULL, NULL, pdstrCondition, g_wchForwardSlash) ) )
        {
            INIT_DRM_STRING( *pdstrCondition );
        }
    }

    if (NULL != pdstrAction)
    {        
        if( DRM_FAILED( DRM_XML_GetSubNodeByPath( &dstrListEvent, &g_dstrAction, NULL, NULL, NULL, pdstrAction, g_wchForwardSlash) ) )
        {          
            INIT_DRM_STRING( *pdstrAction );
        }
    }

    if (NULL != pdstrRestriction)
    {  
        if( DRM_FAILED( DRM_XML_GetSubNode( &dstrListEvent, 
                                            &g_dstrRestrictions, 
                                            NULL, 
                                            NULL, 
                                            0,
                                            NULL, 
                                            pdstrRestriction, 
                                            1 ) ) )
        {
            INIT_DRM_STRING( *pdstrRestriction );            
        }        
    }

    dr = DRM_SUCCESS;
ErrorExit:
    return(dr);
}

static DRM_NO_INLINE DRM_RESULT GetLSPubKey(
    const DRM_CONST_STRING   *pdstrLicense, 
          PUBKEY             *pbPubKey, 
          DRM_CRYPTO_CONTEXT *pcontextCrypto)
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrCert          = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrListCertChain = EMPTY_DRM_STRING;
    DRM_DWORD        iNode = 0;
    
    if (pbPubKey == NULL)
    {
        dr = LIC_PARAM_NOT_OPTIONAL;
        goto ErrorExit;
    }
        
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrCertChain, NULL, NULL, &dstrListCertChain, NULL, g_wchForwardSlash ) );
    while( DRM_SUCCEEDED( DRM_XML_GetSubNode( &dstrListCertChain, &g_dstrTagCertificate, NULL, NULL, iNode, &dstrCert, NULL, 1 ) ) )
    {
        iNode++;
    }
    if( iNode == 0 )
    {
        dr = LIC_INVALID_LICENSE;
        goto ErrorExit;
    }

    ChkDR( DRM_XML_GetSubNode( &dstrListCertChain, &g_dstrTagCertificate, NULL, NULL, iNode - 1, NULL, &dstrCert, 1 ) );
    iNode = SIZEOF( CERT );
    ChkDR(DRM_B64_DecodeW(&dstrCert, &iNode, (DRM_BYTE *)&(pcontextCrypto->union_cert.cert), 0 ) );
    MEMCPY( pbPubKey, &(pcontextCrypto->union_cert.cert.cd.pk), SIZEOF(PUBKEY) );    

ErrorExit:
    if( DRM_FAILED( dr ) )
    {
        dr = LIC_INVALID_LICENSE;
    }

    return(dr);
}

DRM_API DRM_RESULT DRM_CALL DRM_LIC_GetEnablingBits(
    IN const DRM_CONST_STRING   *pdstrLicense,
    IN       DRM_DWORD           dwIndex,
    OUT      DRM_DWORD          *pdwAlgorithm,
    OUT      PUBKEY             *pPubKey, 
    __out_bcount_opt( *pdValueLen ) DRM_BYTE *pbValue, 
    OUT      DRM_DWORD          *pdValueLen, 
    OUT      PUBKEY             *pVerPubKey, 
    __out_bcount( DRM_ECC160_SIGNATURE_LEN ) DRM_BYTE *pbSignature,
    __out_bcount_opt( CHECKSUM_LENGTH ) DRM_BYTE rgbChainedChecksum[CHECKSUM_LENGTH],
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto)
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrString              = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrEnablingBitsSection = EMPTY_DRM_STRING;
    DRM_DWORD        dwSize                  = SIZEOF( PUBKEY );
    DRM_BOOL         fSymmetricallyBound     = FALSE;

    if ( pPubKey     == NULL 
      || pdValueLen  == NULL 
      || pbSignature == NULL )
    {
        dr = LIC_PARAM_NOT_OPTIONAL;
        goto ErrorExit;
    }

    dr = DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrDrmRestoreInfoEnablingBits, NULL, NULL, &dstrEnablingBitsSection, NULL, g_wchForwardSlash );
    if( DRM_FAILED( dr ) 
     && dwIndex == 0 )
    {
        /* There is no restore enabling bits.  So 0 index is the first regular enabling bits */
        dwIndex++;
    }

    if( dwIndex > 0 )
    {
        ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLIData, NULL, NULL, &dstrString, NULL, g_wchForwardSlash ) );
        dr = DRM_XML_GetSubNode( &dstrString, &g_dstrTagEnablingbits, NULL, NULL, dwIndex - 1, &dstrEnablingBitsSection, NULL, 1);
        if( DRM_FAILED( dr ) )
        {
            /* These was no ENABLINGBITS section.  This could be a chained license.  Look for CHAINEDENABLINGBITS */
            ChkDR( DRM_XML_GetSubNode( &dstrString, &g_dstrChainedEnablingBits, NULL, NULL, dwIndex - 1, &dstrEnablingBitsSection, NULL, 1) );
            if( NULL != rgbChainedChecksum )
            {
                /* Get Chained Checksum */
                ChkDR( DRM_XML_GetSubNodeByPath( &dstrEnablingBitsSection, &g_dstrChainedCheckSum, NULL, NULL, NULL, &dstrString, g_wchForwardSlash ) );
                /* Decode PubKey */
                dwSize = CHECKSUM_LENGTH;
                ChkDR(DRM_B64_DecodeW(&dstrString, &dwSize, rgbChainedChecksum, 0) );
            }

        }
        else
        {
            ChkDR( DRM_XML_GetSubNodeByPath( &dstrEnablingBitsSection, &g_dstrTagPubkey, NULL, NULL, NULL, &dstrString, g_wchForwardSlash ) );
            /* Decode PubKey */
            dwSize = SIZEOF( PUBKEY );
            ChkDR( DRM_B64_DecodeW(&dstrString, &dwSize, (DRM_BYTE *)pPubKey, 0) );
        }

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
        /* Get PubKey     */
        if( DRM_SUCCEEDED( DRM_XML_GetSubNode(  pdstrLicense,
                                               &g_dstrTagSymValue,
                                                NULL,
                                                NULL,
                                                0,
                                               &dstrString,
                                                NULL,
                                                2 ) ) )
        {
            /* This license has been rebound to a symmetric key.  Ensure that we return the correct values in this case */
            fSymmetricallyBound = TRUE;
        }
#endif

        if ( NULL != pVerPubKey )
        {
            ChkDR( GetLSPubKey( pdstrLicense, pVerPubKey, pcontextCrypto ) );
        }
    }
    else if( NULL != pVerPubKey )
    {
        /* Get PubKey     */
        ChkDR( DRM_XML_GetSubNodeByPath( &dstrEnablingBitsSection, &g_dstrTagPubkey, NULL, NULL, NULL, &dstrString, g_wchForwardSlash ) );
        /* Decode PubKey */
        dwSize = SIZEOF( PUBKEY );
        ChkDR(DRM_B64_DecodeW(&dstrString, &dwSize, (DRM_BYTE *)pPubKey, 0) );
        MEMCPY(pVerPubKey, &g_BrLicSrvPubl, SIZEOF(PUBKEY) );
    }

    if (NULL != pdwAlgorithm )
    {
        if( fSymmetricallyBound )
        {
            *pdwAlgorithm = eMSDRM_SYM;
        }
        else
        {
            DRM_CONST_STRING dstrAlgo = EMPTY_DRM_STRING;

            *pdwAlgorithm = 0;

            ChkDR( DRM_XML_GetSubNodeByPath( &dstrEnablingBitsSection, &g_dstrTagHashAlgorithm, NULL, NULL, &dstrString, NULL, g_wchForwardSlash ) );
            ChkDR( DRM_XML_GetNodeAttribute( &dstrString, &g_dstrAttributeType, &dstrAlgo ) );
            if( DRM_UTL_DSTRStringsEqual( &dstrAlgo, &g_dstrMSDRM ) )
            {
                *pdwAlgorithm = eMSDRM_PK;
                /* Is is a eMSDRM_PK algorithm */
            }
            else if( DRM_UTL_DSTRStringsEqual( &dstrAlgo, &g_dstrMSDRM_CK ) )
            {
                *pdwAlgorithm = eMSDRM_CK;
                /* It is a eMSDRM_CK algorithm */
            }
            else
            {
                ChkDR( DRM_E_UNSUPPORTEDALGORITHM );
            }
        }
    }

    /* Get Value     */
    if( fSymmetricallyBound )
    {
        ChkDR( DRM_XML_GetSubNode( pdstrLicense, &g_dstrTagSymValue, NULL, NULL, 0, NULL, &dstrString, 2) );
    }
    else
    {
        ChkDR( DRM_XML_GetSubNodeByPath( &dstrEnablingBitsSection, &g_dstrTagValue, NULL, NULL, NULL, &dstrString, g_wchForwardSlash ) );
    }
    
    /* Base64 Decode Value */
    ChkDR(DRM_B64_DecodeW(&dstrString, pdValueLen, pbValue, 0 ) );

    /* Get Signature     */
    ChkDR( DRM_XML_GetSubNodeByPath( &dstrEnablingBitsSection, &g_dstrTagSignature, NULL, NULL, NULL, &dstrString, g_wchForwardSlash ) );

    /* Decode Signature */
    dwSize = DRM_ECC160_SIGNATURE_LEN;
    ChkDR(DRM_B64_DecodeW(&dstrString, &dwSize, pbSignature, 0) );

    dr = DRM_SUCCESS;
ErrorExit:
    return(dr);
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LIC_VerifySignature(
    IN const DRM_CONST_STRING *pdstrLicense,
    IN       DRM_BB_CONTEXT   *pcontextBBX,
       OUT   DRM_LONG         *plResult)
{
    DRM_RESULT       dr  = DRM_SUCCESS;    
    DRM_CONST_STRING dstrData      = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrSignature = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrLID       = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrBRInfo    = EMPTY_DRM_STRING;
    DRM_DWORD        dwSize = DRM_ECC160_SIGNATURE_LEN;
#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
    DRM_CONST_STRING dstrLicInfo   = EMPTY_DRM_STRING;
#endif
    
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMLICPARSER, PERF_FUNC_DRM_LIC_VerifySignature);
    
    ChkArg ( plResult     != NULL 
          && pdstrLicense != NULL
          && pcontextBBX  != NULL );

    *plResult = 0; /* Init. */

    ChkDR( GetLSPubKey(pdstrLicense, &pcontextBBX->CryptoContext.pubKey, &pcontextBBX->CryptoContext ) );
    
    /* Get DATA section     */
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLIData, NULL, NULL, &dstrData, NULL, g_wchForwardSlash ) );

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
    /* Look for a SYMMETRIC signature first.  If not found then proceed to regular signature verification */
    if( DRM_SUCCEEDED( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLicensorInfoNode, NULL, NULL, &dstrLicInfo, NULL, g_wchForwardSlash ) ) )
    {
        if( DRM_SUCCEEDED( DRM_XML_GetSubNode( &dstrLicInfo,
                                               &g_dstrTagSymSig,
                                                NULL,
                                                NULL,
                                                0,
                                                NULL,
                                                &dstrSignature,
                                                1 ) ) )
        {
            /* There is a symmetric signature, verify it. */
            DRM_BYTE rgbSymSig[__CB_DECL( DRM_SHA1_DIGEST_LEN )];
            
            dwSize = SIZEOF( rgbSymSig );
            ChkDR( DRM_B64_DecodeW( &dstrSignature, &dwSize, rgbSymSig, 0 ) );
            ChkDR( DRM_BBX_SymmetricVerify( pcontextBBX, 
                                            PB_DSTR( &dstrData ), 
                                            CB_DSTR( &dstrData ), 
                                            NULL,
                                            rgbSymSig ) );

            /* Signture verification passed.  Skip the rest of the function */
            *plResult = 1;
            goto ErrorExit;
        }
    }
#endif


    /* Get the LID */
    ChkDR( DRM_XML_GetSubNodeByPath( &dstrData, &g_dstrTagLID, NULL, NULL, &dstrLID, NULL, g_wchForwardSlash ) );

    if( DRM_FAILED( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLISigHashAlgo, &g_dstrAttributeType, &g_dstrSHA, &dstrSignature, NULL, g_wchForwardSlash ) ) )
    {
        dr = LIC_UNSUPPORTED_VALUE;
        goto ErrorExit;
    }


    if( DRM_FAILED( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLISigAlgo, &g_dstrAttributeType, &g_dstrMSDRM, &dstrSignature, NULL, g_wchForwardSlash ) ) )
    {
        dr = LIC_UNSUPPORTED_VALUE;
        goto ErrorExit;
    }
    
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLISigValue, NULL, NULL, NULL, &dstrSignature, g_wchForwardSlash ) );
    dwSize = DRM_ECC160_SIGNATURE_LEN;
    ChkDR(DRM_B64_DecodeW(&dstrSignature, &dwSize, pcontextBBX->CryptoContext.signature, 0 ) );

    if ( DRM_SUCCEEDED( DRM_PK_Verify( pcontextBBX->CryptoContext.rgbCryptoContext, 
                                       eDRM_ECC_P160,
                                       DRM_ECC160_PUBLIC_KEY_LEN,
                                       ( const DRM_BYTE * )&pcontextBBX->CryptoContext.pubKey, 
                                       CB_DSTR(&dstrData),
                                       PB_DSTR(&dstrData),  
                                       DRM_ECC160_SIGNATURE_LEN,
                                       pcontextBBX->CryptoContext.signature) ) )
    {
        if( DRM_SUCCEEDED( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrDrmRestoreInfo, NULL, NULL, &dstrBRInfo, NULL, g_wchForwardSlash ) ) )
        {
            /* The DRMRESTOREINFO section exists so we need to validate that             */
            
            
            ChkDR( DRM_XML_GetSubNodeByPath( &dstrBRInfo, &g_dstrTagSignature, NULL, NULL, &dstrData, NULL, g_wchForwardSlash ) );
            
            /* 
            ** Get the SHA hashalgorithm and MSDRM signalgorithm.  
            ** Don't do anything with it just make sure it is there
            */
            ChkDR( DRM_XML_GetSubNode( &dstrData, &g_dstrTagHashAlg, &g_dstrAttributeType, &g_dstrSHA,   0, &dstrSignature, NULL, 1 ) );
            ChkDR( DRM_XML_GetSubNode( &dstrData, &g_dstrTagSignAlg, &g_dstrAttributeType, &g_dstrMSDRM, 0, &dstrSignature, NULL, 1 ) );

            ChkDR( DRM_XML_GetSubNodeByPath( &dstrBRInfo, &g_dstrXPathSigValue, NULL, NULL, NULL,       &dstrSignature, g_wchForwardSlash ) );            
            ChkDR( DRM_XML_GetSubNodeByPath( &dstrBRInfo, &g_dstrTagData,       NULL, NULL, &dstrData,   NULL,          g_wchForwardSlash ) );

            /* Get the LID that is in the DRMRESTOREINFO/DATA section */
            ChkDR( DRM_XML_GetSubNodeByPath( &dstrData,   &g_dstrTagLID,        NULL, NULL, &dstrBRInfo, NULL,          g_wchForwardSlash ) );

            /* Compare with the original LID to prevent a spoofing attack */
            if( !DRM_UTL_DSTRStringsEqual( &dstrBRInfo, &dstrLID ) )
            {
                /* The LID from the original license and the LID in the B/R info don't match */
                /* Someone isn't playing nice.  We fail the signature check because something is fishy. */
                dr = LIC_INVALID_LICENSE;
                goto ErrorExit;
            }
            dwSize = DRM_ECC160_SIGNATURE_LEN;
            ChkDR(DRM_B64_DecodeW(&dstrSignature, &dwSize, pcontextBBX->CryptoContext.signature, 0) );

            if( dstrData.cchString > ((DRM_DWORD)(-1)) ||
                dstrData.cchString * SIZEOF( DRM_WCHAR ) > ((DRM_DWORD)(-1)) )
            {
                dr = DRM_E_ARITHMETIC_OVERFLOW;
                goto ErrorExit;
            }

            if ( DRM_SUCCEEDED( DRM_PK_Verify( pcontextBBX->CryptoContext.rgbCryptoContext, 
                                               eDRM_ECC_P160,
                                               DRM_ECC160_PUBLIC_KEY_LEN,
                                               ( const DRM_BYTE * )&g_BrLicSrvPubl, 
                                               CB_DSTR(&dstrData),
                                               PB_DSTR(&dstrData),  
                                               DRM_ECC160_SIGNATURE_LEN,
                                               pcontextBBX->CryptoContext.signature) ) )             
            {
                *plResult = 1;
            }

        }
        else
        {
            *plResult = 1;
        }
    }
    dr = DRM_SUCCESS;
    
ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
        
    return( dr );
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LIC_VerifyCertChain(
    IN const DRM_CONST_STRING    *pdstrLicense, 
    IN       DRM_BOOL             fCheckExpiry,
    IN       DRM_LICEVAL_CONTEXT *pcontextLEVL,
    OUT      DRM_LONG            *plResult)
{
    DRM_RESULT       dr = DRM_SUCCESS;    
    DRM_CONST_STRING dstrCert          = EMPTY_DRM_STRING; 
    DRM_CONST_STRING dstrListCertChain = EMPTY_DRM_STRING;
    DRM_DWORD        dwIndex = 0;
    DRM_BOOL         fFirstCertCheck = TRUE;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMLICPARSER, PERF_FUNC_DRM_LIC_VerifyCertChain);

    ChkArg( plResult     != NULL
         && pdstrLicense != NULL
         && pcontextLEVL != NULL );

    *plResult = 0;
    
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrCertChain, NULL, NULL, &dstrListCertChain, NULL, g_wchForwardSlash ) );

    for(dwIndex = 0; DRM_SUCCEEDED(dr); dwIndex++ )
    {
        DRM_DWORD dwSize = SIZEOF( CERT );
        dr = DRM_XML_GetSubNode( &dstrListCertChain, 
                                 &g_dstrTagCertificate, 
                                 NULL, 
                                 NULL, 
                                 dwIndex, 
                                 NULL, 
                                 &dstrCert, 
                                 1 );
        if ( (dr == DRM_E_XMLNOTFOUND) && (dwIndex == 0) )
        {
            ChkDR( LIC_INVALID_LICENSE );
        }
        else if ( DRM_SUCCEEDED(dr) )
        {                    
            ChkDR(DRM_B64_DecodeW(&dstrCert, 
                                  &dwSize, 
                                  (DRM_BYTE*) &(pcontextLEVL->pcontextBBX->CryptoContext.union_cert.cert), 
                                  0));
            ChkDR( DRM_UTL_CheckCert( &(pcontextLEVL->pcontextBBX->CryptoContext.union_cert.cert), 
                                      fFirstCertCheck?NULL:&(pcontextLEVL->pcontextBBX->CryptoContext.pubKey),
                                      fCheckExpiry, 
                                      pcontextLEVL) );
            MEMCPY( &(pcontextLEVL->pcontextBBX->CryptoContext.pubKey), 
                    &(pcontextLEVL->pcontextBBX->CryptoContext.union_cert.cert.cd.pk), 
                    SIZEOF( PUBKEY ) );
            fFirstCertCheck = FALSE;   
        }
    }

    *plResult = 1;
    dr = DRM_SUCCESS;

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
        
    return(dr);
}

#if DRM_SUPPORT_CONTENT_REVOCATION

DRM_API DRM_RESULT DRM_CALL DRM_LIC_VerifyContentRevocation(
    IN const DRM_CONST_STRING   *pdstrContentRevocation, 
    OUT      DRM_CONST_STRING   *pdstrLSPubKey,
    OUT      DRM_DWORD          *pdwSequenceNumber,
    OUT      DRM_CONST_STRING   *pdstrContentOwnerPubKey,
    OUT      DRM_CONST_STRING   *pdstrCondition,
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto)
{
    DRM_RESULT       dr = DRM_E_LOGICERR;
    DRM_CONST_STRING dstrData          = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrContentPubKey = EMPTY_DRM_STRING;
    DRM_DWORD        dwSize = 0;

    ChkArg( pcontextCrypto         != NULL
         && pdstrContentRevocation != NULL );
        
    /* Initialize output parameters. */
    if (NULL != pdwSequenceNumber)
    {
        *pdwSequenceNumber = 0;
    }
    if (NULL != pdstrContentOwnerPubKey)
    {
        INIT_DRM_STRING( *pdstrContentOwnerPubKey );
    }
    if (NULL != pdstrCondition)
    {
        INIT_DRM_STRING( *pdstrCondition );
    }
        
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrContentRevocation, &g_dstrTagData, NULL, NULL, &dstrData, NULL, g_wchForwardSlash ) );

    /* Get Sequence Number */
    if (NULL != pdwSequenceNumber)
    {
        DRM_CONST_STRING dstrSequenceNumber = EMPTY_DRM_STRING;        
        dr = DRM_XML_GetSubNodeByPath( &dstrData, &g_dstrSequenceNumber, NULL, NULL, NULL, &dstrSequenceNumber, g_wchForwardSlash );
        if( DRM_SUCCEEDED( dr ) )
        {
            ChkDR (DRMCRT_wcsntol (dstrSequenceNumber.pwszString, 
                            dstrSequenceNumber.cchString, 
               (DRM_LONG *) pdwSequenceNumber));
        }
    }

    /* Get Content Owner PubKey     */
    ChkDR( DRM_XML_GetSubNodeByPath( &dstrData, &g_dstrContentPubKey, NULL, NULL, NULL, &dstrContentPubKey, g_wchForwardSlash ) );
    if (NULL != pdstrContentOwnerPubKey)
    {
        ASSIGN_DRM_STRING( *pdstrContentOwnerPubKey, dstrContentPubKey );
    }
    dwSize = SIZEOF( PUBKEY );
    ChkDR(DRM_B64_DecodeW(&dstrContentPubKey, &dwSize, (DRM_BYTE *)&(pcontextCrypto->pubKey), 0 ) );

    /* Get License Server PubKey. It is optional. */
    if (NULL != pdstrLSPubKey)
    {        
        dr = DRM_XML_GetSubNodeByPath( &dstrData, &g_dstrLSPubKey, NULL, NULL, NULL, pdstrLSPubKey, g_wchForwardSlash );
        if( DRM_FAILED( dr ) )
        {
            INIT_DRM_STRING( *pdstrLSPubKey );
        }
    }

    /* Get the Condition */
    if (NULL != pdstrCondition)
    {
        if( DRM_FAILED( DRM_XML_GetSubNodeByPath( &dstrData, &g_dstrCondition, NULL, NULL, NULL, pdstrCondition, g_wchForwardSlash) ) )
        {
            INIT_DRM_STRING( *pdstrCondition );
        }
    }
    
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrContentRevocation, &g_dstrTagSignature, NULL, NULL, &dstrContentPubKey, NULL, g_wchForwardSlash ) );

    /* Get the SHA hashalgorithm.  Don't do anything with it just make sure it is there */
    ChkDR( DRM_XML_GetSubNode( &dstrContentPubKey, &g_dstrTagHashAlg, &g_dstrAttributeType, &g_dstrSHA, NULL, &dstrData, NULL, 1 ) );

    /* Get the MSDRM signalgorithm.  Don't do anything with it just make sure it is there */
    ChkDR( DRM_XML_GetSubNode( &dstrContentPubKey, &g_dstrTagSignAlg, &g_dstrAttributeType, &g_dstrMSDRM, NULL, &dstrData, NULL, 1 ) );

    ChkDR( DRM_XML_GetSubNodeByPath( pdstrContentRevocation, &g_dstrXPathSigValue, NULL, NULL, NULL, &dstrData, g_wchForwardSlash ) );
    dwSize = DRM_ECC160_SIGNATURE_LEN;
    ChkDR(DRM_B64_DecodeW(&dstrData, &dwSize, pcontextCrypto->signature, 0) );
    
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrContentRevocation, &g_dstrTagData, NULL, NULL, &dstrData, NULL, g_wchForwardSlash ) );

    if( dstrData.cchString > ((DRM_DWORD)(-1)) ||
        dstrData.cchString * SIZEOF( DRM_WCHAR ) > ((DRM_DWORD)(-1)) )
    {
        ChkDR( DRM_E_ARITHMETIC_OVERFLOW );
    }

    /* Use PkCrypto to verify the signature of the DATA section        */
    ChkDR( DRM_PK_Verify( pcontextCrypto->rgbCryptoContext, 
                          eDRM_ECC_P160,
                          DRM_ECC160_PUBLIC_KEY_LEN,
                          ( const DRM_BYTE * )&pcontextCrypto->pubKey,
                          CB_DSTR( &dstrData ),
                          PB_DSTR( &dstrData ), 
                          DRM_ECC160_SIGNATURE_LEN,
                          pcontextCrypto->signature) );                                                
    
    /* Everything looks good.  */
    dr = DRM_SUCCESS;
ErrorExit:
    return ( dr );    
}


DRM_API DRM_RESULT DRM_CALL DRM_LIC_GetContentRevocation(
    IN const DRM_CONST_STRING   *pdstrLicense,
    IN       DRM_DWORD           dwSequenceNumber,
    OUT      DRM_DWORD          *pdwSequenceNumber,
    OUT      DRM_CONST_STRING   *pdstrContentRevocation,
    OUT      DRM_CONST_STRING   *pdstrContentOwnerPubKey,
    OUT      DRM_CONST_STRING   *pdstrCondition,
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto)
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrSectionData = EMPTY_DRM_STRING;    
    DRM_CONST_STRING dstrLSPubKey    = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrTemp        = EMPTY_DRM_STRING;

    ChkArg( pdstrLicense            != NULL
         && pdstrContentRevocation  != NULL
         && pdstrContentOwnerPubKey != NULL );
        
    if( DRM_FAILED ( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLIData, NULL, NULL, &dstrSectionData, NULL, g_wchForwardSlash ) ) )
    {
        dr = DRM_S_FALSE;
        goto ErrorExit;
    }
    
    if( DRM_FAILED ( DRM_XML_GetSubNode( &dstrSectionData, &g_dstrContentRevocation, NULL, NULL, dwSequenceNumber, pdstrContentRevocation, &dstrTemp, 1 ) ) )
    {
        dr = DRM_S_FALSE;
        goto ErrorExit;
    }

    /* Verify and set output parameters. */
    ChkDR( DRM_LIC_VerifyContentRevocation( pdstrContentRevocation, &dstrLSPubKey, pdwSequenceNumber, pdstrContentOwnerPubKey, pdstrCondition, pcontextCrypto) );
    
    /* If license server pubkey is in the content revocation list, make sure that it corresponds to that of this license. */
    /* If the license server pubkey exists and is non-empty string, make sure it matched the one in license. */
    if ( NULL != dstrLSPubKey.pwszString )
    {
        DRM_DWORD dwSize = SIZEOF( PUBKEY );

        /* Retrieve pubkey of license server for this license. */
        ChkDR( GetLSPubKey( pdstrLicense, &(pcontextCrypto->pubKey), pcontextCrypto ) );
        ChkDR(DRM_B64_DecodeW(&dstrLSPubKey, &dwSize, (DRM_BYTE*) &(pcontextCrypto->pubKey2), 0));
        if (MEMCMP((DRM_BYTE*) &(pcontextCrypto->pubKey), (DRM_BYTE*) &(pcontextCrypto->pubKey2), SIZEOF( PUBKEY ) ) != 0 )
        {
            ChkDR( DRM_E_KEY_MISMATCH );
        }
    }
    dr = DRM_SUCCESS;
ErrorExit:
    return(dr);
}
#endif


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmmetercertstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmmetercertstore.h>
#include <drmdatastore.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

static const DRM_DST_NAMESPACE g_namespaceMeterCertStore = 
{ 
    TWO_BYTES('m', 'e'), TWO_BYTES('t', 'e'), TWO_BYTES('r', 'c'), TWO_BYTES('e',  'r'), 
    TWO_BYTES('t', 's'), TWO_BYTES('t', 'o'), TWO_BYTES('r', 'e'), TWO_BYTES('\0', '\0') 
};

#define DRM_METERCERT_STORE_SLOT_SIZE 2000

#define DRM_MIN_METERCERT_STORE_ENTRY_SIZE ( SIZEOF( DRM_DWORD ) * 3 )
#define DRM_METERCERT_FLAG_ACQ_PROTO_IS_V2 1

/*********************************************************************
 *                   INTERNAL FUNCTIONS _GetMIDStoreData
 *                                      _SetMIDStoreData
 *
 * purpose: get/set the data currently in the meter cert store for this MID
 *********************************************************************/


DRM_RESULT _GetMIDStoreData(
    IN       DRM_METERCERT_CONTEXT   *f_pcontextMeterCert,
    IN const DRM_MID                 *f_pmid,
    IN       DRM_DST_SLOT_HINT       *f_pslotHint,
       OUT   DRM_WCHAR               *f_pwszLAINFO,
    IN OUT   DRM_DWORD               *f_pcchLAINFO,
       OUT   DRM_BOOL                *f_pfIsV2,
       OUT   DRM_BYTE                *f_pbMeterCert,
    IN OUT   DRM_DWORD               *f_pcbMeterCert )
{
    DRM_METERCERT_CONTEXT_PRIVATE *pcontextMeterCert = (DRM_METERCERT_CONTEXT_PRIVATE *) f_pcontextMeterCert;
    DRM_DWORD   cbSlot   = SIZEOF (DRM_LICENSE_STATE_DATA   );
    DRM_DWORD   cbIO     = 0;
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_RESULT drCached = DRM_SUCCESS;
    DRM_DWORD  cbData   = 0;
    DRM_BOOL   fSlotOpen = FALSE;
    DRM_BOOL   fSkipData = FALSE;
    DRM_DWORD  dwFlags   = 0;

    ChkArg( f_pcontextMeterCert != NULL
        &&  f_pmid              != NULL );
    
    if( f_pwszLAINFO != NULL )
    {
        ChkArg( f_pcchLAINFO != NULL );
    }

    if( f_pbMeterCert != NULL )
    {
        ChkArg( f_pcbMeterCert != NULL );
    }
    
    ChkDR( DRM_DST_OpenSlot( pcontextMeterCert->pDatastore,
                             &pcontextMeterCert->contextNameSpace, 
                             eDRM_DST_OPEN_EXISTING | eDRM_DST_LOCKWAIT, 
                             f_pmid,
                             f_pmid, 
                             f_pslotHint,
                             &cbSlot, 
                             &pcontextMeterCert->contextDSTSlot) );
    fSlotOpen = TRUE;

    if( cbSlot < DRM_MIN_METERCERT_STORE_ENTRY_SIZE )
    {
        ChkDR( DRM_E_DSTCORRUPTED );
    }

    /*
    ** Read the flags
    */
    ChkDR( DRM_DST_SlotRead( pcontextMeterCert->pDatastore,
                             &pcontextMeterCert->contextDSTSlot, 
                             SIZEOF( DRM_DWORD ), 
                             (DRM_BYTE *)&dwFlags, 
                             &cbIO ) );
    FIX_ENDIAN_DWORD(dwFlags);
    if( f_pfIsV2 != NULL )
    {
        *f_pfIsV2 = (dwFlags & DRM_METERCERT_FLAG_ACQ_PROTO_IS_V2) ? TRUE : FALSE;
    }

    /*
    ** Read the LAINFO
    */

    /* read the number of characters of the LAINFO */
    ChkDR( DRM_DST_SlotRead( pcontextMeterCert->pDatastore,
                             &pcontextMeterCert->contextDSTSlot, 
                             SIZEOF( DRM_DWORD ), 
                             (DRM_BYTE *)&cbData, 
                             &cbIO ) );
    FIX_ENDIAN_DWORD(cbData);


    fSkipData = TRUE;
    if( f_pcchLAINFO != NULL )
    {
        /* They want either just the size of, or the actual LAINFO */
        
        if( cbData <= *f_pcchLAINFO * SIZEOF( DRM_WCHAR ) 
         && f_pwszLAINFO != NULL )
        {
            /* read the LAINFO itself */
            ChkDR( DRM_DST_SlotRead( pcontextMeterCert->pDatastore,
                                     &pcontextMeterCert->contextDSTSlot, 
                                     cbData, 
                                     (DRM_BYTE *)f_pwszLAINFO, 
                                     &cbIO ) );
            ChkBOOL( cbIO == cbData, DRM_E_FILEREADERROR );

            /* No need to skip over the LAINFO, we've passed it by reading it */
            fSkipData = FALSE;
        }
        else if ( cbData > *f_pcchLAINFO * SIZEOF( DRM_WCHAR ) )
        {
            drCached = DRM_E_BUFFERTOOSMALL;
        }
        
        *f_pcchLAINFO = cbData / SIZEOF( DRM_WCHAR );
    }

    if( fSkipData )
    {
        /* Skip over the LAINFO */
        ChkDR( DRM_DST_SlotSeek( pcontextMeterCert->pDatastore,
                                 &pcontextMeterCert->contextDSTSlot,
                                 cbData,
                                 eDRM_DST_SEEKCUR,
                                 NULL ) );
    }


    /*
    ** Read the metering certificate
    */
    
    if( f_pcbMeterCert == NULL )
    {
        /* They don't care about the meter cert, so exit now */
        goto ErrorExit;
    }
    /* They want either just the size of, or the actual metercert */

    /* read the number of characters in the metercert */
    ChkDR( DRM_DST_SlotRead( pcontextMeterCert->pDatastore,
                             &pcontextMeterCert->contextDSTSlot, 
                             SIZEOF( DRM_DWORD ), 
                             (DRM_BYTE *)&cbData, 
                             &cbIO ) );
    FIX_ENDIAN_DWORD(cbData);
 
    if( cbData <= *f_pcbMeterCert
      && f_pbMeterCert != NULL )
    {
        /* read the meter cert itself */
        ChkDR( DRM_DST_SlotRead( pcontextMeterCert->pDatastore,
                                 &pcontextMeterCert->contextDSTSlot, 
                                 cbData, 
                                 f_pbMeterCert, 
                                 &cbIO ) );
        ChkBOOL( cbIO == cbData, DRM_E_FILEREADERROR );
    }
    else if ( cbData > *f_pcbMeterCert )
    {
        drCached = DRM_E_BUFFERTOOSMALL;
    }
        
    *f_pcbMeterCert = cbData;

ErrorExit:

    if( DRM_SUCCEEDED( dr )
        && DRM_FAILED( drCached ) )
    {
        dr = drCached;
    }
    
    if( fSlotOpen )
    {
        /* Don't want to potentially overwrite a failure code */
        ( DRM_VOID )DRM_DST_CloseSlot( pcontextMeterCert->pDatastore,
                                       &pcontextMeterCert->contextDSTSlot );
    }

    if( dr == DRM_E_DSTSLOTNOTFOUND )
    {
        dr = DRM_E_METERCERTNOTFOUND;
    }

    return dr;
} /* _GetMIDStoreData */

DRM_RESULT _WriteStoreDataElement(
    __in     DRM_DST              *f_pDatastore,
    __in     DRM_DST_SLOT_CONTEXT *f_pcontextDSTSlot,
    __in     DRM_DWORD            *f_pcbSlot,
    __in     DRM_BOOL              f_fNewSlot,
    __in_bcount( f_cbData )
             DRM_BYTE             *f_pbData,
    __in     DRM_DWORD             f_cbData,
    __in_bcount( f_cbScratchBuffer )
             DRM_BYTE             *f_pbScratchBuffer,
    __in     DRM_DWORD             f_cbScratchBuffer,
    __in     DRM_BOOL              f_fInvalidate )
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  cbOld    = 0;
    DRM_DWORD  cbData   = 0;
    DRM_DWORD  cbIO     = 0;

    ChkArg( f_pcontextDSTSlot   != NULL
         && f_pbScratchBuffer    != NULL );
    ChkArg( f_pDatastore != NULL );

    /* Read how many characters are in the slot for the old LAINFO */
    if( !f_fNewSlot )
    {
        /* If it's an existing slot, we need to read the size of the LAINFO currently stored */
        ChkDR( DRM_DST_SlotRead( f_pDatastore,
                                 f_pcontextDSTSlot,
                                 SIZEOF( DRM_DWORD ),
                                 (DRM_BYTE*)&cbOld,
                                 &cbIO ) );
        ChkBOOL( cbIO == SIZEOF(DRM_DWORD), DRM_E_FILEREADERROR );
        FIX_ENDIAN_DWORD( cchOld );
    }
    else
    {
        cbOld = 0;
    }

    /* Write out the new size of the LAINFO if needed */
    if( f_pbData != NULL
        || f_fNewSlot 
        || f_fInvalidate )
    {
        /* cbData is the size of the new LAINFO, if LAINFO is NULL then it'll
           be stored as blank (ie cbData = 0) */
        if( f_pbData != NULL )
        {
            cbData = f_cbData;
        }
        else
        {
            cbData = 0;
        }

        if( cbData != cbOld
          || f_fNewSlot )
        {
            /* The size doesn't match, or it's a new slot so we need to write out the new one */

            if( !f_fNewSlot )
            {
                /* If it's an existing slot, we need to back up since we already
                   read the LAINFO size and now are past it */
                ChkDR( DRM_DST_SlotSeek( f_pDatastore,
                                         f_pcontextDSTSlot,
                                         -((DRM_LONG)SIZEOF( DRM_DWORD )),
                                         eDRM_DST_SEEKCUR,
                                         NULL ) );
            }

            /* Write the new LAINFO size */
            FIX_ENDIAN_DWORD( cbData );
            ChkDR( DRM_DST_SlotWrite( f_pDatastore,
                                      f_pcontextDSTSlot,
                                      SIZEOF(DRM_DWORD),
                                      (DRM_BYTE*)&cbData,
                                      &cbIO ) );
            ChkBOOL( cbIO == SIZEOF(DRM_DWORD), DRM_E_FILEWRITEERROR );
        }

    }

    /* Write out the new element */
    if( f_pbData == NULL && !f_fInvalidate )
    {
        /* They don't want to change the current element, so skip over it */
        ChkDR( DRM_DST_SlotSeek( f_pDatastore,
                                 f_pcontextDSTSlot,
                                 cbOld,
                                 eDRM_DST_SEEKCUR,
                                 NULL ) );
    }
    else
    {
        if( cbOld != f_cbData
            && !f_fNewSlot )
        {
            /* The new size doesn't match the old, need to adjust the slot */
            DRM_DWORD dwOrigSeekPtr = 0;
            DRM_DWORD cbTemp = 0;
    
            /* Save the current seek pointer */
            ChkDR( DRM_DST_SlotSeek( f_pDatastore,
                                     f_pcontextDSTSlot,
                                     0,
                                     eDRM_DST_SEEKCUR,
                                     &dwOrigSeekPtr ) );

            /* Skip over the LAINFO */
            ChkDR( DRM_DST_SlotSeek( f_pDatastore,
                                     f_pcontextDSTSlot,
                                     cbOld,
                                     eDRM_DST_SEEKCUR,
                                     NULL ) );

            /* Calculate how much data is in the slot past the current element */
            cbTemp = *f_pcbSlot - dwOrigSeekPtr - cbOld;

            if( cbTemp > f_cbScratchBuffer )
            {
                ChkDR( DRM_E_BUFFERTOOSMALL );
            }

            if( cbTemp > 0 )
            {
                /* Keep this data (if there is any) */
                ChkDR( DRM_DST_SlotRead( f_pDatastore,
                                         f_pcontextDSTSlot,
                                         cbTemp,
                                         f_pbScratchBuffer,
                                         &cbIO ) );
            }

            *f_pcbSlot += ( f_cbData - cbOld);
            ChkDR( DRM_DST_SlotResize( f_pDatastore,
                                       f_pcontextDSTSlot, 
                                       *f_pcbSlot ) );

            if( cbTemp > 0 )
            {
                /* Seek back to where the new element data goes */
                ChkDR( DRM_DST_SlotSeek( f_pDatastore, 
                                         f_pcontextDSTSlot,
                                         *f_pcbSlot - cbTemp,
                                         eDRM_DST_SEEKSET,
                                         NULL ) );

                /* Put back the data we saved */
                ChkDR( DRM_DST_SlotWrite( f_pDatastore,
                                          f_pcontextDSTSlot,
                                          cbTemp,
                                          f_pbScratchBuffer,
                                          &cbIO ) );
            }

            /* Seek back to where we were originally */
            ChkDR( DRM_DST_SlotSeek( f_pDatastore,
                                     f_pcontextDSTSlot,
                                     dwOrigSeekPtr,
                                     eDRM_DST_SEEKSET,
                                     NULL ) );
        }

        if( f_cbData > 0 )
        {
            /* Write the new element data */
            ChkDR( DRM_DST_SlotWrite( f_pDatastore,
                                      f_pcontextDSTSlot,
                                      f_cbData,
                                      f_pbData,
                                      &cbIO ) );
        }
    }
ErrorExit:
    return dr;
}

DRM_RESULT _SetMIDStoreData(
    IN       DRM_METERCERT_CONTEXT  *f_pcontextMeterCert,
    IN const DRM_MID                *f_pmid,
    IN       DRM_DST_SLOT_HINT      *f_pslotHint,
    IN const DRM_CONST_STRING       *f_pdstrLAINFO,
    IN       DRM_BOOL               *f_pfIsV2,
    __in_bcount_opt( f_cbMeterCert )
             DRM_BYTE               *f_pbMeterCert,
    __in     DRM_DWORD               f_cbMeterCert,
    IN       DRM_BOOL                f_fCreateIfNotExisting,
    IN       DRM_BOOL                f_fInvalidate )
{
    DRM_METERCERT_CONTEXT_PRIVATE *pcontextMeterCert = (DRM_METERCERT_CONTEXT_PRIVATE *) f_pcontextMeterCert;
    DRM_DWORD                      cbSlot            = SIZEOF( DRM_DWORD );
    DRM_RESULT                     dr                = DRM_SUCCESS;
    DRM_BOOL                       fSlotOpen         = FALSE;    
    DRM_BOOL                       fNewSlot          = FALSE;
    DRM_DWORD                      dwFlags           = 0;
    DRM_DWORD                      cbIO              = 0;

    ChkArg( f_pcontextMeterCert != NULL
         && f_pmid              != NULL );
    ChkArg( pcontextMeterCert->pDatastore != NULL );
    
    if( f_fCreateIfNotExisting )
    {        
        /* Calculate the needed size of the slot */
        /* Three DWORDs store the flags, and character count for the LAINFO and meter cert */
        cbSlot = DRM_MIN_METERCERT_STORE_ENTRY_SIZE;
 
        /* Add the size of the LAINFO and meter cert if specified */
        if( f_pdstrLAINFO != NULL )
        {
            cbSlot += (f_pdstrLAINFO->cchString * SIZEOF( DRM_WCHAR ));
        }

        if( f_pbMeterCert != NULL )
        {
            cbSlot += f_cbMeterCert;
        }
    }
        
    dr = DRM_DST_OpenSlot( pcontextMeterCert->pDatastore,
                           &pcontextMeterCert->contextNameSpace, 
                           ( f_fCreateIfNotExisting ? eDRM_DST_OPEN_ALWAYS : eDRM_DST_OPEN_EXISTING )| eDRM_DST_LOCKEXCLUSIVE | eDRM_DST_LOCKWAIT, 
                           f_pmid,
                           f_pmid,
                           f_pslotHint,
                          &cbSlot,
                          &pcontextMeterCert->contextDSTSlot);
    if( f_fCreateIfNotExisting && dr == DRM_S_FALSE )
    {
        fNewSlot = TRUE;
    }
    if( dr == DRM_E_DSTSLOTNOTFOUND )
    {
        dr = DRM_E_METERCERTNOTFOUND;
    }
    ChkDR( dr );
    fSlotOpen = TRUE;

    if( cbSlot < DRM_MIN_METERCERT_STORE_ENTRY_SIZE )
    {
        /* We need at least two DWORDs for a valid entry */
        return DRM_E_DSTCORRUPTED;
    }

    /*
    ** Write out the flags
    */
    if( f_pfIsV2 != NULL )
    {
        dwFlags = *f_pfIsV2 ? DRM_METERCERT_FLAG_ACQ_PROTO_IS_V2 : 0;
        FIX_ENDIAN_DWORD( dwFlags );
        ChkDR( DRM_DST_SlotWrite( pcontextMeterCert->pDatastore,
                                  &pcontextMeterCert->contextDSTSlot,
                                  SIZEOF(DRM_DWORD),
                                  (DRM_BYTE*)&dwFlags,
                                  &cbIO ) );
        ChkBOOL( cbIO == SIZEOF(DRM_DWORD), DRM_E_FILEWRITEERROR );
    }
    else
    {
        /* Skip it if they didn't want to change it */
        ChkDR( DRM_DST_SlotSeek( pcontextMeterCert->pDatastore,
                                 &pcontextMeterCert->contextDSTSlot,
                                 (DRM_LONG)SIZEOF( DRM_DWORD ),
                                 eDRM_DST_SEEKCUR,
                                 NULL ) );
    }
    
    /*
    ** Store the LAINFO
    */

    ChkDR( _WriteStoreDataElement( pcontextMeterCert->pDatastore,
                                  &pcontextMeterCert->contextDSTSlot,
                                  &cbSlot,
                                   fNewSlot,
                                   f_pdstrLAINFO != NULL ? PB_DSTR( f_pdstrLAINFO ) : NULL,
                                   f_pdstrLAINFO != NULL ? CB_DSTR( f_pdstrLAINFO ) : 0,
                                   pcontextMeterCert->pbBuffer,
                                   pcontextMeterCert->cbBuffer,
                                   FALSE ) );

    /*
    ** Store the metering certificate
    */

    ChkDR( _WriteStoreDataElement( pcontextMeterCert->pDatastore,
                                  &pcontextMeterCert->contextDSTSlot,
                                  &cbSlot,
                                   fNewSlot,
                                   f_pbMeterCert,
                                   f_cbMeterCert,
                                   pcontextMeterCert->pbBuffer,
                                   pcontextMeterCert->cbBuffer,
                                   f_fInvalidate ) );

#if !_DATASTORE_WRITE_THRU
    ChkDR ( DRM_DST_CommitNamespace( pcontextMeterCert->pDatastore,
                                     &pcontextMeterCert->contextNameSpace ) );
#endif

ErrorExit:
    if (fSlotOpen)
    {
        dr = DRM_DST_CloseSlot( pcontextMeterCert->pDatastore, &pcontextMeterCert->contextDSTSlot );
    }

    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_MCS_DeleteMeterCert(
    IN       DRM_METERCERT_CONTEXT  *f_pcontextMeterCert, 
    IN const DRM_MID                *f_pmid)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_METERCERT_CONTEXT_PRIVATE *pcontextMeterCert = (DRM_METERCERT_CONTEXT_PRIVATE *) f_pcontextMeterCert;

    ChkArg(f_pcontextMeterCert != NULL
        && f_pmid              != NULL);
    ChkArg( pcontextMeterCert->pDatastore != NULL );
    
    dr = DRM_DST_DeleteSlot( pcontextMeterCert->pDatastore,
                            &pcontextMeterCert->contextNameSpace, 
                            f_pmid, 
                            f_pmid,
                            NULL,
                            TRUE);

    if (dr == DRM_E_DSTSLOTNOTFOUND)
    {
        dr = DRM_E_METERCERTNOTFOUND;
    }
    else
    {
        ChkDR(dr);
    }
    
ErrorExit:
    return dr;
} /* DRM_MCS_DeleteMeterCert */

DRM_API DRM_RESULT DRM_CALL DRM_MCS_InvalidateMeterCert(
    IN       DRM_METERCERT_CONTEXT  *f_pcontextMeterCert, 
    IN const DRM_MID                *f_pmid)
{
    DRM_RESULT dr            = DRM_SUCCESS;

    ChkArg(f_pcontextMeterCert != NULL
        && f_pmid              != NULL );

   ChkDR( _SetMIDStoreData( f_pcontextMeterCert, f_pmid, NULL, NULL, NULL, NULL, 0, FALSE, TRUE ) );
    
ErrorExit:
    return dr;
} /* DRM_MCS_InvalidateMeterCert */

DRM_API DRM_RESULT DRM_CALL DRM_MCS_OpenStore  (
    IN  DRM_DST                        *f_pDatastore,
    __in_bcount( f_cbBuffer ) DRM_BYTE *f_pbBuffer,
    IN  DRM_DWORD                       f_cbBuffer,
    OUT DRM_METERCERT_CONTEXT          *f_pcontextMeterCert)
{
    DRM_RESULT                     dr                =  DRM_SUCCESS;
    DRM_METERCERT_CONTEXT_PRIVATE *pcontextMeterCert = (DRM_METERCERT_CONTEXT_PRIVATE *) f_pcontextMeterCert;

    ChkArg (f_pDatastore        != NULL
         && f_pcontextMeterCert != NULL);
    
    DRMCASSERT (SIZEOF (DRM_METERCERT_CONTEXT_PRIVATE) <= SIZEOF (DRM_METERCERT_CONTEXT));

    ZEROMEM( f_pcontextMeterCert, SIZEOF( DRM_METERCERT_CONTEXT ) );

    /* open the namespace for the Meter Cert Store */    
    ChkDR( DRM_DST_OpenNamespace( f_pDatastore, 
                                  &g_namespaceMeterCertStore, 
                                  (DRM_DST_OPENMODE)(eDRM_DST_CREATE_NEW | eDRM_DST_LOCKWAIT),
                                  16,
                                  DRM_METERCERT_STORE_SLOT_SIZE,
                                  &pcontextMeterCert->contextNameSpace ) );
    pcontextMeterCert->pDatastore = f_pDatastore;

    pcontextMeterCert->pbBuffer = f_pbBuffer;
    pcontextMeterCert->cbBuffer = f_cbBuffer;
    
    pcontextMeterCert->fInited  = TRUE;

ErrorExit:

    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_MCS_CloseStore (
    IN  DRM_METERCERT_CONTEXT       *f_pcontextMeterCert)
{
    DRM_METERCERT_CONTEXT_PRIVATE *pcontextMeterCert = (DRM_METERCERT_CONTEXT_PRIVATE *) f_pcontextMeterCert;
    DRM_RESULT                     dr                = DRM_SUCCESS;

    ChkArg( f_pcontextMeterCert != NULL );   

    if( pcontextMeterCert->fInited )
    {
        ChkDR( DRM_DST_CloseNamespace( pcontextMeterCert->pDatastore, 
                                       &pcontextMeterCert->contextNameSpace ) );
    }

    ZEROMEM( f_pcontextMeterCert, SIZEOF( DRM_METERCERT_CONTEXT ) );
    
ErrorExit:
    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_MCS_InitEnum   (
    IN  DRM_METERCERT_CONTEXT       *f_pcontextMeterCert, 
    OUT DRM_METERCERT_ENUM          *f_pcontextMeterCertEnum)
{
    DRM_METERCERT_CONTEXT_PRIVATE *pcontextMeterCert     = (DRM_METERCERT_CONTEXT_PRIVATE *) f_pcontextMeterCert;
    DRM_METERCERT_ENUM_PRIVATE    *pcontextMeterCertEnum = (DRM_METERCERT_ENUM_PRIVATE *) f_pcontextMeterCertEnum;
    DRM_RESULT dr =  DRM_SUCCESS;  

    ChkArg( f_pcontextMeterCert         != NULL
         && f_pcontextMeterCertEnum     != NULL );
    ChkArg( pcontextMeterCert->fInited );

    DRMCASSERT (SIZEOF (DRM_METERCERT_CONTEXT_PRIVATE) <= SIZEOF (DRM_METERCERT_CONTEXT));

    ZEROMEM(f_pcontextMeterCertEnum, SIZEOF (DRM_METERCERT_ENUM));

    dr = DRM_DST_InitSlotEnum( pcontextMeterCert->pDatastore,
                               &pcontextMeterCert->contextNameSpace, 
                               NULL, 
                               (DRM_DST_LOCKMODE)(eDRM_DST_LOCKSHARED | eDRM_DST_LOCKWAIT), 
                               &pcontextMeterCertEnum->contextDSTEnum);

    if (DRM_SUCCEEDED (dr))
    {
        pcontextMeterCertEnum->fAny = TRUE;
    }
    else if (dr == DRM_E_DSTSLOTNOTFOUND)
    {
        /* No MIDs found. */
        
        pcontextMeterCertEnum->fAny = FALSE;
        dr = DRM_SUCCESS;
    }
    else
    {
        ChkDR (dr);
    }
    
    pcontextMeterCertEnum->pcontextMeterCert = (DRM_METERCERT_CONTEXT_PRIVATE*)f_pcontextMeterCert;
    pcontextMeterCertEnum->fInited           = TRUE;

ErrorExit:    
    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_MCS_EnumNext   (
    IN  DRM_METERCERT_ENUM          *f_pcontextMeterCertEnum, 
    OUT DRM_MID                     *f_pmid,
    OUT DRM_DST_SLOT_HINT           *f_pslotHint)
{
    DRM_METERCERT_ENUM_PRIVATE *pcontextMeterCertEnum = (DRM_METERCERT_ENUM_PRIVATE *) f_pcontextMeterCertEnum;
    DRM_RESULT                  dr                    = DRM_SUCCESS;
    DRM_DWORD                   cbSlot                = SIZEOF (DRM_DWORD);
    DRM_DST                    *pDatastore            = NULL;

    ChkArg (f_pcontextMeterCertEnum != NULL
         && f_pmid                  != NULL);
    ChkArg (pcontextMeterCertEnum->fInited);
    
    pDatastore = pcontextMeterCertEnum->pcontextMeterCert->pDatastore;

    DRMCASSERT (SIZEOF (DRM_METERCERT_CONTEXT_PRIVATE) 
            <= SIZEOF (DRM_METERCERT_CONTEXT));

    if  (pcontextMeterCertEnum->fAny == FALSE)
    {
        dr = DRM_E_NOMORE;
        goto ErrorExit;            
    }

    dr = DRM_DST_SlotEnumNext( pDatastore,
                               &pcontextMeterCertEnum->contextDSTEnum, 
                               &pcontextMeterCertEnum->contextDSTSlot, 
                               f_pmid,
                               NULL, 
                               &cbSlot );

    if (dr == DRM_E_DSTBLOCKMISMATCH 
    ||  dr == DRM_E_DSTSLOTNOTFOUND)
    {
        ChkDR (DRM_E_NOMORE);
    }
    ChkDR (dr);

    if( f_pslotHint != NULL )
    {
        DRM_DST_MakeSlotHint( pDatastore,
                              &pcontextMeterCertEnum->contextDSTSlot, 
                              f_pslotHint );
    }

    ChkDR( DRM_DST_CloseSlot( pDatastore, &pcontextMeterCertEnum->contextDSTSlot ) );
    
ErrorExit:
    
    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_MCS_GetMeterCertByMID(
    IN                                   DRM_METERCERT_CONTEXT   *f_pcontextMeterCert, 
    IN const                             DRM_MID                 *f_pmid,
       __out_ecount_opt(*f_pcchLAINFO)   DRM_WCHAR               *f_pwszLAINFO,
    IN OUT                               DRM_DWORD               *f_pcchLAINFO,
       OUT                               DRM_BOOL                *f_pfIsV2,
       __out_bcount_opt(*f_pcbMeterCert) DRM_BYTE                *f_pbMeterCert,
    IN OUT                               DRM_DWORD               *f_pcbMeterCert )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_METERING,  PERF_FUNC_Drm_GetMeterCert_By_MID);

    ChkArg ( f_pcontextMeterCert != NULL
          && f_pmid              != NULL );

    ChkDR( _GetMIDStoreData( f_pcontextMeterCert, f_pmid, NULL, f_pwszLAINFO, f_pcchLAINFO, f_pfIsV2, f_pbMeterCert, f_pcbMeterCert ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE
    return dr;    
}

DRM_API DRM_RESULT DRM_CALL DRM_MCS_UpdateMeterCert(
    IN       DRM_METERCERT_CONTEXT      *f_pcontextMeterCert, 
    IN       DRM_CONST_STRING           *f_pdstrLAINFO,
    IN       DRM_BOOL                   *f_pfIsV2,
    __in_bcount_opt( f_cbMeterCert )
             DRM_BYTE                   *f_pbMeterCert,
    __in     DRM_DWORD                   f_cbMeterCert,
    IN const DRM_MID                    *f_pmid)
{
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_METERING, PERF_FUNC_Drm_MeterCert_Update);
   
    ChkArg( f_pcontextMeterCert != NULL
         && f_pmid              != NULL);

    ChkDR( _SetMIDStoreData(f_pcontextMeterCert, f_pmid, NULL, f_pdstrLAINFO, f_pfIsV2, f_pbMeterCert,  f_cbMeterCert, TRUE, FALSE ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmmd5.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <byteorder.h>
#include <drmcrt.h>
#include <drmmd5.h>

ENTER_PK_NAMESPACE_CODE;

static const DRM_DWORD MD5_cons[64] =
/* Round 1 */
 {0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,

/* Round 2 */
  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 
  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,

/* Round 3 */
  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,

/* Round 4 */
  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391};

static const DRM_DWORD magic_md5 = 0x2035444DUL;
                          /* "MD5 " in ASCII */


/*
** Update the MD5 hash from a fresh 64 bytes of data.
*/

static DRM_NO_INLINE DRM_VOID _MD5_block( IN OUT DRM_MD5_CTX *f_contextMD5)
{
    DRM_DWORD a = f_contextMD5->partial_hash[0];
    DRM_DWORD b = f_contextMD5->partial_hash[1]; 
    DRM_DWORD c = f_contextMD5->partial_hash[2];
    DRM_DWORD d = f_contextMD5->partial_hash[3];
    DRM_DWORD msg16[32];   /* Two copies of message */
    const DRM_DWORD *cons = MD5_cons;
    DRM_INT i;

    for (i = 0; i != 16; i++) 
    {
        /*
        ** Copy to local array, zero original
        ** Make two copies, to simplify indexing
        */
        msg16[i] = msg16[i+16] = f_contextMD5->awaiting_data[i];
        f_contextMD5->awaiting_data[i] = 0;
    }


    /* Round 1 */
    for (i = -16; i != 0; i += 4) 
    {      
        /*
        ** Rewrite (X & Y) | (~X & Z)  as  Z ^ (X & (Y ^ Z))
        ** [Easily validated by checking X = 0 and X = 1 cases.]
        ** This avoids ANDNOT (which X86 lacks) and needs only 
        ** one temporary register.
        ** On register-rich architectures, the Y ^ Z computation
        ** can start early, before X is computed.
        */

        a += msg16[i+16] + cons[0] + (d ^ (b & (c ^ d)));
        a = b + ROTATE_LEFT(a, 7);

        d += msg16[i+17] + cons[1] + (c ^ (a & (b ^ c)));
        d = a + ROTATE_LEFT(d, 12);

        c += msg16[i+18] + cons[2] + (b ^ (d & (a ^ b)));
        c = d + ROTATE_LEFT(c, 17);

        b += msg16[i+19] + cons[3] + (a ^ (c & (d ^ a)));
        b = c + ROTATE_LEFT(b, 22);

        cons += 4;
    }

    /* Round 2 */
    for (i = -16; i != 0; i += 4) 
    {
        /* Rewrite (Z & X) | (~Z & Y)  as  Y ^ (Z & (X ^ Y)) */
        a += msg16[i+17] + cons[0] + (c ^ (d & (b ^ c)));
        a = b + ROTATE_LEFT(a, 5);

        d += msg16[i+22] + cons[1] + (b ^ (c & (a ^ b)));
        d = a + ROTATE_LEFT(d, 9);

        c += msg16[i+27] + cons[2] + (a ^ (b & (d ^ a))); 
        c = d + ROTATE_LEFT(c, 14);

        b += msg16[i+16] + cons[3] + (d ^ (a & (c ^ d)));
        b = c + ROTATE_LEFT(b, 20);

        cons += 4;
    }

    /* Round 3 */
    for (i = 16; i != 0; i -= 4) 
    { 
        a += msg16[i+5]  + cons[0] + ((b ^ c) ^ d);
        a = b + ROTATE_LEFT(a, 4);
        
        d += msg16[i+8]  + cons[1] + (a ^ (b ^ c));
        d = a + ROTATE_LEFT(d, 11);
        
        c += msg16[i+11] + cons[2] + ((d ^ a) ^ b);
        c = d + ROTATE_LEFT(c, 16);

        b += msg16[i+14] + cons[3] + (c ^ (d ^ a));
        b = c + ROTATE_LEFT(b, 23);

        cons += 4;
    }

    /* Round 4 */
    for (i = 16; i != 0; i -= 4) 
    {
        a += msg16[i  ]  + cons[0] + (c ^ (~d | b));
        a = b + ROTATE_LEFT(a, 6);

        d += msg16[i+7]  + cons[1] + (b ^ (~c | a));
        d = a + ROTATE_LEFT(d, 10);

        c += msg16[i+14] + cons[2] + (a ^ (~b | d));
        c = d + ROTATE_LEFT(c, 15);

        b += msg16[i+5]  + cons[3] + (d ^ (~a | c));
        b = c + ROTATE_LEFT(b, 21);

        cons += 4;
    }

    f_contextMD5->partial_hash[0] += a;
    f_contextMD5->partial_hash[1] += b;
    f_contextMD5->partial_hash[2] += c;
    f_contextMD5->partial_hash[3] += d;
} /* end _MD5_block */


DRM_API DRM_NO_INLINE DRM_VOID DRM_CALL DRM_MD5_Init( IN OUT DRM_MD5_CTX *f_contextMD5)
{
    DRM_DWORD i;

    f_contextMD5->nbit_total[0] = f_contextMD5->nbit_total[1] = 0;
    for (i = 0; i != 16; i++) 
    {
        f_contextMD5->awaiting_data[i] = 0;
    }
   
     /* 
     **  Initialize hash variables.
     **    
     **  The initial values in RFC 1321 appear
     **  in byte-reversed order.  Bruce Schneier's 
     **  2nd edition neglects to rearrange them.
     */

    f_contextMD5->partial_hash[0] = 0x67452301;
    f_contextMD5->partial_hash[1] = 0xefcdab89;
    f_contextMD5->partial_hash[2] = ~f_contextMD5->partial_hash[0];
    f_contextMD5->partial_hash[3] = ~f_contextMD5->partial_hash[1];
}


/*
**  Append data to a partially hashed MD5 message.
*/
DRM_API DRM_NO_INLINE DRM_VOID DRM_CALL DRM_MD5_Update(
    IN OUT   DRM_MD5_CTX *f_contextMD5,
    IN const DRM_VOID    *f_rgbData,
    IN       DRM_DWORD    f_cbData )
{
    const DRM_BYTE *rgbData  = (const DRM_BYTE *)f_rgbData;
    DRM_DWORD cbData         = f_cbData;
    DRM_DWORD iData          = 0;
    DRM_DWORD nbit_occupied  = f_contextMD5->nbit_total[0] & 511;
    DRM_DWORD *awaiting_data = NULL;
    DRM_DWORD nbitnew_low    = 8 * f_cbData;

    f_contextMD5->nbit_total[0] += nbitnew_low;
    f_contextMD5->nbit_total[1] += (DRM_DWORD)(f_cbData >> 29) 
                                 + (f_contextMD5->nbit_total[0] < nbitnew_low);

    /* Advance to word boundary in waiting_data */
    
    if ((nbit_occupied & 31) != 0) 
    {        
        awaiting_data = f_contextMD5->awaiting_data + nbit_occupied/32;

        while ((nbit_occupied & 31) != 0 && cbData != 0) 
        {
            *awaiting_data |= (DRM_DWORD)GET_BYTE(rgbData, iData) << (nbit_occupied & 31);
            iData++;
            cbData--;
            nbit_occupied += 8;
        }
    }

    /* Transfer 4 bytes at a time */
    do 
    {
        DRM_DWORD nword_occupied = nbit_occupied/32;
        DRM_DWORD nwcopy         = min(cbData/4, 16 - nword_occupied);

        awaiting_data  = f_contextMD5->awaiting_data 
                       + nword_occupied;
                       
        /* check for integer underflow */
        if ((cbData - (4 * nwcopy)) > f_cbData)
        {
            break;
        }
        
        cbData        -=  4 * nwcopy;
        nbit_occupied += 32 * nwcopy;

        while (nwcopy != 0) 
        {
            DRM_BYTE rgbDWORD[__CB_DECL( 4 )];
            
            PUT_BYTE( rgbDWORD, 0, GET_BYTE( rgbData, iData++ ) );
            PUT_BYTE( rgbDWORD, 1, GET_BYTE( rgbData, iData++ ) );
            PUT_BYTE( rgbDWORD, 2, GET_BYTE( rgbData, iData++ ) );
            PUT_BYTE( rgbDWORD, 3, GET_BYTE( rgbData, iData++ ) );

            /* this check will never fail, but having it here keeps the source */
            /* code diagnostic tools happy.                                    */
            if (awaiting_data < f_contextMD5->awaiting_data + 16)
            {
                BYTES_TO_DWORD( *awaiting_data, rgbDWORD );
                awaiting_data++;            
                nwcopy--;
            }
        } 

        /* nbit_occupied can never be > 512, however, source code diagnostic tools */
        /* believe that it is possible, so > was added to make the tools happy.    */
        if (nbit_occupied >= 512) 
        {
            _MD5_block( f_contextMD5 );
            nbit_occupied  = 0;
            awaiting_data -= 16;
        }
    } while (cbData >= 4); 

    while ((cbData != 0) && (cbData < f_cbData)) 
    {        
        DRM_DWORD new_byte = (DRM_DWORD)GET_BYTE( rgbData, iData++ );

        /* this check will never fail, but having it here keeps the source */
        /* code diagnostic tools happy.                                    */
        if (awaiting_data < f_contextMD5->awaiting_data + 16)
        {
            *awaiting_data |= new_byte << (nbit_occupied & 31);
            nbit_occupied  += 8;
            cbData--;
        }
    }
}



/*
** Finish an MD5 hash.
*/
DRM_API DRM_NO_INLINE DRM_VOID DRM_CALL DRM_MD5_Final( IN OUT DRM_MD5_CTX *f_contextMD5)
{
    DRM_DWORD nbit0 = f_contextMD5->nbit_total[0];
    DRM_DWORD nbit1 = f_contextMD5->nbit_total[1];
    DRM_DWORD nbit_occupied = nbit0 & 511;
    DRM_DWORD i;

    f_contextMD5->awaiting_data[nbit_occupied/32] |= (DRM_DWORD)0x80 << (nbit_occupied & 31);
                          /* Append a 1 bit */
    nbit_occupied += 8;

    /*
    ** Append zero bits until length (in bits) is 448 mod 512.
    ** Then append the length, in bits.
    ** Here we assume the buffer was zeroed earlier.
    */

    if (nbit_occupied > 448)
    {   /* If fewer than 64 bits left */
        _MD5_block( f_contextMD5 );
    }

    f_contextMD5->awaiting_data[14] = nbit0;
    f_contextMD5->awaiting_data[15] = nbit1;
    
    _MD5_block(f_contextMD5);

    /* Copy final digest to byte array */

    for (i = 0; i != 4; i++) 
    {
        DRM_BYTE rgbDWORD[__CB_DECL( 4 )];
        
        DWORD_TO_BYTES( rgbDWORD, f_contextMD5->partial_hash[i] );
        DRM_BYT_CopyBytes( f_contextMD5->digest, 4 * i, rgbDWORD, 0, 4 );
    }
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmlicstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmlicenseparser.h>
#include <drmlicstore.h>
#if DRM_SUPPORT_DELETEDSTORE
#include <drmrecentexpired.h>
#endif
#include <drmdatastore.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

/*************************************************************************
** local constants
**************************************************************************/
#define DRM_LICENSE_STORE_NUM_CHILDREN      16

/* Average size of licenses in the various stores */
#define DRM_XML_LICENSE_STORE_SLOT_SIZE     5100
#define DRM_XMR_LICENSE_STORE_SLOT_SIZE     800
#define DRM_TEMP_LICENSE_STORE_SLOT_SIZE    800

static const DRM_DST_NAMESPACE _namespaceLSTXML =
{
    TWO_BYTES( 'L', 'i' ), TWO_BYTES( 'c', 'S' ),
    TWO_BYTES( 't', 'o' ), TWO_BYTES( 'r', 'e' )
};

static const DRM_DST_NAMESPACE _namespaceLSTXMR =
{
    TWO_BYTES( 'L', 'i' ), TWO_BYTES( 'c', 'S' ),
    TWO_BYTES( 't', 'o' ), TWO_BYTES( 'r', 'e' ),
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'r', '\0' )
};

#if DRM_TEMP_LICENSE_STORE_HDS
static const DRM_DST_NAMESPACE _namespaceLSTTemp =
{
    TWO_BYTES('L', 'i'), TWO_BYTES('c', 'S'),
    TWO_BYTES('t', 'o'), TWO_BYTES('r', 'e'),
    TWO_BYTES('T', 'e'), TWO_BYTES('m', 'p')
};
#endif /* DRM_TEMP_LICENSE_STORE_HDS */

/*************************************************************************
** static functions
**************************************************************************/

/**********************************************************************
** Function:    _LoadPrioritizedList
**
** Synopsis:    Load the prioritized list into the enumeration context
**
** Arguments:
**      [f_pLicEnumContext]   : The License store enumeration context
**      [f_fReverseOrder]     : TRUE specifies loading licenses lowest priority first.
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pLicEnumContext is NULL
**
***********************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _LoadPrioritizedList( 
    DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext, 
    DRM_BOOL f_fReverseOrder )
{
    DRM_RESULT            dr              = DRM_SUCCESS;
    DRM_BOOL              fInserted       = FALSE;
    DRM_DWORD             i               = 0;
    DRM_DWORD             j               = 0;
    DRM_DWORD             iList           = MAX_PRILIC_LIST;
    DRM_DST_SLOT_CONTEXT *pSlotContext    = &f_pLicEnumContext->SlotContext;
    DRM_DST              *pDatastore      = NULL;

    ChkArg( f_pLicEnumContext != NULL );
    ChkArg( f_pLicEnumContext->pLicContext != NULL );

    pDatastore = f_pLicEnumContext->pLicContext->pDatastore;

    f_pLicEnumContext->List.Prioritized.cLicenses    = 0;
    f_pLicEnumContext->List.Prioritized.iNextLicense = 0;
    

    while ( TRUE )
    {
        fInserted    = FALSE;
        iList        = MAX_PRILIC_LIST;

        if( f_pLicEnumContext->List.Prioritized.cLicenses == 0 )
        {
            iList = 0;
        }

        dr = DRM_DST_SlotEnumNext( pDatastore,
                                   &f_pLicEnumContext->DstEnumContext,
                                   pSlotContext,
                                   &f_pLicEnumContext->List.Prioritized.KID,
                                   &f_pLicEnumContext->List.Prioritized.rgPrioritizedList[iList].LID,
                                   NULL );

        if ( dr == DRM_E_NOMORE )
        {
            dr = DRM_SUCCESS;
            goto ErrorExit;
        }
        ChkDR( dr );

        ChkDR( DRM_DST_MakeSlotHint( pDatastore,
                                     pSlotContext,
                                     &( f_pLicEnumContext->List.Prioritized.rgPrioritizedList[iList].slotHint ) ) );
                    
        /*
        ** load the license's priority
        */
        ChkDR( DRM_DST_SlotRead( pDatastore,
                                 &f_pLicEnumContext->SlotContext,
                                 SIZEOF( DRM_DWORD ),
                    ( DRM_BYTE* )&( f_pLicEnumContext->List.Prioritized.rgPrioritizedList[iList].dwPriority ),
                                 NULL ) );
        FIX_ENDIAN_DWORD( f_pLicEnumContext->List.Prioritized.rgPrioritizedList[iList].dwPriority );
        ChkDR( DRM_DST_CloseSlot( pDatastore, &f_pLicEnumContext->SlotContext ) ); 

        /*
        ** First license
        */
        if ( f_pLicEnumContext->List.Prioritized.cLicenses == 0 )
        {
            f_pLicEnumContext->List.Prioritized.cLicenses++;
        }
        else
        {
            /*
            ** Merge this license to the list
            */
            for ( i = 0; i < f_pLicEnumContext->List.Prioritized.cLicenses; i++ )
            {
                DRM_BOOL fInsertLicense = FALSE;

                if ( f_fReverseOrder )
                {
                    fInsertLicense = f_pLicEnumContext->List.Prioritized.rgPrioritizedList[MAX_PRILIC_LIST].dwPriority <
                                     f_pLicEnumContext->List.Prioritized.rgPrioritizedList[i].dwPriority;
                }
                else
                {
                    fInsertLicense = f_pLicEnumContext->List.Prioritized.rgPrioritizedList[MAX_PRILIC_LIST].dwPriority >
                                     f_pLicEnumContext->List.Prioritized.rgPrioritizedList[i].dwPriority;
                }

                if ( fInsertLicense )
                {
                    /*
                    ** bump the licenses from i to rest and insert the new license to pos i
                    */
                    if ( f_pLicEnumContext->List.Prioritized.cLicenses == MAX_PRILIC_LIST )
                    {
                        j = f_pLicEnumContext->List.Prioritized.cLicenses - 1;
                    }
                    else
                    {
                        j = f_pLicEnumContext->List.Prioritized.cLicenses;
                    }

                    for ( ; j > i; j-- )
                    {
                        MEMCPY( &f_pLicEnumContext->List.Prioritized.rgPrioritizedList[j],
                                &f_pLicEnumContext->List.Prioritized.rgPrioritizedList[j - 1],
                                 SIZEOF( DRM_PRIORITIZED_LICENSE ) );
                    }

                    MEMCPY( &f_pLicEnumContext->List.Prioritized.rgPrioritizedList[i],
                            &f_pLicEnumContext->List.Prioritized.rgPrioritizedList[MAX_PRILIC_LIST],
                             SIZEOF( DRM_PRIORITIZED_LICENSE ) );

                    if ( f_pLicEnumContext->List.Prioritized.cLicenses < MAX_PRILIC_LIST )
                    {
                        ++f_pLicEnumContext->List.Prioritized.cLicenses;
                    }

                    fInserted = TRUE;
                    break;
                }
            }

            if ( !fInserted && f_pLicEnumContext->List.Prioritized.cLicenses < MAX_PRILIC_LIST )
            {
                MEMCPY( &f_pLicEnumContext->List.Prioritized.rgPrioritizedList[f_pLicEnumContext->List.Prioritized.cLicenses],
                        &f_pLicEnumContext->List.Prioritized.rgPrioritizedList[MAX_PRILIC_LIST],
                         SIZEOF( DRM_PRIORITIZED_LICENSE ) );

                ++f_pLicEnumContext->List.Prioritized.cLicenses;
            }
        }
    }

ErrorExit:
    return dr;
}

#if DRM_SUPPORT_DELETEDSTORE
/*
** Update the recent expired license data.
*/
static DRM_RESULT _UpdateRecentExpired(
    IN       DRM_DST            *pDatastore,
    IN       DRM_KID            *pKID )
{
    DRM_RESULT                  dr              = DRM_SUCCESS;
    DRM_RECENTEXPIRED_CONTEXT   contextRCX;
    DRM_RECENTEXPIRED_DATA      data;

    ZEROMEM( &contextRCX, SIZEOF( contextRCX ) );
    ZEROMEM( &data, SIZEOF( data ) );

    ChkDR( DRM_RCX_OpenStore(  pDatastore,
                              &contextRCX ) );

    /*
    ** Save the current datetime as the deletion datetime.
    ** Assume it is always later than the previous datetime.
    ** Don't worry about clock change scenario here.
    ** The only issue if the user changed the clock
    **  is that the "fast query" won't return "expired"
    **  for a recently expired license.
    ** The user will then see "no license"
    **  instead of "expired license".
    ** This is not important enough to do additional work.
    */
    Oem_Clock_GetSystemTimeAsFileTime( NULL, &data.datetime );

    ChkDR( DRM_RCX_SetKIDStoreData( &contextRCX,
                                     pKID,
                                    &data,
                                     TRUE ) );

ErrorExit:
    (void) DRM_RCX_CloseStore( &contextRCX );

    /*
    ** Updating the "recently expired" list should not be a fatal error.
    ** On DBG, we'll return failures to assist in debugging.
    ** On FRE, we'll simple return to S_OK to avoid failing the delete call.
    */
#if DBG
    return dr;
#else  /* DBG */
    return DRM_SUCCESS;
#endif /* DBG */

}
#endif

/**************************************************************************
** API functions
* *************************************************************************/

/**********************************************************************
** Function:    DRM_LST_Open
**
** Synopsis:    Initialize the license store for the given license store type.
**
** Arguments:
**      [f_pLicContext]       : The License store context to initialize
**      [f_pDatastore]        : Specifies the underlying data store to use.
**      [f_eLicenseStoreType] : Specifies the type of license store to initialize
**                              ( XML or XMR )
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the pointer arguments was NULL or the license store type
**          is invalid
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LST_Open( 
    OUT DRM_LICSTORE_CONTEXT    *f_pLicContext,
    IN  DRM_DST                 *f_pDatastore,
    IN  eDRM_LICENSE_STORE_TYPE  f_eLicenseStoreType )
{
    DRM_RESULT   dr  = DRM_SUCCESS;    

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMLICSTORE, PERF_FUNC_DRM_LST_Open );

    ChkArg( f_pLicContext != NULL );
    ChkArg( f_pDatastore  != NULL );

    /*
    ** open the namespace for the LicenseStore
    */
    if ( f_eLicenseStoreType == eDRM_LICENSE_STORE_XML )
    {
        ChkDR( DRM_DST_OpenNamespace( f_pDatastore,
                                      &_namespaceLSTXML,
                                      (DRM_DST_OPENMODE)(eDRM_DST_CREATE_NEW | eDRM_DST_LOCKWAIT),
                                      DRM_LICENSE_STORE_NUM_CHILDREN,
                                      DRM_XML_LICENSE_STORE_SLOT_SIZE,
                                      &f_pLicContext->DstNamespaceContext ) );
    }

#if DRM_TEMP_LICENSE_STORE_HDS

    else if ( f_eLicenseStoreType == eDRM_LICENSE_STORE_TEMP )
    {
        ChkDR( DRM_DST_OpenNamespace( f_pDatastore,
                                      &_namespaceLSTTemp,
                                      (DRM_DST_OPENMODE)(eDRM_DST_CREATE_NEW | eDRM_DST_LOCKWAIT),
                                      DRM_LICENSE_STORE_NUM_CHILDREN,
                                      DRM_TEMP_LICENSE_STORE_SLOT_SIZE,
                                      &f_pLicContext->DstNamespaceContext ) );
    }

#endif /* DRM_TEMP_LICENSE_STORE_HDS */

    else
    {
        ChkArg( f_eLicenseStoreType == eDRM_LICENSE_STORE_XMR );
        ChkDR( DRM_DST_OpenNamespace( f_pDatastore,
                                      &_namespaceLSTXMR,
                                      (DRM_DST_OPENMODE)(eDRM_DST_CREATE_NEW | eDRM_DST_LOCKWAIT),
                                      DRM_LICENSE_STORE_NUM_CHILDREN,
                                      DRM_XMR_LICENSE_STORE_SLOT_SIZE,
                                      &f_pLicContext->DstNamespaceContext ) );
    }
    
    f_pLicContext->eType = f_eLicenseStoreType;
    f_pLicContext->fInited = TRUE;
    f_pLicContext->pDatastore = f_pDatastore;

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}




/**********************************************************************
** Function:    DRM_LST_Close
**
** Synopsis:    Close the license store.  This will also Commit before close
**
** Arguments:
**      [f_pLicContext] : The License store context to close
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pLicContext was NULL or not inited
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LST_Close( IN DRM_LICSTORE_CONTEXT *f_pLicContext )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMLICSTORE, PERF_FUNC_DRM_LST_Close );

    ChkArg( f_pLicContext != NULL );
    ChkArg( f_pLicContext->fInited );

    ChkDR( DRM_DST_CloseNamespace( f_pLicContext->pDatastore, &f_pLicContext->DstNamespaceContext ) );
    f_pLicContext->pDatastore = NULL;
    f_pLicContext->fInited = FALSE;
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}


/**********************************************************************
** Function:    DRM_LST_AddLicense
**
** Synopsis:    Add a license to the store
**
** Arguments:
**      [f_pLicContext] : The License store context
**      [f_cbLicense]   : The length of the license buffer
**      [f_pbLicense]   : Buffer containing the license string
**      [f_pKID]        : Pointer to the KID
**      [f_pLID]        : Pointer to the LID
**      [dwPriority]    : The priority to give the license
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the required pointer parameters was NULL or the context
**          was not properly initialized
**      DRM_E_ARITHMETIC_OVERFLOW
**          An arithmetic overflow occurred during processing
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LST_AddLicense(
    IN OUT DRM_LICSTORE_CONTEXT *f_pLicContext,
    IN     DRM_DWORD             f_cbLicense,
    __in_bcount( f_cbLicense ) DRM_BYTE *f_pbLicense,
    IN     DRM_KID              *f_pKID,
    IN     DRM_LID              *f_pLID,
    IN     DRM_DWORD             f_dwPriority )
{
    DRM_RESULT        dr             = DRM_SUCCESS;
    DRM_CONST_STRING  dstrLicense    = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrValue      = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrLIDData    = EMPTY_DRM_STRING;
    DRM_DST_KEY       KeyKID         = { 0 };
    DRM_DST_KEY       KeyLID         = { 0 };
    DRM_DWORD         dwPriorityTemp = 0;
    DRM_DWORD         dwSize         = f_cbLicense + SIZEOF( DRM_DWORD );
    DRM_BOOL          fCompatWrite   = FALSE;

    ChkArg( f_pLicContext != NULL );
    ChkArg( f_pbLicense   != NULL );
    ChkArg( f_cbLicense   !=0 );
    ChkArg( f_pLicContext->fInited );

    ChkOverflow( f_cbLicense + SIZEOF( DRM_DWORD ), f_cbLicense );

    dwPriorityTemp = f_dwPriority;

    if( f_pKID == NULL || f_pLID == NULL )
    {
        /*
        ** To support older clients that just pass in a license buffer with no
        ** preparsed data we can extract it.  The preferred method is for the caller
        ** to pass in this data
        */
        fCompatWrite = TRUE;
        DSTR_FROM_PB( &dstrLicense, f_pbLicense, f_cbLicense );

        ChkDR( DRM_LIC_GetAttribute( &dstrLicense,
                                      NULL,
                                      DRM_LICENSE_ATTRIB_KID,
                                     &dstrLIDData,
                                     &dstrValue,
                                      0 ) );
        ChkDR( DRM_UTL_DecodeKID( &dstrValue, &KeyKID ) );

        ChkDR( DRM_LIC_GetAttribute( &dstrLicense,
                                      NULL,
                                      DRM_LICENSE_ATTRIB_LID,
                                     &dstrLIDData,
                                     &dstrValue,
                                      0 ) );
        ChkDR( DRM_UTL_StringToGuid( &dstrValue, ( DRM_GUID * )( KeyLID.rgb ) ) );
        ChkDR( DRM_LIC_GetAttribute( &dstrLicense,
                                      NULL,
                                      DRM_LICENSE_ATTRIB_PRIORITY,
                                     &dstrLIDData,
                                     &dstrValue,
                                      0 ) );
        ChkDR( DRMCRT_wcsntol( dstrValue.pwszString,
                               dstrValue.cchString,
                 ( DRM_LONG * )&dwPriorityTemp ) );
        f_pKID = &KeyKID;
        f_pLID = &KeyLID;
    }

    /*
    ** allocate a slot in the license store
    */
    ChkDR( DRM_DST_OpenSlot( f_pLicContext->pDatastore,
                             &f_pLicContext->DstNamespaceContext,
                             eDRM_DST_CREATE_NEW | eDRM_DST_LOCKEXCLUSIVE | eDRM_DST_LOCKWAIT,
                             f_pKID,
                             f_pLID,
                             NULL,
                             &dwSize,
                             &f_pLicContext->SlotContext ) );

    FIX_ENDIAN_DWORD( dwPriorityTemp );

    if( fCompatWrite )
    {
        ChkDR( DRM_DST_SlotWrite( f_pLicContext->pDatastore,
                                  &f_pLicContext->SlotContext,
                                  SIZEOF( DRM_DWORD ),
                                  ( DRM_BYTE * )&dwPriorityTemp,
                                  NULL ) );
        ChkDR( DRM_DST_SlotWrite( f_pLicContext->pDatastore,
                                  &f_pLicContext->SlotContext,
                                  f_cbLicense,
                                  f_pbLicense,
                                  NULL ) );
    }
    else
    {
        ChkBOOL( f_cbLicense >= SIZEOF( DRM_DWORD ), DRM_E_INVALIDARG );

        MEMCPY( f_pbLicense, &dwPriorityTemp, SIZEOF( DRM_DWORD ) );
        ChkDR( DRM_DST_SlotWrite( f_pLicContext->pDatastore,
                                  &f_pLicContext->SlotContext,
                                  dwSize,
                                  f_pbLicense,
                                  NULL ) );
    }

    ChkDR( DRM_DST_CloseSlot( f_pLicContext->pDatastore, &f_pLicContext->SlotContext ) );

#if !_DATASTORE_WRITE_THRU
    ChkDR( DRM_DST_CommitNamespace( f_pLicContext->pDatastore, 
                                    &f_pLicContext->DstNamespaceContext ) );
#endif

ErrorExit:
    /* remap the slot exists to a more meaningful user message */
    if( dr == DRM_E_DSTSLOTEXIST )
    {
        dr = DRM_E_DUPLICATE_LICENSE;
    }
    
    return dr;
}



/**********************************************************************
** Function:    DRM_LST_GetLicense
**
** Synopsis:    Get a license from the store using KID and LID
**
** Arguments:
**      [f_pLicContext] : The License store context
**      [f_pKID]        : Pointer to the KID
**      [f_pLID]        : Pointer to the LID
**      [f_pSlotHint]   : DST slot hint
**      [f_pbLicense]   : Buffer to return the license
**      [f_cbLicense]   : Specified the size of the license buffer in bytes,
**                        and returns the size of the license retrieved.
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the required pointer parameters was NULL or the context
**          was not properly initialized
**      DRM_E_BUFFERTOOSMALL
**          The license buffer provided is not big enough to contain the license
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LST_GetLicense( 
    IN     DRM_LICSTORE_CONTEXT *f_pLicContext,
    IN     DRM_KID              *f_pKID,
    IN     DRM_LID              *f_pLID,
    IN     DRM_DST_SLOT_HINT    *f_pSlotHint,
    __out_bcount_opt( *f_pcbLicense ) DRM_BYTE *f_pbLicense,
    IN OUT DRM_DWORD            *f_pcbLicense )
{
    DRM_RESULT dr         = DRM_SUCCESS;
    DRM_DWORD  cbSlotSize = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMLICSTORE, PERF_FUNC_DRM_LST_GetLicense );

    ChkArg( f_pLicContext != NULL );
    ChkArg( f_pcbLicense  != NULL );
    ChkArg( f_pKID        != NULL );
    ChkArg( f_pLID        != NULL );

    /*
    ** get size of SlotContext
    */
    ChkDR( DRM_DST_OpenSlot( f_pLicContext->pDatastore,
                             &f_pLicContext->DstNamespaceContext,
                             eDRM_DST_OPEN_EXISTING | eDRM_DST_LOCKWAIT,
                             f_pKID,
                             f_pLID,
                             f_pSlotHint,
                             &cbSlotSize,
                             &f_pLicContext->SlotContext ) );

    /*
    ** check size of license buffer
    */
    if ( *f_pcbLicense < ( cbSlotSize - SIZEOF( DRM_DWORD ) ) )
    {
        *f_pcbLicense = ( cbSlotSize - SIZEOF( DRM_DWORD ) );

        ChkDR( DRM_DST_CloseSlot( f_pLicContext->pDatastore, &f_pLicContext->SlotContext ) );
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    /*
    ** read the license
    */
    ChkDR( DRM_DST_SlotSeek( f_pLicContext->pDatastore,
                             &f_pLicContext->SlotContext,
                             SIZEOF( DRM_DWORD ),
                             eDRM_DST_SEEKSET,
                             NULL ) );
    ChkDR( DRM_DST_SlotRead( f_pLicContext->pDatastore,
                             &f_pLicContext->SlotContext,
                             cbSlotSize,
                             f_pbLicense,
                             f_pcbLicense ) );
    ChkDR( DRM_DST_CloseSlot( f_pLicContext->pDatastore, &f_pLicContext->SlotContext ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/**********************************************************************
** Function:    _InitEnum
**
** Synopsis:    Initialize an un-indexed enumeration of the license store
**
** Arguments:
**      [f_pLicContext]     : The License store context
**      [f_pKID]            : KID filter to be used.
**                            If not specified, all license will be enumerated
**      [f_fPrioritized]    : Ignored if pKID is NULL.
**                            TRUE to prioritize returned licenses,
**                            FALSE to enumerate in nature order
**      [f_fReversedOrder]  : Ignored if pKID is NULL or f_fPrioritized is FALSE.
**                            TRUE to enumerate licenses with lowest priority first.
**      [f_pLicEnumContext] : Returns the initialized context
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the required pointer parameters was NULL or the context
**          was not properly initialized
**
***********************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _InitEnum(
    IN  DRM_LICSTORE_CONTEXT     *f_pLicContext, 
    IN  DRM_KID                  *f_pKID,         
    IN  DRM_BOOL                  f_fPrioritized, 
    IN  DRM_BOOL                  f_fReversedOrder,
    OUT DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext )
{
    DRM_RESULT dr = DRM_SUCCESS;    

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMLICSTORE, PERF_FUNC__InitEnum );

    ChkArg( f_pLicContext     != NULL );
    ChkArg( f_pLicEnumContext != NULL );
    ChkArg( f_pLicContext->fInited );

    ZEROMEM( f_pLicEnumContext, SIZEOF( DRM_LICSTOREENUM_CONTEXT ) );
    f_pLicEnumContext->pLicContext = f_pLicContext;

    dr = DRM_DST_InitSlotEnum( f_pLicContext->pDatastore,
                               &f_pLicContext->DstNamespaceContext,
                               f_pKID,
                               (DRM_DST_LOCKMODE)(eDRM_DST_LOCKSHARED | eDRM_DST_LOCKWAIT),
                               &f_pLicEnumContext->DstEnumContext );

    /*
    ** No licenses found.
    */
    if( dr == DRM_E_DSTSLOTNOTFOUND )
    {
        f_pLicEnumContext->eMode = eDRM_LICENSE_STORE_MODE_NONE;
        f_pLicEnumContext->List.Prioritized.cLicenses = 0;
        f_pLicEnumContext->List.Prioritized.iNextLicense = 0;
        dr = DRM_SUCCESS;
    }
    else
    {
        ChkDR( dr );

        if ( f_pKID != NULL )
        {
            MEMCPY( f_pLicEnumContext->List.NonPrioritized.CurrKID.rgb, f_pKID->rgb, DRM_ID_SIZE );

            if ( f_fPrioritized )
            {
                MEMCPY( f_pLicEnumContext->List.Prioritized.KID.rgb, f_pKID->rgb, DRM_ID_SIZE );
                ChkDR( _LoadPrioritizedList( f_pLicEnumContext, f_fReversedOrder ) );
                f_pLicEnumContext->eMode = f_fReversedOrder? eDRM_LICENSE_STORE_MODE_REVERSE_PRIORITIZED : eDRM_LICENSE_STORE_MODE_PRIORITIZED;
            }
            else
            {
                f_pLicEnumContext->eMode = eDRM_LICENSE_STORE_MODE_FILTERED;
                f_pLicEnumContext->List.NonPrioritized.fCurrIsValid = FALSE;
            }
        }
        else
        {
            f_pLicEnumContext->eMode = eDRM_LICENSE_STORE_MODE_NATURAL;
            f_pLicEnumContext->List.NonPrioritized.fCurrIsValid = FALSE;
        }
    }
    f_pLicEnumContext->fInited = TRUE;    

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/**********************************************************************
** Function:    DRM_LST_InitEnum
**
** Synopsis:    Initialize an un-indexed enumeration of the license store
**
** Arguments:
**      [f_pLicContext]     : The License store context
**      [f_pKID]            : KID filter to be used.
**                            If not specified, all license will be enumerated
**      [f_fPrioritized]    : Ignored if pKID is NULL.
**                            TRUE to prioritize returned licenses,
**                            FALSE to enumerate in nature order
**      [f_fReversedOrder]  : Ignored if pKID is NULL or f_fPrioritized is FALSE.
**                            TRUE to enumerate licenses with lowest priority first.
**      [f_pLicEnumContext] : Returns the initialized context
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the required pointer parameters was NULL or the context
**          was not properly initialized
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LST_InitEnum(
    IN  DRM_LICSTORE_CONTEXT     *f_pLicContext, 
    IN  DRM_KID                  *f_pKID,         
    IN  DRM_BOOL                  f_fPrioritized, 
    OUT DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext )
{
    return _InitEnum( f_pLicContext, f_pKID, f_fPrioritized, FALSE, f_pLicEnumContext );
}

/**********************************************************************
** Function:    DRM_LST_InitReverseEnum
**
** Synopsis:    Initialize an un-indexed enumeration of the license store in reverse
**              priority order.
**
** Arguments:
**      [f_pLicContext]     : The License store context
**      [f_pKID]            : KID filter to be used.
**      [f_pLicEnumContext] : Returns the initialized context
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the required pointer parameters was NULL or the context
**          was not properly initialized
**
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LST_InitReverseEnum(
    IN  DRM_LICSTORE_CONTEXT     *f_pLicContext, 
    IN  DRM_KID                  *f_pKID,         
    OUT DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext )
{
    return _InitEnum( f_pLicContext, f_pKID, TRUE, TRUE, f_pLicEnumContext );
}

/**********************************************************************
** Function:    DRM_LST_EnumNext
**
** Synopsis:    Retrieve the next license from the enumerated license store
**
** Arguments:
**      [f_pLicEnumContext] : The License store enumeration context
**      [f_pKID]            : Returns the KID, if using prioritized or filtered mode.
**      [f_pLID]            : Returns the LID.
**      [f_pSlotHint]       : Returns the DST slot hint
**      [f_pcbLicense]      : Returns the size of the license
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the required pointer parameters was NULL or the context
**          was not properly initialized
**      DRM_E_LICENSENOTFOUND
**          Failed to retrieve the next license
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LST_EnumNext( 
    IN DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext,
    OUT DRM_KID                 *f_pKID,
    OUT DRM_LID                 *f_pLID,
    OUT DRM_DST_SLOT_HINT       *f_pSlotHint,
    OUT DRM_DWORD               *f_pcbLicense )
{
    DRM_RESULT dr            = DRM_SUCCESS;
    DRM_DWORD  dwSlot        = 0;
    DRM_BOOL   fKeepLooking  = TRUE;
    DRM_DWORD  i             = 0;
    DRM_DST   *pDatastore    = NULL;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMLICSTORE, PERF_FUNC_DRM_LST_EnumNext );

    ChkArg( f_pLicEnumContext != NULL );
    ChkArg( f_pLID            != NULL );
    ChkArg( f_pLicEnumContext->fInited );

    pDatastore = f_pLicEnumContext->pLicContext->pDatastore;

    ChkBOOL( f_pLicEnumContext->eMode != eDRM_LICENSE_STORE_MODE_NONE, DRM_E_NOMORE );

    if ( f_pcbLicense != NULL )
    {
        *f_pcbLicense = 0;
    }

    if ( f_pLicEnumContext->eMode == eDRM_LICENSE_STORE_MODE_PRIORITIZED
      || f_pLicEnumContext->eMode == eDRM_LICENSE_STORE_MODE_REVERSE_PRIORITIZED )
    {
        if ( f_pLicEnumContext->List.Prioritized.iNextLicense
          == f_pLicEnumContext->List.Prioritized.cLicenses ) /* end of list reached */
        {
            /*
            ** end of prioritized list. start to enumerate in non-prioritized way
            ** if we have filled our priority list
            */
            if( f_pLicEnumContext->List.Prioritized.cLicenses < MAX_PRILIC_LIST )
            {
                /* If we didn't fill the prioritized list then we have no more licenses to find */
                ChkDR( DRM_E_NOMORE );
            }

            f_pLicEnumContext->eMode = eDRM_LICENSE_STORE_MODE_POST_PRIORITIZED;
            dr = DRM_DST_InitSlotEnum( pDatastore,
                                       &f_pLicEnumContext->pLicContext->DstNamespaceContext,
                                       &f_pLicEnumContext->List.NonPrioritized.CurrKID,
                                       (DRM_DST_LOCKMODE)(eDRM_DST_LOCKSHARED | eDRM_DST_LOCKWAIT),
                                       &f_pLicEnumContext->DstEnumContext );
        }
        else
        {
            /*
            ** get license size
            */
            if ( f_pcbLicense != NULL )
            {
                dr = DRM_LST_GetLicense( ( DRM_LICSTORE_CONTEXT * )f_pLicEnumContext->pLicContext, 
                                        &f_pLicEnumContext->List.Prioritized.KID,
                                        &f_pLicEnumContext->List.Prioritized.rgPrioritizedList[f_pLicEnumContext->List.Prioritized.iNextLicense].LID,
                                        &f_pLicEnumContext->List.Prioritized.rgPrioritizedList[f_pLicEnumContext->List.Prioritized.iNextLicense].slotHint,
                                         NULL,
                                         f_pcbLicense );

                /*
                ** DRM_E_BUFFERTOOSMALL is not an error here
                */
                if( dr == DRM_E_BUFFERTOOSMALL )
                {
                    dr = DRM_SUCCESS;
                }
                else
                {
                    ChkDR( dr );
                }
            }
            if ( f_pKID != NULL )
            {
                MEMCPY( f_pKID->rgb, 
                        f_pLicEnumContext->List.Prioritized.KID.rgb, 
                        DRM_ID_SIZE );
            }
            if ( f_pSlotHint != NULL )
            {
                MEMCPY( f_pSlotHint, 
                       &( f_pLicEnumContext->List.Prioritized.rgPrioritizedList[f_pLicEnumContext->List.Prioritized.iNextLicense].slotHint ), 
                        SIZEOF( DRM_DST_SLOT_HINT ) );
            }
            
            MEMCPY( f_pLID->rgb, 
                    f_pLicEnumContext->List.Prioritized.rgPrioritizedList[f_pLicEnumContext->List.Prioritized.iNextLicense].LID.rgb, 
                    DRM_ID_SIZE );
            f_pLicEnumContext->List.Prioritized.iNextLicense++;
        }
    }

    /*
    ** Not using prioritized list or the prioritized list is exhausted
    */
    if ( f_pLicEnumContext->eMode != eDRM_LICENSE_STORE_MODE_PRIORITIZED 
      && f_pLicEnumContext->eMode != eDRM_LICENSE_STORE_MODE_REVERSE_PRIORITIZED )
    {
        f_pLicEnumContext->List.NonPrioritized.fCurrIsValid = FALSE;

        ChkArg( f_pLicEnumContext->eMode != eDRM_LICENSE_STORE_MODE_NATURAL
             || f_pKID != NULL );

        while ( fKeepLooking )
        {                      
            dr = DRM_DST_SlotEnumNext( pDatastore,
                                       &f_pLicEnumContext->DstEnumContext, 
                                       &f_pLicEnumContext->SlotContext, 
                                       &f_pLicEnumContext->List.NonPrioritized.CurrKID, 
                                       &f_pLicEnumContext->List.NonPrioritized.CurrLID, 
                                       &dwSlot );
                                       
            /*
            ** license has been changed or removed
            */
            ChkBOOL( dr != DRM_E_DSTBLOCKMISMATCH && dr != DRM_E_DSTSLOTNOTFOUND, DRM_E_LICENSENOTFOUND );               
            ChkDR( dr );

            MEMCPY( f_pLID->rgb, f_pLicEnumContext->List.NonPrioritized.CurrLID.rgb, DRM_ID_SIZE );
                        
            if ( f_pKID != NULL )     
            {
                MEMCPY( f_pKID->rgb, f_pLicEnumContext->List.NonPrioritized.CurrKID.rgb, DRM_ID_SIZE );
            }

            f_pLicEnumContext->List.NonPrioritized.fCurrIsValid = TRUE;

            if ( f_pcbLicense != NULL )
            {
                *f_pcbLicense = dwSlot - SIZEOF( DRM_DWORD );
            }

            if ( f_pSlotHint != NULL )
            {
                DRM_DST_MakeSlotHint( pDatastore, &f_pLicEnumContext->SlotContext, f_pSlotHint );
            }

            ChkDR( DRM_DST_CloseSlot( pDatastore, &f_pLicEnumContext->SlotContext ) );

            fKeepLooking = FALSE;
            if ( f_pLicEnumContext->eMode == eDRM_LICENSE_STORE_MODE_POST_PRIORITIZED )
            {
                /*
                ** check if the LID is in the priority list, if so, skip it
                */
                for ( i = 0;
                      i < f_pLicEnumContext->List.Prioritized.cLicenses;
                      i++ )
                {
                    if ( MEMCMP( &f_pLicEnumContext->List.Prioritized.rgPrioritizedList[i].LID,
                                  f_pLID,
                                  DRM_ID_SIZE ) == 0 )
                    {
                        fKeepLooking = TRUE;
                        break;
                    }
                }
            }
        }
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/**********************************************************************
** Function:    DRM_LST_EnumDelete
**
** Synopsis:    Delete currently enumerated license
**
** Arguments:
**      [f_pLicEnumContext] : The License store enumeration context
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pLicEnumContext is NULL or not initialized
**      DRM_E_LICENSENOTFOUND
**          Could not find the license to delete
**
***********************************************************************/
DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LST_EnumDelete(
    IN DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext)
{
    return DRM_LST_EnumDeleteAndSaveDate(f_pLicEnumContext, FALSE);
}


/**********************************************************************
** Function:    DRM_LST_EnumDelete
**
** Synopsis:    Delete currently enumerated license
**
** Arguments:
**      [f_pLicEnumContext] : The License store enumeration context
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pLicEnumContext is NULL or not initialized
**      DRM_E_LICENSENOTFOUND
**          Could not find the license to delete
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LST_EnumDeleteAndSaveDate(
    IN DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext,
    IN DRM_BOOL                  f_fSaveDate )
{
    DRM_RESULT dr         = DRM_SUCCESS;
    DRM_DST   *pDatastore = NULL;

    ChkArg( f_pLicEnumContext != NULL );
    ChkArg( f_pLicEnumContext->fInited );

    pDatastore = f_pLicEnumContext->pLicContext->pDatastore;

    ChkBOOL( f_pLicEnumContext->eMode != eDRM_LICENSE_STORE_MODE_NONE, DRM_E_LICENSENOTFOUND );

    if ( f_pLicEnumContext->eMode == eDRM_LICENSE_STORE_MODE_PRIORITIZED
      || f_pLicEnumContext->eMode == eDRM_LICENSE_STORE_MODE_REVERSE_PRIORITIZED )
    {
        /*
        ** EnumNext has not been called yet, or the license was already deleted
        */
        ChkBOOL( f_pLicEnumContext->List.Prioritized.iNextLicense != 0
              && !f_pLicEnumContext->List.Prioritized.rgPrioritizedList[f_pLicEnumContext->List.Prioritized.iNextLicense - 1].fDelete,
                 DRM_E_LICENSENOTFOUND );

        /*
        ** Delete the current license
        */
        ChkDR( DRM_DST_DeleteSlot( pDatastore,
                                  &f_pLicEnumContext->pLicContext->DstNamespaceContext,
                                  &f_pLicEnumContext->List.Prioritized.KID,
                                  &f_pLicEnumContext->List.Prioritized.rgPrioritizedList[f_pLicEnumContext->List.Prioritized.iNextLicense - 1].LID,
                                  &( f_pLicEnumContext->List.Prioritized.rgPrioritizedList[f_pLicEnumContext->List.Prioritized.iNextLicense - 1].slotHint ),
                                   TRUE ) );
 
        f_pLicEnumContext->List.Prioritized.rgPrioritizedList[f_pLicEnumContext->List.Prioritized.iNextLicense-1].fDelete = TRUE;

#if DRM_SUPPORT_DELETEDSTORE
        if(f_fSaveDate)
        {
            ChkDR( _UpdateRecentExpired( pDatastore,
                                        &f_pLicEnumContext->List.Prioritized.KID ) );
        }
#endif
    }
    /*
    ** eDRM_LICENSE_STORE_MODE_FILTERED or eDRM_LICENSE_STORE_MODE_NATURAL
    */
    else
    {
        /*
        ** Check that current license is valid
        */
        ChkBOOL( f_pLicEnumContext->List.NonPrioritized.fCurrIsValid, DRM_E_LICENSENOTFOUND );

        if ( pDatastore != NULL && pDatastore->eImplementationType == eDRM_DST_EMBEDDED )
        {
            ChkDR( DRM_DST_SlotEnumReloadCurrent ( pDatastore,
                                                  &f_pLicEnumContext->DstEnumContext,
                                                  &f_pLicEnumContext->SlotContext,
                                                   NULL,
                                                   NULL,
                                                   NULL ) );

            ChkDR( DRM_DST_SlotEnumDeleteCurrent( pDatastore, 
                                                 &f_pLicEnumContext->DstEnumContext,
                                                 &f_pLicEnumContext->SlotContext ) );
        }
        else
        {
            ChkDR( DRM_DST_DeleteSlot( pDatastore,
	                                   &f_pLicEnumContext->pLicContext->DstNamespaceContext,
	                                   &f_pLicEnumContext->List.NonPrioritized.CurrKID,
	                                   &f_pLicEnumContext->List.NonPrioritized.CurrLID,
	                                   NULL,
	                                   TRUE ) );
        }
     
#if DRM_SUPPORT_DELETEDSTORE
        if(f_fSaveDate)
        {
            ChkDR( _UpdateRecentExpired( pDatastore,
                                        &f_pLicEnumContext->List.NonPrioritized.CurrKID ) );
        }
#endif

        f_pLicEnumContext->List.NonPrioritized.fCurrIsValid = FALSE;
    }

#if !_DATASTORE_WRITE_THRU
    ChkDR( DRM_DST_CommitStore( pDatastore ) );
#endif

ErrorExit:
    return dr;
}


/**********************************************************************
** Function:    DRM_LST_DeleteLicense
**
** Synopsis:    Delete a license based on KID and LID
**
** Arguments:
**      [f_pLicContext] : The License store context
**      [f_pKID]        : Specifies the KID of the license to delete
**      [f_pLID]        : Specifies the LID of the license to delete
**      [f_pSlotHint]   : Specifies the slot hint
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the required pointer parameters was NULL or the context
**          was not properly initialized
**
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LST_DeleteLicense(
    IN OUT DRM_LICSTORE_CONTEXT *f_pLicContext,
    IN     DRM_KID              *f_pKID,
    IN     DRM_LID              *f_pLID,
    IN     DRM_DST_SLOT_HINT    *f_pSlotHint )
{
    return DRM_LST_DeleteLicenseAndSaveDate(f_pLicContext, f_pKID, f_pLID, f_pSlotHint, FALSE);
}

/**********************************************************************
** Function:    DRM_LST_DeleteLicenseAndSaveData
**
** Synopsis:    Delete a license based on KID and LID and saves the deleted date in the RecentDeleted store
**
** Arguments:
**      [f_pLicContext] : The License store context
**      [f_pKID]        : Specifies the KID of the license to delete
**      [f_pLID]        : Specifies the LID of the license to delete
**      [f_pSlotHint]   : Specifies the slot hint
**      [f_fSaveDate]   : Specifies whether the deleted date should be persisted
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the required pointer parameters was NULL or the context
**          was not properly initialized
**
***********************************************************************/
DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LST_DeleteLicenseAndSaveDate(
    IN OUT DRM_LICSTORE_CONTEXT *f_pLicContext,
    IN     DRM_KID              *f_pKID,
    IN     DRM_LID              *f_pLID,
    IN     DRM_DST_SLOT_HINT    *f_pSlotHint,
    IN     DRM_BOOL              f_fSaveDate )
{
    DRM_RESULT   dr   = DRM_SUCCESS;

    ChkArg( f_pLicContext  != NULL );
    ChkArg( f_pKID         != NULL );
    ChkArg( f_pLID         != NULL );
    ChkArg( f_pLicContext->fInited );

    ChkDR( DRM_DST_DeleteSlot( f_pLicContext->pDatastore,
                               &f_pLicContext->DstNamespaceContext,
                               f_pKID,
                               f_pLID,
                               f_pSlotHint,
                               FALSE ) );
#if DRM_SUPPORT_DELETEDSTORE
    if(f_fSaveDate)
    {
        ChkDR( _UpdateRecentExpired( f_pLicContext->pDatastore,
                                     f_pKID ) );
    }
#endif

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_LST_LicCount
**
** Synopsis:    Counts the number of licenses in the store
**
** Arguments:
**      [f_pLicEnumContext] : The License store enumeration context
**      [f_pcLicenses]      : Returns the number of licenses in the store
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the required pointer parameters was NULL or the context
**          was not properly initialized
**
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LST_LicCount( 
    IN    DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext, 
    OUT   DRM_DWORD                *f_pcLicenses )
{
    DRM_RESULT dr         = DRM_SUCCESS;
    DRM_DWORD  cLicenses  = 0;
    DRM_DST   *pDatastore = NULL;

    ChkArg( f_pLicEnumContext != NULL );
    ChkArg( f_pcLicenses      != NULL );
    ChkArg( f_pLicEnumContext->fInited );

    pDatastore = f_pLicEnumContext->pLicContext->pDatastore;

    *f_pcLicenses = 0;

    /*
    ** Check whether there are licenses in the store
    */
    if ( f_pLicEnumContext->eMode != eDRM_LICENSE_STORE_MODE_NONE )
    {
        while( TRUE )
        {
            /*
            **  Look for next available license
            */
            ChkDR( DRM_DST_SlotEnumNext( pDatastore,
                                        &f_pLicEnumContext->DstEnumContext,
                                        &f_pLicEnumContext->SlotContext,
                                        &f_pLicEnumContext->List.NonPrioritized.CurrKID,
                                        &f_pLicEnumContext->List.NonPrioritized.CurrLID,
                                        NULL ) );

            /*
            ** Increment the license count
            */
            cLicenses++;

            /*
            ** Close the slot
            */
            ChkDR( DRM_DST_CloseSlot( pDatastore, &f_pLicEnumContext->SlotContext ) );
        }
    }

ErrorExit:
    /*
    ** DRM_E_NOMORE is not an error
    */
    if ( dr == DRM_E_NOMORE )
    {
        dr = DRM_SUCCESS;
        *f_pcLicenses = cLicenses;
    }
    return dr;
}

/**********************************************************************
** Function:    DRM_LST_InitEnumMultiple
**
** Synopsis:    Initializes an enumeration over multiple license stores.
**
** Arguments:
**      [f_prgbLicContexts] : The License stores to enumerate over.
**      [f_cLicContexts]    : The element count of f_prgbLicContexts
**      [f_pKID]            : Optional. Specifies a KID to filter on. 
**      [f_fPrioritized]    : Specifies whether to enumerate in priority order.
**      [f_pLicEnumContext] : Returns the enumeration context.
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the required pointer parameters was NULL or the context
**          was not properly initialized
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LST_InitEnumMultiple(
    __in_ecount( f_cLicContexts )  DRM_LICSTORE_CONTEXT              *f_prgbLicContexts[], 
    __in                           DRM_DWORD                          f_cLicContexts,
    __in_opt                       DRM_KID                           *f_pKID,         
    __in                           DRM_BOOL                           f_fPrioritized, 
    __out                          DRM_LICSTOREENUM_MULTIPLE_CONTEXT *f_pLicEnumContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  i  = 0;

    ChkArg( f_prgbLicContexts != NULL );
    ChkArg( f_cLicContexts    >  0 );
    ChkArg( f_cLicContexts    <= DRM_LICSTORE_MAX_STORES );
    ChkArg( f_pLicEnumContext != NULL );    
   
    /*
    ** Initialize per-store members
    */
    f_pLicEnumContext->cLicContexts = 0;

    for ( i = 0; i < f_cLicContexts; i++ )
    {
        ChkDR( DRM_LST_InitEnum( f_prgbLicContexts[i],
                                 f_pKID,
                                 f_fPrioritized,
                                &f_pLicEnumContext->rgLicContexts[f_pLicEnumContext->cLicContexts] ) );
        /*
        ** Exclude stores with no licenses
        */
        if ( f_pLicEnumContext->rgLicContexts[f_pLicEnumContext->cLicContexts].eMode != eDRM_LICENSE_STORE_MODE_NONE
          && ( !f_fPrioritized || f_pLicEnumContext->rgLicContexts[f_pLicEnumContext->cLicContexts].List.Prioritized.cLicenses > 0 ) )
        {
            f_pLicEnumContext->cLicContexts++;
        }
    }

    /*
    ** Initialize cross-store members
    */
    f_pLicEnumContext->eMode   = f_pLicEnumContext->cLicContexts > 0? f_pLicEnumContext->rgLicContexts[0].eMode : eDRM_LICENSE_STORE_MODE_NONE;
    f_pLicEnumContext->fInited = TRUE;

ErrorExit:
    return dr;
}

static DRM_NO_INLINE DRM_RESULT DRM_CALL _EnumNextMultiple_Natural(
    __in       DRM_LICSTOREENUM_MULTIPLE_CONTEXT *f_pLicEnumContext,
    __out_opt  DRM_KID                           *f_pKID,              
    __out_opt  DRM_LID                           *f_pLID,
    __out_opt  DRM_LICSTORE_CONTEXT             **f_ppLicStore,
    __out_opt  DRM_DST_SLOT_HINT                 *f_pSlotHint,    
    __out_opt  DRM_DWORD                         *f_pcbLicense )
{
    DRM_RESULT dr        = DRM_E_NOMORE;
    DRM_DWORD  iCurStore = 0;

    ChkArg( f_pLicEnumContext != NULL );

    /*
    ** Returns licenses enumerated naturally from the stores
    ** in the order they were initialized
    */
    for ( iCurStore = 0; iCurStore < f_pLicEnumContext->cLicContexts
                      && iCurStore < DRM_LICSTORE_MAX_STORES; iCurStore++ )
    {
        dr = DRM_LST_EnumNext( &f_pLicEnumContext->rgLicContexts[iCurStore],
                                f_pKID,
                                f_pLID,
                                f_pSlotHint,
                                f_pcbLicense );
        if ( dr == DRM_E_NOMORE ) /* Remove from the list of stores */
        {
            DRM_DWORD iStores = 0;
            
            ZEROMEM( &f_pLicEnumContext->rgLicContexts[iCurStore], SIZEOF( DRM_LICSTOREENUM_CONTEXT ) );
            f_pLicEnumContext->cLicContexts--;
            
            for ( iStores = iCurStore; iStores     < f_pLicEnumContext->cLicContexts
                                    && iStores + 1 < DRM_LICSTORE_MAX_STORES; iStores++ )
            {
                MEMCPY( &f_pLicEnumContext->rgLicContexts[iStores], 
                        &f_pLicEnumContext->rgLicContexts[iStores+1],
                        SIZEOF( DRM_LICSTOREENUM_CONTEXT ) );
            }
            iCurStore--;
        } 
        else
        {
            f_pLicEnumContext->pCurEnum = &f_pLicEnumContext->rgLicContexts[iCurStore];
            if ( f_ppLicStore != NULL )
            {
                *f_ppLicStore = f_pLicEnumContext->rgLicContexts[iCurStore].pLicContext;
            }
            break; 
        }
    }

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_LST_EnumNextMultiple
**
** Synopsis:    Retrieves the next element in an enumeration across multiple license stores.
**
** Arguments:
**      [f_pLicEnumContext] : The License enumeration context.
**      [f_pKID]            : Optional. Returns the KID for the next license.
**      [f_pLID]            : Optional. Returns the LID for the next license.
**      [f_ppLicStore]      : Optional. Returns a pointer to the license store containing the next license.
**      [f_pSlotHint]       : Optional. Returns a slot hint for the next license.
**      [f_pcbLicense]      : Optional. Returns the size in bytes of the next license.
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the required pointer parameters was NULL or the context
**          was not properly initialized
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LST_EnumNextMultiple( 
    __in       DRM_LICSTOREENUM_MULTIPLE_CONTEXT *f_pLicEnumContext,
    __out_opt  DRM_KID                           *f_pKID,              
    __out_opt  DRM_LID                           *f_pLID,
    __out_opt  DRM_LICSTORE_CONTEXT             **f_ppLicStore,
    __out_opt  DRM_DST_SLOT_HINT                 *f_pSlotHint,    
    __out_opt  DRM_DWORD                         *f_pcbLicense )
{
    DRM_RESULT                dr                                               = DRM_SUCCESS;
    DRM_DWORD                 iCurStore                                        = 0;
    DRM_LICSTOREENUM_CONTEXT *pLicContextsPrioritized[DRM_LICSTORE_MAX_STORES] = { 0 };
    DRM_DWORD                 cLicContextsPrioritized                          = 0;

    ChkArg( f_pLicEnumContext != NULL );
    ChkArg( f_pLicEnumContext->fInited );

    f_pLicEnumContext->pCurEnum = NULL;

    if ( f_ppLicStore != NULL )
    {
        *f_ppLicStore = NULL;
    }

    switch ( f_pLicEnumContext->eMode )
    {  
    case eDRM_LICENSE_STORE_MODE_NONE:
        ChkDR( DRM_E_NOMORE );
        break;
    case eDRM_LICENSE_STORE_MODE_PRIORITIZED:
        /*
        ** Returns licenses enumerated in priority order across stores
        */

        /*
        ** Set up a list of enumerations which are still prioritized
        */
        for ( iCurStore = 0; iCurStore               < f_pLicEnumContext->cLicContexts 
                          && cLicContextsPrioritized < DRM_LICSTORE_MAX_STORES; iCurStore++ )
        {
            if ( f_pLicEnumContext->rgLicContexts[iCurStore].eMode == eDRM_LICENSE_STORE_MODE_PRIORITIZED
              && f_pLicEnumContext->rgLicContexts[iCurStore].List.Prioritized.iNextLicense < f_pLicEnumContext->rgLicContexts[iCurStore].List.Prioritized.cLicenses )
            {
                pLicContextsPrioritized[cLicContextsPrioritized] = &f_pLicEnumContext->rgLicContexts[iCurStore];                
                cLicContextsPrioritized++;                
            }
        }

        /*
        ** If all stores are post prioritized (prioritized lists are all empty), 
        ** enumerate in natural mode
        */
        if ( cLicContextsPrioritized == 0 )
        {
            f_pLicEnumContext->eMode = eDRM_LICENSE_STORE_MODE_POST_PRIORITIZED;
            ChkDR( _EnumNextMultiple_Natural( f_pLicEnumContext,
                                              f_pKID,
                                              f_pLID,
                                              f_ppLicStore,
                                              f_pSlotHint,
                                              f_pcbLicense ) );
        }
        else
        {
            DRM_DWORD dwPriorityMax = 0;

            for ( iCurStore = 0; iCurStore < cLicContextsPrioritized; iCurStore++ )
            {
                if ( dwPriorityMax <= pLicContextsPrioritized[iCurStore]->List.Prioritized.rgPrioritizedList[pLicContextsPrioritized[iCurStore]->List.Prioritized.iNextLicense].dwPriority )
                {
                    dwPriorityMax = pLicContextsPrioritized[iCurStore]->List.Prioritized.rgPrioritizedList[pLicContextsPrioritized[iCurStore]->List.Prioritized.iNextLicense].dwPriority;
                    f_pLicEnumContext->pCurEnum = pLicContextsPrioritized[iCurStore];             
                }
            }
            
            if ( f_ppLicStore != NULL )
            {
                *f_ppLicStore = f_pLicEnumContext->pCurEnum->pLicContext;
            }
            ChkDR( DRM_LST_EnumNext( f_pLicEnumContext->pCurEnum,
                                     f_pKID,
                                     f_pLID,
                                     f_pSlotHint,
                                     f_pcbLicense ) );
        }
        break;
    case eDRM_LICENSE_STORE_MODE_NATURAL:
    case eDRM_LICENSE_STORE_MODE_POST_PRIORITIZED:
    case eDRM_LICENSE_STORE_MODE_FILTERED:
        ChkDR( _EnumNextMultiple_Natural( f_pLicEnumContext,
                                          f_pKID,
                                          f_pLID,
                                          f_ppLicStore,
                                          f_pSlotHint,
                                          f_pcbLicense ) );
        break;
    default:
        ChkArg( FALSE );
        break;
    }

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_LST_EnumDeleteMultiple
**
** Synopsis:    Delete currently enumerated license
**
** Arguments:
**      [f_pLicEnumContext] : The multi-license store enumeration context
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pLicEnumContext is NULL or not initialized
**      DRM_E_LICENSENOTFOUND
**          Could not find the license to delete
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LST_EnumDeleteMultiple( 
    __in DRM_LICSTOREENUM_MULTIPLE_CONTEXT *f_pLicEnumContext )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pLicEnumContext != NULL );

    ChkBOOL( f_pLicEnumContext->pCurEnum != NULL, DRM_E_LICENSENOTFOUND );

    ChkDR( DRM_LST_EnumDeleteAndSaveDate( f_pLicEnumContext->pCurEnum, FALSE ) );

ErrorExit:
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmliceval.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmexpreval.h>
#include <drmliceval.h>
#include <drmheaderparser.h>
#include <drmlicenseparser.h>
#include <drmsecurestore.h>
#include <drmxmlparser.h>
#include <drmlicreason.h>
#include <drmstrings.h>
#include <drmaes.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

typedef struct __tagDRM_STRING_AND_GUID
{
    const DRM_CONST_STRING    *pdstrString;
    const DRM_GUID            *pdguidGuid;
} DRM_STRING_TO_GUID;


/******************************************************************************
**
** Action String and GUID pairs for conversion into each other
**
******************************************************************************/
const DRM_STRING_TO_GUID g_ActionStringAndGuidConversion [] = 
{
    { &g_dstrWMDRM_RIGHT_PLAYBACK,               &DRM_ACTION_PLAY               },
    { &g_dstrWMDRM_RIGHT_COPY,                   &DRM_ACTION_COPY               },
    { &g_dstrWMDRM_RIGHT_CREATE_THUMBNAIL_IMAGE, &DRM_ACTION_CREATE_THUMBNAIL   },
    { &g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY,     &DRM_ACTION_COLLABORATIVE_PLAY },
#if DRM_SUPPORT_PLAYLIST_BURN
    { &g_dstrWMDRM_RIGHT_PLAYLIST_BURN,          &DRM_ACTION_PLAYLIST_BURN      },
#endif
    { &g_dstrWMDRM_RIGHT_COPY_TO_CD,             &DRM_ACTION_COPY_TO_CD         },
    { &g_dstrCreatePMLicense,                    &DRM_ACTION_COPY               },
    { &g_dstrBackup,                             &DRM_ACTION_BACKUP_RESTORE     },
    { &g_dstrRestore,                            &DRM_ACTION_BACKUP_RESTORE     }
};

#if DRM_SUPPORT_CONTENT_REVOCATION
static DRM_RESULT DRM_CALL _SetOrUpdateContentRevocation( 
          DRM_LICEVAL_CONTEXT *f_pContextLicEval,
    const DRM_DST             *f_pDatastore );

static DRM_BOOL DRM_CALL _IsLicenseRevoked(
    IN const DRM_LICEVAL_CONTEXT *f_pContextLicEval,
    IN const DRM_DST             *f_pDatastore );
#endif


/******************************************************************************
**
** Function: _ConvertActionStringToActionGUIDAndRightID
**
** Synopsis: Looks up a table to convert Action string into Action GUID.
**           Maps any string that it could not find to a Zero GUID (including empty string)
**           If string not found in the lookup table - tries to convert action string 
**           into a RightID DWORD.
**           
**
** Arguments:  
**      [f_pdstrAction]           : Specifies Action string
**      [f_pdguidAction]          : Returns Action GUID
**      [f_pdwRightID]            : Returns Right ID
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or improperly initialized
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _ConvertActionStringToActionGUIDAndRightID(
    __in     DRM_CONST_STRING const    *f_pdstrAction,
    __inout  DRM_GUID                  *f_pdguidAction,
    __inout  DRM_DWORD                 *f_pdwRightID )
{
    DRM_RESULT              dr                  = DRM_SUCCESS;
    DRM_DWORD               dwCount             = 0;
    DRM_BOOL                fFound              = FALSE;
    DRM_GUID                dguidZero           = EMPTY_DRM_GUID;
    DRM_LONG                lRightID            = 0;
    
    ChkArg( NULL != f_pdstrAction );
    ChkArg( NULL != f_pdguidAction );
    ChkArg( NULL != f_pdwRightID );

    *f_pdwRightID = 0;

    /* 
    ** Anything that we would not be able to map becomes a zero GUID
    */
    MEMCPY( f_pdguidAction, &dguidZero, SIZEOF(DRM_GUID) );
        
    if ( 0 < f_pdstrAction->cchString )
    {
        for ( dwCount = 0 ; dwCount < NO_OF( g_ActionStringAndGuidConversion ) && !fFound ; ++dwCount )
        {
            if ( DRM_UTL_DSTRStringsEqual( f_pdstrAction, g_ActionStringAndGuidConversion[ dwCount ].pdstrString ) )
            {
                MEMCPY( f_pdguidAction, g_ActionStringAndGuidConversion[ dwCount ].pdguidGuid, SIZEOF(DRM_GUID) );
                fFound = TRUE;
            }
        }

        /* 
        ** Not found in the lookup table? Try to convert the Action string into a Right ID
        */
        if ( !fFound )
        {
            if( DRM_SUCCEEDED( DRMCRT_wcsntol( f_pdstrAction->pwszString, f_pdstrAction->cchString, &lRightID ) ) )
            {
                *f_pdwRightID = lRightID;
            }
        }
    }

ErrorExit:
                
    return dr;
}


/******************************************************************************
**
** Function: DRM_LEVL_SearchQualifierGuidInEnablerContainer
**
** Synopsis: Searches the Qualifier GUID in Enabler Container. 
**           If not found - does depth-first search in other containers 
**           (i.e. checks nested containers first)
**           Uses recursion.
**
** Arguments:  
**      [f_pdguidActionQualifier] : Specifies action qualifier GUID for DRM_LICENSE_EVAL_ACTION operation
**      [f_pEnablerContainer]     : Specifies container to search in.
**      [f_wContainerType]        : Specifies the expected container type for license verification
**      [f_wObjectType]           : Specifies the expected object type for license verification
**      [f_fFound]                : Returns TRUE if the GUID was found in any object of any container
**                                  False otherwise.
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or improperly initialized
**      DRM_E_INVALIDLICENSE
**          The license has Unknown container or object of unexpected type
**          (in place of Enabler Container or Object of a proper type)
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LEVL_SearchQualifierGuidInEnablerContainer(
    __in     DRM_GUID const                    *f_pdguidActionQualifier,
    __in     DRM_XMR_UNKNOWN_CONTAINER const   *f_pEnablerContainer,
    __in     DRM_WORD const                     f_wContainerType,
    __in     DRM_WORD const                     f_wObjectType,
    __inout  DRM_BOOL                          *f_pfFound )
{
    DRM_RESULT                  dr                  = DRM_SUCCESS;
    DRM_XMR_UNKNOWN_OBJECT     *pObject             = NULL;

    ChkArg( NULL != f_pdguidActionQualifier
         && NULL != f_pEnablerContainer
         && NULL != f_pfFound );

    /*
    ** If the enabler container isn't valid, there's no way we'll
    ** find any specific enabler under it.
    */
    if( f_pEnablerContainer->fValid )
    {
        /* 
        ** Check that we have a container of the proper type 
        */
        ChkBOOL( f_wContainerType == f_pEnablerContainer->wType, DRM_E_INVALIDLICENSE );

        /* 
        ** First, check Enabler Objects in this container 
        */
        pObject = f_pEnablerContainer->pObject;
        while ( NULL != pObject )
        {
            /* 
            ** Check that we have a object of the proper type 
            ** Don't fail if we don't because it could be an enabler-specific restriction,
            ** instead just move on to the next object
            */
            if( pObject->fValid && ( f_wObjectType == pObject->wType ) )
            {
                DRM_GUID    dguidFromObject = EMPTY_DRM_GUID;

                /* 
                ** Check that the object contains a GUID 
                */
                ChkBOOL( SIZEOF(DRM_GUID) == (pObject->cbData), DRM_E_INVALIDLICENSE );

                DRM_BYT_CopyBytes(
                    &dguidFromObject,
                    0,
                    pObject->pbBuffer,
                    pObject->ibData,
                    SIZEOF(DRM_GUID) );
                if ( IDENTICAL_GUIDS( &dguidFromObject, f_pdguidActionQualifier ) )
                {
                    *f_pfFound = TRUE;
                    break;
                }
            }
            pObject = pObject->pNext;
        }

        /* 
        ** Did not find? Check child containers (that is, we are going depth-first container-wise) 
        */
        if ( !(*f_pfFound) && NULL != f_pEnablerContainer->pUnkChildcontainer )
        {
            ChkDR( DRM_LEVL_SearchQualifierGuidInEnablerContainer( 
                                            f_pdguidActionQualifier, 
                                            f_pEnablerContainer->pUnkChildcontainer, 
                                            f_wContainerType, 
                                            f_wObjectType, 
                                            f_pfFound ) );
        }

        /* 
        ** Still did not find? Check linked containers 
        */
        if ( !(*f_pfFound) && NULL != f_pEnablerContainer->pNext )
        {
            ChkDR( DRM_LEVL_SearchQualifierGuidInEnablerContainer( 
                                            f_pdguidActionQualifier, 
                                            f_pEnablerContainer->pNext, 
                                            f_wContainerType, 
                                            f_wObjectType, 
                                            f_pfFound ) );
        }
    }

ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   _IsCachedEvent
** 
** Synopsis :   Check whether we already have this event cached, and find the 
**              index of the entry in cache, if found
** 
** Arguments :  
**      [f_pdstrEvent]    : Event string
**      [f_pdstrType]     : Type string if it is a "ONACTION" event
**      [f_pCachedEvents] : Buffer of cached events
**      [f_cCachedEvents] : Length of cached events buffer
**      [f_piEvent]       : Returns index of entry in cache. If event is not found 
**                          in cache, this returns -1
** 
** Returns :    
**      TRUE
**          Found event in cache
**      FALSE 
**          Did not find event in cache
** 
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL _IsCachedEvent(
    IN  const DRM_CONST_STRING *f_pdstrEvent, 
    IN  const DRM_CONST_STRING *f_pdstrType,
    IN        DRM_CACHED_EVENT *f_pCachedEvents,
    IN        DRM_DWORD         f_cCachedEvents,
    OUT       DRM_LONG         *f_piEvent )
{
    DRM_DWORD  iEvent = 0;
    DRM_BOOL   fFound = FALSE;
    
    DRMASSERT( f_piEvent != NULL );
    
    if ( f_piEvent == NULL )
    {
        return FALSE;
    }
    
    *f_piEvent  = -1;
    
    if ( DRM_UTL_DSTRStringsEqual( f_pdstrEvent, &g_dstrLicEvalOnAction ) )
    {
        /*
        ** We might have already parsed this event  
        */
        for( ; iEvent < f_cCachedEvents && !fFound; iEvent++ )
        {
            if ( DRM_UTL_DSTRStringsEqual( f_pdstrType, &f_pCachedEvents[iEvent].dstrType ) )
            {
                *f_piEvent = iEvent;
                fFound = TRUE;
            }
        }
    }     
    
    return fFound;           
}

/******************************************************************************
**
** Function: _Eval
**
** Synopsis: Evaluate an expression 
**
** Arguments:  
**      [f_pcontextLicEval] : Specifies the liceval context to use
**      [f_pdstrLIData]     : Specifies the LI Data string
**      [f_pdstrEvent]      : Speifies event string data
**      [f_pdstrAttrValue]  : Specifies attribute data
**      [f_fCondition]      : Specifies whether to verify a condition or action
**      [f_pfResult]        : Returns the result of the action
**      [f_pfExisted]       : Returns whether the action existed 
**
** Returns:
**      DRM_SUCCESS
**          Success. If an action fails, may still return DRM_SUCCESS as long
**          as the error was not fatal.
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or improperly initialized
**      DRM_E_XMLNOTFOUND
**          XML data error occurred
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _Eval(
    IN OUT   DRM_LICEVAL_CONTEXT *f_pContextLicEval,
    IN OUT   DRM_CONST_STRING    *f_pdstrLIData,
    IN const DRM_CONST_STRING    *f_pdstrEvent, 
    IN const DRM_CONST_STRING    *f_pdstrAttrValue,
    IN       DRM_BOOL             f_fCondition, 
    OUT      DRM_BOOL            *f_pfResult, 
    OUT      DRM_BOOL            *f_pfExisted )
{
    DRM_RESULT        dr       = DRM_SUCCESS; 
    DRM_LONG          iEvents  = 0;
    DRM_CONST_STRING  dstrExpr = EMPTY_DRM_STRING;
    TOKEN             tResult  = { 0 };    
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMLICEVAL, PERF_FUNC_Eval );
    
    ChkArg( f_pdstrEvent != NULL );

    if ( f_pfResult != NULL )
    {
        /*
        ** Set the default value for missing event or condition 
        */
        if ( DRM_UTL_DSTRStringsEqual( f_pdstrEvent, &g_dstrLicEvalOnAction ) )
        {
            *f_pfResult = FALSE;   /* An action is missing => that right is not allowed. */
        }
        else
        {
            *f_pfResult = TRUE;    /* For other events, the default is to assume true. */
        }
    }
    else
    {
        ChkArg( !f_fCondition );
    }
    
    if ( f_pContextLicEval->fUseCachedAttribs
      && _IsCachedEvent( f_pdstrEvent, 
                         f_pdstrAttrValue, 
                         f_pContextLicEval->rgCachedEvents, 
                         f_pContextLicEval->cCachedEvents,
                        &iEvents ) )
    {
        if ( f_fCondition )
        {
            ASSIGN_DRM_STRING( dstrExpr, 
                               f_pContextLicEval->rgCachedEvents[iEvents].dstrCondition );
        }
        else
        {
            ASSIGN_DRM_STRING( dstrExpr, f_pContextLicEval->rgCachedEvents[iEvents].dstrAction );
        } 
        if ( dstrExpr.cchString == 0 )
        { 
            dr = DRM_E_XMLNOTFOUND;
        }
    }
    else
    {
        if ( f_fCondition )
        {
            dr = DRM_LIC_GetEvent( &( f_pContextLicEval->dstrContentLicense ), 
                                    f_pdstrEvent, 
                                    f_pdstrAttrValue, 
                                    f_pdstrLIData, 
                                   &dstrExpr, 
                                    NULL, 
                                    NULL );
        }
        else
        {
            dr = DRM_LIC_GetEvent( &( f_pContextLicEval->dstrContentLicense ), 
                                    f_pdstrEvent, 
                                    f_pdstrAttrValue, 
                                    f_pdstrLIData, 
                                    NULL, 
                                   &dstrExpr, 
                                    NULL );
        }
    }
    if ( DRM_FAILED( dr ) )
    {        
        if ( f_pfExisted != NULL )
        {
            *f_pfExisted = FALSE;
        }
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }
    
    if ( dstrExpr.cchString == 0 )
    {
        if ( f_pfResult != NULL )
        {
            *f_pfResult = TRUE; /* A missing CONDITION or missing expression in CONDITION. */
        }
        if ( f_pfExisted != NULL )
        {
            *f_pfExisted = FALSE;
        }
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }    
    
    if ( f_pfExisted != NULL )
    {
        *f_pfExisted = TRUE;
    }

    dr = DRM_EXPR_EvaluateExpression( &dstrExpr, &f_pContextLicEval->contextEXPR, &tResult );

    if ( !f_fCondition )
    {
        /* 
        ** It's an action.  Eat the errors, unless we're a chk build in which case let's fail.
        ** An action failing doesn't mean we shouldn't let people play their content, but we should
        ** catch this failure when testing to ensure scripts are working properly 
        */
        DRMASSERT( DRM_SUCCEEDED( dr ) );
        
        dr = DRM_SUCCESS;
        if ( f_pfResult != NULL )
        {
            *f_pfResult = TRUE;
        }
    }
    else
    {
        ChkDR( dr );
        /*
        ** It's a condition 
        */
        if ( tResult.TokenType == TOKEN_LONG && f_pfResult != NULL )
        {
            *f_pfResult = ( tResult.val.lValue != 0 );
        }
    }

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}



/******************************************************************************
**
** Function: DRM_LEVL_EvaluateExpression
**
** Synopsis: Evaluate an expression 
**
** Arguments:  
**      [f_pcontextLicEval] : Specifies the liceval context to use
**      [f_pdstrExpression] : Specifies the expression to evaluate
**      [f_pfValue]         : Returns the output of the expression
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL 
**      CPRMEXP_RETRIEVAL_FAILURE
**          Failred to retrieve date/time data
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_LEVL_EvaluateExpression(
    IN OUT   DRM_LICEVAL_CONTEXT *f_pContextLicEval,
    IN const DRM_CONST_STRING    *f_pdstrExpression,
    OUT      DRM_BOOL            *f_pfValue )
{
    DRM_RESULT dr      = DRM_SUCCESS;
    TOKEN      tResult = {0};

    ChkArg( f_pContextLicEval != NULL );
    ChkArg( f_pfValue         != NULL );
    ChkDRMString( f_pdstrExpression );

    f_pContextLicEval->contextEXPR.GetVariable          = GlobalGetVariable;
    f_pContextLicEval->contextEXPR.SetVariable          = GlobalSetVariable;
    f_pContextLicEval->contextEXPR.pvOpaqueData         = f_pContextLicEval;
    
    ChkDR( DRM_EXPR_EvaluateExpression( f_pdstrExpression, 
                                       &( f_pContextLicEval->contextEXPR ), 
                                       &tResult ) );
    if ( tResult.TokenType == TOKEN_LONG )
    {
        *f_pfValue = ( tResult.val.lValue != 0 );
    }

ErrorExit:
    return dr;
}

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK

/******************************************************************************
**
** Function: GetMachineDatetime
**
** Synopsis: Get the "machine.datetime" for the antirollback clock
**
** Arguments:  
**      [f_pcontextLicEval]    : Specifies the liceval context to use
**      [f_u64MachineDateTime] : Returns the machine date/time 
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL 
**      CPRMEXP_RETRIEVAL_FAILURE
**          Failred to retrieve date/time data
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL GetMachineDatetime(
    IN OUT DRM_LICEVAL_CONTEXT *f_pContextLicEval,
    OUT    DRM_UINT64          *f_u64MachineDateTime )
{
    DRM_RESULT dr               = DRM_SUCCESS;
    TOKEN      tMachineDatetime = {0};

    ChkArg( f_pContextLicEval    != NULL );
    ChkArg( f_u64MachineDateTime != NULL );

    /*
    ** Use GlobalGetVariable for its side effects 
    */
    ChkDR( GlobalGetVariable( &g_dstrDRM_LS_MACHINE_DATETIME, 
                              &tMachineDatetime, 
                               f_pContextLicEval ) );

    ChkBOOL( tMachineDatetime.TokenType == TOKEN_DATETIME, CPRMEXP_RETRIEVAL_FAILURE );    

    *f_u64MachineDateTime = tMachineDatetime.val.u64DateTime;
    
ErrorExit:
    return dr;
}

#endif

/******************************************************************************
**
** Function: _PerformOperationsXML
**
** Synopsis: Do an operation on an XML license
**
** Arguments:  
**      [f_pcontextLicEval] : Specifies the liceval context to use
**      [f_eOperation]      : Specifies the operation to be perfomed
**      [f_eOperationState] : 
**      [f_pdstrAction]     : Specifies action data for DRM_LICENSE_EVAL_ACTION operation
**      [f_pfPerform]       : Returns whether the action has been performed
**      [f_pfActionExisted] : Returns whether the action existed
**      [f_pDatastore]      : Specifies the DST context   
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or improperly initialized
**      LICEVAL_LICENSE_NOT_SUPPLIED
**          The license content string is NULL
**      LICEVAL_INVALID_LICENSE
**          The specified license is invalid
**      LICEVAL_LICENSE_REVOKED
**          The specified license has been revoked
**      LICEVAL_KID_MISMATCH
**          KID mismatch with header
**      DRM_E_CH_UNABLE_TO_VERIFY
**          Unable to verify the signature of the content header
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _PerformOperationsXML(
    IN OUT   DRM_LICEVAL_CONTEXT          *f_pContextLicEval,
    IN       eDRM_LICEVAL_OPERATIONS       f_eOperation,
    IN       eDRM_LICEVAL_OPERATION_STATE  f_eOperationState,
    IN const DRM_CONST_STRING             *f_pdstrAction,
    OUT      DRM_BOOL                     *f_pfPerform,
    OUT      DRM_BOOL                     *f_pfActionExisted,
    IN const DRM_DST                      *f_pDatastore )
{
    DRM_RESULT        dr            = DRM_SUCCESS;
    DRM_LONG          lResult       = 0;
    DRM_CONST_STRING  dstrAction    = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrLIData    = EMPTY_DRM_STRING;
    DRM_BOOL          fCondition    = TRUE;
    DRM_CONST_STRING  dstrKID       = EMPTY_DRM_STRING;
#if DRM_SUPPORT_CONTENT_REVOCATION
    DRM_CONST_STRING  dstrHeaderKID = EMPTY_DRM_STRING;   
#endif

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMLICEVAL, PERF_FUNC_DRM_LEVL_PerformOperationsXML );
                
    /*
    ** The other pointers in the context structure *may* not be needed so don't fail just yet for those 
    */                
    ChkArg( f_pContextLicEval              != NULL );
    ChkArg( f_pContextLicEval->pcontextBBX != NULL );
    ChkArg( f_pDatastore                   != NULL );
    
    switch( f_eOperationState )
    {
    case DRM_LICENSE_EVAL_CAN_DO_OPERATION:
        fCondition = TRUE;
        break;
    case DRM_LICENSE_EVAL_DONE_WITH_OPERATION:
        fCondition = FALSE;
        break;
    default:
        ChkArg( FALSE );
    }
    
    if ( f_pfPerform != NULL )
    {
        *f_pfPerform = FALSE;
    }
    else
    {
        ChkArg( !fCondition );
    }
    
    /*
    ** Some flag we don't recognize was given. 
    */
    ChkArg( ( f_pContextLicEval->dwFlags & 
            ~( LICEVAL_VERIFY_IGNORE_VERIFICATION
             | LICEVAL_VERIFY_CERT_WITH_EXPIRYCHECK
             | LICEVAL_VERIFY_CERT_WITHOUT_EXPIRYCHECK
             | LICEVAL_VERIFY_SIGNATURE ) ) == 0 );

    /*
    ** If you are checking the cert chain you must also check the signature 
    */       
    ChkArg( ( f_pContextLicEval->dwFlags & LICEVAL_VERIFY_SIGNATURE )                != 0
         || ( f_pContextLicEval->dwFlags & LICEVAL_VERIFY_CERT_WITH_EXPIRYCHECK )    == 0
         || ( f_pContextLicEval->dwFlags & LICEVAL_VERIFY_CERT_WITHOUT_EXPIRYCHECK ) == 0 );
      
    if ( !f_pContextLicEval->fReserved )
    {
        ChkBOOL( f_pContextLicEval->dstrContentLicense.pwszString != NULL,
                 DRM_E_LICEVAL_LICENSE_NOT_SUPPLIED );        
        
        if ( ( f_pContextLicEval->dwFlags & LICEVAL_VERIFY_IGNORE_VERIFICATION ) == 0 )
        {
            /*
            **  Some XML optimizations can be done here as well. Ignoring for
            **  now since the XML operations in here are relatively inexpensive.
            */            
            ChkDR( DRM_LIC_VerifySignature( &f_pContextLicEval->dstrContentLicense, 
                                             f_pContextLicEval->pcontextBBX, 
                                            &lResult ) );
            ChkBOOL( lResult != 0, DRM_E_INVALIDLICENSE );            
            
#if !DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
            /*
            ** During storing, we normally should check expiry of license server certificates. 
            */
            if ( f_pContextLicEval->dwFlags & LICEVAL_VERIFY_CERT_WITH_EXPIRYCHECK )
            {
                ChkDR( DRM_LIC_VerifyCertChain( &f_pContextLicEval->dstrContentLicense,
                                                 TRUE,
                                                 f_pContextLicEval, 
                                                &lResult ) );
                ChkBOOL( lResult != 0, DRM_E_INVALIDLICENSE ); 
            }
            else if ( f_pContextLicEval->dwFlags & LICEVAL_VERIFY_CERT_WITHOUT_EXPIRYCHECK )
            {
                ChkDR( DRM_LIC_VerifyCertChain( &f_pContextLicEval->dstrContentLicense,
                                                 FALSE,
                                                 f_pContextLicEval, 
                                                &lResult ) );
                ChkBOOL( lResult != 0, DRM_E_INVALIDLICENSE );  
            }
#endif
        }

#if DRM_SUPPORT_CONTENT_REVOCATION
        /*
        ** Process content revocation lists if any from this license. 
        */
        dr = _SetOrUpdateContentRevocation( f_pContextLicEval, f_pDatastore );
        
        /*
        ** Treat as failure and revoke this license. 
        ** Set a value in the ExprControl  
        */ 
        ChkBOOL( DRM_SUCCEEDED( dr )
              && !_IsLicenseRevoked( f_pContextLicEval, f_pDatastore ), DRM_E_LICEVAL_LICENSE_REVOKED );        
#endif        
        f_pContextLicEval->fReserved = TRUE; 
    }

    if ( !f_pContextLicEval->fUseCachedAttribs )
    {
        ChkDR( DRM_LIC_GetAttribute( &( f_pContextLicEval->dstrContentLicense ), 
                                      NULL, 
                                      DRM_LICENSE_ATTRIB_LID, 
                                     &dstrLIData, 
                                     &dstrAction, 
                                      0 ) );
        ChkDR( DRM_UTL_StringToGuid( &dstrAction, ( DRM_GUID* )f_pContextLicEval->LID.rgb ) );
        ChkDR( DRM_LIC_GetAttribute( &( f_pContextLicEval->dstrContentLicense ), 
                                      NULL, 
                                      DRM_LICENSE_ATTRIB_KID, 
                                     &dstrLIData, 
                                     &dstrKID, 
                                      0 ) );
        ChkDR( DRM_UTL_DecodeKID( &dstrKID, &f_pContextLicEval->KID ) );        
    }
    ZEROMEM( &( f_pContextLicEval->PMExpiryDate ), 
              SIZEOF( f_pContextLicEval->PMExpiryDate ) );
              
    f_pContextLicEval->PMExpiryDate.wYear  = 9999; /* unlimited expiry */
    f_pContextLicEval->PMExpiryDate.wMonth = 12;
    f_pContextLicEval->PMExpiryDate.wDay   = 31;
    f_pContextLicEval->lPMRights           = 0;

#if DRM_SUPPORT_PMLICENSE
    f_pContextLicEval->pwszPMLicVersion = &g_dstrPMLicenseVersionString;
#else
    f_pContextLicEval->pwszPMLicVersion = NULL;
#endif

    /*
    ** Actually can do action stuff here.  
    */
    switch( f_eOperation )
    {
        case DRM_LICENSE_EVAL_SELECT:        
            /*
            ** Fetch KID, ISSUEDATE, and CONTENTPUBKEY from the license. 
            */                           
#if DRM_SUPPORT_CONTENT_REVOCATION
            if ( f_eOperationState == DRM_LICENSE_EVAL_CAN_DO_OPERATION 
              && f_pContextLicEval->dstrContentHeader.pwszString != NULL
              && f_pContextLicEval->dstrContentHeader.cchString  > 0
              && f_pContextLicEval->dwChainDepth                 == 0 )
            {
                dr = DRM_HDR_GetAttribute( &( f_pContextLicEval->dstrContentHeader ), 
                                            NULL, 
                                            DRM_HEADER_ATTRIB_KID, 
                                           &dstrHeaderKID, 
                                            0 );
                if ( dr == DRM_SUCCESS )
                {
                    /*
                    ** Match KID only if it can be retrieved from header. 
                    ** Thus, any license can be selected for an empty content header as long
                    ** as the condition allows. If the condition refers to content data, 
                    ** then it will fail. 
                    ** Compare the KID 
                    */                        
                    if ( !f_pContextLicEval->fUseCachedAttribs )
                    {
                        ChkBOOL( DRM_UTL_DSTRStringsEqual( &dstrKID, &dstrHeaderKID ), 
                                 DRM_E_LICEVAL_KID_MISMATCH );
                    
                        DRM_LIC_GetAttribute( &( f_pContextLicEval->dstrContentLicense ), 
                                               NULL, 
                                               DRM_LICENSE_ATTRIB_CONTENTPUBKEY, 
                                              &dstrLIData, 
                                              &f_pContextLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CONTENTPUBKEY], 
                                               0 );
                    }
                    else
                    {
                        ChkBOOL( DRM_UTL_DSTRStringsEqual( &f_pContextLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_KID], 
                                                            &dstrHeaderKID ), DRM_E_LICEVAL_KID_MISMATCH );
                    }

                    if ( f_pContextLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CONTENTPUBKEY].cchString != 0 )
                    {
                        ChkDR( DRM_HDR_Verify( &( f_pContextLicEval->dstrContentHeader ), 
                                               &( f_pContextLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CONTENTPUBKEY] ), 
                                               &f_pContextLicEval->pcontextBBX->CryptoContext, 
                                               &lResult ) );                        
                        ChkBOOL( lResult != 0, DRM_E_CH_UNABLE_TO_VERIFY );
                    }
                }
            }
#endif                
            dstrAction.cchString  = g_dstrLicEvalOnSelect.cchString;
            dstrAction.pwszString = g_dstrLicEvalOnSelect.pwszString;        
            break;
        case DRM_LICENSE_EVAL_DELETE:
            dstrAction.cchString  = g_dstrLicEvalOnDelete.cchString;
            dstrAction.pwszString = g_dstrLicEvalOnDelete.pwszString;
            break;
        case DRM_LICENSE_EVAL_STORE:
            fCondition = FALSE;
            dstrAction.cchString  = g_dstrLicEvalOnStore.cchString;
            dstrAction.pwszString = g_dstrLicEvalOnStore.pwszString;
            break;
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
        case DRM_LICENSE_EVAL_REPORTCLOCK_ROLLBACK:
            ChkArg( !fCondition );
            ASSIGN_DRM_STRING( dstrAction, g_dstrLicEvalOnClockRollback );
            break;
#endif
        case DRM_LICENSE_EVAL_ACTION:
            ChkArg( f_pdstrAction != NULL );
            dstrAction.cchString  = g_dstrLicEvalOnAction.cchString;
            dstrAction.pwszString = g_dstrLicEvalOnAction.pwszString;
            break;
        default: 
            ChkArg( FALSE ); 
    }

    f_pContextLicEval->contextEXPR.GetVariable  = GlobalGetVariable;
    f_pContextLicEval->contextEXPR.SetVariable  = GlobalSetVariable;
    f_pContextLicEval->contextEXPR.pvOpaqueData = f_pContextLicEval;

    MEMCPY( &f_pContextLicEval->contextEXPR.KID, 
            &f_pContextLicEval->KID, 
             SIZEOF( DRM_KID ) );
    MEMCPY( &f_pContextLicEval->contextEXPR.LID, 
            &f_pContextLicEval->LID, 
             SIZEOF( DRM_LID ) );

    ChkDR( _Eval( f_pContextLicEval, 
                 &dstrLIData, 
                 &dstrAction, 
                  f_pdstrAction, 
                  fCondition, 
                  f_pfPerform, 
                  f_pfActionExisted ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
                
    return dr;
}

/******************************************************************************
**
** Function: _CheckCount
**
** Synopsis: Check the count for a given right on an XMR license
**
** Arguments:  
**      [f_pcontextSST]        : Specifies the secure store context
**      [f_pdstrRight]         : Specifies the right string to check
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or improperly initialized
**      DRM_E_LICENSEEXPIRED
**          The license has expired
**      LICEVAL_INVALID_LICENSE
**          The specified license is invalid
**      CPRMEXP_RETRIEVAL_FAILURE
**          Unable to retrieve the count data
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _CheckCount(
    IN OUT   DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN const DRM_CONST_STRING     *f_pdstrRight )
{
    DRM_RESULT dr    = DRM_SUCCESS;
    TOKEN      token = { 0 };

    ChkBOOL( f_pcontextSST != NULL, DRM_E_INVALIDLICENSE );        
    ChkDR( DRM_SST_GetTokenValue( f_pcontextSST, f_pdstrRight, &token ) );
    ChkBOOL( token.TokenType == TOKEN_LONG, CPRMEXP_RETRIEVAL_FAILURE );
    ChkBOOL( token.val.lValue > 0, DRM_E_LICENSEEXPIRED );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function: _DecrementCount
**
** Synopsis: Decrement the count for a given right on an XMR license
**
** Arguments:  
**      [f_pcontextSST]        : Specifies the secure store context
**      [f_pdstrRight]         : Specifies the right string to check
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or improperly initialized
**      CPRMEXP_RETRIEVAL_FAILURE
**          Unable to retrieve the count data
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _DecrementCount(
    IN OUT   DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN const DRM_CONST_STRING     *f_pdstrRight )
{
    DRM_RESULT dr    = DRM_SUCCESS;
    TOKEN      token = { 0 };

    ChkDR( DRM_SST_GetTokenValue( f_pcontextSST, f_pdstrRight, &token ) );
    ChkBOOL( token.TokenType == TOKEN_LONG, CPRMEXP_RETRIEVAL_FAILURE );
    token.val.lValue--;
    ChkDR( DRM_SST_SetTokenValue( f_pcontextSST, f_pdstrRight, &token ) );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function: _IsAllowedSourceID
**
** Synopsis: Verifies whether the application is allowed access to the source
**           of the current content
**
** Arguments:  
**      [f_pContextLicEval] : Specifies the license context
**
** Returns:
**      TRUE
**          The application is allowed access to the source
**      FALSE
**          The application is not allowed access to the source
**
******************************************************************************/
static DRM_NO_INLINE DRM_BOOL _IsAllowedSourceID( 
    IN const DRM_LICEVAL_CONTEXT *f_pContextLicEval )
{
    DRM_LONG  cAllowedSourceIDs = 0;
    DRM_BOOL  fReturn           = FALSE;

    if ( f_pContextLicEval == NULL )
    {
        return FALSE;
    }

    if ( f_pContextLicEval->fAllowAllSourceIDs )
    {
        fReturn = TRUE;
    }

    cAllowedSourceIDs = (DRM_LONG)f_pContextLicEval->cAllowedSourceIDs;
    while ( cAllowedSourceIDs > 0 && !fReturn )
    {
        cAllowedSourceIDs--;

        if ( f_pContextLicEval->plicenseXMR->containerOuter.containerGlobalPolicies.SourceID.dwValue
          == f_pContextLicEval->rgdwAllowedSourceIDs[cAllowedSourceIDs] )
        {
            fReturn = TRUE;
        }
    }

    return fReturn;
}
static DRM_NO_INLINE DRM_RESULT DRM_CALL _StoreInitialExtensibleStates( 
    DRM_WORD                wRightID, 
    DRM_XMR_UNKNOWN_OBJECT *pObject, 
    DRM_SECSTORE_CONTEXT   *pContextSST )
{
    DRM_RESULT dr = DRM_SUCCESS;

    while( pObject != NULL
        && pObject->fValid )
    {
        if( pObject->wFlags & XMR_FLAGS_HAS_SECURE_STATE )
        {
            DRM_DWORD wPolicySize = 0;
            DRM_BYTE  bType = 0;
            DRM_WORD  wStateSize = 0;
            DRM_DWORD ibOffset = pObject->ibData;
            DRM_BOOL  fIsGarbage = FALSE;
            TOKEN     token;

            ChkBOOL( pObject->cbData - (ibOffset - pObject->ibData) >= SIZEOF( DRM_DWORD ) + 1 + SIZEOF( DRM_WORD ), DRM_E_INVALIDLICENSE );

            NETWORKBYTES_TO_WORD( wPolicySize, pObject->pbBuffer, ibOffset );
            ibOffset += SIZEOF( DRM_WORD );
            ibOffset += wPolicySize;

            bType = GET_BYTE( pObject->pbBuffer, ibOffset );
            ibOffset++;

            NETWORKBYTES_TO_WORD( wStateSize, pObject->pbBuffer, ibOffset );
            ibOffset += SIZEOF( DRM_WORD );

            /*
            ** Server may not have given us any data at all if
            ** the type is binary. Only thing we can do is just ignore
            ** it.
            */
            if( pObject->cbData - (ibOffset - pObject->ibData) < wStateSize )
            {
                if( bType == TOKEN_BYTEBLOB )
                {
                    fIsGarbage = TRUE;
                }
                else
                {
                    ChkDR( DRM_E_INVALIDLICENSE );
                }
            }
            
            switch( bType )
            {
                case TOKEN_LONG:
                    /* Count */
                    ChkBOOL( wStateSize == SIZEOF( DRM_DWORD ), DRM_E_INVALIDLICENSE );
                    token.TokenType = TOKEN_LONG;
                    NETWORKBYTES_TO_DWORD( token.val.lValue, pObject->pbBuffer, ibOffset );
                    break;
                case TOKEN_DATETIME:
                    /* Date */
                    ChkBOOL( wStateSize == SIZEOF( DRM_UINT64 ), DRM_E_INVALIDLICENSE );
                    token.TokenType = TOKEN_DATETIME;
                    NETWORKBYTES_TO_QWORD( token.val.u64DateTime, pObject->pbBuffer, ibOffset );
                    break;
                case TOKEN_BYTEBLOB:
                    /* Raw binary */
                    token.TokenType = TOKEN_BYTEBLOB;
                    token.val.byteValue.cbBlob = wStateSize;
                    token.val.byteValue.pbBlob = pObject->pbBuffer + __CB_DECL( ibOffset );
                    break;
                default:
                    ChkDR( DRM_E_INVALIDLICENSE );
            }

            if( !fIsGarbage )
            {
                ChkDR( DRM_SST_SetExtendedTokenValue( pContextSST, wRightID, pObject->wType, &g_dstrInitialExtensibleStateAttributeName, &token, DRM_TOKEN_RESOLVE_LAST_WINS ) );
            }
        }
        pObject = pObject->pNext;
    }
    
ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function: DRM_LEVL_PerformOperationsXMR
**
** Synopsis: Do an operation on an XMR license
**
** Arguments:  
**      [f_pcontextLicEval] : Specifies the liceval context to use
**      [f_eOperation]      : Specifies the operation to be perfomed
**      [f_eOperationState] : 
**      [f_pdguidAction]    : Specifies action GUID for DRM_LICENSE_EVAL_ACTION operation
**      [f_pdguidActionQualifier] : Specifies action qualifier GUID for DRM_LICENSE_EVAL_ACTION operation
**      [f_dwRightID]       : Specifies optional right ID
**      [f_pfPerform]       : Returns whether the action has been performed
**      [f_pfActionExisted] : Returns whether the action existed
**      [f_pDatastore]      : Specifies the DST context   
**      [f_pfnPolicyCallback] : Callback function for output restrictions
**      [f_pv]                      : Void pass-through parameter for callback
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or improperly initialized
**      DRM_E_LICEVAL_LICENSE_NOT_SUPPLIED
**          The license content string is NULL
**      DRM_E_LICEVAL_INVALID_LICENSE
**          The specified license is invalid
**      DRM_E_LICEVAL_LICENSE_REVOKED
**          The specified license has been revoked
**      DRM_E_LICEVAL_KID_MISMATCH
**          KID mismatch with header
**      DRM_E_CH_UNABLE_TO_VERIFY
**          Unable to verify the signature of the content header
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LEVL_PerformOperationsXMR(
    __inout     DRM_LICEVAL_CONTEXT          *f_pContextLicEval,
    __in        eDRM_LICEVAL_OPERATIONS       f_eOperation,
    __in        eDRM_LICEVAL_OPERATION_STATE  f_eOperationState,
    __in_opt    DRM_GUID const               *f_pdguidAction,
    __in_opt    DRM_GUID const               *f_pdguidActionQualifier,
    __in        DRM_DWORD const               f_dwRightID,
    __out_opt   DRM_BOOL                     *f_pfPerform,
    __out_opt   DRM_BOOL                     *f_pfActionExisted,
    __in        DRM_DST const                *f_pDatastore,
    __in_opt    DRMPFNPOLICYCALLBACK          f_pfnPolicyCallback,
    __in_opt    DRM_VOID const               *f_pv )
{
    DRM_RESULT              dr                 = DRM_SUCCESS;
    DRM_DWORD               dwTemp             = XMR_UNLIMITED;
    DRM_WORD                wTemp              = 0;
    DRM_BOOL                fCondition         = TRUE;
    DRM_BOOL                fRestricted        = FALSE;
    DRMFILETIME             ftXMR              = {0};
    DRMFILETIME             ftCurrent          = {0};
    DRM_UINT64              ui64Current        = DRM_UI64LITERAL( 0, 0 );
    DRM_UINT64              ui64XMR            = DRM_UI64LITERAL( 0, 0 );
    DRM_XMR_LICENSE        *pXMR               = NULL;
    TOKEN                   token              = { 0 };  
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK  
    TOKEN                   tSaved             = { 0 };
    DRM_UINT64              u64MachineDateTime = { 0 };
#endif /* DRM_SUPPORT_ANTIROLLBACK_CLOCK */
    const DRM_CONST_STRING *pdstrCountString   = NULL;
    DRM_XMR_UNKNOWN_CONTAINER *pExtendedRight  = NULL;
    DRM_XMR_UNKNOWN_OBJECT    *pExtendedRestrictions = NULL;
    DRM_BOOL                fReturnStoreError  = FALSE;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMLICEVAL, PERF_FUNC_DRM_LEVL_PerformOperationsXMR );
           
    ChkArg( f_pContextLicEval != NULL );
    ChkArg( f_pDatastore      != NULL );
    
    ChkBOOL( f_pContextLicEval->plicenseXMR != NULL, DRM_E_LICEVAL_LICENSE_NOT_SUPPLIED );     
    ChkArg( f_pContextLicEval->plicenseXMR->containerOuter.fValid );

    f_pContextLicEval->fDomainBoundRootRequired = FALSE;

    pXMR = f_pContextLicEval->plicenseXMR;
    
    switch( f_eOperationState )
    {
    case DRM_LICENSE_EVAL_CAN_DO_OPERATION:
        fCondition = TRUE;
        break;
    case DRM_LICENSE_EVAL_DONE_WITH_OPERATION:
        fCondition = FALSE;
        break;
    default:
        ChkArg( FALSE );
    }
    
    if ( f_pfPerform != NULL )
    {
        *f_pfPerform = FALSE;
    }
    else
    {
        ChkArg( !fCondition );
    }

    Oem_Clock_GetSystemTimeAsFileTime( f_pContextLicEval->pcontextBBX->pOEMContext, &ftCurrent );
    FILETIME_TO_UI64( ftCurrent, ui64Current );

    if ( f_pContextLicEval->pcontextSSTLicense != NULL )
    {
        ChkDR( DRM_SST_GetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                     &g_dstrDRM_LS_DELETED_ATTR, 
                                     &token ) );
        
        /*
        ** Value should be 0.  If not fail because the license has been deleted before 
        */
        ChkBOOL( token.val.lValue == 0, DRM_E_INVALIDLICENSE );
    }

    switch( f_eOperation )
    {
        case DRM_LICENSE_EVAL_SELECT:
        {
             ChkBOOL( !XMR_IS_RIGHTS_VALID( pXMR )
                  || !( ( pXMR->containerOuter.containerGlobalPolicies.Rights.wValue & XMR_RIGHTS_CANNOT_BIND_LICENSE ) == XMR_RIGHTS_CANNOT_BIND_LICENSE ),
                     DRM_E_XMR_LICENSE_NOT_BINDABLE );
             
            if( XMR_IS_GLOBAL_POLICIES_VALID( pXMR ) )
            {
                if( XMR_HAS_TIME_BASED_RESTRICTIONS( pXMR ) )
                {
                    /*
                    **  If the license is timebound and flag is set to ignore time bound licenses
                    ** ( for e.g. if device  clock is not set ), return Clock not set
                    */
                    if ( ( f_pContextLicEval->pcontextSSTLicense == NULL
                        && ( f_pContextLicEval->dwFlags & LICEVAL_IGNORE_SECURESTORE_ENTRY ) == 0 )
                      || ( f_pContextLicEval->fIgnoreTimeBoundLicense 
                        && XMR_IS_EXPIRATION_DATE_VALID( pXMR ) ) )
                    {
                        f_pContextLicEval->lReasonForFail = LR_LICENSE_CLOCK_NOT_SET;
                        ChkDR( CPRMEXP_CLOCK_REQUIRED );
                    }
                }

                if( XMR_IS_EXPIRATION_AFTER_FIRST_USE_VALID( pXMR )
                 && f_pContextLicEval->pcontextSSTLicense != NULL )
                {
                    ZEROMEM( &token, SIZEOF( token ) );
                    ChkDR( DRM_SST_GetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                                 &g_dstrDRM_LS_FIRSTUSE_ATTR, 
                                                 &token ) );
                    if( dr != DRM_S_FALSE )
                    {
                        ChkBOOL( token.TokenType == TOKEN_DATETIME, CPRMEXP_INVALID_TOKEN );
                        
                        if ( !DRM_UI64Les( ui64Current, token.val.u64DateTime ) )
                        {                                                                       
                            if( DRM_I64ToUI32( DRM_I64Div( DRM_UI2I64( DRM_UI64Sub( ui64Current, token.val.u64DateTime ) ), DRM_I64( C_TICS_PER_SECOND )) ) >= pXMR->containerOuter.containerGlobalPolicies.ExpirationAfterUse.dwValue )
                            {
                                f_pContextLicEval->lReasonForFail = LR_LICENSE_EXPIRED;
                                goto ErrorExit;
                            }
                        }
                        else
                        {
                            f_pContextLicEval->lReasonForFail = LR_LICENSE_TIME_CHECK_FAILURE;
                            goto ErrorExit;
                        }
                    }
                }

                if( XMR_IS_EXPIRATION_AFTER_STORE_VALID( pXMR )
                 && f_pContextLicEval->pcontextSSTLicense != NULL )
                {
                    ZEROMEM( &token, SIZEOF( token ) );
                    ChkDR( DRM_SST_GetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                                 &g_dstrDRM_LS_FIRSTSTORE_ATTR, 
                                                 &token ) );
                    if( dr == DRM_S_FALSE )
                    {
                        /* 
                        ** Token not found isn't acceptable 
                        */
                        ChkDR( CPRMEXP_RETRIEVAL_FAILURE );
                    }
                    else
                    {
                        ChkBOOL( token.TokenType == TOKEN_DATETIME, CPRMEXP_INVALID_TOKEN );
                        
                        if ( !DRM_UI64Les( ui64Current, token.val.u64DateTime ) )
                        {                                                                       
                            if( DRM_I64ToUI32( DRM_I64Div( DRM_UI2I64( DRM_UI64Sub( ui64Current, token.val.u64DateTime ) ), DRM_I64( C_TICS_PER_SECOND )) ) >= pXMR->containerOuter.containerGlobalPolicies.ExpirationAfterStore.dwValue )
                            {
                                f_pContextLicEval->lReasonForFail = LR_LICENSE_EXPIRED;
                                goto ErrorExit;
                            }
                        }
                        else
                        {
                            f_pContextLicEval->lReasonForFail = LR_LICENSE_TIME_CHECK_FAILURE;
                            goto ErrorExit;
                        }
                    }
                }

                if( XMR_IS_EXPIRATION_VALID( pXMR ) )
                {
                    if( pXMR->containerOuter.containerGlobalPolicies.Expiration.dwBeginDate != 0 )
                    {
                        CREATE_FILE_TIME( pXMR->containerOuter.containerGlobalPolicies.Expiration.dwBeginDate, ftXMR );                                                  
                        FILETIME_TO_UI64( ftXMR, ui64XMR );
                        
                        if( !( DRM_UI64Les( ui64XMR, ui64Current )
                            || DRM_UI64Eql( ui64XMR, ui64Current ) ) )
                        {
                            f_pContextLicEval->lReasonForFail = LR_LICENSE_NOTENABLED;
                            goto ErrorExit;
                        }
                    }
                    if( pXMR->containerOuter.containerGlobalPolicies.Expiration.dwEndDate != XMR_UNLIMITED )
                    {
                        CREATE_FILE_TIME( pXMR->containerOuter.containerGlobalPolicies.Expiration.dwEndDate, ftXMR );
                        FILETIME_TO_UI64( ftXMR, ui64XMR );
                        
                        if( !DRM_UI64Les( ui64Current, ui64XMR ) )
                        {
                            f_pContextLicEval->lReasonForFail = LR_LICENSE_EXPIRED;
                            goto ErrorExit;
                        }
                    }
                }
                
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
                /*
                ** If the license should be disabled on clock rollback
                ** require that "machine.datetime >= secstate.OldSaveTime"
                ** Basically, don't let the license be used before it was saved 
                ** or before the clock rollback time
                */
                if ( XMR_HAS_TIME_BASED_RESTRICTIONS( pXMR )
                  && f_pContextLicEval->pcontextSSTLicense != NULL )
                {
                    /*
                    ** Get machine.datetime 
                    */
                    ChkDR( GetMachineDatetime( f_pContextLicEval, &u64MachineDateTime ) );

                    /*
                    ** Get secstate.OldSaveTime 
                    */
                    ZEROMEM( &token, SIZEOF( token ) );
                    ChkDR( DRM_SST_GetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                                 &g_dstrDRM_LS_OLDSAVETIME_ATTR, 
                                                 &token ) );
                                                 
                    /*
                    ** If secure store entry token does not contain oldsavetime attribute for this license ( possible if we have upgraded from Emerald ),
                    ** continue without reporting any error
                    */
                    if ( token.TokenType == TOKEN_DATETIME 
                      && DRM_UI64Les( u64MachineDateTime, token.val.u64DateTime ) )
                    {
                        TRACE(("Clock rollback detected in DRM_LEVL_PerformOperationsXMR."));
                        f_pContextLicEval->lReasonForFail = LR_LICENSE_TIME_CHECK_FAILURE;
                        goto ErrorExit;
                    }
                }

#endif /* DRM_SUPPORT_ANTIROLLBACK_CLOCK */

#if DRM_SUPPORT_SECURE_CLOCK
                /*
                ** If the license specifies a grace period,                
                */
                if ( XMR_IS_GRACE_PERIOD_VALID( pXMR ) )
                {
                    /*
                    ** Indicate that the license has processed the grace period 
                    */
                    f_pContextLicEval->eTimeBasedState = LICEVAL_GRACEPERIODREFERENCED;

                    /*
                    ** If we're in the grace period, make sure we're within the limit allowed by the license 
                    */
                    if ( f_pContextLicEval->fInGracePeriod )
                    {
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
                        /*
                        ** Get machine.datetime
                        */
                        ChkDR( GetMachineDatetime( f_pContextLicEval, &ui64Current ) );
#endif
                        /*
                        ** Can only exceed grace period if current time is after GP Start Time 
                        */
                        if ( DRM_UI64Les( f_pContextLicEval->u64GPStartTime, ui64Current )
                          && DRM_I64ToUI32( DRM_I64Div( DRM_UI2I64( DRM_UI64Sub( ui64Current, f_pContextLicEval->u64GPStartTime ) ), DRM_I64( C_TICS_PER_SECOND ) ) ) >= pXMR->containerOuter.containerGlobalPolicies.GracePeriod.dwValue )
                        {
                            TRACE(("Grace period of %d seconds exceeded.", pXMR->containerOuter.containerGlobalPolicies.GracePeriod.dwValue));
                            f_pContextLicEval->lReasonForFail = LR_LICENSE_TIME_CHECK_FAILURE;
                            goto ErrorExit;
                        }
                    }
                }
#endif /* DRM_SUPPORT_SECURE_CLOCK */
                if( XMR_IS_MINIMUM_ENVIRONMENT_VALID( pXMR ) )
                {
                    if( pXMR->containerOuter.containerGlobalPolicies.MinimumEnvironment.wMinimumSecurityLevel > f_pContextLicEval->certinfoSDK.appSec
                     || ( ( f_pContextLicEval->fLegacyAppInfoValid 
                         && pXMR->dwVersion == XMR_VERSION_1 
                         && pXMR->containerOuter.containerGlobalPolicies.MinimumEnvironment.wMinimumSecurityLevel > f_pContextLicEval->certinfoAppLegacy.appSec )
                       || ( f_pContextLicEval->fAppInfoValid 
                         && pXMR->dwVersion != XMR_VERSION_1 
                         && pXMR->containerOuter.containerGlobalPolicies.MinimumEnvironment.wMinimumSecurityLevel > f_pContextLicEval->certinfoApp.appSec ) ) )
                    {
                        f_pContextLicEval->lReasonForFail = LR_LICENSE_APPSECLOW;
                        goto ErrorExit;
                    }

#if DRM_SUPPORT_APP_REVOCATION
                    if (pXMR->dwVersion == XMR_VERSION_1)
                    {
                        if( pXMR->containerOuter.containerGlobalPolicies.MinimumEnvironment.dwMinimumAppRevocationListVersion > f_pContextLicEval->idCRLsCurrent.wmdrmapp)
                        {
                            f_pContextLicEval->lReasonForFail = LR_LICENSE_CONTENT_REVOKED;
                            goto ErrorExit;
                        }
                    }
                    else
                    {
                        /*
                         * For V2+ XMR, we do not support the minimum environment objects, so validate
                         * that the versions in this object are zero if the object is valid.
                         * Note that it can be valid since the minimum security level is still
                         * honored.
                        */
                        ChkBOOL( pXMR->containerOuter.containerGlobalPolicies.MinimumEnvironment.dwMinimumAppRevocationListVersion == 0,
                            DRM_E_INVALIDLICENSE);
                        
                        ChkBOOL( pXMR->containerOuter.containerGlobalPolicies.MinimumEnvironment.dwMinimumDeviceRevocationListVersion == 0,
                            DRM_E_INVALIDLICENSE);
                    }
#endif /* DRM_SUPPORT_APP_REVOCATION */
                }
            }
        }
        break;

        case DRM_LICENSE_EVAL_DELETE:

            /*
            ** Update secure store to add Deleted to the entry 
            */
            token.val.lValue = 1;
            token.TokenType  = TOKEN_LONG;
            ChkDR( DRM_SST_SetTokenValue( f_pContextLicEval->pcontextSSTLicense, &g_dstrDRM_LS_DELETED_ATTR, &token ) );

            break;
        case DRM_LICENSE_EVAL_STORE:
            /*
            ** Return a store error if we have a valid yet non-bindable license.
            */
            wTemp = pXMR->containerOuter.containerGlobalPolicies.Rights.wValue;

            fReturnStoreError =
                 XMR_IS_RIGHTS_VALID( pXMR )
              && ( ( wTemp & XMR_RIGHTS_CANNOT_BIND_LICENSE ) == XMR_RIGHTS_CANNOT_BIND_LICENSE );

            ChkBOOL( !fReturnStoreError, DRM_E_FAILED_TO_STORE_LICENSE );

            if( XMR_IS_EXPIRATION_VALID( pXMR ) )
            {
                if( pXMR->containerOuter.containerGlobalPolicies.Expiration.dwEndDate != XMR_UNLIMITED )
                {
                    CREATE_FILE_TIME( pXMR->containerOuter.containerGlobalPolicies.Expiration.dwEndDate, ftXMR );
                    FILETIME_TO_UI64( ftXMR, ui64XMR );
                    
                    if( !DRM_UI64Les( ui64Current, ui64XMR ) )
                    {
                        f_pContextLicEval->lReasonForFail = LR_LICENSE_EXPIRED;
                        goto ErrorExit;
                    }
                }
            }

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
            /* 
            ** If the license should be disabled on clock rollback
            ** evaluate "!exists( secstate.OldSaveTime )?secstate.OldSaveTime=machine.datetime:0;"
            ** Basically, save the time the license was first saved
            */
            if ( XMR_HAS_TIME_BASED_RESTRICTIONS( pXMR ) )
            {
                /*
                ** Get secstate.OldSaveTime 
                */
                ZEROMEM( &token, SIZEOF( token ) );
                ChkDR( DRM_SST_GetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                             &g_dstrDRM_LS_OLDSAVETIME_ATTR, 
                                             &token ) );
                /*
                ** Only set it if it doesn't already exist 
                */
                if( dr == DRM_S_FALSE )
                {                    
                    /*
                    ** Get machine.datetime 
                    */
                    ChkDR( GetMachineDatetime( f_pContextLicEval, &u64MachineDateTime ) );

                    /*
                    ** Set the time this license was saved 
                    */
                    ZEROMEM( &token, SIZEOF( token ) );
                    token.val.u64DateTime = u64MachineDateTime;
                    token.TokenType = TOKEN_DATETIME;
                    ChkDR( DRM_SST_SetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                                 &g_dstrDRM_LS_OLDSAVETIME_ATTR, 
                                                 &token ) );

                }
            }
#endif /* DRM_SUPPORT_ANTIROLLBACK_CLOCK */

            if( XMR_IS_EXPIRATION_AFTER_STORE_VALID( pXMR ) )
            {
                ZEROMEM( &token, SIZEOF( token ) );
                FILETIME_TO_UI64( ftCurrent, token.val.u64DateTime );
                token.TokenType = TOKEN_DATETIME;
                ChkDR( DRM_SST_SetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                             &g_dstrDRM_LS_FIRSTSTORE_ATTR, 
                                             &token ) );
            }

            if( XMR_IS_PLAY_VALID( pXMR ) )
            {
                if( XMR_IS_PLAYCOUNT_VALID( pXMR ) )
                {
                    ZEROMEM( &token, SIZEOF( token ) );
                    token.TokenType  = TOKEN_LONG;
                    token.val.lValue = pXMR->containerOuter.containerPlaybackPolicies.PlayCount.dwValue;
                    ChkDR( DRM_SST_SetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                                 &g_dstrDRM_LS_PLAYCOUNT_ATTR, 
                                                 &token ) );
                }
                
                ChkDR( _StoreInitialExtensibleStates( XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER, 
                                    pXMR->containerOuter.containerPlaybackPolicies.pUnknownObjects, 
                                    f_pContextLicEval->pcontextSSTLicense ) );
            }

            if( XMR_IS_COPY_VALID( pXMR ) )
            {
                if( XMR_IS_COPYCOUNT_VALID( pXMR ) )
                {
                    ZEROMEM( &token, SIZEOF( token ) );
                    token.TokenType  = TOKEN_LONG;
                    token.val.lValue = pXMR->containerOuter.containerCopyPolicies.CopyCount.dwValue;
                    ChkDR( DRM_SST_SetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                                 &g_dstrDRM_LS_COPYCOUNT_ATTR, 
                                                 &token ) );
                }

                ChkDR( _StoreInitialExtensibleStates( XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER, 
                        pXMR->containerOuter.containerCopyPolicies.pUnknownObjects, 
                        f_pContextLicEval->pcontextSSTLicense ) );
            }
            
#if DRM_SUPPORT_PLAYLIST_BURN
            if( XMR_IS_PLAYLISTBURN_VALID( pXMR ) )
            {
                if( XMR_IS_PLAYLISTBURN_RESTRICTIONS_VALID( pXMR )
                 && pXMR->containerOuter.containerPlaylistBurnPolicies.Restrictions.dwPlaylistBurnTrackCount != XMR_UNLIMITED )
                {
                    ZEROMEM( &token, SIZEOF( token ) );
                    token.TokenType  = TOKEN_LONG;
                    token.val.lValue = pXMR->containerOuter.containerPlaylistBurnPolicies.Restrictions.dwPlaylistBurnTrackCount;
                    ChkDR( DRM_SST_SetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                                 &g_dstrPlaylistBurnCount, 
                                                 &token ) );

                    /*
                    ** Set the playlist burn increment count before returning 
                    */
                    f_pContextLicEval->cPlaylistBurnIncrement = pXMR->containerOuter.containerPlaylistBurnPolicies.Restrictions.dwMaxPlaylistBurnCount;
                }
            
                ChkDR( _StoreInitialExtensibleStates( XMR_OBJECT_TYPE_ALLOW_PLAYLISTBURN_POLICY_CONTAINER, 
                        pXMR->containerOuter.containerPlaylistBurnPolicies.pUnknownObjects, 
                        f_pContextLicEval->pcontextSSTLicense ) );
            }

#endif /* DRM_SUPPORT_PLAYLIST_BURN */

            if( pXMR->containerOuter.containerUnknown.fValid )
            {
                DRM_XMR_UNKNOWN_CONTAINER *pContainer = &pXMR->containerOuter.containerUnknown;

                while( pContainer != NULL
                    && pContainer->fValid )
                {
                    ChkDR( _StoreInitialExtensibleStates( pContainer->wType, pContainer->pObject, f_pContextLicEval->pcontextSSTLicense ) );
                    pContainer = pContainer->pNext;
                }
            }

            break;

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK

        case DRM_LICENSE_EVAL_REPORTCLOCK_ROLLBACK:
            ChkArg( !fCondition );

            /*
            ** If the license should be disabled on clock rollback
            ** Set the license save time to a newer last know good time
            */
            if ( XMR_HAS_TIME_BASED_RESTRICTIONS( pXMR ) )
            {
                /*
                ** Get secstate.OldSaveTime 
                */
                ZEROMEM( &token, SIZEOF( token ) );
                ChkDR( DRM_SST_GetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                             &g_dstrDRM_LS_OLDSAVETIME_ATTR, 
                                             &token ) );
                               
                if ( dr == DRM_S_FALSE  || token.TokenType != TOKEN_DATETIME )
                {
                    /*
                    ** If the oldsavetime attribute doesn't exists 
                    ** ( possible if we upgraded from emerald )
                    ** create one now
                    */

                    /*
                    ** Get machine.datetime 
                    */
                    ChkDR( GetMachineDatetime( f_pContextLicEval, &u64MachineDateTime ) );

                    /*
                    ** Set the time this license was saved 
                    */
                    ZEROMEM( &token, SIZEOF( token ) );
                    token.val.u64DateTime = u64MachineDateTime;
                    token.TokenType = TOKEN_DATETIME;
                    ChkDR( DRM_SST_SetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                                 &g_dstrDRM_LS_OLDSAVETIME_ATTR, 
                                                 &token ) );
                }

                /*
                ** Get secstate.global.saveddatetime 
                */
                ChkDR( DRM_SST_GetTokenValue( f_pContextLicEval->pcontextSSTGlobal, 
                                             &g_dstrExprVarSavedDateTime, 
                                             &tSaved ) );
                ChkBOOL( dr != DRM_S_FALSE  && token.TokenType == TOKEN_DATETIME, 
                         CPRMEXP_RETRIEVAL_FAILURE );
                
                if ( DRM_UI64Les( token.val.u64DateTime, tSaved.val.u64DateTime ) )
                {
                    /*
                    ** Set the time this license was rolled back 
                    */
                    ZEROMEM( &token, SIZEOF( token ) );
                    token.val.u64DateTime = tSaved.val.u64DateTime;
                    token.TokenType = TOKEN_DATETIME;
                    ChkDR( DRM_SST_SetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                                 &g_dstrDRM_LS_OLDSAVETIME_ATTR, 
                                                 &token ) );
                }
            }
            break;
#endif /* DRM_SUPPORT_ANTIROLLBACK_CLOCK */

        case DRM_LICENSE_EVAL_ACTION:
            {   
                DRM_WORD wRightID = 0;
                DRM_GUID dguidEmpty = EMPTY_DRM_GUID;
                
                ChkArg( NULL != f_pdguidAction );
                                           
                /*
                **  Check for Allowed SourceIDs
                */
                if ( (!IDENTICAL_GUIDS( f_pdguidAction, &dguidEmpty ) || (0 < f_dwRightID))
                  && XMR_IS_RESTRICTED_SOURCEID_VALID( pXMR )
                  && !_IsAllowedSourceID( f_pContextLicEval ) )
                {
                    fRestricted = TRUE;
                }

                /*
                ** First assume that the action exists 
                */
                if( f_pfActionExisted != NULL )
                {
                    *f_pfActionExisted = TRUE;                    
                }

                if( IDENTICAL_GUIDS( f_pdguidAction, &DRM_ACTION_PLAY ) )
                {
                    wRightID = XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER;
                    
                    if( XMR_IS_PLAY_VALID( f_pContextLicEval->plicenseXMR ) )
                    {
                        if( XMR_IS_PLAYCOUNT_VALID( f_pContextLicEval->plicenseXMR ) )
                        {
                            dwTemp = f_pContextLicEval->plicenseXMR->containerOuter.containerPlaybackPolicies.PlayCount.dwValue;
                            pdstrCountString = &g_dstrDRM_LS_PLAYCOUNT_ATTR;
                        }

                        /* 
                        ** We will be trampling this, make sure it hasn't already been set 
                        */
                        DRMASSERT( pExtendedRestrictions == NULL );
                        pExtendedRestrictions = pXMR->containerOuter.containerPlaybackPolicies.pUnknownObjects;

                        /* 
                        ** Check if we need to verify the Action Qualifier GUID as well 
                        */
                        if ( NULL != f_pdguidActionQualifier )
                        {
                            DRM_BOOL    fFound = FALSE;

                            /* 
                            ** This will check the first container; if not found - will go depth-first into other containers 
                            */
                            ChkDR( DRM_LEVL_SearchQualifierGuidInEnablerContainer(
                                                            f_pdguidActionQualifier,
                                                           &pXMR->containerOuter.containerPlaybackPolicies.UnknownContainer,
                                                            XMR_OBJECT_TYPE_PLAY_ENABLER_CONTAINER,
                                                            XMR_OBJECT_TYPE_PLAY_ENABLER_OBJECT,
                                                           &fFound ) );

                            /* 
                            ** Enabler GUID not found in the license? Just fail. 
                            */
                            if ( !fFound )
                            {
                                goto ErrorExit;
                            }
                        }
                    }
                    else
                    {
                        /*
                        ** Right doesn't exist.  Just fail 
                        */
                        goto ErrorExit;
                    }
                }
                else if( IDENTICAL_GUIDS( f_pdguidAction, &DRM_ACTION_COLLABORATIVE_PLAY ) )
                {
                    /*
                    ** It's possible that XMR_RIGHTS_COLLABORATIVE_PLAY right doesn't exist.
                    ** However, PDRM licenses that supported PLAY always supported 
                    ** COLLABORATIVE_PLAY too. So if this license supports play AND it was 
                    ** converted from PDRM, then we allow use of the basic PLAY right.
                    ** Note: We can NOT simply change the V1->V3 conversion logic to add the
                    ** COLLABORATIVE_PLAY rights to PDRM licenses because we've already shipped
                    ** code that does this conversion without adding that right. 
                    ** Without this evaluation code handling this situation, people will lose
                    **  their COLLABORATIVE_PLAY rights on those licenses.
                    */
                    if( ( XMR_IS_RIGHTS_VALID( pXMR ) && ( XMR_RIGHTS_COLLABORATIVE_PLAY == ( XMR_RIGHTS_COLLABORATIVE_PLAY & pXMR->containerOuter.containerGlobalPolicies.Rights.wValue ) ) )
                     || ( XMR_IS_PLAY_VALID( pXMR ) && XMR_IS_SOURCEID_VALID( pXMR ) && pXMR->containerOuter.containerGlobalPolicies.SourceID.dwValue == XMR_SOURCEID_PDRM ) )
                    {
                        if( XMR_IS_PLAYCOUNT_VALID( pXMR ) )
                        {
                            dwTemp = pXMR->containerOuter.containerPlaybackPolicies.PlayCount.dwValue;
                            pdstrCountString = &g_dstrDRM_LS_PLAYCOUNT_ATTR;
                        }
                    }
                    else
                    {
                        /*
                        ** Right doesn't exist.  Just fail 
                        */
                        goto ErrorExit;
                    }
                }
                
#if DRM_SUPPORT_PLAYLIST_BURN                
                /*
                ** This simple OR clause embeds ALL of the fall-forward logic
                ** from COPY_TO_CD to PLAYLIST_BURN.
                ** It is what allows us to support legacy apps using V1->V3 converted licenses.                
                */
                else if( IDENTICAL_GUIDS( f_pdguidAction, &DRM_ACTION_PLAYLIST_BURN )
                      || IDENTICAL_GUIDS( f_pdguidAction, &DRM_ACTION_COPY_TO_CD ) )
                {
                    wRightID = XMR_OBJECT_TYPE_ALLOW_PLAYLISTBURN_POLICY_CONTAINER;
                    
                    /*
                    ** Check for playlist burn rights 
                    */
                    if( XMR_IS_PLAYLISTBURN_VALID( pXMR ) )
                    {
                        if( XMR_IS_PLAYLISTBURN_RESTRICTIONS_VALID( pXMR ) )
                        {
                            /*
                            ** If using the legacy right, only fall-forward to the playlist burn 
                            ** right if MaxPlaylistBurnCount is *not* set.
                            ** If it *is* set, treat the legacy right as if it does not exist.
                            */
                            if( IDENTICAL_GUIDS( f_pdguidAction, &DRM_ACTION_COPY_TO_CD )
                             && pXMR->containerOuter.containerPlaylistBurnPolicies.Restrictions.dwMaxPlaylistBurnCount != XMR_UNLIMITED )
                            {
                                /*
                                ** Right doesn't exist.  Just fail 
                                */
                                goto ErrorExit;
                            }

                            dwTemp = pXMR->containerOuter.containerPlaylistBurnPolicies.Restrictions.dwPlaylistBurnTrackCount;
                            pdstrCountString = &g_dstrPlaylistBurnCount;
                        }


                        /* 
                        ** We will be trampling this, make sure it hasn't already been set 
                        */
                        DRMASSERT( pExtendedRestrictions == NULL );
                        pExtendedRestrictions = pXMR->containerOuter.containerPlaylistBurnPolicies.pUnknownObjects;
                    }                   
                    else
                    {
                        /*
                        ** Right doesn't exist.  Just fail 
                        */
                        goto ErrorExit;
                    }
                }
#endif /* DRM_SUPPORT_PLAYLIST_BURN */
                
                else if( IDENTICAL_GUIDS( f_pdguidAction, &DRM_ACTION_COPY ) )
                {
                    DRM_BOOL fDomainAllowsAction    = FALSE;

                    /*
                    ** Domain only allows Copy To PC and Copy To Device
                    ** If caller didn't ask for a specific Copy right,
                    **  we also allow it here.
                    */
                    DRM_BOOL fDomainCanAllowAction  =
                        ( ( f_pdguidActionQualifier == NULL )
                         || IDENTICAL_GUIDS( f_pdguidActionQualifier, &DRM_ACTION_COPY_TO_PC )
                         || IDENTICAL_GUIDS( f_pdguidActionQualifier, &DRM_ACTION_COPY_TO_DEVICE ) );

                    /*
                    ** If the license is domain bound, then copy is simply allowed
                    ** It is the caller's responsibility to verify that the target
                    **  is joined to the domain, and we hand back the domain
                    **  information to allow them to make that check
                    */
                    if( XMR_IS_DOMAIN_ID_VALID( pXMR ) )
                    {
                        if( fDomainCanAllowAction )
                        {
                            /* 
                            ** Give the license's domain ID back to the caller 
                            */
                            DRM_XMR_DOMAIN_ID *pLicenseDomainId =
                                &pXMR->containerOuter.containerGlobalPolicies.DomainID;

                            fDomainAllowsAction = TRUE;

                            if( pLicenseDomainId->cbAccountID == SIZEOF( DRM_GUID ) )
                            {
                                f_pContextLicEval->fCopyDestDomainAccountIDRequired = TRUE;
                                DRM_BYT_CopyBytes(
                                    &f_pContextLicEval->guidCopyDestDomainAccountIDRequired,
                                    0,
                                    pLicenseDomainId->pbAccountID,
                                    pLicenseDomainId->ibAccountID,
                                    pLicenseDomainId->cbAccountID );
                                f_pContextLicEval->dwCopyDestDomainRevisionRequired = pLicenseDomainId->dwRevision;
                            }
                        }
                    }

                    if( !fDomainAllowsAction )
                    {
                        /* 
                        ** Use the copy right, if present 
                        */

                        wRightID = XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER;

                        /*
                        ** Check for Copy ( to device ) rights 
                        */
                        if( XMR_IS_COPY_VALID( pXMR ) )
                        {
                            /*
                            ** XMR does not have corresponding PM rights. So if copy is allowed in XMR 
                            ** license, we assume it is okay to copy to PDDRM devices:
                            */
                            f_pContextLicEval->lPMRights = XMR_RIGHTS_COPY_FROM_V1;

                            /*
                            ** Check the counts 
                            */
                            if( XMR_IS_COPYCOUNT_VALID( pXMR ) )
                            {
                                dwTemp = pXMR->containerOuter.containerCopyPolicies.CopyCount.dwValue;
                                pdstrCountString = &g_dstrDRM_LS_COPYCOUNT_ATTR;
                            }

                            /* 
                            ** We will be trampling this, make sure it hasn't already been set 
                            */
                            DRMASSERT( pExtendedRestrictions == NULL );
                            pExtendedRestrictions = pXMR->containerOuter.containerCopyPolicies.pUnknownObjects;

                            /* 
                            ** Check if we need to verify the Action Qualifier GUID as well 
                            */
                            if( IDENTICAL_GUIDS( f_pdguidAction, &DRM_ACTION_COPY ) && NULL != f_pdguidActionQualifier )
                            {
                                DRM_BOOL    fFound = FALSE;

                                /* 
                                ** This will check the first container; if not found - will go depth-first into other containers 
                                */
                                ChkDR( DRM_LEVL_SearchQualifierGuidInEnablerContainer(
                                                                f_pdguidActionQualifier,
                                                               &pXMR->containerOuter.containerCopyPolicies.UnknownContainer,
                                                                XMR_OBJECT_TYPE_COPY_ENABLER_CONTAINER,
                                                                XMR_OBJECT_TYPE_COPY_ENABLER_OBJECT,
                                                               &fFound ) );

                                /* 
                                ** Enabler GUID not found in the license? Just fail. 
                                */
                                if ( !fFound )
                                {
                                    goto ErrorExit;
                                }
                            }
                        }
                        else
                        {
                            /*
                            ** Copy right not available.
                            ** If this is a LEAF license, that might be OK
                            **  if (and only if) the root is domain-bound
                            **  AND the domain can allow the copy action.
                            ** See comments regarding this flag in drmliceval.h
                            **  for more information.
                            */
                            if( XMR_IS_UPLINK_KID_VALID( pXMR )
                             && fDomainCanAllowAction )
                            {
                                f_pContextLicEval->fDomainBoundRootRequired = TRUE;
                            }
                            else
                            {
                                /*
                                ** Right doesn't exist.  Just fail.
                                */
                                goto ErrorExit;
                            }
                        }
                    }
                }
#if DRM_SUPPORT_THUMBNAIL                
                else if( IDENTICAL_GUIDS( f_pdguidAction, &DRM_ACTION_CREATE_THUMBNAIL ) )
                {
                    if( XMR_IS_THUMBNAIL_VALID( pXMR ) )
                    {
                        dwTemp           = XMR_UNLIMITED;
                        pdstrCountString = &g_dstrDRM_LS_PLAYCOUNT_ATTR;
                    }
                    else
                    {
                        /* 
                        ** Right doesn't exist.  Just fail 
                        */
                        goto ErrorExit;
                    }
                }
#endif /* DRM_SUPPORT_THUMBNAIL */
                else if( IDENTICAL_GUIDS( f_pdguidAction, &DRM_ACTION_BACKUP_RESTORE ) )
                {
                    /*
                    ** Check for rights 
                    */
                    if( !XMR_IS_RIGHTS_VALID( pXMR )
                     || ( XMR_RIGHTS_ALLOW_BACKUP_RESTORE != ( XMR_RIGHTS_ALLOW_BACKUP_RESTORE & pXMR->containerOuter.containerGlobalPolicies.Rights.wValue ) ) )
                    {
                        goto ErrorExit;
                    }

                    /*
                    **  Always allow Backup/Restore 
                    */
                    fRestricted = FALSE;
                }
                else
                {
                    if( pXMR->containerOuter.containerUnknown.fValid )
                    {
                        /* Check if the Right ID they gave is a 16-bit number; if so, it would be the
                        ** object type of a container that may be an extensible right
                        */
                        if( f_dwRightID > 0 && f_dwRightID <= MAX_UNSIGNED_TYPE( DRM_WORD ) )
                        {
                            DRM_XMR_UNKNOWN_CONTAINER *pUnknownContainer = &pXMR->containerOuter.containerUnknown;
                            
                            /* 
                            ** Seems to be a valid object type 
                            */

                            while( pUnknownContainer != NULL
                                && pUnknownContainer->fValid )
                            {
                                if( pUnknownContainer->wType == f_dwRightID )
                                {
                                    /* 
                                    ** We found a match 
                                    */
                                    DRMASSERT( pExtendedRestrictions == NULL );
                                    pExtendedRight = pUnknownContainer;
                                    pExtendedRestrictions = pExtendedRight->pObject;
                                    break;
                                }

                                pUnknownContainer = pUnknownContainer->pNext;
                            }
                        }

                        wRightID = (DRM_WORD)f_dwRightID;
                    }

                    /* 
                    ** If no extended right was found then we couldn't find it 
                    */
                    if( pExtendedRight == NULL )
                    {
                        if( f_pfActionExisted != NULL )
                        {
                            /*
                            **  Extensible Right was not found.  
                            */
                            f_pContextLicEval->lReasonForFail = LR_LICENSE_EXTENSIBLE_RIGHT_NOT_FOUND;
                            *f_pfActionExisted = FALSE;
                        }
                        dr = DRM_SUCCESS;
                        goto ErrorExit;
                    }
                }

                if ( fRestricted )
                {
                    /*
                    **  Application doesn't have the rights to do this  
                    */
                    f_pContextLicEval->lReasonForFail = LR_LICENSE_RESTRICTED_SOURCE;
                    goto ErrorExit;
                }

                /*
                ** It was a right we understand and it existed.  Check or update counts 
                */
                if( fCondition )
                {
                    if( dwTemp != XMR_UNLIMITED )
                    {
                        dr = _CheckCount( f_pContextLicEval->pcontextSSTLicense,
                                          pdstrCountString );
                        if( dr == DRM_E_LICENSEEXPIRED )
                        {
                              if( XMR_IS_DOMAIN_ID_VALID(pXMR)
                                  && DRM_UTL_DSTRStringsEqual(pdstrCountString, &g_dstrDRM_LS_COPYCOUNT_ATTR ) )
                              {
                                  /* 
                                  ** If we're attempting copy, and we're all out of copy counts,
                                  ** and the license is domain bound, we could avoid using Copy by joining the device to the domain
                                  */
                                  ChkDR(  DRM_E_DEVICE_DOMAIN_JOIN_REQUIRED );
                              }
                              else
                              {

                                  f_pContextLicEval->lReasonForFail = LR_LICENSE_EXPIRED;
                                  dr = DRM_SUCCESS;
                                  goto ErrorExit;
                              }
                        }
                        ChkDR( dr );
                    }

                    if( pExtendedRestrictions != NULL )
                    {
                        DRM_XMR_UNKNOWN_OBJECT *pExtRestrictLoop = pExtendedRestrictions;

                        while( pExtRestrictLoop != NULL
                            && pExtRestrictLoop->fValid )
                        {
                            if( ( pExtRestrictLoop->wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 )
                            {
                                /*
                                ** This is likley an extensible rights container.
                                ** Need to pass it up to the app for them to parse.
                                */

                                dr = DRM_E_EXTENDED_RESTRICTION_NOT_UNDERSTOOD;
                                if( f_pfnPolicyCallback != NULL )
                                {
                                    DRM_EXTENDED_RESTRICTION_CALLBACK_STRUCT oCallback = {0};
                                    
                                    oCallback.wRightID = wRightID;
                                    oCallback.pRestriction = pExtRestrictLoop;
                                    oCallback.pXMRLicense = f_pContextLicEval->plicenseXMR;
                                    oCallback.pContextSST = f_pContextLicEval->pcontextSSTLicense;
                                    
                                    dr = f_pfnPolicyCallback( &oCallback, DRM_EXTENDED_RESTRICTION_CONDITION_CALLBACK, f_pv );
                                }

                                /*
                                ** If either there was no callback specified or if the callback responded
                                ** with DRM_E_EXTENDED_RESTRICTION_NOT_UNDERSTOOD, then the restriction was not processed
                                */
                                if( dr == DRM_E_EXTENDED_RESTRICTION_NOT_UNDERSTOOD || dr == DRM_E_NOTIMPL )
                                {
                                    if( ( pExtRestrictLoop->wFlags & XMR_FLAGS_MUST_UNDERSTAND ) != 0 )
                                    {
                                        TRACE(("Extensible restrction marked as must understand, but couldn't. Callback: 0x%X", f_pfnPolicyCallback ));
                                        ChkDR( DRM_E_EXTENDED_RESTRICTION_NOT_UNDERSTOOD );
                                    }
                                    else
                                    {
                                        /* 
                                        ** Callback didn't understand the restriction, but they didn't have to. 
                                        */
                                        dr = DRM_SUCCESS;
                                    }
                                }
                                else if( dr == DRM_E_LICENSEEXPIRED )
                                {
                                    f_pContextLicEval->lReasonForFail = LR_LICENSE_EXPIRED;
                                }
                                ChkDR( dr );
                                
                            }

                            pExtRestrictLoop = pExtRestrictLoop->pNext;
                        }
                    }
                }
                else
                {
                    if( dwTemp != XMR_UNLIMITED )
                    {
                        ChkDR( _DecrementCount( f_pContextLicEval->pcontextSSTLicense,
                                                pdstrCountString ) );
                    }
                    /*
                    ** Update expire after first use 
                    */
                    if( ( ( pXMR->dwVersion == XMR_VERSION_1 )
                       || IDENTICAL_GUIDS( f_pdguidAction, &DRM_ACTION_PLAY ) )
                     && XMR_IS_EXPIRATION_AFTER_FIRST_USE_VALID( pXMR ) )
                    {
                        ChkDR( DRM_SST_GetTokenValue( f_pContextLicEval->pcontextSSTLicense,
                                                     &g_dstrDRM_LS_FIRSTUSE_ATTR, 
                                                     &token ) );
                        if( dr == DRM_S_FALSE )
                        {
                            ZEROMEM( &token, SIZEOF( token ) );
                            FILETIME_TO_UI64( ftCurrent, token.val.u64DateTime );
                            token.TokenType = TOKEN_DATETIME;
                            ChkDR( DRM_SST_SetTokenValue( f_pContextLicEval->pcontextSSTLicense, 
                                                         &g_dstrDRM_LS_FIRSTUSE_ATTR, 
                                                         &token ) );
                        }
                    }

                    if( pExtendedRestrictions != NULL
                     && f_pfnPolicyCallback != NULL )
                    {
                        DRM_XMR_UNKNOWN_OBJECT *pExtRestrictLoop = pExtendedRestrictions;

                        while( pExtRestrictLoop != NULL
                            && pExtRestrictLoop->fValid )
                        {
                            if( ( pExtRestrictLoop->wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 )
                            {
                                DRM_EXTENDED_RESTRICTION_CALLBACK_STRUCT oCallback = {0};
                                
                                /*
                                ** This is likley an extensible rights container.
                                ** Need to pass it up to the app for them to parse.
                                */
                                oCallback.wRightID = wRightID;
                                oCallback.pRestriction = pExtRestrictLoop;
                                oCallback.pXMRLicense = f_pContextLicEval->plicenseXMR;
                                oCallback.pContextSST = f_pContextLicEval->pcontextSSTLicense;
                                
                                dr = f_pfnPolicyCallback( &oCallback, DRM_EXTENDED_RESTRICTION_ACTION_CALLBACK, f_pv );
                                if( dr == DRM_E_EXTENDED_RESTRICTION_NOT_UNDERSTOOD || dr == DRM_E_NOTIMPL )
                                {
                                    if( ( pExtRestrictLoop->wFlags & XMR_FLAGS_MUST_UNDERSTAND ) != 0 )
                                    {
                                        TRACE(("Extensible restrction marked as must understand, but couldn't. Callback: 0x%X", f_pfnPolicyCallback ));
                                        ChkDR( DRM_E_EXTENDED_RESTRICTION_NOT_UNDERSTOOD );
                                    }
                                    else
                                    {
                                        /* 
                                        ** Callback didn't understand the restriction, but they didn't have to. 
                                        */
                                        ChkDR( DRM_SUCCESS );
                                    }
                                }
                            }
                            pExtRestrictLoop = pExtRestrictLoop->pNext;
                        }
                    }
                }
            }
            break;
        default:
            ChkDR( DRM_E_INVALIDARG );
    }


    if( f_pfPerform != NULL )
    {
        *f_pfPerform = TRUE;
    }

    dr = DRM_SUCCESS;
    
ErrorExit:    
    if ( dr == DRM_S_FALSE )
    {
        dr = DRM_SUCCESS;
    }

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}    
    
/******************************************************************************
**
** Function: DRM_LEVL_PerformOperations
**
** Synopsis: Do an operation on a license
**
** Arguments:  
**      [f_pcontextLicEval] : Specifies the liceval context to use
**      [f_eOperation]      : Specifies the operation to be perfomed
**      [f_eOperationState] : 
**      [f_pdstrAction]     : Specifies action data for DRM_LICENSE_EVAL_ACTION operation
**      [f_pfPerform]       : Returns whether the action has been performed
**      [f_pfActionExisted] : Returns whether the action existed
**      [f_pDatastore]      : Specifies the DST context   
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or improperly initialized
**      LICEVAL_LICENSE_NOT_SUPPLIED
**          The license content string is NULL
**      LICEVAL_INVALID_LICENSE
**          The specified license is invalid
**      LICEVAL_LICENSE_REVOKED
**          The specified license has been revoked
**      LICEVAL_KID_MISMATCH
**          KID mismatch with header
**      DRM_E_CH_UNABLE_TO_VERIFY
**          Unable to verify the signature of the content header
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LEVL_PerformOperations(
    IN OUT   DRM_LICEVAL_CONTEXT          *f_pContextLicEval,
    IN       eDRM_LICEVAL_OPERATIONS       f_eOperation,
    IN       eDRM_LICEVAL_OPERATION_STATE  f_eOperationState,
    IN const DRM_CONST_STRING             *f_pdstrAction,     /* Only required if DRM_LICENSE_EVAL_ACTION is passed as eOperation */
    OUT      DRM_BOOL                     *f_pfPerform,
    OUT      DRM_BOOL                     *f_pfActionExisted,
    IN const DRM_DST                      *f_pDatastore,
    IN       DRMPFNPOLICYCALLBACK          f_pfnPolicyCallback,
    IN const DRM_VOID                     *f_pv )
{
    DRM_RESULT  dr = DRM_SUCCESS;
    DRM_BOOL    fPerformActionEval = FALSE;
    
    ChkArg( f_pContextLicEval != NULL );

    if( DRM_LICENSE_EVAL_ACTION == f_eOperation )
    {
        fPerformActionEval = TRUE;
    }
    
    if( fPerformActionEval )
    {
        ChkArg( f_pdstrAction != NULL );
        
        if( DRM_UTL_DSTRStringsEqual( f_pdstrAction, &g_dstrWMDRM_RIGHT_NONE ) )
        {
            /*
            **  If the action is none, we always want to allow the action as long as
            **  a license exists
            */
            ChkArg( (f_pfPerform != NULL) && (f_pfActionExisted != NULL) );
            *f_pfPerform       = TRUE;
            *f_pfActionExisted = TRUE;
            goto ErrorExit;
        }
    }
    
    if ( f_pContextLicEval->fLicenseIsXMR )
    {
        DRM_GUID        dguidAction = EMPTY_DRM_GUID;
        DRM_DWORD       dwRightID = 0;

        if ( fPerformActionEval )
        {
            /* 
            ** Convert Action string to Action GUID, using lookup table; 
            ** extract Right ID from Action string if there is one
            */
            ChkDR( _ConvertActionStringToActionGUIDAndRightID( f_pdstrAction, &dguidAction, &dwRightID ) );
        }
        
        ChkDR( DRM_LEVL_PerformOperationsXMR( f_pContextLicEval, 
                                      f_eOperation, 
                                      f_eOperationState,
                                      fPerformActionEval ? &dguidAction : NULL,
                                      NULL,         /* f_pdguidActionQualifier */
                                      dwRightID,
                                      f_pfPerform,
                                      f_pfActionExisted,
                                      f_pDatastore,
                                      f_pfnPolicyCallback,
                                      f_pv ) );
    }
    else
    {
        ChkDR( _PerformOperationsXML( f_pContextLicEval, 
                                      f_eOperation, 
                                      f_eOperationState,
                                      f_pdstrAction,
                                      f_pfPerform,
                                      f_pfActionExisted,
                                      f_pDatastore ) );
    }
                                         
ErrorExit:
    return dr;                                  
}

/******************************************************************************
**
** Function: DRM_LEVL_IsLicenseReadyForDeletion
**
** Synopsis: Checks if this license has expired and is ready to be deleted
**
** Arguments:  
**      [f_pcontextLicEval] : Specifies the liceval context to check
**      [f_pfDelete]        : Returns whether or not the license can be deleted
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or improperly initialized
**
** Notes:
**      For now this function is mostly a CUT&PASTE
**      job from DRM_LEVL_PerformOperations, with a lot of 
**      duplicate code. The common sections should be factored
**      out into a separate subroutine
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LEVL_IsLicenseReadyForDeletion( 
    IN OUT DRM_LICEVAL_CONTEXT *f_pContextLicEval,
    OUT    DRM_BOOL            *f_pfDelete )
{
    DRM_RESULT        dr         = DRM_SUCCESS;
    DRM_BOOL          fResult    = FALSE;

    /*
    ** The other pointers in the context structure *may* not be
    ** needed so don't fail just yet for those 
    */
    ChkArg( f_pContextLicEval              != NULL );
    ChkArg( f_pfDelete                     != NULL );
    ChkArg( f_pContextLicEval->pcontextBBX != NULL );

    /*
    **  Clear output 
    */
    *f_pfDelete = FALSE;
    f_pContextLicEval->fDeleteLicense = FALSE;

#if DRM_SUPPORT_PMLICENSE
    f_pContextLicEval->pwszPMLicVersion = &g_dstrPMLicenseVersionString;
#else
    f_pContextLicEval->pwszPMLicVersion = NULL;
#endif

    MEMCPY( &f_pContextLicEval->contextEXPR.KID, 
            &f_pContextLicEval->KID, 
             SIZEOF( DRM_KID ) );
    MEMCPY( &f_pContextLicEval->contextEXPR.LID, 
            &f_pContextLicEval->LID, 
             SIZEOF( DRM_LID ) ); 
    
    /*
    ** Is license selectable   
    */
    ChkDR( DRM_LEVL_PerformOperations( f_pContextLicEval, 
                                       DRM_LICENSE_EVAL_SELECT, 
                                       DRM_LICENSE_EVAL_CAN_DO_OPERATION, 
                                       NULL, 
                                      &fResult, 
                                       NULL, 
                                       f_pContextLicEval->pDatastore,
                                       NULL,
                                       NULL ) );
    if( !fResult )
    {
        /*
        **  We need to make sure that the reason for failure is set correctly.
        **  This is a workaround to compensate for the fact that v9
        **  licenses do not set the reason correctly sometimes.
        */
        if( f_pContextLicEval->lReasonForFail == 0 )
        {
            /* No reason given by license. Try parsing to get the reason, if we can. */
            (void) DRM_LEVL_GetLicenseReasonForUnusable( f_pContextLicEval,
                                                        &f_pContextLicEval->lReasonForFail );
        }
        /*
        ** If the reason for license not usable is because license expired, then
        ** set *pfDelete
        */
        if( f_pContextLicEval->lReasonForFail == LR_LICENSE_EXPIRED
         || f_pContextLicEval->fDeleteLicense )
        {
            /* 
            ** License cannot be selected because it is expired 
            */
            *f_pfDelete = TRUE;
            goto ErrorExit;
        }
    }

    if ( f_pContextLicEval->fLicenseIsXMR )
    {
        DRM_DWORD i = 0;
        const DRM_CONST_STRING *rgpdstrKnownRights[] = {
                                        &g_dstrWMDRM_RIGHT_PLAYBACK,
                                        &g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY,
#if DRM_SUPPORT_PLAYLIST_BURN
                                        &g_dstrWMDRM_RIGHT_PLAYLIST_BURN,
#endif
                                        &g_dstrWMDRM_RIGHT_COPY };
        
        if( f_pContextLicEval->plicenseXMR->containerOuter.containerUnknown.fValid )
        {
            /* 
            ** There is at least one extensible right in the license, so we can't safely delete it 
            */
            goto ErrorExit;
        }
        
        for( i = 0; i < NO_OF( rgpdstrKnownRights );i++ )
        {
            ChkDR( DRM_LEVL_PerformOperations( f_pContextLicEval, 
                                               DRM_LICENSE_EVAL_ACTION, 
                                               DRM_LICENSE_EVAL_CAN_DO_OPERATION, 
                                               rgpdstrKnownRights[i], 
                                              &fResult, 
                                               NULL, 
                                               f_pContextLicEval->pDatastore,
                                               NULL,
                                               NULL ) );

            if( fResult
             || ( f_pContextLicEval->lReasonForFail != LR_LICENSE_EXPIRED && !f_pContextLicEval->fDeleteLicense ) )
            {
                /* 
                ** At least one right isn't expired, so can't delete the license 
                */
                goto ErrorExit;
            }
        }

        /* 
        ** No non-expired rights exist in the license, so it's safe to delete it 
        */
        *f_pfDelete = TRUE;
    }

ErrorExit:
    return dr;
}

#if DRM_SUPPORT_CONTENT_REVOCATION

/******************************************************************************
**
** Function: _GetContentRevocationInStore
**
** Synopsis: Get the content revocation data from the data store
**
** Arguments:  
**      [f_pcontextLicEval]        : Specifies the liceval context to check
**      [f_pdstrContentOwnerPubKey]: Specifies the public key of the content owner
**      [f_pdstrContentRevocation] : Returns the content revocation data
**      [f_pDatastore]             : Specifies the DST context
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or f_pdstrContentOwnerPubKey is 
**          an invalid string
**
******************************************************************************/
static DRM_RESULT DRM_CALL _GetContentRevocationInStore(
    IN  const DRM_LICEVAL_CONTEXT *f_pcontextLicEval,
    IN  const DRM_CONST_STRING    *f_pdstrContentOwnerPubKey,
    OUT       DRM_CONST_STRING    *f_pdstrContentRevocation,
    IN  const DRM_DST             *f_pDatastore )
{
    DRM_RESULT       dr         = DRM_SUCCESS;
    DRM_DWORD        cbBuffer   = 0;
    DRM_LID          lid        = { 0 };
    DRM_SHA_CONTEXT  contextSHA = DRM_SHA_CONTEXT_DEFAULT;
    DRM_BYTE         rgbPassword[__CB_DECL( DRM_SHA1_DIGEST_LEN )] = { 0 };

    ChkArg( f_pcontextLicEval        != NULL );
    ChkArg( f_pDatastore             != NULL );
    ChkArg( f_pdstrContentRevocation != NULL );

    ChkDRMString( f_pdstrContentOwnerPubKey );
    
    ChkDR( DRM_SHA_Init( &contextSHA, eDRM_SHA_1 ) );
    ChkDR( DRM_SHA_Update( PB_DSTR ( f_pdstrContentOwnerPubKey ), 
                           CB_DSTR ( f_pdstrContentOwnerPubKey ), 
                          &contextSHA ) );
                          
    ChkDR( DRM_SHA_Finalize( &contextSHA, DRM_SHA1_DIGEST_LEN, rgbPassword ) );

    MEMCPY( lid.rgb, rgbPassword, SIZEOF( lid.rgb ) );

    ChkDR( DRM_SST_CreateLicenseStatePassword( &lid, 
                                                rgbPassword, 
                                                f_pcontextLicEval->pcontextBBX ) );

    cbBuffer = f_pcontextLicEval->cbRevocationBuffer;

    ChkDR( DRM_SST_GetData( f_pcontextLicEval->pcontextSSTRevocation, 
                           &lid, 
                            NULL,
                            rgbPassword,
                            SECURE_STORE_REVOCATION_DATA,
                            ( DRM_DST * )f_pDatastore, 
                            f_pcontextLicEval->pbRevocationBuffer, 
                           &cbBuffer ) );

    DSTR_FROM_PB( f_pdstrContentRevocation, f_pcontextLicEval->pbRevocationBuffer, cbBuffer );

ErrorExit:
    return( dr );
}

/******************************************************************************
**
** Function: _SetContentRevocationInStore
**
** Synopsis: Set the content revocation data in the data store
**
** Arguments:  
**      [f_pcontextLicEval]        : Specifies the liceval context to check
**      [f_pdstrContentOwnerPubKey]: Specifies the public key of the content owner
**      [f_pdstrContentRevocation] : Specifies the content revocation data
**      [f_pDatastore]             : Specifies the DST context
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or an invalid DRM string
**      LICEVAL_UPDATE_FAILURE
**          Unable to update the license eval context for revocation
**
******************************************************************************/
static DRM_RESULT DRM_CALL _SetContentRevocationInStore(
    IN  const DRM_LICEVAL_CONTEXT *f_pcontextLicEval,
    IN  const DRM_CONST_STRING    *f_pdstrContentOwnerPubKey, 
    IN  const DRM_CONST_STRING    *f_pdstrContentRevocation,
    IN OUT    DRM_DST             *f_pDatastore )
{
    DRM_RESULT       dr         = DRM_SUCCESS;    
    DRM_LID          lid        = { 0 };
    DRM_SHA_CONTEXT  contextSHA = DRM_SHA_CONTEXT_DEFAULT;
    DRM_BYTE         rgbPassword [__CB_DECL( DRM_SHA1_DIGEST_LEN )] = { 0 };
            
    ChkArg( f_pcontextLicEval != NULL );
    ChkArg( f_pDatastore      != NULL );
    
    ChkDRMString( f_pdstrContentOwnerPubKey );
    ChkDRMString( f_pdstrContentRevocation );
   
    ChkDR( DRM_SHA_Init( &contextSHA, eDRM_SHA_1 ) );
    ChkDR( DRM_SHA_Update( PB_DSTR ( f_pdstrContentOwnerPubKey ), 
                           CB_DSTR ( f_pdstrContentOwnerPubKey ), 
                          &contextSHA ) );
                          
    ChkDR( DRM_SHA_Finalize( &contextSHA,  DRM_SHA1_DIGEST_LEN, rgbPassword ) );

    MEMCPY( lid.rgb, rgbPassword, SIZEOF( lid.rgb ) );

    ChkDR( DRM_SST_CreateLicenseStatePassword( &lid, 
                                                rgbPassword, 
                                                f_pcontextLicEval->pcontextBBX ) );
    ChkDR( DRM_SST_SetData( f_pcontextLicEval->pcontextSSTRevocation, 
                           &lid, 
                            NULL,
                            rgbPassword,
                            SECURE_STORE_REVOCATION_DATA,
                            f_pDatastore, 
                            PB_DSTR( f_pdstrContentRevocation ),
                            CB_DSTR( f_pdstrContentRevocation ) ) );
    
ErrorExit:
    if ( DRM_FAILED( dr ) )
    {
        dr = DRM_E_LICEVAL_UPDATE_FAILURE;
    }
    return dr;
}

/******************************************************************************
**
** Function: _SetOrUpdateContentRevocation
**
** Synopsis: 
**
** Arguments:  
**      [f_pcontextLicEval] : Specifies the liceval context to check
**      [f_pDatastore]      : Specifies the DST context
**
** Returns :
**      DRM_SUCCESS
**          Success
**      LICEVAL_UPDATE_FAILURE
**          Unable to update the license eval context for revocation
**
******************************************************************************/
static DRM_RESULT DRM_CALL _SetOrUpdateContentRevocation( 
          DRM_LICEVAL_CONTEXT *f_pContextLicEval,
    const DRM_DST             *f_pDatastore )
{
    DRM_RESULT       dr                            = DRM_SUCCESS;
    DRM_CONST_STRING dstrContentRev                = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrContentOwnerPubkey        = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrSecStateContentRevocation = EMPTY_DRM_STRING;
    DRM_DWORD        dwLicSequenceNumber           = 0;
    DRM_DWORD        dwSecStateSequenceNumber      = 0;
    DRM_DWORD        dwIndex                       = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMLICEVAL, PERF_FUNC__SetOrUpdateContentRevocation );

    /*
    ** Retrieve content revocation from the license one by one and process. 
    */
    while( DRM_SUCCESS == dr )
    {        
        dr = DRM_LIC_GetContentRevocation( &( f_pContextLicEval->dstrContentLicense ),
                                              dwIndex,
                                             &dwLicSequenceNumber,
                                             &dstrContentRev,
                                             &dstrContentOwnerPubkey,
                                              NULL,
                                             &f_pContextLicEval->pcontextBBX->CryptoContext );
        if( DRM_SUCCESS == dr )
        {
            if( DRM_SUCCESS != _GetContentRevocationInStore( f_pContextLicEval, &dstrContentOwnerPubkey, &dstrSecStateContentRevocation, f_pDatastore )
             || DRM_SUCCESS != DRM_LIC_VerifyContentRevocation( &dstrSecStateContentRevocation, 
                                                                 NULL, 
                                                                &dwSecStateSequenceNumber, 
                                                                 NULL, 
                                                                 NULL, 
                                                                &f_pContextLicEval->pcontextBBX->CryptoContext )
             || dwSecStateSequenceNumber < dwLicSequenceNumber )
            {
                /*
                ** The one in secure state seems older. Write the new one 
                */
                ChkDR( _SetContentRevocationInStore( f_pContextLicEval, 
                                                    &dstrContentOwnerPubkey, 
                                                    &dstrContentRev, 
                                          (DRM_DST*)f_pDatastore ) );
            }
        }
        dwIndex++;
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/******************************************************************************
**
** Function: _IsLicenseRevoked
**
** Synopsis: Check whether a license is revoked.
**
** Arguments:  
**      [f_pcontextLicEval] : Specifies the liceval context to check
**      [f_pDatastore]      : Specifies the DST context
**
** Returns :
**      TRUE
**          The license is revoked
**      FALSE
**          The license is not revoked
**
******************************************************************************/
static DRM_BOOL DRM_CALL _IsLicenseRevoked(
    IN const DRM_LICEVAL_CONTEXT *f_pContextLicEval,
    IN const DRM_DST             *f_pDatastore )
{
    DRM_RESULT       dr                             = DRM_SUCCESS;    
    DRM_CONST_STRING dstrContentPubKey              = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrSecStateContentRevocation  = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrCondition                  = EMPTY_DRM_STRING;
    DRM_BOOL         fResult                        = FALSE;    
    
    /*
    ** Check if the license has public key. If not, it cannot be revoked. 
    */
    ChkDR( DRM_LIC_GetAttribute( &( f_pContextLicEval->dstrContentLicense ), 
                                  NULL, 
                                  DRM_LICENSE_ATTRIB_CONTENTPUBKEY,
                                  NULL,
                                 &dstrContentPubKey, 
                                  0 ) ); /* optional. Don't check for errors. */
                                  
    if ( dstrContentPubKey.pwszString != NULL )
    {
        /*
        ** License contains content owner public key. Retrieve content revocation section 
        ** for this public key, if any. 
        */
        ChkDR( _GetContentRevocationInStore( f_pContextLicEval, 
                                           &dstrContentPubKey, 
                                           &dstrSecStateContentRevocation, 
                                            f_pDatastore ) );

        ChkDR( DRM_LIC_VerifyContentRevocation( &dstrSecStateContentRevocation, 
                                                 NULL, 
                                                 NULL, 
                                                 NULL, 
                                                &dstrCondition, 
                                                &f_pContextLicEval->pcontextBBX->CryptoContext ) );

        /* 
        ** Evaluate the condition to determine if it allows the use of license. 
        */
        
        /* 
        ** missing condition is treated as the one that allows use of license. 
        */
        if ( dstrCondition.pwszString != NULL && dstrCondition.cchString != 0 )
        {

            /* 
            ** DRM_LEVL_EvaluateExpression will return FALSE if the expression evaluates 
            ** correctly and the license is revoked. So we can set fResult to TRUE intially
            ** and then invert it ( if fResult is TRUE on the way out of 
            ** DRM_LEVL_EvaluateExpression then the license IS NOT revoked.  
            ** If it is false then the license IS revoked
            */
            fResult = TRUE;
            ChkDR( DRM_LEVL_EvaluateExpression( (DRM_LICEVAL_CONTEXT*)f_pContextLicEval, &dstrCondition, &fResult ) );
            fResult = !fResult;
        }
    }

ErrorExit:
    return fResult;
}

#endif

/******************************************************************************
**
** Function: DRM_LEVL_GetLicenseReasonForUnusable
**
** Synopsis: Parse the license again to get the reason for failure.
**
** Arguments:  
**      [f_pcontextLicEval]     : Specifies the liceval context
**      [f_plReasonForUnusable] : Returns the reason for failure
**
** Returns :
**      DRM_SUCCESS
**          Succeeded
**      DRM_E_INVALIDARG
**          One of the parameters is NULL
**
** Notes:
**      This is a workaround to compensate for the fact that v9
**      licenses do not always set the failure reason correctly
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_LEVL_GetLicenseReasonForUnusable(
    IN  const DRM_LICEVAL_CONTEXT   *f_pcontextLicEval,
    OUT       DRM_LONG              *f_plReasonForUnusable )
{
    DRM_RESULT  dr       = DRM_SUCCESS;
    DRM_DWORD   dwAppSec = 0;
    DRMFILETIME fileTime = {0};
    DRMFILETIME currDate = {0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMLICEVAL, 
                               PERF_FUNC_DRM_LEVL_GetLicenseReasonForUnusable );

    ChkArg( f_pcontextLicEval     != NULL );
    ChkArg( f_plReasonForUnusable != NULL );

    *f_plReasonForUnusable = 0;

    Oem_Clock_GetSystemTimeAsFileTime( f_pcontextLicEval->pcontextBBX->pOEMContext, &currDate );

    dr = DRM_ASD_ParseV2License( &f_pcontextLicEval->dstrContentLicense,
                                 &g_dstrDRM_LS_BEGDATE_ATTR,
                                  NULL,
                                 &fileTime );

    if ( dr == DRM_SUCCESS
      && DRM_UTL_DateLessThan( &currDate, &fileTime ) )
    {
        *f_plReasonForUnusable = LR_LICENSE_NOTENABLED;
    }
    else
    {
        dr = DRM_ASD_ParseV2License( &f_pcontextLicEval->dstrContentLicense,
                                     &g_dstrDRM_LS_ENDDATE_ATTR,
                                      NULL,
                                     &fileTime );

        if ( dr == DRM_SUCCESS
          && DRM_UTL_DateLessThan( &fileTime, &currDate ) )
        {
            *f_plReasonForUnusable = LR_LICENSE_EXPIRED;
        }
        else
        {
            dr = DRM_ASD_ParseV2License( &f_pcontextLicEval->dstrContentLicense,
                                         &g_dstrDRM_LS_APPSEC_ATTR,
                                         &dwAppSec,
                                          NULL );
            if ( dr == DRM_SUCCESS
              && ( ( f_pcontextLicEval->fLegacyAppInfoValid 
                  && f_pcontextLicEval->certinfoAppLegacy.appSec < dwAppSec )
                 || f_pcontextLicEval->certinfoSDK.appSec < dwAppSec ) )
            {
                *f_plReasonForUnusable = LR_LICENSE_APPSECLOW;
            }
        }
    }

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmorderedlist.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcrt.h>
#include <drmorderedlist.h>

ENTER_PK_NAMESPACE_CODE;

DRM_RESULT DRM_CALL DRM_OrderedList_Initialize(
    __out      ORDERED_LIST            *pOrderedList,
    __in const DRM_DWORD                dwSize
)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( pOrderedList );

    pOrderedList->dwCurrentSize = 0;
    pOrderedList->dwMaxSize     = dwSize;
    pOrderedList->pHead         = NULL;

 ErrorExit:
    return dr;
}



DRM_VOID DRM_CALL DRM_OrderedList_Uninitialize(
    __out ORDERED_LIST * const pOrderedList
)
{
    if ( NULL != pOrderedList )
    {
        ORDERED_LIST_ENTRY *pEntry;
        for( pEntry = pOrderedList->pHead; NULL != pEntry; )
        {
            ORDERED_LIST_ENTRY *pFreeMe = pEntry;
            pEntry = pEntry->pNext;
            SAFE_OEM_FREE(pFreeMe);
        }

        ZEROMEM(pOrderedList, SIZEOF(ORDERED_LIST));
    }

    return;
}



DRM_RESULT DRM_CALL DRM_OrderedList_GetCount(
    __in const ORDERED_LIST * const pOrderedList,
    __out      DRM_DWORD    * const pdwCount
)
{
    DRM_RESULT dr = DRM_SUCCESS;


    ChkArg( NULL != pOrderedList );
    ChkArg( NULL != pdwCount );

    *pdwCount = pOrderedList->dwCurrentSize;

 ErrorExit:
    return dr;
}



DRM_RESULT DRM_CALL DRM_OrderedList_AddEntry(
    __inout    ORDERED_LIST * const pOrderedList,
    __in const DRM_UINT64           qwValue,
    __in       DRM_VOID     * const pbData
)
{
    DRM_RESULT dr = DRM_SUCCESS;
    ORDERED_LIST_ENTRY *pNew = NULL;

    
    ChkArg( NULL != pOrderedList );

    ChkBOOL( pOrderedList->dwCurrentSize < pOrderedList->dwMaxSize, DRM_E_FAIL);

    ChkMem( pNew = (ORDERED_LIST_ENTRY *) Oem_MemAlloc(SIZEOF(ORDERED_LIST_ENTRY)) );
    
    pNew->qwValue = qwValue;
    pNew->pbData  = pbData;
    pNew->pNext   = NULL;

    if ( NULL == pOrderedList->pHead )
    {
        pOrderedList->pHead = pNew;
    }
    else
    {
        ORDERED_LIST_ENTRY *pEntry;
        ORDERED_LIST_ENTRY *pPrevious = NULL;

        for( pEntry = pOrderedList->pHead; NULL != pEntry; pEntry = pEntry->pNext )
        {
            if ( DRM_UI64Les(qwValue, pEntry->qwValue) )
            {
                break;
            }
            pPrevious = pEntry;
        }
        
        if ( NULL == pPrevious )
        {
            pNew->pNext = pEntry;
            pOrderedList->pHead = pNew;
        }
        else
        {
            pNew->pNext = pEntry;
            pPrevious->pNext = pNew;
        }
    }
    
    pOrderedList->dwCurrentSize++;

 ErrorExit:
    if ( DRM_FAILED(dr) )
    {
        SAFE_OEM_FREE(pNew);
    }

    return dr;
}



DRM_RESULT DRM_CALL DRM_OrderedList_RemoveEntry(
    __inout    ORDERED_LIST  * const pOrderedList,
    __in const DRM_DWORD             dwFirstEntryToConsider,
    __out      DRM_UINT64    * const pqwValue,
    __out      DRM_VOID            **ppbData
)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  i = 0;
    ORDERED_LIST_ENTRY *pEntry;
    ORDERED_LIST_ENTRY *pPrevious = NULL;

    
    ChkArg( NULL != pOrderedList );
    ChkArg( NULL != ppbData );
    ChkArg( NULL != pqwValue );
    ChkBOOL(dwFirstEntryToConsider < pOrderedList->dwCurrentSize, DRM_E_FAIL);

    pEntry = pOrderedList->pHead;
    for ( i = 0; i < dwFirstEntryToConsider && NULL != pEntry; i++ )
    {
        pPrevious = pEntry;
        pEntry = pEntry->pNext;
    }

    if ( NULL == pEntry )
    {
        ChkDR( DRM_E_FAIL );
    }
    else
    {
        *ppbData = pEntry->pbData;
        *pqwValue = pEntry->qwValue;
        pOrderedList->dwCurrentSize--;

        if ( NULL == pPrevious )
        {
            ORDERED_LIST_ENTRY *pFreeMe = pOrderedList->pHead;
            pOrderedList->pHead = pOrderedList->pHead->pNext;
            SAFE_OEM_FREE( pFreeMe );
        }
        else
        {
            ORDERED_LIST_ENTRY *pFreeMe = pEntry;
            pPrevious->pNext = pEntry->pNext;
            SAFE_OEM_FREE( pFreeMe );
        }
    }

 ErrorExit:
    return dr;
}



DRM_RESULT DRM_CALL DRM_OrderedList_AddLeadingEntry(
    __inout    ORDERED_LIST  * const pOrderedList,
    __in const DRM_UINT64            qwValue,
    __in       DRM_VOID      * const pbData
)
{
    DRM_RESULT dr = DRM_SUCCESS;
    ORDERED_LIST_ENTRY *pNew = NULL;

    
    ChkArg( NULL != pOrderedList);
    ChkBOOL( pOrderedList->dwCurrentSize < pOrderedList->dwMaxSize, DRM_E_FAIL);

    pNew = (ORDERED_LIST_ENTRY *) Oem_MemAlloc(SIZEOF(ORDERED_LIST_ENTRY));
    ChkMem(pNew);
    pNew->qwValue = qwValue;
    pNew->pbData  = pbData;
    pNew->pNext   = NULL;

    if ( NULL == pOrderedList->pHead )
    {
        pOrderedList->pHead = pNew;
    }
    else
    {
        ORDERED_LIST_ENTRY *pEntry;
        ORDERED_LIST_ENTRY *pPrevious = NULL;

        for( pEntry = pOrderedList->pHead; NULL != pEntry; pEntry = pEntry->pNext )
        {
            if ( DRM_UI64Les(qwValue, pEntry->qwValue) 
                 || DRM_UI64Eql(qwValue, pEntry->qwValue) )
            {
                break;
            }
            pPrevious = pEntry;
        }
        
        if ( NULL == pPrevious )
        {
            pNew->pNext = pEntry;
            pOrderedList->pHead = pNew;
        }
        else
        {
            pNew->pNext = pEntry;
            pPrevious->pNext = pNew;
        }
    }
    
    pOrderedList->dwCurrentSize++;

 ErrorExit:
    if ( DRM_FAILED(dr) )
    {
        SAFE_OEM_FREE(pNew);
    }

    return dr;
}



DRM_RESULT DRM_CALL DRM_OrderedList_GetEntry(
    __in const ORDERED_LIST  * const pOrderedList,
    __in const DRM_DWORD             dwFirstEntryToConsider,
    __out      DRM_UINT64    * const pqwValue,
    __out      DRM_VOID            **ppbData
)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD i;
    ORDERED_LIST_ENTRY *pEntry;


    ChkArg( NULL != pOrderedList );
    ChkArg( NULL != ppbData );
    ChkArg( NULL != pqwValue );
    ChkBOOL(dwFirstEntryToConsider < pOrderedList->dwCurrentSize, DRM_E_FAIL);

    pEntry = pOrderedList->pHead;
    for ( i = 0; i < dwFirstEntryToConsider && NULL != pEntry; i++ )
    {
        pEntry = pEntry->pNext;
    }

    if ( NULL != pEntry )
    {
        *pqwValue = pEntry->qwValue;
        *ppbData = pEntry->pbData;
    }
    else
    {
        ChkDR( DRM_E_FAIL );
    }

 ErrorExit:
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmpkcrypto.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmpkcrypto.h>
#include <drmeccp160.h>
#include <drmeccp256.h>
#include <oemrsa.h>
#include <drmrsa.h>

ENTER_PK_NAMESPACE_CODE;


/*********************************************************************
**
**  Function:  DRM_PK_GenKeyPair
**
**  Synopsis:  Generate a matched public and private key pair for the given algorithm
**
**  Arguments:  
**     [f_pContext]      : Pointer to pk crypto context. Not required ECC 256
**     [f_eAlgorithm]    : Enumeration specifying algorithm to generate keys for
**     [f_eRSAKeyLength] : Length of RSA key in bits. Required for RSA algorithm only.
**     [f_cbPublicKey]   : Specifies the length of the public key buffer. 
**                         Returns the length of the generated public key. 
**     [f_pbPublicKey]   : Returns the generated public key 
**     [f_cbPrivateKey]  : Specifies the length of the private key buffer. 
**                         Returns the length of the generated private key. 
**     [f_pbPrivateKey]  : Returns the generated private key
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument was NULL or improperly initialized
**      DRM_E_BUFFERTOOSMALL
**          One of the key buffers was too small for the specified algorithm
**      DRM_E_UNSUPPORTEDALGORITHM
**          f_eAlgorithm specifies an invalid or not supported algorithm
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_PK_GenKeyPair( 
    __in_opt                        DRM_VOID                              *f_pContext,
    __in                            DRM_PKCRYPTO_SUPPORTED_ALGORITHMS      f_eAlgorithm,
    __in                            DRM_RSA_SUPPORTED_KEY_LENGTHS          f_eRSAKeyLength,
    __inout_ecount( 1 )             DRM_DWORD                             *f_pcbPublicKey,
    __out_bcount( *f_pcbPublicKey ) DRM_BYTE                              *f_pbPublicKey,
    __inout_ecount( 1 )             DRM_DWORD                             *f_pcbPrivateKey,
    __out_bcount( *f_pcbPrivateKey )DRM_BYTE                              *f_pbPrivateKey )
{
    DRM_RESULT dr = DRM_SUCCESS;       
           
    ChkArg( f_pcbPublicKey  != NULL );
    ChkArg( f_pbPublicKey   != NULL );
    ChkArg( f_pcbPrivateKey != NULL );       
    ChkArg( f_pbPrivateKey  != NULL );       
    
    switch ( f_eAlgorithm )
    {
    case eDRM_ECC_P160:
        ChkBOOL( *f_pcbPublicKey  >= DRM_ECC160_PUBLIC_KEY_LEN 
              && *f_pcbPrivateKey >= DRM_ECC160_PRIVATE_KEY_LEN, 
                 DRM_E_BUFFERTOOSMALL );               
        ChkDR( DRM_ECC_GenKeyPair_P160( f_pContext, ( PUBKEY * )f_pbPublicKey, ( PRIVKEY * )f_pbPrivateKey ) );
        *f_pcbPublicKey  = DRM_ECC160_PUBLIC_KEY_LEN;
        *f_pcbPrivateKey = DRM_ECC160_PRIVATE_KEY_LEN;
        break;
    case eDRM_ECC_P256:
        ChkBOOL( *f_pcbPublicKey  >= ECC_P256_POINT_SIZE_IN_BYTES 
              && *f_pcbPrivateKey >= ECC_P256_INTEGER_SIZE_IN_BYTES, 
                 DRM_E_BUFFERTOOSMALL );               
        /*
        ** Always generate ECC-p256 encryptable keys: the 'restricted' set
        */               
        ChkDR( DRM_ECC_GenKeyPairRestrictedPriv_P256( ( PUBKEY_P256 * )f_pbPublicKey, 
                                                      ( PRIVKEY_P256 * )f_pbPrivateKey, (struct bigctx_t *)f_pContext ) );
        *f_pcbPublicKey  = ECC_P256_POINT_SIZE_IN_BYTES;
        *f_pcbPrivateKey = ECC_P256_INTEGER_SIZE_IN_BYTES;
        break;        
    case eDRM_RSA:

		ChkArg( f_pContext != NULL );
        ChkArg( f_eRSAKeyLength == eDRM_RSA_1024 || f_eRSAKeyLength == eDRM_RSA_2048 );
        ChkBOOL( *f_pcbPublicKey  >= DRM_RSA_CB_PUBKEY , DRM_E_BUFFERTOOSMALL );
        ChkBOOL( *f_pcbPrivateKey >= DRM_RSA_CB_PRIVKEY, DRM_E_BUFFERTOOSMALL );               
        ChkDR( OEM_RSA_GenerateKeyPair(  f_eRSAKeyLength, 
			                            ( DRM_RSA_PRIVATE_KEY * )f_pbPrivateKey, 
			                            ( DRM_RSA_PUBLIC_KEY * )f_pbPublicKey, 
			                            ( DRM_CRYPTO_CONTEXT * )f_pContext ) );
        *f_pcbPublicKey  = DRM_RSA_CB_PUBKEY;
        *f_pcbPrivateKey = DRM_RSA_CB_PRIVKEY;
        break;        
    default:
        ChkDR( DRM_E_UNSUPPORTEDALGORITHM );    
    }
    
ErrorExit:       
   
    return dr;    
}


/*********************************************************************
**
**  Function:  DRM_PK_Encrypt
**
**  Synopsis:  Encrypt a block of data with a given public key, using the
**             specified algorithm.
**
**  Arguments:  
**     [f_pOEMContext]   : Pointer to OEM-specific context (optional)
**     [f_pContext]      : Pointer to pk crypto context. Not required for ECC 256
**     [f_eAlgorithm]    : Enumeration specifying algorithm to use for encryption
**     [f_cbPublicKey]   : Byte count of the public key
**     [f_pbPublicKey]   : Specifies the public key to use
**     [f_cbPlainText]   : Byte count of the plaintext buffer
**     [f_pbPlainText]   : Specifies the plaintext buffer
**     [f_pcbCipherText] : Byte count of the ciphertext buffer. Returns the length of the
**                         actual ciphertext.
**     [f_pbCipherText]  : Specifies the ciphertext buffer
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument was NULL or improperly initialized
**      DRM_E_BUFFERTOOSMALL
**          One of the buffers was too small for the specified algorithm
**      DRM_E_UNSUPPORTEDALGORITHM
**          f_eAlgorithm specifies an invalid or not supported algorithm
**
**  Notes:  Data is not encrypted in place.
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_PK_Encrypt( 
    __in_opt                           DRM_VOID                           *f_pOEMContext,
    __in_opt                           DRM_VOID                           *f_pContext,
    __in                               DRM_PKCRYPTO_SUPPORTED_ALGORITHMS   f_eAlgorithm,
    __in                               DRM_DWORD                           f_cbPublicKey,
    __in_bcount( f_cbPublicKey ) const DRM_BYTE                           *f_pbPublicKey,
    __in                               DRM_DWORD                           f_cbPlainText,
    __in_bcount( f_cbPlainText ) const DRM_BYTE                           *f_pbPlainText,
    __inout_ecount( 1 )                DRM_DWORD                          *f_pcbCipherText,
    __out_bcount( *f_pcbCipherText )   DRM_BYTE                           *f_pbCipherText )
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg( f_pbPublicKey   != NULL );
    ChkArg( f_pbPlainText   != NULL );
    ChkArg( f_pcbCipherText != NULL );
    ChkArg( f_pbCipherText  != NULL );  
    
    switch ( f_eAlgorithm )
    {
    case eDRM_ECC_P160:
        ChkArg( f_cbPublicKey  == DRM_ECC160_PUBLIC_KEY_LEN );  
                     
        ChkBOOL( *f_pcbCipherText >= DRM_ECC160_CIPHERTEXT_LEN, DRM_E_BUFFERTOOSMALL );
        ChkBOOL(  f_cbPlainText   >= DRM_ECC160_PLAINTEXT_LEN, DRM_E_BUFFERTOOSMALL );
        
        ChkDR( DRM_ECC_Encrypt_P160( f_pContext, 
                                     ( const PUBKEY * )f_pbPublicKey, 
                                     f_pbPlainText,
                                     f_pbCipherText ) );
                
        *f_pcbCipherText = DRM_ECC160_CIPHERTEXT_LEN; 
        break;
    case eDRM_ECC_P256:
        ChkArg( f_cbPublicKey == ECC_P256_POINT_SIZE_IN_BYTES )
        
        ChkBOOL( *f_pcbCipherText >= ECC_P256_CIPHERTEXT_SIZE_IN_BYTES, DRM_E_BUFFERTOOSMALL );
        ChkBOOL(  f_cbPlainText   >= ECC_P256_PLAINTEXT_SIZE_IN_BYTES,  DRM_E_BUFFERTOOSMALL );
        
        ChkDR( DRM_ECC_Encrypt_P256( ( const PUBKEY_P256 * )f_pbPublicKey, 
                                     ( const PLAINTEXT_P256 * )f_pbPlainText,
                                     ( CIPHERTEXT_P256 * )f_pbCipherText, 
                                     (struct bigctx_t *)f_pContext )  );                                       
                                       
        *f_pcbCipherText = ECC_P256_CIPHERTEXT_SIZE_IN_BYTES;
        break;        
    case eDRM_RSA:   
        ChkArg( f_cbPublicKey == SIZEOF( DRM_RSA_PUBLIC_KEY ) );

        ChkDR( DRM_RSA_OaepEncrypt(                               f_pOEMContext,
                                    ( const DRM_RSA_PUBLIC_KEY * )f_pbPublicKey, 
                                                                  f_cbPlainText,
                                                                  f_pbPlainText,
                                                                  f_pcbCipherText,
                                                                  f_pbCipherText,
                                           (DRM_CRYPTO_CONTEXT*)  f_pContext ) );                                       
        break;        
    default:
        ChkDR( DRM_E_UNSUPPORTEDALGORITHM );    
    }  

   
ErrorExit:    
    return dr;
}


/*********************************************************************
**
**  Function:  DRM_PK_Decrypt
**
**  Synopsis:  Decrypt a buffer using the given private key and algorithm type
**
**  Arguments:  
**     [f_pContext]      : Pointer to pk crypto context. Not required for ECC 256
**     [f_eAlgorithm]    : Enumeration specifying algorithm to use for decryption
**     [f_cbPrivateKey]  : Byte count of the private key
**     [f_pbPrivateKey]  : Specifies the private key to use
**     [f_cbCipherText]  : Byte count of the ciphertext buffer. 
**     [f_pbCipherText]  : Specifies the ciphertext buffer
**     [f_pcbPlainText]  : Byte count of the plaintext buffer. Returns the length of the
**                         actual plaintext.
**     [f_pbPlainText]   : Specifies the plaintext buffer
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument was NULL or improperly initialized
**      DRM_E_BUFFERTOOSMALL
**          One of the buffers was too small for the specified algorithm
**      DRM_E_UNSUPPORTEDALGORITHM
**          f_eAlgorithm specifies an invalid or not supported algorithm
**
**  Notes:  Data is not decrypted in place.
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_PK_Decrypt(
    __in_opt                            DRM_VOID                           *f_pContext,
    __in                                DRM_PKCRYPTO_SUPPORTED_ALGORITHMS   f_eAlgorithm,
    __in                                DRM_DWORD                           f_cbPrivateKey,
    __in_bcount( f_cbPrivateKey ) const DRM_BYTE                           *f_pbPrivateKey,
    __in                                DRM_DWORD                           f_cbCipherText,
    __in_bcount( f_cbCipherText ) const DRM_BYTE                           *f_pbCipherText,
    __inout_ecount( 1 )                 DRM_DWORD                          *f_pcbPlainText,
    __out_bcount( *f_pcbPlainText )     DRM_BYTE                           *f_pbPlainText )
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg( f_pbPrivateKey  != NULL );
    ChkArg( f_pbPlainText   != NULL );
    ChkArg( f_pcbPlainText  != NULL );
    ChkArg( f_pbCipherText  != NULL );  
    
    switch ( f_eAlgorithm )
    {
    case eDRM_ECC_P160:
        ChkArg( f_cbPrivateKey == DRM_ECC160_PRIVATE_KEY_LEN );  
        ChkArg( f_cbCipherText == DRM_ECC160_CIPHERTEXT_LEN );
                     
        ChkBOOL( *f_pcbPlainText >= DRM_ECC160_PLAINTEXT_LEN, DRM_E_BUFFERTOOSMALL );
        
        ChkDR( DRM_ECC_Decrypt_P160( f_pContext, 
                                     ( const PRIVKEY * )f_pbPrivateKey, 
                                     f_pbCipherText,
                                     f_pbPlainText ) );
                
        *f_pcbPlainText = DRM_ECC160_PLAINTEXT_LEN; 
        break;
    case eDRM_ECC_P256:   
        ChkArg( f_cbPrivateKey == ECC_P256_INTEGER_SIZE_IN_BYTES );
        ChkArg( f_cbCipherText == ECC_P256_CIPHERTEXT_SIZE_IN_BYTES );
                
        ChkBOOL( *f_pcbPlainText >= ECC_P256_PLAINTEXT_SIZE_IN_BYTES, DRM_E_BUFFERTOOSMALL );        
        
        ChkDR( DRM_ECC_Decrypt_P256( ( const PRIVKEY_P256 * )f_pbPrivateKey, 
                                     ( const CIPHERTEXT_P256 * )f_pbCipherText,
                                     ( PLAINTEXT_P256 * )f_pbPlainText,
                                     (struct bigctx_t *)f_pContext ) );                                       
                                       
        *f_pcbPlainText = ECC_P256_PLAINTEXT_SIZE_IN_BYTES;
        break;        
    case eDRM_RSA:   
        ChkArg( f_cbPrivateKey == SIZEOF( DRM_RSA_PRIVATE_KEY ) );

        ChkDR( DRM_RSA_OaepDecrypt( ( const DRM_RSA_PRIVATE_KEY * )f_pbPrivateKey, 
                                                                   f_cbCipherText,
                                                                   f_pbCipherText,
                                                                   f_pcbPlainText,
                                                                   f_pbPlainText,
                                            (DRM_CRYPTO_CONTEXT*)  f_pContext ) );
        break;        
    default:
        ChkDR( DRM_E_UNSUPPORTEDALGORITHM );    
    }  
   
ErrorExit:    
    return dr;
}


/*********************************************************************
**
**  Function:  DRM_PK_Sign
**
**  Synopsis:  Generate a digital signature with a private key
**
**  Arguments:  
**     [f_pContext]      : Pointer to pk crypto context. Not required for ECC 256
**     [f_eAlgorithm]    : Enumeration specifying algorithm to use for signing
**     [f_cbPrivateKey]  : Byte count of the private key
**     [f_pbPrivateKey]  : Specifies the private key to use
**     [f_cbData]        : Byte count of the input buffer. 
**     [f_pbData]        : Specifies the input buffer
**     [f_pcbSignature]  : Byte count of the signature buffer. Returns the length of the
**                         computed signature.
**     [f_pbSignature]   : Specifies the signature buffer
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          A required argument was NULL or improperly initialized
**      DRM_E_BUFFERTOOSMALL
**          One of the buffers was too small for the specified algorithm
**      DRM_E_UNSUPPORTEDALGORITHM
**          f_eAlgorithm specifies an invalid or not supported algorithm
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_PK_Sign(
    __in_opt                            DRM_VOID                           *f_pContext,
    __in                                DRM_PKCRYPTO_SUPPORTED_ALGORITHMS   f_eAlgorithm,
    __in                                DRM_DWORD                           f_cbPrivateKey,
    __in_bcount( f_cbPrivateKey ) const DRM_BYTE                           *f_pbPrivateKey,
    __in                                DRM_DWORD                           f_cbData,    
    __in_bcount( f_cbData ) const       DRM_BYTE                           *f_pbData,
    __inout_ecount( 1 )                 DRM_DWORD                          *f_pcbSignature,
    __out_bcount( *f_pcbSignature )     DRM_BYTE                           *f_pbSignature )
{    
    DRM_RESULT dr = DRM_SUCCESS;           
    
    ChkArg( f_pbPrivateKey  != NULL );
    ChkArg( f_pbData        != NULL );
    ChkArg( f_pcbSignature  != NULL );
    ChkArg( f_pbSignature   != NULL );  
    
    switch ( f_eAlgorithm )
    {
    case eDRM_ECC_P160:         
        ChkArg( f_cbPrivateKey == DRM_ECC160_PRIVATE_KEY_LEN );  
                     
        ChkBOOL( *f_pcbSignature >= DRM_ECC160_SIGNATURE_LEN, DRM_E_BUFFERTOOSMALL );
        
        ChkDR( DRM_ECC_Sign_P160( f_pContext, 
                                  ( const PRIVKEY * )f_pbPrivateKey, 
                                  f_pbData,
                                  f_cbData,
                                  f_pbSignature ) );                                  
                
        *f_pcbSignature = DRM_ECC160_SIGNATURE_LEN; 
        break;
    case eDRM_ECC_P256:          
        ChkArg( f_cbPrivateKey == ECC_P256_INTEGER_SIZE_IN_BYTES );
                
        ChkBOOL( *f_pcbSignature >= ECDSA_P256_SIGNATURE_SIZE_IN_BYTES, DRM_E_BUFFERTOOSMALL );        
        
        ChkDR( DRM_ECDSA_Sign_P256( f_pbData,
                                    f_cbData,
                                    ( const PRIVKEY_P256 * )f_pbPrivateKey,                                   
                                    ( SIGNATURE_P256 * )f_pbSignature,
                                    (struct bigctx_t *)f_pContext ) );
                                       
        *f_pcbSignature = ECDSA_P256_SIGNATURE_SIZE_IN_BYTES;
        break;        
    case eDRM_RSA:          
        ChkArg( f_cbPrivateKey == SIZEOF( DRM_RSA_PRIVATE_KEY ) );

        ChkDR( DRM_RSA_PssSign( ( const DRM_RSA_PRIVATE_KEY * )f_pbPrivateKey, 
                                                               f_cbData,
                                                               f_pbData,
                                                               0,
                                                               f_pcbSignature,
                                                               f_pbSignature,
                                        (DRM_CRYPTO_CONTEXT*)  f_pContext ) );
        break;        
    default:
        ChkDR( DRM_E_UNSUPPORTEDALGORITHM );    
    }  
   
ErrorExit:      
    return dr;
} 


/*********************************************************************
**
**  Function:  DRM_PK_Verify
**
**  Synopsis:  Verify a digital signature created by DRM_PK_Sign.
**
**  Arguments:  
**     [f_pContext]      : Pointer to pk crypto context. Not required for ECC 256
**     [f_eAlgorithm]    : Enumeration specifying algorithm to use for signing
**     [f_cbPublicKey]   : Byte count of the public key
**     [f_pbPublicKey]   : Specifies the public key to use
**     [f_cbData]        : Byte count of the input buffer. 
**     [f_pbData]        : Specifies the input buffer
**     [f_cbSignature]   : Byte count of the signature buffer.
**     [f_pbSignature]   : Specifies the signature buffer
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALID_SIGNATURE
**          Failed to verify the signature
**      DRM_E_P256_INVALID_SIGNATURE
**          Failed to verify the signature (ECC P256 algorithm)
**      DRM_E_P256_ECDSA_VERIFICATION_ERROR
**          Failed to verify the signature due to ECSDA error (ECC P256 algorithm)
**      DRM_E_INVALIDARG
**          A required argument was NULL or improperly initialized
**      DRM_E_BUFFERTOOSMALL
**          One of the buffers was too small for the specified algorithm
**      DRM_E_UNSUPPORTEDALGORITHM
**          f_eAlgorithm specifies an invalid or not supported algorithm
**
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_PK_Verify(     
    __in_opt                           DRM_VOID                           *f_pContext,
    __in                               DRM_PKCRYPTO_SUPPORTED_ALGORITHMS   f_eAlgorithm,
    __in                               DRM_DWORD                           f_cbPublicKey,
    __in_bcount( f_cbPublicKey ) const DRM_BYTE                           *f_pbPublicKey,
    __in                               DRM_DWORD                           f_cbData,
    __in_bcount( f_cbData )      const DRM_BYTE                           *f_pbData,
    __in                               DRM_DWORD                           f_cbSignature,
    __in_bcount( f_cbSignature ) const DRM_BYTE                           *f_pbSignature )
{    
    DRM_RESULT dr = DRM_SUCCESS;            
    
    ChkArg( f_pbPublicKey   != NULL );
    ChkArg( f_pbData        != NULL );
    ChkArg( f_cbData        > 0 );
    ChkArg( f_pbSignature   != NULL );
    
     switch ( f_eAlgorithm )
    {
    case eDRM_ECC_P160:
        ChkArg( f_pContext    != NULL );
        ChkArg( f_cbPublicKey == DRM_ECC160_PUBLIC_KEY_LEN );  
                     
        ChkBOOL( f_cbSignature == DRM_ECC160_SIGNATURE_LEN, DRM_E_INVALID_SIGNATURE );        
        
        ChkBOOL( DRM_ECC_Verify_P160( f_pContext, 
                                      ( const PUBKEY * )f_pbPublicKey, 
                                      f_pbData,
                                      f_cbData,
                                      f_pbSignature ), DRM_E_INVALID_SIGNATURE );                        
        break;
    case eDRM_ECC_P256:
        ChkArg( f_cbPublicKey == ECC_P256_POINT_SIZE_IN_BYTES )

        ChkBOOL( f_cbSignature == ECDSA_P256_SIGNATURE_SIZE_IN_BYTES, DRM_E_INVALID_SIGNATURE );        
        
        ChkDR( DRM_ECDSA_Verify_P256( f_pbData,
                                      f_cbData,
                                      ( const PUBKEY_P256 * )f_pbPublicKey,
                                      ( const SIGNATURE_P256 * )f_pbSignature,
                                      (struct bigctx_t *)f_pContext ) );
        break;        
    case eDRM_RSA:                   
        ChkArg( f_cbPublicKey == SIZEOF( DRM_RSA_PUBLIC_KEY ) );

        ChkDR( DRM_RSA_PssVerify( ( const DRM_RSA_PUBLIC_KEY * )f_pbPublicKey, 
                                                                f_cbData,
                                                                f_pbData,
                                                                0,
                                                                f_cbSignature,
                                                                f_pbSignature,
                                          (DRM_CRYPTO_CONTEXT*) f_pContext ) );
        break;        
    default:
        ChkDR( DRM_E_UNSUPPORTEDALGORITHM );    
    }  
    
ErrorExit:           
    return dr;
} 


 

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmoutputlevels.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmxmlparser.h>
#include <drmutilities.h>
#include <drmoutputleveltypes.h>
#include <drmoutputlevels.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmtoken.h>

ENTER_PK_NAMESPACE_CODE;

static const DRM_WORD g_wDefaultMinimumLevel = 100;

/*************************************************************************
**
** Private functions
**
**************************************************************************/

/*********************************************************************
**
**  Function:  _GetOPLLevel
**
**  Synopsis:  Returns the level of a specific category as defined in the XML 
**             restriction blob.  If the category doesn't exist the default level
**             is returned.
**
**  Arguments:  
**     [f_pdstrRestrictions] -- XML blob that contains the RESTRICTIONS tag.  
**                              If not provided the default will be returned
**     [f_pdstrCategory]     -- Category to extract the level from
**
*********************************************************************/
static DRM_WORD _GetOPLLevel( 
    IN const DRM_CONST_STRING *f_pdstrRestrictions,
    IN const DRM_CONST_STRING *f_pdstrCategory )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrCategoryNode = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrLevel        = EMPTY_DRM_STRING;
    DRM_WORD level = g_wDefaultMinimumLevel;
    DRM_LONG lval  = 0;

    ChkDRMString( f_pdstrCategory );

    if( f_pdstrRestrictions != NULL )
    {

        ChkDR( DRM_XML_GetNode( f_pdstrRestrictions,
                                f_pdstrCategory,
                                NULL,
                                NULL,
                                0,
                            &dstrCategoryNode,
                                NULL ) );

        /* Get the level from the node */

        ChkDR( DRM_XML_GetNodeAttribute( &dstrCategoryNode,
                                         &g_dstrLabelLevel,
                                         &dstrLevel ) );

        ChkDR( DRMCRT_wcsntol( dstrLevel.pwszString, dstrLevel.cchString, &lval ) );
        if( lval > 0 && lval <= (DRM_WORD) MAX_UNSIGNED_TYPE( DRM_WORD ) )
        {
            level = (DRM_WORD)lval;
        }
    }

ErrorExit:
    return level;
}


/*********************************************************************
**
**  Function:  _ProcessExtensions
**
**  Synopsis:  Process all EXTENSION tags from an output level XML block
**
**  Arguments:  
**     [f_pdstrRestrictions] -- String from XML blob that contains the entire RESTRICTIONS section
**     [f_pPlayOPL]          -- Play OPL struct that will be filled in 
**     [f_pstack]            -- Stack allocator context that will be used to allocate room for the extensions
**
**  Notes:     Data may be allocated from the stack context.  This data will be returned in the
**             f_pPlayOPL.vopi.rgVop pointer.
**
*********************************************************************/
static DRM_RESULT _ProcessExtensions( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_PLAY_OPL_EX2             *f_pPlayOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrAnalogAudio   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrExtensionList = EMPTY_DRM_STRING;
    DRM_VIDEO_OUTPUT_PROTECTION_EX *rgVop               = NULL;
    DRM_WORD iExtension  = 0;
    DRM_WORD cExtensions = 0;
    DRM_DWORD dwBase     = 10;

    dr = DRM_XML_GetNode( f_pdstrRestrictions,
                         &g_dstrTagAnalogVideo,
                          NULL,
                          NULL,
                          0,
                          NULL,
                         &dstrAnalogAudio );

    if( DRM_FAILED( dr ) )
    {
        /* There is no Analog Video OPL */
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }

    dr = DRM_XML_GetNode( &dstrAnalogAudio,
                          &g_dstrTagExtensionList,
                           NULL,
                           NULL,
                           0,
                           NULL,
                          &dstrExtensionList );

    if( DRM_FAILED( dr ) )
    {
        /* There is no Analog Video OPL */
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }

    /* Count the number of extensions that exist in the license */
    for( iExtension = 0; DRM_SUCCEEDED( dr ); iExtension++ )
    {
        DRM_CONST_STRING dstrExtension = EMPTY_DRM_STRING;

        dr = DRM_XML_GetNode( &dstrExtensionList, 
                              &g_dstrTagExtension,
                               NULL,
                               NULL,
                               iExtension,
                              &dstrExtension,
                               NULL );
    }

    dr = DRM_SUCCESS;
    iExtension--;
    if( iExtension == 0 )
    {
        goto ErrorExit;
    }

    cExtensions = iExtension;
    ChkDR( DRM_STK_Alloc( f_pstack, cExtensions * SIZEOF( DRM_VIDEO_OUTPUT_PROTECTION_EX ), (DRM_VOID**)&rgVop ) );
    ZEROMEM(rgVop, cExtensions * SIZEOF( DRM_VIDEO_OUTPUT_PROTECTION_EX ) );

    /* Populate the data structure with data from the license */
    for( iExtension = 0; iExtension < cExtensions; iExtension++ )
    {
        DRM_CONST_STRING dstrExtension = EMPTY_DRM_STRING;
        DRM_CONST_STRING dstrGuid      = EMPTY_DRM_STRING;
        DRM_CONST_STRING dstrData      = EMPTY_DRM_STRING;

        ChkDR( DRM_XML_GetNode( &dstrExtensionList, 
                                &g_dstrTagExtension,
                                 NULL,
                                 NULL,
                                 iExtension,
                                &dstrExtension,
                                 NULL ) );

        ChkDR( DRM_XML_GetNodeAttribute( &dstrExtension, &g_dstrLabelGuid,  &dstrGuid ) );
        ChkDR( DRM_XML_GetNodeAttribute( &dstrExtension, &g_dstrLabelValue, &dstrData ) );
        rgVop[iExtension].dwVersion = VER_DRM_VIDEO_OUTPUT_PROTECTION;
        ChkDR( DRM_UTL_StringToGuid( &dstrGuid, &rgVop[iExtension].guidId ) );


        /* 
         * Check if dstrData is a hex number  (dwBase is 10 by default)
         */
        if (     dstrData.cchString > 1
             &&  *(dstrData.pwszString) == NATIVE_WCHAR( g_wch0 )
             && (*(dstrData.pwszString +1 ) == NATIVE_WCHAR( g_wchx ) || *(dstrData.pwszString +1 ) == NATIVE_WCHAR( g_wchX ) ) )
        {
            dwBase = 16;
        }

        ChkDR( DRMCRT_WtoDWORD( dstrData.pwszString,
                                dstrData.cchString,
                                dwBase,
                               &rgVop[iExtension].dwConfigData ) );

    }

    f_pPlayOPL->vopi.dwVersion= VER_DRM_PLAY_OPL;
    f_pPlayOPL->vopi.cEntries = cExtensions;
    f_pPlayOPL->vopi.rgVop    = rgVop;
    rgVop = NULL;

    /* Explicit Digital Audio restrictions not supported in XML licenses */
    f_pPlayOPL->aopi.dwVersion= 0;
    f_pPlayOPL->aopi.cEntries = 0;
    f_pPlayOPL->aopi.rgAop    = NULL;


ErrorExit:
    SAFE_STK_FREE( f_pstack, rgVop );
    return dr;
}

/*********************************************************************
**
**  Function:  _ProcessExtensionsXMR
**
**  Synopsis:  Process all extensions from an XMR analog video and digital
               audio protection structures
**
**  Arguments:  
**     [f_pxmrVideoRestrictions] : Structure containing all video restrictions
**     [f_pxmrAudioRestrictions] : Structure containing all audio restrictions
**     [f_pPlayOPL]              : Play OPL struct that will be filled in 
**     [f_pstack]                : Stack allocator context that will be used to allocate 
**                                 room for the extensions
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_ARITHMETICOVERFLOW
**          An arithmetic overflow occurred during processing
**
**  Notes: Data may be allocated from the stack context.  This data will be returned in the
**         f_pPlayOPL.vopi.rgVop and f_pPlayOPL.aopi.rgAop pointers.
**
*********************************************************************/
static DRM_RESULT _ProcessExtensionsXMR(
    IN const DRM_XMR_EXPLICIT_ANALOG_VIDEO_PROTECTION   *f_pxmrVideoRestrictions,
    IN const DRM_XMR_EXPLICIT_DIGITAL_AUDIO_PROTECTION  *f_pxmrAudioRestrictions,
    IN OUT   DRM_PLAY_OPL_EX2                           *f_pPlayOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT                *f_pstack )
{
    DRM_RESULT dr               = DRM_SUCCESS;
    DRM_WORD   iExtension       = 0;
    DRM_WORD   cVideoExtensions = 0;
    DRM_DWORD  cVop             = 0;
    DRM_WORD   cAudioExtensions = 0;
    DRM_DWORD  cAop             = 0;
    DRM_VIDEO_OUTPUT_PROTECTION_EX          *pVop                          = NULL;
    DRM_VIDEO_OUTPUT_PROTECTION_EX          *pAop                          = NULL;
    DRM_XMR_VIDEO_OUTPUT_CONFIGURATION_LIST *plistVideoOutputConfiguration = NULL;
    DRM_XMR_VIDEO_OUTPUT_CONFIGURATION_LIST *plistAudioOutputConfiguration = NULL;

    MEMSET( &f_pPlayOPL->vopi, 0, SIZEOF(f_pPlayOPL->vopi) ); 
    MEMSET( &f_pPlayOPL->aopi, 0, SIZEOF(f_pPlayOPL->aopi) ); 

    if( f_pxmrVideoRestrictions->fValid )
    {
        ChkDR( DRM_UTL_MultiplyDWORDs( f_pxmrVideoRestrictions->cOutputProtectionIDs,
                                   SIZEOF( DRM_VIDEO_OUTPUT_PROTECTION_EX ),
                                      &cVop ) );

        ChkDR( DRM_STK_Alloc( f_pstack, cVop, ( DRM_VOID** )&pVop ) );
        ZEROMEM( pVop, cVop );

        /*
        ** Populate the data structure with data from the license 
        */
        for( plistVideoOutputConfiguration = f_pxmrVideoRestrictions->plistOutputConfiguration;
             iExtension < f_pxmrVideoRestrictions->cOutputProtectionIDs 
          && plistVideoOutputConfiguration != NULL;
             iExtension++, plistVideoOutputConfiguration = plistVideoOutputConfiguration->pNext )
        {
            DRM_BYT_CopyBytes( &pVop[iExtension].guidId,
                                0,
                                plistVideoOutputConfiguration->Config.pguidBuffer,
                                plistVideoOutputConfiguration->Config.iGuid,
                                SIZEOF( pVop[iExtension].guidId ) );

            DRM_BYT_CopyBytes( &pVop[iExtension].dwConfigData,
                                0,
                                plistVideoOutputConfiguration->Config.pbConfigDataBuffer,
                                plistVideoOutputConfiguration->Config.iConfigData,
                                plistVideoOutputConfiguration->Config.cbConfigData );

            pVop[iExtension].dwVersion = VER_DRM_VIDEO_OUTPUT_PROTECTION;

            cVideoExtensions++;
        }
        
        f_pPlayOPL->vopi.cEntries = cVideoExtensions;
        f_pPlayOPL->vopi.rgVop    = pVop;
        pVop = NULL;
    }

    if( f_pxmrAudioRestrictions->fValid )
    {
        ChkDR( DRM_UTL_MultiplyDWORDs( f_pxmrAudioRestrictions->cOutputProtectionIDs,
                                   SIZEOF( DRM_AUDIO_OUTPUT_PROTECTION_EX ),
                                      &cAop ) );

        ChkDR( DRM_STK_Alloc( f_pstack, cAop, ( DRM_VOID** )&pAop ) );
        ZEROMEM( pAop, cAop );

        /*
        ** Populate the data structure with data from the license 
        */
        for( plistAudioOutputConfiguration = f_pxmrAudioRestrictions->plistOutputConfiguration,
             iExtension = 0;
             iExtension < f_pxmrAudioRestrictions->cOutputProtectionIDs 
          && plistAudioOutputConfiguration != NULL;
             iExtension++, plistAudioOutputConfiguration = plistAudioOutputConfiguration->pNext )
        {
            DRM_BYT_CopyBytes( &pAop[iExtension].guidId,
                                0,
                                plistAudioOutputConfiguration->Config.pguidBuffer,
                                plistAudioOutputConfiguration->Config.iGuid,
                                SIZEOF( pAop[iExtension].guidId ) );


            DRM_BYT_CopyBytes( &pAop[iExtension].dwConfigData,
                                0,
                                plistAudioOutputConfiguration->Config.pbConfigDataBuffer,
                                plistAudioOutputConfiguration->Config.iConfigData,
                                plistAudioOutputConfiguration->Config.cbConfigData );

            pAop[iExtension].dwVersion = VER_DRM_VIDEO_AUDIO_OUTPUT_PROTECTION;

            cAudioExtensions++;
        }
        
        f_pPlayOPL->aopi.cEntries = cAudioExtensions;
        f_pPlayOPL->aopi.rgAop    = pAop;
        pAop = NULL;
    }

ErrorExit:
    SAFE_STK_FREE( f_pstack, pVop );
    SAFE_STK_FREE( f_pstack, pAop );
    return dr;
}

/*********************************************************************
**
**  Function:  _ProcessIdList
**
**  Synopsis:  Finds ID tags in a generic way and populates an ID struct with the enumerated
**             guids.
**
**  Arguments:  
**     [f_pdstrRestrictions] -- String from XML blob that contains the entire RESTRICTIONS section
**     [f_pdstrType]         -- XML tag to be searched for in RESTRICTIONS
**     [f_pdstrTypeList]     -- LIST XML tag to be searched for in RESTRICTIONs
**     [f_pOPLIds]           -- A OPL_OUTPUT_IDS structure that will be filled in.
**     [f_pstack]            -- Stack allocator context that will be used to allocate room for the Ids
**
*********************************************************************/
static DRM_RESULT _ProcessIdList( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN const DRM_CONST_STRING             *f_pdstrType,
    IN const DRM_CONST_STRING             *f_pdstrTypeList,
    IN OUT   DRM_OPL_OUTPUT_IDS           *f_pOPLIds,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrIdList = EMPTY_DRM_STRING;
    DRM_GUID *rgIds         = NULL;
    DRM_WORD  iId   = 0;
    DRM_WORD  cIds = 0;

    dr = DRM_XML_GetNode( f_pdstrRestrictions,
                          f_pdstrTypeList,
                          NULL,
                          NULL,
                          0,
                          NULL,
                         &dstrIdList );

    if( DRM_FAILED( dr ) )
    {
        /* There is no Analog Video OPL */
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }

    /* Count the number of extensions that exist in the license */
    for( iId = 0; DRM_SUCCEEDED( dr ); iId++ )
    {
        DRM_CONST_STRING dstrId = EMPTY_DRM_STRING;

        dr = DRM_XML_GetNode( &dstrIdList, 
                               f_pdstrType,
                               NULL,
                               NULL,
                               iId,
                              &dstrId,
                               NULL );
    }

    dr = DRM_SUCCESS;
    iId--;

    if( iId == 0 )
    {
        goto ErrorExit;
    }

    cIds = iId;
    ChkDR( DRM_STK_Alloc( f_pstack, cIds * SIZEOF( DRM_GUID ), (DRM_VOID**)&rgIds ) );
    ZEROMEM( rgIds, cIds * SIZEOF( DRM_GUID ) );

    /* Populate the data structure with data from the license */
    for( iId = 0; iId < cIds; iId++ )
    {
        DRM_CONST_STRING dstrId   = EMPTY_DRM_STRING;
        DRM_CONST_STRING dstrGuid = EMPTY_DRM_STRING;

        ChkDR( DRM_XML_GetNode( &dstrIdList, 
                                 f_pdstrType,
                                 NULL,
                                 NULL,
                                 iId,
                                &dstrId,
                                 NULL ) );

        ChkDR( DRM_XML_GetNodeAttribute( &dstrId, &g_dstrLabelGuid, &dstrGuid ) );
        ChkDR( DRM_UTL_StringToGuid( &dstrGuid, &(rgIds[iId]) ) );
    }

    f_pOPLIds->cIds  = cIds;
    f_pOPLIds->rgIds = rgIds;
    rgIds = NULL;

ErrorExit:
    SAFE_STK_FREE( f_pstack, rgIds );
    return dr;
}

/*********************************************************************
**
**  Function:  _ProcessExclusions
**
**  Synopsis:  Finds exlude tags in the restrictions XML
**
**  Arguments:  
**     [f_pdstrRestrictions] -- String from XML blob that contains the entire RESTRICTIONS section
**     [f_pOPLIds]           -- Id struct that will be populated
**     [f_pstack]            -- Stack allocator context that will be used to allocate room for the Ids
**
*********************************************************************/
static DRM_RESULT _ProcessExclusions( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_OPL_OUTPUT_IDS           *f_pOPLIds,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    return _ProcessIdList( f_pdstrRestrictions,
                          &g_dstrTagExclude,
                          &g_dstrTagExcludeList,
                           f_pOPLIds, 
                           f_pstack );
}


/*********************************************************************
**
**  Function:  _ProcessInclusions
**
**  Synopsis:  Finds include tags in the restrictions XML
**
**  Arguments:  
**     [f_pdstrRestrictions] -- String from XML blob that contains the entire RESTRICTIONS section
**     [f_pOPLIds]           -- Id struct that will be populated
**     [f_pstack]            -- Stack allocator context that will be used to allocate room for the Ids
**
*********************************************************************/
static DRM_RESULT _ProcessInclusions( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_OPL_OUTPUT_IDS           *f_pOPLIds,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    return _ProcessIdList( f_pdstrRestrictions,
                          &g_dstrTagInclude,
                          &g_dstrTagIncludeList,
                           f_pOPLIds, 
                           f_pstack );
}




/*************************************************************************
**
** Public functions
**
**************************************************************************/


/*********************************************************************
**
**  Function:  DRM_OPL_ProcessPlayOutputLevelData
**
**  Synopsis:  
**
**  Arguments:  
**     [f_pdstrRestrictions] -- String from XML blob that contains the entire RESTRICTIONS section
**     [f_pPlayOPL]          -- Play OPL struct that will be populated with output level data
**     [f_pstack]            -- Stack allocator context that will be used to allocate room for the Ids
**
**  Notes:  Caller should provide a clean, unused stack context.  Caller shouldn't free data directly from stack
**          context.  Instead just throw entire stack context away when finished with the OPL structures.
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_OPL_ProcessPlayOutputLevelData( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_PLAY_OPL_EX2             *f_pPlayOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    DRM_RESULT dr = DRM_SUCCESS;

    if( f_pdstrRestrictions != NULL )
    {
        ChkDRMString( f_pdstrRestrictions );
    }
    ChkArg( f_pPlayOPL        != NULL 
         && f_pstack          != NULL 
         && f_pstack->pbStack != NULL
         && f_pstack->cbStack  > 0 );
        
    ZEROMEM( f_pPlayOPL, SIZEOF( *f_pPlayOPL ) );

    f_pPlayOPL->minOPL.wCompressedDigitalVideo   = _GetOPLLevel( f_pdstrRestrictions, &g_dstrTagCompressedDigitalVideo   );
    f_pPlayOPL->minOPL.wUncompressedDigitalVideo = _GetOPLLevel( f_pdstrRestrictions, &g_dstrTagUncompressedDigitalVideo );
    f_pPlayOPL->minOPL.wAnalogVideo              = _GetOPLLevel( f_pdstrRestrictions, &g_dstrTagAnalogVideo              );
    f_pPlayOPL->minOPL.wCompressedDigitalAudio   = _GetOPLLevel( f_pdstrRestrictions, &g_dstrTagCompressedDigitalAudio   );
    f_pPlayOPL->minOPL.wUncompressedDigitalAudio = _GetOPLLevel( f_pdstrRestrictions, &g_dstrTagUncompressedDigitalAudio );

    if( f_pdstrRestrictions != NULL )
    {
        ChkDR( _ProcessExtensions( f_pdstrRestrictions, f_pPlayOPL, f_pstack ) );
    }
ErrorExit:
    return dr;
}


/*********************************************************************
**
**  Function:  DRM_OPL_ProcessCopyOutputLevelData
**
**  Synopsis:  
**
**  Arguments:  
**     [f_pdstrRestrictions] -- String from XML blob that contains the entire RESTRICTIONS section
**     [f_pCopyOPL]          -- Copy OPL struct that will be populated with output level data
**     [f_pstack]            -- Stack allocator context that will be used to allocate room for the Ids
**
**  Notes:  Caller should provide a clean, unused stack context.  Caller shouldn't free data directly from stack
**          context.  Instead just throw entire stack context away when finished with the OPL structures.
**
*********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_OPL_ProcessCopyOutputLevelData( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_COPY_OPL                 *f_pCopyOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    DRM_RESULT dr = DRM_SUCCESS;

    if( f_pdstrRestrictions != NULL )
    {
        ChkDRMString( f_pdstrRestrictions );
    }
    ChkArg( f_pCopyOPL        != NULL 
         && f_pstack          != NULL 
         && f_pstack->pbStack != NULL
         && f_pstack->cbStack  > 0 );
        
    ZEROMEM( f_pCopyOPL, SIZEOF( *f_pCopyOPL ) );

    f_pCopyOPL->wMinimumCopyLevel = _GetOPLLevel( f_pdstrRestrictions, &g_dstrTagCopy );

    if( f_pdstrRestrictions != NULL )
    {
        /* Process exclusions first because the inclusion processing will expect exlusions to have been done first */
        ChkDR( _ProcessExclusions( f_pdstrRestrictions, &(f_pCopyOPL->oplIdExcludes), f_pstack ) );
        ChkDR( _ProcessInclusions( f_pdstrRestrictions, &(f_pCopyOPL->oplIdIncludes), f_pstack ) );
    }

ErrorExit:
    return dr;
}

/*********************************************************************
**
**  Function:  DRM_OPL_ProcessPlayOutputLevelDataXMR
**
**  Synopsis:  Process a Playback OPL for XMR
**
**  Arguments:  
**     [f_pxmrPlaybackRights] : XMR Playback rights structure to parse the OPL from
**     [f_pPlayOPL]           : Playback OPL struct that will be populated with output level data
**     [f_pstack]             : Stack allocator context that will be used to allocate room for IDs
**
** Returns:
**      DRM_SUCCESS:
**          Success
**      DRM_E_INVALIDARG:
**          One of the arguments was NULL or improperly initialized        
**
**  Notes:  Caller should provide a clean, unused stack context.  
**          Caller shouldn't free data directly from stack context.  
**          Instead just throw entire stack context away when finished with the OPL structures.
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_OPL_ProcessPlayOutputLevelDataXMR(
    IN const DRM_XMR_PLAYBACK_RIGHTS      *f_pxmrPlaybackRights,
    IN OUT   DRM_PLAY_OPL_EX2             *f_pPlayOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pPlayOPL          != NULL );
    ChkArg( f_pstack            != NULL );
    ChkArg( f_pstack->pbStack   != NULL );
    ChkArg( f_pstack->cbStack    > 0 );
    ChkArg( f_pxmrPlaybackRights!= NULL );

    ZEROMEM( f_pPlayOPL, SIZEOF( *f_pPlayOPL ) );

    if( f_pxmrPlaybackRights->opl.fValid )
    {
        f_pPlayOPL->minOPL.wCompressedDigitalVideo   = f_pxmrPlaybackRights->opl.wCompressedDigitalVideo;
        f_pPlayOPL->minOPL.wUncompressedDigitalVideo = f_pxmrPlaybackRights->opl.wUncompressedDigitalVideo;
        f_pPlayOPL->minOPL.wAnalogVideo              = f_pxmrPlaybackRights->opl.wAnalogVideo;
        f_pPlayOPL->minOPL.wCompressedDigitalAudio   = f_pxmrPlaybackRights->opl.wCompressedDigitalAudio;
        f_pPlayOPL->minOPL.wUncompressedDigitalAudio = f_pxmrPlaybackRights->opl.wUncompressedDigitalAudio;
    }

    ChkDR( _ProcessExtensionsXMR( &f_pxmrPlaybackRights->containerExplicitAnalogVideoProtection,
                                  &f_pxmrPlaybackRights->containerExplicitDigitalAudioProtection,
                                   f_pPlayOPL,
                                   f_pstack ) );

ErrorExit:
    return dr;
}

/*********************************************************************
**
**  Function:  DRM_OPL_ProcessCopyOutputLevelDataXMR
**
**  Synopsis:  Process a Copy OPL for XMR
**
**  Arguments:  
**     [f_pxmrCopyRights] : XMR Copy rights structure to parse the OPL from
**     [f_pCopyOPL]       : Copy OPL struct that will be populated with output level data
**     [f_pstack]         : Stack allocator context that will be used to allocate room for IDs
**
** Returns:
**      DRM_SUCCESS:
**          Success
**      DRM_E_INVALIDARG:
**          One of the arguments was NULL or improperly initialized        
**
**  Notes:  Caller should provide a clean, unused stack context.  
**          Caller shouldn't free data directly from stack context.  
**          Instead just throw entire stack context away when finished with the OPL structures.
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_OPL_ProcessCopyOutputLevelDataXMR(
    IN const DRM_XMR_COPY_RIGHTS          *f_pxmrCopyRights,
    IN OUT   DRM_COPY_OPL                 *f_pCopyOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    DRM_RESULT dr = DRM_SUCCESS;
         
    ChkArg( f_pCopyOPL          != NULL );
    ChkArg( f_pstack            != NULL );
    ChkArg( f_pstack->pbStack   != NULL );
    ChkArg( f_pstack->cbStack    > 0 );
    ChkArg( f_pxmrCopyRights    != NULL );         

    ZEROMEM( f_pCopyOPL, SIZEOF( *f_pCopyOPL ) );

    if( f_pxmrCopyRights->CopyProtectionLevel.fValid )
    {
        f_pCopyOPL->wMinimumCopyLevel = f_pxmrCopyRights->CopyProtectionLevel.wValue;
    }


ErrorExit:
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmprofile.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmprofile.h>

ENTER_PK_NAMESPACE_CODE;


#if DRM_SUPPORT_PROFILING

/* L"perf.dat" */
const DRM_WCHAR g_rgwchPerfLog[] = {ONE_WCHAR('p', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('r', '\0'), ONE_WCHAR('f', '\0'),
                              ONE_WCHAR('.', '\0'), ONE_WCHAR('d', '\0'), ONE_WCHAR('a', '\0'), ONE_WCHAR('t', '\0'),
                              ONE_WCHAR('\0', '\0')};

/* L"perfagg.dat" */
const DRM_WCHAR g_rgwchPerfAggLog[] = {ONE_WCHAR('p', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('r', '\0'), ONE_WCHAR('f', '\0'),
                                 ONE_WCHAR('a', '\0'), ONE_WCHAR('g', '\0'), ONE_WCHAR('g', '\0'), ONE_WCHAR('.', '\0'), 
                                 ONE_WCHAR('d', '\0'), ONE_WCHAR('a', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR('\0', '\0')};

/* L"perfuserdata.dat" */
const DRM_WCHAR g_rgwchPerfUserDataLog[] = {ONE_WCHAR('p', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('r', '\0'), ONE_WCHAR('f', '\0'),
                                      ONE_WCHAR('u', '\0'), ONE_WCHAR('s', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('r', '\0'),
                                      ONE_WCHAR('d', '\0'), ONE_WCHAR('a', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR('a', '\0'),
                                      ONE_WCHAR('.', '\0'), ONE_WCHAR('d', '\0'), ONE_WCHAR('a', '\0'), ONE_WCHAR('t', '\0'), 
                                      ONE_WCHAR('\0', '\0')};

/*L"perfstacksize.dat"*/
const DRM_WCHAR g_rgwchPerfStackSizeLog[] = {ONE_WCHAR('p', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('r', '\0'), ONE_WCHAR('f', '\0'),
                                      ONE_WCHAR('s', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR('a', '\0'), ONE_WCHAR('c', '\0'),
                                      ONE_WCHAR('k', '\0'), ONE_WCHAR('s', '\0'), ONE_WCHAR('i', '\0'), ONE_WCHAR('z', '\0'),
                                      ONE_WCHAR('e', '\0'), ONE_WCHAR('.', '\0'), ONE_WCHAR('d', '\0'), ONE_WCHAR('a', '\0'),
                                      ONE_WCHAR('t', '\0'), ONE_WCHAR('\0', '\0')};

/*L"StackSize*/
const DRM_WCHAR g_rgwchStackSizePrefix[] = {ONE_WCHAR('s', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR('a', '\0'), ONE_WCHAR('c', '\0'),
                                      ONE_WCHAR('k', '\0'), ONE_WCHAR('s', '\0'), ONE_WCHAR('i', '\0'), ONE_WCHAR('z', '\0'),
                                      ONE_WCHAR('e', '\0'),ONE_WCHAR('\0', '\0')};

/* Hash a string into a DRM_DWORD to facilitate user data logging since it only takes DRM_DWORD */
DRM_DWORD Perf_String_Data(DRM_CONST_STRING * pdstrIn)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwResult = 0;
    DRM_INT nSize = 0, i = 0;
    const DRM_WCHAR * pStr = NULL;

    ChkArg(pdstrIn != NULL);
    
    nSize = pdstrIn->cchString;
    pStr = pdstrIn->pwszString;

    for (i = 0; i < nSize; i++)
        dwResult += *(pStr++);
    
ErrorExit:
    return dwResult;
}

/* Hash a binary buffer into a DRM_DWORD to facilitate user data logging since it only takes DRM_DWORD */
DRM_DWORD Perf_Binary_Data(DRM_BYTE * pbIn, DRM_DWORD dwSize)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwResult = 0;
    DRM_DWORD i = 0;

    ChkArg(pbIn != NULL);
        
    for (i = 0; i < dwSize; i++)
        dwResult += *(pbIn+i);
    
ErrorExit:
    return dwResult;
}

PERF_AGG_SCOPE_CONTEXT * Perf_Allocate_Agg_Scope()
{
    PERF_GLOBAL_CONTEXT *pPerfContext = Oem_Profiling_GetProfileContext();

    if (pPerfContext->m_nCurrAggScope >= MAX_PROFILE_AGG_SCOPES)
        return NULL;
        
    MEMSET(&pPerfContext->m_AggScopes[pPerfContext->m_nCurrAggScope], 0, SIZEOF(PERF_AGG_SCOPE_CONTEXT));
        
    return &pPerfContext->m_AggScopes[pPerfContext->m_nCurrAggScope++];
}

DRM_API DRM_RESULT DRM_CALL _WriteProfileSample(DRM_BYTE * pbData, DRM_DWORD dwSize)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cch = 0;
    PERF_GLOBAL_CONTEXT *pPerfContext = Oem_Profiling_GetProfileContext();

    /* Check whether the cached sample buffer is full */                
    if (pPerfContext->m_dwBufferIndex + dwSize > MAX_PROFILE_BUFFER_SIZE)
    {
        /* Flush out all content in the cached sample buffer */
        ChkDR(Oem_File_Write(pPerfContext->m_fp, pPerfContext->m_bBuffer, pPerfContext->m_dwBufferIndex, &cch));

        pPerfContext->m_dwBufferIndex = 0;
    }
    
    /* Store the sample in the cached sample buffer */
    MEMCPY(&(pPerfContext->m_bBuffer[pPerfContext->m_dwBufferIndex]), pbData, dwSize);

    pPerfContext->m_dwBufferIndex += dwSize;

ErrorExit:
    return dr;
}

#if PROFILE_USER_DATA
DRM_API DRM_RESULT DRM_CALL _WriteProfileUserData(DRM_BYTE * pbData, DRM_DWORD dwSize)
{
    DRM_RESULT dr = DRM_SUCCESS;    
    DRM_DWORD cch = 0;
    PERF_GLOBAL_CONTEXT *pPerfContext = Oem_Profiling_GetProfileContext();
        
    /* Check whether the cached user data buffer is full */    
    if (pPerfContext->m_dwBufferUserDataIndex + dwSize > MAX_PROFILE_BUFFER_SIZE)
    {                
        /* Flush out all content in the cached user data buffer */
        ChkDR(Oem_File_Write(pPerfContext->m_fpUserData, pPerfContext->m_bBufferUserData, pPerfContext->m_dwBufferUserDataIndex, &cch));

        pPerfContext->m_dwBufferUserDataIndex = 0;
    }
    
    /* Store the user data in the cached user data buffer */
    MEMCPY(&(pPerfContext->m_bBufferUserData[pPerfContext->m_dwBufferUserDataIndex]), pbData, dwSize);

    pPerfContext->m_dwBufferUserDataIndex += dwSize;

ErrorExit:
    return dr;
}
#endif

/**********************************************************************
Function: Perf_Log_Profile
Synopsis: This functions logs the profiling data to perf*.dat file when 
          profiling is turned on
Arguments: pScopeContext : the scope context used to store profiling data
           nScopeLevel   : Unsigned Int used to track the scope level of 
                           the current function being logged
***********************************************************************/
DRM_RESULT Perf_Log_Profile(PERF_SCOPE_CONTEXT * pScopeContext, DRM_UINT nScopeLevel)
{
    DRM_RESULT dr = DRM_SUCCESS;
    PERF_GLOBAL_CONTEXT *pPerfContext = Oem_Profiling_GetProfileContext();
    DRM_DWORD dwTickCount = 0;

    ChkArg(pScopeContext != NULL);

    if (pPerfContext->m_nDetailLevel != 0 && pPerfContext->m_nDetailLevel < pScopeContext->m_nDetailLevel)
        goto ErrorExit;

    if (pPerfContext->m_nFeatureSet != 0 && ((pPerfContext->m_nFeatureSet & pScopeContext->m_nFeatureSet) == 0))
        goto ErrorExit;

    if( pPerfContext->m_fp == OEM_INVALID_HANDLE_VALUE )
    {
        /* Not using ChkArg here since it would flood the trace log.
        ** An invalid handle value is a sign that we've stopped
        ** profiling but all functions will still call into profiling.
        */
        dr = DRM_E_INVALIDARG;
        goto ErrorExit;
    }
    
    dwTickCount = PERF_CURRENT_MICROSECOND_COUNT;
        
    ChkDR(_WriteProfileSample((DRM_BYTE *) &pScopeContext->m_dwScopeID, SIZEOF(DRM_DWORD)));

    ChkDR(_WriteProfileSample((DRM_BYTE *) &pScopeContext->m_dwParentScopeID, SIZEOF(DRM_DWORD)));
    
    ChkDR(_WriteProfileSample((DRM_BYTE *) &pScopeContext->m_dwDuration, SIZEOF(DRM_DWORD)));

    ChkDR(_WriteProfileSample((DRM_BYTE *)&nScopeLevel,SIZEOF(DRM_UINT)));

#if PROFILE_USER_DATA
    /* Only log if all user data in the scope context is not 0xffffffff */
    if (pScopeContext->m_dwUserData1 != 0xffffffff && pScopeContext->m_dwUserData2 != 0xffffffff)
    {
        ChkDR(_WriteProfileUserData((DRM_BYTE *) &pScopeContext->m_dwScopeID, SIZEOF(DRM_DWORD)));
        
        ChkDR(_WriteProfileUserData((DRM_BYTE *) &pScopeContext->m_dwUserData1, SIZEOF(DRM_DWORD)));

        ChkDR(_WriteProfileUserData((DRM_BYTE *) &pScopeContext->m_dwUserData2, SIZEOF(DRM_DWORD)));
    }
#endif

    pPerfContext->m_dwLogWriteDuration = pPerfContext->m_dwLogWriteDuration + PERF_CURRENT_MICROSECOND_COUNT - dwTickCount;

ErrorExit:
    return dr;
}

DRM_RESULT Perf_Enter_Scope(PERF_SCOPE_CONTEXT * pScopeContext)
{
    DRM_RESULT dr = DRM_SUCCESS;
    PERF_GLOBAL_CONTEXT *pPerfContext = Oem_Profiling_GetProfileContext();
    DRM_BOOL fResetInProfile = FALSE;
                
    ChkArg(pScopeContext != NULL);

    if( !pPerfContext->m_bRunning
     ||  pPerfContext->m_bInProfile)
    {
        /* Profiling is either turned off or we're already inside it */
        goto ErrorExit;
    }
    pPerfContext->m_bInProfile = TRUE;
    fResetInProfile = TRUE;

    if (pPerfContext->m_nCurrScope >= MAX_PROFILE_SCOPE_LEVEL)
    {
        /*    printf("Scope stack is full!\n"); */
        goto ErrorExit;
    }

#if PROFILE_USER_DATA

    /* Initialize user data in the current scope context */
    pScopeContext->m_dwUserData1 = 0xffffffff;

    pScopeContext->m_dwUserData2 = 0xffffffff;

#endif                                                                

    pScopeContext->m_dwDuration = PERF_CURRENT_MICROSECOND_COUNT - pPerfContext->m_dwLogWriteDuration;

    if (pPerfContext->m_nCurrScope == 0)
    {
        pScopeContext->m_dwParentScopeID = 0;
    }
    else
    {
        pScopeContext->m_dwParentScopeID = pPerfContext->m_dwScopeID[pPerfContext->m_nCurrScope - 1];
    }

    pPerfContext->m_dwScopeID[pPerfContext->m_nCurrScope++] = pScopeContext->m_dwScopeID;

#if PROFILE_STACK_SIZE

    /*initialize the StackBase if it has not already been initialized */
    if(pPerfContext->m_dwStackBase == 0)
    {
        pPerfContext->m_dwStackBase = (DRM_DWORD_PTR)pScopeContext;
        pPerfContext->m_dwMaxStackSize = 0;
    }
    
#endif

ErrorExit:
    if( fResetInProfile )
    {
        pPerfContext->m_bInProfile = FALSE;
    }
    
    return dr;
}

DRM_RESULT Perf_Leave_Scope(PERF_SCOPE_CONTEXT * pScopeContext)
{
    DRM_RESULT dr = DRM_SUCCESS;    
    DRM_DWORD dwNow = 0;
    PERF_GLOBAL_CONTEXT *pPerfContext = Oem_Profiling_GetProfileContext();
    DRM_BOOL fResetInProfile = FALSE;

    ChkArg(pScopeContext != NULL);

    if( !pPerfContext->m_bRunning
     ||  pPerfContext->m_bInProfile)
    {
        /* Profiling is either turned off or we're already inside it */
        goto ErrorExit;
    }
    pPerfContext->m_bInProfile = TRUE;
    fResetInProfile = TRUE;

    if (pPerfContext->m_nCurrScope == 0)
    {
        /*  printf("Scope stack is empty!\n"); */
        DRMASSERT(FALSE);
        dr = DRM_E_PERF_SCOPING_ERROR;
        goto ErrorExit;
    }

    if (pPerfContext->m_dwScopeID[pPerfContext->m_nCurrScope - 1] != pScopeContext->m_dwScopeID)
    {
        /*  printf("Scope ID mismatch!\n"); */
        DRMASSERT(FALSE);
        dr = DRM_E_PERF_SCOPING_ERROR;
        goto ErrorExit;
    }

    dwNow = PERF_CURRENT_MICROSECOND_COUNT;

    pScopeContext->m_dwDuration = dwNow - pScopeContext->m_dwDuration - pPerfContext->m_dwLogWriteDuration;

    ChkDR( Perf_Log_Profile(pScopeContext,pPerfContext->m_nCurrScope) );

#if PROFILE_STACK_SIZE
{
    /*Measure the stack usage till this point, and store it if it is max. so far */
    if( (pPerfContext->m_dwStackBase - (DRM_DWORD_PTR)&dr) > pPerfContext->m_dwMaxStackSize)
    {
        pPerfContext->m_dwMaxStackSize = (pPerfContext->m_dwStackBase - (DRM_DWORD_PTR)&dr);
        
    }

    if(pPerfContext->m_nCurrScope == 2)
    {
        if(pPerfContext->m_fpStackSize != OEM_INVALID_HANDLE_VALUE)
        {
            ChkBOOL(Oem_File_Write(pPerfContext->m_fpStackSize, &pScopeContext->m_dwScopeID, SIZEOF(DRM_DWORD), &dwNow), DRM_E_FILEWRITEERROR );
            ChkBOOL(Oem_File_Write(pPerfContext->m_fpStackSize, &pPerfContext->m_dwMaxStackSize, SIZEOF(DRM_DWORD), &dwNow), DRM_E_FILEWRITEERROR );
        }

        /*If the stack usage of this API is greater than that of the max usage recorded so far, save this value */
        if(pPerfContext->m_dwMaxStackSize > pPerfContext->m_dwMaxStackSizeinScenario)
        {
            pPerfContext->m_dwMaxStackSizeinScenario = pPerfContext->m_dwMaxStackSize;
            pPerfContext->m_dwMaxStackSizeScopeID = pScopeContext->m_dwScopeID;
        }

        /*We are at the top level API - so reset the stack base and max stack size*/
        pPerfContext->m_dwMaxStackSize = 0;
        pPerfContext->m_dwStackBase = 0;
    }
}
 
#endif

    pPerfContext->m_nCurrScope--;

ErrorExit:
    if( fResetInProfile )
    {
        pPerfContext->m_bInProfile = FALSE;
    }
    return dr;
}

DRM_RESULT Perf_Enter_Agg_Scope(PERF_AGG_SCOPE_CONTEXT ** ppAggScopeContext, DRM_DWORD dwScopeID)
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    if (*ppAggScopeContext == NULL)
    {
        *ppAggScopeContext = Perf_Allocate_Agg_Scope();

        ChkArg(*ppAggScopeContext != NULL);

        (*ppAggScopeContext)->m_dwScopeID = dwScopeID;
    }

    /* Increment the call count of the scope */
    (*ppAggScopeContext)->m_dwCallCount++;

ErrorExit:    
    return dr;
}

DRM_RESULT Perf_Leave_Agg_Scope(PERF_AGG_SCOPE_CONTEXT * pAggScopeContext, DRM_DWORD dwDuration)
{
    DRM_RESULT dr = DRM_SUCCESS;
    PERF_GLOBAL_CONTEXT *pPerfContext = Oem_Profiling_GetProfileContext();

    ChkArg(pAggScopeContext != NULL);

    ChkArg(pAggScopeContext->m_dwScopeID != 0);

    if (pPerfContext->m_nDetailLevel != 0 && pPerfContext->m_nDetailLevel < pAggScopeContext->m_nDetailLevel)
        goto ErrorExit;

    if (pPerfContext->m_nFeatureSet != 0 && ((pPerfContext->m_nFeatureSet & pAggScopeContext->m_nFeatureSet) == 0))
        goto ErrorExit;

    /* Accumulate the dutation of the scope */
    pAggScopeContext->m_dwDuration += dwDuration;

ErrorExit:
    return dr;
}

DRM_RESULT Perf_Start_Profiling( DRM_VOID *pOEMContext, DRM_CONST_STRING *dstrPerfFileName )
{
    DRM_RESULT dr = DRM_SUCCESS;
    OEM_FILEHDL fp = OEM_INVALID_HANDLE_VALUE;
    DRM_STRING dstrPerfStackSizeLog = EMPTY_DRM_STRING;
    PERF_GLOBAL_CONTEXT *pPerfContext = Oem_Profiling_GetProfileContext();

    if (pPerfContext->m_bRunning)
        goto ErrorExit;

    pPerfContext->m_bInProfile = TRUE;

#if PROFILE_USE_SCOPE
    ChkArg(pPerfContext->m_fp == OEM_INVALID_HANDLE_VALUE);

    fp = Oem_File_Open(pOEMContext,
                      (NULL == dstrPerfFileName? g_rgwchPerfLog:dstrPerfFileName->pwszString), 
                      OEM_GENERIC_WRITE, 
                      OEM_FILE_SHARE_NONE, 
                      (NULL == dstrPerfFileName? OEM_OPEN_ALWAYS:OEM_CREATE_ALWAYS),
                      OEM_ATTRIBUTE_NORMAL);

    if (fp == OEM_INVALID_HANDLE_VALUE)
    {
        if(dstrPerfFileName == NULL)
        {
            fp = Oem_File_Open(pOEMContext,
                          (NULL == dstrPerfFileName? g_rgwchPerfLog:dstrPerfFileName->pwszString), 
                          OEM_GENERIC_WRITE, 
                          OEM_FILE_SHARE_NONE, 
                          OEM_CREATE_NEW, 
                          OEM_ATTRIBUTE_NORMAL);
        }
        ChkBOOL(fp != OEM_INVALID_HANDLE_VALUE, DRM_E_FILEOPEN);                                      
    }
    else
    {
        if (!Oem_File_SetFilePointer(fp, 0, OEM_FILE_END, NULL))
        {
            ChkDR(DRM_E_FILESEEKERROR);
        }
    }

    pPerfContext->m_fp = fp;

#endif    
    
#if PROFILE_USE_AGG_SCOPE
    fp = OEM_INVALID_HANDLE_VALUE;

    fp = Oem_File_Open(pOEMContext,
                      (NULL == dstrPerfFileName? g_rgwchPerfAggLog:dstrPerfFileName->pwszString), 
                      OEM_GENERIC_WRITE, 
                      OEM_FILE_SHARE_NONE, 
                      OEM_OPEN_ALWAYS,
                      OEM_ATTRIBUTE_NORMAL);

    if (fp == OEM_INVALID_HANDLE_VALUE)
    {
        fp = Oem_File_Open(pOEMContext,
                          (NULL == dstrPerfFileName? g_rgwchPerfAggLog:dstrPerfFileName->pwszString), 
                          OEM_GENERIC_WRITE, 
                          OEM_FILE_SHARE_NONE, 
                          OEM_CREATE_NEW, 
                          OEM_ATTRIBUTE_NORMAL);

        ChkBOOL(fp != OEM_INVALID_HANDLE_VALUE, DRM_E_FILEOPEN);                                      
    }
    else
    {
        if (!Oem_File_SetFilePointer(fp, 0, OEM_FILE_END, NULL))
        {
            ChkDR(DRM_E_FILESEEKERROR);
        }
    }

    pPerfContext->m_fpAgg = fp;

#endif

#if PROFILE_USER_DATA
    fp = OEM_INVALID_HANDLE_VALUE;

    fp = Oem_File_Open(pOEMContext,
                      (NULL == dstrPerfFileName? g_rgwchPerfUserDataLog:dstrPerfFileName->pwszString), 
                      OEM_GENERIC_WRITE, 
                      OEM_FILE_SHARE_NONE, 
                      OEM_OPEN_ALWAYS,
                      OEM_ATTRIBUTE_NORMAL);

    if (fp == OEM_INVALID_HANDLE_VALUE)
    {
        fp = Oem_File_Open(pOEMContext,
                          (NULL == dstrPerfFileName? g_rgwchPerfUserDataLog:dstrPerfFileName->pwszString), 
                          OEM_GENERIC_WRITE, 
                          OEM_FILE_SHARE_NONE, 
                          OEM_CREATE_NEW, 
                          OEM_ATTRIBUTE_NORMAL);

        ChkBOOL(fp != OEM_INVALID_HANDLE_VALUE, DRM_E_FILEOPEN);                                      
    }
    else
    {
        if (!Oem_File_SetFilePointer(fp, 0, OEM_FILE_END, NULL))
        {
            ChkDR(DRM_E_FILESEEKERROR);
        }
    }

    pPerfContext->m_fpUserData = fp;

#endif    

#if PROFILE_STACK_SIZE
    fp = OEM_INVALID_HANDLE_VALUE;

    if(dstrPerfFileName != NULL)
    {
        DRM_DWORD dwStackPrefixLength = 0;
        
        ChkDR(DRM_STR_StringCchLengthW(g_rgwchStackSizePrefix, DRM_STRSAFE_MAX_CCH, &dwStackPrefixLength));
        dstrPerfStackSizeLog.cchString = dstrPerfFileName->cchString + dwStackPrefixLength + 1;
        
        ChkMem(dstrPerfStackSizeLog.pwszString = (DRM_WCHAR*)Oem_MemAlloc((dstrPerfStackSizeLog.cchString)* SIZEOF(DRM_WCHAR)));
        ChkDR(DRM_STR_StringCchCopyNW(dstrPerfStackSizeLog.pwszString, dstrPerfStackSizeLog.cchString , g_rgwchStackSizePrefix, dwStackPrefixLength));
        ChkDR(DRM_STR_StringCchCatNW(dstrPerfStackSizeLog.pwszString,dstrPerfStackSizeLog.cchString, dstrPerfFileName->pwszString, dstrPerfFileName->cchString));
    }
        
    
    fp = Oem_File_Open(pOEMContext,
                      (NULL == dstrPerfFileName? g_rgwchPerfStackSizeLog: dstrPerfStackSizeLog.pwszString),
                      OEM_GENERIC_WRITE, 
                      OEM_FILE_SHARE_NONE, 
                      OEM_CREATE_ALWAYS,
                      OEM_ATTRIBUTE_NORMAL);

    if (fp == OEM_INVALID_HANDLE_VALUE)
    {
        fp = Oem_File_Open(pOEMContext,
                      (NULL == dstrPerfFileName? g_rgwchPerfStackSizeLog: dstrPerfStackSizeLog.pwszString),
                      OEM_GENERIC_WRITE, 
                      OEM_FILE_SHARE_NONE, 
                      OEM_CREATE_NEW, 
                      OEM_ATTRIBUTE_NORMAL);

        ChkBOOL(fp != OEM_INVALID_HANDLE_VALUE, DRM_E_FILEOPEN);                                      
    }
    else
    {
        if (!Oem_File_SetFilePointer(fp, 0, OEM_FILE_END, NULL))
        {
            ChkDR(DRM_E_FILESEEKERROR);
        }
    }

    pPerfContext->m_fpStackSize= fp;
#endif

    pPerfContext->m_bRunning = TRUE;
    pPerfContext->m_dwLogWriteDuration = 0;

ErrorExit:
    pPerfContext->m_bInProfile = FALSE;
    SAFE_OEM_FREE(dstrPerfStackSizeLog.pwszString);
    return dr;
}

DRM_RESULT Perf_Stop_Profiling()
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cch = 0;
    PERF_GLOBAL_CONTEXT *pPerfContext = Oem_Profiling_GetProfileContext();

#if PROFILE_USE_AGG_SCOPE    
    DRM_DWORD i = 0;
#endif

    if (!pPerfContext->m_bRunning)
        goto ErrorExit;

    pPerfContext->m_bInProfile = TRUE;
    pPerfContext->m_bRunning = FALSE;

#if PROFILE_USE_SCOPE
    ChkArg(pPerfContext->m_fp != OEM_INVALID_HANDLE_VALUE);

    /* Check whether there is any sample in the cached sample buffer */
    if (pPerfContext->m_dwBufferIndex > 0)
    {
        /* Flush out all the cached samples */
        ChkDR(Oem_File_Write(pPerfContext->m_fp, pPerfContext->m_bBuffer, pPerfContext->m_dwBufferIndex, &cch));
    }

    ChkDR(Oem_File_Close(pPerfContext->m_fp));

    pPerfContext->m_fp = OEM_INVALID_HANDLE_VALUE;
    ZEROMEM(pPerfContext->m_bBuffer,MAX_PROFILE_BUFFER_SIZE);
    pPerfContext->m_dwBufferIndex = 0;
#endif

#if PROFILE_USE_AGG_SCOPE
    /* Write data of all aggregated scopes*/
    for (i = 0; i < pPerfContext->m_nCurrAggScope; i++)
    {
        ChkDR(Oem_File_Write(pPerfContext->m_fpAgg, &pPerfContext->m_AggScopes[i].m_dwScopeID, SIZEOF(DRM_DWORD), &cch));
        ChkDR(Oem_File_Write(pPerfContext->m_fpAgg, &pPerfContext->m_AggScopes[i].m_dwDuration, SIZEOF(DRM_DWORD), &cch));
        ChkDR(Oem_File_Write(pPerfContext->m_fpAgg, &pPerfContext->m_AggScopes[i].m_dwCallCount, SIZEOF(DRM_DWORD), &cch));
    }

    ChkDR(Oem_File_Close(pPerfContext->m_fpAgg));

    pPerfContext->m_fpAgg = OEM_INVALID_HANDLE_VALUE;
#endif

#if PROFILE_USER_DATA
    ChkArg(pPerfContext->m_fpUserData != OEM_INVALID_HANDLE_VALUE);

    /* Check whether there is any user data in the cached user data buffer */
    if (pPerfContext->m_dwBufferUserDataIndex > 0)
    {
        /* Flush out all the cached samples */
        ChkDR(Oem_File_Write(pPerfContext->m_fpUserData, pPerfContext->m_bBufferUserData, pPerfContext->m_dwBufferUserDataIndex, &cch));
    }

    ChkDR(Oem_File_Close(pPerfContext->m_fpUserData));

    pPerfContext->m_fpUserData = OEM_INVALID_HANDLE_VALUE;
    ZEROMEM(pPerfContext->m_bBufferUserData,MAX_PROFILE_BUFFER_SIZE);
    pPerfContext->m_dwBufferUserDataIndex = 0;
#endif

#if PROFILE_STACK_SIZE
    ChkArg(pPerfContext->m_fpStackSize!= OEM_INVALID_HANDLE_VALUE);

     if((pPerfContext->m_dwMaxStackSizeinScenario != 0) && (pPerfContext->m_dwMaxStackSizeScopeID != 0 ))
    {
        ChkDR(Oem_File_Write(pPerfContext->m_fpStackSize,&(pPerfContext->m_dwMaxStackSizeScopeID),SIZEOF(DRM_DWORD),&cch));
        ChkDR(Oem_File_Write(pPerfContext->m_fpStackSize,&(pPerfContext->m_dwMaxStackSizeinScenario),SIZEOF(DRM_DWORD),&cch));
    }
    ChkDR(Oem_File_Close(pPerfContext->m_fpStackSize));
    pPerfContext->m_fpStackSize = OEM_INVALID_HANDLE_VALUE;
#endif

ErrorExit:
    pPerfContext->m_bInProfile = FALSE;
    return dr;
}

DRM_RESULT Perf_Init_ProfileStack()
{
    DRM_RESULT dr = DRM_SUCCESS;

#if PROFILE_STACK_SIZE
    PERF_GLOBAL_CONTEXT *pPerfContext = Oem_Profiling_GetProfileContext();

     pPerfContext->m_dwStackBase = (DRM_DWORD_PTR)&dr;
     pPerfContext->m_dwMaxStackSize = 0;
 #endif

     return dr;      
}

#endif /* #if DRM_SUPPORT_PROFILING */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmpubkeydeviceexclusion.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <drmcommon.h>
#include <drmpubkeydeviceexclusion.h>

ENTER_PK_NAMESPACE_CODE;

/* definition for 2 public keys for verification of Device and WMDRMNET CRL */


const PUBKEY g_pubkeyDeviceRevocation = 
{
    TWO_BYTES(0x15, 0x66), TWO_BYTES(0x90, 0x16), TWO_BYTES(0x30, 0x8C), TWO_BYTES(0x5C, 0xED), TWO_BYTES(0xE9, 0x9F), 
    TWO_BYTES(0xF2, 0xC9), TWO_BYTES(0xC5, 0x39), TWO_BYTES(0x28, 0x00), TWO_BYTES(0x73, 0xD5), TWO_BYTES(0xE6, 0x2D), 
    TWO_BYTES(0xCB, 0x44), TWO_BYTES(0xA4, 0xE3), TWO_BYTES(0xFE, 0xA9), TWO_BYTES(0xAC, 0x2B), TWO_BYTES(0xB4, 0x0E), 
    TWO_BYTES(0x16, 0x6B), TWO_BYTES(0xFE, 0xA0), TWO_BYTES(0xF9, 0x95), TWO_BYTES(0x3D, 0x0A), TWO_BYTES(0x7A, 0x11)
};

const PUBKEY g_pubkeyWMDRMNDRevocation = 
{
    TWO_BYTES(0x17, 0xab), TWO_BYTES(0x8d, 0x43), TWO_BYTES(0xe6, 0x47), TWO_BYTES(0xef, 0xba), TWO_BYTES(0xbd, 0x23), 
    TWO_BYTES(0x44, 0x66), TWO_BYTES(0x9f, 0x64), TWO_BYTES(0x04, 0x84), TWO_BYTES(0xf8, 0xe7), TWO_BYTES(0x71, 0x39), 
    TWO_BYTES(0xc7, 0x07), TWO_BYTES(0x36, 0x25), TWO_BYTES(0x5d, 0xa6), TWO_BYTES(0x5f, 0xba), TWO_BYTES(0xb9, 0x00), 
    TWO_BYTES(0xef, 0x9c), TWO_BYTES(0x89, 0x6b), TWO_BYTES(0xf2, 0xc4), TWO_BYTES(0x81, 0x1d), TWO_BYTES(0xa2, 0x12)
};

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmptrlist.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcrt.h>
#include <drmptrlist.h>

ENTER_PK_NAMESPACE_CODE;


DRM_API DRM_RESULT DRM_CALL DRM_PtrList_Initialize(
    __out       PTR_LIST  * const f_pPtrList,
    __in const  DRM_DWORD         f_dwSize
)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( NULL != f_pPtrList );

    f_pPtrList->pHead         = NULL;
    f_pPtrList->dwMaxSize     = f_dwSize;
    f_pPtrList->dwCurrentSize = 0;

 ErrorExit:
    return dr;
}


DRM_API DRM_VOID DRM_CALL DRM_PtrList_Uninitialize(
    __out PTR_LIST * const f_pPtrList
)
{
    if ( NULL != f_pPtrList )
    {
        DRM_VOID  *pbData;

        while ( f_pPtrList->dwCurrentSize > 0 )
        {
            DRM_PtrList_RemoveHead(f_pPtrList, &pbData);
        }

        ZEROMEM(f_pPtrList, SIZEOF(PTR_LIST));
    }

    return;
}


DRM_API DRM_RESULT DRM_CALL DRM_PtrList_GetFront(
    __in const PTR_LIST  * const f_pPtrList,
    __out      DRM_VOID        **f_ppbData
)
{
    DRM_RESULT dr = DRM_SUCCESS;
    PTR_LIST_ENTRY *pEntry;

    ChkArg( NULL != f_pPtrList );
    ChkBOOL(f_pPtrList->dwCurrentSize > 0, DRM_E_FAIL);

    pEntry     = f_pPtrList->pHead;
    *f_ppbData = pEntry->pbData;

 ErrorExit:
    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_PtrList_RemoveHead(
    __in    PTR_LIST  * const f_pPtrList,
    __out   DRM_VOID        **f_ppbData
)
{
    DRM_RESULT dr = DRM_SUCCESS;
    PTR_LIST_ENTRY *pEntry;

    ChkArg( NULL != f_pPtrList );
    ChkBOOL(f_pPtrList->dwCurrentSize > 0, DRM_E_FAIL);

    pEntry = f_pPtrList->pHead;
    f_pPtrList->pHead = f_pPtrList->pHead->pNext;
    *f_ppbData = pEntry->pbData;
    SAFE_OEM_FREE( pEntry );
    f_pPtrList->dwCurrentSize--;

 ErrorExit:

    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_PtrList_AddTail(
    __in  PTR_LIST * const f_pPtrList,
    __in  DRM_VOID * const f_pbData
)
{
    DRM_RESULT dr = DRM_SUCCESS;
    PTR_LIST_ENTRY *pEntry;
    PTR_LIST_ENTRY *pNew = NULL;

    ChkArg( NULL != f_pPtrList );
    ChkBOOL(f_pPtrList->dwCurrentSize < f_pPtrList->dwMaxSize, DRM_E_FAIL);

    pNew = (PTR_LIST_ENTRY *) Oem_MemAlloc(SIZEOF(PTR_LIST_ENTRY));
    ChkMem(pNew);

    pNew->pbData = f_pbData;
    pNew->pNext = NULL;
    f_pPtrList->dwCurrentSize++;

    if ( NULL == f_pPtrList->pHead )
    {
        f_pPtrList->pHead = pNew;
    }
    else
    {
        pEntry = f_pPtrList->pHead;
        while( NULL != pEntry->pNext )
        {
            pEntry = pEntry->pNext;
        }
        pEntry->pNext = pNew;
    }

 ErrorExit:
    if ( DRM_FAILED(dr) )
    {
        SAFE_OEM_FREE( pNew );
    }

    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_PtrList_GetTail(
    __in const   PTR_LIST * const f_pPtrList,
    __out        DRM_VOID       **f_ppbData
)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( NULL != f_pPtrList );

    if ( NULL == f_pPtrList->pHead )
    {
        ChkDR( DRM_E_FAIL );
    }
    else
    {
        PTR_LIST_ENTRY *pEntry;
        pEntry = f_pPtrList->pHead;
        while( NULL != pEntry->pNext )
        {
            pEntry = pEntry->pNext;
        }
        *f_ppbData = pEntry->pbData;
    }

 ErrorExit:
    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_PtrList_GetByIndex(
    __in const PTR_LIST * const   f_pPtrList,
    __in const DRM_DWORD          f_dwIndex,
    __out      DRM_VOID         **f_ppbData
)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( NULL != f_pPtrList );

    if ( NULL == f_pPtrList->pHead || f_dwIndex >= f_pPtrList->dwCurrentSize )
    {
        ChkDR( DRM_E_FAIL );
    }
    else
    {
        PTR_LIST_ENTRY *pEntry;
        DRM_DWORD i = 0;

        pEntry = f_pPtrList->pHead;
        while( NULL != pEntry->pNext && i < f_dwIndex )
        {
            i++;
            pEntry = pEntry->pNext;
        }
        DRMASSERT( NULL != pEntry );
        *f_ppbData = pEntry->pbData;
    }

 ErrorExit:
    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_PtrList_RemoveByIndex(
    __in       PTR_LIST * const   f_pPtrList,
    __in const DRM_DWORD          f_dwIndex,
    __out      DRM_VOID         **f_ppbData
)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( NULL != f_pPtrList );

    if ( NULL == f_pPtrList->pHead || f_dwIndex >= f_pPtrList->dwCurrentSize )
    {
        ChkDR( DRM_E_FAIL );
    }
    else
    {
        PTR_LIST_ENTRY *pEntry;
        PTR_LIST_ENTRY *pPrevious = NULL;
        DRM_DWORD i = 0;

        pEntry = f_pPtrList->pHead;
        while( NULL != pEntry->pNext && i < f_dwIndex )
        {
            i++;
            pPrevious = pEntry;
            pEntry = pEntry->pNext;
        }
        DRMASSERT( NULL != pEntry );
        *f_ppbData = pEntry->pbData;

        if ( NULL == pPrevious )
        {
            f_pPtrList->pHead = f_pPtrList->pHead->pNext;
        }
        else
        {
            pPrevious->pNext = pEntry->pNext;
        }

        SAFE_OEM_FREE( pEntry );
        f_pPtrList->dwCurrentSize--;
    }

 ErrorExit:
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmplayreadyobj.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmplayreadyobj.h>
#include <drmxmlbuilder.h>
#include <drmxmlparser.h>
#include <drmcontract.h>

ENTER_PK_NAMESPACE_CODE;

/* "<WRMHEADER xmlns="http://schemas.microsoft.com/DRM/2007/03/PlayReadyHeader" version="4.0.0.0">" */
static const DRM_WCHAR g_rgwchOpenNodeWRMHeader[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( 'W', '\0' ), ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( 'M', '\0' ), 
    ONE_WCHAR( 'H', '\0' ), ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'D', '\0' ), 
    ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( ' ', '\0' ), ONE_WCHAR( 'x', '\0' ), 
    ONE_WCHAR( 'm', '\0' ), ONE_WCHAR( 'l', '\0' ), ONE_WCHAR( 'n', '\0' ), ONE_WCHAR( 's', '\0' ),
    ONE_WCHAR( '=', '\0' ), ONE_WCHAR( '"', '\0' ), ONE_WCHAR( 'h', '\0' ), ONE_WCHAR( 't', '\0' ),
    ONE_WCHAR( 't', '\0' ), ONE_WCHAR( 'p', '\0' ), ONE_WCHAR( ':', '\0' ), ONE_WCHAR( '/', '\0' ),
    ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 's', '\0' ), ONE_WCHAR( 'c', '\0' ), ONE_WCHAR( 'h', '\0' ),
    ONE_WCHAR( 'e', '\0' ), ONE_WCHAR( 'm', '\0' ), ONE_WCHAR( 'a', '\0' ), ONE_WCHAR( 's', '\0' ),
    ONE_WCHAR( '.', '\0' ), ONE_WCHAR( 'm', '\0' ), ONE_WCHAR( 'i', '\0' ), ONE_WCHAR( 'c', '\0' ),
    ONE_WCHAR( 'r', '\0' ), ONE_WCHAR( 'o', '\0' ), ONE_WCHAR( 's', '\0' ), ONE_WCHAR( 'o', '\0' ),
    ONE_WCHAR( 'f', '\0' ), ONE_WCHAR( 't', '\0' ), ONE_WCHAR( '.', '\0' ), ONE_WCHAR( 'c', '\0' ),
    ONE_WCHAR( 'o', '\0' ), ONE_WCHAR( 'm', '\0' ), ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'D', '\0' ),
    ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( 'M', '\0' ), ONE_WCHAR( '/', '\0' ), ONE_WCHAR( '2', '\0' ),
    ONE_WCHAR( '0', '\0' ), ONE_WCHAR( '0', '\0' ), ONE_WCHAR( '7', '\0' ), ONE_WCHAR( '/', '\0' ),
    ONE_WCHAR( '0', '\0' ), ONE_WCHAR( '3', '\0' ), ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'P', '\0' ),
    ONE_WCHAR( 'l', '\0' ), ONE_WCHAR( 'a', '\0' ), ONE_WCHAR( 'y', '\0' ), ONE_WCHAR( 'R', '\0' ),
    ONE_WCHAR( 'e', '\0' ), ONE_WCHAR( 'a', '\0' ), ONE_WCHAR( 'd', '\0' ), ONE_WCHAR( 'y', '\0' ),
    ONE_WCHAR( 'H', '\0' ), ONE_WCHAR( 'e', '\0' ), ONE_WCHAR( 'a', '\0' ), ONE_WCHAR( 'd', '\0' ),
    ONE_WCHAR( 'e', '\0' ), ONE_WCHAR( 'r', '\0' ), ONE_WCHAR( '"', '\0' ), ONE_WCHAR( ' ', '\0' ),
    ONE_WCHAR( 'v', '\0' ), ONE_WCHAR( 'e', '\0' ), ONE_WCHAR( 'r', '\0' ), ONE_WCHAR( 's', '\0' ),
    ONE_WCHAR( 'i', '\0' ), ONE_WCHAR( 'o', '\0' ), ONE_WCHAR( 'n', '\0' ), ONE_WCHAR( '=', '\0' ),
    ONE_WCHAR( '"', '\0' ), ONE_WCHAR( '4', '\0' ), ONE_WCHAR( '.', '\0' ), ONE_WCHAR( '0', '\0' ),
    ONE_WCHAR( '.', '\0' ), ONE_WCHAR( '0', '\0' ), ONE_WCHAR( '.', '\0' ), ONE_WCHAR( '0', '\0' ),
    ONE_WCHAR( '"', '\0' ), ONE_WCHAR( '>', '\0' ) };
    
/* "</WRMHEADER>" */
static const DRM_WCHAR g_rgwchCloseNodeWRMHeader[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'W', '\0' ), ONE_WCHAR( 'R', '\0' ),
    ONE_WCHAR( 'M', '\0' ), ONE_WCHAR( 'H', '\0' ), ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'A', '\0' ),
    ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( '>', '\0' ) };

/* "<DATA>" */
static const DRM_WCHAR g_rgwchOpenNodeData[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'T', '\0' ),
    ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( '>', '\0' ) };

/* "</DATA>" */
static const DRM_WCHAR g_rgwchCloseNodeData[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( 'A', '\0' ),
    ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( '>', '\0' ) };

/* "<KID>" */
static const DRM_WCHAR g_rgwchOpenNodeKID[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( 'K', '\0' ), ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'D', '\0' ),
    ONE_WCHAR( '>', '\0' ) };

/* "</KID>" */
static const DRM_WCHAR g_rgwchCloseNodeKID[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'K', '\0' ), ONE_WCHAR( 'I', '\0' ),
    ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( '>', '\0' ) };

/* "<CHECKSUM>" */
static const DRM_WCHAR g_rgwchOpenNodeChecksum[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'H', '\0' ), ONE_WCHAR( 'E', '\0' ),
    ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'K', '\0' ), ONE_WCHAR( 'S', '\0' ), ONE_WCHAR( 'U', '\0' ),
    ONE_WCHAR( 'M', '\0' ), ONE_WCHAR( '>', '\0' ) };

/* "</CHECKSUM>" */
static const DRM_WCHAR g_rgwchCloseNodeChecksum[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'H', '\0' ),
    ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'K', '\0' ), ONE_WCHAR( 'S', '\0' ),
    ONE_WCHAR( 'U', '\0' ), ONE_WCHAR( 'M', '\0' ), ONE_WCHAR( '>', '\0' ) };

/* "<LA_URL>" */
static const DRM_WCHAR g_rgwchOpenNodeLAURL[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( '_', '\0' ),
    ONE_WCHAR( 'U', '\0' ), ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( '>', '\0' ) }; 

/* "</LA_URL>" */
static const DRM_WCHAR g_rgwchCloseNodeLAURL[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( 'A', '\0' ),
    ONE_WCHAR( '_', '\0' ), ONE_WCHAR( 'U', '\0' ), ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( 'L', '\0' ),
    ONE_WCHAR( '>', '\0' ) }; 

/* "<LUI_URL>" */
static const DRM_WCHAR g_rgwchOpenNodeLUIURL[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( 'U', '\0' ), ONE_WCHAR( 'I', '\0' ),
    ONE_WCHAR( '_', '\0' ), ONE_WCHAR( 'U', '\0' ), ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( 'L', '\0' ),
    ONE_WCHAR( '>', '\0' ) }; 

/* "</LUI_URL>" */
static const DRM_WCHAR g_rgwchCloseNodeLUIURL[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( 'U', '\0' ),
    ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( '_', '\0' ), ONE_WCHAR( 'U', '\0' ), ONE_WCHAR( 'R', '\0' ),
    ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( '>', '\0' ) }; 

/* "<DS_ID>" */
static const DRM_WCHAR g_rgwchOpenNodeDSID[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( 'S', '\0' ), ONE_WCHAR( '_', '\0' ),
    ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( '>', '\0' ) }; 

/* "</DS_ID>" */
static const DRM_WCHAR g_rgwchCloseNodeDSID[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( 'S', '\0' ),
    ONE_WCHAR( '_', '\0' ), ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( '>', '\0' ) }; 

/* "<PROTECTINFO>" */
static const DRM_WCHAR g_rgwchOpenNodeProtectInfo[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( 'P', '\0' ), ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( 'O', '\0' ),
    ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'T', '\0' ),
    ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'N', '\0' ), ONE_WCHAR( 'F', '\0' ), ONE_WCHAR( 'O', '\0' ),
    ONE_WCHAR( '>', '\0' ) };

/* "</PROTECTINFO>" */
static const DRM_WCHAR g_rgwchCloseNodeProtectInfo[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'P', '\0' ), ONE_WCHAR( 'R', '\0' ),
    ONE_WCHAR( 'O', '\0' ), ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'C', '\0' ),
    ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'N', '\0' ), ONE_WCHAR( 'F', '\0' ),
    ONE_WCHAR( 'O', '\0' ), ONE_WCHAR( '>', '\0' ) };

/* "<KEYLEN>7</KEYLEN> */
static const DRM_WCHAR g_rgwchNodesKeyLen7[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( 'K', '\0' ), ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'Y', '\0' ),
    ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'N', '\0' ), ONE_WCHAR( '>', '\0' ),
    ONE_WCHAR( '7', '\0' ), ONE_WCHAR( '<', '\0' ), ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'K', '\0' ),
    ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'Y', '\0' ), ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( 'E', '\0' ),
    ONE_WCHAR( 'N', '\0' ), ONE_WCHAR( '>', '\0' ) };

/* "<ALGID>COCKTAIL</ALGID>" */
static const DRM_WCHAR g_rgwchNodesAlgIDCocktail[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( 'G', '\0' ),
    ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( '>', '\0' ), ONE_WCHAR( 'C', '\0' ),
    ONE_WCHAR( 'O', '\0' ), ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'K', '\0' ), ONE_WCHAR( 'T', '\0' ),
    ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( '<', '\0' ),
    ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( 'G', '\0' ),
    ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( '>', '\0' ) };

/* "<CUSTOMATTRIBUTES xmlns="">" */
static const DRM_WCHAR g_rgwchOpenNodeCustomAttributes[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'U', '\0' ), ONE_WCHAR( 'S', '\0' ),
    ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'O', '\0' ), ONE_WCHAR( 'M', '\0' ), ONE_WCHAR( 'A', '\0' ),
    ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( 'I', '\0' ),
    ONE_WCHAR( 'B', '\0' ), ONE_WCHAR( 'U', '\0' ), ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'E', '\0' ),
    ONE_WCHAR( 'S', '\0' ), ONE_WCHAR( ' ', '\0' ), ONE_WCHAR( 'x', '\0' ), ONE_WCHAR( 'm', '\0' ),
    ONE_WCHAR( 'l', '\0' ), ONE_WCHAR( 'n', '\0' ), ONE_WCHAR( 's', '\0' ), ONE_WCHAR( '=', '\0' ),
    ONE_WCHAR( '"', '\0' ), ONE_WCHAR( '"', '\0' ), ONE_WCHAR( '>', '\0' ) };

/* "</CUSTOMATTRIBUTES>" */
static const DRM_WCHAR g_rgwchCloseNodeCustomAttributes[] = {
    ONE_WCHAR( '<', '\0' ), ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'U', '\0' ),
    ONE_WCHAR( 'S', '\0' ), ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'O', '\0' ), ONE_WCHAR( 'M', '\0' ),
    ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'R', '\0' ),
    ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'B', '\0' ), ONE_WCHAR( 'U', '\0' ), ONE_WCHAR( 'T', '\0' ),
    ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'S', '\0' ), ONE_WCHAR( '>', '\0' ) };

/* "2.0.0.0" */
static const DRM_WCHAR g_rgwchV2[] = {
    ONE_WCHAR( '2', '\0' ), ONE_WCHAR( '.', '\0' ), ONE_WCHAR( '0', '\0' ), ONE_WCHAR( '.', '\0' ),
    ONE_WCHAR( '0', '\0' ), ONE_WCHAR( '.', '\0' ), ONE_WCHAR( '0', '\0' ), ONE_WCHAR( '\0', '\0' ) }; 

/* "4.0.0.0" */
static const DRM_WCHAR g_rgwchV4[] = {
    ONE_WCHAR( '4', '\0' ), ONE_WCHAR( '.', '\0' ), ONE_WCHAR( '0', '\0' ), ONE_WCHAR( '.', '\0' ),
    ONE_WCHAR( '0', '\0' ), ONE_WCHAR( '.', '\0' ), ONE_WCHAR( '0', '\0' ), ONE_WCHAR( '\0', '\0' ) }; 

/* "version" */
static const DRM_WCHAR g_rgwchVersion[] = {
    ONE_WCHAR( 'v', '\0' ), ONE_WCHAR( 'e', '\0' ), ONE_WCHAR( 'r', '\0' ), ONE_WCHAR( 's', '\0' ),
    ONE_WCHAR( 'i', '\0' ), ONE_WCHAR( 'o', '\0' ), ONE_WCHAR( 'n', '\0' ), ONE_WCHAR( '\0', '\0' ) };

/* "WRMHEADER" */
static const DRM_WCHAR g_rgwchWRMHeader[] = {
    ONE_WCHAR( 'W', '\0' ), ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( 'M', '\0' ), ONE_WCHAR( 'H', '\0' ),
    ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( 'E', '\0' ),
    ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( '\0', '\0' ) };

/* "KID" */
static const DRM_WCHAR g_rgwchKID[] = {
    ONE_WCHAR( 'K', '\0' ), ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( '\0', '\0' ) }; 

/* "CHECKSUM" */
static const DRM_WCHAR g_rgwchChecksum[] = {
    ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'H', '\0' ), ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'C', '\0' ),
    ONE_WCHAR( 'K', '\0' ), ONE_WCHAR( 'S', '\0' ), ONE_WCHAR( 'U', '\0' ), ONE_WCHAR( 'M', '\0' ),
    ONE_WCHAR( '\0', '\0' ) };

/* "DATA" */
static const DRM_WCHAR g_rgwchData[] = {
    ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'A', '\0' ),
    ONE_WCHAR( '\0', '\0' ) };

/* "LAINFO" */
static const DRM_WCHAR g_rgwchLAInfo[] = {
    ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'N', '\0' ),
    ONE_WCHAR( 'F', '\0' ), ONE_WCHAR( 'O', '\0' ), ONE_WCHAR( '\0', '\0' ) };

/* "PROTECTINFO" */
static const DRM_WCHAR g_rgwchProtectInfo[] = {
    ONE_WCHAR( 'P', '\0' ), ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( 'O', '\0' ), ONE_WCHAR( 'T', '\0' ),
    ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'I', '\0' ),
    ONE_WCHAR( 'N', '\0' ), ONE_WCHAR( 'F', '\0' ), ONE_WCHAR( 'O', '\0' ), ONE_WCHAR( '\0', '\0' ) };

/* "CONTENTXML" */
static const DRM_WCHAR g_rgwchContentXML[] = {
    ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'O', '\0' ), ONE_WCHAR( 'N', '\0' ), ONE_WCHAR( 'T', '\0' ),
    ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'N', '\0' ), ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'X', '\0' ),
    ONE_WCHAR( 'M', '\0' ), ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( '\0', '\0' ) };

/* "SIGNATURE" */
static const DRM_WCHAR g_rgwchSignature[] = {
    ONE_WCHAR( 'S', '\0' ), ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'G', '\0' ), ONE_WCHAR( 'N', '\0' ),
    ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'U', '\0' ), ONE_WCHAR( 'R', '\0' ),
    ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( '\0', '\0' ) };

static const DRM_CONST_STRING g_rgdstrV2[]          = CREATE_DRM_STRING( g_rgwchV2 );
static const DRM_CONST_STRING g_rgdstrV4[]          = CREATE_DRM_STRING( g_rgwchV4 );
static const DRM_CONST_STRING g_rgdstrVersion[]     = CREATE_DRM_STRING( g_rgwchVersion );
static const DRM_CONST_STRING g_rgdstrWRMHEADER[]   = CREATE_DRM_STRING( g_rgwchWRMHeader );
static const DRM_CONST_STRING g_rgdstrKID[]         = CREATE_DRM_STRING( g_rgwchKID );
static const DRM_CONST_STRING g_rgdstrChecksum[]    = CREATE_DRM_STRING( g_rgwchChecksum );
static const DRM_CONST_STRING g_rgdstrData[]        = CREATE_DRM_STRING( g_rgwchData );
static const DRM_CONST_STRING g_rgdstrLAInfo[]      = CREATE_DRM_STRING( g_rgwchLAInfo );
static const DRM_CONST_STRING g_rgdstrProtectInfo[] = CREATE_DRM_STRING( g_rgwchProtectInfo );
static const DRM_CONST_STRING g_rgdstrContentXML[]  = CREATE_DRM_STRING( g_rgwchContentXML );
static const DRM_CONST_STRING g_rgdstrSignature[]   = CREATE_DRM_STRING( g_rgwchSignature );

/* "DATA/PROTECTINFO/ALGID" */
static const DRM_WCHAR g_rgwchAlgorithmPath[] = {
    ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'A', '\0' ),
    ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'P', '\0' ), ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( 'O', '\0' ),
    ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'T', '\0' ),
    ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'N', '\0' ), ONE_WCHAR( 'F', '\0' ), ONE_WCHAR( 'O', '\0' ),
    ONE_WCHAR( '/', '\0' ), ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'L', '\0' ), ONE_WCHAR( 'G', '\0' ),
    ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'D', '\0' ), ONE_WCHAR( '\0', '\0' ) };

static const DRM_CONST_STRING g_dstrAlgorithmPath = CREATE_DRM_STRING( g_rgwchAlgorithmPath );

/* "COCKTAIL" */
static const DRM_WCHAR g_rgwchCOCKTAIL[] = {
    ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'O', '\0' ), ONE_WCHAR( 'C', '\0' ), ONE_WCHAR( 'K', '\0' ),
    ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'I', '\0' ), ONE_WCHAR( 'L', '\0' ),
    ONE_WCHAR( '\0', '\0' ) };

static const DRM_CONST_STRING g_dstrCOCKTAIL = CREATE_DRM_STRING( g_rgwchCOCKTAIL );

/* "AESCTR" */
static const DRM_WCHAR g_rgwchAESCTR[] = {
    ONE_WCHAR( 'A', '\0' ), ONE_WCHAR( 'E', '\0' ), ONE_WCHAR( 'S', '\0' ), ONE_WCHAR( 'C', '\0' ),
    ONE_WCHAR( 'T', '\0' ), ONE_WCHAR( 'R', '\0' ), ONE_WCHAR( '\0', '\0' ) };

static const DRM_CONST_STRING g_dstrAESCTR = CREATE_DRM_STRING( g_rgwchAESCTR );

#define V2_BOM ( 0xFEFF )
#define SIZEOF_V2_BOM ( SIZEOF( DRM_WORD ) )
#define STR_SIZE( x ) ( SIZEOF( x ) / SIZEOF( x[ 0 ] ) - 1 )
#define RECORDTYPE_WRMHEADER ( 1 )

#define SAFE_MEMCPY( to, toSize, toIndex, from, fromSize )                      \
do                                                                              \
{                                                                               \
    ChkBOOL( ( toIndex ) + ( fromSize ) <= ( toSize ), DRM_E_BUFFERTOOSMALL );  \
    MEMCPY( ( to ) + ( toIndex ), ( from ), ( fromSize ) );                     \
}                                                                               \
while ( FALSE )

typedef struct __tagV4Header
{
    DRM_DWORD m_cbSize;
    DRM_WORD  m_coRecordCount;
    DRM_WORD  m_wRecordType;
    DRM_WORD  m_wRecordLength;
} V4Header;

DRM_RESULT _GetCustAttributes( 
    __in_ecount( 1 )  DRM_CONST_STRING *f_pstrRMHeader,
    __out_opt         DRM_CONST_STRING *f_pstrDestination,    
    __out_ecount( 1 ) DRM_DWORD        *f_pcchCustAttrLen );

DRM_BOOL _IsCustomAttrNode( 
    __in_ecount( 1 )  DRM_CONST_STRING *f_pstrNodeTag );

DRMFORCEINLINE DRM_BOOL _SafeStrCmp( 
    __in_ecount( 1 ) const DRM_CONST_STRING *f_pstrLHS,
    __in_ecount( 1 ) const DRM_CONST_STRING *f_pstrRHS );


/**********************************************************************
**
** Function:    _GetCustAttributes
**
** Synopsis:    Gets len in wchars of all the custom attributes in a v2 header
**
** Arguments:
** [f_pstrRMHeader]:    -- Pointer to a RMHeader string.
** [f_pstrDestination]  -- Optional output parameter, if specified, then the 
**                         custom attributes will be copied to this string.
** [f_pcchCustAttrLen]  -- If DRM_SUCCESS, then the number of wchars written to param 2.
**                         If DRM_E_BUFFERTOOSMALL, then size required to write.
**
** Returns:     DRM_SUCCESS - on success AND true.
**              DRM_E_ error message on other failure.
**              Sets f_pcchCustAttrLen, could be set to 0.
**
**********************************************************************/
DRM_RESULT _GetCustAttributes( 
    __in_ecount( 1 )  DRM_CONST_STRING *f_pstrRMHeader,
    __out_opt         DRM_CONST_STRING *f_pstrDestination,    
    __out_ecount( 1 ) DRM_DWORD        *f_pcchWritten )
{
    DRM_RESULT       dr      = DRM_SUCCESS;
    DRM_DWORD        i       = 0;
    DRM_CONST_STRING strData = EMPTY_DRM_STRING;
    DRM_DWORD        cchLen  = 0;

    ChkArg( NULL != f_pcchWritten );
    ChkArg( NULL != f_pstrRMHeader );
    ChkArg( NULL != f_pstrRMHeader->pwszString );
    ChkArg( 0    != f_pstrRMHeader->cchString );

    /*
    ** All custom attributes sit under the DATA node, so get that node now.
    */
    ChkDR( DRM_XML_GetSubNode(  f_pstrRMHeader, 
                                g_rgdstrData, 
                                NULL, 
                                NULL,
                                0,
                                NULL,
                               &strData,
                                1 ) );

    *f_pcchWritten = 0; 

    /*
    ** Now loop through all sub nodes.
    */
    while( 0 != strData.cchString )
    {
        DRM_CONST_STRING strNode = EMPTY_DRM_STRING;
        DRM_CONST_STRING strTag  = EMPTY_DRM_STRING;
        DRM_BOOL         fIsLeaf = FALSE;
        
        /*
        ** Get the next node, even though we don't use all the params, they have to be supplied.
        */
        ChkDR( DRM_XML_EnumNextSubNode( &strData, 
                                        &strTag, 
                                        &strNode, 
                                         NULL,
                                         NULL,
                                         NULL,
                                        &fIsLeaf,
                                        0 ) );

        /*
        ** if this was detected to be a custom data node, then lets add the len to our output
        */
        if ( _IsCustomAttrNode( &strTag ) )
        {
            cchLen += strNode.cchString;

            if (    NULL != f_pstrDestination 
                 && NULL != f_pstrDestination->pwszString
                 && cchLen <= f_pstrDestination->cchString )
            {
                SAFE_MEMCPY( ( DRM_BYTE* )f_pstrDestination->pwszString, 
                               f_pstrDestination->cchString * SIZEOF( DRM_WCHAR ), 
                               i,
                             ( DRM_BYTE* )strNode.pwszString,
                               strNode.cchString * SIZEOF( DRM_WCHAR ) );
                i = cchLen * SIZEOF( DRM_WCHAR );
            }
        }

        /*
        ** Setup of next iteration, increment our pointer to the end of the node we just read,
        ** decrement the len of our array by the amount we are moving forward.
        */
        strData.pwszString += strNode.cchString;
        ChkOverflow( strData.cchString, strData.cchString - strNode.cchString ); /* underflow check */
        strData.cchString -= strNode.cchString;    
    }

    if (      0 != cchLen 
         && ( NULL == f_pstrDestination || cchLen > f_pstrDestination->cchString ) )
    {
        dr = DRM_E_BUFFERTOOSMALL;
    }

    *f_pcchWritten = cchLen;
        

ErrorExit:
   return dr; 
}

/**********************************************************************
**
** Function:    _IsCustomAttrNode
**
** Synopsis:    Tells if we are a custom attribute node or not.
**
** Arguments:
** [f_pstrNodeTag]  -- The node tag to be tested.
**
** Returns:     TRUE  if we are a custom attribute node tag.
**              FALSE if we are not or if invalid arg.
**
**********************************************************************/
DRM_BOOL _IsCustomAttrNode( 
    __in_ecount( 1 )  DRM_CONST_STRING *f_pstrNodeTag )
{
    if (    f_pstrNodeTag             != NULL
         && f_pstrNodeTag->pwszString != NULL 
         && f_pstrNodeTag->cchString  != 0 
         && !_SafeStrCmp( f_pstrNodeTag, g_rgdstrSignature )
         && !_SafeStrCmp( f_pstrNodeTag, g_rgdstrContentXML )
         && !_SafeStrCmp( f_pstrNodeTag, g_rgdstrProtectInfo )
         && !_SafeStrCmp( f_pstrNodeTag, g_rgdstrLAInfo )
         && !_SafeStrCmp( f_pstrNodeTag, g_rgdstrData )
         && !_SafeStrCmp( f_pstrNodeTag, g_rgdstrChecksum )
         && !_SafeStrCmp( f_pstrNodeTag, g_rgdstrKID ) )
    {
        return TRUE;
    }      

    return FALSE;
}

/**********************************************************************
**
** Function:    _SafeStrCmp
**
** Synopsis:    Performs a string compare on two DRM_STRINGs
**
** Arguments:
** [f_pstrLHS]  -- The 1st string to compare.
** [f_pstrLHS]  -- The 2nd string to compare.
**
** Returns:     TRUE  They contain the exact same string and length
**              FALSE on mismatched strings/lengths or bad args.
**
**********************************************************************/
DRMFORCEINLINE DRM_BOOL _SafeStrCmp( 
    __in_ecount( 1 ) const DRM_CONST_STRING *f_pstrLHS,
    __in_ecount( 1 ) const DRM_CONST_STRING *f_pstrRHS )
{
    if (    NULL == f_pstrLHS 
         || NULL == f_pstrRHS
         || f_pstrLHS->cchString != f_pstrRHS->cchString )
    {
        return FALSE;
    }
    
    return 0 == MEMCMP( f_pstrLHS->pwszString, 
                        f_pstrRHS->pwszString, 
                        f_pstrLHS->cchString * SIZEOF( DRM_WCHAR ) );
}

/**********************************************************************
**
** Function:    DRM_PRO_GetRMHeaderVersion
**
** Synopsis:    Gets the version of the RMHEADER passed in. It currently
**              handles WMDRM header ( with or without BOM ) and  PlayReady
**              header ( wrapped in a PlayReady object record ) only.
**
** Arguments:
** [f_pbHeader]     -- WMDRM header to be tested.
** [f_cbHeader]     -- Size of f_pbHeader in bytes.
** [f_peVersion]    -- Return value of the version type, must not be null.
**
** Returns:     DRM_SUCCESS - on success.
**              DRM_E_ error message on other failure.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_PRO_GetRMHeaderVersion(
    __in_bcount( f_cbHeader ) const DRM_BYTE        *f_pbHeader,
    __in                      const DRM_DWORD        f_cbHeader,
    __out_ecount( 1 )               eRMHeaderVersion *f_peVersion )
{
    DRM_RESULT dr       = DRM_SUCCESS;
    V4Header  *poHeader = ( V4Header * )f_pbHeader;
    DRM_CONST_STRING strHeader = EMPTY_DRM_STRING;
    DRM_CONST_STRING strNode   = EMPTY_DRM_STRING;

    ChkArg( NULL != f_pbHeader );
    ChkArg( NULL != f_peVersion );

    /* Minimum size for safe PlayReady header checks. */
    ChkArg( SIZEOF( V4Header ) < f_cbHeader );

    *f_peVersion = RM_HEADER_VERSION_UNKNOWN;

    /*
    ** Look for the v2 or V4 header. If one is found then double check that
    ** the version field in the WRMHEADER tag matches to the correct version.
    */
    if ( RECORDTYPE_WRMHEADER == poHeader->m_wRecordType )
    {
        DRM_CONST_STRING strAttr = EMPTY_DRM_STRING;
        
        ChkBOOL( poHeader->m_cbSize <= f_cbHeader, DRM_E_INVALID_PLAYREADY_OBJECT );
        ChkBOOL( poHeader->m_wRecordLength <= f_cbHeader - SIZEOF( V4Header ), 
                 DRM_E_INVALID_PLAYREADY_OBJECT );
        
        /*
        ** Skip the v4 header struct when initializing string.
        */      
        strHeader.pwszString = ( DRM_WCHAR* )( f_pbHeader + SIZEOF( V4Header ) );
        strHeader.cchString  = ( poHeader->m_wRecordLength / SIZEOF( DRM_WCHAR ) );
        
        /*
        ** Get the version attribute out of the WRMHEADER node, it should be 4.0.0.0, if it is
        ** then set the detected version accordingly.
        */
        if( DRM_SUCCEEDED( DRM_XML_GetSubNode( &strHeader,
                                                g_rgdstrWRMHEADER,
                                                NULL,
                                                NULL,
                                                0,
                                               &strNode,
                                                NULL,
                                                0 ) ) )
        {
            if ( DRM_SUCCEEDED( DRM_XML_GetNodeAttribute( &strNode, g_rgdstrVersion, &strAttr ) ) )
            {
                if ( DRM_UTL_DSTRStringsEqual( g_rgdstrV4, &strAttr ) )
                {
                    *f_peVersion = RM_HEADER_VERSION_4;
                }
            }
        }
    }
    else
    {
        if ( V2_BOM == ( ( DRM_WCHAR* )f_pbHeader )[ 0 ] )
        {
            /* Skip the BOM, 2 bytes or 1 wchar. */
            strHeader.pwszString = ( DRM_WCHAR* )( f_pbHeader + SIZEOF_V2_BOM );
            strHeader.cchString  = ( f_cbHeader - SIZEOF_V2_BOM ) / SIZEOF( DRM_WCHAR );
        }
        else
        {
            strHeader.pwszString = ( DRM_WCHAR* )f_pbHeader;
            strHeader.cchString  = f_cbHeader / SIZEOF( DRM_WCHAR );
        }
    
        /*
        ** Get the version attribute out of the WRMHEADER node. It should be 2.0.0.0, if it is
        ** then set the detected version accordingly.
        */
        if( DRM_SUCCEEDED( DRM_XML_GetSubNode( &strHeader,
                                                g_rgdstrWRMHEADER,
                                                g_rgdstrVersion,
                                                g_rgdstrV2,
                                                0,
                                               &strNode,
                                                NULL,
                                                0 ) ) )
        {
            *f_peVersion = RM_HEADER_VERSION_2;
        }
    }

ErrorExit:

    return dr;
}

/**********************************************************************
**
** Function:    DRM_PRO_IsValidObject
**
** Synopsis:    This method validates structure of PlayReady object
**
** Arguments:
** [f_pbBuffer]        -- Pointer to PlayReady object
** [f_cbBuffer]        -- Size of buffer
**
** Returns:     DRM_SUCCESS       if byte array represents PlayReady object
**              DRM_S_FALSE       if byte array does not represent PlayReady object
**              DRM_E_INVALIDARG  if at least one input parameter is invalid
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_PRO_IsValidObject( 
    __in_bcount( f_cbBuffer ) const DRM_BYTE *f_pbBuffer, 
    __in                      const DRM_DWORD f_cbBuffer )
{
    DRM_RESULT dr              = DRM_SUCCESS;
    DRM_DWORD  dwRemainingSize = f_cbBuffer;
    DRM_WORD   wCounter        = 0;
    DRM_DWORD  dwHeaderLength  = 0;
    DRM_WORD   wRecordCount    = 0;
    DRM_WORD   wRecordType     = 0;
    DRM_WORD   wDataLength     = 0;
    DRM_BYTE  *pbCurrent       = (DRM_BYTE*) f_pbBuffer;
    DRM_BOOL   fV4HeaderFound  = FALSE;

    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_cbBuffer > 0 );
    
    /* Make sure there is enough data to process DRMPlayReadyDataHeader */ 
    ChkBOOL( f_cbBuffer >= SIZE_OF_DRM_PLAYREADY_DATA_HEADER, DRM_S_FALSE );

    /* Read the size of the PlayReadyObject */
    BYTES_TO_DWORD( dwHeaderLength, pbCurrent );
    ChkBOOL( f_cbBuffer >= dwHeaderLength, DRM_S_FALSE );

    /* PlayReady object must contain at least one record */
    BYTES_TO_WORD( wRecordCount, pbCurrent + SIZEOF( DRM_DWORD ) );
    ChkBOOL( wRecordCount > 0, DRM_S_FALSE );

    /* Make sure there is enough data to process PlayReady Record header */ 
    ChkBOOL( f_cbBuffer >= SIZE_OF_DRM_PLAYREADY_DATA_HEADER + SIZE_OF_DRM_PLAYREADY_RECORD_HEADER, DRM_S_FALSE );

    pbCurrent += SIZE_OF_DRM_PLAYREADY_DATA_HEADER;
    dwRemainingSize -= SIZE_OF_DRM_PLAYREADY_DATA_HEADER; 

    /* iterate through the records and verify the size */  
    for( wCounter = 0; wCounter < wRecordCount; wCounter++ )
    {
        BYTES_TO_WORD( wRecordType, pbCurrent );
        BYTES_TO_WORD( wDataLength, (pbCurrent + SIZEOF( DRM_WORD ) ) );
        
        /* Do not allow zero length */
        ChkBOOL( wDataLength != 0, DRM_S_FALSE );

        /* Check if have enough buffer data for current record */
        ChkBOOL( dwRemainingSize >= SIZE_OF_DRM_PLAYREADY_RECORD_HEADER + wDataLength, DRM_S_FALSE );

        /* PLAYREADY_V4_XML_HEADER must be present in PlayReady header only once */
        if( wRecordType == PLAYREADY_V4_XML_HEADER )
        {
            ChkBOOL( !fV4HeaderFound, DRM_S_FALSE );
            fV4HeaderFound = TRUE;
        }
        
        /* Subtract the size of current record */
        dwRemainingSize -= ( SIZE_OF_DRM_PLAYREADY_RECORD_HEADER + wDataLength );
        
        /* Get to the next record */
        pbCurrent += SIZE_OF_DRM_PLAYREADY_RECORD_HEADER + wDataLength; 
    }

    /* PLAYREADY_V4_XML_HEADER must be present in PlayReady header */
    ChkBOOL( fV4HeaderFound, DRM_S_FALSE );
    
    /* All buffer data should be consumed at this point */
    ChkBOOL( dwRemainingSize == 0, DRM_S_FALSE );
ErrorExit:
    return dr;
}

/**********************************************************************
**
** Function:    DRM_PRO_GetRecord
**
** Synopsis:    This function extracts the record with specified record type.
**              It can be used to extract Embedded store and V4 XML header. 
**              This function validates structure of PlayReady object, but it does not 
**              validate the extracted record whether it is embedded store or V4 XML record. 
**
** Arguments:
** [f_pbBuffer]          -- Pointer to PlayReady object
** [f_cbBuffer]          -- Size of PlayReady object
** [f_wRecordType]       -- type of record to extract.
** [f_ppbRecord]         -- Returns a pointer to the embedded store within f_pbBuffer.
** [f_pcbRecord]         -- Returns the length of the embedded store record.
**
** Returns:     DRM_SUCCESS                    - The Embedded Store was successfully extracted
**              DRM_E_RECORD_NOT_FOUND         - Record with requested type is not found. The PlayReady object has correct structure.
**              DRM_E_INVALIDARG               - At least one input parameter is invalid
**                                               or input f_pbBuffer does not contain valid PlayReady object
**              DRM_E_INVALID_PLAYREADY_OBJECT - Parsing of PlayReady object failed
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_PRO_GetRecord( 
    __in_bcount( f_cbBuffer )   const DRM_BYTE   *f_pbBuffer,
    __in                        const DRM_DWORD   f_cbBuffer,
    __in                              DRM_WORD    f_wRecordType,
    __out_bcount(*f_pcbRecord) DRM_BYTE  **f_ppbRecord,
    __out                             DRM_DWORD  *f_pcbRecord )
{    
   DRM_RESULT dr             = DRM_SUCCESS;
   DRM_WORD   wRecordType    = 0;
   DRM_WORD   wDataLength    = 0;
   DRM_WORD   wCounter       = 0;
   DRM_WORD   wRecordCount   = 0;
   DRM_DWORD  ibCur          = 0;

   ChkArg( f_ppbRecord != NULL );
   ChkArg( f_pcbRecord != NULL );

   /*
   ** Preset size of returned object to zero in case it is not found.
   */
   *f_pcbRecord = 0;

   /*
   ** Validates the PlayReadyObject structure.
   */
   ChkDRMap( DRM_PRO_IsValidObject( f_pbBuffer, f_cbBuffer ), DRM_S_FALSE, DRM_E_INVALIDARG );

   /*
   ** Make sure there is enough data to process DRMPlayReadyDataHeader 
   */ 
   ChkBOOL( f_cbBuffer >= SIZE_OF_DRM_PLAYREADY_DATA_HEADER, DRM_E_INVALID_PLAYREADY_OBJECT );

   /*
   ** Read count of records from header of PlayReady object.
   ** PlayReady object must contains at least one record
   ** Record count is located after the DWORD length in the data header
   */   
   BYTES_TO_WORD( wRecordCount, f_pbBuffer + ibCur + SIZEOF( DRM_DWORD ) ); 
   ChkBOOL( wRecordCount > 0, DRM_E_INVALID_PLAYREADY_OBJECT );
   ibCur += SIZE_OF_DRM_PLAYREADY_DATA_HEADER;

   /*
   ** iterate through the records and verify the size 
   */  
   for( wCounter = 0; wCounter < wRecordCount; wCounter++ )
   {
        BYTES_TO_WORD( wRecordType, f_pbBuffer + ibCur );
        ibCur += SIZEOF( DRM_WORD );
        BYTES_TO_WORD( wDataLength, f_pbBuffer + ibCur );
        ibCur += SIZEOF( DRM_WORD );

        /*
        ** Do not allow zero length 
        */
        ChkBOOL( wDataLength > 0, DRM_E_INVALID_PLAYREADY_OBJECT );

        /*
        ** Check the type of the record. If the type is the same as requested in f_wRecordType
        ** then it means we found the object and need to return it.
        */ 
        
        if( wRecordType == f_wRecordType )
        {            
            ChkBOOL( wDataLength <= MAX_EMBEDDED_STORE_LEN, DRM_E_INVALID_PLAYREADY_OBJECT );
            *f_ppbRecord = ( DRM_BYTE * )( f_pbBuffer + ibCur );
            *f_pcbRecord = wDataLength;  
            goto ErrorExit;
        }

       /*
       ** Get to the next record 
       */
       ibCur += wDataLength; 
   }

   /*
   ** Failed to find embedded record. Set return value FAIL, re-use value DRM_E_NOMORE.
   */
   dr = DRM_E_RECORD_NOT_FOUND;

ErrorExit:
    return dr;
}


typedef struct __tagDRM_BUFFER_STREAM
{ 
    DRM_BYTE    *pbBuffer;
    DRM_DWORD    cbBuffer;
    DRM_DWORD    dwCurrentPos;
} DRM_BUFFER_STREAM; 


/******************************************************************************
**
** Function:   _drm_BufferStreamWriteData
** 
** Synopsis:   Writes DWORD into stream
**             
** Arguments:
**
** [f_pHeaderStream]    -- DRM_BUFFER_STREAM structure that keeps track of the buffer., 
** [f_pbData]           -- Pointer to buffer to write.      
** f_cbData             -- Size of the buffer.
** 
** Returns:       DRM_SUCCESS          if successful
**                DRM_E_BUFFERTOOSMALL if buffer specified by f_pHeaderStream is too small.
**
******************************************************************************/
static DRM_RESULT _drm_BufferStreamWriteData( 
    __inout                         DRM_BUFFER_STREAM *f_pHeaderStream, 
    __in_bcount_opt(f_cbData) const DRM_BYTE *f_pbData, 
    __in                            DRM_WORD f_cbData )

{   DRM_RESULT dr                = DRM_SUCCESS;
    
    DRMASSERT( f_pHeaderStream != NULL );
    DRMASSERT( f_pbData != NULL );

    /*
    ** If there is no space for extra WORD, return error.  
    */ 
    if ( f_pHeaderStream->dwCurrentPos + f_cbData > f_pHeaderStream->cbBuffer )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    /*
    ** Writes data and update current position.
    */
    DRMCRT_memcpy( f_pHeaderStream->pbBuffer + f_pHeaderStream->dwCurrentPos, f_pbData, f_cbData ); 
    f_pHeaderStream->dwCurrentPos +=f_cbData;

ErrorExit :
    return dr;
}

/******************************************************************************
**
** Function:   _drm_BufferStreamWriteWORD
** 
** Synopsis:   Writes WORD into stream
**             
** Arguments:
**
** [f_pHeaderStream]    -- DRM_BUFFER_STREAM structure that keeps track of the buffer., 
** [f_wValue]           -- WORD value.      
**  
** Returns:       DRM_SUCCESS          if successful
**                DRM_E_BUFFERTOOSMALL if buffer specifieded by f_pHeaderStream is too small.
**
******************************************************************************/
static DRM_RESULT _drm_BufferStreamWriteWORD( __inout DRM_BUFFER_STREAM *f_pHeaderStream, __in DRM_WORD f_wValue )

{   DRM_RESULT dr                = DRM_SUCCESS;
    
    DRMASSERT( f_pHeaderStream != NULL );

    /*
    ** If there is no space for extra WORD, return error.  
    */ 
    ChkOverflow( f_pHeaderStream->dwCurrentPos + SIZEOF( f_wValue ), f_pHeaderStream->dwCurrentPos );
    if ( f_pHeaderStream->dwCurrentPos + SIZEOF( f_wValue ) > f_pHeaderStream->cbBuffer )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    /*
    ** Writes data and update current position.
    */
    WORD_TO_BYTES( f_pHeaderStream->pbBuffer + f_pHeaderStream->dwCurrentPos, f_wValue ); 
    f_pHeaderStream->dwCurrentPos += SIZEOF( f_wValue );

ErrorExit :
    return dr;
}

/******************************************************************************
**
** Function:   _drm_BufferStreamWriteDWORD
** 
** Synopsis:   Writes DWORD into stream
**             
** Arguments:
**
** [f_pHeaderStream]    -- DRM_BUFFER_STREAM structure that keeps track of the buffer., 
** [f_dwValue]          -- DWORD value.      
**  
** Returns:       DRM_SUCCESS          if successful
**                DRM_E_BUFFERTOOSMALL if buffer pointed by f_pbPlayReadyHeader is too small or f_pbPlayReadyHeader is NULL.
**
******************************************************************************/
static DRM_RESULT _drm_BufferStreamWriteDWORD( __inout DRM_BUFFER_STREAM *f_pHeaderStream, __in DRM_DWORD f_dwValue )

{   DRM_RESULT dr                = DRM_SUCCESS;
    
    DRMASSERT( f_pHeaderStream != NULL );

    /*
    ** If there is no space for extra DWORD, return error.  
    */ 
    ChkOverflow( f_pHeaderStream->dwCurrentPos + SIZEOF( f_dwValue ), f_pHeaderStream->dwCurrentPos );
    if ( f_pHeaderStream->dwCurrentPos + SIZEOF( f_dwValue ) > f_pHeaderStream->cbBuffer )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    /*
    ** Writes data and update current position.
    */
    DWORD_TO_BYTES( f_pHeaderStream->pbBuffer + f_pHeaderStream->dwCurrentPos, f_dwValue ); 
    f_pHeaderStream->dwCurrentPos += SIZEOF( f_dwValue );

ErrorExit :
    return dr;
}

/******************************************************************************
**
** Function:   _drm_InsertRecord
** 
** Synopsis:   Insert record into PlayReady object
**             
** Arguments:
**
** [f_pHeaderStream]         -- DRM_BUFFER_STREAM strcture that keeps track of the buffer., 
**                               
** [f_wRecordType]           -- Record type.      
**                            
** [f_pRecord]               -- Pointer to inserted record data. If it is NULL space just reserved for f_wRecordType type
**                              Output: size of PlayReady object header (including PlayReady header)
** 
**[f_cbRecord]               -- Size of the record.
**  
** Returns:       DRM_SUCCESS          if successful
**                DRM_E_BUFFERTOOSMALL if buffer pointed by f_pRecord is too small or f_pRecord is NULL.
**
******************************************************************************/
static DRM_RESULT _drm_InsertRecord(   
    __inout DRM_BUFFER_STREAM * f_pHeaderStream, 
    __in    DRM_WORD            f_wRecordType, 
    __in_bcount_opt(f_cbRecord) const DRM_BYTE  *f_pRecord, 
    __in    DRM_WORD            f_cbRecord )

{   DRM_RESULT dr                = DRM_SUCCESS;

    DRMASSERT( f_pHeaderStream != NULL );
 
    /* Record type, pre-defined constants */
    ChkDR( _drm_BufferStreamWriteWORD( f_pHeaderStream, f_wRecordType ) );
    
    /* Writes size of the record */
    ChkDR( _drm_BufferStreamWriteWORD( f_pHeaderStream, f_cbRecord ) );

    /*
    ** If pointer to record data is provided, we write it to the target buffer. 
    ** If pointer is NULL, means the space should be reserved and we move the current position forward
    */
    if ( f_pRecord != NULL )
    {
        ChkDR( _drm_BufferStreamWriteData( f_pHeaderStream, f_pRecord, f_cbRecord ) );
    }
    else
    {
        ChkBOOL( f_pHeaderStream->dwCurrentPos + f_cbRecord <= f_pHeaderStream->cbBuffer, DRM_E_BUFFERTOOSMALL );
        f_pHeaderStream->dwCurrentPos += f_cbRecord;
    }

ErrorExit :
    return dr;
}

/******************************************************************************
**
** Function:   DRM_PRO_Create
** 
** Synopsis:   Wraps a PlayReady header into a PlayReady object.
**             
** Arguments:
**
** [f_pdstrPlayReadyHeader]   -- Input: Pointer to a DRM string with PlayReady header.
**                               
** [f_pbPlayReadyObject]      -- Pointer to a buffer to receive the PlayReady object header.
**                            
** [f_pcbPlayReadyObject]     -- Input: Size of the memory block pointed by f_pbPlayReadyObject.
**                               Output: Size of PlayReady object created.
**
** Returns:       DRM_SUCCESS          if successful
**                DRM_E_INVALIDARG     if input parameters is invalid 
**                DRM_E_BUFFERTOOSMALL if buffer pointed by f_pbPlayReadyObject is too small
**                                     or f_pbPlayReadyObject is NULL.
**
** Please make sure to update Drm_PlayReadyObject_ConvertFromWmdrmHeader()
** if the PlayReady object format changes.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_PRO_Create(
    __in    DRM_CONST_STRING           *f_pdstrPlayReadyHeader,
    __out_bcount_opt( *f_pcbPlayReadyObject )
            DRM_BYTE                   *f_pbPlayReadyObject,
    __inout DRM_DWORD                  *f_pcbPlayReadyObject )
{   
    DRM_RESULT dr                = DRM_SUCCESS;
    DRM_DWORD  cbPlayReadyObject = 0;
    DRM_BUFFER_STREAM    oBufferStream = {0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMPRO, PERF_FUNC_DRM_PRO_Create );
    
    ChkDRMString( f_pdstrPlayReadyHeader );
    ChkArg( f_pcbPlayReadyObject != NULL );

    ChkOverflow( f_pdstrPlayReadyHeader->cchString * SIZEOF( DRM_WCHAR ),
                 f_pdstrPlayReadyHeader->cchString );

    /*
    ** Calculates the size of the PlayReady object.
    */ 
    cbPlayReadyObject = f_pdstrPlayReadyHeader->cchString * SIZEOF( DRM_WCHAR ) + 
                        SIZE_OF_DRM_PLAYREADY_DATA_HEADER       + 
                        2 * SIZE_OF_DRM_PLAYREADY_RECORD_HEADER +
                        MAX_EMBEDDED_STORE_LEN;

    /*
    ** If f_pbPlayReadyObject is NULL or buffer is not large enough, we just return the size.
    */
    if ( f_pbPlayReadyObject == NULL || *f_pcbPlayReadyObject < cbPlayReadyObject )
    {
        *f_pcbPlayReadyObject = cbPlayReadyObject;
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    ZEROMEM( f_pbPlayReadyObject, cbPlayReadyObject );

    *f_pcbPlayReadyObject = cbPlayReadyObject;

    oBufferStream.pbBuffer = f_pbPlayReadyObject;
    oBufferStream.cbBuffer = *f_pcbPlayReadyObject;
    oBufferStream.dwCurrentPos = 0;

    /* 
    ** Write the size. 
    */
    ChkDR( _drm_BufferStreamWriteDWORD( &oBufferStream, cbPlayReadyObject ) );

    /* 
    ** Set record count. We set 2 records, one for PlayReady header, another embedded store. 
    */
    ChkDR( _drm_BufferStreamWriteWORD( &oBufferStream, 2 ) );
    
    /*
    **  Insert PlayReady header.
    */
// Xbox LIVE specific: disabling conversion warning (C4242) after review.
//
    #pragma warning( disable:4242 )
    ChkDR( _drm_InsertRecord( &oBufferStream,
                              PLAYREADY_V4_XML_HEADER,
                              (DRM_BYTE *)f_pdstrPlayReadyHeader->pwszString,
                              f_pdstrPlayReadyHeader->cchString * SIZEOF( DRM_WCHAR ) ) );
    #pragma warning( default:4242 )
//
// End Xbox LIVE specific
//


    /*
    ** Insert empty embedded store.
    */
    ChkDR( _drm_InsertRecord( &oBufferStream, PLAYREADY_EMBEDDED_LICENSE_STORE, NULL, MAX_EMBEDDED_STORE_LEN ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/******************************************************************************
**
** Function:   DRM_PRO_GetCipherTypeFromPlayReadyHeader
** 
** Synopsis:   Returns the cipher type in the PlayReady header.
**             
** Arguments:
**
** [f_pbPlayReadyHeader]      -- Pointer to a byte buffer that contains the PlayReady header.
** [f_cbPlayReadyHeader]      -- Size of the buffer that contains the PlayReady header.
** [f_peCipherType]           -- Pointer to a variable that receives the cipher type in the
**                               PlayReady header.
**
** Returns:       DRM_SUCCESS          if successful
**                DRM_E_INVALIDARG     if input parameters is invalid 
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_PRO_GetCipherTypeFromPlayReadyHeader(
    __in_bcount( f_cbPlayReadyHeader )
            DRM_BYTE  *f_pbPlayReadyHeader,
    __in    DRM_DWORD f_cbPlayReadyHeader,
    __out   DRM_SUPPORTED_CIPHERS *f_peCipherType )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrV4Header = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrAlgorithm = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMPRO, PERF_FUNC_DRM_PRO_GetCipherTypeFromPlayReadyHeader );

    ChkArg( f_pbPlayReadyHeader != NULL && f_cbPlayReadyHeader > 0 );
    ChkArg( f_peCipherType != NULL );

    *f_peCipherType = eDRM_CIPHER_INVALID;

    DSTR_FROM_PB( &dstrV4Header, f_pbPlayReadyHeader, f_cbPlayReadyHeader );
    
    ChkDR( DRM_XML_GetSubNodeByPath( &dstrV4Header, 
                                     &g_dstrAlgorithmPath, 
                                     NULL, 
                                     NULL,
                                     NULL,
                                     &dstrAlgorithm,
                                     g_wchForwardSlash ) );

    if ( DRM_UTL_DSTRStringsEqual( &dstrAlgorithm, &g_dstrCOCKTAIL ) )
    {
        *f_peCipherType = eDRM_RC4_CIPHER;
    }
    else if ( DRM_UTL_DSTRStringsEqual( &dstrAlgorithm, &g_dstrAESCTR ))
    {
        *f_peCipherType = eDRM_AES_COUNTER_CIPHER;
    }   

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/******************************************************************************
**
** Function:   DRM_PRO_GetCipherType
** 
** Synopsis:   Returns the cipher type in the PlayReady object.
**             
** Arguments:
**
** [f_pbPlayReadyObject]      -- Pointer to a byte buffer that contains the PlayReady object.
** [f_cbPlayReadyObject]      -- Size of the buffer that contains the PlayReady object.
** [f_peCipherType]           -- Pointer to a variable that receives the cipher type in the
**                               PlayReady object.
**
** Returns:       DRM_SUCCESS          if successful
**                DRM_E_INVALIDARG     if input parameters is invalid 
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_PRO_GetCipherType(
    __in_bcount( f_cbPlayReadyObject )
            DRM_BYTE  *f_pbPlayReadyObject,
    __in    DRM_DWORD f_cbPlayReadyObject,
    __out   DRM_SUPPORTED_CIPHERS *f_peCipherType )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE *pbV4Header = NULL;
    DRM_DWORD cbV4Header = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMPRO, PERF_FUNC_DRM_PRO_GetCipherType );

    ChkArg( f_pbPlayReadyObject != NULL && f_cbPlayReadyObject > 0 );
    ChkArg( f_peCipherType != NULL );

    *f_peCipherType = eDRM_CIPHER_INVALID;

    ChkDR( DRM_PRO_GetRecord( f_pbPlayReadyObject,
                              f_cbPlayReadyObject,
                              PLAYREADY_V4_XML_HEADER,
                              &pbV4Header,
                              &cbV4Header ));

    ChkDR( DRM_PRO_GetCipherTypeFromPlayReadyHeader( pbV4Header,
                                                     cbV4Header,
                                                     f_peCipherType ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/**********************************************************************
**
** Function:    DRM_PRO_ConvertHeaderFromWmdrmToPlayReady
**
** Synopsis:    Generates a PlayReady header from a WMDRM header. The conversion
**              can be seen in the examples below.
**
** Arguments:
** [f_pbWmdrmHeader]    -- WMDRM header to be converted. It may contain the BOM
**                         at the very beginning.
** [f_cbWmdrmHeader]    -- Size of f_pbWmdrmHeader in bytes (including BOM if exists).
** [f_pwchPlayReadySilentURL]        
**                      -- PlayReady server silent LA URL, optional. If not
**                         used then new header will not contain LA_URL node.
** [f_cchPlayReadySilentURL]
**                      -- Size of f_pwchPlayReadySilentURL in WCHARs. If
**                         f_pwchPlayReadySilentURL is NULL then 
**                         this values should be 0.
** [f_pwchPlayReadyNonSilentURL]
**                      -- PlayReady server non silent LA URL, optional. If not 
**                         used then new header will not contain LUI_URL node.
** [f_cchPlayReadyNonSilentURL]         
**                      -- Size of f_pwchPlayReadyNonSilentURL in WCHARs. If
**                         f_pwchPlayReadyNonSilentURL is NULL then 
**                         this values should be 0.
** [f_pwchServiceID]    -- Domain service ID, optional. If not used then new header
**                         will not have DS_ID node.
** [f_pcchServiceID]    -- Size of f_pwchServiceID in WCHARs. If f_pwchServiceID
**                         is NULL then this values should be 0.
** [f_pbPlayReadyHeader]-- Pointer to a buffer to receive the PlayReady header created. 
** [f_pcbPlayReadyHeader]
**                      -- Size of f_pbPlayReadyHeader in bytes. If
**                         f_pbPlayReadyHeader is too small or null, then this
**                         will be set to the required size.
**                         On successful execution, this will be the size written.
**
** Returns:     DRM_SUCCESS - on success.
**              DRM_E_BUFFTOOSMALL if f_pbPlayReadyHeader is not big enough or is NULL.
**              DRM_E_ fail codes on other failures.
**              DRM_E_CH_INCOMPATIBLE_HEADER_TYPE if the header to be converted is 
**              not of type WMDRM.
**
** Example Input:
**   <WRMHEADER version="2.0.0.0">
**       <DATA>
**           <RID>5</RID>
**           <CID>500</CID>
**           <LAINFO>http://WMDRM_Silent_LA_URL</LAINFO>
**           <KID>P5GlZb7/CEKig6gco/eQQw==</KID>
**           <CHECKSUM>jbzXJoUdhw==</CHECKSUM>
**       </DATA>
**       <SIGNATURE>
**           <HASHALGORITHM type="SHA"></HASHALGORITHM>
**           <SIGNALGORITHM type="MSDRM"></SIGNALGORITHM>
**           <VALUE>XQd7zeXfy5PO75w41ZoOAIEn0ga5nubBzlXf8udrZASTNOKEUwUzGQ==</VALUE>
**       </SIGNATURE>
**   </WRMHEADER> 
**
** Example Output (Note that the LA_URL node will only be inserted if f_pwchf_cchPlayReadySilentURL
** is not NULL):
**     <WRMHEADER xmlns="http://schemas.microsoft.com/DRM/2007/03/PlayReadyHeader" version="4.0.0.0">
**         <DATA>
**             <PROTECTINFO>
**                 <KEYLEN>7</KEYLEN>
**                 <ALGID>COCKTAIL</ALGID>
**             </PROTECTINFO>
**             <KID>P5GlZb7/CEKig6gco/eQQw==</KID>
**             <CHECKSUM>jbzXJoUdhw==</CHECKSUM>
**             <LA_URL>http://PlayReady_Silent_LA_URL</LA_URL>
**             <LUI_URL>http://PlayReady_Non_Silent_LA_URL</LUI_URL>
**         </DATA>
**     </WRMHEADER>
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_PRO_ConvertHeaderFromWmdrmToPlayReady( 
    __in_bcount( f_cbWmdrmHeader )      const DRM_BYTE  *f_pbWmdrmHeader,
    __in                                const DRM_DWORD  f_cbWmdrmHeader,
    __in_ecount_nz_opt( f_cchPlayReadySilentURL )
                                        const DRM_WCHAR *f_pwchPlayReadySilentURL,
    __in                                const DRM_DWORD  f_cchPlayReadySilentURL,
    __in_ecount_nz_opt( f_cchPlayReadyNonSilentURL )
                                        const DRM_WCHAR *f_pwchPlayReadyNonSilentURL,
    __in                                const DRM_DWORD  f_cchPlayReadyNonSilentURL,
    __in_ecount_nz_opt( f_cchServiceID )
                                        const DRM_WCHAR *f_pwchServiceID,
    __in                                const DRM_DWORD  f_cchServiceID,
    __inout_bcount_opt( *f_pcbPlayReadyHeader )      
                                              DRM_BYTE  *f_pbPlayReadyHeader,
    __in                                      DRM_DWORD *f_pcbPlayReadyHeader )
{
    DRM_RESULT dr           = DRM_SUCCESS;
    DRM_DWORD  cbV4Size     = 0;
    DRM_DWORD  cchCustAttr  = 0;
    DRM_CONST_STRING strKID = EMPTY_DRM_STRING;
    DRM_STRING strCheckSum  = EMPTY_DRM_STRING;
    eRMHeaderVersion eRMHeaderVer = RM_HEADER_VERSION_UNKNOWN;
    DRM_CONST_STRING strV2Header  = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMPRO, PERF_FUNC_DRM_PRO_ConvertHeaderFromWmdrmToPlayReady );

    /*
    ** Arg checks, f_pbPlayReadyHeader can be null, in which case we return 
    ** a size in *f_pcbPlayReadyHeader.
    */
    ChkArg( NULL != f_pbWmdrmHeader );
    ChkArg( NULL != f_pcbPlayReadyHeader  ); 
    ChkArg( ( f_pwchPlayReadySilentURL != NULL && f_cchPlayReadySilentURL > 0 ) ||
            ( f_pwchPlayReadySilentURL == NULL && f_cchPlayReadySilentURL == 0 ) );
    ChkArg( ( f_pwchPlayReadyNonSilentURL != NULL && f_cchPlayReadyNonSilentURL > 0 ) ||
            ( f_pwchPlayReadyNonSilentURL == NULL && f_cchPlayReadyNonSilentURL == 0 ) );
    ChkArg( ( f_pwchServiceID != NULL && f_cchServiceID > 0 ) ||
            ( f_pwchServiceID == NULL && f_cchServiceID == 0 ) );
    ChkArg( f_cbWmdrmHeader >= SIZEOF_V2_BOM );

    if ( V2_BOM == ( ( DRM_WCHAR * )f_pbWmdrmHeader )[ 0 ] )
    {
        /* Skip the BOM. */
        strV2Header.pwszString = ( DRM_WCHAR* )( f_pbWmdrmHeader + SIZEOF( DRM_WCHAR ) );
        strV2Header.cchString = ( f_cbWmdrmHeader - SIZEOF( DRM_WCHAR ) ) / SIZEOF( DRM_WCHAR );
    }
    else
    {
        strV2Header.pwszString = ( DRM_WCHAR* )f_pbWmdrmHeader;
        strV2Header.cchString = f_cbWmdrmHeader / SIZEOF( DRM_WCHAR );
    }
    
    /* Make sure that we were given a WMDRM header. */
    ChkDR( DRM_PRO_GetRMHeaderVersion( f_pbWmdrmHeader, f_cbWmdrmHeader, &eRMHeaderVer ) );
    ChkBOOL( RM_HEADER_VERSION_2 == eRMHeaderVer, DRM_E_CH_INVALID_HEADER );

    /* Get the needed data from the v2 header: KID, checksum & sizeof custom attributes. */
    {
        /* Get the KID, then the checksum, then the size of the custom attributes (could be zero). */
        ChkDR( DRM_XML_GetSubNode( &strV2Header, 
                                    g_rgdstrKID, 
                                    NULL, 
                                    NULL,
                                    0,
                                    NULL,
                                   &strKID,
                                    2 ) );

        ChkDR( DRM_XML_GetSubNode( &strV2Header, 
                                    g_rgdstrChecksum, 
                                    NULL, 
                                    NULL,
                                    0,
                                    NULL,
                                   ( DRM_CONST_STRING * )&strCheckSum,
                                    2 ) );

        dr = _GetCustAttributes( &strV2Header, NULL, &cchCustAttr );

        ChkBOOL( DRM_SUCCESS == dr ||
                 DRM_E_BUFFERTOOSMALL == dr,
                 DRM_E_FAIL );
    }

    /* Calculate the size needed. */
    cbV4Size =   SIZEOF( g_rgwchOpenNodeWRMHeader )   + SIZEOF( g_rgwchCloseNodeWRMHeader )
               + SIZEOF( g_rgwchOpenNodeData )        + SIZEOF( g_rgwchCloseNodeData )
               + SIZEOF( g_rgwchOpenNodeProtectInfo ) + SIZEOF( g_rgwchCloseNodeProtectInfo )
               + SIZEOF( g_rgwchNodesKeyLen7 )
               + SIZEOF( g_rgwchNodesAlgIDCocktail )
               + SIZEOF( g_rgwchOpenNodeKID )         + SIZEOF( g_rgwchCloseNodeKID )
               + strKID.cchString * SIZEOF( DRM_WCHAR )
               + SIZEOF( g_rgwchOpenNodeChecksum )    + SIZEOF( g_rgwchCloseNodeChecksum )
               + strCheckSum.cchString * SIZEOF( DRM_WCHAR )
               + cchCustAttr * SIZEOF( DRM_WCHAR );

    /* 
    ** If there are no custom attributes, then don't use these nodes.
    */
    cbV4Size += ( 0 == cchCustAttr ) ? 0 :   SIZEOF( g_rgwchCloseNodeCustomAttributes ) 
                                            + SIZEOF( g_rgwchOpenNodeCustomAttributes ); 

    if ( NULL != f_pwchPlayReadySilentURL )
    {
        cbV4Size += SIZEOF( g_rgwchOpenNodeLAURL ) + SIZEOF( g_rgwchCloseNodeLAURL )
                    + f_cchPlayReadySilentURL * SIZEOF( DRM_WCHAR );
    }

    if ( NULL != f_pwchPlayReadyNonSilentURL )
    {
        cbV4Size += SIZEOF( g_rgwchOpenNodeLUIURL ) + SIZEOF( g_rgwchCloseNodeLUIURL )
                    + f_cchPlayReadyNonSilentURL * SIZEOF( DRM_WCHAR );
    }
 
    if ( NULL != f_pwchServiceID )
    {
        cbV4Size += SIZEOF( g_rgwchOpenNodeDSID ) + SIZEOF( g_rgwchCloseNodeDSID )
                    + f_cchServiceID * SIZEOF( DRM_WCHAR );
    }
    
    /* If the size is too small set the output param and return the correct error code. */
    if ( NULL == f_pbPlayReadyHeader || cbV4Size > *f_pcbPlayReadyHeader )
    {
        *f_pcbPlayReadyHeader = cbV4Size;
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    /* Zero out the input/output buffer to be written. */
    OEM_SECURE_ZERO_MEMORY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader );

    /* Now lets do the writing. */
    {
        DRM_DWORD i = 0, j = 0;

        /*
        ** Open the WRMHEADER open, DATA open, PROTECTINFO open, KEYLEN=7, ALGID=Cocktail
        ** and the PROTECTINFO close nodes. 
        */
        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchOpenNodeWRMHeader, SIZEOF( g_rgwchOpenNodeWRMHeader ) );
        i += SIZEOF( g_rgwchOpenNodeWRMHeader );
        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchOpenNodeData, SIZEOF( g_rgwchOpenNodeData ) );
        i += SIZEOF( g_rgwchOpenNodeData );
        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchOpenNodeProtectInfo, SIZEOF( g_rgwchOpenNodeProtectInfo ) );
        i += SIZEOF( g_rgwchOpenNodeProtectInfo );
        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchNodesKeyLen7, SIZEOF( g_rgwchNodesKeyLen7 ) );
        i += SIZEOF( g_rgwchNodesKeyLen7 );
        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchNodesAlgIDCocktail, SIZEOF( g_rgwchNodesAlgIDCocktail ) );
        i += SIZEOF( g_rgwchNodesAlgIDCocktail );
        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchCloseNodeProtectInfo, SIZEOF( g_rgwchCloseNodeProtectInfo ) );
        i += SIZEOF( g_rgwchCloseNodeProtectInfo );

        /* Write the KID node. */
        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchOpenNodeKID, SIZEOF( g_rgwchOpenNodeKID ) );
        i += SIZEOF( g_rgwchOpenNodeKID );
        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, strKID.pwszString, strKID.cchString * SIZEOF( DRM_WCHAR ) );
        i += strKID.cchString * SIZEOF( DRM_WCHAR );
        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchCloseNodeKID, SIZEOF( g_rgwchCloseNodeKID ) );
        i += SIZEOF( g_rgwchCloseNodeKID );

        /* Write the checksum node. */
        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchOpenNodeChecksum, SIZEOF( g_rgwchOpenNodeChecksum ) );
        i += SIZEOF( g_rgwchOpenNodeChecksum );

        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, strCheckSum.pwszString, strCheckSum.cchString * SIZEOF( DRM_WCHAR ) );

        /* Checksum is in the form of a B64 string. Convert '!' to '+'; '*' to '/'. */
        for ( j = 0; j < strCheckSum.cchString; j++ )
        {
            DRM_WCHAR *pwChar = ( DRM_WCHAR * )( f_pbPlayReadyHeader + i + j * SIZEOF( DRM_WCHAR ) );

            if ( *pwChar == WCHAR_CAST( '!' ) )
            {
                *pwChar = WCHAR_CAST( '+' );

            }
            else if ( *pwChar == WCHAR_CAST( '*' ) )
            {
                *pwChar = WCHAR_CAST( '/' );
            }
        }

        i += strCheckSum.cchString * SIZEOF( DRM_WCHAR );
        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchCloseNodeChecksum, SIZEOF( g_rgwchCloseNodeChecksum ) );
        i += SIZEOF( g_rgwchCloseNodeChecksum );
       
        /* Write LA_URL node if the PlayReady Silent URL was supplied. */
        if ( NULL != f_pwchPlayReadySilentURL )
        {
            SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchOpenNodeLAURL, SIZEOF( g_rgwchOpenNodeLAURL ) );
            i += SIZEOF( g_rgwchOpenNodeLAURL );
 
            SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader,
                         i, 
                         f_pwchPlayReadySilentURL, 
                         f_cchPlayReadySilentURL * SIZEOF( DRM_WCHAR ) );
            i += f_cchPlayReadySilentURL * SIZEOF( DRM_WCHAR );

            SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchCloseNodeLAURL, SIZEOF( g_rgwchCloseNodeLAURL ) );
            i += SIZEOF( g_rgwchCloseNodeLAURL );
        }

        /* Write LUI_URL node if the PlayReady Non Silent URL was supplied. */
        if ( NULL != f_pwchPlayReadyNonSilentURL )
        {
            SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchOpenNodeLUIURL, SIZEOF( g_rgwchOpenNodeLUIURL ) );
            i += SIZEOF( g_rgwchOpenNodeLUIURL );

            SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader,
                         i, 
                         f_pwchPlayReadyNonSilentURL, 
                         f_cchPlayReadyNonSilentURL * SIZEOF( DRM_WCHAR ) );
            i += f_cchPlayReadyNonSilentURL * SIZEOF( DRM_WCHAR );

            SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchCloseNodeLUIURL, SIZEOF( g_rgwchCloseNodeLUIURL ) );
            i += SIZEOF( g_rgwchCloseNodeLUIURL );
        }

        /* Write DS_ID node if the domain service ID was supplied. */
        if ( NULL != f_pwchServiceID )
        {
            SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchOpenNodeDSID, SIZEOF( g_rgwchOpenNodeDSID ) );
            i += SIZEOF( g_rgwchOpenNodeDSID );
            
            SAFE_MEMCPY( f_pbPlayReadyHeader,
                         *f_pcbPlayReadyHeader,
                         i, 
                         f_pwchServiceID, 
                         f_cchServiceID * SIZEOF( DRM_WCHAR ) );
            i += f_cchServiceID * SIZEOF( DRM_WCHAR );

            SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchCloseNodeDSID, SIZEOF( g_rgwchCloseNodeDSID ) );
            i += SIZEOF( g_rgwchCloseNodeDSID );
        }
        
        /* Write custom attributes (if supplied). */
        if ( 0 != cchCustAttr )
        {
            DRM_DWORD        cchWritten  = 0;
            DRM_CONST_STRING strV4Header = EMPTY_DRM_STRING;
                
            /*
            ** Copy the open customattributes node, copy all the attributes to the correct location, increment our
            ** index then copy the end customattributes node.
            */
            SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchOpenNodeCustomAttributes, SIZEOF( g_rgwchOpenNodeCustomAttributes ) );
            i += SIZEOF( g_rgwchOpenNodeCustomAttributes );

            strV4Header.cchString  = ( *f_pcbPlayReadyHeader - i ) / SIZEOF( DRM_WCHAR );
            strV4Header.pwszString = ( DRM_WCHAR* )( f_pbPlayReadyHeader + i );
            ChkDR( _GetCustAttributes( &strV2Header, &strV4Header, &cchWritten ) );
            i += cchWritten * SIZEOF( DRM_WCHAR );

            SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchCloseNodeCustomAttributes, SIZEOF( g_rgwchCloseNodeCustomAttributes ) );
            i += SIZEOF( g_rgwchCloseNodeCustomAttributes );
        }
        
        /* Close the Data and WRMHEADER nodes. */
        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchCloseNodeData, SIZEOF( g_rgwchCloseNodeData ) );
        i += SIZEOF( g_rgwchCloseNodeData );
        SAFE_MEMCPY( f_pbPlayReadyHeader, *f_pcbPlayReadyHeader, i, g_rgwchCloseNodeWRMHeader, SIZEOF( g_rgwchCloseNodeWRMHeader ) );
        i += SIZEOF( g_rgwchCloseNodeWRMHeader );     
    }

    /* Now set the amount of bytes we wrote. */
    *f_pcbPlayReadyHeader = cbV4Size;

ErrorExit:  

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;   
}

/******************************************************************************
**
** Function:    Drm_PlayReadyObject_ConvertFromWmdrmHeader
**
** Synopsis:    Generates a PlayReady object from a WMDRM header.
**
** Arguments:
**
** [f_pbWmdrmHeader]        -- WMDRM header to be converted. It may contain the BOM
**                             at the very beginning.
** [f_cbWmdrmHeader]        -- Size of f_pbWmdrmHeader in bytes (including BOM if exists).
** [f_pwchPlayReadySilentURL]        
**                          -- PlayReady server silent LA URL, optional. If not
**                             used then new header will not contain LA_URL node.
** [f_cchPlayReadySilentURL]
**                          -- Size of f_pwchPlayReadySilentURL in WCHARs. If
**                             f_pwchPlayReadySilentURL is NULL then 
**                             this values should be 0.
** [f_pwchPlayReadyNonSilentURL]
**                          -- PlayReady server non silent LA URL, optional. If not 
**                             used then new header will not contain LUI_URL node.
** [f_cchPlayReadyNonSilentURL]         
**                          -- Size of f_pwchPlayReadyNonSilentURL in WCHARs. If
**                             f_pwchPlayReadyNonSilentURL is NULL then 
**                             this values should be 0.
** [f_pwchServiceID]        -- Domain service ID, optional. If not used then new header
**                             will not have DS_ID node.
** [f_pcchServiceID]        -- Size of f_pwchServiceID in WCHARs. If f_pwchServiceID
**                             is NULL then this values should be 0.
** [f_pbPlayReadyObject]    -- Pointer to a buffer to receive the PlayReady object converted.
** [f_pcbPlayReadyObject]   -- Size of f_pbPlayReadyObject in bytes. If f_pbPlayReadyObject is
**                             too small or null, then this will be set to the required size.
**                             On successful execution, this will be the size written.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_CH_INCOMPATIBLE_HEADER_TYPE if the header to be converted
**                          is not of type WMDRM.
**                          DRM_E_BUFFERTOOSMALL - output buffer too small.
**                          Other error codes as defined in drmresults.h.
**
** Please make sure to update DRM_PRO_Create() if the PlayReady object format changes.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_PlayReadyObject_ConvertFromWmdrmHeader( 
    __in_bcount( f_cbWmdrmHeader )  const DRM_BYTE  *f_pbWmdrmHeader,
    __in                            const DRM_DWORD  f_cbWmdrmHeader,
    __in_ecount_nz_opt( f_cchPlayReadySilentURL )
                                    const DRM_WCHAR *f_pwchPlayReadySilentURL,
    __in                            const DRM_DWORD  f_cchPlayReadySilentURL,
    __in_ecount_nz_opt( f_cchPlayReadyNonSilentURL )
                                    const DRM_WCHAR *f_pwchPlayReadyNonSilentURL,
    __in                            const DRM_DWORD  f_cchPlayReadyNonSilentURL,
    __in_ecount_nz_opt( f_cchServiceID )
                                    const DRM_WCHAR *f_pwchServiceID,
    __in                            const DRM_DWORD  f_cchServiceID,
    __inout_bcount_opt( *f_pcbPlayReadyObject )
                                          DRM_BYTE  *f_pbPlayReadyObject,
    __in                                  DRM_DWORD *f_pcbPlayReadyObject )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cbPlayReadyHeader = 0;
    DRM_DWORD cbPlayReadyObject = 0;
    DRM_BUFFER_STREAM oBufferStream = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMPRO, PERF_FUNC_Drm_PlayReadyObject_ConvertFromWmdrmHeader );
    
    ChkArg( f_pbWmdrmHeader != NULL && f_cbWmdrmHeader > 0 );
    ChkArg( f_pcbPlayReadyObject != NULL );
    ChkArg( ( f_pbPlayReadyObject != NULL && *f_pcbPlayReadyObject > 0 ) ||
            ( f_pbPlayReadyObject == NULL && *f_pcbPlayReadyObject == 0 ) );

    /* Calculate the size of the PlayReady header converted. */
    dr = DRM_PRO_ConvertHeaderFromWmdrmToPlayReady(
                f_pbWmdrmHeader,
                f_cbWmdrmHeader,
                f_pwchPlayReadySilentURL,
                f_cchPlayReadySilentURL,
                f_pwchPlayReadyNonSilentURL,
                f_cchPlayReadyNonSilentURL,
                f_pwchServiceID,
                f_cchServiceID,
                NULL,
                &cbPlayReadyHeader );

    if ( dr != DRM_E_BUFFERTOOSMALL )
    {
        ChkDR( dr );
        
        /* Should not reach here. */
        DRMASSERT( FALSE );
    }
    else
    {
        ChkDR( DRM_SUCCESS );
    }

    /* Calculate the overall size of the PlayReady object generated. */
    cbPlayReadyObject = cbPlayReadyHeader +
                        SIZE_OF_DRM_PLAYREADY_DATA_HEADER       + 
                        2 * SIZE_OF_DRM_PLAYREADY_RECORD_HEADER +
                        MAX_EMBEDDED_STORE_LEN;

    /* If f_pbPlayReadyObject is NULL or the buffer is not large enough, just return the size. */
    if ( f_pbPlayReadyObject == NULL || *f_pcbPlayReadyObject < cbPlayReadyObject )
    {
        *f_pcbPlayReadyObject = cbPlayReadyObject;

        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    ZEROMEM( f_pbPlayReadyObject, cbPlayReadyObject );
    
    *f_pcbPlayReadyObject = cbPlayReadyObject;

    oBufferStream.pbBuffer = f_pbPlayReadyObject;
    oBufferStream.cbBuffer = *f_pcbPlayReadyObject;
    oBufferStream.dwCurrentPos = 0;

    /* Write the overall size of the PlayReady object. */
    ChkDR( _drm_BufferStreamWriteDWORD( &oBufferStream, cbPlayReadyObject ) );

    /* 
    ** Write the record count. There are 2 records, one for PlayReady header,
    ** the other for embedded store.
    */
    ChkDR( _drm_BufferStreamWriteWORD( &oBufferStream, 2 ) );

    /* Write the type of the PlayReady header record. */
    ChkDR( _drm_BufferStreamWriteWORD( &oBufferStream, PLAYREADY_V4_XML_HEADER ) );
    
    /* Write size of the PlayReady header record. */

    //
    // Xbox LIVE specific: disabling conversion warning (C4242) after review.
    //
    #pragma warning( disable:4242 )
    ChkDR( _drm_BufferStreamWriteWORD( &oBufferStream, cbPlayReadyHeader ) );
    #pragma warning( default:4242 )
    //
    // End Xbox LIVE specific
    //

    /* Convert and write the PlayReady header. */
    ChkDR( DRM_PRO_ConvertHeaderFromWmdrmToPlayReady(
                f_pbWmdrmHeader,
                f_cbWmdrmHeader,
                f_pwchPlayReadySilentURL,
                f_cchPlayReadySilentURL,
                f_pwchPlayReadyNonSilentURL,
                f_cchPlayReadyNonSilentURL,
                f_pwchServiceID,
                f_cchServiceID,
                oBufferStream.pbBuffer + __CB_DECL( oBufferStream.dwCurrentPos ),
                &cbPlayReadyHeader ) );

    oBufferStream.dwCurrentPos += cbPlayReadyHeader;

    /* Insert empty embedded store record. */
    ChkDR( _drm_InsertRecord( &oBufferStream, PLAYREADY_EMBEDDED_LICENSE_STORE, NULL, MAX_EMBEDDED_STORE_LEN ) );

ErrorExit:

    ChkECC( ECC_Drm_PlayReadyObject_ConvertFromWmdrmHeader, dr );

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmrevocationstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>

#if DRM_SUPPORT_REVOCATION
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmsecurestore.h>
#include <drmrevocationstore.h>

ENTER_PK_NAMESPACE_CODE;

/*****************************************************************************
** Function: _CreateRevocationStorePassword
**
** Synopsis: create the one-byte-zero hash to open the revocations secure store
**
** Arguments:
**            [f_pcontextBBX] -- blackbox context
**            [f_rgbPassword] -- output buffer
*****************************************************************************/

static DRM_NO_INLINE DRM_RESULT DRM_CALL _CreateRevocationStorePassword(
    __inout                           _RevocationStoreContext *f_pContextRev,
    __out_bcount(DRM_SHA1_DIGEST_LEN) DRM_BYTE                 f_rgbPassword [__CB_DECL(DRM_SHA1_DIGEST_LEN)])
{
    DRM_RESULT dr                                           = DRM_SUCCESS;
    const DRM_BYTE bZero                                    = 0x00;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC__CreateRevocationStorePassword );

    DRMASSERT( f_pContextRev != NULL );

    if( !f_pContextRev->fInitedPassword )
    {
        /* If we've never calculated the password before, do it now */
        ChkDR( DRM_BBX_HashValue(&bZero, SIZEOF (bZero), f_pContextRev->rgbPassword, f_pContextRev->pContextBB ) );
        f_pContextRev->fInitedPassword = TRUE;
    }

    /* Copy the cached password, it will never change. */
    MEMCPY( f_rgbPassword, f_pContextRev->rgbPassword, DRM_SHA1_DIGEST_LEN );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

static DRM_NO_INLINE DRM_RESULT DRM_CALL _LoopkupRevocationLIDFromGUID(
    __in  const DRM_GUID  *f_pRevGUID,
    __out const DRM_ID   **f_pLID )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC__LoopkupRevocationLIDFromGUID );

    DRMASSERT( f_pRevGUID != NULL );
    DRMASSERT( f_pLID     != NULL );

    *f_pLID = NULL;

    if( MEMCMP( f_pRevGUID, &g_guidRevocationTypeRevInfo, SIZEOF( DRM_GUID ) ) == 0 )
    {
        *f_pLID = &g_lidRevocationInfo;
    }
    else if( MEMCMP( f_pRevGUID, &g_guidRevocationTypeRevInfo2, SIZEOF( DRM_GUID ) ) == 0 )
    {
        *f_pLID = &g_lidRevocationInfo2;
    }
    else if( MEMCMP( f_pRevGUID, &g_guidRevocationTypePlayReadySilverLightRuntime, SIZEOF( DRM_GUID ) ) == 0 )
    {
        *f_pLID = &g_lidPRRTRevocation;
    }
    else if( MEMCMP( f_pRevGUID, &g_guidRevocationTypePlayReadySilverLightApplication, SIZEOF( DRM_GUID ) ) == 0 )
    {
        *f_pLID = &g_lidPRAppRevocation;
    }
#if DRM_SUPPORT_DEVICE_REVOCATION
    else if( MEMCMP( f_pRevGUID, &g_guidRevocationTypeDevice, SIZEOF( DRM_GUID ) ) == 0 )
    {
        *f_pLID = &g_lidDeviceRevocation;
    }
#endif
#if DRM_SUPPORT_APP_REVOCATION
    else if( MEMCMP( f_pRevGUID, &g_guidRevocationTypeApp, SIZEOF( DRM_GUID ) ) == 0 )
    {
        *f_pLID = &g_lidAppRevocation;
    }
#endif
#if DRM_SUPPORT_WMDRMNET
    else if( MEMCMP( f_pRevGUID, &g_guidRevocationTypeWMDRMNET, SIZEOF( DRM_GUID ) ) == 0 )
    {
        *f_pLID = &g_lidWMDRMNET_Revocation;
    }
#endif
    else
    {
        ChkDR( DRM_E_REVOCATION_GUID_NOT_RECOGNIZED );
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVS_InitRevocationStore(
    __in  const DRM_DST                      *f_pDatastore,
    __in  const DRM_SECSTORE_CONTEXT         *f_pContextSST,
    __in  const DRM_BB_CONTEXT               *f_pContextBB,
    __out       DRM_REVOCATIONSTORE_CONTEXT  *f_pContextRev )
{
    DRM_RESULT               dr       = DRM_SUCCESS;
    _RevocationStoreContext *pContext = (_RevocationStoreContext*)f_pContextRev;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVS_InitRevocationStore );

    ChkArg( f_pDatastore  != NULL );
    ChkArg( f_pContextSST != NULL );
    ChkArg( f_pContextBB  != NULL );
    ChkArg( f_pContextRev != NULL );

    ZEROMEM( f_pContextRev, SIZEOF( DRM_REVOCATIONSTORE_CONTEXT ) );

    pContext->pContextBB  = (DRM_BB_CONTEXT*)       f_pContextBB;
    pContext->pDatastore  = (DRM_DST*)              f_pDatastore;
    pContext->pContextSST = (DRM_SECSTORE_CONTEXT*) f_pContextSST;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVS_StoreRevocationData(
    __inout                               DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in                            const DRM_GUID                    *f_pRevGUID,
    __in_bcount(f_cbRevocationData) const DRM_BYTE                    *f_pbRevocationData,
    __in                            const DRM_DWORD                    f_cbRevocationData )
{
    DRM_RESULT    dr                               = DRM_SUCCESS;
    DRM_BYTE      rgbPassword[DRM_SHA1_DIGEST_LEN] = {0};
    const DRM_ID *pLID                             = NULL;
    _RevocationStoreContext *pContext              = (_RevocationStoreContext*)f_pContextRev;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVS_StoreRevocationData );

    ChkDR( _LoopkupRevocationLIDFromGUID( f_pRevGUID, &pLID ) );

    ChkDR( _CreateRevocationStorePassword( pContext, rgbPassword ) );

    ChkDR( DRM_SST_SetData( pContext->pContextSST,
                            pLID,
                            NULL,
                            rgbPassword,
                            SECURE_STORE_REVOCATION_DATA,
                            pContext->pDatastore,
                            f_pbRevocationData,
                            f_cbRevocationData ) );
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVS_GetRevocationData(
    __inout                                      DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in                                   const DRM_GUID                    *f_pRevGUID,
    __out_bcount_opt(*f_pcbRevocationData)       DRM_BYTE                    *f_pbRevocationData,
    __inout                                      DRM_DWORD                   *f_pcbRevocationData )
{
    DRM_RESULT    dr                               = DRM_SUCCESS;
    DRM_BYTE      rgbPassword[DRM_SHA1_DIGEST_LEN] = {0};
    const DRM_ID *pLID                             = NULL;
    _RevocationStoreContext *pContext              = (_RevocationStoreContext*)f_pContextRev;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVS_GetRevocationData );

    ChkDR( _LoopkupRevocationLIDFromGUID( f_pRevGUID, &pLID ) );

    ChkDR( _CreateRevocationStorePassword( pContext, rgbPassword ) );

    ChkDR( DRM_SST_GetData( pContext->pContextSST,
                            pLID,
                            NULL,
                            rgbPassword,
                            SECURE_STORE_REVOCATION_DATA,
                            pContext->pDatastore,
                            f_pbRevocationData,
                            f_pcbRevocationData));
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

EXIT_PK_NAMESPACE_CODE;

#endif /* DRM_SUPPORT_REVOCATION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmrsa.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
 * drmrsa.c
 *
 * This file implements RSA signing and encryption of variable length data.
 * It assumes the existence of routines to encrypt a single key sized buffer
 *
 */

#include <drmcommon.h>
#include <drmrsa.h>
#include <drmhash.h>
#include <drmutilities.h>
#include <byteorder.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

#ifndef RSA_REVERSE_OS2IP
#define RSA_REVERSE_OS2IP 0
#endif
      
/*********************************************************************
**
**  Function:  _GenerateMGF1Mask
**
**  Synopsis:  Generates an MGF1 mask using SHA1 as the hash ( see PKCS#1 v2.1 )
**
**  Arguments:  
**     [f_pbSeed]   :  Specifies the seed to use for the mask.
**                     Must be the length specified in f_cbSeed
**     [f_cbSeed]   :  Specifies the size of the seed
**     [f_cbMask]   :  Specifies the size of the mask that is required
**                     Must be the length specified in f_cbMask
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL or out of range
**      DRM_E_ARITHMETIC_OVERFLOW
**          An overflow/underflow occurred while processing the data
*********************************************************************/
static DRM_NO_INLINE DRM_RESULT _GenerateMGF1Mask( 
    __in const                    DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __in const                    DRM_DWORD                      f_cbSeed,
    __in_ecount( f_cbSeed ) const DRM_BYTE                      *f_pbSeed,
    __in const                    DRM_DWORD                      f_cbMask,
    __out_bcount( f_cbMask )      DRM_BYTE                      *f_pbMask 
    )
{
    DRM_RESULT      dr           = DRM_SUCCESS;
    DRM_DWORD       cIterations  = 0;
    DRM_DWORD       i            = 0;
    DRM_DWORD       ibHashOut    = 0;
    DRM_SHA_CONTEXT contextSHA   = DRM_SHA_CONTEXT_DEFAULT;
    DRM_BYTE        rgbHashInput[__CB_DECL( MGF1_CB_MAX_SEED_MAX + SIZEOF( DRM_DWORD ) )] = { 0 };
    DRM_BYTE        rgbTempMask[__CB_DECL( MGF1_CB_MAX_MASK_MAX )]                        = { 0 };
    const DRM_DWORD cbHashInput = f_cbSeed + SIZEOF( DRM_DWORD );

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC__GenerateMGF1Mask );

    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( f_eKeyLength ) );
    ChkArg( 0 < f_cbSeed );
    ChkArg( MGF1_CB_MAX_SEED( (DRM_DWORD)f_eKeyLength ) >= f_cbSeed );
    ChkArg( NULL != f_pbSeed );
    ChkArg( 0 < f_cbMask );
    ChkArg( MGF1_CB_MAX_MASK( (DRM_DWORD)f_eKeyLength ) >= f_cbMask );
    ChkArg( NULL != f_pbMask );

    ChkOverflow( cbHashInput, f_cbSeed );

    cIterations = f_cbMask / DRM_SHA1_DIGEST_LEN;

    if ( f_cbMask % DRM_SHA1_DIGEST_LEN > 0 )
    {
        cIterations++;
    }
    DRMASSERT( cIterations * DRM_SHA1_DIGEST_LEN <= MGF1_CB_MAX_MASK( (DRM_DWORD)f_eKeyLength ) );

    MEMCPY( rgbHashInput, f_pbSeed, f_cbSeed );
        
    for ( i = 0; i < cIterations; i++ )
    {
        ChkDR( DRM_SHA_Init( &contextSHA, eDRM_SHA_1 ) );

        DWORD_TO_NETWORKBYTES( rgbHashInput, f_cbSeed, i );

        ChkDR( DRM_SHA_Update( rgbHashInput, cbHashInput, &contextSHA ) );
        ChkDR( DRM_SHA_Finalize( &contextSHA, DRM_SHA1_DIGEST_LEN, &( rgbTempMask[ibHashOut] ) ) );

        ibHashOut += DRM_SHA1_DIGEST_LEN;
    }
    MEMCPY( f_pbMask, rgbTempMask, f_cbMask );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/*********************************************************************
**
**  Function:  _OAEPDecode
**
**  Synopsis:  performs the OAEP decode on an encoded buffer ( see PKCS#1 v2.1 )
**
**  Arguments:  
**     [f_rgbEncData]  :  Specifies the encoded data
**     [f_rgbDecData]  :  Returns the decoded data.
**     [f_pcbDecData]  :  Returns the size of the decoded data
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pcbDecData is NULL
**      DRM_E_ARITHMETIC_OVERFLOW
**          An overflow/underflow occurred while processing the data
**      DRM_E_RSA_DECRYPTION_ERROR
**          The DB/EM used in OAEP decoding is not correct
**
*********************************************************************/
static DRM_RESULT _OAEPDecode(
    __in const                       DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __in const                       DRM_DWORD                      f_cbEncData,
    __in_ecount( f_cbEncData ) const DRM_BYTE                      *f_pbEncData,
    __inout                          DRM_DWORD                     *f_pcbDecData,
     __out_ecount( *f_pcbDecData )   DRM_BYTE                      *f_pbDecData
    )
{
    DRM_RESULT      dr          = DRM_SUCCESS;
    DRM_DWORD       ibCur       = DRM_SHA1_DIGEST_LEN;
    DRM_SHA_CONTEXT contextSHA  = DRM_SHA_CONTEXT_DEFAULT;
    DRM_BYTE        rgbLHash[ __CB_DECL( DRM_SHA1_DIGEST_LEN ) ]         = { 0 };
    DRM_BYTE        rgbSeed[__CB_DECL( DRM_SHA1_DIGEST_LEN )]            = { 0 };
    DRM_BYTE        rgbSeedMask[__CB_DECL( DRM_SHA1_DIGEST_LEN )]        = { 0 };
    DRM_BYTE        rgbDataBlock[__CB_DECL( OAEP_CB_DATABLOCK_MAX )]     = { 0 };
    DRM_BYTE        rgbDataBlockMask[__CB_DECL( OAEP_CB_DATABLOCK_MAX )] = { 0 };
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC__OAEPDecode );

    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( f_eKeyLength ) );
    ChkArg( OAEP_CB_ENCRYPTED_MSG( (DRM_DWORD)f_eKeyLength ) == f_cbEncData );
    ChkArg( NULL != f_pbEncData );
    ChkArg( NULL != f_pcbDecData );
    if ( DRM_RSA_CB_MAX_PLAINTEXT( (DRM_DWORD)f_eKeyLength ) > *f_pcbDecData )
    {
        *f_pcbDecData = DRM_RSA_CB_MAX_PLAINTEXT( f_eKeyLength );
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }
    ChkArg( NULL != f_pbDecData );

    /*
    ** First byte of the EM must be 0
    */
    ChkBOOL( GET_BYTE( f_pbEncData, OAEP_IB_EM_START ) == OAEP_B_EM_START, DRM_E_RSA_DECRYPTION_ERROR );   

    /*
    ** Set up seed buffer
    */
    DRM_BYT_CopyBytes( rgbSeed, 0, f_pbEncData, OAEP_IB_SEED, DRM_SHA1_DIGEST_LEN );

    /*
    ** Set up data block buffer
    */
    DRM_BYT_CopyBytes( rgbDataBlock, 0, f_pbEncData, OAEP_IB_DATABLOCK, OAEP_CB_DATABLOCK( f_eKeyLength ) );
    
    /*
    ** Compute the seed mask and decode the seed
    */
    ChkDR( _GenerateMGF1Mask( f_eKeyLength, OAEP_CB_DATABLOCK( f_eKeyLength ), rgbDataBlock, SIZEOF( rgbSeedMask ), rgbSeedMask ) );
    DRM_XOR( rgbSeed, rgbSeedMask, SIZEOF( rgbSeed ) );

    /*
    ** Compute data block mask from the seed and decode DB
    */
    ChkDR( _GenerateMGF1Mask( f_eKeyLength, SIZEOF( rgbSeed ), rgbSeed, OAEP_CB_DATABLOCK( f_eKeyLength ), rgbDataBlockMask ) );
    DRM_XOR( rgbDataBlock, rgbDataBlockMask, OAEP_CB_DATABLOCK( f_eKeyLength ) );

    /*
    ** Compute LHash for empty label and verify that DB starts with LHash
    */
    ChkDR( DRM_SHA_Init( &contextSHA, eDRM_SHA_1 ) );
    ChkDR( DRM_SHA_Finalize( &contextSHA, SIZEOF( rgbLHash ), rgbLHash ) );
    ChkBOOL( MEMCMP( rgbLHash, rgbDataBlock, SIZEOF( rgbLHash ) ) == 0, DRM_E_RSA_DECRYPTION_ERROR );
    
    /*
    ** Locate a 0x01 value byte to indicate start of original message
    */ 
    while( ( ibCur < DRM_RSA_CB_MODULUS( (DRM_DWORD)f_eKeyLength ) )
        && ( GET_BYTE( rgbDataBlock, ibCur ) == 0x00 ) )
    {
        ibCur++;
    }
    ChkBOOL( ibCur != DRM_RSA_CB_MODULUS( (DRM_DWORD)f_eKeyLength ), DRM_E_RSA_DECRYPTION_ERROR );
    ChkBOOL( GET_BYTE( rgbDataBlock, ibCur ) == OAEP_B_MSG_START, DRM_E_RSA_DECRYPTION_ERROR );

    /*
    ** Finally, output the decoded message
    */
    ibCur++;
    ChkOverflow( (DRM_DWORD)DRM_RSA_CB_MODULUS( f_eKeyLength ), ibCur );
    ChkOverflow( (DRM_DWORD)DRM_RSA_CB_MODULUS( f_eKeyLength ) - ibCur, (DRM_DWORD)OAEP_IB_DATABLOCK );
    *f_pcbDecData = ( DRM_RSA_CB_MODULUS( f_eKeyLength ) - ibCur ) - OAEP_IB_DATABLOCK;
    DRM_BYT_CopyBytes( f_pbDecData, 0, rgbDataBlock, ibCur, *f_pcbDecData );
            
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/*********************************************************************
**
**  Function:  _OAEPEncode
**
**  Synopsis:  performs the OAEP encode on a buffer ( see PKCS#1 v2.1 )
**
**  Arguments:  
**     [f_pbData]     :  Specifies the data to encode
**     [f_cbData]     :  Specifies the length of the data to encode
**     [f_rgbEncData] :  Returns the encoded data
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pbData is NULL of f_cbData is out of range
**
*********************************************************************/
static DRM_RESULT _OAEPEncode(
    __in const                    DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __in_opt                      DRM_VOID                      *f_pOEMContext,
    __in const                    DRM_DWORD                      f_cbData,
    __in_ecount( f_cbData ) const DRM_BYTE                      *f_pbData,
    __inout                       DRM_DWORD                     *f_pcbEncData,
    __out_ecount( *f_pcbEncData ) DRM_BYTE                      *f_pbEncData
    )
{
    DRM_RESULT      dr                = DRM_SUCCESS;
    DRM_SHA_CONTEXT contextSHA        = DRM_SHA_CONTEXT_DEFAULT;
    DRM_BYTE        rgbHash[__CB_DECL( OAEP_CB_DATABLOCK_HASH )]         = { 0 };
    DRM_BYTE        rgbSeed[__CB_DECL( OAEP_CB_SEED )]                   = { 0 };
    DRM_BYTE        rgbSeedMask[__CB_DECL( OAEP_CB_SEED )]               = { 0 };
    DRM_BYTE        rgbDataBlock[__CB_DECL( OAEP_CB_DATABLOCK_MAX )]     = { 0 };
    DRM_BYTE        rgbDataBlockMask[__CB_DECL( OAEP_CB_DATABLOCK_MAX )] = { 0 };
   
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC__OAEPEncode );

    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( f_eKeyLength ) );
    ChkArg( 0 < f_cbData );
    ChkArg( OAEP_CB_DATABLOCK_MSG_MAX( (DRM_DWORD)f_eKeyLength ) >= f_cbData );
    ChkArg( NULL != f_pbData );
    ChkArg( NULL != f_pcbEncData );
    if ( OAEP_CB_ENCRYPTED_MSG( (DRM_DWORD)f_eKeyLength ) > *f_pcbEncData )
    {
        *f_pcbEncData = OAEP_CB_ENCRYPTED_MSG( f_eKeyLength );
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }
    ChkArg( NULL != f_pbEncData );
    
    /*
    ** Set first byte of EM to 0 
    EM.EMStart = 0x00
    */   
    PUT_BYTE( f_pbEncData, OAEP_IB_EM_START, OAEP_B_EM_START );                  
                                  
    /*
    ** Compute Hash of the empty Label 
    ** DB.lHash = Hash( L )
    */
    ChkDR( DRM_SHA_Init( &contextSHA, eDRM_SHA_1 ) );
    ChkDR( DRM_SHA_Finalize( &contextSHA, DRM_SHA1_DIGEST_LEN, rgbHash ) );
    DRM_BYT_CopyBytes( f_pbEncData, OAEP_IB_DATABLOCK_HASH, rgbHash, 0, OAEP_CB_DATABLOCK_HASH );

    /*
    ** Construct PS 
    ** DB.PS = bunch of zeros.
    */
    DRM_BYT_SetBytes( f_pbEncData, OAEP_IB_DATABLOCK_PS, OAEP_CB_DATABLOCK_PS( f_eKeyLength, f_cbData ), 0 );
    
    /*
    ** Write the 0x01 value byte to mark start of original message 
    ** DB.MsgStart = 0x01
    */
    PUT_BYTE( f_pbEncData, OAEP_IB_DATABLOCK_MSG_START( f_eKeyLength, f_cbData ), OAEP_B_MSG_START );

    /*
    ** Copy the original message 
    ** DB.M = original message
    */
    DRM_BYT_CopyBytes( f_pbEncData, OAEP_IB_DATABLOCK_MSG( f_eKeyLength, f_cbData ), f_pbData, 0, f_cbData );
    
    /*
    ** Generate the seed in temporary variable 
    */
    ChkDR( Oem_Random_GetBytes( f_pOEMContext, rgbSeed, SIZEOF( rgbSeed ) ) );
    
    /*
    ** Compute the DB Mask from the seed and XOR it with DB 
    */
    ChkDR( _GenerateMGF1Mask( f_eKeyLength, SIZEOF( rgbSeed ), rgbSeed, OAEP_CB_DATABLOCK( f_eKeyLength ), rgbDataBlockMask ) );
    DRM_BYT_CopyBytes( rgbDataBlock, 0, f_pbEncData, OAEP_IB_DATABLOCK, OAEP_CB_DATABLOCK( f_eKeyLength ) );
    DRM_XOR( rgbDataBlock, rgbDataBlockMask, OAEP_CB_DATABLOCK( f_eKeyLength ) );
    
    /*
    ** Next, compute the seed mask and XOR it with the seed 
    */
    ChkDR( _GenerateMGF1Mask( f_eKeyLength, OAEP_CB_DATABLOCK( f_eKeyLength ), rgbDataBlock, SIZEOF( rgbSeedMask ), rgbSeedMask ) );
    DRM_XOR( rgbSeed, rgbSeedMask, SIZEOF( rgbSeed ) );
    DRM_BYT_CopyBytes( f_pbEncData, OAEP_IB_SEED, rgbSeed, 0, OAEP_CB_SEED );
    DRM_BYT_CopyBytes( f_pbEncData, OAEP_IB_DATABLOCK, rgbDataBlock, 0, OAEP_CB_DATABLOCK( f_eKeyLength ) );

    *f_pcbEncData = OAEP_CB_ENCRYPTED_MSG( f_eKeyLength );
    
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}
/*********************************************************************
**
**  Function:  _PSSVerify
**
**  Synopsis:  Does PSS Verification (see PKCS #1 v2.1)
**
**  Arguments:  
**     [f_pbData]      :  Specifies the original data
**     [f_cbData]      :  Specifies the length of the original data
**     [f_ibData]      :  Specifies the offset from the beginning of the original data
**     [f_pbEncoding]  :  Specifies the encoded/signed data
**     [f_cbEMBits]    :  Specifies the size of the encoded bits
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL or out of range
**      DRM_E_RSA_SIGNATURE_ERROR
**          Failed to verify the signature
**
*********************************************************************/
static DRM_NO_INLINE DRM_RESULT _PSSVerify(
    __in const                                 DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __in                                       DRM_DWORD                      f_cbData,
    __in_ecount( f_cbData ) const              DRM_BYTE                      *f_pbData,
    __in                                       DRM_DWORD                      f_ibData,       
    __in                                       DRM_DWORD                      f_cbEMBits,
    __in_ecount( BITS_TO_BYTES( f_cbEMBits ) ) DRM_BYTE                      *f_pbEncoding
    )
{
    DRM_RESULT      dr           = DRM_SUCCESS;
    DRM_DWORD       cbEncodedMsg = f_cbEMBits / BITS_PER_STANDARD_BYTE;
    DRM_DWORD       cbDataBlock  = 0;
    DRM_DWORD       cZeroBits    = 0;
    DRM_DWORD       i            = 0;
    DRM_SHA_CONTEXT contextSHA   = DRM_SHA_CONTEXT_DEFAULT;
    DRM_BYTE        rgbMPrime[__CB_DECL( PSS_CB_MPRIME )]            = { 0 };
    DRM_BYTE        rgbMPrimeHash [__CB_DECL( DRM_SHA1_DIGEST_LEN )] = { 0 };
    DRM_BYTE        rgbDBMask[__CB_DECL( MGF1_CB_MAX_MASK_MAX )]     = { 0 };
#if SIXTEEN_BIT_ADDRESSING
    DRM_BYTE        rgbTemp[__CB_DECL( DRM_SHA1_DIGEST_LEN )]        = { 0 };
#endif /* SIXTEEN_BIT_ADDRESSING */

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC__PSSVerify );

    if( f_cbEMBits % BITS_PER_STANDARD_BYTE != 0 )
    {
        cbEncodedMsg++;
    }
    cZeroBits = ( BITS_PER_STANDARD_BYTE * cbEncodedMsg ) - f_cbEMBits;

    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( f_eKeyLength ) );
    ChkArg( cbEncodedMsg >= DRM_SHA1_DIGEST_LEN + PSS_CB_SALT + 2 );
    ChkArg( cbEncodedMsg <= DRM_RSA_CB_MODULUS( (DRM_DWORD)f_eKeyLength ) );

    /*
    ** Verify last bit of EM
    */
    ChkBOOL( GET_BYTE( f_pbEncoding, cbEncodedMsg - 1 ) == PSS_B_END_MSG, 
             DRM_E_RSA_SIGNATURE_ERROR );

    /*
    ** Compute the original message hash
    */
    ChkDR( DRM_SHA_Init( &contextSHA, eDRM_SHA_1 ) );                  
    ChkDR( DRM_SHA_UpdateOffset( f_pbData, f_ibData, f_cbData, &contextSHA ) );
    ChkDR( DRM_SHA_Finalize( &contextSHA, DRM_SHA1_DIGEST_LEN, &( rgbMPrime[PSS_CB_ZERO_PAD] ) ) );

    /*
    ** Set up DB and Hash( M' ) in EM
    */
    cbDataBlock = ( cbEncodedMsg - DRM_SHA1_DIGEST_LEN  ) - 1;

#if SIXTEEN_BIT_ADDRESSING
    DRM_BYT_CopyBytes( rgbTemp, 0, f_pbEncoding, cbDataBlock, DRM_SHA1_DIGEST_LEN );
#endif
    
    /*
    ** Check that the requisite leftmost bits of DB are 0
    */
    ChkBOOL( ( GET_BYTE( f_pbEncoding, 0 )
             & ( 0xFF << ( BITS_PER_STANDARD_BYTE - cZeroBits ) ) ) == 0, 
             DRM_E_RSA_SIGNATURE_ERROR );

    /*
    ** Compute DBMask and extract DB
    */
#if SIXTEEN_BIT_ADDRESSING
    ChkDR( _GenerateMGF1Mask( f_eKeyLength,
                              rgbTemp,
                              DRM_SHA1_DIGEST_LEN, 
                              cbDataBlock, 
                              rgbDBMask ));
#else
    ChkDR( _GenerateMGF1Mask(    f_eKeyLength,
                                 DRM_SHA1_DIGEST_LEN, 
                              &( f_pbEncoding[cbDataBlock] ), 
                                 cbDataBlock, 
                                 rgbDBMask ));
#endif
    DRM_XOR( f_pbEncoding, rgbDBMask, cbDataBlock );
    PUT_BYTE( f_pbEncoding, 
              0, 
              ( DRM_BYTE )( GET_BYTE( f_pbEncoding, 0 ) & ( 0xFF >> cZeroBits ) ) );

    /*
    ** Verify that bytes before the salt are all zero followed by 0x01
    */
    for ( ; i < ( cbDataBlock - PSS_CB_SALT ) - 1; i++ )
    {
        ChkBOOL( GET_BYTE( f_pbEncoding, i ) == 0, DRM_E_RSA_SIGNATURE_ERROR );
    }
    ChkBOOL( GET_BYTE( f_pbEncoding, i ) == OAEP_B_MSG_START, DRM_E_RSA_SIGNATURE_ERROR );

    /*
    ** Fill the salt in M' now, compute Hash( M' ) and check against the hash in EM
    */
    DRM_BYT_CopyBytes( rgbMPrime, PSS_IB_SALT, f_pbEncoding, cbDataBlock - PSS_CB_SALT, PSS_CB_SALT );
    ChkDR( DRM_SHA_Init( &contextSHA, eDRM_SHA_1 ) );
    ChkDR( DRM_SHA_Update( rgbMPrime, PSS_CB_MPRIME, &contextSHA ) );
    ChkDR( DRM_SHA_Finalize ( &contextSHA, DRM_SHA1_DIGEST_LEN, rgbMPrimeHash ) );

    ChkBOOL( DRM_BYT_CompareBytes( f_pbEncoding, 
                                   cbDataBlock, 
                                   rgbMPrimeHash, 
                                   0, 
                                   DRM_SHA1_DIGEST_LEN ) == 0,
             DRM_E_RSA_SIGNATURE_ERROR );
    
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/*********************************************************************
**
**  Function:  _PSSEncode
**
**  Synopsis:  Does PSS Encoding on a variable sized buffer (see PKCS #1 v2.1)
**
**  Arguments:  
**     [f_pbData]        :  Specifies the data to encode
**     [f_cbData]        :  Specifies the length of the data to encode
**     [f_ibData]        :  Specifies the offset from the beginning of the original data
**     [f_cbEMBits]      :  Specifies the bit length of the encoded message
**     [f_rgbEncodedMsg] :  Returns the PSS encoded data
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL or out of range
**
*********************************************************************/
static DRM_RESULT _PSSEncode(
    __in const                                  DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __in                                        DRM_DWORD                      f_cbData,
    __in_ecount( f_cbData ) const               DRM_BYTE                      *f_pbData,
    __in                                        DRM_DWORD                      f_ibData,      
    __in                                        DRM_DWORD                      f_cbEMBits,
    __out_ecount( BITS_TO_BYTES( f_cbEMBits ) ) DRM_BYTE                      *f_pEncodedMsg
    )
{
    DRM_RESULT      dr           = DRM_SUCCESS;
    DRM_DWORD       ibCurr       = PSS_CB_ZERO_PAD;
    DRM_SHA_CONTEXT contextSHA   = DRM_SHA_CONTEXT_DEFAULT;
    DRM_BYTE        rgbMPrime[__CB_DECL( PSS_CB_MPRIME )]                = { 0 };
    DRM_BYTE        rgbDataBlockMask[__CB_DECL( OAEP_CB_DATABLOCK_MAX )] = { 0 };
#if SIXTEEN_BIT_ADDRESSING
    DRM_DWORD       ibData       = f_ibData;
    DRM_DWORD       cbData       = f_cbData;
    DRM_BYTE        bTemp        = 0x00;
#endif /* SIXTEEN_BIT_ADDRESSING */    

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC__PSSEncode );

    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( f_eKeyLength ) );
    ChkArg( f_pbData   != NULL );
    ChkArg( f_cbData   >  0 );
    ChkArg( BITS_TO_BYTES( f_cbEMBits ) == DRM_RSA_CB_MODULUS( (DRM_DWORD)f_eKeyLength ) ) ;
    
    /*
    ** Generate M' and compute its hash
    */   
    ChkDR( DRM_SHA_Init( &contextSHA, eDRM_SHA_1 ) );  
    ChkDR( DRM_SHA_Update( f_pbData, f_cbData, &contextSHA ) );
    ChkDR( DRM_SHA_Finalize( &contextSHA, DRM_SHA1_DIGEST_LEN, &( rgbMPrime[ibCurr] ) ) );
    ibCurr += DRM_SHA1_DIGEST_LEN; 

    /*
    ** Calculate Hash( M' )
    */
    ChkDR( DRM_SHA_Init( &contextSHA, eDRM_SHA_1 ) );
    ChkDR( DRM_SHA_Update( rgbMPrime, ibCurr, &contextSHA ) );
    ChkDR( DRM_SHA_Finalize( &contextSHA, DRM_SHA1_DIGEST_LEN, &( f_pEncodedMsg[OAEP_CB_DATABLOCK( f_eKeyLength )] ) ) );

    ZEROMEM( f_pEncodedMsg, OAEP_CB_DATABLOCK( f_eKeyLength ) - 1 );
    
    /*
    ** 0x01 byte separating padding and salt 
    */
    PUT_BYTE( f_pEncodedMsg, OAEP_CB_DATABLOCK( f_eKeyLength ) - 1, OAEP_B_MSG_START );

    ChkDR( _GenerateMGF1Mask(    f_eKeyLength,
                                 DRM_SHA1_DIGEST_LEN, 
                              &( f_pEncodedMsg[OAEP_CB_DATABLOCK( f_eKeyLength )] ), 
                                 OAEP_CB_DATABLOCK( f_eKeyLength ), 
                                 rgbDataBlockMask ) );

    DRM_XOR( f_pEncodedMsg, rgbDataBlockMask, OAEP_CB_DATABLOCK( f_eKeyLength ) );
    f_pEncodedMsg[0] &= ( 0xFF >> ( DRM_RSA_CBITS_MODULUS( f_eKeyLength ) - f_cbEMBits ) );
    PUT_BYTE( f_pEncodedMsg, DRM_RSA_CB_MODULUS( f_eKeyLength ) - 1, PSS_B_END_MSG );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
**  Function:  DRM_RSA_OaepDecrypt
**
**  Synopsis:  Decrypts a cipher text that was encrypted using 
**             PKCS #1 RSAES-OAEP v2.1. MGF1 is used as the mask
**             generation function and SHA1 is the hashing algorithm.
**             This version of OAEP decrypt uses an empty string for 
**             the "Label".
**
**  Arguments:  
**     [f_pPrivateKey]   : Specifies the private key to use. 
**                         NULL indicates the private key baked into
**                         the device should be used.
**     [f_rgbCiphertext] : Specifies the encrypted text
**     [f_rgpbPlaintext] : Returns the decrypted data.
**     [f_pcbPlaintext]  : Returns the size of the original plaintext
**     [f_pCryptoCtx]     : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pcbPlaintext is NULL
**      DRM_E_OEM_RSA_DECRYPTION_ERROR
**          An error occurred while processing the data
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_RSA_OaepDecrypt(
    __in const                          DRM_RSA_PRIVATE_KEY *f_pPrivateKey,
    __in const                          DRM_DWORD            f_cbCiphertext,
    __in_ecount( f_cbCiphertext ) const DRM_BYTE            *f_pbCiphertext,
    __inout                             DRM_DWORD           *f_pcbPlaintext,
    __out_ecount( *f_pcbPlaintext )     DRM_BYTE            *f_pbPlaintext,
    __in                                DRM_CRYPTO_CONTEXT  *f_pCryptoCtx 
    )
{
    DRM_RESULT dr           = DRM_SUCCESS;
    const DRM_BYTE  *pbData = NULL;
    DRM_RSA_SUPPORTED_KEY_LENGTHS eKeyLength = eDRM_RSA_UNKNOWN;
#if RSA_REVERSE_OS2IP == 1
    #if TARGET_LITTLE_ENDIAN
    DRM_DWORD  i            = 0;
    DRM_BYTE   rgbTempOS2IP[__CB_DECL( DRM_RSA_CB_MODULUS_MAX )]  = { 0 };
    #endif /* TARGET_LITTLE_ENDIAN */
#endif  /* RSA_REVERSE_OS2IP */
    DRM_BYTE   rgbDecrypted[__CB_DECL( DRM_RSA_CB_MODULUS_MAX )]  = { 0 };    

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMRSA, PERF_FUNC_DRM_RSA_OaepDecrypt );

    ChkArg( NULL != f_pPrivateKey );
    ChkDR( OEM_RSA_GetPrivateKeyLength( f_pPrivateKey, &eKeyLength ) );
    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( eKeyLength ) );
    ChkArg( 0 < f_cbCiphertext );
    ChkArg( DRM_RSA_CB_CIPHERTEXT( (DRM_DWORD)eKeyLength ) >= f_cbCiphertext );
    ChkArg( SIZEOF( rgbDecrypted ) >= f_cbCiphertext );
    ChkArg( NULL != f_pbCiphertext );
    ChkArg( NULL != f_pcbPlaintext );
    if ( DRM_RSA_CB_MAX_PLAINTEXT( (DRM_DWORD)eKeyLength ) > *f_pcbPlaintext )
    {
        *f_pcbPlaintext = DRM_RSA_CB_MAX_PLAINTEXT( eKeyLength );
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }
    ChkArg( NULL != f_pbPlaintext );
    ChkArg( NULL != f_pCryptoCtx );
       
   
    /*
    ** Perform OS2IP on encrypted data if required
    */
#if RSA_REVERSE_OS2IP == 1

    #if TARGET_LITTLE_ENDIAN

    for( ; i < DRM_RSA_CB_MODULUS( eKeyLength ); i++ )
    {
        PUT_BYTE( rgbTempOS2IP, i, GET_BYTE( f_pbCiphertext, ( DRM_RSA_CB_MODULUS( eKeyLength ) - 1 ) - i ) );
    }
    pbData = rgbTempOS2IP;
        
    #else  /* TARGET_LITTLE_ENDIAN */

    pbData = f_pbCiphertext;

    #endif /* TARGET_LITTLE_ENDIAN */

#else  /* RSA_REVERSE_OS2IP == 1 */

    pbData = f_pbCiphertext;

#endif /* RSA_REVERSE_OS2IP == 1 */

    /*
    ** Decrypt the buffer with the private key
    */
    ChkDR( OEM_RSA_Decrypt( f_pPrivateKey, f_cbCiphertext, pbData, rgbDecrypted, f_pCryptoCtx ) );
             
    /*
    ** Perform I2OSP on decrypted data if required
    */
#if RSA_REVERSE_OS2IP == 1

    #if TARGET_LITTLE_ENDIAN

    for( i = 0; i < DRM_RSA_CB_MODULUS( eKeyLength ); i++ )
    {
        PUT_BYTE( rgbTempOS2IP, i, GET_BYTE( rgbDecrypted, ( DRM_RSA_CB_MODULUS( eKeyLength ) - 1 ) - i ) );
    }
    pbData = rgbTempOS2IP;

    #else /* TARGET_LITTLE_ENDIAN */

    pbData = rgbDecrypted;

    #endif /* TARGET_LITTLE_ENDIAN */

#else   /* RSA_REVERSE_OS2IP */

    pbData = rgbDecrypted;

#endif  /* RSA_REVERSE_OS2IP */

    /*
    ** Decode EM and hand out
    */
    ChkDR( _OAEPDecode( eKeyLength, f_cbCiphertext, pbData, f_pcbPlaintext, f_pbPlaintext ) );
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


/*********************************************************************
**
**  Function:  DRM_RSA_OaepEncrypt
**
**  Synopsis:  Encrypts a cipher text using PKCS #1 RSAES-OAEP v2.1.
**             MGF1 is used as the mask generation function and SHA1 is 
**             the hashing algorithm. This version of OAEP encrypt uses
**             an empty string for the "Label".
**
**  Arguments:  
**     [f_pPublicKey]    :  Specifies the public key to use 
**     [f_rgbPlaintext]  :  Specifies the plain text to encrypt
**     [f_cbPlaintext]   :  Specifies the size of the plain text
**     [f_rgbCiphertext] :  Returns the encrypted data.
**     [f_pCryptoCtx]     : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL or out of range
**      DRM_E_OEM_RSA_ENCRYPTION_ERROR
**          An error occurred while processing the data
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_RSA_OaepEncrypt(
    __in_opt                           DRM_VOID           *f_pOEMContext,
    __in const                         DRM_RSA_PUBLIC_KEY *f_pPublicKey,
    __in const                         DRM_DWORD           f_cbPlaintext,
    __in_ecount( f_cbPlaintext ) const DRM_BYTE           *f_pbPlaintext,
    __inout                            DRM_DWORD          *f_pcbCiphertext,
    __out_ecount( *f_pcbCiphertext )   DRM_BYTE           *f_pbCiphertext,
    __in                               DRM_CRYPTO_CONTEXT *f_pCryptoCtx 
    )
{
    DRM_RESULT dr                    = DRM_SUCCESS;
    const DRM_BYTE  *pbEncodedData   = NULL;
    const DRM_BYTE  *pbEncryptedData = NULL;
    DRM_RSA_SUPPORTED_KEY_LENGTHS eKeyLength = eDRM_RSA_UNKNOWN;
#if RSA_REVERSE_OS2IP == 1
    #if TARGET_LITTLE_ENDIAN
    DRM_DWORD  i                     = 0;
    DRM_BYTE   rgbTempOS2IP[__CB_DECL( OAEP_CB_ENCRYPTED_MSG_MAX )]  = { 0 };
    #endif /* TARGET_LITTLE_ENDIAN */
#endif  /* RSA_REVERSE_OS2IP */
    DRM_BYTE   rgbEncoded[__CB_DECL( OAEP_CB_ENCRYPTED_MSG_MAX )]    = { 0 };  
    DRM_DWORD  cbEncoded = 0;
    DRM_DWORD  cbCiphertext = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMRSA, PERF_FUNC_DRM_RSA_OaepEncrypt );

    ChkArg( NULL != f_pPublicKey );
    ChkDR( OEM_RSA_GetPublicKeyLength( f_pPublicKey, &eKeyLength ) );
    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( eKeyLength ) );
    ChkArg( 0 < f_cbPlaintext );
    ChkArg( OAEP_CB_DATABLOCK_MSG_MAX( (DRM_DWORD)eKeyLength ) >= f_cbPlaintext );
    ChkArg( NULL != f_pbPlaintext );
    ChkArg( NULL != f_pcbCiphertext );
    if ( OAEP_CB_ENCRYPTED_MSG( (DRM_DWORD)eKeyLength ) > *f_pcbCiphertext )
    {
         *f_pcbCiphertext = OAEP_CB_ENCRYPTED_MSG( eKeyLength );
         ChkDR( DRM_E_BUFFERTOOSMALL );
    }
    ChkArg( NULL != f_pbCiphertext );
    ChkArg( NULL != f_pCryptoCtx );

    cbCiphertext = *f_pcbCiphertext;
    *f_pcbCiphertext = OAEP_CB_ENCRYPTED_MSG( eKeyLength );
    
    /*
    ** Compute encoded message
    */
    cbEncoded = SIZEOF( rgbEncoded );
    ChkDR( _OAEPEncode( eKeyLength, f_pOEMContext, f_cbPlaintext, f_pbPlaintext, &cbEncoded, rgbEncoded ) );
    if ( ( SIZEOF( rgbEncoded ) < cbEncoded )
      || ( cbCiphertext < cbEncoded ) )
    {
        ChkDR( DRM_E_CRYPTO_FAILED );
    }

/*
** Perform OS2IP( EM ): Reverse encoded message
*/
#if RSA_REVERSE_OS2IP == 1

    #if TARGET_LITTLE_ENDIAN
    
    for( ; i < cbEncoded; i++ )
    {
        PUT_BYTE( rgbTempOS2IP, i,  GET_BYTE( rgbEncoded, ( cbEncoded - 1 ) - i ) );
    }
    pbEncodedData = rgbTempOS2IP;
    pbEncryptedData = rgbEncoded;
    
    #else /* TARGET_LITTLE_ENDIAN */
    
    pbEncodedData = rgbEncoded;
    pbEncryptedData = f_pbCiphertext;
    
    #endif /* TARGET_LITTLE_ENDIAN */

#else   /* RSA_REVERSE_OS2IP == 1 */

    pbEncodedData = rgbEncoded;
    pbEncryptedData = f_pbCiphertext;

#endif  /* RSA_REVERSE_OS2IP == 1 */
                        
    /*
    ** Encrypt the buffer with the public key
    */                                     
    ChkDR( OEM_RSA_Encrypt( f_pPublicKey, cbEncoded, pbEncodedData, ( DRM_BYTE * )pbEncryptedData, f_pCryptoCtx ) );

/*
** Compute I2OSP for encrypted message: reverse encrypted message
*/
#if RSA_REVERSE_OS2IP == 1
    
    #if TARGET_LITTLE_ENDIAN

    for( i = 0; i < cbEncoded; i++ )
    {
        PUT_BYTE( f_pbCiphertext, i, GET_BYTE( pbEncryptedData, ( cbEncoded - 1 ) - i ) );
    }
    
    #endif /* TARGET_LITTLE_ENDIAN */

#endif  /* RSA_REVERSE_OS2IP */

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/**********************************************************************
**
**  Function: DRM_RSA_PssSign
**
**  Synopsis: RSA signs the given data with the privkey. 
**            Uses PSS (see PKCS #1 v2.1)
**
**  Arguments:
**     [f_pPrivateKey]   : Specifies the private key to use.
**                         NULL indicates the private key baked into
**                         the device should be used
**     [f_pbMsg]         : Specifies the Message to sign
**     [f_cbMsg]         : Specifies the length of the original message
**     [f_ibMsg]         : Specifies the offset from the beginning of the original message
**                         buffer
**     [f_prgbSignature] : Returns the computed RSA signature
**     [f_pCryptoCtx]     : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL or out of range
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_RSA_PssSign(
    __in const                      DRM_RSA_PRIVATE_KEY *f_pPrivateKey,
    __in const                      DRM_DWORD            f_cbMsg,
    __in_ecount( f_cbMsg ) const    DRM_BYTE            *f_pbMsg,
    __in const                      DRM_DWORD            f_ibMsg,    
    __inout                         DRM_DWORD           *f_pcbSignature,
    __out_ecount( *f_pcbSignature ) DRM_BYTE            *f_pbSignature,
    __in                            DRM_CRYPTO_CONTEXT  *f_pCryptoCtx 
    )
{
    DRM_RESULT dr              = DRM_SUCCESS;
    DRM_BYTE  *pbDataEncoded   = NULL;
    DRM_BYTE  *pbDataEncrypted = NULL;
    DRM_RSA_SUPPORTED_KEY_LENGTHS eKeyLength = eDRM_RSA_UNKNOWN;
#if RSA_REVERSE_OS2IP == 1
    #if TARGET_LITTLE_ENDIAN
    DRM_DWORD  i               = 0;
    DRM_BYTE   rgbTempOS2IP[__CB_DECL( DRM_RSA_CB_MODULUS_MAX )] = { 0 };
    #endif /* TARGET_LITTLE_ENDIAN */
#endif  /* RSA_REVERSE_OS2IP */
    DRM_BYTE   rgbData[__CB_DECL( DRM_RSA_CB_MODULUS_MAX )]      = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMRSA, PERF_FUNC_DRM_RSA_PssSign );

    ChkArg( NULL != f_pPrivateKey );
    ChkDR( OEM_RSA_GetPrivateKeyLength( f_pPrivateKey, &eKeyLength ) );
    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( eKeyLength ) );
    ChkArg( 0 < f_cbMsg );
    ChkArg( NULL != f_pbMsg );
    ChkArg( NULL != f_pcbSignature );
    if ( DRM_RSA_CB_MODULUS( (DRM_DWORD)eKeyLength ) > *f_pcbSignature )
    {
        *f_pcbSignature = DRM_RSA_CB_MODULUS( eKeyLength );
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }
    ChkArg( NULL != f_pbSignature );
    ChkArg( NULL != f_pCryptoCtx );

    *f_pcbSignature = DRM_RSA_CB_MODULUS( eKeyLength );
    
    ChkDR( _PSSEncode( eKeyLength, 
                       f_cbMsg,
                       f_pbMsg, 
                       f_ibMsg,
                       DRM_RSA_CBITS_MODULUS( eKeyLength ) - 1, 
                       rgbData ) );
                          
#if RSA_REVERSE_OS2IP == 1

    #if TARGET_LITTLE_ENDIAN
    
    for ( ; i < DRM_RSA_CB_MODULUS( eKeyLength ); i++ )
    {
        PUT_BYTE( rgbTempOS2IP, 
                  i, 
                  GET_BYTE( rgbData, ( DRM_RSA_CB_MODULUS( eKeyLength )( eKeyLength ) - 1 ) - i ) );
    }
    pbDataEncoded = rgbTempOS2IP;
    pbDataEncrypted = rgbData;
    
    #else /* TARGET_LITTLE_ENDIAN */
    
    pbDataEncoded = rgbData;
    pbDataEncrypted = f_pbSignature;
    
    #endif /* TARGET_LITTLE_ENDIAN */
    
#else  /* RSA_REVERSE_OS2IP */

    pbDataEncoded = rgbData;
    pbDataEncrypted = f_pbSignature;
    
#endif  /* RSA_REVERSE_OS2IP */

    /*
    ** Decrypt the buffer with the private key
    */                                
    ChkDR( OEM_RSA_Decrypt( f_pPrivateKey, DRM_RSA_CB_MODULUS( eKeyLength ), pbDataEncoded, pbDataEncrypted, f_pCryptoCtx ) );
    
#if RSA_REVERSE_OS2IP == 1

    #if TARGET_LITTLE_ENDIAN

    for ( i = 0; i < DRM_RSA_CB_MODULUS( eKeyLength ); i++ )
    {
        PUT_BYTE( f_pbSignature, i, GET_BYTE( pbDataEncrypted, ( DRM_RSA_CB_MODULUS( eKeyLength ) - 1 ) - i ) );
    }
    
    #endif /* TARGET_LITTLE_ENDIAN */
    
#endif  /* RSA_REVERSE_OS2IP */
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/**********************************************************************
**
**  Function: DRM_RSA_PssVerify
**
**  Synopsis: Verifies an RSA signature using the given pubkey. 
**            Uses PSS (see PKCS #1 v2.1)
**
**  Arguments:
**     [f_pPublicKey]   : Specifies the public key to use.
**     [f_pbMsg]        : Specifies the original message
**     [f_cbMsg]        : Specifies the length of the original message
**     [f_ibMsg]        : Specifies the offset from the beginning of the original message
**                        buffer
**     [f_rgbSignature] : Specifies the signature to verify
**     [f_pCryptoCtx]     : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL or out of range
**      DRM_E_RSA_SIGNATURE_ERROR
**          Failed to verify the signature
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RSA_PssVerify(
    __in const                         DRM_RSA_PUBLIC_KEY  *f_pPublicKey,
    __in                               DRM_DWORD            f_cbMsg,
    __in_ecount( f_cbMsg ) const       DRM_BYTE            *f_pbMsg,
    __in const                         DRM_DWORD            f_ibMsg,
    __in const                         DRM_DWORD            f_cbSignature,
    __in_ecount( f_cbSignature ) const DRM_BYTE            *f_pbSignature,
    __in                               DRM_CRYPTO_CONTEXT  *f_pCryptoCtx 
    )
{
    DRM_RESULT dr              = DRM_SUCCESS;    
    DRM_RSA_SUPPORTED_KEY_LENGTHS eKeyLength = eDRM_RSA_UNKNOWN;
#if RSA_REVERSE_OS2IP == 1
    #if TARGET_LITTLE_ENDIAN
    DRM_DWORD  i               = 0;
    DRM_BYTE   rgbTempOS2IP[__CB_DECL( DRM_RSA_CB_MODULUS_MAX )] = { 0 };
    #endif /* TARGET_LITTLE_ENDIAN */
#endif  /* RSA_REVERSE_OS2IP */
    DRM_BYTE   rgbTempData[__CB_DECL( DRM_RSA_CB_MODULUS_MAX )]  = { 0 };
    DRM_BYTE  *pbData          = ( DRM_BYTE * )f_pbSignature;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMRSA, PERF_FUNC_DRM_RSA_PssVerify );

    ChkArg( NULL != f_pPublicKey );
    ChkDR( OEM_RSA_GetPublicKeyLength( f_pPublicKey, &eKeyLength ) );
    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( eKeyLength ) );
    ChkArg( 0 < f_cbMsg );
    ChkArg( NULL != f_pbMsg );
    ChkArg( 0 < f_cbSignature );
    ChkArg( NULL != f_pbSignature );
    ChkArg( f_pCryptoCtx != NULL );


    ChkArg( DRM_RSA_CB_MODULUS( (DRM_DWORD)eKeyLength ) == f_cbSignature );

    /*
    ** Perform OS2IP on the signature: reverse the signature
    */    
#if RSA_REVERSE_OS2IP == 1
    
    #if TARGET_LITTLE_ENDIAN

    for ( ; i < DRM_RSA_CB_MODULUS( eKeyLength ); i++ )
    {
        PUT_BYTE( rgbTempOS2IP, i, GET_BYTE( f_pbSignature, ( DRM_RSA_CB_MODULUS( eKeyLength ) - 1 ) - i ) );
    }
    pbData = rgbTempOS2IP;

    #endif /* TARGET_LITTLE_ENDIAN */
       
#endif  /* RSA_REVERSE_OS2IP == 1 */

    /*
    ** Encrypt the buffer with the public key
    */ 
    dr = OEM_RSA_Encrypt( f_pPublicKey, f_cbSignature, pbData, rgbTempData, f_pCryptoCtx );
    ChkBOOL( DRM_SUCCEEDED( dr ), DRM_E_RSA_SIGNATURE_ERROR );
    
    /* 
    ** Perform I2OSP on the decrypted data to get EM: reverse decrypted data
    */
#if RSA_REVERSE_OS2IP == 1

    #if TARGET_LITTLE_ENDIAN

    for ( i = 0; i < DRM_RSA_CB_MODULUS( eKeyLength ); i++ )
    {
        PUT_BYTE( rgbTempOS2IP, i, GET_BYTE( rgbTempData, ( DRM_RSA_CB_MODULUS( eKeyLength ) - 1 ) - i ) );
    }
    pbData = rgbTempOS2IP;
    
    #else /* TARGET_LITTLE_ENDIAN */
    
    pbData = rgbTempData;
    
    #endif /* TARGET_LITTLE_ENDIAN */

#else   /* RSA_REVERSE_OS2IP == 1 */

    pbData = rgbTempData;

#endif  /* RSA_REVERSE_OS2IP == 1 */

    /*
    ** Verify Encoded Message
    */
    ChkDR( _PSSVerify( eKeyLength, 
                       f_cbMsg, 
                       f_pbMsg, 
                       f_ibMsg, 
                       DRM_RSA_CBITS_MODULUS( eKeyLength ) - 1,
                       pbData ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmsecstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmsecurestore.h>
#include <drmhmac.h>
#include <oem.h>
#include <drmdatastore.h>

ENTER_PK_NAMESPACE_CODE;

/*
    A secure store entry in the DST will look like this:
    4 bytes -- type of entry ( see type enum )
    20 bytes -- hmac of data with password
    n bytes of data
    The decrypted data will contain attributes name/value pairs like so:
    DRM_WORD ( length in bytes of the attribute name )
    n bytes of name
    TOKEN - 12 bytes
    --- Next attribute
*/

static const DRM_DST_NAMESPACE SEC_STORE_NAMESPACE                 = { TWO_BYTES('s', 'e'),  TWO_BYTES('c', 'u'),  TWO_BYTES('r', 'e'),  TWO_BYTES('s', 't'),  TWO_BYTES('o', 'r'),  TWO_BYTES('e', '\0') };
static const DRM_DST_NAMESPACE METER_STORE_NAMESPACE               = { TWO_BYTES('m', 'e'),  TWO_BYTES('t', 'e'),  TWO_BYTES('r', 'i'),  TWO_BYTES('n', 'g'),  TWO_BYTES('s', 't'),  TWO_BYTES('o', 'r'),   TWO_BYTES('e', '\0') };
static const DRM_DST_NAMESPACE DEVICE_REGISTRATION_STORE_NAMESPACE = { TWO_BYTES('d', 'e'),  TWO_BYTES('v', 'i'),  TWO_BYTES('c', 'e'),  TWO_BYTES('r', 'e'),  TWO_BYTES('g', 's'),  TWO_BYTES('t', 'o'),   TWO_BYTES('r', 'e')  };
static const DRM_DST_NAMESPACE PLAYLIST_BURN_STORE_NAMESPACE       = { TWO_BYTES('p', 'l'),  TWO_BYTES('a', 'y'),  TWO_BYTES('l', 'i'),  TWO_BYTES('s', 't'),  TWO_BYTES('b', 'u'),  TWO_BYTES('r', 'n'),   TWO_BYTES('s', 't'),   TWO_BYTES('r', '\0') };
static const DRM_DST_NAMESPACE TRANSIENT_STORE_NAMESPACE           = { TWO_BYTES('t', 'r'),  TWO_BYTES('a', 'n'),  TWO_BYTES('s', 'i'),  TWO_BYTES('e', 'n'),  TWO_BYTES('t', 's'),  TWO_BYTES('t', 'o'),   TWO_BYTES('r', 'e')  };

typedef enum
{
    ALLOW_ALL           = 0x0,
    DISALLOW_DEVICE_REG = 0x1,
    DISALLOW_PLB        = 0x2,
    DISALLOW_CACHEDCERT = 0x4,
    DISALLOW_REVOCATION = 0x8,
} eDRM_IS_VALID_SECURE_STORE_TYPE_OPTIONS;

static DRM_NO_INLINE DRM_BOOL IsValidSecureStoreType(
    IN       eDRM_SECURE_STORE_TYPE f_eType,
    IN       DRM_DWORD              f_dwOptions )
{
    DRM_BOOL fAllowRevocation   = ((f_dwOptions & DISALLOW_REVOCATION ) == 0);
    DRM_BOOL fAllowDeviceReg    = ((f_dwOptions & DISALLOW_DEVICE_REG ) == 0);
    DRM_BOOL fAllowPlaylistBurn = ((f_dwOptions & DISALLOW_PLB        ) == 0);
    DRM_BOOL fAllowCachedCert   = ((f_dwOptions & DISALLOW_CACHEDCERT ) == 0);
    return ( ( f_eType == SECURE_STORE_LICENSE_DATA    )
          || ( f_eType == SECURE_STORE_GLOBAL_DATA     )
          || ( fAllowRevocation   && ( f_eType == SECURE_STORE_REVOCATION_DATA          ) )
          || ( f_eType == SECURE_STORE_METERING_DATA   )
          || ( f_eType == SECURE_STORE_TRANSIENT_DATA  )
          || ( fAllowDeviceReg    && ( f_eType == SECURE_STORE_DEVICE_REGISTRATION_DATA ) )
          || ( fAllowPlaylistBurn && ( f_eType == SECURE_STORE_PLAYLIST_BURNING_DATA    ) )
          || ( fAllowCachedCert   && ( f_eType == SECURE_STORE_CACHED_CERTIFICATE_DATA  ) ) );
}

static DRM_NO_INLINE const DRM_DST_NAMESPACE* MapSecureStoreTypeToNamespace(
    IN       eDRM_SECURE_STORE_TYPE f_eType )
{
    switch( f_eType )
    {
    case SECURE_STORE_METERING_DATA:
        return &METER_STORE_NAMESPACE;
    case SECURE_STORE_PLAYLIST_BURNING_DATA:
        return &PLAYLIST_BURN_STORE_NAMESPACE;
    case SECURE_STORE_DEVICE_REGISTRATION_DATA:
        return &DEVICE_REGISTRATION_STORE_NAMESPACE;
    case SECURE_STORE_TRANSIENT_DATA:
        return &TRANSIENT_STORE_NAMESPACE;
    case SECURE_STORE_GLOBAL_DATA: /* Fall through */
    case SECURE_STORE_REVOCATION_DATA:
    case SECURE_STORE_LICENSE_DATA:
    case SECURE_STORE_CACHED_CERTIFICATE_DATA:
    default:
        return &SEC_STORE_NAMESPACE;
    }
}

DRM_NO_INLINE DRM_VOID _PrepareTokenForWrite(
    const TOKEN    *pToken,
    DRM_BYTE       *pbPersistedToken)
{
    DRM_RESULT dr = DRM_SUCCESS;
    PERSISTEDTOKEN persistedToken = { 0 };
    
    ChkArg( pToken != NULL && pbPersistedToken != NULL );

    persistedToken.TokenType = pToken->TokenType;

    switch( persistedToken.TokenType )
    {
    case TOKEN_LONG:
        persistedToken.val.lValue = pToken->val.lValue;
        FIX_ENDIAN_DWORD( persistedToken.val.lValue );
        break;
    case TOKEN_DATETIME:
        persistedToken.val.u64DateTime = pToken->val.u64DateTime;
        FIX_ENDIAN_QWORD( persistedToken.val.u64DateTime );
        break;
    case TOKEN_BYTEBLOB:
        persistedToken.val.lValue = (DRM_LONG)pToken->val.byteValue.cbBlob;
        FIX_ENDIAN_DWORD( persistedToken.val.lValue );
        DRM_BYT_CopyBytes( pbPersistedToken, 
                            SIZEOF( PERSISTEDTOKEN ), 
                            pToken->val.byteValue.pbBlob, 
                            0, 
                            pToken->val.byteValue.cbBlob );
        break;
    default:
        DRMASSERT( FALSE );
        break;
    }
    FIX_ENDIAN_DWORD( persistedToken.TokenType );

    MEMCPY( pbPersistedToken, (DRM_BYTE*)&persistedToken, SIZEOF( PERSISTEDTOKEN ) );
ErrorExit:
    return;
}


static DRM_NO_INLINE DRM_VOID DRM_CALL _PrepareTokenForRead(
    DRM_BYTE       *pbPersistedToken,
    TOKEN          *pToken)
{
    DRM_RESULT dr = DRM_SUCCESS;
    PERSISTEDTOKEN persistedToken;
    
    ChkArg( pToken != NULL && pbPersistedToken != NULL );

    /* Input may not be aligned */
    MEMCPY( (DRM_BYTE*)&persistedToken, pbPersistedToken, SIZEOF( PERSISTEDTOKEN ) );

    pToken->TokenType = persistedToken.TokenType;

    FIX_ENDIAN_DWORD( pToken->TokenType );
    switch( pToken->TokenType )
    {
    case TOKEN_LONG:
         pToken->val.lValue =  persistedToken.val.lValue;
        FIX_ENDIAN_DWORD( pToken->val.lValue );
        break;
    case TOKEN_DATETIME:
        pToken->val.u64DateTime = persistedToken.val.u64DateTime;
        FIX_ENDIAN_QWORD( pToken->val.u64DateTime );
        break;
    case TOKEN_BYTEBLOB:
        pToken->val.byteValue.cbBlob = (DRM_DWORD)persistedToken.val.lValue;
        FIX_ENDIAN_DWORD( pToken->val.byteValue.cbBlob );
        pToken->val.byteValue.pbBlob = pbPersistedToken + __CB_DECL( SIZEOF( PERSISTEDTOKEN ) );
        break;
    default:
        DRMASSERT( FALSE );
        break;
    }
ErrorExit:
    return;
}

DRM_VOID _PersistedToken_To_Token(
    const PERSISTEDTOKEN *pPersistedToken,
    TOKEN                *pToken)
{
    DRMASSERT( pToken != NULL && pPersistedToken != NULL );

    if ( pToken == NULL || pPersistedToken == NULL )
    {
        return;
    }

    pToken->TokenType = pPersistedToken->TokenType;

    switch( pToken->TokenType )
    {
    case TOKEN_LONG:
        pToken->val.lValue =  pPersistedToken->val.lValue;
        break;
    case TOKEN_DATETIME:
        pToken->val.u64DateTime = pPersistedToken->val.u64DateTime;
        break;
    default:
        DRMASSERT( FALSE );
        break;
    }
}

DRM_NO_INLINE DRM_VOID _Token_To_PersistedToken(
    const TOKEN    *pToken,
    PERSISTEDTOKEN *pPersistedToken)
{
    DRMASSERT( pToken != NULL && pPersistedToken != NULL );

    if ( pToken == NULL || pPersistedToken == NULL )
    {
        return;
    }

    pPersistedToken->TokenType = pToken->TokenType;

    switch( pPersistedToken->TokenType )
    {
    case TOKEN_LONG:
        pPersistedToken->val.lValue =  pToken->val.lValue;
        break;
    case TOKEN_DATETIME:
        pPersistedToken->val.u64DateTime = pToken->val.u64DateTime;
        break;
     default:
        DRMASSERT( FALSE );
        break;
    }
}

/*******************************************************************
 *                  FUNCTION DRM_SST_LoadAttributesIntoCache
 *
 * purpose: scan through an entire slot that has been cached and populate an
 *          array of the data for easy manipulation later
 *
 * assumptions:  the data will be in this format
 * |2 |  cb  | Token | 
 * |cb| Name | Value | 
 ******************************************************************/

DRM_NO_INLINE DRM_RESULT DRM_SST_LoadAttributesIntoCache(
    IN const DRM_BYTE        *pbSlotData,
    IN       DRM_DWORD        cbSlotData,
       OUT   CachedAttribute  rgAttributes[DRM_MAX_ATTRIBUTES_PER_SST_KEY],
       OUT   DRM_WORD        *pwNumAttributes)
{
    DRM_RESULT dr    = DRM_SUCCESS;
    TOKEN      token;
    
    ChkArg( pwNumAttributes != NULL );

    /* The first assert ensures that when we write tokens to disk they are align on boundaries that
       are compatible with the DRM_WCHAR alignment.  If they aren't most processors could have a
       alignment fault later when we access the strings.
       The second assert ensures that the size of token struct remains consistent (12 bytes) under
       all conditions (target processors, compiler switches).  This is eminent for maintaining
       backward compatability */
    DRMCASSERT( ( SIZEOF( PERSISTEDTOKEN ) % SIZEOF( DRM_WCHAR ) ) == 0 );
    DRMCASSERT( SIZEOF( PERSISTEDTOKEN ) == 12 );

    for( *pwNumAttributes = 0;
         ( *pwNumAttributes < DRM_MAX_ATTRIBUTES_PER_SST_KEY ) && ( cbSlotData > 0 );
         (*pwNumAttributes)++ )
    {
        DRM_WORD cbString = 0;

        if( cbSlotData < SIZEOF( DRM_WORD ) )
        {
            /* Absolutely too small */
            dr = DRM_E_SECURESTORE_CORRUPT;
            goto ErrorExit;
        }
        MEMCPY( &cbString, pbSlotData, SIZEOF( cbString ) );
        FIX_ENDIAN_WORD( cbString );
        pbSlotData += __CB_DECL(SIZEOF( DRM_WORD ));
        cbSlotData -= SIZEOF( DRM_WORD );

        if( cbSlotData < cbString + SIZEOF( PERSISTEDTOKEN ) )
        {
            /* There are not enough bytes left in the slot to finish this token out */
            dr = DRM_E_SECURESTORE_CORRUPT;
            goto ErrorExit;
        }

        DSTR_FROM_PB( &rgAttributes[*pwNumAttributes].dstrAttribute, pbSlotData, cbString );

        pbSlotData += __CB_DECL(cbString);
        cbSlotData -= cbString;

        rgAttributes[*pwNumAttributes].pTokenValue = (DRM_BYTE*)pbSlotData;
        pbSlotData += __CB_DECL(SIZEOF( PERSISTEDTOKEN ));
        cbSlotData -= SIZEOF( PERSISTEDTOKEN );

        _PrepareTokenForRead( rgAttributes[*pwNumAttributes].pTokenValue, &token );
        if( token.TokenType == TOKEN_BYTEBLOB )
        {
            /* For binary tokens the binary data follows the token struct */
            pbSlotData += __CB_DECL( token.val.byteValue.cbBlob + (token.val.byteValue.cbBlob % 2));
            cbSlotData -= __CB_DECL( token.val.byteValue.cbBlob + (token.val.byteValue.cbBlob % 2));
        }

        ZEROMEM( &rgAttributes[*pwNumAttributes].TokenDelta, SIZEOF( rgAttributes[*pwNumAttributes].TokenDelta ) );
        rgAttributes[*pwNumAttributes].dwFlags = 0;
    }

ErrorExit:
    return dr;
}

static DRM_NO_INLINE DRM_RESULT _VerifySlotHash( 
    IN OUT   DRM_SECSTORE_CONTEXT *pcontextSST,
    IN       DRM_BOOL              fRaw,
    IN const DRM_BYTE              rgbPassword [__CB_DECL(DRM_SHA1_DIGEST_LEN)] )
{
    DRM_RESULT       dr = DRM_SUCCESS;    
    DRM_BYTE        *pbSlotHash     = NULL;
    DRM_BYTE        *pbBuffer       = NULL;
    DRM_BYTE         rgbVerifiedHash[__CB_DECL(DRM_SHA1_DIGEST_LEN)] = { 0 };
    DRM_DWORD        cbBuffer       = 0;
    DRM_DWORD        cbHeader       = 0;
    DRM_HMAC_CONTEXT oHmacContext   = DRM_HMAC_CONTEXT_DEFAULT;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMSECSTORE, PERF_FUNC__VerifySlotHash);

    cbHeader = ( pcontextSST->dwSlotVersion == 0 )
             ? DRM_SST_SLOT_V0_HEADER_SIZE
             : DRM_SST_SLOT_HEADER_SIZE;
    pbBuffer = pcontextSST->rgbSlotData + __CB_DECL( cbHeader ); 

    /* If it is a raw slot the min-header has been loaded.
       Other wise the whole slot has been cached already */
    ChkDR( DRM_HMAC_Init( &oHmacContext, eDRM_SHA_1, rgbPassword, DRM_SHA1_DIGEST_LEN ) );

    if( fRaw )
    {
        DRM_DWORD cbRead = 0;
        DRM_DWORD cbSlot = pcontextSST->cbSlotData - cbHeader;
            
        cbBuffer = SIZEOF( pcontextSST->rgbSlotData ) - cbHeader;
        while( cbSlot > 0 )
        {
            DRM_DWORD cbToRead = min( cbBuffer, cbSlot );

            ChkDR( DRM_DST_SlotRead( pcontextSST->pDatastore,
                                     &pcontextSST->oSlotContext, 
                                     cbToRead, 
                                     pbBuffer, 
                                     &cbRead ) );    
            if( cbToRead != cbRead )
            {
                dr = DRM_E_FILEREADERROR;
                goto ErrorExit;
            }
            ChkDR( DRM_HMAC_Update( &oHmacContext, pbBuffer, cbRead ) );
            cbSlot -= cbRead;
        }
    }
    else
    {
        cbBuffer = pcontextSST->cbSlotData  - cbHeader;
        ChkDR( DRM_HMAC_Update( &oHmacContext, pbBuffer, cbBuffer ) );
    }

    ChkDR( DRM_HMAC_Finalize( &oHmacContext, rgbVerifiedHash, DRM_SHA1_DIGEST_LEN ) );

    pbSlotHash = ( pcontextSST->dwSlotVersion == 0 )
               ? ( pcontextSST->rgbSlotData + __CB_DECL(DRM_SST_SLOT_V0_HASH_OFFSET) )
               : ( pcontextSST->rgbSlotData + __CB_DECL(DRM_SST_SLOT_HASH_OFFSET) );
    if( 0 != MEMCMP( pbSlotHash, rgbVerifiedHash, DRM_SHA1_DIGEST_LEN ) )
    {
        dr = DRM_E_INVALID_SECURESTORE_PASSWORD;
        goto ErrorExit;
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

static DRM_NO_INLINE DRM_RESULT _InitSlot(
    IN OUT   DRM_SECSTORE_CONTEXT  *pcontextSST,
    IN       DRM_BOOL               fRaw,
    IN       eDRM_SECURE_STORE_TYPE eType,
    IN const DRM_BYTE               rgbPassword[__CB_DECL(DRM_SHA1_DIGEST_LEN)])
{
    DRM_DWORD        dwSlotMetaData = eType;
    DRM_RESULT       dr        = DRM_SUCCESS;
    DRM_DWORD        cbWritten = 0;
    DRM_DWORD        cbToWrite = 0;
    DRM_HMAC_CONTEXT hmac      = DRM_HMAC_CONTEXT_DEFAULT;

    if ( fRaw )
    {
        dwSlotMetaData |= DRM_SST_RAW_DATA;
    }

    /*  Set the slot version    */
    pcontextSST->dwSlotVersion = DRM_SST_SLOT_VERSION;
    
    /* Secure store section was just created.  Add the Initial hash */
    ChkDR(DRM_HMAC_Init(&hmac, eDRM_SHA_1, rgbPassword, DRM_SHA1_DIGEST_LEN));
    ChkDR(DRM_HMAC_FinalizeOffset(&hmac, pcontextSST->rgbSlotData, DRM_SST_SLOT_HASH_OFFSET, DRM_SHA1_DIGEST_LEN ) );

    DRM_SST_SET_SLOT_METADATA(dwSlotMetaData);
    DWORD_TO_BYTES(pcontextSST->rgbSlotData, dwSlotMetaData);
    DWORD_TO_BYTES(pcontextSST->rgbSlotData + __CB_DECL( SIZEOF( dwSlotMetaData)), pcontextSST->cbSlotData);

    cbToWrite = SIZEOF(dwSlotMetaData)
              + SIZEOF(pcontextSST->cbSlotData)
              + DRM_SHA1_DIGEST_LEN;

    ChkDR( DRM_DST_SlotSeek( pcontextSST->pDatastore,
                             &pcontextSST->oSlotContext, 
                             0, 
                             eDRM_DST_SEEKSET,
                             NULL ) );
    ChkDR( DRM_DST_SlotWrite( pcontextSST->pDatastore,
                              &pcontextSST->oSlotContext, 
                              cbToWrite, 
                              pcontextSST->rgbSlotData, 
                              &cbWritten ) );
    if ( cbWritten != cbToWrite )
    {
        dr = DRM_E_FILEWRITEERROR;
        goto ErrorExit;
    }
#if !_DATASTORE_WRITE_THRU
    ChkDR( pcontextSST->pDatastore->oDataStoreInterface.pfnCommitNamespace(&pcontextSST->oNsContext) );
#endif

ErrorExit:
    return dr;
}


static DRM_NO_INLINE DRM_RESULT _LoadSlot(
    IN OUT   DRM_SECSTORE_CONTEXT  *pcontextSST,
    IN       DRM_BOOL               fRaw,
    IN       eDRM_SECURE_STORE_TYPE eType,
    IN const DRM_BYTE               rgbPassword[__CB_DECL(DRM_SHA1_DIGEST_LEN)])
{
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_DWORD  cbRead    = 0;
    DRM_DWORD  cbToRead  = 0;
    DRM_DWORD  dwSlotMetaData = 0;

    /* A secure store slot is never this small.  Somethings wrong */
    ChkBOOL(pcontextSST->cbSlot >= DRM_SST_SLOT_V0_HEADER_SIZE, DRM_E_SECURESTORE_CORRUPT);
   
    if ( fRaw )
    {
        cbToRead = DRM_SST_SLOT_V0_HEADER_SIZE;
    }        
    else
    {
        ChkBOOL((pcontextSST->cbSlot <= SIZEOF(pcontextSST->rgbSlotData)), DRM_E_SECURESTORE_FULL);
        cbToRead = pcontextSST->cbSlot;
    }
    
    ChkDR( DRM_DST_SlotRead( pcontextSST->pDatastore, 
                             &pcontextSST->oSlotContext, 
                             cbToRead, 
                             pcontextSST->rgbSlotData, 
                             &cbRead ) );
    ChkBOOL(cbToRead == cbRead, DRM_E_FILEREADERROR);
    
    /*
    **  First check the version number
    */
    BYTES_TO_DWORD( dwSlotMetaData, pcontextSST->rgbSlotData );
    pcontextSST->dwSlotVersion = dwSlotMetaData & DRM_SST_SLOT_VERSION_MASK;
    if ( pcontextSST->dwSlotVersion == 0 )
    {            
        if ( (DRM_SST_SLOT_SIZE_VALID_MASK & dwSlotMetaData) != 0 )
        {
            DRM_SST_GET_SLOT_SIZE_FROM_METADATA(pcontextSST->cbSlotData, dwSlotMetaData);
        }
        dwSlotMetaData &= ~DRM_SST_SLOT_SIZE_MASK;  
    }
    else 
    {  
        if ( fRaw )
        {
            /*
            **  We need to read one more DWORD. This DWORD is just the last
            **  DWORD of the hash. We haven't read it yet because we first 
            **  read just DRM_SST_SLOT_V0_HEADER_SIZE amount of data from
            **  the beginning of the slot.
            */
            ChkDR( DRM_DST_SlotRead( pcontextSST->pDatastore,
                                     &pcontextSST->oSlotContext, 
                                     DRM_SST_SLOT_SIZEDATA_SIZE, 
                                     pcontextSST->rgbSlotData + __CB_DECL( DRM_SST_SLOT_V0_HEADER_SIZE ), 
                                     &cbRead ) );
            ChkBOOL(cbRead == DRM_SST_SLOT_SIZEDATA_SIZE, DRM_E_FILEREADERROR);
        }
        BYTES_TO_DWORD( pcontextSST->cbSlotData, 
                        pcontextSST->rgbSlotData + __CB_DECL( DRM_SST_SLOT_METADATA_SIZE ) );            
    }
    
    if ( (DRM_SST_SLOT_SIZE_VALID_MASK & dwSlotMetaData) == 0 )
    {            
        pcontextSST->cbSlotData = pcontextSST->cbSlot;
    }  
    else
    {
        dwSlotMetaData &= ~((DRM_DWORD)DRM_SST_SLOT_SIZE_VALID_MASK);
    }
    
    dwSlotMetaData &= ~((DRM_DWORD)DRM_SST_SLOT_VERSION_MASK);
    
    ChkBOOL(pcontextSST->cbSlotData <= pcontextSST->cbSlot, DRM_E_SECURESTORE_CORRUPT);
    if ( fRaw )
    {
        ChkBOOL((dwSlotMetaData == (((DRM_DWORD)eType)|((DRM_DWORD)DRM_SST_RAW_DATA))), DRM_E_SECURESTORE_CORRUPT);
    }
    else
    {
        ChkBOOL((dwSlotMetaData == (DRM_DWORD)eType), DRM_E_SECURESTORE_CORRUPT);
    }

    /* verify the slot if passwod is given */
    if ( !pcontextSST->fNoPassword )
    {
        dr = _VerifySlotHash(pcontextSST, fRaw, rgbPassword);
    }
ErrorExit:

    return dr;
}
static DRM_NO_INLINE DRM_RESULT _OpenAndVerifySlot( 
    IN OUT DRM_SECSTORE_CONTEXT    *pcontextSST,
    IN     DRM_DST                 *pDatastore,
    const  DRM_BYTE                 rgbPassword [__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN     eDRM_SECURE_STORE_TYPE   eType,
    IN     DRM_BOOL                 fRaw,
    IN     DRM_DWORD                dwFlags,
    IN     DRM_DWORD                cbMinSlotSizeForCreate)
{
    DRM_RESULT dr              = DRM_SUCCESS;
    DRM_BOOL   fCloseNamespace = FALSE,
               fCloseSlot      = FALSE,
               fCreated        = FALSE;
    DRM_DWORD  dwSlotMetaData  = eType;
    DRM_DWORD  cbPreallocatedSlot  = max( cbMinSlotSizeForCreate,
                                            ( eType == SECURE_STORE_DEVICE_REGISTRATION_DATA)
                                                ?  (DRM_DWORD)DRM_SST_DEVREG_PREALLOCATE_SIZE
                                                :  (DRM_DWORD)DRM_SST_PREALLOCATE_SIZE );
    DRM_DWORD  dwDstOpenMode = 0;

    pcontextSST->fNoPassword = FALSE;
    pcontextSST->fDirty      = FALSE;
    pcontextSST->pDatastore  = pDatastore;

    if ( rgbPassword == NULL
      || DRM_UTL_IsZeros(rgbPassword, DRM_SHA1_DIGEST_LEN) )
    {
        MEMSET( pcontextSST->rgbPassword, 0, DRM_SHA1_DIGEST_LEN );
        pcontextSST->fNoPassword = TRUE;
    }

    if ( ( dwFlags & DRM_SECURE_STORE_CREATE_NEW ) != 0 )
    {
        ChkDR( DRM_DST_OpenNamespace( pDatastore, 
                                      pcontextSST->pNamespaceId, 
                                      (DRM_DST_OPENMODE)(eDRM_DST_OPEN_ALWAYS | eDRM_DST_LOCKWAIT),
                                      DRM_SECURE_STORE_NUM_CHILD_NODES,
                                      DRM_SST_PREALLOCATE_SIZE,
                                      &pcontextSST->oNsContext ) );
        
        /* Clear the slot hint or it'll try to search there first */
        ZEROMEM( &pcontextSST->slotHint, SIZEOF( DRM_DST_SLOT_HINT ) );
        dwDstOpenMode = eDRM_DST_CREATE_NEW;
    }
    else if ( ( dwFlags & DRM_SECURE_STORE_OPEN_ALWAYS ) != 0 )
    {
        ChkDR( DRM_DST_OpenNamespace( pDatastore,
                                      pcontextSST->pNamespaceId,
                                      (DRM_DST_OPENMODE)(eDRM_DST_OPEN_ALWAYS | eDRM_DST_LOCKWAIT),
                                      DRM_SECURE_STORE_NUM_CHILD_NODES,
                                      DRM_SST_PREALLOCATE_SIZE,
                                      &pcontextSST->oNsContext ) );

        dwDstOpenMode = eDRM_DST_OPEN_ALWAYS;
    }
    else if( ( dwFlags & DRM_SECURE_STORE_OPEN_EXISTING ) != 0 )
    {
        dr = DRM_DST_OpenNamespace( pDatastore, 
                                    pcontextSST->pNamespaceId, 
                                    (DRM_DST_OPENMODE)(eDRM_DST_OPEN_EXISTING | eDRM_DST_LOCKWAIT),
                                    DRM_SECURE_STORE_NUM_CHILD_NODES,
                                    DRM_SST_PREALLOCATE_SIZE,
                                    &pcontextSST->oNsContext );
        if ( dr == DRM_E_DSTNAMESPACENOTFOUND )
        {
            dr = DRM_E_DSTSLOTNOTFOUND;
        }
        ChkDR(dr);

        dwDstOpenMode = eDRM_DST_OPEN_EXISTING;
    }
    else
    {
        /* Invalid open mode */
        ChkArg( FALSE );
    }
    fCloseNamespace = TRUE;

    if( fRaw )
    {
        dwSlotMetaData |= DRM_SST_RAW_DATA;
    }

    if ( ( dwFlags & DRM_SECURE_STORE_OPEN_ALWAYS ) != 0
     ||  ( dwFlags & DRM_SECURE_STORE_CREATE_NEW ) != 0 )
    {
        
        pcontextSST->cbSlotData = DRM_SST_SLOT_HEADER_SIZE;
        pcontextSST->cbSlot     = DRM_SST_SLOT_HEADER_SIZE
                                + cbPreallocatedSlot;
    }
    
    dr = DRM_DST_OpenSlot( pDatastore,
                           &pcontextSST->oNsContext,
                           dwDstOpenMode | eDRM_DST_LOCKEXCLUSIVE | eDRM_DST_LOCKWAIT,
                           &pcontextSST->rgbKey1,
                           &pcontextSST->rgbKey2,
                           &pcontextSST->slotHint,
                           &pcontextSST->cbSlot,
                           &pcontextSST->oSlotContext);
    if ( ( ( dwFlags & DRM_SECURE_STORE_OPEN_ALWAYS )          && dr == DRM_S_FALSE )
     ||  ( ( dwFlags & DRM_SECURE_STORE_CREATE_NEW ) && DRM_SUCCEEDED( dr ) ) )
    {
        fCreated = TRUE;
        dr = DRM_SUCCESS;
    }
    ChkDR( dr );
    fCloseSlot = TRUE;
    
    /* The slot is open.*/
    if( fCreated )
    {
        dr = _InitSlot(pcontextSST, fRaw, eType, rgbPassword);
    }
    else
    {           
        dr = _LoadSlot(pcontextSST, fRaw, eType, rgbPassword);
    }
    pcontextSST->eType = eType;

ErrorExit:
    if( DRM_FAILED( dr ) )
    {
        if( fCloseSlot )
        {
            DRM_DST_CloseSlot( pDatastore, &pcontextSST->oSlotContext );
            ZEROMEM( &pcontextSST->slotHint, SIZEOF( DRM_DST_SLOT_HINT ) );
        }
        if( fCloseNamespace )
        {            
            DRM_DST_CloseNamespace( pDatastore, &pcontextSST->oNsContext );
        }
    }
    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_SST_LoadKeyTokens(
    IN OUT   DRM_SECSTORE_CONTEXT   *pcontextSST,
    IN       DRM_DWORD               dwFlags,
    IN       DRM_DST                *pDatastore )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cbHeader = 0; 
    DRM_BOOL   fClose = FALSE;

    ChkArg( pcontextSST != NULL
         && pDatastore != NULL
         && pcontextSST->fInited );    

    if( pcontextSST->fOpened )
    {
        /* Already open */
        goto ErrorExit;
    }
    
    ChkDR( _OpenAndVerifySlot( pcontextSST, pDatastore, pcontextSST->rgbPassword, pcontextSST->eType, FALSE, dwFlags, 0) );
    fClose = TRUE;

    /* The data has been read and verified.  Run through the data and create a map of the keys */
    cbHeader = ( pcontextSST->dwSlotVersion == 0) 
             ? DRM_SST_SLOT_V0_HEADER_SIZE
             : DRM_SST_SLOT_HEADER_SIZE;
    ChkDR( DRM_SST_LoadAttributesIntoCache( pcontextSST->rgbSlotData + __CB_DECL( cbHeader ), 
                                            pcontextSST->cbSlotData  - cbHeader,
                                            pcontextSST->rgAttributes,
                                           &pcontextSST->wNumAttributes ) );

    pcontextSST->wNumOriginalAttributes = pcontextSST->wNumAttributes;
    pcontextSST->fOpened = TRUE;

ErrorExit:
    if ( fClose 
      && pcontextSST != NULL )
    {
        DRM_DST_CloseSlot( pDatastore, &pcontextSST->oSlotContext );
        DRM_DST_CloseNamespace( pDatastore, &pcontextSST->oNsContext );
    }
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL _LoadKeyTokens(
    IN OUT   DRM_SECSTORE_CONTEXT   *pcontextSST,
    IN       DRM_DST                *pDatastore )
{
    return DRM_SST_LoadKeyTokens( pcontextSST, DRM_SECURE_STORE_OPEN_ALWAYS, pDatastore );
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_OpenKeyTokens(
    IN OUT   DRM_SECSTORE_CONTEXT   *pcontextSST,
    IN const DRM_ID                 *pKey1,
    IN const DRM_ID                 *pKey2,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE rgbPassword [__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN       DRM_DWORD               dwFlags,
    IN       eDRM_SECURE_STORE_TYPE  eType,
    IN       DRM_DST                *pDatastore)
{
    DRM_RESULT  dr        = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMSECSTORE, PERF_FUNC_DRM_SST_OpenKeyTokens);
        
    ChkArg( pcontextSST != NULL
         && pKey1       != NULL
         && pDatastore != NULL );

    ZEROMEM( pcontextSST, SIZEOF( *pcontextSST ) );

    /* Check for supported flags */
    if ( ( dwFlags & ~(DRM_SECURE_STORE_CREATE_NEW | DRM_SECURE_STORE_OPEN_ALWAYS) ) ||
        !( IsValidSecureStoreType(eType, DISALLOW_DEVICE_REG | DISALLOW_REVOCATION | DISALLOW_CACHEDCERT) ) )
    {
        dr = DRM_E_INVALIDARG;
        goto ErrorExit;
    }

    pcontextSST->fNoPassword = FALSE;
    if ( rgbPassword == NULL
      || DRM_UTL_IsZeros(rgbPassword, DRM_SHA1_DIGEST_LEN) )
    {
        MEMSET( pcontextSST->rgbPassword, 0, DRM_SHA1_DIGEST_LEN );
        pcontextSST->fNoPassword = TRUE;
    }

    pcontextSST->pNamespaceId = MapSecureStoreTypeToNamespace( eType );

    /* Copy the IDs so we can open the right slot later */
    MEMCPY( &pcontextSST->rgbKey1, pKey1, SIZEOF( pcontextSST->rgbKey1 ) );
    if( pKey2 )
    {
        MEMCPY( &pcontextSST->rgbKey2, pKey2, SIZEOF( pcontextSST->rgbKey2 ) );
    }
    else
    {
        ZEROMEM( &pcontextSST->rgbKey2, SIZEOF( pcontextSST->rgbKey2 ) );
    }

    if ( !pcontextSST->fNoPassword )
    {
        MEMCPY( pcontextSST->rgbPassword, rgbPassword, DRM_SHA1_DIGEST_LEN );
    }

    pcontextSST->eType       = eType;
    pcontextSST->pDatastore  = pDatastore;
    pcontextSST->fInited     = TRUE;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
        
    return ( dr );
}

/******************************************************************************
** 
** Function :   DRM_SST_OpenAndLockSlot
** 
** Synopsis :   Opens and locks the appropriate slot
** 
** Arguments :  f_pDatastore    : 
**              f_eType         :   Type of secure store
**              f_pKey1         :   Key1 buffer
**              f_pKey2         :   Key2 buffer
**              f_rgbPassword   :   Secure store password
**              f_dwFlags       :   Only allowed flags for now is 
**                                  DRM_SECURE_STORE_CREATE_IF_NOT_EXIST | DRM_SECURE_STORE_OPEN_ALWAYS
**              f_pcontextSST   :   Secure store context for opened slot
**              f_pcbData       :   (Optional - can be NULL)If slot already 
**                                  exists, on return it contains slot size
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_OpenAndLockSlot(
    IN          DRM_DST                *f_pDatastore,
    IN          eDRM_SECURE_STORE_TYPE  f_eType,
    IN  const   DRM_ID                 *f_pKey1,
    IN  const   DRM_ID                 *f_pKey2,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE f_rgbPassword[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN          DRM_DWORD               f_dwFlags,
        OUT     DRM_SECSTORE_CONTEXT   *f_pcontextSST,
        OUT     DRM_DWORD              *f_pcbData )
{
    DRM_RESULT  dr  = DRM_SUCCESS;

    /*
    **  Check input
    */
    ChkArg( (f_dwFlags & ~DRM_SECURE_STORE_VALID_FLAGS) == 0 );
    ChkArg( f_pcontextSST != NULL
         && f_pDatastore != NULL
         && f_pKey1       != NULL );

    f_pcontextSST->fNoPassword = FALSE;
    if ( f_rgbPassword == NULL
      || DRM_UTL_IsZeros(f_rgbPassword, DRM_SHA1_DIGEST_LEN) )
    {
        MEMSET( f_pcontextSST->rgbPassword, 0, DRM_SHA1_DIGEST_LEN );
        f_pcontextSST->fNoPassword = TRUE;
    }

    /*
    **  Clear the output flag in secstore
    */
    f_pcontextSST->fLocked = FALSE;
    
    /*
    **  Check for supported flags
    */
    if ( !IsValidSecureStoreType( f_eType, ALLOW_ALL ) )
    {
        dr = DRM_E_INVALIDARG;
        goto ErrorExit;
    }

    /*
    **  Initialize the secstore context
    */
    ZEROMEM( f_pcontextSST, SIZEOF( *f_pcontextSST ) );
    f_pcontextSST->pNamespaceId = MapSecureStoreTypeToNamespace( f_eType );

    /*
    **  Copy the IDs so we can open the right slot later
    */
    MEMCPY( &f_pcontextSST->rgbKey1, f_pKey1, SIZEOF( f_pcontextSST->rgbKey1 ) );
    if( f_pKey2 != NULL )
    {
        MEMCPY( &f_pcontextSST->rgbKey2, f_pKey2, SIZEOF( f_pcontextSST->rgbKey2 ) );
    }
    else
    {
        ZEROMEM(&f_pcontextSST->rgbKey2, SIZEOF( f_pcontextSST->rgbKey2 ) );
    }

    /*
    **  Open and lock slot
    */
    ChkDR( _OpenAndVerifySlot( f_pcontextSST, 
                               f_pDatastore, 
                               f_rgbPassword, 
                               f_eType, 
                               TRUE, 
                               f_dwFlags,
                               f_pcbData == NULL ? 0 : *f_pcbData ) );
    
    /*
    **  Save the securestore password
    */
    if ( !f_pcontextSST->fNoPassword )
    {
        MEMCPY( f_pcontextSST->rgbPassword, 
                f_rgbPassword, 
                SIZEOF(f_pcontextSST->rgbPassword) );
    }

    /*
    **  Set the slot size for the caller
    */
    if (f_pcbData != NULL)
    {
        *f_pcbData = ( f_pcontextSST->dwSlotVersion == 0 )
                   ? f_pcontextSST->cbSlotData - DRM_SST_SLOT_V0_HEADER_SIZE
                   : f_pcontextSST->cbSlotData - DRM_SST_SLOT_HEADER_SIZE; 
    }   
    
    /*
    **  Secstore context now holds the lock. Set appropriate flag
    */
    f_pcontextSST->fLocked = TRUE;
    
ErrorExit:
    return dr;
}
    

/******************************************************************************
** 
** Function :   DRM_SST_GetLockedData
** 
** Synopsis :   Gets data from the slot if this thread holds the lock to the slot
** 
** Arguments :  f_pcontextSST   : Secure store context
**              f_pbData        : Buffer for slot data
**              f_pcbData       : Buffer size; if slot is bigger, on return, it
**                                would contain the slot size
** 
** Returns :    DRM_E_SECURESTORE_LOCKNOTOBTAINED if  DRM_SST_OpenAndLockSlot has
**              not been successfully called prior to this function
** 
** Notes :      
** 
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_GetLockedData(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    __out_bcount_opt( *f_pcbData ) DRM_BYTE *f_pbData,
       OUT   DRM_DWORD              *f_pcbData )
{
    DRM_RESULT  dr          = DRM_SUCCESS;
    DRM_DWORD   cbRemaining = 0;
    DRM_DWORD   cbHeader    = 0;

    ChkArg( f_pcontextSST != NULL
         && f_pcbData     != NULL );
    
    /*
    **  Check if the caller holds the lock for the secure store
    */
    if (!f_pcontextSST->fLocked)
    {
        ChkDR(DRM_E_SECURESTORE_LOCKNOTOBTAINED);
    }
    
    /*
    **  Check size of input buffer
    */
    cbHeader = ( f_pcontextSST->dwSlotVersion == 0 )
             ? DRM_SST_SLOT_V0_HEADER_SIZE
             : DRM_SST_SLOT_HEADER_SIZE;
    cbRemaining = f_pcontextSST->cbSlotData - cbHeader;    
    
    if( f_pbData == NULL || *f_pcbData < cbRemaining )
    {
        *f_pcbData = cbRemaining;
        dr = DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }
    *f_pcbData = cbRemaining;
    
    /*
    **  Get the data
    */
    ChkDR( DRM_DST_SlotSeek( f_pcontextSST->pDatastore,
                             &f_pcontextSST->oSlotContext, 
                             cbHeader, 
                             eDRM_DST_SEEKSET, NULL ) );
    ChkDR( DRM_DST_SlotRead( f_pcontextSST->pDatastore,
                             &f_pcontextSST->oSlotContext, 
                             cbRemaining, 
                             f_pbData, 
                             f_pcbData ) );

ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_SST_SetLockedData
** 
** Synopsis :   Sets data into the slot if this thread holds the lock to the slot
** 
** Arguments :  f_pcontextSST   : Secure store context
**              f_cbData        : Buffer size; 
**              f_pbData        : Data Buffer
** 
** Returns :    DRM_E_SECURESTORE_LOCKNOTOBTAINED if  DRM_SST_OpenAndLockSlot has
**              not been successfully called prior to this function
**
** Notes :
** 
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_SetLockedData(
    IN          DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN          DRM_DWORD               f_cbData,
    __in_bcount( f_cbData ) const DRM_BYTE *f_pbData )
{
    DRM_RESULT        dr              = DRM_SUCCESS;
    DRM_DWORD         cbWritten       = 0;
    DRM_DWORD         dwSlotMetaData  = 0;

    ChkArg( f_pcontextSST != NULL
         && f_pbData      != NULL );
    
    /*
    **  Check if the caller holds the lock for the secure store
    */
    if (!f_pcontextSST->fLocked)
    {
        ChkDR(DRM_E_SECURESTORE_LOCKNOTOBTAINED);
    }    
    

    f_pcontextSST->cbSlotData = DRM_SST_SLOT_HEADER_SIZE + f_cbData;
    if ( f_pcontextSST->cbSlotData > f_pcontextSST->cbSlot )
    {
        ChkDR( DRM_DST_SlotResize( f_pcontextSST->pDatastore,
                                   &f_pcontextSST->oSlotContext, 
                                   f_pcontextSST->cbSlotData ) );
    }

    /*
    **  If this was a v0 slot, update it to current version
    */
    if ( f_pcontextSST->dwSlotVersion == 0 )
    {
        /* Clear the old format size fields in the slot meta data */
        BYTES_TO_DWORD( dwSlotMetaData, f_pcontextSST->rgbSlotData );
        DRM_SST_SET_SLOT_METADATA( dwSlotMetaData );
        DWORD_TO_BYTES( f_pcontextSST->rgbSlotData, dwSlotMetaData );
    }
     
    /*
    **  Obtain HMAC of data to be written to secstore
    */
    ChkDR( DRM_HMAC_CreateMAC( eDRM_SHA_1,
                               f_pcontextSST->rgbPassword,
                               DRM_SHA1_DIGEST_LEN,
                               f_pbData,
                               0,
                               f_cbData,                               
                               f_pcontextSST->rgbSlotData,
                               DRM_SST_SLOT_HASH_OFFSET,
                               DRM_SHA1_DIGEST_LEN ) );                              

    /*
    **  Find the right slot
    */
    ChkDR( DRM_DST_SlotSeek( f_pcontextSST->pDatastore,
                             &f_pcontextSST->oSlotContext, 
                             0, 
                             eDRM_DST_SEEKSET,
                             NULL ) );

    /* Update the size in the slot meta data */
    DWORD_TO_BYTES( f_pcontextSST->rgbSlotData + __CB_DECL( DRM_SST_SLOT_METADATA_SIZE ), 
                    f_pcontextSST->cbSlotData );        
    
    if( DRM_SST_SLOT_HEADER_SIZE + f_cbData <= SIZEOF( f_pcontextSST->rgbSlotData )
     && DRM_SST_SLOT_HEADER_SIZE + f_cbData  > f_cbData )
    {
        /* Copy to in memory buffer to minimize calls to SlotWrite */
        DRM_BYT_CopyBytes( f_pcontextSST->rgbSlotData, DRM_SST_SLOT_DATA_OFFSET, f_pbData, 0, f_cbData );
        ChkDR( DRM_DST_SlotWrite( f_pcontextSST->pDatastore,
                                  &f_pcontextSST->oSlotContext, 
                                  f_pcontextSST->cbSlotData, 
                                  f_pcontextSST->rgbSlotData, 
                                  &cbWritten ) );
        if ( cbWritten != f_pcontextSST->cbSlotData )
        {
            ChkDR( DRM_E_FILEWRITEERROR );
        }
    }
    else
    {

        /*
        **  Write HMAC to secstore
        */
        ChkDR( DRM_DST_SlotWrite( f_pcontextSST->pDatastore,
                                  &f_pcontextSST->oSlotContext, 
                                  DRM_SST_SLOT_HEADER_SIZE, 
                                  f_pcontextSST->rgbSlotData, 
                                  &cbWritten ) );
        if ( cbWritten != DRM_SST_SLOT_HEADER_SIZE )
        {
            ChkDR( DRM_E_FILEWRITEERROR );
        }
        
        /*
        **  Write data to slot
        */
        ChkDR( DRM_DST_SlotWrite( f_pcontextSST->pDatastore,
                                  &f_pcontextSST->oSlotContext, 
                                  f_cbData, 
                                  f_pbData, 
                                  &cbWritten ) );        
        if( cbWritten != f_cbData )
        {
            ChkDR( DRM_E_FILEWRITEERROR );
        }
    }

#if !_DATASTORE_WRITE_THRU
    ChkDR( DRM_DST_CommitNamespace( f_pcontextSST->pDatastore, 
                                    &f_pcontextSST->oNsContext ) );
#endif

ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_SST_CloseLockedSlot
** 
** Synopsis :   Closes the slot, releasing lock in the process
** 
** Arguments :  f_pcontextSST - secure store context
** 
** Returns :    DRM_SUCCESS 
** 
** Notes :      
** 
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_CloseLockedSlot( 
    IN  DRM_SECSTORE_CONTEXT *f_pcontextSST )
{
    DRM_RESULT  dr  = DRM_SUCCESS;

    ChkArg( f_pcontextSST != NULL );
    
    /*
    **  Close the slot - release lock if the caller holds the lock for the 
    **  secure store
    */
    if (f_pcontextSST->fLocked)
    {
        DRM_DST_CloseSlot( f_pcontextSST->pDatastore, &f_pcontextSST->oSlotContext );
        DRM_DST_CloseNamespace( f_pcontextSST->pDatastore, &f_pcontextSST->oNsContext );
        f_pcontextSST->fLocked = FALSE;
    }      
        
ErrorExit:
    if( f_pcontextSST != NULL )
    {
        ZEROMEM( &f_pcontextSST->slotHint, SIZEOF( DRM_DST_SLOT_HINT ) );
    }
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_SST_GetData
** 
** Synopsis :   
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_GetData(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN const DRM_ID                 *f_pKey1,
    IN const DRM_ID                 *f_pKey2,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE f_rgbPassword[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN       eDRM_SECURE_STORE_TYPE  f_eType,
    IN       DRM_DST                *f_pDatastore,
    __out_bcount_opt( *f_pcbData ) DRM_BYTE *f_pbData,
       OUT   DRM_DWORD              *f_pcbData )
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   cbData  = 0;
    
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMSECSTORE, PERF_FUNC_DRM_SST_GetData);
    
    /*
    **  All other parameters will be checked by internal functions
    **  This is just a wrapper over them
    */
    ChkArg( f_pcbData != NULL );
    
    ChkDR( DRM_SST_OpenAndLockSlot( f_pDatastore, 
                                    f_eType, 
                                    f_pKey1, 
                                    f_pKey2, 
                                    f_rgbPassword,
                                    DRM_SECURE_STORE_OPEN_EXISTING, 
                                    f_pcontextSST,
                                    &cbData ) );
    if ( *f_pcbData < cbData)
    {
        *f_pcbData = cbData;
        dr = DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;        
    }
    
    /*
    **  Read data now
    */
    ChkDR( DRM_SST_GetLockedData( f_pcontextSST, 
                                  f_pbData, 
                                  f_pcbData ) );
    
ErrorExit:
    
    /*
    **  Release lock
    */ 
    DRM_SST_CloseLockedSlot( f_pcontextSST );   
    
    DRM_PROFILING_LEAVE_SCOPE;
     
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_SST_SetData
** 
** Synopsis :   
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_SetData(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN const DRM_ID                 *f_pKey1,
    IN const DRM_ID                 *f_pKey2,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE f_rgbPassword[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN       eDRM_SECURE_STORE_TYPE  f_eType,
    IN       DRM_DST                *f_pDatastore,
    __in_bcount( f_cbData ) const DRM_BYTE *f_pbData,
    IN       DRM_DWORD               f_cbData )
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   cbSlot  = f_cbData;
    
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMSECSTORE, PERF_FUNC_DRM_SST_SetData);

    /*
    **  Parameters will be checked by internal functions
    **  This is just a wrapper over them
    */
    ChkDR( DRM_SST_OpenAndLockSlot( f_pDatastore, 
                                    f_eType, 
                                    f_pKey1, 
                                    f_pKey2, 
                                    f_rgbPassword,
                                    DRM_SECURE_STORE_OPEN_ALWAYS, 
                                    f_pcontextSST,
                                   &cbSlot ) );    
    /*
    **  Set data now
    */
    ChkDR( DRM_SST_SetLockedData( f_pcontextSST,
                                  f_cbData, 
                                  f_pbData ) );
    
ErrorExit:

    /*
    **  Release lock
    */ 
    DRM_SST_CloseLockedSlot( f_pcontextSST );
    
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;

}

static DRM_NO_INLINE DRM_RESULT _UpdateAttributeTokenInSlot( 
    DRM_SECSTORE_CONTEXT *pcontextSST, 
    DRM_CONST_STRING     *pdstrAttribute,
    PERSISTEDTOKEN       *pTokenDelta,
    TOKEN                *pTokenAbsolute,
    DRM_DWORD             dwFlags,
    DRM_BOOL              fNewAttribute,
    DRM_BOOL              fDataChangedOnDisk,
    DRMPFNPOLICYCALLBACK  pfnMergeCallback,
    const DRM_VOID       *pvCallbackData )
{
    DRM_RESULT dr        = DRM_SUCCESS;    
    DRM_DWORD  dwOffset  = 0;
    DRM_WORD   cbString  = 0;
    TOKEN      token;

    if ( pcontextSST->dwSlotVersion == 0)
    {
        dwOffset    = DRM_SST_SLOT_V0_DATA_OFFSET;
    }
    else
    {
        dwOffset    = DRM_SST_SLOT_DATA_OFFSET;
    }
    while( dwOffset < pcontextSST->cbSlotData )
    {
        DRM_WORD cbString = 0;

        DRM_BYT_CopyBytes( &cbString, 0, pcontextSST->rgbSlotData, dwOffset, SIZEOF( cbString ) );
        FIX_ENDIAN_WORD( cbString );        
        dwOffset += SIZEOF( cbString );

        if( cbString == CB_DSTR( pdstrAttribute )
         && DRM_BYT_CompareBytes( pcontextSST->rgbSlotData, dwOffset, PB_DSTR( pdstrAttribute ), 0, CB_DSTR( pdstrAttribute ) ) == 0 )
        {
            dwOffset += cbString;
            
            _PrepareTokenForRead( pcontextSST->rgbSlotData + __CB_DECL( dwOffset ),
                                    &token );

                /* If fNewAttribute is TRUE, then this is a new attribute for our context but someother context has already
                    written it.  Tread here very carfully
                    The valid scenarios for this is relative expiration, or saveddatetime being updated,
                    or perhaps metering or playlist burns.  In the time cases we will do nothing.  In the count
                    cases we can safely add the diff */

            if( (dwFlags & DRM_TOKEN_RESOLVE_BITMASK) == DRM_TOKEN_RESOLVE_LAST_WINS
              || (( dwFlags & DRM_TOKEN_RESOLVE_BITMASK) == DRM_TOKEN_RESOLVE_CALLBACK &&  !fDataChangedOnDisk ) )
            {
                /* The resolve option DRM_TOKEN_RESOLVE_LAST_WINS means we should
                ** overwrite any existing data, even if this is a new attribute.
                ** Also, if the resolve option is for callback but the data on 
                ** disk never changed, we overwrite too.
                */

                switch( pTokenDelta->TokenType )
                {
                case TOKEN_LONG:
                    token.val.lValue = pTokenAbsolute->val.lValue + pTokenDelta->val.lValue;
                    break;
                    
                case TOKEN_DATETIME:
                    token.val.u64DateTime = DRM_UI64Add( pTokenAbsolute->val.u64DateTime, pTokenDelta->val.u64DateTime );
                    break;
                    
                case TOKEN_BYTEBLOB:
                    /* Size shouldn't have changed */
                    ChkArg( token.val.byteValue.cbBlob == pTokenAbsolute->val.byteValue.cbBlob );
                    
                    token.val.byteValue.pbBlob = pTokenAbsolute->val.byteValue.pbBlob;
                    break;
                    
                default:
                    ChkDR( CPRMEXP_UPDATE_FAILURE );
                }
            }
            else if( (dwFlags & DRM_TOKEN_RESOLVE_BITMASK) == DRM_TOKEN_RESOLVE_FIRST_WINS )
            {
                /* The resolve option DRM_TOKEN_RESOLVE_FIRST_WINS means we shouldn't
                ** overwrite any existing data if it's changed since we had loaded it */

                switch( pTokenDelta->TokenType )
                {
                case TOKEN_LONG:

                    /* Make sure some other context hasn't changed the value on disk.
                    ** If it has, we shouldn't overwite, we just let it be.
                    */
                    if( token.val.lValue == pTokenAbsolute->val.lValue )
                    {
                        /* Add the delta to the value from the original value */
                        token.val.lValue += pTokenDelta->val.lValue;
                    }
                    break;
                    
                case TOKEN_DATETIME:
                    /* Make sure some other context hasn't changed the value on disk.
                    ** If it has, we shouldn't overwite, we just let it be.
                    */
                    if( DRM_UI64Eql( token.val.u64DateTime, pTokenAbsolute->val.u64DateTime ) )
                    {
                        /* Add the delta to the value from the original value */
                        token.val.u64DateTime = DRM_UI64Add( token.val.u64DateTime, pTokenDelta->val.u64DateTime );
                    }
                    break;
                    
                case TOKEN_BYTEBLOB:
                    /* This should be hit as SetToken ChkArgs this. We can't perform this
                    ** type of resolve on binary data as we don't cache the original value
                    ** to know whether the state on disk has been disturbed or not.
                    **
                    ** Fall through to error
                    */
                default:
                    ChkDR( CPRMEXP_UPDATE_FAILURE );
                }
            }
            else if( (dwFlags & DRM_TOKEN_RESOLVE_BITMASK) == DRM_TOKEN_RESOLVE_DELTA )
            {
                /* The resolve option DRM_TOKEN_RESOLVE_DELTA means we should
                ** add the delta regardless of whether the value on disk has changed,
                ** but we should fail if we're decrementing past zero. */

                switch( pTokenDelta->TokenType )
                {
                case TOKEN_LONG:
                    
                    /* If we decremented past zero, then we need to fail. */
                    if( token.val.lValue >= 0
                     && token.val.lValue < -pTokenDelta->val.lValue )
                    {
                        ChkDR( CPRMEXP_UPDATE_FAILURE );
                    }

                    /* Add the delta to the value from disk */
                    token.val.lValue += pTokenDelta->val.lValue;
                    break;
                    
                case TOKEN_DATETIME:
                    /* Add the delta to the value from disk */
                    token.val.u64DateTime = DRM_UI64Add( token.val.u64DateTime, pTokenDelta->val.u64DateTime );
                    break;
                    
                case TOKEN_BYTEBLOB:
                    /* This should be hit as SetToken ChkArgs this. We can't perform this
                    ** type of resolve on binary data as we don't cache the original value
                    ** to know whether the state on disk has been disturbed or not.
                    **
                    ** Fall through to error
                    */
                default:
                    ChkDR( CPRMEXP_UPDATE_FAILURE );
                }
            }
            else if( (dwFlags & DRM_TOKEN_RESOLVE_BITMASK) == DRM_TOKEN_RESOLVE_CALLBACK )
            {
                DRM_SECURE_STATE_TOKEN_RESOLVE_DATA callbackData = {0};
                TOKEN tokenIntended = *pTokenAbsolute;
                DRM_DWORD dwID = 0;

                ChkArg( pfnMergeCallback != NULL );

                /* Provide the application with all the data it needs to resolve this conflict */
                callbackData.pdstrAttributeName = pdstrAttribute;
                callbackData.fNewAttribute = fNewAttribute;
                callbackData.pOnDisk = &token;
                callbackData.pOriginallyIntendedValue = &tokenIntended;

                /* Need to add the delta for LONG/DATETIME */
                switch( pTokenDelta->TokenType )
                {
                case TOKEN_LONG:
                    tokenIntended.val.lValue = pTokenAbsolute->val.lValue + pTokenDelta->val.lValue;
                    break;
                    
                case TOKEN_DATETIME:
                    tokenIntended.val.u64DateTime = DRM_UI64Add( pTokenAbsolute->val.u64DateTime, pTokenDelta->val.u64DateTime );
                    break;
                }

                /*
                ** Check if the attribute name is greater than 9 characters with a period at the end
                ** (4 characters for each of right ID and restriction ID in hex, and 1 character for a period)
                */
                if( pdstrAttribute->cchString >= 9
                 && *(pdstrAttribute->pwszString + 8) == WCHAR_CAST('.') )
                {
                    /*
                    ** Parse out the 4 hex character right ID and restriction ID
                    */
                    DRM_CHAR rgchID[5] = {0};

                    /* Demote 4 character hex right ID to ANSI and decode hex */
                    DRM_UTL_DemoteUNICODEtoASCII( pdstrAttribute->pwszString, rgchID, 4 );
                    ChkDR( DRMCRT_AtoDWORD( rgchID, NO_OF( rgchID ), 16, &dwID ) );
                    callbackData.wRightID = (DRM_WORD)dwID;

                    /* Demote 4 character hex restriction ID to ANSI and decode hex */
                    DRM_UTL_DemoteUNICODEtoASCII( pdstrAttribute->pwszString + 4, rgchID, 4 );
                    ChkDR( DRMCRT_AtoDWORD( rgchID, NO_OF( rgchID ), 16, &dwID ) );
                    callbackData.wRestrictionID = (DRM_WORD)dwID;
                }
                
                ChkDR( pfnMergeCallback( &callbackData, DRM_SECURE_STATE_TOKEN_RESOLVE_CALLBACK, pvCallbackData ) );
            }

            _PrepareTokenForWrite( &token, pcontextSST->rgbSlotData + __CB_DECL( dwOffset ) );

            dr = DRM_SUCCESS;
            goto ErrorExit;
        }
        else
        {
            dwOffset += cbString;
            
            _PrepareTokenForRead( pcontextSST->rgbSlotData + __CB_DECL( dwOffset ), &token );
            dwOffset += SIZEOF( PERSISTEDTOKEN );

            if( token.TokenType == TOKEN_BYTEBLOB )
            {
                dwOffset += token.val.byteValue.cbBlob + (token.val.byteValue.cbBlob % 2);
            }
        }
    }

    /* If we got here then the attribute was not found in the slot.  This is good for new attributes, bad for non-new attributes */
    if( !fNewAttribute )
    {
        ChkDR( CPRMEXP_UPDATE_FAILURE );
    }
    
    dwOffset                 = pcontextSST->cbSlotData;
    pcontextSST->cbSlotData += SIZEOF( DRM_WORD ) 
                             + CB_DSTR( pdstrAttribute ) 
                             + CALC_PERSISTEDTOKEN_FILE_LENGTH( pTokenAbsolute );

    if( pcontextSST->cbSlotData > DRM_SEC_STORE_MAX_SLOT_SIZE )
    {
        ChkDR( DRM_E_SECURESTORE_FULL );
    }
    
    if( CB_DSTR( pdstrAttribute ) > MAX_UNSIGNED_TYPE( DRM_WORD ) )
    {
        ChkDR( DRM_E_SECURESTORE_FULL );
    }

    cbString = (DRM_WORD) CB_DSTR( pdstrAttribute ) & MAX_UNSIGNED_TYPE( DRM_WORD );

    FIX_ENDIAN_WORD( cbString );

    DRM_BYT_CopyBytes( pcontextSST->rgbSlotData, dwOffset, &cbString,                 0, SIZEOF( cbString ) );
    dwOffset += SIZEOF( cbString );
    FIX_ENDIAN_WORD( cbString );
    DRM_BYT_CopyBytes( pcontextSST->rgbSlotData, dwOffset, PB_DSTR( pdstrAttribute ), 0, cbString );
    dwOffset += CB_DSTR( pdstrAttribute );

    DRMASSERT( pTokenAbsolute->TokenType == pTokenDelta->TokenType );
    token = *pTokenAbsolute;
    switch( pTokenDelta->TokenType )
    {
    case TOKEN_LONG:                     
        token.val.lValue += pTokenDelta->val.lValue;
        break;
    case TOKEN_DATETIME:
        token.val.u64DateTime = DRM_UI64Add( pTokenDelta->val.u64DateTime, pTokenAbsolute->val.u64DateTime );
        break;
    case TOKEN_BYTEBLOB:
        token.val.byteValue.pbBlob = pTokenAbsolute->val.byteValue.pbBlob;
        break;
    default:
        ChkDR( CPRMEXP_UPDATE_FAILURE );
    }
    
    _PrepareTokenForWrite( &token, pcontextSST->rgbSlotData + __CB_DECL( dwOffset ) );
    
ErrorExit:
    return dr;
}

static DRM_NO_INLINE DRM_RESULT _ApplyDiffsToStore( 
    IN     DRM_SECSTORE_CONTEXT *pcontextSST, 
    IN OUT DRM_SECSTORE_CONTEXT *pcontextSSTFromDisk,
    IN     DRMPFNPOLICYCALLBACK  pfnMergeCallback,
    IN     const DRM_VOID       *pvCallbackData )
{
    DRM_RESULT dr     = DRM_SUCCESS;
    DRM_WORD   iCount = 0;
    TOKEN      token;
    DRM_BOOL   fDataChangedOnDisk = FALSE;

    if( MEMCMP( pcontextSST->rgbSlotData + __CB_DECL( DRM_SST_SLOT_HASH_OFFSET ),
                 pcontextSSTFromDisk->rgbSlotData + __CB_DECL( DRM_SST_SLOT_HASH_OFFSET ),
                 DRM_SHA1_DIGEST_LEN ) != 0 )
    {
        /*
        ** Another instance of DRM wrote updated data to disk between OpenKey and CloseKey
        */
        fDataChangedOnDisk = TRUE;
    }

    for( iCount = 0; iCount < pcontextSST->wNumOriginalAttributes; iCount++ )
    {
        if( (pcontextSST->rgAttributes[iCount].dwFlags & DRM_TOKEN_FLAG_DIRTY) != 0 )
        {
            _PrepareTokenForRead( pcontextSST->rgAttributes[iCount].pTokenValue, &token);

            /* Make sure that if this needs to be resolved with a callback that they did specify one */
            ChkArg( (pcontextSST->rgAttributes[iCount].dwFlags & DRM_TOKEN_RESOLVE_BITMASK) != DRM_TOKEN_RESOLVE_CALLBACK
                 || pfnMergeCallback != NULL )
            
            
            ChkDR( _UpdateAttributeTokenInSlot( pcontextSSTFromDisk,
                                                &(pcontextSST->rgAttributes[iCount].dstrAttribute),
                                                &(pcontextSST->rgAttributes[iCount].TokenDelta),
                                                &token,
                                                pcontextSST->rgAttributes[iCount].dwFlags,
                                                FALSE,
                                                fDataChangedOnDisk,
                                                pfnMergeCallback,
                                                pvCallbackData ) );
        }
    }

    for( iCount = pcontextSST->wNumOriginalAttributes; iCount < pcontextSST->wNumAttributes; iCount++ )
    {
        if( (pcontextSST->rgAttributes[iCount].dwFlags & DRM_TOKEN_FLAG_DIRTY) != 0 )
        {
            _PrepareTokenForRead( pcontextSST->rgAttributes[iCount].pTokenValue, &token);

            /* Make sure that if this needs to be resolved with a callback that they did specify one */
            ChkArg( (pcontextSST->rgAttributes[iCount].dwFlags & DRM_TOKEN_RESOLVE_BITMASK) != DRM_TOKEN_RESOLVE_CALLBACK
                 || pfnMergeCallback != NULL )
            
            ChkDR( _UpdateAttributeTokenInSlot( pcontextSSTFromDisk, 
                                                &(pcontextSST->rgAttributes[iCount].dstrAttribute),
                                                &(pcontextSST->rgAttributes[iCount].TokenDelta),
                                                &token,
                                                pcontextSST->rgAttributes[iCount].dwFlags,
                                                TRUE,
                                                fDataChangedOnDisk,
                                                pfnMergeCallback,
                                                pvCallbackData ) );        
        }
    }

ErrorExit:
    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_CloseKey( 
    IN       DRM_SECSTORE_CONTEXT *pcontextSST, 
    IN       DRM_DST              *pDatastore,
    IN       DRMPFNPOLICYCALLBACK  pfnMergeCallback,
    IN       const DRM_VOID       *pvCallbackData )
{
    DRM_RESULT           dr              = DRM_SUCCESS;
    DRM_DWORD            cbWritten       = 0;    
    DRM_DWORD            dwSlotMetaData  = 0;
    DRM_BOOL             fCloseStore     = FALSE;
    DRM_SECSTORE_CONTEXT contextSST      = { 0 };

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMSECSTORE, PERF_FUNC_DRM_SST_CloseKey);

    ChkArg (pcontextSST          != NULL
         && pDatastore          != NULL
         && pcontextSST->fInited != FALSE);

    if( !pcontextSST->fOpened
     || !pcontextSST->fDirty
     ||  pcontextSST->fNoPassword )
    {
        /* They didn't touch anything in the store, so we're done.
        ** Return DRM_S_FALSE to notify callers that nothing changed
        ** in the secure store.
        */
        dr = DRM_S_FALSE;
        goto ErrorExit;
    }
    
    MEMCPY( &contextSST.rgbKey1, &pcontextSST->rgbKey1, SIZEOF( contextSST.rgbKey1 ) );
    MEMCPY( &contextSST.rgbKey2, &pcontextSST->rgbKey2, SIZEOF( contextSST.rgbKey2 ) );
    MEMCPY( &contextSST.slotHint, &pcontextSST->slotHint, SIZEOF( contextSST.slotHint ) );
    contextSST.pNamespaceId = pcontextSST->pNamespaceId;
        
    ChkDR( _OpenAndVerifySlot( &contextSST, pDatastore, pcontextSST->rgbPassword, pcontextSST->eType, FALSE, DRM_SECURE_STORE_OPEN_EXISTING, 0 ) );    
    fCloseStore = TRUE;

    /* The slot hash of the now opened slot is valid.  Go about the process of applying diff's to the 
       attributes in the slot */    
    ChkDR( _ApplyDiffsToStore( pcontextSST, &contextSST, pfnMergeCallback, pvCallbackData ) );

    /* Update the size in the slot meta data */
    if ( contextSST.dwSlotVersion == 0 )
    {
        /*
        **  We must update the format of this slot before writing it to disc
        */ 

        /*  Set the metadata first  */
        BYTES_TO_DWORD( dwSlotMetaData, contextSST.rgbSlotData );
        DRM_SST_SET_SLOT_METADATA( dwSlotMetaData );
        DWORD_TO_BYTES( contextSST.rgbSlotData, dwSlotMetaData );

        /*  Move the rest of the data down by a DWORD       */
        /*  We have enough space in the bufer to do this    */
        DRM_BYT_MoveBytes( contextSST.rgbSlotData, 
                           DRM_SST_SLOT_DATA_OFFSET, 
                           contextSST.rgbSlotData, 
                           DRM_SST_SLOT_V0_DATA_OFFSET, 
                           contextSST.cbSlotData - DRM_SST_SLOT_V0_HEADER_SIZE );

        /*  Increment the slotsize by a DWORD   */
        contextSST.cbSlotData += DRM_SST_SLOT_SIZEDATA_SIZE;
        
        ChkOverflow( contextSST.cbSlotData, DRM_SST_SLOT_SIZEDATA_SIZE );
    }

    /*  Update the size data in the buffer  */        
    DWORD_TO_BYTES( contextSST.rgbSlotData + __CB_DECL( DRM_SST_SLOT_METADATA_SIZE ), 
                    contextSST.cbSlotData );     

    ChkDR( DRM_HMAC_CreateMAC( eDRM_SHA_1,
                               pcontextSST->rgbPassword,
                               DRM_SHA1_DIGEST_LEN,
                               contextSST.rgbSlotData,
                               DRM_SST_SLOT_DATA_OFFSET,
                               contextSST.cbSlotData - DRM_SST_SLOT_HEADER_SIZE,                               
                               contextSST.rgbSlotData,                               
                               DRM_SST_SLOT_HASH_OFFSET,
                               DRM_SHA1_DIGEST_LEN ) );

    /* Write the new hash back to disk */    
    if( contextSST.cbSlot < contextSST.cbSlotData )
    {
        ChkDR( DRM_DST_SlotResize( pDatastore, &contextSST.oSlotContext, contextSST.cbSlotData ) );
    }
    ChkDR( DRM_DST_SlotSeek( pDatastore, &contextSST.oSlotContext, 0, eDRM_DST_SEEKSET, NULL ) );
    ChkDR( DRM_DST_SlotWrite( pDatastore, &contextSST.oSlotContext, contextSST.cbSlotData, contextSST.rgbSlotData, &cbWritten ) );

#if !_DATASTORE_WRITE_THRU
    ChkDR( DRM_DST_CommitNamespace( pDatastore, &contextSST.oNsContext ) );
#endif
    
ErrorExit:    
    if( pcontextSST != NULL )
    {
        ZEROMEM( &pcontextSST->slotHint, SIZEOF( DRM_DST_SLOT_HINT ) );
    }

    if( fCloseStore )
    {
        DRM_DST_CloseSlot( pDatastore, &contextSST.oSlotContext );
        DRM_DST_CloseNamespace( pDatastore, &contextSST.oNsContext   );
    }    
    
    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_GetTokenValue(
    IN       DRM_SECSTORE_CONTEXT *pcontextSST,
    IN const DRM_CONST_STRING     *pdstrAttribute,
       OUT   TOKEN                *pToken )
{
    return DRM_SST_GetExtendedTokenValue( pcontextSST, XMR_OBJECT_TYPE_INVALID, XMR_OBJECT_TYPE_INVALID, pdstrAttribute, pToken );
}

/* 4 characters is right ID, 4 is restriction ID, and 1 is a trailing period */
#define DRM_SECSTORE_EXTENDED_PREFIX_LEN 9

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_GetExtendedTokenValue(
    IN       DRM_SECSTORE_CONTEXT *pcontextSST,
    IN const DRM_WORD              wRightID,
    IN const DRM_WORD              wRestrictionID,
    IN const DRM_CONST_STRING     *pdstrAttribute,
       OUT   TOKEN                *pToken )
{
    DRM_RESULT                  dr       = DRM_SUCCESS; /* Return DRM_S_FALSE to indicate that it couldn't be found */

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMSECSTORE, PERF_FUNC_DRM_SST_GetExtendedTokenValue );
    
    ChkArg (pcontextSST          != NULL
         && pcontextSST->fInited != FALSE
         && pToken               != NULL);

    if( !pcontextSST->fOpened )
    {
        /* This is the first time they're touching data, so need to load it */
        ChkDR( _LoadKeyTokens( pcontextSST, pcontextSST->pDatastore ) );
    }

    ChkDR( DRM_SST_GetTokenValueFromCache( wRightID,
                                           wRestrictionID,
                                           pdstrAttribute,
                                           pcontextSST->rgAttributes,
                                           pcontextSST->wNumAttributes,
                                           pToken) );
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_GetTokenValueFromCache(
    IN const DRM_WORD              wRightID,
    IN const DRM_WORD              wRestrictionID,
    IN const DRM_CONST_STRING     *pdstrAttribute,
    IN  CachedAttribute            rgAttributes[DRM_MAX_ATTRIBUTES_PER_SST_KEY], 
    IN  DRM_WORD                   wNumAttributes,
       OUT   TOKEN                *pToken )
{
    DRM_RESULT                  dr       = DRM_SUCCESS; /* Return DRM_S_FALSE to indicate that it couldn't be found */
    DRM_DWORD                   dwCount  = 0;
    DRM_WCHAR  rgwcExtendedPrefix[DRM_SECSTORE_EXTENDED_PREFIX_LEN+1] = {0};
    DRM_BOOL   fIsExtended = FALSE;

    ChkArg ( pToken != NULL && wNumAttributes < DRM_MAX_ATTRIBUTES_PER_SST_KEY );    
    ChkDRMString( pdstrAttribute );
    
    /* Both or neither should be XMR_OBJECT_TYPE_INVALID, but not a mix */
    ChkArg( !((wRightID == XMR_OBJECT_TYPE_INVALID) ^ (wRestrictionID == XMR_OBJECT_TYPE_INVALID)) );

    if( wRightID != XMR_OBJECT_TYPE_INVALID && wRestrictionID != XMR_OBJECT_TYPE_INVALID )
    {
        ChkDR( DRM_STR_NumberToString( ((DRM_DWORD)wRightID << 16) | (DRM_DWORD)wRestrictionID, rgwcExtendedPrefix, NO_OF( rgwcExtendedPrefix ), DRM_MAX_CCH_BASE16_DWORD_STRING, 16, NULL ) );
        rgwcExtendedPrefix[DRM_SECSTORE_EXTENDED_PREFIX_LEN-1] = WCHAR_CAST('.');
        fIsExtended = TRUE;
    }
    
    for( dwCount = 0; dwCount < wNumAttributes; dwCount++ )
    {
        if( (!fIsExtended && pdstrAttribute->cchString == rgAttributes[dwCount].dstrAttribute.cchString 
                    && 0 == MEMCMP( PB_DSTR( pdstrAttribute ), PB_DSTR( &rgAttributes[dwCount].dstrAttribute ), CB_DSTR( pdstrAttribute ) ) )

          || (fIsExtended && (pdstrAttribute->cchString + DRM_SECSTORE_EXTENDED_PREFIX_LEN ) == rgAttributes[dwCount].dstrAttribute.cchString
                    && 0 == MEMCMP( rgwcExtendedPrefix , PB_DSTR( &rgAttributes[dwCount].dstrAttribute ), DRM_SECSTORE_EXTENDED_PREFIX_LEN * SIZEOF(DRM_WCHAR) ) )
                    && 0 == MEMCMP( PB_DSTR( pdstrAttribute ), PB_DSTR( &rgAttributes[dwCount].dstrAttribute ) + __CB_DECL( DRM_SECSTORE_EXTENDED_PREFIX_LEN * SIZEOF(DRM_WCHAR) ), CB_DSTR( pdstrAttribute ) ) )
        {
            
            /* We matched the string value. Return the token value.*/
            _PrepareTokenForRead( rgAttributes[dwCount].pTokenValue, pToken );
            
            /* Update the result token with the delta data */
            switch( pToken->TokenType )
            {
            case TOKEN_LONG:
                /* NewDiff = NewValue - CachedValue */
                pToken->val.lValue += rgAttributes[dwCount].TokenDelta.val.lValue;
                break;
            case TOKEN_DATETIME:
                pToken->val.u64DateTime = DRM_UI64Add( pToken->val.u64DateTime, rgAttributes[dwCount].TokenDelta.val.u64DateTime );
                break;
            }
            
            dr = DRM_SUCCESS; /* DRM_SUCCESS indicates that the value was found */
            goto ErrorExit;
        }
    }

    /* Value wasn't found */
    dr = DRM_S_FALSE;

ErrorExit:
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_SetTokenValue(
    IN       DRM_SECSTORE_CONTEXT *pcontextSST,
    IN const DRM_CONST_STRING     *pdstrAttribute,
    IN const TOKEN                *pToken )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  dwFlags = 0;

    switch( pToken->TokenType )
    {
    case TOKEN_LONG:
        dwFlags = DRM_TOKEN_RESOLVE_DELTA;
        break;
        
    case TOKEN_DATETIME:
        dwFlags = DRM_TOKEN_RESOLVE_FIRST_WINS;
        break;
    }

    dr = DRM_SST_SetExtendedTokenValue( pcontextSST, XMR_OBJECT_TYPE_INVALID, XMR_OBJECT_TYPE_INVALID, pdstrAttribute, pToken, dwFlags );
    
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_SetExtendedTokenValue(
    IN       DRM_SECSTORE_CONTEXT *pcontextSST,
    IN const DRM_WORD              wRightID,
    IN const DRM_WORD              wRestrictionID,
    IN const DRM_CONST_STRING     *pdstrAttribute,
    IN const TOKEN                *pToken,
    IN       DRM_DWORD             dwFlags )
{
    DRM_RESULT dr       = DRM_S_FALSE; /* Return DRM_S_FALSE to indicate that it couldn't be found */
    DRM_DWORD  dwCount  = 0;
    DRM_WORD   cbString = 0;
    TOKEN      token;
    DRM_WCHAR  rgwcExtendedPrefix[DRM_SECSTORE_EXTENDED_PREFIX_LEN+1] = {0};
    DRM_BOOL   fIsExtended = FALSE;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMSECSTORE, PERF_FUNC_DRM_SST_SetExtendedTokenValue );

    ChkArg (pcontextSST          != NULL
        &&  pToken               != NULL
        &&  pcontextSST->fInited != FALSE
        &&  (pToken->TokenType   == TOKEN_LONG 
          || pToken->TokenType   == TOKEN_DATETIME
          || pToken->TokenType   == TOKEN_BYTEBLOB));

    /* Both or neither should be XMR_OBJECT_TYPE_INVALID, but not a mix */
    ChkArg( !((wRightID == XMR_OBJECT_TYPE_INVALID) ^ (wRestrictionID == XMR_OBJECT_TYPE_INVALID)) );

    ChkDRMString( pdstrAttribute );

    /* make sure the slot is not opened without password */
    ChkBOOL(!pcontextSST->fNoPassword, DRM_E_INVALID_SECURESTORE_PASSWORD);

    switch( dwFlags & DRM_TOKEN_RESOLVE_BITMASK )
    {
        case DRM_TOKEN_RESOLVE_DELTA:
        case DRM_TOKEN_RESOLVE_FIRST_WINS:
            ChkArg( pToken->TokenType == TOKEN_LONG
                 || pToken->TokenType == TOKEN_DATETIME ); /* Only long or datetime types are allowed for delta resolves */
            break;
        
        case DRM_TOKEN_RESOLVE_LAST_WINS:
        case DRM_TOKEN_RESOLVE_CALLBACK:
            break;
        default:
            ChkArg( FALSE ); /* Unknown token resolve type */
    }

    if( !pcontextSST->fOpened )
    {
        /* This is the first time they're touching data, so need to load it */
        ChkDR( _LoadKeyTokens( pcontextSST, pcontextSST->pDatastore ) );
    }

    /* Set the dirty flag to indicate it needs to be written to disk */
    pcontextSST->fDirty = TRUE;

    if( wRightID != XMR_OBJECT_TYPE_INVALID && wRestrictionID != XMR_OBJECT_TYPE_INVALID )
    {
        ChkDR( DRM_STR_NumberToString( ((DRM_DWORD)wRightID << 16) | (DRM_DWORD)wRestrictionID, rgwcExtendedPrefix, NO_OF( rgwcExtendedPrefix ), DRM_MAX_CCH_BASE16_DWORD_STRING, 16, NULL ) );
        rgwcExtendedPrefix[DRM_SECSTORE_EXTENDED_PREFIX_LEN-1] = WCHAR_CAST('.');
        fIsExtended = TRUE;
    }
    
    /* Search to see if the token already exists */
    for( dwCount = 0; dwCount < pcontextSST->wNumAttributes; dwCount++ )
    {
        /* Compare the attribute name to see if it matches. For extended attributes need to
        ** compare the prefix as well */
        if( (!fIsExtended && pdstrAttribute->cchString == pcontextSST->rgAttributes[dwCount].dstrAttribute.cchString 
                    && 0 == MEMCMP( PB_DSTR( pdstrAttribute ), PB_DSTR( &pcontextSST->rgAttributes[dwCount].dstrAttribute ), CB_DSTR( pdstrAttribute ) ) )

          || (fIsExtended && (pdstrAttribute->cchString + DRM_SECSTORE_EXTENDED_PREFIX_LEN ) == pcontextSST->rgAttributes[dwCount].dstrAttribute.cchString
                    && 0 == MEMCMP( rgwcExtendedPrefix , PB_DSTR( &pcontextSST->rgAttributes[dwCount].dstrAttribute ), DRM_SECSTORE_EXTENDED_PREFIX_LEN * SIZEOF(DRM_WCHAR) ) )
                    && 0 == MEMCMP( PB_DSTR( pdstrAttribute ), PB_DSTR( &pcontextSST->rgAttributes[dwCount].dstrAttribute ) + __CB_DECL( DRM_SECSTORE_EXTENDED_PREFIX_LEN * SIZEOF(DRM_WCHAR) ), CB_DSTR( pdstrAttribute ) ) )
        {
            /* We matched the string value. Update the delta.*/
            _PrepareTokenForRead( pcontextSST->rgAttributes[dwCount].pTokenValue, &token );
            
            if( pToken->TokenType != token.TokenType )
            {
                /* You can't change the token type!! */
                ChkDR( DRM_E_WRONG_TOKEN_TYPE );
            }


            pcontextSST->rgAttributes[dwCount].dwFlags = dwFlags | DRM_TOKEN_FLAG_DIRTY;
            pcontextSST->rgAttributes[dwCount].TokenDelta.TokenType = token.TokenType;
            switch( token.TokenType )
            {
                case TOKEN_LONG:
                    /* We're storing only the delta */
                    /* NewDiff = NewValue - CachedValue */
                    pcontextSST->rgAttributes[dwCount].TokenDelta.val.lValue = pToken->val.lValue - token.val.lValue;
                    break;
                case TOKEN_DATETIME:
                    /* We're storing only the delta */
                    /* NewDiff = NewValue - CachedValue */
                    pcontextSST->rgAttributes[dwCount].TokenDelta.val.u64DateTime = DRM_UI64Sub(pToken->val.u64DateTime, token.val.u64DateTime);
                    break;
                case TOKEN_BYTEBLOB:
                    /* Can't change the size */
                    ChkArg( pToken->val.byteValue.cbBlob == token.val.byteValue.cbBlob );

                    MEMCPY( (DRM_BYTE*)pcontextSST->rgAttributes[dwCount].pTokenValue + __CB_DECL( SIZEOF( PERSISTEDTOKEN ) ), 
                                    pToken->val.byteValue.pbBlob, 
                                    pToken->val.byteValue.cbBlob );
                    break;
                default:
                    DRMASSERT( FALSE );
            }

            dr = DRM_SUCCESS;
            goto ErrorExit;
        }
    }
    
    /* Attribute doesn't exist.  Try to create a new one.  Be weary of running out of slot space, as well as 
       cached attribute structure space */
    if( pcontextSST->wNumAttributes == DRM_MAX_ATTRIBUTES_PER_SST_KEY )
    {
        ChkDR( DRM_E_SECURESTORE_FULL );
    }
    if( pcontextSST->cbSlotData                                                                                                   > DRM_SEC_STORE_MAX_SLOT_SIZE
     || pcontextSST->cbSlotData + SIZEOF( DRM_WORD )                                                                              > DRM_SEC_STORE_MAX_SLOT_SIZE
     || pcontextSST->cbSlotData + SIZEOF( DRM_WORD ) + CB_DSTR( pdstrAttribute )                                                  > DRM_SEC_STORE_MAX_SLOT_SIZE
     || pcontextSST->cbSlotData + SIZEOF( DRM_WORD ) + CB_DSTR( pdstrAttribute ) + CALC_PERSISTEDTOKEN_FILE_LENGTH( pToken )      > DRM_SEC_STORE_MAX_SLOT_SIZE
     || (fIsExtended && (pcontextSST->cbSlotData + SIZEOF( DRM_WORD ) + CB_DSTR( pdstrAttribute ) + CALC_PERSISTEDTOKEN_FILE_LENGTH( pToken ) + NO_OF( rgwcExtendedPrefix ) > DRM_SEC_STORE_MAX_SLOT_SIZE)) )
    {
        /* Not enough room in the slot */
        ChkDR( DRM_E_SECURESTORE_FULL );
    }

    /* Fill in the data in the slot buffer and the cache attribute array */
    ZEROMEM(       &pcontextSST->rgAttributes[pcontextSST->wNumAttributes], 
            SIZEOF( pcontextSST->rgAttributes[pcontextSST->wNumAttributes] ) );

    if( CB_DSTR( pdstrAttribute ) > MAX_UNSIGNED_TYPE( DRM_WORD ) )
    {
        ChkDR( DRM_E_SECURESTORE_FULL );
    }

    cbString = (DRM_WORD) CB_DSTR( pdstrAttribute ) + ( fIsExtended ? DRM_SECSTORE_EXTENDED_PREFIX_LEN * SIZEOF(DRM_WCHAR) : 0 );
    FIX_ENDIAN_WORD( cbString );
    MEMCPY( &(pcontextSST->rgbSlotData[__CB_DECL(pcontextSST->cbSlotData)]), &cbString, SIZEOF( cbString ) );
    pcontextSST->cbSlotData += SIZEOF( cbString );
    FIX_ENDIAN_WORD( cbString );

    pcontextSST->rgAttributes[pcontextSST->wNumAttributes].dstrAttribute.cchString  = pdstrAttribute->cchString;
    pcontextSST->rgAttributes[pcontextSST->wNumAttributes].dstrAttribute.pwszString = (DRM_WCHAR*) &(pcontextSST->rgbSlotData[__CB_DECL(pcontextSST->cbSlotData)]);
    if( fIsExtended )
    {
        pcontextSST->rgAttributes[pcontextSST->wNumAttributes].dstrAttribute.cchString += DRM_SECSTORE_EXTENDED_PREFIX_LEN;
        MEMCPY( &(pcontextSST->rgbSlotData[__CB_DECL(pcontextSST->cbSlotData)]), rgwcExtendedPrefix, DRM_SECSTORE_EXTENDED_PREFIX_LEN * SIZEOF(DRM_WCHAR) );
        pcontextSST->cbSlotData += DRM_SECSTORE_EXTENDED_PREFIX_LEN * SIZEOF(DRM_WCHAR);
    }
    MEMCPY( &(pcontextSST->rgbSlotData[__CB_DECL(pcontextSST->cbSlotData)]), pdstrAttribute->pwszString, CB_DSTR( pdstrAttribute ) );
    pcontextSST->cbSlotData += CB_DSTR( pdstrAttribute );

    if( pToken->TokenType == TOKEN_BYTEBLOB )
    {
        /* We're storing an absolute value, not a delta */
        token = *pToken;
        ZEROMEM( &(pcontextSST->rgAttributes[dwCount].TokenDelta), SIZEOF( PERSISTEDTOKEN ) );
    }
    else
    {
        /* We're storing a delta from 0 since the token doesn't exist */
        _Token_To_PersistedToken( pToken, &(pcontextSST->rgAttributes[dwCount].TokenDelta));
        ZEROMEM(&token, SIZEOF( TOKEN ) );
        token.TokenType = pToken->TokenType;
    }
    pcontextSST->rgAttributes[dwCount].TokenDelta.TokenType = pToken->TokenType;
    pcontextSST->rgAttributes[dwCount].dwFlags = dwFlags | DRM_TOKEN_FLAG_DIRTY;
    
    pcontextSST->rgAttributes[pcontextSST->wNumAttributes].pTokenValue = &(pcontextSST->rgbSlotData[__CB_DECL(pcontextSST->cbSlotData)]);
    _PrepareTokenForWrite( &token, &(pcontextSST->rgbSlotData[__CB_DECL(pcontextSST->cbSlotData)]) );
    pcontextSST->cbSlotData += CALC_PERSISTEDTOKEN_FILE_LENGTH( pToken );
    
    pcontextSST->wNumAttributes++;

    dr = DRM_SUCCESS;

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/*****************************************************************************
** Function: DRM_SST_DeleteKey
**
** Synopsis: Delete an entry from the secure store
**
** Arguments:
**           [f_pcontextSST] -- secure store context, need not be initialized
**           [f_typeSST]     -- one of the legal enums corresponding to the 
**                              layer to open
**           [f_pid1]
**           [f_pid2]        -- major and minor "keys" of the data store to 
**                              delete
**           [f_pDatastore] -- initialized DST context
**                              
** Notes:    Indiscriminate deletion of keys could open up the system for 
**           replay attacks 
*****************************************************************************/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_DeleteKey(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN       eDRM_SECURE_STORE_TYPE  f_typeSST,
    IN const DRM_ID                 *f_pid1,
    IN const DRM_ID                 *f_pid2,
    IN       DRM_DST                *f_pDatastore)
{
    DRM_RESULT  dr  = DRM_SUCCESS;
    DRM_DST_KEY id2 = {0};

    ChkArg(f_pcontextSST != NULL
        && f_pDatastore != NULL
        && f_pid1        != NULL);

    /* Check for supported flags */

    ChkArg( IsValidSecureStoreType( f_typeSST, DISALLOW_CACHEDCERT ) );

    f_pcontextSST->pNamespaceId = MapSecureStoreTypeToNamespace( f_typeSST );

    if( f_pid2 != NULL )
    {
        MEMCPY( &id2, f_pid2, SIZEOF( id2 ) );
    }
    ChkDR( DRM_DST_OpenNamespace( f_pDatastore, 
                                  f_pcontextSST->pNamespaceId, 
                                  (DRM_DST_OPENMODE)(eDRM_DST_OPEN_EXISTING | eDRM_DST_LOCKWAIT),
                                  0,
                                  0,
                                  &f_pcontextSST->oNsContext ) );
                               
    ChkDR( DRM_DST_DeleteSlot( f_pDatastore,
                               &f_pcontextSST->oNsContext,
                               f_pid1, 
                               &id2,
                               NULL,
                               TRUE ) );

ErrorExit:
    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_GetAllData( 
    IN     DRM_SECSTORE_CONTEXT *pcontextSST,
    __out_bcount_opt( *pcbData ) DRM_BYTE *pbData,
    IN OUT DRM_DWORD            *pcbData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cbRequired = 0;
    DRM_DWORD   cbHeader    = 0;

    ChkArg (pcontextSST          != NULL
        &&  pcbData              != NULL
        &&  pcontextSST->fInited != FALSE);

    if( !pcontextSST->fOpened )
    {
        /* This is the first time they're touching data, so need to load it */
        ChkDR( _LoadKeyTokens( pcontextSST, pcontextSST->pDatastore ) );
    }

    cbHeader = ( pcontextSST->dwSlotVersion == 0 )
             ? DRM_SST_SLOT_V0_HEADER_SIZE
             : DRM_SST_SLOT_HEADER_SIZE;

    ChkBOOL( pcontextSST->cbSlotData >= cbHeader, DRM_E_SECURESTORE_CORRUPT );
    cbRequired = pcontextSST->cbSlotData - cbHeader;

    if (  pbData == NULL
      || *pcbData < cbRequired)
    {        
        *pcbData = cbRequired;
        dr = DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }

    MEMCPY (pbData, pcontextSST->rgbSlotData + __CB_DECL( cbHeader ), cbRequired);

    *pcbData = cbRequired;
    dr = DRM_SUCCESS;

ErrorExit:
    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_OpenEnumerator(
    IN        eDRM_SECURE_STORE_TYPE    eType,
    IN  const DRM_ID                   *pKey1,
    OUT       DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
    IN        DRM_DST                  *pDatastore,
    IN        DRM_BOOL                  fExclusiveLock)
{
    DRM_RESULT dr=DRM_SUCCESS;      
    const DRM_DST_NAMESPACE *pNamespaceId = NULL;
    DRM_DWORD  dwLockMode = eDRM_DST_LOCKWAIT;

    ChkArg( pcontextSSTEnum && pDatastore );
    if ( fExclusiveLock )
    {
        dwLockMode |= eDRM_DST_LOCKEXCLUSIVE;
    }
    else
    {
        dwLockMode |= eDRM_DST_LOCKSHARED;
    }

    /* Check for supported flags */
    if (!IsValidSecureStoreType( eType, DISALLOW_CACHEDCERT ) )
    {
        dr = DRM_E_INVALIDARG;
        goto ErrorExit;
    }

    ZEROMEM(pcontextSSTEnum, SIZEOF(pcontextSSTEnum));

    pNamespaceId = MapSecureStoreTypeToNamespace( eType );

    dr = DRM_DST_OpenNamespace( pDatastore, 
                                pNamespaceId, 
                                (DRM_DST_OPENMODE)(eDRM_DST_OPEN_EXISTING | eDRM_DST_LOCKWAIT),
                                0,
                                0,
                                &pcontextSSTEnum->oNsContext );
    if ( dr == DRM_E_DSTNAMESPACENOTFOUND )
    {  
        dr = DRM_SUCCESS;
        pcontextSSTEnum->fInited = TRUE;
        pcontextSSTEnum->eMode   = eSSTEnumNone;
        goto ErrorExit;
    }
    ChkDR( dr );

    dr =  DRM_DST_InitSlotEnum( pDatastore,
                                &pcontextSSTEnum->oNsContext, 
                                ( DRM_DST_KEY * )pKey1, 
                                ( DRM_DST_LOCKMODE )dwLockMode, 
                                &pcontextSSTEnum->oDstEnumContext);
    if( dr == DRM_E_DSTSLOTNOTFOUND )
    {
        /* No Slots found. */
        pcontextSSTEnum->eMode = eSSTEnumNone;
        dr = DRM_SUCCESS;
    }
    else if( DRM_FAILED( dr ) )
    {
        goto ErrorExit;
    }
    else if ( pKey1 )
    {
        pcontextSSTEnum->eMode = eSSTEnumFiltered;
    }
    else
    {
        pcontextSSTEnum->eMode = eSSTEnumNatural;        
    }
    pcontextSSTEnum->pDatastore   = pDatastore;
    pcontextSSTEnum->fCurrIsValid = FALSE;
    pcontextSSTEnum->fInited      = TRUE;
    pcontextSSTEnum->eType        = eType;

ErrorExit:    
    return dr;
}


/*
**
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_EnumNext( 
    IN  DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
    OUT DRM_ID                   *pKey1,
    OUT DRM_ID                   *pKey2,
    OUT DRM_DWORD                *pcbData )
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  cbSlot = 0;
    DRM_DWORD  cbRead           = 0;   
    DRM_DWORD  dwSlotMetaData   = 0;

    ChkArg (pcontextSSTEnum           != NULL
         && pcontextSSTEnum->fInited  != FALSE
         && pcbData         != NULL);

    if ( pcontextSSTEnum->eMode == eSSTEnumNone )
    {
        dr = DRM_E_NOMORE;
        goto ErrorExit;            
    }

    *pcbData = 0;

    dr = DRM_DST_SlotEnumNext( pcontextSSTEnum->pDatastore,
                               &pcontextSSTEnum->oDstEnumContext, 
                               &pcontextSSTEnum->oSlotContext, 
                               &pcontextSSTEnum->oCurrKID, 
                               &pcontextSSTEnum->oCurrLID, 
                               &cbSlot );
    if ( dr == DRM_E_NOMORE )
    {
        goto ErrorExit;
    }
    else if ( dr == DRM_E_DSTBLOCKMISMATCH 
           || dr == DRM_E_DSTSLOTNOTFOUND )
    {
        ChkDR(DRM_E_SECURESTORE_CORRUPT);
    }
    ChkDR(dr);

    if( pKey1 != NULL )
    {
        MEMCPY(pKey1->rgb, pcontextSSTEnum->oCurrKID.rgb, DRM_ID_SIZE);
    }
    if( pKey2 != NULL )
    {
        MEMCPY(pKey2->rgb, pcontextSSTEnum->oCurrLID.rgb, DRM_ID_SIZE);
    }

    pcontextSSTEnum->fCurrIsValid = TRUE;
    
    /*
    **  Figure out the slot version
    */
    ChkDR( DRM_DST_SlotRead( pcontextSSTEnum->pDatastore,
                             &pcontextSSTEnum->oSlotContext, 
                             DRM_SST_SLOT_METADATA_SIZE, 
                             (DRM_BYTE *)&dwSlotMetaData, 
                             &cbRead ) );
    if( cbRead != DRM_SST_SLOT_METADATA_SIZE )
    {
        dr = DRM_E_FILEREADERROR;
        goto ErrorExit;
    }
    FIX_ENDIAN_DWORD( dwSlotMetaData );

    /*
    **  Read the slot size
    */
    ChkDR( DRM_DST_SlotRead( pcontextSSTEnum->pDatastore,
                             &pcontextSSTEnum->oSlotContext, 
                             DRM_SST_SLOT_SIZEDATA_SIZE, 
                             (DRM_BYTE *)pcbData, 
                             &cbRead ) );
    if( cbRead != DRM_SST_SLOT_SIZEDATA_SIZE )
    {
        *pcbData = 0;
        dr = DRM_E_FILEREADERROR;
        goto ErrorExit;
    }
    FIX_ENDIAN_DWORD( *pcbData );
    
    *pcbData = ( ( dwSlotMetaData & DRM_SST_SLOT_VERSION_MASK ) == 0 )
             ? *pcbData - DRM_SST_SLOT_V0_HEADER_SIZE
             : *pcbData - DRM_SST_SLOT_HEADER_SIZE;
    ChkDR( DRM_DST_CloseSlot( pcontextSSTEnum->pDatastore, &pcontextSSTEnum->oSlotContext ) );
    
ErrorExit:
    return dr;
}

/******************************************************************************
** Function :   DRM_SST_EnumDeleteCurrent
** Synopsis :   Delete the current enumerated slot
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_SST_EnumDeleteCurrent( 
    IN       DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
    IN OUT   DRM_SECSTORE_CONTEXT     *pcontextSST)
{
    DRM_RESULT dr               = DRM_SUCCESS;
    DRM_DWORD  cbSlot           = 0;
    
    ChkArg (pcontextSSTEnum          != NULL
         && pcontextSSTEnum->fInited != FALSE );

    ChkBOOL( pcontextSSTEnum->eMode != eSSTEnumNone, DRM_E_NOMORE);

    dr = DRM_DST_SlotEnumReloadCurrent( pcontextSSTEnum->pDatastore,
                                        &pcontextSSTEnum->oDstEnumContext, 
                                        &pcontextSST->oSlotContext, 
                                        &pcontextSSTEnum->oCurrKID, 
                                        &pcontextSSTEnum->oCurrLID, 
                                        &cbSlot );
    ChkBOOL(dr != DRM_E_NOMORE, DRM_E_NOMORE);
    ChkBOOL((dr != DRM_E_DSTBLOCKMISMATCH && dr != DRM_E_DSTSLOTNOTFOUND), DRM_E_SECURESTORE_CORRUPT);
    ChkDR(dr);

    dr = DRM_DST_SlotEnumDeleteCurrent( pcontextSSTEnum->pDatastore,
                                        &pcontextSSTEnum->oDstEnumContext, 
                                        &pcontextSST->oSlotContext );
    DRM_DST_CloseSlot( pcontextSSTEnum->pDatastore, &pcontextSST->oSlotContext );
    pcontextSSTEnum->fCurrIsValid = FALSE;
    pcontextSST->fInited = FALSE;
    pcontextSST->fOpened = FALSE;
    
ErrorExit:
    return dr;
}


/******************************************************************************
** Function :   DRM_SST_EnumLoadCurrent
** Synopsis :   Load the current slot in memory
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_EnumLoadCurrent( 
    IN       DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
    IN OUT   DRM_SECSTORE_CONTEXT     *pcontextSST,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE rgbPassword[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
       OUT   DRM_ID                   *pKey1,
       OUT   DRM_ID                   *pKey2,
    IN OUT DRM_DWORD                  *pcbData)
{
    DRM_RESULT dr               = DRM_SUCCESS;
    DRM_DWORD  cbSlot           = 0;
    DRM_DWORD  cbRead           = 0;   
    DRM_DWORD  dwSlotMetaData   = 0;
    DRM_DWORD  cbData           = 0;
    
    ChkArg (pcontextSSTEnum          != NULL
         && pcontextSSTEnum->fInited != FALSE
         && pcbData                  != NULL);


    ChkBOOL( pcontextSSTEnum->eMode != eSSTEnumNone, DRM_E_NOMORE);

    dr = DRM_DST_SlotEnumReloadCurrent( pcontextSSTEnum->pDatastore,
                                        &pcontextSSTEnum->oDstEnumContext, 
                                        &pcontextSST->oSlotContext, 
                                        &pcontextSSTEnum->oCurrKID, 
                                        &pcontextSSTEnum->oCurrLID, 
                                        &cbSlot );
    ChkBOOL(dr != DRM_E_NOMORE, DRM_E_NOMORE);
    ChkBOOL((dr != DRM_E_DSTBLOCKMISMATCH && dr != DRM_E_DSTSLOTNOTFOUND), DRM_E_SECURESTORE_CORRUPT);
    ChkDR(dr);

    if( pKey1 != NULL )
    {
        MEMCPY(pKey1->rgb, pcontextSSTEnum->oCurrKID.rgb, DRM_ID_SIZE);
    }
    
    if( pKey2 != NULL )
    {
        MEMCPY(pKey2->rgb, pcontextSSTEnum->oCurrLID.rgb, DRM_ID_SIZE);
    }
    pcontextSSTEnum->fCurrIsValid = TRUE;
    
    /*
    **  Figure out the slot version
    */
    ChkDR( DRM_DST_SlotRead( pcontextSSTEnum->pDatastore,
                             &pcontextSST->oSlotContext, 
                             DRM_SST_SLOT_METADATA_SIZE, 
                             ( DRM_BYTE * )&dwSlotMetaData, 
                             &cbRead ) );
    if ( cbRead != DRM_SST_SLOT_METADATA_SIZE )
    {
        dr = DRM_E_FILEREADERROR;
        goto ErrorExit;
    }
    FIX_ENDIAN_DWORD( dwSlotMetaData );

    cbData = ( ( dwSlotMetaData & DRM_SST_SLOT_VERSION_MASK ) == 0 )
             ? cbSlot - DRM_SST_SLOT_V0_HEADER_SIZE
             : cbSlot - DRM_SST_SLOT_HEADER_SIZE;

    /* read the slot data */
    pcontextSST->cbSlot = cbData;

    DRM_DST_SlotSeek( pcontextSSTEnum->pDatastore, &pcontextSST->oSlotContext, 0, eDRM_DST_SEEKSET, NULL);
    dr = _LoadSlot(pcontextSST, FALSE, pcontextSSTEnum->eType, rgbPassword);
    if ( DRM_SUCCEEDED(dr) )
    {
        *pcbData = cbData;
    }
    DRM_DST_CloseSlot( pcontextSSTEnum->pDatastore, &pcontextSST->oSlotContext );
    pcontextSST->fInited = TRUE;
    pcontextSST->fOpened = TRUE;
    
ErrorExit:
    return dr;
}
/*****************************************************************************
** Function: DRM_SST_CreateGlobalStorePassword
**
** Synopsis: use the keyeed to create the hash used as the secure store password 
**           for the global store
**
** Arguments:
**           [f_rgbSeed]     -- buffer to hold keyseed 
**           [f_rgbPassword] -- buffer to hold Password
**           [f_pcontextBBX] -- initialized BBX context
*****************************************************************************/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_CreateGlobalStorePassword(
    __out_bcount( DRM_SHA1_DIGEST_LEN ) DRM_BYTE  f_rgbPasswordSST[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN  DRM_BYTE *f_pbContextBBX)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE   rgbSeed [__CB_DECL(DRM_SHA1_DIGEST_LEN)];

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMSECSTORE, PERF_FUNC_DRM_SST_CreateGlobalStorePassword);

    ChkDR(Oem_Device_GetSecureStoreGlobalPasswordSeed(rgbSeed));

    ChkDR(DRM_BBX_HashValue(rgbSeed, 
                            DRM_SHA1_DIGEST_LEN-1,
                            f_rgbPasswordSST,
                            (DRM_BB_CONTEXT *) f_pbContextBBX));

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}

/*****************************************************************************
** Function: DRM_SST_CreateLicenseStatePassword
**
** Synopsis: use the LID to create the hash used as the secure store password 
**           for this license
**
** Arguments:
**           [f_rgbLID]         -- the LID 
**           [f_rgbPasswordSST] -- buffer to receive the password
**           [f_pcontextBBX]    -- initialized BBX context
*****************************************************************************/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SST_CreateLicenseStatePassword(
    IN            const DRM_LID  *f_plid,
    __out_bcount( DRM_SHA1_DIGEST_LEN ) DRM_BYTE  f_rgbPasswordLST[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN            DRM_BB_CONTEXT *f_pContextBBX)
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMSECSTORE, PERF_FUNC_DRM_SST_CreateLicenseStatePassword);

    ChkDR(DRM_BBX_HashValue((DRM_BYTE*) f_plid, 
                            SIZEOF (DRM_LID), 
                            f_rgbPasswordLST, 
                            f_pContextBBX)); 

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmrevocation.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>

#if DRM_SUPPORT_REVOCATION
#include <drmutilities.h>
#include <drmpkcrypto.h>
#include <drmcipher.h>
#include <drmsha1.h>
#include <drmrevocation.h>
#include <drmlicenseparser.h>
#include <drmxmlparser.h>
#include <drmxmlutilities.h>
#include <drmcrt.h>
#include <byteorder.h>
#include <drmint64.h>
#include <drmcert.h>
#include <drmbase64.h>
#include <drmcertparser.h>
#include <drmbcertparser.h>
#include <drmbcrl.h>
#include <oem.h>
#include <drmbcertparser.h>
#include <drmbcrl.h>

#if DRM_SUPPORT_WMDRMNET
#include <drmrsa.h>
#endif /* DRM_SUPPORT_WMDRMNET */


/* keypair for device exclusion; the private key is cloaked and must be uncloaked to compile */

#include <drmpubkeydeviceexclusion.h>

/* pubkey for app revocation */

#include <drmpubkeyrevocation.h>

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_WMDRMNET
static DRM_RESULT DRM_CALL _VerifyBinaryWMDRMNETSignature(
    IN     DRM_BYTE          *f_pbBinary,
    IN     DRM_DWORD          f_cbBinary,
    IN OUT DRM_DWORD         *f_pidSerial,
    IN     DRM_CRYPTO_CONTEXT*f_pCryptoCtx);

static DRM_RESULT _VerifyWMDRMNETRevocationList(
    IN  DRM_CONST_STRING   *f_pdstrList,
    OUT DRM_DWORD          *f_pdwVersion,
    DRM_CRYPTO_CONTEXT     *f_pCryptoCtx );
#endif /* DRM_SUPPORT_WMDRMNET */

static DRM_RESULT
_ValidateCertificate(
    IN DRM_CHAR          *      f_rgchBase,
    IN DRM_SUBSTRING             f_dasstrCertificate,
    IN OUT DRM_SUBSTRING        *f_pdasstrWMDRMNDCertificate,
    IN     DRM_CRYPTO_CONTEXT   *f_pCryptoCtx);

#if DRM_SUPPORT_APP_REVOCATION
/************************ APP REVOCATION ************************/
const DRM_DWORD CURRENT_REVOCATION_VERSION = 2;


static DRM_NO_INLINE DRM_RESULT _CheckCertInRevocationList(
    DRM_CERT_TYPE        f_certificatetype,
    DRM_BYTE            *f_pbCertData,
    DRM_DWORD            f_cbCertData,
    DRM_REVOCATION_LIST *f_prevocationlist)
{
    DRM_BYTE  *pbElt    = f_prevocationlist->rgbData;
    DRM_DWORD  cbElt    = 0;
    DRM_DWORD  ibElt    = 0;
    DRM_RESULT dr       = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC__CheckCertInRevocationList );

    cbElt = f_prevocationlist->cb;
    FIX_ENDIAN_DWORD( cbElt );

    /* The revocation list is an array of DRM_REVOCATION_LIST_ELEMENT structs, so lets check them */
    while ( ibElt < cbElt )
    {
        DRM_CERT_TYPE  ecertType = 0;
        DRM_DWORD      cbCert    = 0;

        DRM_BYT_CopyBytes( &ecertType, 0, pbElt, ibElt, SIZEOF( DRM_DWORD ) );
        FIX_ENDIAN_DWORD( ecertType );
        ibElt += SIZEOF( DRM_CERT_TYPE );

        DRM_BYT_CopyBytes( &cbCert, 0, pbElt, ibElt, SIZEOF( DRM_DWORD ) );
        FIX_ENDIAN_DWORD( cbCert );
        ibElt += SIZEOF( DRM_DWORD );

        if ((ecertType == f_certificatetype)
         && (cbCert    == f_cbCertData)
         && (DRM_BYT_CompareBytes(f_pbCertData, 0, pbElt, ibElt, f_cbCertData) == 0))
        {
            ChkDR(DRM_E_CERTIFICATE_REVOKED);
        }

        ibElt += cbCert;
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*****************************************************************************
** Function - DRM_RVK_PerformAppRevocationCheck
**
** Synopsis - calls app revocation operation
**
** Arguments
** [f_pcontextLEVL] -- initialized liceval context
** [f_pcontextBBX]  -- initialized blackbox context
** [f_pcontextHDS]  -- initialized HDS context
*****************************************************************************/
/*
NOTE: this function will only work for legacy WMDRM app certs. we need to
implement similar functionality for PlayReady app certs.
*/
DRM_API DRM_RESULT DRM_CALL DRM_RVK_PerformAppRevocationCheck(
    IN     DRM_CRYPTO_CONTEXT          *f_pContextCrypto,
    IN     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN     DRM_CONST_STRING            *f_pdstrContentLicense,
    IN     APPCERT                     *f_pAppCert,
    __in_bcount( f_cbRevocationBuffer ) DRM_BYTE *f_pbRevocationBuffer,
    IN     DRM_DWORD                    f_cbRevocationBuffer,
    IN OUT DRM_REVLIST_ID_VALUES       *f_pRevListIDs )
{
    DRM_RESULT       dr                         = DRM_SUCCESS;
    DRM_CONST_STRING dstrAttributeData          = EMPTY_DRM_STRING;
    DRM_DWORD        cbBuffer                   = 0;
    DRM_DWORD        crlVersion                 = 0;
    DRM_BOOL         fUpdatedRevocationList     = FALSE;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_PerformAppRevocationCheck );

    ChkArg ( f_pContextCrypto != NULL
        &&  f_pContextRev != NULL
        &&  f_pRevListIDs  != NULL);

    dr = DRM_LIC_GetAttribute( f_pdstrContentLicense,
                               &g_dstrAppRevocation,
                               DRM_LICENSE_ATTRIB_REVOCATION,
                               NULL,
                               &dstrAttributeData,
                               0 );

    if (dr == DRM_E_XMLNOTFOUND)
    {
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }

    ChkDR(dr);  /* other errors */

    /* Ensure latest app crl version is up to date */
    cbBuffer = f_cbRevocationBuffer;
    crlVersion = f_pRevListIDs->wmdrmapp;
    ChkDR( DRM_RVK_GetCurrentAppRevocationList( f_pContextRev,
                                                f_pbRevocationBuffer,
                                                &cbBuffer,
                                                &crlVersion ) );
    if( crlVersion > f_pRevListIDs->wmdrmapp )
    {
        f_pRevListIDs->wmdrmapp = crlVersion;
        f_pRevListIDs->fUpdatedRevocationList = TRUE;
    }

    ChkDR(DRM_RVK_UpdateAppRevocationListW( f_pContextCrypto,
                                            f_pContextRev,
                                            f_pbRevocationBuffer,
                                            f_cbRevocationBuffer,
                                            &dstrAttributeData,
                                            f_pAppCert,
                                            f_pRevListIDs->wmdrmapp,
                                            &fUpdatedRevocationList,
                                            NULL));
    if( fUpdatedRevocationList )
    {
        f_pRevListIDs->fUpdatedRevocationList = TRUE;
    }

ErrorExit:
    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        dr = DRM_E_REVOCATION_BUFFERTOOSMALL;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;

}

/*****************************************************************************
** Function: DRM_RVK_GetCurrentAppRevocationList
**
** Synopsis: open the secure store and get the version number of the
**           app revocation list currently stored
**
** Parameters:
**
** [f_pcontextSST]    -- secure store context
** [f_rgbPasswordSST] -- password used to retrieve secure store data
** [f_pbBuffer]       -- working buffer
** [f_pcbBuffer]      -- pointer to variable to receive app revocation list size
** [f_pcontextHDS]    -- initialized HDS context
** [f_pidCRLApp]      -- pointer to variable to receive app revocation list index
*****************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVK_GetCurrentAppRevocationList(
    IN      DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in_bcount( *f_pcbBuffer ) DRM_BYTE *f_pbBuffer,
    IN  OUT DRM_DWORD            *f_pcbBuffer,
    OUT     DRM_DWORD            *f_pidCRLApp)
{
    DRM_RESULT dr    = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_GetCurrentAppRevocationList );

    ChkArg (f_pContextRev     != NULL
        &&  f_pidCRLApp      != NULL
        &&  f_pcbBuffer      != NULL);

    dr = DRM_RVS_GetRevocationData( f_pContextRev,
                       &g_guidRevocationTypeApp,
                        f_pbBuffer,
                        f_pcbBuffer );

    if (DRM_SUCCEEDED(dr))
    {
        ChkBOOL( f_pbBuffer != NULL,                        DRM_E_LOGICERR);
        ChkBOOL(*f_pcbBuffer > SIZEOF(DRM_REVOCATION_LIST), DRM_E_BUFFERTOOSMALL);

        *f_pidCRLApp = ((DRM_REVOCATION_LIST *) f_pbBuffer)->idSerial;

        FIX_ENDIAN_DWORD(*f_pidCRLApp);
    }
    else if (dr == DRM_E_BUFFERTOOSMALL)
    {
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }
    else if (dr == DRM_E_FILENOTFOUND
          || dr == DRM_E_DSTSLOTNOTFOUND)
    {
        dr          = DRM_SUCCESS;
       *f_pidCRLApp = DRM_APP_REVOCATION_VERSION_NONE;
       *f_pcbBuffer = 0;
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/*****************************************************************************
** Function DRM_RVK_CheckAppCertForRevocation
**
** f_pbAppCRL -- DRM_REVOCATION_LIST passed in as byte buffer
** f_cbAppCRL -- size of the App CRL in bytes
** f_pappcert -- app certificate to check against what is in the store.
*****************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_RVK_CheckAppCertForRevocation(
    __in_bcount( f_cbAppCRL ) DRM_BYTE *f_pbAppCRL,
    DRM_DWORD             f_cbAppCRL,
    APPCERT              *f_pappcert)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg(f_pbAppCRL    != NULL
        && f_pappcert    != NULL
        && f_cbAppCRL     > 0);

    ChkDR(_CheckCertInRevocationList(CERTTYPE_V1APP,
                       (DRM_BYTE *) &f_pappcert->appcd.pk.pk,
                             SIZEOF (f_pappcert->appcd.pk.pk),
            (DRM_REVOCATION_LIST *)  f_pbAppCRL));

ErrorExit:
    return dr;
}

/*****************************************************************************
** Function: DRM_RVK_UpdateAppRevocationListA
**
** Synopsis: Expanded version of DRM_RVK_PerformAppRevocationCheck.  Allows an
**           app to query for app revocation without the lic eval context.
**
** Parameters:
**
** [pcontextCRYP]         -- Crypto buffer
** [f_pContextRev]        -- revocation store context
** [f_pbBuffer]           -- working buffer
** [f_cbBuffer]           -- size of f_pbBuffer in bytes
** [f_pdstrRevocationList]-- Revocation list string that will be updated in the store
** [f_pappcert]           -- app certificate to check against what is in the store.
** [f_idCRLAppCurrent]    -- version number/index of the currently stored App CRL
** [f_pfUpdatedAppRevocationList] -- optional pointer to a bool variable to be set TRUE
**                           if the stored App CRL was updated.  PC-side callers
**                           should update cached global App CRL
 ****************************************************************************/
/*
Note: this function only works for lgegacy wmdrm app certs and will only support
pre-playready types of crls and rev info.
*/

DRM_API DRM_RESULT DRM_CALL DRM_RVK_UpdateAppRevocationListA(
        DRM_CRYPTO_CONTEXT   *f_pcontextCRY,
        DRM_REVOCATIONSTORE_CONTEXT * f_pContextRev,
        __in_bcount( f_cbBuffer ) DRM_BYTE *f_pbBuffer,
        DRM_DWORD             f_cbBuffer,
        __in_ecount( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch ) DRM_CHAR *f_rgchBase,
  const DRM_SUBSTRING        *f_pdasstrRevocationList,
        APPCERT              *f_pappcert,
        DRM_DWORD             f_idCRLAppCurrent,
        DRM_BOOL             *f_pfUpdatedAppRevocationList)
{
    DRM_RESULT            dr              = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_UpdateAppRevocationListA );

    /* Note: f_pappcert is optional */
    ChkArg(f_pcontextCRY != NULL
        && f_pContextRev  != NULL
        && f_cbBuffer     > 0
        && f_rgchBase     != NULL
        && f_pdasstrRevocationList != NULL );


    if (f_pfUpdatedAppRevocationList != NULL)
    {
       *f_pfUpdatedAppRevocationList = FALSE;
    }


    /* If they don't pass us a buffer, it's a signal to just decode in place */
    if( f_pbBuffer == NULL )
    {

        /* pbOffset will point within the base64 revocation list we were passed,
           such that after base64 decoding the end of the decoded data will co-incide with
           the end of the buffer we were given, minus one byte.

           This is because we are giving the B64 decoder overlapping memory for source and desitination,
           and we can't use the DECODE_IN_PLACE flag because this is ANSI where the offset may not coincide
           with a word boundary as required on 16-bit platforms.
         */

        f_pbBuffer = (DRM_BYTE*)f_rgchBase
                            + __CB_DECL( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) - 1 )
                            + ( ( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) ) % CB_NATIVE_BYTE );

        f_cbBuffer = CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) + 1 - ( ( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) ) % CB_NATIVE_BYTE );

        ChkDR( DRM_B64_DecodeA( f_rgchBase,
                    f_pdasstrRevocationList,
                   &f_cbBuffer,
                    f_pbBuffer,
                    0 ) );

        /*
        ** If we're not aligned, we have slack space behind the pointer due to the base 64 decode
        */
        if( (DRM_DWORD_PTR)f_pbBuffer % SIZEOF( DRM_DWORD ) != 0 )
        {
            DRM_BYTE *pbAlign = NULL;

            pbAlign = f_pbBuffer - ((DRM_DWORD_PTR)f_pbBuffer % SIZEOF( DRM_DWORD ));

            /* Ensure that the slack space does exist */
            ChkBOOL( f_cbBuffer - CB_BASE64_DECODE( f_cbBuffer ) >= ((DRM_DWORD_PTR)f_pbBuffer % SIZEOF( DRM_DWORD )),
                    DRM_E_BUFFERTOOSMALL );

            MEMMOVE( pbAlign, f_pbBuffer, f_cbBuffer );
            f_pbBuffer = pbAlign;
        }
    }
    else
    {
        ChkDR( DRM_B64_DecodeA( f_rgchBase,
                    f_pdasstrRevocationList,
                   &f_cbBuffer,
                    f_pbBuffer,
                    0 ) );
    }

    ChkDR( DRM_RVK_UpdateAppRevocationListDecoded( f_pcontextCRY,
                f_pContextRev,
                f_pbBuffer,
                f_cbBuffer,
                f_pappcert,
                f_idCRLAppCurrent,
                f_pfUpdatedAppRevocationList,
                NULL ) );


ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVK_UpdateAppRevocationListW(
    DRM_CRYPTO_CONTEXT   *f_pcontextCRY,
    DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in_bcount( f_cbBuffer ) DRM_BYTE *f_pbBuffer,
    DRM_DWORD             f_cbBuffer,
    DRM_CONST_STRING     *f_pdstrRevocationList,
    APPCERT              *f_pappcert,
    DRM_DWORD             f_idCRLAppCurrent,
    DRM_BOOL             *f_pfUpdatedAppRevocationList,
    OUT DRM_DWORD        *f_pdwVersion)
{
    DRM_RESULT            dr              = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_UpdateAppRevocationListW );

    /* Note: f_pappcert is optional */
    ChkArg(f_pcontextCRY             != NULL
        && f_pContextRev             != NULL
        && f_cbBuffer                > 0
        && f_pdstrRevocationList     != NULL );


    if (f_pfUpdatedAppRevocationList != NULL)
    {
       *f_pfUpdatedAppRevocationList = FALSE;
    }
    if (f_pdwVersion != NULL)
    {
        *f_pdwVersion = 0;
    }

    if( f_pbBuffer == NULL )
    {
        /* If they don't pass us a buffer, it's a signal to just decode in place */

        ChkDR( DRM_B64_DecodeW(f_pdstrRevocationList,
                               &f_cbBuffer,
                               NULL,
                               DRM_BASE64_DECODE_IN_PLACE ) );

        f_pbBuffer = (DRM_BYTE*)f_pdstrRevocationList->pwszString;
    }
    else
    {
        ChkDR( DRM_B64_DecodeW(f_pdstrRevocationList,
                               &f_cbBuffer,
                               f_pbBuffer,
                               0 ) );
    }

    ChkDR( DRM_RVK_UpdateAppRevocationListDecoded( f_pcontextCRY,
                                                   f_pContextRev,
                                                   f_pbBuffer,
                                                   f_cbBuffer,
                                                   f_pappcert,
                                                   f_idCRLAppCurrent,
                                                   f_pfUpdatedAppRevocationList,
                                                   f_pdwVersion) );


ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

DRM_RESULT DRM_NO_INLINE DRM_CALL DRM_RVK_UpdateAppRevocationListDecoded(
    DRM_CRYPTO_CONTEXT   *f_pcontextCRY,
    DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in_bcount( f_cbRevocationList ) DRM_BYTE *f_pbRevocationList,
    DRM_DWORD             f_cbRevocationList,
    APPCERT              *f_pappcert,
    DRM_DWORD             f_idCRLAppCurrent,
    DRM_BOOL             *f_pfUpdatedAppRevocationList,
    OUT DRM_DWORD        *f_pdwVersion)
{
    DRM_RESULT            dr              = DRM_SUCCESS;
    DRM_DWORD             idCRLAppNew     = 0;
    DRM_REVOCATION_LIST  *prevocationlist = NULL;
    DRM_DWORD             cbSigned         = 0;
    DRM_DWORD             dwVersion        = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_UpdateAppRevocationListDecoded );

    /* Note: f_pappcert is optional */
    ChkArg(f_pcontextCRY != NULL
        && f_pContextRev != NULL
        && f_pbRevocationList     != NULL
        && f_cbRevocationList > 0 );

    DRMASSERT( (DRM_DWORD_PTR)f_pbRevocationList % SIZEOF( DRM_DWORD ) == 0 );

    if (f_pfUpdatedAppRevocationList != NULL)
    {
       *f_pfUpdatedAppRevocationList = FALSE;
    }
    if (f_pdwVersion != NULL)
    {
        *f_pdwVersion = 0;
    }

    prevocationlist = (DRM_REVOCATION_LIST *)  f_pbRevocationList;
    dwVersion       = prevocationlist->dwVersion;

    FIX_ENDIAN_DWORD( dwVersion );

    if (dwVersion != CURRENT_REVOCATION_VERSION)
    {
        ChkDR( DRM_E_INVALID_REVOCATION_LIST );
    }

    idCRLAppNew = prevocationlist->idSerial;
    FIX_ENDIAN_DWORD( idCRLAppNew );

    if (f_idCRLAppCurrent == DRM_APP_REVOCATION_VERSION_NONE
    ||  f_idCRLAppCurrent  < idCRLAppNew)
    {
        /* Verify & store the new list. */

        cbSigned = prevocationlist->cb;
        FIX_ENDIAN_DWORD(cbSigned);

        cbSigned += ( 3 * SIZEOF( DRM_DWORD ) );

        if ( DRM_SUCCEEDED( DRM_PK_Verify( f_pcontextCRY,
                                           eDRM_ECC_P160,
                                           DRM_ECC160_PUBLIC_KEY_LEN,
                                           ( const DRM_BYTE * )&g_pubkeyRevocation,
                                           cbSigned,
                                           ( const DRM_BYTE * )&prevocationlist->dwVersion,
                                           DRM_ECC160_SIGNATURE_LEN,
                                           prevocationlist->rgbSignature ) ) )
        {
            /* The new list is verified.  Store it. */

            ChkDR( DRM_RVS_StoreRevocationData( f_pContextRev,
                                                &g_guidRevocationTypeApp,
                                                f_pbRevocationList,
                                                f_cbRevocationList ) );

            if (f_pfUpdatedAppRevocationList != NULL)
            {
                *f_pfUpdatedAppRevocationList = TRUE;
            }
            if (f_pdwVersion)
            {
                *f_pdwVersion = idCRLAppNew;
            }
        }

        if( f_pappcert != NULL )
        {
            ChkDR(_CheckCertInRevocationList(CERTTYPE_V1APP,
                                             (DRM_BYTE *) &f_pappcert->appcd.pk.pk,
                                             SIZEOF (f_pappcert->appcd.pk.pk),
                                             prevocationlist));
        }
    }
    else
    {
        /* CRL did not get updated, so set it to the old version. */
        if (f_pdwVersion)
        {
            *f_pdwVersion = f_idCRLAppCurrent;
        }
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;

}
#endif

static DRM_NO_INLINE DRM_RESULT _GetPlayReadyRevocationList(
    __in                                     DRM_CRYPTO_CONTEXT          *f_pcontextCRYP, 
    __in                                     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in                               const DRM_GUID                    *f_pguidRevocationType,
    __out_bcount_opt( *f_pcbRevocationData ) DRM_BYTE                    *f_pbRevocationData,
    __inout                                  DRM_DWORD                   *f_pcbRevocationData,
    __out                                    DRM_DWORD                   *f_pdwVersion)
{
    DRM_RESULT       dr          = DRM_SUCCESS;
    DRM_BYTE        *pbAligned   = NULL;
    DRM_DWORD        cbAligned   = 0;
    DRM_BCRL_Signed  oBCRLSigned = { 0 };
    _RevocationStoreContext *pRevStore = (_RevocationStoreContext*)f_pContextRev;

    ChkArg( f_pcontextCRYP      != NULL
         && f_pContextRev       != NULL
         && f_pcbRevocationData != NULL
         && f_pdwVersion        != NULL );

    *f_pdwVersion = 0;

    /*
        The call to DRM_UTL_EnsureDataAlignment
        re-adjust alightment of buffer and may place revocation
        information with offset to f_pcbRevocationData
        The calling code would need to detect the same condition.
        It would be more reasonable to request the f_pcbRevocationData
        to be already aligned buffer
        and return error if buffer is not aligned.
        Currently we use the same logic as appears througth the code.
    */

    if (f_pbRevocationData != NULL)
    {
        ChkDR( DRM_UTL_EnsureDataAlignment(
            f_pbRevocationData,
            *f_pcbRevocationData,
            &pbAligned,
            &cbAligned,
            SIZEOF (DRM_WCHAR),
            NULL ) );

        DRMASSERT(pbAligned != NULL);
    }

    dr = DRM_RVS_GetRevocationData(
        f_pContextRev,
        f_pguidRevocationType,
        pbAligned,
        &cbAligned );

    if ( DRM_FAILED( dr ) )
    {
        if ( DRM_E_DSTSLOTNOTFOUND == dr )
        {
            cbAligned = 0;
            dr = DRM_SUCCESS;
        }
        goto ErrorExit;
    }

    ChkDR( DRM_BCrl_ParseCrl(
        pbAligned,
        cbAligned,
        &oBCRLSigned,
        (const PUBKEY_P256 *) &g_rgbMSPlayReadyRootIssuerPubKey,
        f_pcontextCRYP, pRevStore->pContextBB, pRevStore->pContextSST, pRevStore->pDatastore ) );

    *f_pdwVersion = oBCRLSigned.Crl.dwVersion;

ErrorExit:
    if( f_pcbRevocationData != NULL )
    {
        *f_pcbRevocationData = cbAligned;
    }
    return dr;
}


/******************************************************************************
**
** Function :   DRM_RVK_UpdateRevocationVersionsCache
**
** Synopsis :   Loads the revinfo and CRL versions from the secure store
**              and caches them in the DRM_APP_CONTEXT for use when
**              evaluting licenses with revocation requirements
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVK_UpdateRevocationVersionsCache( 
 IN OUT DRM_REVOCATIONSTORE_CONTEXT  *f_pContextRev,
 IN     DRM_CRYPTO_CONTEXT           *f_pContextCrypto,
 IN OUT DRM_REVLIST_ID_VALUES        *f_pRevListIDs,
 IN     DRM_BYTE                     *f_pbRevocationBuffer,
 IN     DRM_DWORD                     f_cbRevocationBuffer,
    OUT DRM_BOOL                     *f_pfUpdated)
{
    DRM_RESULT       dr             = DRM_SUCCESS;
    DRM_DWORD        cbBuffer       = 0;
    DRM_RLVI         RLVI           = {0};
    DRM_RLVI         RLVI2          = {0};
    DRM_DWORD        dwVersion      = 0;
    DRM_BOOL         fUpdated       = FALSE;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_UpdateRevocationVersionsCache );

    ChkArg( f_pContextRev != NULL
        &&  f_pRevListIDs != NULL
        &&  f_pbRevocationBuffer != NULL);

    cbBuffer = f_cbRevocationBuffer;

    /* Update the revocation info version V1 */
    ChkDR( DRM_RVK_GetCurrentRevocationInfo( f_pContextRev,
                                             &g_guidRevocationTypeRevInfo,
                                             f_pbRevocationBuffer,
                                             &cbBuffer,
                                             &RLVI,
                                             f_pContextCrypto ) );

    if( f_pRevListIDs->riv != RLVI.head.dwRIV )
    {
        fUpdated = TRUE;
        f_pRevListIDs->riv = RLVI.head.dwRIV;
    }

    /* Update the revocation info version V2 */
    cbBuffer = f_cbRevocationBuffer;
    ChkDR( DRM_RVK_GetCurrentRevocationInfo( f_pContextRev,
                                             &g_guidRevocationTypeRevInfo2,
                                             f_pbRevocationBuffer,
                                             &cbBuffer,
                                             &RLVI2,
                                             f_pContextCrypto ) );

    if( f_pRevListIDs->riv2 != RLVI2.head.dwRIV )
    {
        fUpdated = TRUE;
        f_pRevListIDs->riv2 = RLVI2.head.dwRIV;
    }

#if DRM_SUPPORT_DEVICE_REVOCATION
    /* Update the WMDRM device CRL version */
    dwVersion = 0;
    cbBuffer = f_cbRevocationBuffer;
    ChkDR( DRM_RVK_GetDeviceRevocationList( f_pContextCrypto,
                                            f_pContextRev,
                                            f_pbRevocationBuffer,
                                            &cbBuffer,
                                            &dwVersion) );


    if( f_pRevListIDs->device != dwVersion )
    {
        fUpdated = TRUE;
        f_pRevListIDs->device = dwVersion;
    }
#endif

#if DRM_SUPPORT_APP_REVOCATION
    /* Get the playready app crl */
    dwVersion = 0;
    cbBuffer = f_cbRevocationBuffer;
    ChkDR(_GetPlayReadyRevocationList( f_pContextCrypto,
                                       f_pContextRev,
                                       &g_guidRevocationTypePlayReadySilverLightApplication,
                                       f_pbRevocationBuffer,
                                       &cbBuffer,
                                       &dwVersion ) );
    if (f_pRevListIDs->playreadyapp != dwVersion)
    {
        fUpdated = TRUE;
        f_pRevListIDs->playreadyapp = dwVersion;
    }

    /* Get the wmdrm app crl */
    dwVersion = 0;
    cbBuffer = f_cbRevocationBuffer;
    ChkDR( DRM_RVK_GetCurrentAppRevocationList( f_pContextRev,
                                                f_pbRevocationBuffer,
                                                &cbBuffer,
                                                &dwVersion ) );

    if (f_pRevListIDs->wmdrmapp != dwVersion)
    {
        fUpdated = TRUE;
        f_pRevListIDs->wmdrmapp = dwVersion;
    }

#endif

    dwVersion = 0;
    cbBuffer = f_cbRevocationBuffer;
    ChkDR(_GetPlayReadyRevocationList( f_pContextCrypto,
                                       f_pContextRev,
                                       &g_guidRevocationTypePlayReadySilverLightRuntime,
                                       f_pbRevocationBuffer,
                                       &cbBuffer,
                                       &dwVersion ) );

    if (f_pRevListIDs->runtime != dwVersion)
    {
        fUpdated = TRUE;
        f_pRevListIDs->runtime = dwVersion;
    }

#if DRM_SUPPORT_WMDRMNET
    dwVersion = 0;
    cbBuffer = f_cbRevocationBuffer;
    /* Update the WMDRMNET CRL version */
    ChkDR( DRM_RVK_GetWMDRMNETList( f_pContextCrypto,
                                    f_pContextRev,
                                    f_pbRevocationBuffer,
                                    &cbBuffer,
                                    &dwVersion) );


    if( f_pRevListIDs->wmdrmnet != dwVersion )
    {
        fUpdated = TRUE;
        f_pRevListIDs->wmdrmnet = dwVersion;
    }
#endif

ErrorExit:

    if ( fUpdated && ( f_pRevListIDs != NULL ) )
    {
        f_pRevListIDs->fUpdatedRevocationList = TRUE;
    }

    if( f_pfUpdated != NULL )
    {
        *f_pfUpdated = fUpdated;
    }

    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        dr = DRM_E_REVOCATION_BUFFERTOOSMALL;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/*****************************************************************************
** Function: _ExtractRevocationListA
**
** Synopsis: calls app revocation operation
**
** [f_pdstrLicenseXML]      -- entire license response XML
** [f_pbBuffer]             -- buffer
** [f_pcbBuffer]            -- pointer to buffer size
** [f_pdstrRevocationType]  -- the revocation attribute type
** [f_pdstrAttributeData]   -- on success contains the substring for the given
**                             revocation type
*****************************************************************************/
static DRM_RESULT _ExtractRevocationList(
    IN       DRM_ANSI_CONST_STRING *f_pdastrLicenseResponse,
    IN const DRM_ANSI_CONST_STRING *f_pdastrRevocationType,
    OUT      DRM_SUBSTRING         *f_pdasstrAttributeData)
{
    DRM_RESULT    dr                    = DRM_SUCCESS;
    DRM_SUBSTRING dasstrLicenseResponse = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrList            = EMPTY_DRM_SUBSTRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC__ExtractRevocationList );

    ChkArg(f_pdastrLicenseResponse     != NULL
        && f_pdastrRevocationType       != NULL
        && f_pdasstrAttributeData       != NULL);

    /* get the uppermost license list */

    dasstrLicenseResponse.m_ich = 0;
    dasstrLicenseResponse.m_cch = f_pdastrLicenseResponse->cchString;

    ChkDR( DRM_XML_GetNodeA( f_pdastrLicenseResponse->pszString,
                             &dasstrLicenseResponse,
                             &g_adstrLicenseRespTag,
                             NULL,
                             NULL,
                             0,
                             NULL,
                             &dasstrList ) );

    /* get the node for this revocation type */

    ChkDR( DRM_XML_GetNodeA( f_pdastrLicenseResponse->pszString,
                             &dasstrList,
                             &g_dastrTagRevocation,
                             &g_dastrAttributeType,
                             f_pdastrRevocationType,
                             0,
                             NULL,
                             f_pdasstrAttributeData ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


#if DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_WMDRMNET

/*****************************************************************************
** Function: IsWrappedCRL
**
** Synopsis: Checks if the CRL is wrapped with <DATA> tag or not. Used to find
**           out if the WMDRMNET CRL is with wrappers.
**
** [f_pdstrRevocationList]  -- Revocation list
*****************************************************************************/
static DRM_NO_INLINE DRM_BOOL IsWrappedCRL(
    IN DRM_CONST_STRING *f_pdstrRevocationList )
{
    DRM_RESULT       dr       = DRM_SUCCESS;
    DRM_CONST_STRING dstrData = EMPTY_DRM_STRING;

    /*Check if the revocation list contains <DATA> tag */
    dr = DRM_XML_GetNode( f_pdstrRevocationList,
                          &g_dstrTagData,
                          NULL,
                          NULL,
                          0,
                          NULL,
                          &dstrData );
    if ( dr == DRM_E_XMLNOTFOUND )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

/******************************************************************************
**
** Function :   DRM_RVK_VerifyRevocationList
**
** Synopsis :   Verify signature on the revocation list
**
** Arguments :  f_pcontextCRYP  - Crypto context
**              f_pdstrList     - Revocation list
**              f_ppubkey       - Public key for verifying signature on
**                                revocation list
**              f_pidSerial     - Serial number on revocation list
**
** Returns :
**
** Notes :
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVK_VerifyRevocationList(
    IN          DRM_CRYPTO_CONTEXT *f_pcontextCRYP, 
    IN          DRM_CONST_STRING   *f_pdstrList,
    IN  const   PUBKEY             *f_ppubkey,
        OUT     DRM_DWORD          *f_pidSerial)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrListData      = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrListSignature = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrNodeHashAlg   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrNodeSignAlg   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataHashAlg   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataSignature = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataSignAlg   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataIndex     = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_VerifyRevocationList );

    /* verify the signature attributes and get the value */

    ChkDR(DRM_XML_GetNode(f_pdstrList,        &g_dstrTagSignature, NULL, NULL, 0,  NULL,            &dstrListSignature));
    ChkDR(DRM_XML_GetNode(&dstrListSignature, &g_dstrTagHashAlg,   NULL, NULL, 0, &dstrNodeHashAlg,  NULL));
    ChkDR(DRM_XML_GetNode(&dstrListSignature, &g_dstrTagSignAlg,   NULL, NULL, 0, &dstrNodeSignAlg,  NULL));
    ChkDR(DRM_XML_GetNode(&dstrListSignature, &g_dstrTagValue,     NULL, NULL, 0,  NULL,            &dstrDataSignature));

    ChkDR(DRM_XML_GetNodeAttribute(&dstrNodeHashAlg, &g_dstrAttributeType, &dstrDataHashAlg));
    ChkDR(DRM_XML_GetNodeAttribute(&dstrNodeSignAlg, &g_dstrAttributeType, &dstrDataSignAlg));

    ChkFAIL(DRM_UTL_DSTRStringsEqual(&dstrDataHashAlg, &g_dstrSHA));
    ChkFAIL(DRM_UTL_DSTRStringsEqual(&dstrDataSignAlg, &g_dstrMSDRM));

    /* verify the signature against the <DATA> section */

    ChkDR( DRM_XML_GetAndVerifyNode( f_pdstrList,
                                     &g_dstrTagData,
                                     NULL,
                                     NULL,
                                     0,
                                     f_pcontextCRYP,
                                     f_ppubkey,
                                     TRUE,
                                     &dstrDataSignature,
                                     NULL,
                                     &dstrListData ) );

    /* verification successful; get the index (version) of this list */

    ChkDR( DRM_XML_GetNode( &dstrListData,            /*    <INDEX> */
                            &g_dstrTagIndex,
                            NULL,
                            NULL,
                            0,
                            NULL,
                            &dstrDataIndex ) );

    ChkDR( DRMCRT_wcsntol( dstrDataIndex.pwszString,
                    dstrDataIndex.cchString,
                    (DRM_LONG *) f_pidSerial ) );
#if DRM_SUPPORT_WMDRMNET
    if( MEMCMP( f_ppubkey, &g_pubkeyWMDRMNDRevocation, SIZEOF( *f_ppubkey ) ) == 0 )
    {
        DRM_CONST_STRING dstrTemplate = EMPTY_DRM_STRING;

        ChkDR( DRM_XML_GetSubNode(  f_pdstrList,
                                   &g_dstrTemplate,
                                    NULL,
                                    NULL,
                                    0,
                                    NULL,
                                   &dstrTemplate,
                                    1 ) );

        /*
        ** If this is a WMDRMNET revocation list use the OEM function to
        ** validate the internal representation of the list
        */

        ChkDR(_VerifyWMDRMNETRevocationList(&dstrTemplate,
                                          f_pidSerial,
                                          f_pcontextCRYP));

    }
#endif

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/******************************************************************************
**
** Function :   _GetSSTRevocationList
**
** Synopsis :   Get and verify revocation list from Secure store
**
** Arguments :
**
** Returns :
**
** Notes :
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _GetSSTRevocationList(
    IN  const   DRM_GUID             *f_pGUID,
    IN          DRM_CRYPTO_CONTEXT   *f_pcontextCRYP,
    IN          DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN  const   PUBKEY               *f_ppubkey,
        OUT     DRM_BYTE             *f_pbBuffer,
    IN  OUT     DRM_DWORD            *f_pcbBuffer,
        OUT     DRM_DWORD            *f_pidSerial)
{
    DRM_RESULT dr            = DRM_SUCCESS;
    DRM_BYTE  *pbAligned     = NULL;
    DRM_DWORD  cbAligned     = 0;
    DRM_CONST_STRING dstrXML = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC__GetSSTRevocationList );

    ChkArg(f_pGUID         != NULL
       &&  f_pcontextCRYP != NULL
       &&  f_pContextRev  != NULL
       &&  f_ppubkey      != NULL
       &&  f_pcbBuffer    != NULL);

    *f_pidSerial = DRM_NO_PREVIOUS_CRL;

    /* get the current SST image */

    if (f_pbBuffer != NULL)
    {
        ChkDR( DRM_UTL_EnsureDataAlignment( f_pbBuffer,
                                            *f_pcbBuffer,
                                            &pbAligned,
                                            &cbAligned,
                                            SIZEOF (DRM_WCHAR),
                                            NULL ) );
    }

    dr = DRM_RVS_GetRevocationData( f_pContextRev,
                          f_pGUID,
                          pbAligned,
                          &cbAligned );

    *f_pcbBuffer = cbAligned;

    /* includes the DRM_E_BUFFERTOOSMALL case */

    ChkDR(dr);

    DSTR_FROM_PB( &dstrXML, pbAligned, cbAligned );

    /* verify the signature and extract the index of this exclusion list */
    if ( IsWrappedCRL( &dstrXML ) )
    {
        ChkDR( DRM_RVK_VerifyRevocationList( f_pcontextCRYP,
                                      &dstrXML,
                                      f_ppubkey,
                                      f_pidSerial ) );
    }
    else
    {
#if DRM_SUPPORT_WMDRMNET
        ChkDR( _VerifyBinaryWMDRMNETSignature( pbAligned,
                                              cbAligned,
                                              f_pidSerial,
                                              f_pcontextCRYP) );
#else
        ChkDR( DRM_E_NOTIMPL );
#endif
    }


ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#endif /* #if DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_WMDRMNET */


static DRM_NO_INLINE DRM_RESULT _SetPlayReadyRevocationList(
    __in                              DRM_CRYPTO_CONTEXT          *f_pcontextCrypto,
    __in                              DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in                        const DRM_GUID                    *f_pguidRevocationType,
    __in_bcount(f_cbRevocationList)   DRM_BYTE                    *f_pbRevocationList,
    __in                              DRM_DWORD                    f_cbRevocationList,
    __in_bcount(f_cbRevocationBuffer) DRM_BYTE                    *f_pbRevocationBuffer,
    __in                              DRM_DWORD                    f_cbRevocationBuffer,
    __out_opt                         DRM_BOOL                    *f_pfUpdated,
    __out_opt                         DRM_DWORD                   *f_pdwVersion)
{
    DRM_RESULT      dr              = DRM_SUCCESS;
    DRM_BCRL_Signed oBCRLSigned     = { 0 };
    DRM_DWORD       dwVersionOld    = 0;
    DRM_DWORD       dwCRLBufferSize = f_cbRevocationBuffer;
    _RevocationStoreContext *pRevStore = (_RevocationStoreContext*)f_pContextRev;

    ChkArg(   f_pcontextCrypto     != NULL
           && f_pContextRev        != NULL
           && f_pbRevocationList   != NULL
           && f_pbRevocationBuffer != NULL
           && f_cbRevocationBuffer  > 0
           && f_cbRevocationList    > 0 );

    if( f_pfUpdated != NULL )
    {
        *f_pfUpdated = FALSE;
    }
    if (f_pdwVersion != NULL)
    {
        *f_pdwVersion = 0;
    }

    ChkDR( DRM_BCrl_ParseCrl(
        f_pbRevocationList,
        f_cbRevocationList,
        &oBCRLSigned,
        (const PUBKEY_P256*)g_rgbMSPlayReadyRootIssuerPubKey,
        f_pcontextCrypto, pRevStore->pContextBB, pRevStore->pContextSST, pRevStore->pDatastore));

    dr = _GetPlayReadyRevocationList(f_pcontextCrypto,
                                            f_pContextRev,
                                            f_pguidRevocationType,
                                            f_pbRevocationBuffer,
                                            &dwCRLBufferSize,
                                            &dwVersionOld);
    if ( dr == DRM_E_DSTSLOTNOTFOUND
        || ( ( dwVersionOld < oBCRLSigned.Crl.dwVersion ) && DRM_SUCCEEDED( dr ) ) )
    {
        /* Store the list as a wrapped CRL */
        ChkDR( DRM_RVS_StoreRevocationData( f_pContextRev,
                               f_pguidRevocationType,
                               f_pbRevocationList,
                               f_cbRevocationList ) );
        if( f_pfUpdated != NULL )
        {
            *f_pfUpdated = TRUE;
        }
        if (f_pdwVersion != NULL)
        {
            *f_pdwVersion = oBCRLSigned.Crl.dwVersion;
        }
    }
    else
    {
        ChkDR( dr );

        /* CRL did not get updated, so set it to the old version. */
        if (f_pdwVersion)
        {
            *f_pdwVersion = dwVersionOld;
        }

    }



ErrorExit:
    return dr;

}

#if DRM_SUPPORT_DEVICE_REVOCATION

/******************************************************************************
**
** Function :   _UpdateRevocationList
**
** Synopsis :   updates the revocation list in the secure store
**
** Arguments :
** [f_pcontextCrypto]      --
** [f_pcontextRev]         -- revocation store context
** [f_pbRevocationList]    -- input buffer for exclusion list
** [f_cbRevocationList]    -- buffer size
** [f_pdstrRevocationList] -- the new DCRL
** [f_pGUID]               -- DRM_GUID used to store this list
** [f_pfUpdated]           -- Optional flag indicates whether the CRL was
**                            updated in the HDS or not.
** Returns :
**
** Notes :
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _UpdateRevocationList(
    IN          DRM_CRYPTO_CONTEXT   *f_pcontextCrypto,
    IN          DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN          DRM_BYTE             *f_pbRevocationList,
    IN          DRM_DWORD             f_cbRevocationList,
    IN          DRM_BYTE             *f_pbRevocationBuffer,
    IN          DRM_DWORD             f_cbRevocationBuffer,
    IN  const   DRM_GUID             *f_pGUID,
    IN  const   PUBKEY               *f_ppubkey,
    OUT         DRM_BOOL             *f_pfUpdated)
{
    DRM_RESULT dr          = DRM_SUCCESS;
    DRM_DWORD  idSerialNew = 0,
               idSerialOld = 0,
               cbReturned  = 0;
    DRM_STRING dstrRevocationList = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC__UpdateRevocationList );

    ChkArg(   f_pcontextCrypto     != NULL
           && f_pContextRev        != NULL
           && f_pGUID              != NULL
           && f_pbRevocationList   != NULL
           && f_pbRevocationBuffer != NULL
           && f_cbRevocationBuffer  > 0
           && f_cbRevocationList    > 0 );

    if( f_pfUpdated != NULL )
    {
        *f_pfUpdated = FALSE;
    }

    DSTR_FROM_PB( &dstrRevocationList, f_pbRevocationList, f_cbRevocationList );

    idSerialNew = DRM_NO_PREVIOUS_CRL;
    idSerialOld = DRM_NO_PREVIOUS_CRL;


    ChkDR( DRM_RVK_VerifyRevocationList( f_pcontextCrypto,
                                         (DRM_CONST_STRING*)&dstrRevocationList,
                                         f_ppubkey,
                                         &idSerialNew ) );

    cbReturned = f_cbRevocationBuffer;
    /* get and verify the current SST image
     */
    dr = _GetSSTRevocationList( f_pGUID,
                                f_pcontextCrypto,
                                f_pContextRev,
                                f_ppubkey,
                                f_pbRevocationBuffer,
                                &cbReturned,
                                &idSerialOld );


    /* This can be the first Revocation list */

    if ( dr == DRM_E_DSTSLOTNOTFOUND
        || ( ( idSerialOld == DRM_NO_PREVIOUS_CRL ) && DRM_SUCCEEDED( dr ) )
        || ( ( idSerialOld < idSerialNew ) && DRM_SUCCEEDED( dr ) ) )
    {
        /* Store the list as a wrapped CRL */
        ChkDR( DRM_RVS_StoreRevocationData( f_pContextRev,
                                            f_pGUID,
                                            f_pbRevocationList,
                                            f_cbRevocationList ) );
        if( f_pfUpdated != NULL )
        {
            *f_pfUpdated = TRUE;
        }
    }
    else
    {
        ChkDR( dr );
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/******************************************************************************
**
** Function :   DRM_RVK_UpdateRevocationList
**
** Synopsis :   updates the revocation list in the secure store
**
** Arguments :
** [f_pcontextCrypto]      --
** [f_pcontextRev]         -- Revocation store context
** [f_pbRevocationList]    -- input buffer for exclusion list
** [f_cbRevocationList]    -- buffer size
** [f_pdstrRevocationList] -- the new DCRL
** [f_pGUID]               -- DRM_GUID of the CRL type

** Returns :
**
** Notes :
**
******************************************************************************/
DRM_RESULT DRM_RVK_UpdateRevocationList(
    IN          DRM_CRYPTO_CONTEXT   *f_pcontextCrypto,
    IN          DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in_ecount( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch ) DRM_CHAR *f_rgchBase,
    IN  const   DRM_SUBSTRING        *f_pdasstrRevocationList,
    __in_bcount( f_cbRevocationBuffer ) DRM_BYTE *f_pbRevocationBuffer,
    IN          DRM_DWORD             f_cbRevocationBuffer,
    IN  const   DRM_GUID             *f_pGUID,
    IN  const   PUBKEY               *f_ppubkey )
{
    DRM_RESULT       dr             = DRM_SUCCESS;
    DRM_DWORD        cbDecoded      = 0;
    DRM_BYTE        *pbDecoded      = NULL;
    DRM_DWORD        cbAligned      = 0;
    DRM_BYTE        *pbAligned      = NULL;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_UpdateRevocationList );

    ChkArg(   f_pcontextCrypto  != NULL
           && f_pContextRev      != NULL
           && f_pGUID               != NULL
           && f_rgchBase            != NULL
           && f_pbRevocationBuffer != NULL
           && f_cbRevocationBuffer > 0
           && f_pdasstrRevocationList != NULL
           && f_pdasstrRevocationList->m_cch > 0 );

    /* pbOffset will point within the base64 revocation list we were passed,
       such that after base64 decoding the end of the decoded data will co-incide with
       the end of the buffer we were given, minus one byte.

       This is because we are giving the B64 decoder overlapping memory for source and desitination,
       and we can't use the DECODE_IN_PLACE flag because this is ANSI where the offset may not coincide
       with a word boundary as required on 16-bit platforms.
     */
    pbDecoded = (DRM_BYTE*)f_rgchBase
                        + __CB_DECL( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) - 1 )
                        + ( ( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) ) % CB_NATIVE_BYTE );

    cbDecoded = CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) + 1 - ( ( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) ) % CB_NATIVE_BYTE );

    /* Ensure the pointer is DRM_WCHAR aligned */
    ChkDR( DRM_UTL_EnsureDataAlignment( pbDecoded, cbDecoded, &pbAligned, &cbAligned, SIZEOF( DRM_WCHAR ), NULL ) );
    ChkBOOL( cbAligned >= CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ), DRM_E_BUFFERTOOSMALL );

    /* decode the XML for the new exclusion list */
    ChkDR( DRM_B64_DecodeA( f_rgchBase,
                            f_pdasstrRevocationList,
                            &cbAligned,
                            pbAligned,
                            0 ) );

    ChkDR( _UpdateRevocationList( f_pcontextCrypto,
                                  f_pContextRev,
                                  pbAligned,
                                  cbAligned,
                                  f_pbRevocationBuffer,
                                  f_cbRevocationBuffer,
                                  f_pGUID,
                                  f_ppubkey,
                                  NULL) );


ErrorExit:
    if( ( f_rgchBase != NULL )
        && ( f_pdasstrRevocationList != NULL )
        && ( f_pdasstrRevocationList->m_cch != 0 ) )
    {
        /* Since we decoded in-place, we need to clean up otherwise the XML parsing may
         * not work properly later on. So we have to overwrite our binary with spaces.
         *
         * NOTE: This means that we CANNOT process the same revocation list in the same
         * license response buffer twice since we're overwriting the buffer we were given
         */
        DRM_BYT_SetBytes( f_rgchBase, f_pdasstrRevocationList->m_ich, f_pdasstrRevocationList->m_cch, ' ');
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}



/*****************************************************************************
** Function: _UpdateDeviceRevocationList
**
** Synopsis: updates the device exclusion list in the secure store
**
** Arguments:
** [f_pcontextCRYP]        -- just a buffer
** [f_pContextRev]         -- revocation store context
** [f_pbBuffer]            -- input buffer for exclusion list
** [f_cbBuffer]            -- buffer size
** [f_pdstrDeviceRevocationList] -- the new DCRL
*****************************************************************************/
static DRM_RESULT _UpdateDeviceRevocationList(
    IN DRM_CRYPTO_CONTEXT   *f_pcontextCRYP,
    IN DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN DRM_CHAR             *f_rgchBase,
    IN DRM_SUBSTRING        *f_pdasstrRevocationList,
    IN DRM_BYTE             *f_pbRevocationBuffer,
    IN DRM_DWORD             f_cbRevocationBuffer )
{
    return DRM_RVK_UpdateRevocationList( f_pcontextCRYP,
                                  f_pContextRev,
                                  f_rgchBase,
                                  f_pdasstrRevocationList,
                                  f_pbRevocationBuffer,
                                  f_cbRevocationBuffer,
                                  &g_guidRevocationTypeDevice,
                                  &g_pubkeyDeviceRevocation );
}

/*****************************************************************************
** Function: DRM_RVK_GetDeviceRevocationList
**
** Synopsis: gets the current device exclusion list from the secure store
**
** Arguments:
** [f_pcontextCRYP]      -- just a buffer
** [f_pContextRev]       -- revocation store context
** [f_pbBuffer]          -- output buffer for exclusion list; NULL to request
**                          required size
** [f_pcbBuffer]         -- DRM_DWORD to hold max buffer size on in, bytes actually
**                          used on out
** [f_pidSerial]         -- receives numerical representation of <INDEX> tag
*****************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVK_GetDeviceRevocationList(
    IN     DRM_CRYPTO_CONTEXT   *f_pcontextCRYP, 
    IN     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __out_bcount_opt( *f_pcbRevocationData ) DRM_BYTE *f_pbRevocationData,
    IN OUT DRM_DWORD            *f_pcbRevocationData,
    OUT    DRM_DWORD            *f_pidSerial)
{
    DRM_RESULT  dr = DRM_SUCCESS;
    ChkArg(   f_pcontextCRYP        != NULL
           && f_pContextRev         != NULL
           && f_pcbRevocationData   != NULL
           && f_pidSerial           != NULL );

    dr = _GetSSTRevocationList( &g_guidRevocationTypeDevice,
                                  f_pcontextCRYP,
                                  f_pContextRev,
                                  &g_pubkeyDeviceRevocation,
                                  f_pbRevocationData,
                                  f_pcbRevocationData,
                                  f_pidSerial );
    if ( dr == DRM_E_FILENOTFOUND
      || dr == DRM_E_DSTSLOTNOTFOUND )
    {
        dr                   = DRM_SUCCESS;
        *f_pidSerial         = 0;
        *f_pcbRevocationData = 0;
        goto ErrorExit;
    }
    ChkDR(dr);

ErrorExit:
    return dr;
}

/*****************************************************************************
** Function: DRM_RVK_CheckDeviceRevocation
**
** Synopsis: compare a devcert to an exclusion entry and seek a match result
**
** Arguments:
** [f_pdstrDevCert]      -- a DEVICE_CERT struct pointing to the devcert XML
** [f_pdstrXMLExclusion] -- a DSTR pointing to an exclusion list entry with the
** [f_pfExcluded]        -- pointer to a boolean variable to hold the match
**                          result
** Returns: - DRM_SUCCESS regardless of match
**          - error code on XML or numerical translation failure
**
** Notes:
**
*****************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_RVK_CheckDeviceRevocation(
    __in  const DRM_CONST_STRING *f_pdstrDevCert,
    __in  const DRM_CONST_STRING *f_pdstrXMLExclusion,
    __out       DRM_BOOL          *f_pfExcluded )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg(f_pfExcluded != NULL);
    ChkDRMString(f_pdstrXMLExclusion);
    ChkDRMString(f_pdstrDevCert);

    *f_pfExcluded = FALSE;

    /* get the devcert XML with the <DATA> tag at the root */
    ChkDR(DRM_XMU_MatchNodeFromTemplate(f_pdstrDevCert,
                                        f_pdstrXMLExclusion,
                                        TRUE,
                                        f_pfExcluded));

ErrorExit:
    return dr;
}

#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

#if DRM_SUPPORT_WMDRMNET

/******************************************************************************
**
** Function :   _VerifyWMDRMNETRevocationList
**
** Synopsis :   Verify signature on the WMDRMNET CRL and return the version
**              of the CRL.
**
** Arguments :  f_pdstrList     - WMDRMNET Revocation list
**              f_pdwVersion    - Version or Serial number on revocation list
**              [f_pCryptoCtx]     : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns :
**
** Notes :      If the verification fails, the buffer will be filled with
**              spaces to prevent the XML parsing from being confused later
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _VerifyWMDRMNETRevocationList(
    IN  DRM_CONST_STRING   *f_pdstrList,
    OUT DRM_DWORD          *f_pdwVersion,
    DRM_CRYPTO_CONTEXT     *f_pCryptoCtx )
{
    DRM_RESULT dr                 = DRM_SUCCESS;
    DRM_DWORD  cbData             = 0;
    DRM_DWORD  cbEncoded         = 0;
    DRM_STRING dstrRevocationData = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC__VerifyWMDRMNETRevocationList );

    ChkArg( f_pdstrList  != NULL
         && f_pdwVersion != NULL );
    ChkArg( f_pCryptoCtx != NULL );


    DSTR_FROM_PB( &dstrRevocationData,
                  PB_DSTR( f_pdstrList ),
                  CB_DSTR( f_pdstrList ) );

    cbData = CB_BASE64_DECODE(dstrRevocationData.cchString);


    ChkDR( DRM_B64_DecodeW( (DRM_CONST_STRING *) &dstrRevocationData,
                         &cbData,
                          NULL,
                          DRM_BASE64_DECODE_IN_PLACE ) );

    ChkDR( _VerifyBinaryWMDRMNETSignature( (DRM_BYTE*)dstrRevocationData.pwszString,
                                        cbData,
                                        f_pdwVersion,
                                        f_pCryptoCtx ) );

    cbEncoded = dstrRevocationData.cchString;
    ChkDR( DRM_B64_EncodeW( (DRM_BYTE*)dstrRevocationData.pwszString,
                         cbData,
                         dstrRevocationData.pwszString,
                        &cbEncoded,
                         0 ) );

 ErrorExit:

    /*
     * If verification failed, the CRL may be in binary form and could
     * could mess up XML parsing later on, so we overwrite it with spaces.
     */
    if( DRM_FAILED( dr ) )
    {
        DRM_BYT_SetBytes( dstrRevocationData.pwszString,
                    0,
                    dstrRevocationData.cchString,
                    ' ' );
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/******************************************************************************
**
** Function :   _UpdateWMDRMNETRevocationList
**
** Synopsis :   updates the WMDRMNET revocation list in the secure store
**
** Arguments :
** [f_pcontextCrypto]      -- Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code
** [f_pContextRev]         -- revocation store context
** [f_pbRevocationList]    -- input buffer for exclusion list
** [f_cbRevocationList]    -- buffer size
** [f_pdstrRevocationList] -- the new DCRL
** [f_pfUpdated]           -- Optional flag indicates whether the CRL was
**                            updated in the HDS or not.
** [f_pdwVersion]          -- optional parameter which receives the version of the
**                            revocation list that is saved on the system when this
**                            function exits. This is not necessarily the version of the
**                            CRL passed into this function, since we only save
**                            crls if they're a higher version than what is already
**                            there.
** Returns :
**
** Notes :
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _UpdateWMDRMNETRevocationList(
    IN          DRM_CRYPTO_CONTEXT   *f_pcontextCrypto,
    IN          DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN          DRM_BYTE             *f_pbRevocationList,
    IN          DRM_DWORD             f_cbRevocationList,
    IN          DRM_BYTE             *f_pbRevocationBuffer,
    IN          DRM_DWORD             f_cbRevocationBuffer,
    OUT         DRM_BOOL             *f_pfUpdated,
    OUT         DRM_DWORD            *f_pdwVersion)
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_DWORD        idSerialNew  = 0,
                     idSerialOld  = 0,
                     cbReturned   = 0;
    DRM_CONST_STRING dstrTemplate  = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrList       = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC__UpdateWMDRMNETRevocationList );

    ChkArg(   f_pcontextCrypto   != NULL
           && f_pContextRev      != NULL
           && f_pbRevocationList           != NULL
           && f_pbRevocationBuffer != NULL
           && f_cbRevocationBuffer > 0
           && f_cbRevocationList > 0 );

    if( f_pfUpdated != NULL )
    {
        *f_pfUpdated = FALSE;
    }
    if ( f_pdwVersion != NULL )
    {
        *f_pdwVersion = 0;
    }

    DSTR_FROM_PB( &dstrList, f_pbRevocationList, f_cbRevocationList );

    idSerialNew = DRM_NO_PREVIOUS_CRL;
    idSerialOld = DRM_NO_PREVIOUS_CRL;
    if ( IsWrappedCRL( &dstrList ) )
    {
        ChkDR( DRM_RVK_VerifyRevocationList( f_pcontextCrypto,
                                     &dstrList,
                                      &g_pubkeyWMDRMNDRevocation,
                                      &idSerialNew ) );

        ChkDR( DRM_XML_GetSubNode( &dstrList,
                                  &g_dstrTemplate,
                                   NULL,
                                   NULL,
                                   0,
                                   NULL,
                                  &dstrTemplate,
                                   1 ) );

        /* We will store the unwrapped CRL in decoded form */
        ChkDR( DRM_B64_DecodeW( (const DRM_CONST_STRING*)&dstrTemplate,
                               &f_cbRevocationList,
                               NULL,
                               DRM_BASE64_DECODE_IN_PLACE ) );

        f_pbRevocationList = (DRM_BYTE*)dstrTemplate.pwszString;

    }
    else
    {
        ChkDR( _VerifyBinaryWMDRMNETSignature(     f_pbRevocationList,
                                                   f_cbRevocationList,
                                                  &idSerialNew,
                                                   f_pcontextCrypto ) );
    }


    cbReturned = f_cbRevocationBuffer;
    /* get and verify the current SST image
     */
    dr = _GetSSTRevocationList( &g_guidRevocationTypeWMDRMNET,
                                f_pcontextCrypto,
                                f_pContextRev,
                               &g_pubkeyWMDRMNDRevocation,
                                f_pbRevocationBuffer,
                               &cbReturned,
                               &idSerialOld );


    /* This can be the first Revocation list */

    if ( dr == DRM_E_DSTSLOTNOTFOUND
        || ( ( idSerialOld == DRM_NO_PREVIOUS_CRL ) && DRM_SUCCEEDED( dr ) )
        || ( ( idSerialOld < idSerialNew ) && DRM_SUCCEEDED( dr ) ) )
    {

        /* store the new list. */
        ChkDR( DRM_RVS_StoreRevocationData( f_pContextRev,
                                           &g_guidRevocationTypeWMDRMNET,
                                            f_pbRevocationList,
                                            f_cbRevocationList ) );
        if( f_pfUpdated != NULL )
        {
            *f_pfUpdated = TRUE;
        }
        if (f_pdwVersion)
        {
            *f_pdwVersion = idSerialNew;
        }
    }
    else
    {
        ChkDR( dr );

        /* CRL did not get updated, so set it to the old version. */
        if (f_pdwVersion)
        {
            *f_pdwVersion = idSerialOld;
        }
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/******************************************************************************
**
** Function :   DRM_RVK_UpdateWMDRMNETRevocationList
**
** Synopsis :   updates the WMDRMNET revocation list in the secure store
**
** Arguments :
** [f_pcontextCrypto]      -- Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code
** [f_pContextRev]         -- revocation store context
** [f_pbRevocationList]    -- input buffer for exclusion list
** [f_cbRevocationList]    -- buffer size
** [f_pdstrRevocationList] -- the new DCRL

** Returns :
**
** Notes :
**
******************************************************************************/
DRM_RESULT DRM_RVK_UpdateWMDRMNETRevocationList(
    IN          DRM_CRYPTO_CONTEXT   *f_pcontextCrypto,
    IN          DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in_ecount( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch ) DRM_CHAR *f_rgchBase,
    IN  const   DRM_SUBSTRING        *f_pdasstrRevocationList,
    __in_bcount( f_cbRevocationBuffer ) DRM_BYTE *f_pbRevocationBuffer,
    IN          DRM_DWORD             f_cbRevocationBuffer,
    IN  const   PUBKEY               *f_ppubkey )
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_DWORD        cbDecoded    = 0;
    DRM_BYTE        *pbDecoded   = NULL;
    DRM_DWORD        cbAligned      = 0;
    DRM_BYTE        *pbAligned      = NULL;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_UpdateWMDRMNETRevocationList );

    ChkArg(   f_pcontextCrypto   != NULL
           && f_pContextRev      != NULL
           && f_rgchBase           != NULL
           && f_pbRevocationBuffer != NULL
           && f_cbRevocationBuffer > 0
           && f_pdasstrRevocationList != NULL
           && f_pdasstrRevocationList->m_cch > 0 );


     /* pbOffset will point within the base64 revocation list we were passed,
       such that after base64 decoding the end of the decoded data will co-incide with
       the end of the buffer we were given, minus one byte.

       This is because we are giving the B64 decoder overlapping memory for source and desitination,
       and we can't use the DECODE_IN_PLACE flag because this is ANSI where the offset may not coincide
       with a word boundary as required on 16-bit platforms.
     */

     pbDecoded = (DRM_BYTE*)f_rgchBase
                        + __CB_DECL( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) - 1 )
                        + ( ( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) ) % CB_NATIVE_BYTE );

    cbDecoded = CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) + 1 - ( ( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) ) % CB_NATIVE_BYTE );

    /* Ensure the pointer is DRM_WCHAR aligned */
    ChkDR( DRM_UTL_EnsureDataAlignment( pbDecoded, cbDecoded, &pbAligned, &cbAligned, SIZEOF( DRM_WCHAR ), NULL ) );
    ChkBOOL( cbAligned >= CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ), DRM_E_BUFFERTOOSMALL );

    /* decode the XML for the new exclusion list in place */
    ChkDR( DRM_B64_DecodeA( f_rgchBase,
                            f_pdasstrRevocationList,
                           &cbAligned,
                            pbAligned,
                            0 ) );

    ChkDR( _UpdateWMDRMNETRevocationList( f_pcontextCrypto,
                                    f_pContextRev,
                                    pbAligned,
                                    cbAligned,
                                    f_pbRevocationBuffer,
                                    f_cbRevocationBuffer,
                                    NULL,
                                    NULL) );


ErrorExit:
    if( ( f_rgchBase != NULL )
        && ( f_pdasstrRevocationList != NULL )
        && ( f_pdasstrRevocationList->m_cch != 0 ) )
    {
        /* Since we decoded in-place, we need to clean up otherwise the XML parsing may
         * not work properly later on. So we have to overwrite our binary with spaces.
         *
         * NOTE: This means that we CANNOT process the same revocation list in the same
         * license response buffer twice since we're overwriting the buffer we were given
         */
        DRM_BYT_SetBytes( f_rgchBase, f_pdasstrRevocationList->m_ich, f_pdasstrRevocationList->m_cch, ' ');
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*****************************************************************************
** Function: DRM_RVK_GetWMDRMNETList
**
** Synopsis: gets the current link protection list from the secure store
**
** Arguments:
** [f_pcontextCRYP]   -- a buffer
** [f_pContextRev]    -- revocation store context
** [f_pbRevocationData]  -- output buffer for exclusion list; NULL to request
**                       required size
** [f_pcbRevocationData] -- DRM_DWORD to hold max buffer size on in, bytes
**                       actually used on out
** [f_pidSerial]      -- receives numerical representation of <INDEX> tag
*****************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVK_GetWMDRMNETList(
    IN      DRM_CRYPTO_CONTEXT   *f_pcontextCRYP, 
    IN      DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __out_bcount_opt( *f_pcbRevocationData ) DRM_BYTE *f_pbRevocationData,
    IN  OUT DRM_DWORD            *f_pcbRevocationData,
        OUT DRM_DWORD            *f_pidSerial)
{
    DRM_RESULT          dr = DRM_SUCCESS;

    ChkArg(   f_pcontextCRYP        != NULL
           && f_pContextRev         != NULL
           && f_pcbRevocationData   != NULL
           && f_pidSerial           != NULL );

    dr = _GetSSTRevocationList( &g_guidRevocationTypeWMDRMNET,
                                  f_pcontextCRYP,
                                  f_pContextRev,
                                  &g_pubkeyWMDRMNDRevocation,
                                  f_pbRevocationData,
                                  f_pcbRevocationData,
                                  f_pidSerial );
    if ( dr == DRM_E_FILENOTFOUND
      || dr == DRM_E_DSTSLOTNOTFOUND )
    {
        dr                   = DRM_SUCCESS;
        *f_pidSerial         = 0;
        *f_pcbRevocationData = 0;
        goto ErrorExit;
    }
    ChkDR(dr);

ErrorExit:
    return dr;
}

#endif

typedef struct _tagRevDispatchEntry
{
    DRM_REVOCATION_TYPE_ENUM     eType;
    const DRM_ANSI_CONST_STRING *pdastrType;
    const DRM_ANSI_CONST_STRING *pdastrTypeGuid;
    const DRM_GUID              *pguid;
    const PUBKEY                *ppubkey;
} REVDISPATCHENTRY;

/* dispatch table for various revocation types */
/* note: remove this conditional and all like it if any revocation types are entered
         feature-independently
         likewise, extend this conditional and all like it if this list is extended with other
         feature-dependent revocation types */

/* if any of revocation types is defined */
#if DRM_SUPPORT_APP_REVOCATION || DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_WMDRMNET

REVDISPATCHENTRY g_arevDispatch [] =
{
#if DRM_SUPPORT_GRL
    //
    //  Should this include the GRL?
    //
#endif

#if DRM_SUPPORT_APP_REVOCATION
    { DRM_REVOCATION_TYPE_WMDRM_APP,     &g_dastrAppRevocation,          &g_dastrRevocationGuidApp,      &g_guidRevocationTypeApp,       &g_pubkeyRevocation},
#endif /* DRM_SUPPORT_APP_REVOCATION */

#if DRM_SUPPORT_DEVICE_REVOCATION
    { DRM_REVOCATION_TYPE_WMDRM_DEVICE, &g_dastrDeviceRevocation,       &g_dastrRevocationGuidDevice,   &g_guidRevocationTypeDevice,    &g_pubkeyDeviceRevocation},
#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

#if DRM_SUPPORT_WMDRMNET
    { DRM_REVOCATION_TYPE_WMDRM_ND, &g_dastrWMDRMNET_Revocation,    &g_dastrRevocationGuidWMDRMNET, &g_guidRevocationTypeWMDRMNET, &g_pubkeyWMDRMNDRevocation},
#endif /* DRM_SUPPORT_WMDRMNET */
};

#endif /* DRM_SUPPORT_APP_REVOCATION || DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_WMDRMNET */

    /*
    // The CRL has the following format:
    //
    // +--------------------+------------------------------------------+
    // | SECTIONS           | FIELDS                                   |
    // +--------------------+------------------------------------------+
    // | Header             | 32-bit CRL Version                       |
    // |                    +------------------------------------------+
    // |                    | 32-bit Number of Entries                 |
    // +--------------------+------------------------------------------+
    // | Revocation Entries | Multiple 160-bit Revocation Entries      |
    // +--------------------+------------------------------------------+
    // | Certificate        | 32-bit Certificate Length                |
    // |                    +------------------------------------------+
    // |                    | Variable Length Certificate              |
    // +--------------------+------------------------------------------+
    // | Signature          | 8-bit Signature Type                     |
    // |                    +------------------------------------------+
    // |                    | 16-bit Signature Length                  |
    // |                    +------------------------------------------+
    // |                    | Variable Length Signature                |
    // +--------------------+------------------------------------------+
    */

/**********************************************************************
**
** Function:    _VerifyCRLSignature
**
** Synopsis:    Verifies the CRL signature.
**
** Arguments:
**              [f_pbSignedBytes]        - Specifies the bytes that are signed
**              [f_cbSignedBytes]        - Specifies the size of the signed bytes
**              [f_pbSignature]          - Specifies the signature
**              [f_cbSignature]          - Specifies the size signature
**              [f_pbCertificate]        - Specifies the certificate chain used to find signing key
**              [f_cbCertificate]        - Specifies the size certificate chain used to find signing key
**              [f_pCryptoCtx]          -- Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns:     DRM_SUCCESS if the signature is valid
**              DRM_XMLNOTFOUND if unable to locate signing key
**              passes return codes from other failures up to caller
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL _VerifyCRLSignature ( 
    DRM_BYTE               *f_pbSignedBytes,
    DRM_DWORD               f_cbSignedBytes,
    DRM_BYTE               *f_pbSignature,
    DRM_DWORD               f_cbSignature,
    DRM_SUBSTRING           f_dasstrCertificate,
    DRM_CRYPTO_CONTEXT     *f_pCryptoCtx)
{
    DRM_RESULT          dr     = DRM_SUCCESS;

#if DRM_SUPPORT_WMDRMNET
    DRM_RSA_PUBLIC_KEY  pubKey = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC__VerifyCRLSignature );

    ChkArg( f_pCryptoCtx    != NULL );
    /* validate certificate chain */
    dr = _ValidateCertificate( (DRM_CHAR *) f_pbSignedBytes, f_dasstrCertificate, NULL, f_pCryptoCtx );
    if( DRM_FAILED(dr) )
    {
        TRACE(( "_VerifyCRLSignature: Invalid Certificate\n" ));
        ChkDR( dr );
    }

    /* find certificate that signed CRL */
    {
        DRM_SUBSTRING       dasstrCollection = f_dasstrCertificate;
        DRM_SUBSTRING       dasstrData = EMPTY_DRM_SUBSTRING;
        DRM_DWORD           cNodes;
        DRM_DWORD           iNode;


        ChkDR( DRM_XML_GetNodeA( (const DRM_CHAR *) f_pbSignedBytes, &dasstrCollection, &g_dastrTagCertificateCollection, NULL, NULL, 0, NULL, &dasstrData ));

        /* enumerate c:Certificate nodes */

        ChkDR(DRM_XML_CountMatchingNodesA( (const DRM_CHAR *) f_pbSignedBytes,
                                        &dasstrData,
                                        &g_dastrTagWMDRMCertificate,
                                        NULL,
                                        NULL,
                                        &cNodes));

        ChkArg(cNodes >= 1
            && cNodes <= DRM_CERTIFICATE_COLLECTION_MAX);

        for (iNode = 0; iNode < cNodes; iNode++)
        {
            DRM_SUBSTRING dasstrCertificate = EMPTY_DRM_STRING;
            DRM_SUBSTRING dasstrTag         = EMPTY_DRM_STRING;
            DRM_SUBSTRING rgdasstrAttrs [3]   = { 0 };
            DRM_DWORD     cAttrEntries        = NO_OF(rgdasstrAttrs);
            DRM_DWORD     dwUsage    = 0;

            ChkDR(DRM_XML_EnumNextNodeA( (const DRM_CHAR *) f_pbSignedBytes,
                                        &dasstrData,
                                         iNode,
                                        &dasstrTag,
                                        &dasstrCertificate,
                                         NULL,
                                         NULL,
                                         NULL));

            /* there should be nothing but <c:Certificate>s in <CertificateCollection> */

            ChkArg(DRM_UTL_DASSTRStringsEqual( (const DRM_CHAR *) f_pbSignedBytes,
                                              &dasstrTag,
                                              &g_dastrTagWMDRMCertificate));

            /* Check if cert signed CRL, and if so, get public key */
            ChkDR( DRM_WCP_GetKeyUsage( (const DRM_CHAR *) f_pbSignedBytes,
                                        &dasstrCertificate,
                                        &dwUsage ) );

            if( dwUsage & DRM_WMDRM_CERT_KEYUSAGE_SIGNCRL )
            {
                DRM_DWORD cbDestination;
                DRM_BYTE  rgbExponent[__CB_DECL( DRM_RSA_CB_PUBEXP )];
                DRM_BYTE  rgbModulus [__CB_DECL(DRM_RSA_CB_MODULUS_MAX * 2 + 8)] = { 0 };
                DRM_RSA_SUPPORTED_KEY_LENGTHS eKeyLength = eDRM_RSA_UNKNOWN;

                cAttrEntries = 3;
                ChkDR( DRM_WCP_GetAttribute( (const DRM_CHAR *) f_pbSignedBytes,
                                            &dasstrCertificate,
                                             DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SELF_RSA,
                                             rgdasstrAttrs,
                                            &cAttrEntries ) );

                /*
                *  Decode Exponent
                */
                cbDestination = 4;
                ChkDR( DRM_B64_DecodeA( (const DRM_CHAR *) f_pbSignedBytes,
                                        rgdasstrAttrs,
                                       &cbDestination,
                                        rgbExponent,
                                        0 ) );
                PUT_BYTE( rgbExponent, 3, GET_BYTE( rgbExponent, 2 ) );
                PUT_BYTE( rgbExponent, 2, GET_BYTE( rgbExponent, 1 ) );
                PUT_BYTE( rgbExponent, 1, GET_BYTE( rgbExponent, 0 ) );
                PUT_BYTE( rgbExponent, 0, 0 );

                /*
                *  Decode Modulus
                */
                cbDestination = SIZEOF(rgbModulus);
                ChkDR( DRM_B64_DecodeA( (const DRM_CHAR *) f_pbSignedBytes,
                                        rgdasstrAttrs + 1,
                                       &cbDestination,
                                        rgbModulus,
                                        0 ) );

                ChkDR( OEM_RSA_GetKeyLengthFromModulusLength( cbDestination, &eKeyLength ) );

                ChkDR( OEM_RSA_SetPublicKey( eKeyLength,
                                             SIZEOF( rgbExponent ),
                                             rgbExponent,
                                             cbDestination,
                                             rgbModulus,
                                             &pubKey ) );
            }
        }
    }

    dr = DRM_RSA_PssVerify( &pubKey,
                             f_cbSignedBytes,
                             f_pbSignedBytes,
                             0,
                             f_cbSignature,
                             f_pbSignature,
                             f_pCryptoCtx );

    if( DRM_FAILED(dr) )
    {
        TRACE(( "_VerifyCRLSignature: Signature Invalid\n" ));
        ChkDR( dr );
    }

ErrorExit:
    OEM_RSA_ZeroPublicKey( &pubKey );
    DRM_PROFILING_LEAVE_SCOPE;
#endif /* DRM_SUPPORT_WMDRMNET */

    return dr;
}

#if DRM_SUPPORT_WMDRMNET

DRM_RESULT DRM_NO_INLINE DRM_CALL DRM_RVK_GetWMDRMNETRevocationEntries(
    __in_bcount( f_cbRevocationData ) DRM_BYTE *f_pbRevocationData,
    IN     DRM_DWORD            f_cbRevocationData,
       OUT DRM_DWORD           *f_pcEntries,
    __deref_out_ecount( *f_pcEntries ) WMDRMNET_CRL_ENTRY **f_ppEntries)
{
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_DWORD cEntries  = 0;
    DRM_DWORD cbEntries = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_GetWMDRMNETRevocationEntries );

    ChkArg(f_pbRevocationData != NULL
        && f_pcEntries        != NULL
        && f_ppEntries        != NULL );

    *f_pcEntries = 0;
    *f_ppEntries = NULL;

    /*
    ** (check that there is enough room for both the CRL ver and the entry count)
    */

    ChkArg( f_cbRevocationData >= (SIZEOF(DRM_DWORD) * 2) );

    /*
    ** skip over the version DRM_DWORD
    */

    f_pbRevocationData += SIZEOF(DRM_DWORD);
    f_cbRevocationData -= SIZEOF(DRM_DWORD);

    /*
    ** get the entry count and skip over it
    */

    NETWORKBYTES_TO_DWORD( cEntries, f_pbRevocationData, 0 );
    f_pbRevocationData += SIZEOF(DRM_DWORD);
    f_cbRevocationData -= SIZEOF(DRM_DWORD);

    if (cEntries > 0)
    {
        *f_pcEntries = cEntries;

        /*
        ** Get the entries.  we don't need to copy them, just update
        ** our array pointer to point to the right location.
        */
        cbEntries = cEntries * SIZEOF( WMDRMNET_CRL_ENTRY );

        ChkArg( f_cbRevocationData >= cbEntries );

        *f_ppEntries = (WMDRMNET_CRL_ENTRY*) f_pbRevocationData;
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


static DRM_NO_INLINE DRM_RESULT DRM_CALL _VerifyBinaryWMDRMNETSignature(
    IN     DRM_BYTE          *f_pbData,
    IN     DRM_DWORD          f_cbData,
    IN OUT DRM_DWORD         *f_pidSerial,
    IN     DRM_CRYPTO_CONTEXT*f_pCryptoCtx )
{
    DRM_RESULT          dr              = DRM_SUCCESS;
    DRM_BYTE            bSignatureType  = 0;
    DRM_DWORD           cEntries        = 0;
    DRM_UINT64          cbEntries       = DRM_UI64LITERAL(0, 0);
    DRM_DWORD           cbSigned        = 0;
    DRM_DWORD           dwVersion       = 0;
    DRM_SUBSTRING       dasstrCertificate = EMPTY_DRM_SUBSTRING;
    DRM_DWORD           cbData          = f_cbData;
    DRM_DWORD           ibData          = 0;
    DRM_WORD           cbSignature      = 0;
#if SIXTEEN_BIT_ADDRESSING
    DRM_BYTE            rgbSignature[ __CB_DECL( WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1 ) ];
#endif

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC__VerifyBinaryWMDRMNETSignature );

    /*
    ** Get the CRL Version
    */

    ChkArg(f_cbData     >= SIZEOF(DRM_DWORD)
        && f_pbData     != NULL
        && f_pidSerial  != NULL
        && f_pCryptoCtx != NULL );

    NETWORKBYTES_TO_DWORD( dwVersion, f_pbData, 0 );
    cbSigned += SIZEOF(DRM_DWORD);
    ibData   += SIZEOF(DRM_DWORD);
    cbData   -= SIZEOF(DRM_DWORD);

    /* if the expected version number is given it must match, otherwise its' a query */

    if (*f_pidSerial != DRM_NO_PREVIOUS_CRL)
    {
        ChkArg(dwVersion == *f_pidSerial);
    }
    else
    {
        *f_pidSerial = dwVersion;
    }

    /*
    ** Get the number of entries
    */
    ChkArg(cbData >= SIZEOF(DRM_DWORD));

    NETWORKBYTES_TO_DWORD( cEntries, f_pbData, ibData );
    cbSigned += SIZEOF(DRM_DWORD);
    ibData   += SIZEOF(DRM_DWORD);
    cbData   -= SIZEOF(DRM_DWORD);

    /*
    ** Get the size of the entries
    **
    */
    cbEntries = DRM_UI64Mul(DRM_UI64HL( 0, cEntries ), DRM_UI64HL( 0, SIZEOF(WMDRMNET_CRL_ENTRY) ));

    ChkArg(cbData >= DRM_UI64Low32(cbEntries)); /* use qword to prevent arithmetic overflows */


    cbSigned += SIZEOF(WMDRMNET_CRL_ENTRY) * cEntries;
    ibData   += SIZEOF(WMDRMNET_CRL_ENTRY) * cEntries;
    cbData   -= SIZEOF(WMDRMNET_CRL_ENTRY) * cEntries;

    /*
    ** Get the certificate length
    */

    ChkArg(cbData >= SIZEOF(DRM_DWORD));

    NETWORKBYTES_TO_DWORD( dasstrCertificate.m_cch, f_pbData, ibData );

    cbSigned += SIZEOF(DRM_DWORD);
    ibData   += SIZEOF(DRM_DWORD);
    cbData   -= SIZEOF(DRM_DWORD);

    ChkArg(dasstrCertificate.m_cch > 0);

    /*
    ** Get the certificate.  we don't need to copy it, just update
    ** our byte offset to point to the right location.
    */

    ChkArg(cbData >= dasstrCertificate.m_cch);
    dasstrCertificate.m_ich = ibData;


    cbSigned += dasstrCertificate.m_cch;
    ibData   += dasstrCertificate.m_cch;
    cbData   -= dasstrCertificate.m_cch;

    /*
    ** Get the signature type
    */

    ChkArg(cbData >= SIZEOF(DRM_BYTE));

    bSignatureType = GET_BYTE( f_pbData, ibData );

    ibData++;
    cbData--;

    ChkArg( bSignatureType == WMDRMNET_CRL_SIGNATURE_TYPE_RSA_SHA1 );

    /*
    ** get the signature length
    */

    ChkArg(cbData >= SIZEOF(DRM_WORD));

    NETWORKBYTES_TO_WORD( cbSignature, f_pbData, ibData );
    ibData += SIZEOF(DRM_WORD);
    cbData -= SIZEOF(DRM_WORD);

    ChkArg( cbSignature == WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1 );

    /*
    ** get the signature and validate it
    */
    ChkArg(cbData >= WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1);

#if SIXTEEN_BIT_ADDRESSING
    DRM_BYT_CopyBytes( rgbSignature,
                      0,
                      f_pbData,
                      ibData,
                      WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1 );

    dr = _VerifyCRLSignature( f_pbData,
                            cbSigned,
                            rgbSignature,
                            WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1,
                            dasstrCertificate,
                            f_pCryptoCtx );
#else
    dr = _VerifyCRLSignature( f_pbData,
                            cbSigned,
                            f_pbData + ibData,
                            WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1,
                            dasstrCertificate,
                            f_pCryptoCtx );
#endif

    if (DRM_FAILED(dr))
    {
        ChkDR(DRM_E_INVALID_SIGNATURE);
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#endif /* DRM_SUPPORT_WMDRMNET */

/**********************************************************************
**
** Function:    _ValidateCertificate
**
** Synopsis:    Validates the device certificate. Optionally returns WMDRM-ND certificate
**
** Arguments:
**              [f_rgchDeviceCertificate]     - Specifies the device certificate
**              [f_cbDeviceCertificate]       - Specifies the size (in bytes) of the Device Certificate
**              [f_pdasstrWMDRMNDCertificate] - Optional, can be NULL.  If not NULL, returns the
**                                              DRM_SUBSTRING pointing to the WMDRM-ND certificate
**              [f_pCryptoCtx]          -- Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any of the arguments are invalid
**
**********************************************************************/
static DRM_RESULT
_ValidateCertificate(
    IN DRM_CHAR                 *f_rgchBase,
    IN DRM_SUBSTRING             f_dasstrCertificate,
    IN OUT DRM_SUBSTRING        *f_pdasstrWMDRMNDCertificate,
    IN     DRM_CRYPTO_CONTEXT   *f_pCryptoCtx
    )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_rgchBase );
    ChkArg( f_pCryptoCtx != NULL );

    if (DRM_FAILED( DRM_WCP_VerifyCertificateCollection(
                             f_rgchBase,
                            &f_dasstrCertificate,
                            &g_dastrMSNDRootPubKeyB64,
                             NULL,
                             0,
                             f_pdasstrWMDRMNDCertificate,
                             NULL,
                             f_pCryptoCtx ) ) )
    {
        ChkDR(DRM_E_INVALIDDEVICECERTIFICATE);
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_RVK_VerifyRevocationInfo
**
** Synopsis :   Verify signature on the revocation info
**
** Arguments :  f_pbRevInfo  - rev info buffer (already b64 decoded)
**              f_pcbRevInfo - size of rev info buffer
**              [f_pCryptoCtx]          -- Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
** Returns :
**
** Notes :
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVK_VerifyRevocationInfo(
    __in_bcount( f_cbRevInfo ) DRM_BYTE           *f_pbRevInfo,
    __in                       DRM_DWORD           f_cbRevInfo,
    __out                      DRM_RLVI           *f_pRLVI,
    __in                       DRM_CRYPTO_CONTEXT *f_pCryptoCtx,
    __in_opt                   DRM_BB_CONTEXT     *f_pcontextBBX,
    __in_opt                   DRM_SECSTORE_CONTEXT *f_pcontextSST,
    __in_opt                   DRM_DST            *f_pDatastore )
{
    DRM_RESULT      dr                = DRM_SUCCESS;
    DRM_DWORD       cbRevInfo         = f_cbRevInfo;
    DRM_DWORD       cbSignedBytes     = 0;
    DRM_DWORD       cbEntries         = 0;
    DRM_DWORD       dwRevInfo         = 0;
    DRM_SUBSTRING   dasstrCertificate = EMPTY_DRM_SUBSTRING;
#if SIXTEEN_BIT_ADDRESSING
    DRM_BYTE        rgbSignature[ __CB_DECL( max( RLVI_SIGNATURE_SIZE_1, RLVI_SIGNATURE_SIZE_2 ) ) ];
#endif
    DRM_WORD        cbSignature = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_VerifyRevocationInfo );

    ChkArg( f_pbRevInfo != NULL
          && f_pRLVI     != NULL );
    ChkArg( SIZEOF( DRM_RLVI_HEAD ) <= f_cbRevInfo );
    ChkArg( f_pCryptoCtx    != NULL );

    MEMSET( f_pRLVI, 0, SIZEOF( DRM_RLVI ) );

    /* ID */
    NETWORKBYTES_TO_DWORD( f_pRLVI->head.dwID, f_pbRevInfo, dwRevInfo );
    ChkArg( RLVI_MAGIC_NUM_V1 == f_pRLVI->head.dwID || RLVI_MAGIC_NUM_V2 == f_pRLVI->head.dwID );
    dwRevInfo += SIZEOF( DRM_DWORD );

    /* Length */
    NETWORKBYTES_TO_DWORD( f_pRLVI->head.cbSignedBytes, f_pbRevInfo, dwRevInfo );
    ChkArg( SIZEOF( DRM_RLVI_HEAD ) <= f_pRLVI->head.cbSignedBytes );
    dwRevInfo += SIZEOF( DRM_DWORD );

    /* Format Version */
    f_pRLVI->head.bFormatVersion = GET_BYTE( f_pbRevInfo, dwRevInfo );
    ChkArg( (RLVI_FORMAT_VERSION_V1 == f_pRLVI->head.bFormatVersion && f_pRLVI->head.dwID == RLVI_MAGIC_NUM_V1 )
        || ( RLVI_FORMAT_VERSION_V2 == f_pRLVI->head.bFormatVersion && f_pRLVI->head.dwID == RLVI_MAGIC_NUM_V2 ) );
    dwRevInfo += SIZEOF(DRM_BYTE) / CB_NATIVE_BYTE;

    /* Reserved */
    f_pRLVI->head.bReserved[0] = GET_BYTE( f_pbRevInfo, dwRevInfo );
    dwRevInfo += SIZEOF(DRM_BYTE) / CB_NATIVE_BYTE;
    f_pRLVI->head.bReserved[1] = GET_BYTE( f_pbRevInfo, dwRevInfo );
    dwRevInfo += SIZEOF(DRM_BYTE) / CB_NATIVE_BYTE;
    f_pRLVI->head.bReserved[2] = GET_BYTE( f_pbRevInfo, dwRevInfo );
    dwRevInfo += SIZEOF(DRM_BYTE) / CB_NATIVE_BYTE;

    /* Sequence Nubmer */
    NETWORKBYTES_TO_DWORD( f_pRLVI->head.dwRIV, f_pbRevInfo, dwRevInfo );
    dwRevInfo += SIZEOF( DRM_DWORD );

    /* Issued Time: Stored in little endian order for V1 and big endian for V2 */
    if( RLVI_MAGIC_NUM_V1 == f_pRLVI->head.dwID )
    {
        LITTLEENDIAN_BYTES_TO_DWORD( f_pRLVI->head.ftIssuedTime.dwLowDateTime, f_pbRevInfo, dwRevInfo );
        dwRevInfo += SIZEOF( DRM_DWORD );
        LITTLEENDIAN_BYTES_TO_DWORD( f_pRLVI->head.ftIssuedTime.dwHighDateTime, f_pbRevInfo, dwRevInfo );
        dwRevInfo += SIZEOF( DRM_DWORD );
    }
    else if( RLVI_MAGIC_NUM_V2 == f_pRLVI->head.dwID )
    {
        DRM_UINT64 ui64IssueTime = DRM_UI64LITERAL(0,0);

        NETWORKBYTES_TO_QWORD( ui64IssueTime, f_pbRevInfo, dwRevInfo );
        UI64_TO_FILETIME(ui64IssueTime, f_pRLVI->head.ftIssuedTime)
        dwRevInfo += SIZEOF( DRM_UINT64 );
    }
    else
    {
        ChkDR( DRM_E_INVALID_REVOCATION_LIST );
    }

    /* Entry Count */
    NETWORKBYTES_TO_DWORD( f_pRLVI->head.dwRecordCount, f_pbRevInfo, dwRevInfo );
    dwRevInfo += SIZEOF( DRM_DWORD );

    /* Entries */
    cbEntries = SIZEOF( DRM_RLVI_RECORD ) * f_pRLVI->head.dwRecordCount;
    ChkArg( f_cbRevInfo - dwRevInfo >= cbEntries + ( SIZEOF(DRM_BYTE) / CB_NATIVE_BYTE ) + SIZEOF( DRM_DWORD ) );
    f_pRLVI->ibEntries = dwRevInfo;
    dwRevInfo += cbEntries;

    cbSignedBytes = dwRevInfo;

    /* Signature Type */
    f_pRLVI->signature.bSignatureType = GET_BYTE( f_pbRevInfo, dwRevInfo );
    dwRevInfo += SIZEOF(DRM_BYTE) / CB_NATIVE_BYTE;
    if( f_pRLVI->signature.bSignatureType == RLVI_SIGNATURE_TYPE_1 )
    {
        ChkArg( RLVI_SIGNATURE_SIZE_1 + SIZEOF(DRM_DWORD) <= (cbRevInfo - dwRevInfo) );
        cbSignature = RLVI_SIGNATURE_SIZE_1;
    }
    else if( f_pRLVI->signature.bSignatureType == RLVI_SIGNATURE_TYPE_2 )
    {
        NETWORKBYTES_TO_WORD( cbSignature, f_pbRevInfo, dwRevInfo );
        dwRevInfo += SIZEOF( DRM_WORD );
        ChkArg( cbSignature <= cbRevInfo - dwRevInfo );
    }
    else
    {
        ChkDR( DRM_E_INVALID_REVOCATION_LIST );
    }

    /* Signature */
    f_pRLVI->signature.ibSignature = dwRevInfo;
#if SIXTEEN_BIT_ADDRESSING
    DRM_BYT_CopyBytes( rgbSignature, 0, f_pbRevInfo, dwRevInfo, cbSignature );
#endif
    dwRevInfo += cbSignature;


    /*
    ** Certificate Chain Length.
    ** For RLVI_SIGNATURE_TYPE_1 the size is written before the certificate.
    ** For RLVI_SIGNATURE_TYPE_2 the certificate is PlayReady cert and size is not written.
    */
    if ( f_pRLVI->signature.bSignatureType == RLVI_SIGNATURE_TYPE_1 )
    {
        NETWORKBYTES_TO_DWORD( f_pRLVI->certchain.cbCertChain, f_pbRevInfo, dwRevInfo );
        dwRevInfo += SIZEOF( DRM_DWORD );
    }
    else if( f_pRLVI->signature.bSignatureType == RLVI_SIGNATURE_TYPE_2 )
    {
        f_pRLVI->certchain.cbCertChain = f_cbRevInfo - dwRevInfo;
    }
    else
    {
        ChkDR( DRM_E_INVALID_REVOCATION_LIST );
    }

    /* Certificate Chain */
    ChkArg( f_cbRevInfo - dwRevInfo >= f_pRLVI->certchain.cbCertChain );
    f_pRLVI->certchain.ibCertChain = dwRevInfo;
    dwRevInfo += f_pRLVI->certchain.cbCertChain;

    /* Verify Signature */

    dasstrCertificate.m_ich = f_pRLVI->certchain.ibCertChain;
    dasstrCertificate.m_cch = f_pRLVI->certchain.cbCertChain;

#if SIXTEEN_BIT_ADDRESSING
    if( f_pRLVI->head.bFormatVersion == RLVI_FORMAT_VERSION_V1 )
    {
        ChkDR( _VerifyCRLSignature(f_pbRevInfo,
                                      cbSignedBytes,
                                      rgbSignature,
                                      cbSignature,
                                      dasstrCertificate,
                                      f_pCryptoCtx ) );
    }
    else if( f_pRLVI->head.bFormatVersion == RLVI_FORMAT_VERSION_V2 )
    {
        ChkDR( DRM_BCrl_VerifySignature(f_pbRevInfo,
                                        cbSignedBytes,
                                        rgbSignature,
                                        cbSignature,
                                        f_pbRevInfo + dasstrCertificate.m_ich,
                                        dasstrCertificate.m_cch,
                                        (const PUBKEY_P256*)&g_rgbMSPlayReadyRootIssuerPubKey,
                                        f_pCryptoCtx, f_pcontextBBX, f_pcontextSST, f_pDatastore ) );
    }
#else
    if( f_pRLVI->head.bFormatVersion == RLVI_FORMAT_VERSION_V1 )
    {
        ChkDR( _VerifyCRLSignature(f_pbRevInfo,
                                      cbSignedBytes,
                                      f_pbRevInfo + f_pRLVI->signature.ibSignature,
                                      cbSignature,
                                      dasstrCertificate,
                                      f_pCryptoCtx ) );
    }
    else if( f_pRLVI->head.bFormatVersion == RLVI_FORMAT_VERSION_V2 )
    {
        ChkDR( DRM_BCrl_VerifySignature(f_pbRevInfo,
                                        cbSignedBytes,
                                        f_pbRevInfo + f_pRLVI->signature.ibSignature,
                                        cbSignature,
                                        f_pbRevInfo + dasstrCertificate.m_ich,
                                        dasstrCertificate.m_cch,
                                        (const PUBKEY_P256*)&g_rgbMSPlayReadyRootIssuerPubKey,
                                        f_pCryptoCtx, f_pcontextBBX, f_pcontextSST, f_pDatastore ) );
    }
#endif

 ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*****************************************************************************
** Function: DRM_RVK_GetCurrentRevocationInfo
**
** Synopsis: gets the current device exclusion list from the secure store
**
** Arguments:
** [f_pContextRev]       -- revocation store context
** [f_pbBuffer]          -- output buffer for exclusion list; NULL to request
**                          required size
** [f_pcbBuffer]         -- DRM_DWORD to hold max buffer size on in, bytes actually
**                          used on out
** [f_pCryptoCtx]          -- Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
*****************************************************************************/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVK_GetCurrentRevocationInfo(
    IN     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN     const DRM_GUID              *f_pguidRevocationType,
       OUT DRM_BYTE                    *f_pbBuffer,
    IN OUT DRM_DWORD                   *f_pcbBuffer,
       OUT DRM_RLVI                    *f_pRLVI,
    IN     DRM_CRYPTO_CONTEXT          *f_pCryptoCtx )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _RevocationStoreContext *pRevStore = (_RevocationStoreContext*)f_pContextRev;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_GetCurrentRevocationInfo );

    ChkArg( f_pRLVI       != NULL
         && f_pContextRev != NULL
         && f_pCryptoCtx  != NULL );

    if ( ( 0 != MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeRevInfo,  SIZEOF( DRM_GUID ) ) )
      && ( 0 != MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeRevInfo2, SIZEOF( DRM_GUID ) ) ) )
    {
        ChkDR( DRM_E_REVOCATION_GUID_NOT_RECOGNIZED );
    }

    dr = DRM_RVS_GetRevocationData( f_pContextRev,
                                    f_pguidRevocationType,
                                    f_pbBuffer,
                                    f_pcbBuffer);

    if ( dr == DRM_E_FILENOTFOUND
      || dr == DRM_E_DSTSLOTNOTFOUND )
    {
        /* if there's no revocation info current stored, fake out the RIV so the new info can be stored */
        MEMSET( f_pRLVI, 0, SIZEOF( DRM_RLVI ) );
        f_pRLVI->head.dwRIV = 0;
        *f_pcbBuffer = 0;
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }
    ChkDR(dr);

    /* decode the revocation info */

    ChkDR( DRM_RVK_VerifyRevocationInfo( f_pbBuffer,
                                        *f_pcbBuffer,
                                         f_pRLVI,
                                         f_pCryptoCtx,
                                         pRevStore->pContextBB,
                                         pRevStore->pContextSST,
                                         pRevStore->pDatastore) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*
Note: this function only works for legacy wmdrm app certs and will only support
pre-playready types of crls and rev info.
*/
DRM_RESULT DRM_RVK_StoreRevocationLists(
    IN     DRM_CRYPTO_CONTEXT    *f_pContextCrypto,
    IN     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN     DRM_DWORD              f_cRevocationLists,
    IN     DRM_RVK_LIST          *f_pRevocationLists,
    IN     APPCERT               *f_pAppcert,
    IN     DRM_BYTE              *f_pbRevocationBuffer,
    IN     DRM_DWORD              f_cbRevocationBuffer,
    IN OUT DRM_REVLIST_ID_VALUES *f_pRevList )
{
    DRM_RESULT    dr = DRM_SUCCESS;
    DRM_DWORD     i = 0;
    DRM_BOOL      fUpdated = FALSE;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_StoreRevocationLists );

    ChkArg( f_cRevocationLists > 0
     && f_pRevocationLists != NULL
     && f_pbRevocationBuffer != NULL
     && f_cbRevocationBuffer > 0
     && f_pContextCrypto != NULL
     && f_pContextRev  != NULL );
    ChkArg( f_pRevList != NULL );

    /* Process the CRLs first */
    for ( i = 0; i < f_cRevocationLists; i++ )
    {
        if( f_pRevocationLists[i].cbRevocationList == 0 )
        {
            /* Ignore zero length revocation lists */
            continue;
        }

#if DRM_SUPPORT_APP_REVOCATION
        if ( 0 == MEMCMP(&(f_pRevocationLists[i].guidRevocationList), &g_guidRevocationTypeApp, SIZEOF(DRM_GUID)) )
        {
            DRM_DWORD   cbBuffer                = 0;
            DRM_DWORD   crlVersion              = f_pRevList->wmdrmapp;
            DRM_BOOL    fUpdatedRevocationList  = FALSE;

            /* Ensure latest app crl version is up to date */
            cbBuffer = f_cbRevocationBuffer;
            ChkDR( DRM_RVK_GetCurrentAppRevocationList(f_pContextRev,
                                                       f_pbRevocationBuffer,
                                                      &cbBuffer,
                                                      &crlVersion ) );
            if( crlVersion > f_pRevList->wmdrmapp
             || f_pRevList->wmdrmapp == DRM_APP_REVOCATION_VERSION_NONE )
            {
                f_pRevList->wmdrmapp = crlVersion;
                fUpdated = TRUE;
            }

            ChkDR( DRM_RVK_UpdateAppRevocationListDecoded( f_pContextCrypto,
                        f_pContextRev,
                        f_pRevocationLists[i].pbRevocationList,
                        f_pRevocationLists[i].cbRevocationList,
                        f_pAppcert,
                        f_pRevList->wmdrmapp,
                       &fUpdatedRevocationList,
                       NULL ) );
            if( fUpdatedRevocationList )
            {
                fUpdated = TRUE;
            }

            continue;
        }
#endif

#if DRM_SUPPORT_DEVICE_REVOCATION
        if ( 0 == MEMCMP(&(f_pRevocationLists[i].guidRevocationList), &g_guidRevocationTypeDevice, SIZEOF(DRM_GUID)) )
        {
            DRM_BOOL    fUpdatedRevocationList  = FALSE;
            ChkDR( _UpdateRevocationList( f_pContextCrypto,
                                          f_pContextRev,
                                          f_pRevocationLists[i].pbRevocationList,
                                          f_pRevocationLists[i].cbRevocationList,
                                          f_pbRevocationBuffer,
                                          f_cbRevocationBuffer,
                                         &g_guidRevocationTypeDevice,
                                         &g_pubkeyDeviceRevocation,
                                         &fUpdatedRevocationList) );
            if( fUpdatedRevocationList )
            {
                fUpdated = TRUE;
            }
            continue;
        }
#endif

#if DRM_SUPPORT_WMDRMNET
        if ( 0 == MEMCMP(&(f_pRevocationLists[i].guidRevocationList), &g_guidRevocationTypeWMDRMNET, SIZEOF(DRM_GUID)) )
        {
            DRM_BOOL    fUpdatedRevocationList  = FALSE;
            ChkDR( _UpdateWMDRMNETRevocationList(
                                          f_pContextCrypto,
                                          f_pContextRev,
                                          f_pRevocationLists[i].pbRevocationList,
                                          f_pRevocationLists[i].cbRevocationList,
                                          f_pbRevocationBuffer,
                                          f_cbRevocationBuffer,
                                         &fUpdatedRevocationList,
                                          NULL) );
            if( fUpdatedRevocationList )
            {
                fUpdated = TRUE;
            }
            continue;
        }
#endif
    }

    /* Next process the rev infos */
    for ( i = 0; i < f_cRevocationLists; i++ )
    {
        if( f_pRevocationLists[i].cbRevocationList == 0 )
        {
            /* Ignore zero length revocation infos */
            continue;
        }

        if ( 0 == MEMCMP(&(f_pRevocationLists[i].guidRevocationList), &g_guidRevocationTypeRevInfo, SIZEOF(DRM_GUID)) )
        {
            /* To be symmetric with DRM_MGR_GetRevInfo, we accept base64 encoded revinfos */

            DRM_STRING dstrRevInfo = EMPTY_DRM_STRING;
            DRM_BOOL   fUpdatedRevInfo = FALSE;

            dstrRevInfo.pwszString = (DRM_WCHAR*)f_pRevocationLists[i].pbRevocationList;
            dstrRevInfo.cchString = f_pRevocationLists[i].cbRevocationList / SIZEOF( DRM_WCHAR );

            ChkDR( DRM_B64_DecodeW( (DRM_CONST_STRING *)&dstrRevInfo,
                            &f_pRevocationLists[i].cbRevocationList,
                            NULL,
                            DRM_BASE64_DECODE_IN_PLACE ) );

            ChkDR( DRM_RVK_StoreRevInfo( f_pContextCrypto,
                                         f_pContextRev,
                                        &(f_pRevocationLists[i].guidRevocationList),
                                         f_pRevocationLists[i].pbRevocationList,
                                         f_pRevocationLists[i].cbRevocationList,
                                         f_pbRevocationBuffer,
                                         f_cbRevocationBuffer,
                                         f_pRevList,
                                         &fUpdatedRevInfo) );

            if ( fUpdatedRevInfo )
            {
                /* DRM_RVK_StoreRevInfo will fully update passed in RevLists */
                fUpdated = FALSE;
            }

            continue;
        }
    }

ErrorExit:

    if ( fUpdated )
    {
        DRM_RVK_UpdateRevocationVersionsCache( f_pContextRev,
                                               f_pContextCrypto,
                                               f_pRevList,
                                               f_pbRevocationBuffer,
                                               f_cbRevocationBuffer,
                                               NULL );
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVK_FindEntryInRevInfo( 
    __in                        DRM_RLVI    *f_prlvi,
    __in_bcount(f_cbRevInfo)    DRM_BYTE    *f_pbRevInfo,
    __in                        DRM_DWORD    f_cbRevInfo,
    __in                  const DRM_GUID    *f_pguidEntry,
    __out                       DRM_DWORD   *f_pdwVersion )
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_BOOL    fFound  = FALSE;
    DRM_DWORD   iRev    = 0;

    ChkArg( f_pdwVersion != NULL );
    ChkArg( f_pbRevInfo != NULL );
    ChkArg( f_prlvi != NULL );
    ChkArg( f_cbRevInfo > 0 );
    ChkArg( f_pguidEntry != NULL );

    *f_pdwVersion = DRM_NO_PREVIOUS_CRL;

    /* Check buffer is big enough */
    ChkBOOL( f_cbRevInfo >= f_prlvi->ibEntries + ( f_prlvi->head.dwRecordCount * SIZEOF( DRM_RLVI_RECORD ) ), DRM_E_INVALIDREVINFO );

    /* Find the entry in the rev info corresponding to the supplied GUID */
    for ( iRev = 0; iRev < f_prlvi->head.dwRecordCount; iRev++ )
    {
        DRM_INT64  qwrlviVersion;
        DRM_DWORD  dwrlviVersion = 0;
        DRM_GUID   rlviGUID;

        /* Extract the CRL GUID from the iRev-th DRM_RLVI_RECORD in the revinfo */
        DRM_BYT_CopyBytes( &rlviGUID,
                        0,
                        f_pbRevInfo,
                        f_prlvi->ibEntries + ( iRev * SIZEOF( DRM_RLVI_RECORD ) ), /* Add ibEntries offset to the offset of the current record */
                        SIZEOF(DRM_GUID) );

        /* Correct endianness */
        FIX_ENDIAN_DWORD( rlviGUID.Data1 );
        FIX_ENDIAN_WORD( rlviGUID.Data2 );
        FIX_ENDIAN_WORD( rlviGUID.Data3 );

        /* Extract the CRL version from the iRev-th DRM_RLVI_RECORD in the revinfo */
        NETWORKBYTES_TO_QWORD( qwrlviVersion,
                        f_pbRevInfo,
                        f_prlvi->ibEntries + ( iRev * SIZEOF( DRM_RLVI_RECORD ) ) + SIZEOF( DRM_GUID ) );  /* Add ibEntries offset to the offset of the current record and skip the GUID */
        dwrlviVersion = DRM_I64ToUI32(qwrlviVersion);

        if ( 0 == MEMCMP(&rlviGUID, f_pguidEntry, SIZEOF(DRM_GUID)) )
        {
            fFound = TRUE;
            *f_pdwVersion = dwrlviVersion;
            break;
        }
    }
ErrorExit:
    if( DRM_SUCCEEDED( dr ) )
    {
        if( fFound )
        {
            dr = DRM_SUCCESS;
        }
        else
        {
            dr = DRM_S_FALSE;
        }
    }
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVK_StoreRevInfo (
    IN     DRM_CRYPTO_CONTEXT          *f_pContextCrypto,
    IN     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN     const DRM_GUID              *f_pguidRevocationType,
    IN     DRM_BYTE                    *f_pbRevocationInfo,
    IN     DRM_DWORD                    f_cbRevocationInfo,
    IN     DRM_BYTE                    *f_pbRevocationBuffer,
    IN     DRM_DWORD                    f_cbRevocationBuffer,
    IN OUT DRM_REVLIST_ID_VALUES       *f_pRevList,
       OUT DRM_BOOL                    *f_fWasStored )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_RLVI       currentRLVI;
    DRM_RLVI       newRLVI;
    DRM_DWORD      cbTmp = 0;
    DRM_DWORD      crlVersion = 0;
#if DRM_SUPPORT_APP_REVOCATION
    DRM_DWORD      dwWMDRMAppCRLVersion = 0;
    DRM_DWORD      dwPlayReadyAppCRLVersion = 0;
#endif
#if DRM_SUPPORT_WMDRMNET
    DRM_DWORD      dwWMDRMNETCRLVersion = 0;
#endif
#if DRM_SUPPORT_DEVICE_REVOCATION
    DRM_DWORD      dwDeviceCRLVersion = 0;
#endif
    DRM_DWORD      dwRuntimeCRLVersion = 0;
    _RevocationStoreContext *pRevStore = (_RevocationStoreContext*)f_pContextRev;
    DRM_BOOL       fRIV2 = FALSE;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_StoreRevInfo );

    MEMSET( &newRLVI,       0, SIZEOF( DRM_RLVI ) );
    MEMSET( &currentRLVI,   0, SIZEOF( DRM_RLVI ) );

    ChkArg( f_pbRevocationInfo != NULL
     && f_cbRevocationInfo != NULL
     && f_pbRevocationBuffer != NULL
     && f_cbRevocationBuffer > 0
     && f_pContextRev  != NULL );

    if ( 0 == MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeRevInfo2, SIZEOF( DRM_GUID ) ) )
    {
        fRIV2 = TRUE;
    }
    else if ( 0 != MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeRevInfo,  SIZEOF( DRM_GUID ) ) )
    {
        ChkDR( DRM_E_REVOCATION_GUID_NOT_RECOGNIZED );
    }

    if( f_fWasStored != NULL )
    {
        *f_fWasStored = FALSE;
    }

    /* Verify the one from the license response is a good one */
    ChkDR( DRM_RVK_VerifyRevocationInfo( f_pbRevocationInfo,
                                         f_cbRevocationInfo,
                                         &newRLVI,
                                         f_pContextCrypto,
                                         pRevStore->pContextBB,
                                         pRevStore->pContextSST,
                                         pRevStore->pDatastore) );

    cbTmp = f_cbRevocationBuffer;
    ChkDR( DRM_RVK_GetCurrentRevocationInfo( f_pContextRev,
                                             f_pguidRevocationType,
                                             f_pbRevocationBuffer,
                                             &cbTmp,
                                             &currentRLVI,
                                             f_pContextCrypto ) );

    /*
    ** Parse the RevInfo structure currently loaded into the revocation buffer
    ** and retrieve the version numbers for each possible CRL. The FindEntry
    ** function will return DRM_NO_PREVIOUS_CRL for CRLs the RIV has no comment
    ** on.
    */

#if DRM_SUPPORT_APP_REVOCATION
    ChkDR( DRM_RVK_FindEntryInRevInfo( &newRLVI, f_pbRevocationInfo, f_cbRevocationInfo, &g_guidRevocationTypeApp, &dwWMDRMAppCRLVersion) );
    ChkDR( DRM_RVK_FindEntryInRevInfo( &newRLVI, f_pbRevocationInfo, f_cbRevocationInfo, &g_guidRevocationTypePlayReadySilverLightApplication, &dwPlayReadyAppCRLVersion) );
#endif /* DRM_SUPPORT_APP_REVOCATION */

#if DRM_SUPPORT_DEVICE_REVOCATION
    ChkDR( DRM_RVK_FindEntryInRevInfo( &newRLVI, f_pbRevocationInfo, f_cbRevocationInfo, &g_guidRevocationTypeDevice, &dwDeviceCRLVersion) );
#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

#if DRM_SUPPORT_WMDRMNET
    ChkDR( DRM_RVK_FindEntryInRevInfo( &newRLVI, f_pbRevocationInfo, f_cbRevocationInfo, &g_guidRevocationTypeWMDRMNET, &dwWMDRMNETCRLVersion) );
#endif /* DRM_SUPPORT_WMDRMNET */

    ChkDR( DRM_RVK_FindEntryInRevInfo( &newRLVI, f_pbRevocationInfo, f_cbRevocationInfo, &g_guidRevocationTypePlayReadySilverLightRuntime, &dwRuntimeCRLVersion) );

    /*
    ** For each CRL located above, find the corresponding version in the HDS.
    ** The version in the HDS ***must*** be equal or newer than the version
    ** in the RIV. We can't store the RIV if this is not true.
    */

#if DRM_SUPPORT_APP_REVOCATION
    if ( dwWMDRMAppCRLVersion != DRM_NO_PREVIOUS_CRL )
    {
        cbTmp = f_cbRevocationBuffer;
        ChkDR( DRM_RVK_GetCurrentAppRevocationList( f_pContextRev,
                                                    f_pbRevocationBuffer,
                                                    &cbTmp,
                                                    &crlVersion) );

        if( f_pRevList != NULL )
        {
            if( f_pRevList->wmdrmapp != crlVersion )
            {
                f_pRevList->wmdrmapp = crlVersion;
                f_pRevList->fUpdatedRevocationList = TRUE;
            }
        }

        if ( crlVersion < dwWMDRMAppCRLVersion )
        {
            /* Don't update the HDS's RIV - it's CRLs haven't been stored! */
            goto ErrorExit;
        }
    }

    if ( dwPlayReadyAppCRLVersion != DRM_NO_PREVIOUS_CRL )
    {
        cbTmp = f_cbRevocationBuffer;
        ChkDR(_GetPlayReadyRevocationList( f_pContextCrypto,
                                           f_pContextRev,
                                           &g_guidRevocationTypePlayReadySilverLightApplication,
                                           f_pbRevocationBuffer,
                                           &cbTmp,
                                           &crlVersion));
        if( f_pRevList != NULL )
        {
            if( f_pRevList->playreadyapp != crlVersion )
            {
                f_pRevList->playreadyapp = crlVersion;
                f_pRevList->fUpdatedRevocationList = TRUE;
            }
        }

        if ( crlVersion < dwPlayReadyAppCRLVersion )
        {
            /* Don't update the HDS's RIV - it's CRLs haven't been stored! */
            goto ErrorExit;
        }

    }

#endif /* DRM_SUPPORT_APP_REVOCATION */

#if DRM_SUPPORT_DEVICE_REVOCATION
    if ( dwDeviceCRLVersion != DRM_NO_PREVIOUS_CRL )
    {
        cbTmp = f_cbRevocationBuffer;
        ChkDR( DRM_RVK_GetDeviceRevocationList( f_pContextCrypto,
                                                f_pContextRev,
                                                f_pbRevocationBuffer,
                                                &cbTmp,
                                                &crlVersion) );

        if( f_pRevList != NULL )
        {
            if( f_pRevList->device != crlVersion )
            {
                f_pRevList->device = crlVersion;
                f_pRevList->fUpdatedRevocationList = TRUE;
            }
        }

        if ( crlVersion < dwDeviceCRLVersion )
        {
            /* Don't update the HDS's RIV - it's CRLs haven't been stored! */
            goto ErrorExit;
        }
    }
#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

#if DRM_SUPPORT_WMDRMNET
    if ( dwWMDRMNETCRLVersion != DRM_NO_PREVIOUS_CRL )
    {
        cbTmp = f_cbRevocationBuffer;
        ChkDR( DRM_RVK_GetWMDRMNETList( f_pContextCrypto,
                                        f_pContextRev,
                                        f_pbRevocationBuffer,
                                        &cbTmp,
                                        &crlVersion) );
        if( f_pRevList != NULL )
        {
            if( f_pRevList->wmdrmnet != crlVersion )
            {
                f_pRevList->wmdrmnet = crlVersion;
                f_pRevList->fUpdatedRevocationList = TRUE;
            }
        }

        if ( crlVersion < dwWMDRMNETCRLVersion )
        {
            /* Don't update the HDS's RIV - it's CRLs haven't been stored! */
            goto ErrorExit;
        }
    }
#endif /* DRM_SUPPORT_WMDRMNET */

    if ( dwRuntimeCRLVersion != DRM_NO_PREVIOUS_CRL )
    {
        cbTmp = f_cbRevocationBuffer;
        ChkDR(_GetPlayReadyRevocationList( f_pContextCrypto,
                                           f_pContextRev,
                                           &g_guidRevocationTypePlayReadySilverLightRuntime,
                                           f_pbRevocationBuffer,
                                           &cbTmp,
                                           &crlVersion ));
        if( f_pRevList != NULL )
        {
            if( f_pRevList->runtime != crlVersion )
            {
                f_pRevList->runtime = crlVersion;
                f_pRevList->fUpdatedRevocationList = TRUE;
            }
        }

        if ( crlVersion < dwRuntimeCRLVersion )
        {
            /* Don't update the HDS's RIV - it's CRLs haven't been stored! */
            goto ErrorExit;
        }

    }

    /* If each stored version matches the corresponding rlvi version, then store the rlvi */
    if ( newRLVI.head.dwRIV > currentRLVI.head.dwRIV )
    {
        /* Storing binary revocation info */
        ChkDR( DRM_RVS_StoreRevocationData( f_pContextRev,
                                            f_pguidRevocationType,
                                            f_pbRevocationInfo,
                                            f_cbRevocationInfo ) );
        if (f_pRevList != NULL)
        {
            if( fRIV2 )
            {
                f_pRevList->riv2 = newRLVI.head.dwRIV;
            }
            else
            {
                f_pRevList->riv = newRLVI.head.dwRIV;
            }
            f_pRevList->fUpdatedRevocationList = TRUE;
        }

        if( f_fWasStored != NULL )
        {
            *f_fWasStored = TRUE;
        }
    }

    /*
     *  dr could still be S_FALSE from a prior call to FindEntryInRevInfo.
     *  Set it to success here.
     */
    dr = DRM_SUCCESS;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;

}

/*****************************************************************************
** Function: DRM_RVK_ProcessRevocationInfo
**
** Synopsis:
** processes the revocation info struct from the license response and updates
** the revinfo and revocations stored on the device if necessary
**
** Arguments:
** [f_pDrmContext]          -- DRM context
** [f_pdastrLicenseResponse]-- license response XML string
*****************************************************************************/
/*
Note: this function only works for legacy wmdrm app certs and will only support
pre-playready types of crls and rev info.
*/

DRM_API DRM_RESULT DRM_CALL DRM_RVK_ProcessRevocationInfo (
    IN     DRM_CRYPTO_CONTEXT          *f_pContextCrypto,
    IN     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN     DRM_ANSI_CONST_STRING       *f_pdastrLicenseResponse,
    IN     DRM_BYTE                    *f_pbRevocationBuffer,
    IN     DRM_DWORD                    f_cbRevocationBuffer,
    IN     APPCERT                     *f_pAppcert,
    IN OUT DRM_REVLIST_ID_VALUES       *f_pRevList )
{
    DRM_RESULT     dr                    = DRM_SUCCESS;
    DRM_BYTE      *pbLicenseResponse     = 0;
    DRM_SUBSTRING  dasstrLicenseResponse = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING  dasstrDataWithoutTags = EMPTY_DRM_SUBSTRING;
    DRM_BYTE      *pbNewRevocationInfo   = NULL;
    DRM_DWORD      cbNewRevocationInfo   = 0;
    DRM_DWORD      iRev                  = 0 ;
    DRM_SUBSTRING  dasstrRevocationList  = EMPTY_DRM_SUBSTRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_ProcessRevocationInfo );

    ChkArg( f_pdastrLicenseResponse            != NULL
         && f_pdastrLicenseResponse->pszString != NULL
         && f_pdastrLicenseResponse->cchString != 0
         && f_pRevList != NULL
         && f_pContextCrypto != NULL
         && f_pContextRev  != NULL );

    pbLicenseResponse = (DRM_BYTE*)f_pdastrLicenseResponse->pszString;
    dasstrLicenseResponse.m_cch = f_pdastrLicenseResponse->cchString;

/* if any of revocation types is defined */
#if DRM_SUPPORT_APP_REVOCATION || DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_WMDRMNET

    /* foreach revocation type we care about, get it out of the license response, and store if the version is newer */
    for (iRev = 0; iRev < NO_OF(g_arevDispatch); iRev++)
    {
        dr = _ExtractRevocationList( f_pdastrLicenseResponse,
                                     g_arevDispatch [iRev].pdastrTypeGuid,
                                     &dasstrRevocationList );

        if ( dr == DRM_E_XMLNOTFOUND )
        {
            dr = _ExtractRevocationList( f_pdastrLicenseResponse,
                                         g_arevDispatch [iRev].pdastrType,
                                         &dasstrRevocationList );
            if ( dr == DRM_E_XMLNOTFOUND )
            {
                ChkDR(DRM_SUCCESS);  /* This sets 'dr' and keeps the PREfast tool happy. */
                continue;
            }
        }
        ChkDR(dr);

        switch ( g_arevDispatch[iRev].eType )
        {
        case DRM_REVOCATION_TYPE_WMDRM_APP:
#if DRM_SUPPORT_APP_REVOCATION
            ChkDR( DRM_RVK_UpdateAppRevocationListA( f_pContextCrypto,
                                                     f_pContextRev,
                                                     f_pbRevocationBuffer,
                                                     f_cbRevocationBuffer,
                                          (DRM_CHAR*)f_pdastrLicenseResponse->pszString,
                                                    &dasstrRevocationList,
                                                     f_pAppcert,
                                                     f_pRevList->wmdrmapp,
                                                    &f_pRevList->fUpdatedRevocationList ) );
#endif /* DRM_SUPPORT_APP_REVOCATION */
            break;

        case DRM_REVOCATION_TYPE_WMDRM_DEVICE:
#if DRM_SUPPORT_DEVICE_REVOCATION
            ChkDR( DRM_RVK_UpdateRevocationList( f_pContextCrypto,
                                          f_pContextRev,
                               (DRM_CHAR*)f_pdastrLicenseResponse->pszString,
                                         &dasstrRevocationList,
                                          f_pbRevocationBuffer,
                                          f_cbRevocationBuffer,
                                          g_arevDispatch[iRev].pguid,
                                          g_arevDispatch[iRev].ppubkey ) );
#endif /* DRM_SUPPORT_DEVICE_REVOCATION */
            break;
        case DRM_REVOCATION_TYPE_WMDRM_ND:
#if DRM_SUPPORT_WMDRMNET
            ChkDR( DRM_RVK_UpdateWMDRMNETRevocationList(
                                          f_pContextCrypto,
                                          f_pContextRev,
                               (DRM_CHAR*)f_pdastrLicenseResponse->pszString,
                                         &dasstrRevocationList,
                                          f_pbRevocationBuffer,
                                          f_cbRevocationBuffer,
                                          g_arevDispatch[iRev].ppubkey ) );

#endif /* DRM_SUPPORT_WMDRMNET */
            break;
        default:
            ChkDR(DRM_E_INVALIDARG);
            break;
        }
    }
#else /* DRM_SUPPORT_APP_REVOCATION || DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_WMDRMNET */

    ChkDR(DRM_E_NOTIMPL);

#endif /* DRM_SUPPORT_APP_REVOCATION || DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_WMDRMNET */

    /*
      Process the revocation info struct from the license response after the
      CRLs in the license response if present are processed.
    */

    dr = DRM_XML_GetSubNodeA((DRM_CHAR*)pbLicenseResponse,
                            &dasstrLicenseResponse,
                            &g_dastrTagRevocationInfo,
                             NULL,
                             NULL,
                             0,
                             NULL,
                            &dasstrDataWithoutTags,
                             1);
    if ( DRM_E_XMLNOTFOUND == dr )
    {
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }
    ChkDR(dr);

     /* pbOffset will point within the base64 revocation list we were passed,
       such that after base64 decoding the end of the decoded data will co-incide with
       the end of the buffer we were given, minus one byte.

       This is because we are giving the B64 decoder overlapping memory for source and desitination,
       and we can't use the DECODE_IN_PLACE flag because this is ANSI where the offset may not coincide
       with a word boundary as required on 16-bit platforms.
     */

    pbNewRevocationInfo = pbLicenseResponse
                        + __CB_DECL( dasstrDataWithoutTags.m_ich + dasstrDataWithoutTags.m_cch - CB_BASE64_DECODE( dasstrDataWithoutTags.m_cch ) - 1 )
                        + ( ( dasstrDataWithoutTags.m_ich + dasstrDataWithoutTags.m_cch - CB_BASE64_DECODE( dasstrDataWithoutTags.m_cch ) ) % CB_NATIVE_BYTE );

    cbNewRevocationInfo = CB_BASE64_DECODE( dasstrDataWithoutTags.m_cch ) + 1 - ( ( dasstrDataWithoutTags.m_ich + dasstrDataWithoutTags.m_cch - CB_BASE64_DECODE( dasstrDataWithoutTags.m_cch ) ) % CB_NATIVE_BYTE );


    /* decode the XML for the new revocation info in place */
    ChkDR( DRM_B64_DecodeA( (const DRM_CHAR*)pbLicenseResponse,
                           &dasstrDataWithoutTags,
                           &cbNewRevocationInfo,
                            pbNewRevocationInfo,
                            0 ) );

    ChkDR( DRM_RVK_StoreRevInfo( f_pContextCrypto,
                            f_pContextRev,
                           &g_guidRevocationTypeRevInfo,
                            pbNewRevocationInfo,
                            cbNewRevocationInfo,
                            f_pbRevocationBuffer,
                            f_cbRevocationBuffer,
                            f_pRevList,
                            NULL ) );

ErrorExit:

    /*
    ** Update the cached revocation version numbers. Do so regardless of the
    ** overall result of the update.
    */
    DRM_RVK_UpdateRevocationVersionsCache( f_pContextRev,
                                           f_pContextCrypto,
                                           f_pRevList,
                                           f_pbRevocationBuffer,
                                           f_cbRevocationBuffer,
                                           NULL );

    if( ( dasstrDataWithoutTags.m_cch != 0 )
        && ( f_pdastrLicenseResponse != NULL )
        && ( f_pdastrLicenseResponse->pszString != NULL ))
    {
        /* Since we decoded in-place, we need to clean up otherwise the XML parsing may
         * not work properly later on. So we have to overwrite our binary with spaces.
         *
         * NOTE: This means that we CANNOT process the same revocation list in the same
         * license response buffer twice since we're overwriting the buffer we were given
         */
        DRM_BYT_SetBytes( (DRM_BYTE*)f_pdastrLicenseResponse->pszString, dasstrDataWithoutTags.m_ich, dasstrDataWithoutTags.m_cch, ' ');
    }

    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        dr = DRM_E_REVOCATION_BUFFERTOOSMALL;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/******************************************************************************
**
**  Function    :   DRM_RVK_GetCRL
**
**  Synopsis    :   This function returns the CRL corresponding to the GUID
**
**  Arguments   :   IN      f_guidRevocationType : The GUID for Revocation Type
**                  OUT     f_pbCRL              : contains the CRL if retrieved
**                  IN OUT  f_pcbCRL             : size of CRL in bytes
**                  OUT     f_pqwCRLVersion      : CRL version
**                  IN      f_pcontextBBX        : Blackbox context
**                  IN      f_pcontextHDS        : HDS context
**                  IN      f_rgbPassword        : Revocation store password
**
**  Returns     :   DRM_SUCCESS            :If the CRL was successfully retrieved
**              :   DRM_E_BUFFER_TOO_SMALL :If the size of f_pbCRL is less than the
**                                          the size of CRL.
**                  DRM_E_FILENOTFOUND     :If no CRL was found in the store.
**
******************************************************************************/
DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVK_GetCRL(
    IN     DRM_CRYPTO_CONTEXT           *f_pContextCrypto,
    IN     DRM_REVOCATIONSTORE_CONTEXT  *f_pContextRev,
    IN     const DRM_GUID               *f_pguidRevocationType,
    __out_bcount_opt( *f_pcbCRL ) DRM_BYTE *f_pbCRL,
    IN OUT DRM_DWORD                    *f_pcbCRL,
       OUT DRM_DWORD                    *f_pdwCRLVersion)
{
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_DWORD  dwVersion = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_GetCRL );

    ChkArg(f_pcbCRL        != NULL
        && f_pContextRev   != NULL);

#if DRM_SUPPORT_WMDRMNET
    if (0 == MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeWMDRMNET, SIZEOF(DRM_GUID)))
    {
        ChkDR(DRM_RVK_GetWMDRMNETList(f_pContextCrypto,
                                      f_pContextRev,
                                      f_pbCRL,
                                      f_pcbCRL,
                                     &dwVersion));
    }
    else
#endif
#if DRM_SUPPORT_DEVICE_REVOCATION
    if (0 == MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeDevice, SIZEOF(DRM_GUID)))
    {
        ChkDR(DRM_RVK_GetDeviceRevocationList( f_pContextCrypto,
                                               f_pContextRev,
                                               f_pbCRL,
                                               f_pcbCRL,
                                               &dwVersion ) );
    }
    else
#endif
#if DRM_SUPPORT_APP_REVOCATION
    if (0 == MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeApp, SIZEOF(DRM_GUID)))
    {
            ChkDR(DRM_RVK_GetCurrentAppRevocationList( f_pContextRev,
                                                       f_pbCRL,
                                                       f_pcbCRL,
                                                      &dwVersion ) );
    }
    else
#endif
    if ( ( 0 == MEMCMP( f_pguidRevocationType, &g_guidRevocationTypePlayReadySilverLightRuntime,     SIZEOF( DRM_GUID ) ) )
      || ( 0 == MEMCMP( f_pguidRevocationType, &g_guidRevocationTypePlayReadySilverLightApplication, SIZEOF( DRM_GUID ) ) ) )
    {
        ChkDR(_GetPlayReadyRevocationList(f_pContextCrypto,
                                                 f_pContextRev,
                                                 f_pguidRevocationType,
                                                 f_pbCRL,
                                                 f_pcbCRL,
                                                &dwVersion));
    }
    else
    /* REV_INFO and REV_INFO v2 */
    if ( ( 0 == MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeRevInfo,  SIZEOF( DRM_GUID ) ) )
      || ( 0 == MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeRevInfo2, SIZEOF( DRM_GUID ) ) ) )
    {
        DRM_RLVI RLVI;
        ChkDR( DRM_RVK_GetCurrentRevocationInfo( f_pContextRev,
                                                 f_pguidRevocationType,
                                                 f_pbCRL,
                                                 f_pcbCRL,
                                                &RLVI,
                                                 f_pContextCrypto ) );
        dwVersion = RLVI.head.dwRIV;
    }
    else
    {
        /*
        ** Error on unrecognized CRLs since they weren't stored (see comment in DRM_RVK_SetCRL).
        */
        ChkDR( DRM_E_REVOCATION_GUID_NOT_RECOGNIZED );
    }

    if( f_pdwCRLVersion != NULL )
    {
        *f_pdwCRLVersion = dwVersion;
    }

ErrorExit:
    if ( dr == DRM_E_FILENOTFOUND )
    {
        /*
        **  when we dont' have CRL in the secure store. We shouldn't return an error; instead return S_FALSE
        */
        if( f_pdwCRLVersion != NULL )
        {
            *f_pdwCRLVersion = 0;
        }
        *f_pcbCRL = 0;

        dr = DRM_S_FALSE;
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#if DRM_SUPPORT_3RDPARTY_REVOCATION
/******************************************************************************
**
**  Function    :   _VerifyOEMGUID
**
**  Synopsis    :   This function verifies that the GUID inside the OEM wrapper is
**                  the same as the one passed in as the identifying GUID.
**
**  Arguments   :   IN f_guidRevocationType : The GUID for Revocation Type
**                  IN f_pbCRL              : contains the CRL
**                  IN f_cbCRL              : size of CRL in bytes
**
**  Returns     :   DRM_SUCCESS            :If the CRL was successfully retrieved
**              :   DRM_E_INVALIDARG       :If the GUIDs are not equal
**                  Other Error codes can be returned.
******************************************************************************/
static DRM_RESULT _VerifyOEMGUID(
    IN DRM_GUID  f_guidRevocationType,
    IN DRM_BYTE *f_pbCRL,
    IN DRM_DWORD f_cbCRL)
{
    DRM_RESULT        dr           = DRM_SUCCESS;
    DRM_CONST_STRING dstrCRL      = EMPTY_DRM_STRING;
    DRM_GUID         guid         = { 0 };

    DSTR_FROM_PB(&dstrCRL, f_pbCRL, f_cbCRL);

    ChkDR(DRM_RVK_GetOEMRevocationListGUID(&dstrCRL, (DRM_GUID *) &guid));

    ChkArg(IDENTICAL_GUIDS(&guid, &f_guidRevocationType));

ErrorExit:
    return dr;
}
#endif

/******************************************************************************
**
**  Function    :   DRM_RVK_SetCRL
**
**  Synopsis    :   This function stores the CRL in the HDS corresponding to the GUID.
**
**  Arguments   :   IN      f_guidRevocationType : The GUID for Revocation Type
**                  IN      f_pbCRL              : contains the CRL to be stored
**                  IN      f_pcbCRL             : size of CRL in bytes
**                  IN      f_pcontextBBX        : Blackbox context
**                  IN      f_pcontextHDS        : HDS context
**                  IN      f_rgbPassword        : Revocation store password
**                  OUT     f_pfUpdated          : The flag indicates the CRL
**                                                 was updated in the HDS or not.
**
**  Returns     :   DRM_SUCCESS            :If the CRL was successfully stored
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_RVK_SetCRL(
    IN     DRM_CRYPTO_CONTEXT           *f_pContextCrypto,
    IN     DRM_REVOCATIONSTORE_CONTEXT  *f_pContextRev,
    IN     const DRM_GUID               *f_pguidRevocationType,
    __in_bcount( f_cbCRL ) DRM_BYTE *f_pbCRL,
    IN     DRM_DWORD                     f_cbCRL,
    __in_bcount( f_cbRevocationBuffer ) DRM_BYTE *f_pbRevocationBuffer,
    IN     DRM_DWORD                     f_cbRevocationBuffer,
    IN OUT DRM_BOOL                     *f_pfUpdated)
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_REVOCATION, PERF_FUNC_DRM_RVK_SetCRL );

    ChkArg( f_pfUpdated != NULL );
    *f_pfUpdated = FALSE;

#if DRM_SUPPORT_WMDRMNET
    /* WMDRMNET Revocation Lists */
    if (0 == MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeWMDRMNET, SIZEOF(DRM_GUID)))
    {
        ChkDR(_UpdateWMDRMNETRevocationList(f_pContextCrypto,
                                            f_pContextRev,
                                            f_pbCRL,
                                            f_cbCRL,
                                            f_pbRevocationBuffer,
                                            f_cbRevocationBuffer,
                                            f_pfUpdated,
                                            NULL));
    }
    else
#endif
#if DRM_SUPPORT_DEVICE_REVOCATION
    /* WMDRM Device Revocation Lists */
    if (0 == MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeDevice, SIZEOF(DRM_GUID)))
    {
        ChkDR(_UpdateRevocationList(f_pContextCrypto,
                                    f_pContextRev,
                                    f_pbCRL,
                                    f_cbCRL,
                                    f_pbRevocationBuffer,
                                    f_cbRevocationBuffer,
                                    &g_guidRevocationTypeDevice,
                                    &g_pubkeyDeviceRevocation,
                                    f_pfUpdated) );
    }
    else
#endif
#if DRM_SUPPORT_APP_REVOCATION
    /* App Revocation Lists */
    if (0 == MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeApp, SIZEOF(DRM_GUID)))
    {
        DRM_CONST_STRING dstr = EMPTY_DRM_STRING;

        DSTR_FROM_PB( &dstr, f_pbCRL, f_cbCRL );

        ChkDR(DRM_RVK_UpdateAppRevocationListW(f_pContextCrypto,
                                               f_pContextRev,
                                               f_pbRevocationBuffer,
                                               f_cbRevocationBuffer,
                                               &dstr,
                                               NULL,
                                               0,
                                               f_pfUpdated,
                                               NULL) );
    }
    else
#endif
    if ( ( 0 == MEMCMP( f_pguidRevocationType, &g_guidRevocationTypePlayReadySilverLightRuntime,     SIZEOF( DRM_GUID ) ) )
      || ( 0 == MEMCMP( f_pguidRevocationType, &g_guidRevocationTypePlayReadySilverLightApplication, SIZEOF( DRM_GUID ) ) ) )
    {
        ChkDR(_SetPlayReadyRevocationList(f_pContextCrypto,
                                          f_pContextRev,
                                          f_pguidRevocationType,
                                          f_pbCRL,
                                          f_cbCRL,
                                          f_pbRevocationBuffer,
                                          f_cbRevocationBuffer,
                                          f_pfUpdated,
                                          NULL));
    }
    else
    /* REV_INFO and REV_INFO v2 */
    if ( ( 0 == MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeRevInfo,  SIZEOF( DRM_GUID ) ) )
      || ( 0 == MEMCMP(f_pguidRevocationType, &g_guidRevocationTypeRevInfo2, SIZEOF( DRM_GUID ) ) ) )
    {
        ChkDR(DRM_RVK_StoreRevInfo(f_pContextCrypto,
                                   f_pContextRev,
                                   f_pguidRevocationType,
                                   f_pbCRL,
                                   f_cbCRL,
                                   f_pbRevocationBuffer,
                                   f_cbRevocationBuffer,
                                   NULL,
                                   f_pfUpdated));
    }
    else
    {
        /*
        ** Do not store unrecognized CRLs.
        */
        dr = DRM_SUCCESS;
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

EXIT_PK_NAMESPACE_CODE;

#endif /* DRM_SUPPORT_REVOCATION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmsha256.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmprofile.h>
#include "drmsha256.h"
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

/*
** Globals
*/

/*
** Magic numbers use in SHA256
*/
static const DRM_DWORD g_rgdwSHA256Magic[ 64 ] = 
{
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

/*
** Defines
*/

/*
** Define the shift and rotate operators
*/
#define SHA256_SHIFT_RIGHT( b, x )    ( ( x ) >> ( b ) )
#define SHA256_SHIFT_LEFT( b, x )     ( ( x ) << ( b ) )
#define SHA256_ROTATE_LEFT( x, n )   ( ( ( x ) << ( n ) ) | ( ( x ) >> ( 32 - ( n ) ) ) )
#define SHA256_ROTATE_RIGHT( x, n )  ( ( ( x ) >> ( n ) ) | ( ( x ) << ( 32 - ( n ) ) ) )

/*
** logical functions used in SHA-256
*/
#define __F( x, y, z ) ( ( ( x) & ( y ) ) ^ ( (~( x ) ) & ( z ) ) )
#define __G( x, y, z ) ( ( ( x) & ( y ) ) ^ ( ( x) & ( z ) ) ^ ( ( y ) & ( z ) ) )

#define __H( x ) (  SHA256_ROTATE_RIGHT( ( x ),  2 )    \
                  ^ SHA256_ROTATE_RIGHT( ( x ), 13 )    \
                  ^ SHA256_ROTATE_RIGHT( ( x ), 22 ) )
#define __I( x ) (  SHA256_ROTATE_RIGHT( ( x ),  6 )    \
                  ^ SHA256_ROTATE_RIGHT( ( x ), 11 )    \
                  ^ SHA256_ROTATE_RIGHT( ( x ), 25 ) )
#define __J( x ) (  SHA256_ROTATE_RIGHT( ( x ),  7 )    \
                  ^ SHA256_ROTATE_RIGHT( ( x ), 18 )    \
                  ^ SHA256_SHIFT_RIGHT( 3, ( x ) ) )
#define __K( x ) (  SHA256_ROTATE_RIGHT( ( x ), 17 )    \
                  ^ SHA256_ROTATE_RIGHT( ( x ), 19 )    \
                  ^ SHA256_SHIFT_RIGHT( 10, ( x ) ) )


#define SHA256_ROUNDINIT( a, b, c, d, e, f, g, h )         \
    dwTemp =   ( h ) + __I( e ) + __F( ( e ), ( f ), ( g ) )   \
           + g_rgdwSHA256Magic[ dwRound ] + pdwW256[ dwRound ];      \
    ( d ) += dwTemp;                                           \
    ( h ) = dwTemp + __H( a ) + __G( ( a ), ( b ), ( c ) );    \
    dwRound++

#define SHA256_ROUND( a, b, c, d, e, f, g, h )                                              \
    dwS0 = pdwW256[ ( dwRound + 1 ) & 0x0f ];                                                   \
    dwS0 = __J( dwS0 );                                                                         \
    dwS1 = pdwW256[ ( dwRound + 14) & 0x0f ];                                                   \
    dwS1 = __K( dwS1 );                                                                         \
    dwTemp =   ( h ) + __I( e ) + __F( ( e ), ( f ), ( g ) )                                    \
           +  g_rgdwSHA256Magic[ dwRound ]                                                            \
           + ( pdwW256[ dwRound & 0x0f ] += dwS1 + pdwW256[ ( dwRound + 9 ) & 0x0f ] + dwS0 );  \
    ( d ) += dwTemp;                                                                \
    ( h ) = dwTemp + __H( a ) + __G( ( a ), ( b ), ( c ) );                         \
    dwRound++

#define SHA256_REVERSE32( w, x )                                           \
{                                                                              \
    DRM_DWORD tmp = ( w );                                                     \
    tmp = ( tmp >> 16 ) | ( tmp << 16 );                                       \
    ( x ) = ( ( tmp & 0xff00ff00UL ) >> 8 ) | ( ( tmp & 0x00ff00ffUL ) << 8 ); \
}

#define SHA256_REVERSE32_64( w, x )  ( x ) = ( DRM_UINT64 )_rotr64( _byteswap_uint64( w ), 32 )


#if TARGET_LITTLE_ENDIAN

#define SHA256_DWORDTOBIGENDIAN( __rgbBytes, __rgdwDwords, __cdwDwords )                    \
{                                                                                           \
    DRM_DWORD  __i;                                                                         \
    DRM_DWORD  __temp;                                                                      \
    for ( __i = 0 ; __i < __cdwDwords; ++__i )                                              \
    {                                                                                       \
        SHA256_REVERSE32( __rgdwDwords[ __i ], __temp );                                    \
        MEMCPY( __rgbBytes + ( __i * SIZEOF( DRM_DWORD ) ), &__temp, SIZEOF( DRM_DWORD ) ); \
    } /* end for */                                                                         \
}
#else /* must be big endian */
#define SHA256_DWORDTOBIGENDIAN( __rgbBytes, __rgdwDwords, __cdwDwords )                    \
{                                                                                           \
    MEMCPY( __rgbBytes, ( DRM_BYTE* )__rgdwDwords, __cdwDwords * SIZEOF( DRM_DWORD ) );     \
}   
#endif

/*
** Function Prototypes
*/

static DRM_RESULT _SHA256_Transform(
    __inout_ecount( SHA256_STATE_SIZE_IN_DWORDS )       DRM_DWORD f_rgdwState[],
    __in_ecount( SHA256_BLOCK_SIZE_IN_DWORDS )    const DRM_DWORD f_rgdwBlock[] );


/*
** Function Definitions
*/

/*************************************************************************************************
**
** Function: DRM_SHA256_Init
**
** Description: Initialize the sha256 context structure. To do full SHA256 hashing run funct in
**              this order: 1x DRM_SHA256_Init, (0-inf)x DRM_SHA256_Update, 1x DRM_SHA256_Finalize
**
** Args:
**    [f_pShaContext]: Current running sha256 context
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SHA256_Init(
    __in_ecount( 1 ) DRM_SHA256_Context *f_pShaContext )
{
    /*
    ** Decls
    */
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMSHA256, PERF_FUNC_DRM_SHA256_Init );

    /*
    ** Arg Check
    */
    ChkArg( NULL != f_pShaContext );
    
    f_pShaContext->m_rgUnion.m_rgdwState[ 0 ] = 0x6a09e667;
    f_pShaContext->m_rgUnion.m_rgdwState[ 1 ] = 0xbb67ae85;
    f_pShaContext->m_rgUnion.m_rgdwState[ 2 ] = 0x3c6ef372;
    f_pShaContext->m_rgUnion.m_rgdwState[ 3 ] = 0xa54ff53a;
    f_pShaContext->m_rgUnion.m_rgdwState[ 4 ] = 0x510e527f;
    f_pShaContext->m_rgUnion.m_rgdwState[ 5 ] = 0x9b05688c;
    f_pShaContext->m_rgUnion.m_rgdwState[ 6 ] = 0x1f83d9ab;
    f_pShaContext->m_rgUnion.m_rgdwState[ 7 ] = 0x5be0cd19;

    f_pShaContext->m_rgdwCount[ 0 ] = 0;
    f_pShaContext->m_rgdwCount[ 1 ] = 0;

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
} /* end DRM_SHA256Init */

/*************************************************************************************************
**
** Function: DRM_SHA256_Update
**
** Description: Insert data to be hashed in the current sha 256 context. Some hashing takes place
**              in this function out of place.
**
** Args:
**    [f_pShaContext]: Current running sha context
**    [f_rgbBuffer]:   Buffer to perform sha256 on
**    [f_cbBuffer]:    Length of the [f_rgbBuffer] buffer
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SHA256_Update(
    __inout_ecount( 1 )             DRM_SHA256_Context *f_pShaContext,
    __in_ecount( f_cbBuffer ) const DRM_BYTE            f_rgbBuffer[],
    __in                            DRM_DWORD           f_cbBuffer )
{
    return DRM_SHA256_UpdateOffset( f_pShaContext, f_rgbBuffer, f_cbBuffer, 0 );
} /* end DRM_SHA256_Update */ 


/*************************************************************************************************
**
** Function: DRM_SHA256_UpdateOffset 
**
** Description: Insert data to be hashed in the current sha 256 context. Some hashing takes place
**              in this function out of place.
**
** Args:
**    [f_pShaContext]:    Current running sha context
**    [f_rgbBuffer]:      Buffer to perform sha256 on
**    [f_cbBuffer]:       Length of [f_rgbBuffer] buffer to hash (after the offset)
**    [f_ibBufferOffset]: Offset in the buffer where we will begin hashing and continue up to,
**                        but not including f_rgbBuffer[f_cbBuffer + f_ibBufferOffset]
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SHA256_UpdateOffset(
    __inout_ecount( 1 )                                DRM_SHA256_Context *f_pShaContext,
    __in_ecount( f_cbBuffer + f_ibBufferOffset ) const DRM_BYTE            f_rgbBuffer[],
    __in                                               DRM_DWORD           f_cbBuffer,
    __in                                               DRM_DWORD           f_ibBufferOffset )
{
    /*
    ** Inits
    */
    DRM_DWORD  ibOffset    = f_ibBufferOffset;
    DRM_DWORD  dwBufferLen = 0;
    DRM_RESULT dr          = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMSHA256, PERF_FUNC_DRM_SHA256_Update );
    
    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_pShaContext );
    ChkArg( NULL != f_rgbBuffer );

    /*
    ** Copy the size of left over bytes in the context, this size should not
    ** have exceeded 64 (ie it has to be lower than 0x40)
    */    
    dwBufferLen = ( DRM_DWORD )( f_pShaContext->m_rgdwCount[ 1 ] & 0x3f );

    /*
    ** Update number of bytes, this will give the number of bytes left over
    ** if you mod it by 64 (or alternativly AND it with 0x3f (63) )
    */
    if ( ( f_pShaContext->m_rgdwCount[ 1 ] += f_cbBuffer ) < f_cbBuffer )
    {
        f_pShaContext->m_rgdwCount[ 0 ]++;
    } /* end if */

    /*
    ** If previous input in buffer, buffer new input and transform if possible.
    */
    if (     0 < dwBufferLen
        && ( SHA256_BLOCK_SIZE_IN_BYTES - dwBufferLen ) <= f_cbBuffer ) 
    {
        DRM_BYT_CopyBytes( ( DRM_BYTE * )f_pShaContext->m_rgdwBuffer, 
                           dwBufferLen, 
                           f_rgbBuffer, 
                           ibOffset,
                           SHA256_BLOCK_SIZE_IN_BYTES - dwBufferLen );
        ChkDR( _SHA256_Transform( f_pShaContext->m_rgUnion.m_rgdwState, 
                                  f_pShaContext->m_rgdwBuffer ) );

        ChkOverflow(ibOffset + ( SHA256_BLOCK_SIZE_IN_BYTES - dwBufferLen ), ibOffset);
        ibOffset    += ( SHA256_BLOCK_SIZE_IN_BYTES - dwBufferLen );
        f_cbBuffer  -= ( SHA256_BLOCK_SIZE_IN_BYTES - dwBufferLen );
        dwBufferLen = 0;
    } /* end if */

    if ( !IS_DWORD_ALIGNED( f_rgbBuffer + __CB_DECL( ibOffset ) ) )
    {
        /*
        ** Copy input to aligned temporary buffer and then transform
        */
        while ( f_cbBuffer >= SHA256_BLOCK_SIZE_IN_BYTES )
        {
            DRM_BYT_CopyBytes( ( DRM_BYTE * )f_pShaContext->m_rgdwBuffer,
                               0,
                               f_rgbBuffer,
                               ibOffset,
                               SHA256_BLOCK_SIZE_IN_BYTES );

            ChkDR( _SHA256_Transform( f_pShaContext->m_rgUnion.m_rgdwState, 
                                      f_pShaContext->m_rgdwBuffer ) );

            ChkOverflow(ibOffset + SHA256_BLOCK_SIZE_IN_BYTES, ibOffset);
            ibOffset    += SHA256_BLOCK_SIZE_IN_BYTES;
            f_cbBuffer  -= SHA256_BLOCK_SIZE_IN_BYTES;
        } /* end while */
    } /* end if */
    else 
    {
        /*
        ** Transform directly from input.
        */
        while ( f_cbBuffer >= SHA256_BLOCK_SIZE_IN_BYTES )
        {
            ChkDR( _SHA256_Transform( f_pShaContext->m_rgUnion.m_rgdwState, 
                                      ( DRM_DWORD * )( f_rgbBuffer + __CB_DECL( ibOffset ) ) ) );
            
            ChkOverflow(ibOffset + SHA256_BLOCK_SIZE_IN_BYTES, ibOffset);
            ibOffset    += SHA256_BLOCK_SIZE_IN_BYTES;
            f_cbBuffer  -= SHA256_BLOCK_SIZE_IN_BYTES;
        } /* end while */
    } /* end if */

    /*
    ** Save remaining input buffer if necessary. We have already store the count of
    ** bytes left over earlier in this functions.
    */
    if ( 0 != f_cbBuffer )
    {
        DRM_BYT_CopyBytes( ( DRM_BYTE * )f_pShaContext->m_rgdwBuffer, 
                           dwBufferLen, 
                           f_rgbBuffer, 
                           ibOffset, 
                           f_cbBuffer );
    } /* end if */

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
} /* end DRM_SHA256_UpdateOffset */

/*************************************************************************************************
**
** Function: DRM_SHA256_Finalize
**
** Description: Perform all the SHA256 operations on the perviously inputted data and return the 
**              the digest value.
**
** Args:
**    [f_pContext]: current running sha context
**    [f_pDigest]:  resultant sha digest from sha operation
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SHA256_Finalize(
    __inout_ecount( 1 ) DRM_SHA256_Context *f_pContext,
    __inout_ecount( 1 ) DRM_SHA256_Digest  *f_pDigest )
{
    /*
    ** Decls
    */
    DRM_DWORD  rgdwBitCount[ 2 ];         /* not initialized for perf */
    DRM_BYTE   rgbPad[ __CB_DECL( 72 ) ]; /* not initialized for perf */
    DRM_DWORD  dwPadLen;                  /* not initialized for perf */
    DRM_RESULT dr       = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMSHA256, PERF_FUNC_DRM_SHA256_Finalize );

    /*
    ** Arg Checks
    */ 
    ChkArg( NULL != f_pContext );
    ChkArg( NULL != f_pDigest );
    
    /*
    ** Compute padding: 80 00 00 ... 00 00 <bit count>
    */
    dwPadLen = SHA256_BLOCK_SIZE_IN_BYTES - ( DRM_DWORD )( f_pContext->m_rgdwCount[ 1 ] & 0x3f );
    if ( dwPadLen <= 8 )
    {
        dwPadLen += SHA256_BLOCK_SIZE_IN_BYTES;
    } /* end if */

    /* 72 is the size of rgbPad[] defined at the beginning of the function. */

    //
    // Xbox LIVE specific: disabling conversion warning (C4296) after review.
    //
    #pragma warning( disable:4296 )
    ChkArg( dwPadLen - 8 >= 0 && dwPadLen - 8 <= 72 );
    #pragma warning( default:4296 )
    //
    // End Xbox LIVE specific
    //

    /*
    ** Create the padding for the last block. 
    ** sfield: avoid DCU split by aligning fill on DWORD boundry.
    */
    MEMSET( rgbPad, 0, dwPadLen - 8 );
    rgbPad[ 0 ] = 0x80;

    rgdwBitCount[ 0 ] =   ( f_pContext->m_rgdwCount[ 0 ] << 3 ) 
                        | ( f_pContext->m_rgdwCount[ 1 ] >> 29 );
    rgdwBitCount[ 1 ] = f_pContext->m_rgdwCount[ 1 ] << 3;
    SHA256_DWORDTOBIGENDIAN( rgbPad + dwPadLen - 8, rgdwBitCount, 2 );

    /*
    ** digest padding.
    */
    ChkDR( DRM_SHA256_Update( f_pContext, rgbPad, dwPadLen ) );

    /*
    ** store digest.
    */
    SHA256_DWORDTOBIGENDIAN( f_pDigest->m_rgbDigest, 
                             f_pContext->m_rgUnion.m_rgdwState, 
                             SHA256_STATE_SIZE_IN_DWORDS );

    /*
    ** restart/scrub the context.
    */
    ChkDR( DRM_SHA256_Init( f_pContext ) );
    MEMSET( ( DRM_BYTE * )f_pContext->m_rgdwBuffer, 0, SIZEOF( f_pContext->m_rgdwBuffer ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
} /* end DRM_SHA256_Final */

/*************************************************************************************************
**
** Function: SHA256_Transform
**
** Description: Perform the SHA 256 internal transforms for a single block
**
** Args:
**   [f_rgdwState]: The current input state of the previous block hash, this value is modified
**   [f_rgdwBlock]: The next block to be hashed
**
** Returns: DRM_RESULT indicating success or the correct error code. Both parameters will be set
**          if function executes successfully.
**
** Notes:
**
*************************************************************************************************/
static DRM_NO_INLINE DRM_RESULT _SHA256_Transform(
    __inout_ecount( SHA256_STATE_SIZE_IN_DWORDS )       DRM_DWORD f_rgdwState[],
    __in_ecount( SHA256_BLOCK_SIZE_IN_DWORDS )    const DRM_DWORD f_rgdwBlock[] )
{
    #define __a rgdwABCDEFGH[ 0 ]
    #define __b rgdwABCDEFGH[ 1 ]
    #define __c rgdwABCDEFGH[ 2 ]
    #define __d rgdwABCDEFGH[ 3 ]
    #define __e rgdwABCDEFGH[ 4 ]
    #define __f rgdwABCDEFGH[ 5 ]
    #define __g rgdwABCDEFGH[ 6 ]
    #define __h rgdwABCDEFGH[ 7 ]
    
    /*
    ** Decls
    */
    DRM_UINT64  rguulW256_64[ SHA256_STATE_SIZE_IN_DWORDS ]; /* not initialized for perf, room for 64 byte block */
    DRM_DWORD  *pdwW256 = ( DRM_DWORD* )rguulW256_64;
    DRM_DWORD   rgdwABCDEFGH[ SHA256_STATE_SIZE_IN_DWORDS ]; /* not initialized for perf */
    DRM_DWORD   dwS0    /* not initialized for perf */; 
    DRM_DWORD   dwS1    /* not initialized for perf */;
    DRM_DWORD   dwTemp  /* not initialized for perf */;
    DRM_DWORD   dwRound /* not initialized for perf */;
    DRM_RESULT  dr = DRM_SUCCESS;

    /*
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMSHA256, PERF_FUNC_SHA256_Transform );
    */

    /*
    ** Arg Checks
    */
    ChkArg( NULL != f_rgdwState );
    ChkArg( NULL != f_rgdwBlock );

#if TARGET_LITTLE_ENDIAN

#if _WIN64
    {
        DRM_UINT64 *puulIn = ( DRM_UINT64* )f_rgdwBlock;
        DRM_UINT64 *puulOut = rguulW256_64;

        for ( dwRound = 0 ; dwRound < 2 ; dwRound++, puulIn += 4, puulOut += 4 )
        {
            SHA256_REVERSE32_64( puulIn[ 0 ], puulOut[ 0 ] );
            SHA256_REVERSE32_64( puulIn[ 1 ], puulOut[ 1 ] );
            SHA256_REVERSE32_64( puulIn[ 2 ], puulOut[ 2 ] );
            SHA256_REVERSE32_64( puulIn[ 3 ], puulOut[ 3 ] );
        } /* end for */
    } /* end local block for bigendian and !32-bit */
#else /* 32 bit */
    {
        DRM_DWORD *pdwIn  = ( DRM_DWORD * )f_rgdwBlock;
        DRM_DWORD *pdwOut = pdwW256;

        for ( dwRound = 0 ; dwRound < 4 ; dwRound++, pdwIn += 4, pdwOut += 4 )
        {
            SHA256_REVERSE32( pdwIn[ 0 ], pdwOut[ 0 ] );
            SHA256_REVERSE32( pdwIn[ 1 ], pdwOut[ 1 ] );
            SHA256_REVERSE32( pdwIn[ 2 ], pdwOut[ 2 ] );
            SHA256_REVERSE32( pdwIn[ 3 ], pdwOut[ 3 ] );
        } /* end for */
    } /* end local block for bigendian and !64-bit */

#endif /* end !Win64 */

#else
    MEMCPY( pdwW256, ( DRM_BYTE * )f_rgdwBlock, SHA256_BLOCK_SIZE_IN_BYTES );
#endif  /* BIGENDIAN */

    __a = f_rgdwState[ 0 ];
    __b = f_rgdwState[ 1 ];
    __c = f_rgdwState[ 2 ];
    __d = f_rgdwState[ 3 ];
    __e = f_rgdwState[ 4 ];
    __f = f_rgdwState[ 5 ];
    __g = f_rgdwState[ 6 ];
    __h = f_rgdwState[ 7 ];

    /*
    ** Do the initial rounds (1 to 16)
    */
    for ( dwRound = 0 ; dwRound < SHA256_NUM_FRONT_ITERATIONS ; )
    {
        SHA256_ROUNDINIT( __a, __b, __c, __d, __e, __f, __g, __h );
        SHA256_ROUNDINIT( __h, __a, __b, __c, __d, __e, __f, __g );
        SHA256_ROUNDINIT( __g, __h, __a, __b, __c, __d, __e, __f );
        SHA256_ROUNDINIT( __f, __g, __h, __a, __b, __c, __d, __e );
        SHA256_ROUNDINIT( __e, __f, __g, __h, __a, __b, __c, __d );
        SHA256_ROUNDINIT( __d, __e, __f, __g, __h, __a, __b, __c );
        SHA256_ROUNDINIT( __c, __d, __e, __f, __g, __h, __a, __b );
        SHA256_ROUNDINIT( __b, __c, __d, __e, __f, __g, __h, __a );
    } /* end for */

    /*
    ** Do rounds 16 to 64.
    */
    for ( dwRound; dwRound < SHA256_NUM_ITERATIONS ; )
    {
        SHA256_ROUND( __a, __b, __c, __d, __e, __f, __g, __h );
        SHA256_ROUND( __h, __a, __b, __c, __d, __e, __f, __g );
        SHA256_ROUND( __g, __h, __a, __b, __c, __d, __e, __f );
        SHA256_ROUND( __f, __g, __h, __a, __b, __c, __d, __e );
        SHA256_ROUND( __e, __f, __g, __h, __a, __b, __c, __d );
        SHA256_ROUND( __d, __e, __f, __g, __h, __a, __b, __c );
        SHA256_ROUND( __c, __d, __e, __f, __g, __h, __a, __b );
        SHA256_ROUND( __b, __c, __d, __e, __f, __g, __h, __a );
    } /* end for */

    /*
    ** Compute the current intermediate hash value
    */
    f_rgdwState[ 0 ] += __a;
    f_rgdwState[ 1 ] += __b;
    f_rgdwState[ 2 ] += __c;
    f_rgdwState[ 3 ] += __d;
    f_rgdwState[ 4 ] += __e;
    f_rgdwState[ 5 ] += __f;
    f_rgdwState[ 6 ] += __g;
    f_rgdwState[ 7 ] += __h;

ErrorExit:
    /*
    DRM_PROFILING_LEAVE_SCOPE;
    */
    return dr;

    #undef __a
    #undef __b
    #undef __c
    #undef __d
    #undef __e
    #undef __f
    #undef __g
    #undef __h
} /* end SHA256_Transform */


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmsha1.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#include <drmcommon.h>
#include <drmsha1.h>
#include <drmbytemanip.h>

ENTER_PK_NAMESPACE_CODE;

/*
    OEMNOTE: There are optimizations that could be done.
    1.  The loop ranges in SHA are static so the loop can be unrolled.  This will make larger code but will be faster.
    2.  If loop is unrolled the ft and K functions can be put inline as to not incur a function call overhead
*/
    
/* These macros are for readability and should make sense when looking at the standard */
#define A 0
#define B 1
#define C 2
#define D 3
#define E 4

/* Define S (circular shift operator) */
#define S ROTATE_LEFT

/******************************************************************************/
static DRM_VOID DRM_CALL _PackDRMDWORD(
    IN const                DRM_DWORD *dwFrom,
    IN                      DRM_DWORD  dwCount, 
    __out_bcount(dwCount*4) DRM_BYTE  *bOut)
{
    DRM_UINT i = 0;
    DRM_UINT j = 0;
    for(; i<dwCount; i++)
    {
        PUT_BYTE(bOut, j, (DRM_BYTE)((dwFrom[i] >> 24) & 0xff)); j++;
        PUT_BYTE(bOut, j, (DRM_BYTE)((dwFrom[i] >> 16) & 0xff)); j++;
        PUT_BYTE(bOut, j, (DRM_BYTE)((dwFrom[i] >> 8 ) & 0xff)); j++;
        PUT_BYTE(bOut, j, (DRM_BYTE)((dwFrom[i]      ) & 0xff)); j++;
    }
}

/******************************************************************************/

static DRM_VOID DRM_CALL _GetDRMDWORD(
    __out_ecount(dwCount) DRM_DWORD *dwTo,
    IN                    DRM_DWORD  dwCount,
    IN const              DRM_BYTE  *bIn )
{
    DRM_UINT i = 0;
    DRM_UINT j = 0;
    for( ; i < dwCount; i++, j+=4)
    {
        dwTo[i] = ( ( (DRM_DWORD) GET_BYTE(bIn,j)   ) << 24 ) | 
                  ( ( (DRM_DWORD) GET_BYTE(bIn,j+1) ) << 16 ) |
                  ( ( (DRM_DWORD) GET_BYTE(bIn,j+2) ) << 8 )  |
                  (   (DRM_DWORD) GET_BYTE(bIn,j+3) );
    }
}


/******************************************************************************/

static DRM_INT _ft(DRM_INT b, DRM_INT c, DRM_INT d, DRM_INT t)
{
    DRMASSERT(t<80);
    if(t >= 60)
        return (b^c^d);
    if(t>=40)
        return ((b&c)|(b&d)|(c&d));
    if(t>=20)
        return (b^c^d);
    if(t>=0)
        return ((b&c) | ((~b)&d));

    return 0;    /* If valid input we should never hit this */

}

/******************************************************************************/

static DRM_DWORD _K(DRM_SHORT t)
{

    DRMASSERT(t<80);
    if(t >= 60)
        return 0xCA62C1D6;
    if(t>=40)
        return 0x8F1BBCDC;
    if(t>=20)
        return 0x6ED9EBA1;
    if(t>=0)
        return 0x5A827999;

    return 0;    /* If valid input we should never hit this */
}

/******************************************************************************/

/* SHA operates on 512 bit blocks which is 16-dword sized blocks.  (16*32 = 512) */

/**********************************************************************
** Function:        _sha1
**
** Synopsis:    Meat of sha, this is the actual mathematical processing.
**
** Arguments:    [ABCDE] -- current state numbers of sha
**                [bInput] -- 64 byte block to put through the sha process
**
** Returns:        None
**
** Notes:        This version of SHA1 is written to reduce processor instructions
**                but the tradeoff is the 80 DWORD stack buffer.
**
***********************************************************************/
static DRM_NO_INLINE DRM_VOID _sha1(
    IN       DRM_DWORD ABCDE[5],
    IN const DRM_BYTE  bInput[__CB_DECL(DRM_SHA1_BLOCK_SIZE)] )
{
    DRM_DWORD Buf2[5];
    DRM_DWORD W[80];
    DRM_SHORT cCount;
    DRM_DWORD TEMP;


    _GetDRMDWORD(W,16,bInput);
    MEMCPY((DRM_BYTE*)Buf2, (DRM_BYTE*)ABCDE, SIZEOF(DRM_DWORD) * 5);
    for(cCount = 16; cCount < 80; cCount++)
    {
        TEMP = W[cCount-3] ^ W[cCount-8] ^ W[cCount-14] ^ W[cCount-16];
        W[cCount] = S(TEMP,1);
    }
    for(cCount = 0; cCount < 80; cCount++ )
    {
        TEMP = S(ABCDE[A],5);
        TEMP += _ft(ABCDE[B],ABCDE[C],ABCDE[D], cCount);
        TEMP += ABCDE[E];
        TEMP += W[cCount];
        TEMP += _K(cCount);
        ABCDE[E] = ABCDE[D];
        ABCDE[D] = ABCDE[C];
        ABCDE[C] = S(ABCDE[B],30);
        ABCDE[B] = ABCDE[A];
        ABCDE[A] = TEMP;
    }
    for (cCount = 0; cCount < 5; cCount++)
    {
        Buf2[cCount] += ABCDE[cCount];
    }
    MEMCPY((DRM_BYTE*)ABCDE, (DRM_BYTE*)Buf2, SIZEOF(DRM_DWORD) * 5);
}

/******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SHA1_Init(
    IN OUT DRM_SHA1_CONTEXT* pShaContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg( pShaContext != NULL );
     
    /*Zero out the buffer*/
    ZEROMEM((DRM_BYTE*)pShaContext, SIZEOF(DRM_SHA1_CONTEXT));    
    
    /* Set the initial magic numbers */
    pShaContext->ABCDE[A] = 0x67452301;
    pShaContext->ABCDE[B] = 0xEFCDAB89;
    pShaContext->ABCDE[C] = 0x98BADCFE;
    pShaContext->ABCDE[D] = 0x10325476;
    pShaContext->ABCDE[E] = 0xC3D2E1F0;
    
ErrorExit:
    return dr;
}

/******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SHA1_Update(
    __in_bcount( cbData ) const DRM_BYTE *pbData,
    IN       DRM_DWORD         cbData,
    IN OUT   DRM_SHA1_CONTEXT *pShaContext )
{
    return DRM_SHA1_UpdateOffset( pbData, 0, cbData, pShaContext );
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SHA1_UpdateOffset(
    __in_bcount( ibData + cbData ) const DRM_BYTE *pbData,
    IN       DRM_DWORD         ibData,
    IN       DRM_DWORD         cbData,
    IN OUT   DRM_SHA1_CONTEXT *pShaContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwTempLen;
    
    ChkArg( pbData != NULL );
    ChkArg( pShaContext != NULL );

    /* How many bytes do we have remaining? */
    dwTempLen = pShaContext->dwLowByteCount & (DRM_SHA1_BLOCK_SIZE - 1);
    pShaContext->dwLowByteCount += cbData;

    if(pShaContext->dwLowByteCount < cbData)
    {
        /* We overflowed and wrapped around.  This means
        ** we need to increment the high order byte counter 
        */
        pShaContext->dwHighByteCount++;
    }

    if (   dwTempLen > 0 
        && cbData   >= (DRM_SHA1_BLOCK_SIZE - dwTempLen) )
    {
        /* We have enough to complete the last block.  Fill it and sha it */
        DRM_BYT_CopyBytes(pShaContext->bTempBuffer, dwTempLen, pbData, ibData, DRM_SHA1_BLOCK_SIZE-dwTempLen);
        _sha1(pShaContext->ABCDE,pShaContext->bTempBuffer);
        
        ChkOverflow( ibData + (DRM_SHA1_BLOCK_SIZE - dwTempLen), ibData );
        ibData += DRM_SHA1_BLOCK_SIZE - dwTempLen;
        cbData -= DRM_SHA1_BLOCK_SIZE - dwTempLen;

        dwTempLen = 0;
    }
       
    /* Sha each portion of the buffer that is big enough */
    while(cbData>=DRM_SHA1_BLOCK_SIZE)
    {
#if SIXTEEN_BIT_ADDRESSING
        DRM_BYT_CopyBytes(pShaContext->bTempBuffer, 0, pbData, ibData, DRM_SHA1_BLOCK_SIZE);
        _sha1( pShaContext->ABCDE,pShaContext->bTempBuffer);
#else
        _sha1( pShaContext->ABCDE,pbData + __CB_DECL(ibData));
#endif
        ibData += DRM_SHA1_BLOCK_SIZE;
        cbData -= DRM_SHA1_BLOCK_SIZE;
    }

    if(cbData)
    {
        DRM_BYT_CopyBytes(pShaContext->bTempBuffer, dwTempLen, pbData, ibData, cbData);
    }
ErrorExit:
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SHA1_Finalize(
    IN  DRM_SHA1_CONTEXT *pShaContext,
    __out_bcount( DRM_SHA1_DIGEST_LEN ) DRM_BYTE rgbDigest[__CB_DECL(DRM_SHA1_DIGEST_LEN)] )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  dwTempLen;
    DRM_DWORD  dwTotalBitLen[2];
    DRM_BYTE   bPaddingBuffer[__CB_DECL(DRM_SHA1_BLOCK_SIZE+12)] = {0};    /* Maximum block size we may need. */
        
    ChkArg( pShaContext != NULL );
        
    /* How many bytes do we need to make a SHA block? */
    dwTempLen = DRM_SHA1_BLOCK_SIZE - (pShaContext->dwLowByteCount & 63);
    
    /* This is there enough room for the padding?.*/
    if(dwTempLen<=8)
    {
        dwTempLen += DRM_SHA1_BLOCK_SIZE;
    }
    
    /*dwLowByteCount is the number of bytes so we have to multiply that by 8 to get the number of bits */
    dwTotalBitLen[1] = pShaContext->dwLowByteCount << 3;
    dwTotalBitLen[0] = (pShaContext->dwHighByteCount << 3) | 
                        (pShaContext->dwLowByteCount >> 29); /* We could have overflowed so put the extra here */

    PUT_BYTE(bPaddingBuffer, 0, 0x80);    /* We add a 10000000 */ 
    
#if SIXTEEN_BIT_ADDRESSING
    {
        DRM_BYTE rgbTemp[__CB_DECL(2*SIZEOF(DRM_DWORD))];
        /* 
        ** We do the packing to a temporary buffer because the offset into
        ** the padding buffer could be odd, and _PackDRMDWORD doesn't handle
        ** that case
        */
        _PackDRMDWORD(dwTotalBitLen,2,rgbTemp);
        DRM_BYT_CopyBytes( bPaddingBuffer, dwTempLen-8, rgbTemp, 0, 2*SIZEOF(DRM_DWORD) );
    }

#else

    /* Last 2 DWORDS are for the total bit length */
    _PackDRMDWORD(dwTotalBitLen,2,&(bPaddingBuffer[(dwTempLen-8)]));

#endif

    ChkDR( DRM_SHA1_Update(bPaddingBuffer, dwTempLen, pShaContext) );
    
    /* Extract the digest and save it. */
    _PackDRMDWORD(pShaContext->ABCDE,5,rgbDigest);        

ErrorExit:
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmstkalloc.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmstkalloc.h>

ENTER_PK_NAMESPACE_CODE;


/*
** Returns a pointer to where the next call to Alloc will allocate memory from, but doesn't
** actually allocate yet. Useful if the size of the buffer desired is not known in advance.
*/
DRM_API DRM_RESULT DRM_CALL DRM_STK_PreAlloc(
    IN  DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    OUT DRM_DWORD                   *pcbSize,
    __deref_out_bcount( *pcbSize ) DRM_VOID **ppbBuffer)
{
    DRM_RESULT dr     = DRM_SUCCESS;

    ChkArg( pContext  != NULL
         && ppbBuffer != NULL
         && pcbSize   != NULL );
    
    ChkOverflow( pContext->nStackTop + SIZEOF(DRM_DWORD), pContext->nStackTop );
    ChkOverflow( pContext->pbStack + ((pContext->nStackTop + SIZEOF(DRM_DWORD))/CB_NATIVE_BYTE), pContext->pbStack );

    *ppbBuffer = pContext->pbStack + ((pContext->nStackTop + SIZEOF(DRM_DWORD))/CB_NATIVE_BYTE);
    
    ChkOverflow( pContext->cbStack, pContext->nStackTop + SIZEOF( DRM_DWORD ) );
    
    *pcbSize = pContext->cbStack - (pContext->nStackTop + SIZEOF(DRM_DWORD));

    pContext->fWasPreAlloc = TRUE;

#if DBG
    /* clear the buffer */
    MEMSET((DRM_BYTE*)*ppbBuffer, 0xa, *pcbSize);
#endif

ErrorExit:    
    return dr;
}

/*
** Push the stack to allocate the requested size of buffer 
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_STK_Alloc(
    IN  DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    IN  DRM_DWORD                    cbSize,
    __deref_out_bcount( cbSize ) DRM_VOID  **ppbBuffer)
{
    DRM_RESULT dr     = DRM_SUCCESS;
    DRM_DWORD  dwSize = cbSize;

    ChkArg( pContext  != NULL
         && ppbBuffer != NULL
         && cbSize     > 0 );
    
    *ppbBuffer = NULL;
    /* allocate buffer from top of stack */
    if ( ( dwSize % SIZEOF(DRM_DWORD_PTR) )!=0 )
    {
        /* adjust cbSize for alignment of DRM_DWORD_PTR */
        dwSize += SIZEOF(DRM_DWORD_PTR) - ( dwSize % SIZEOF(DRM_DWORD_PTR) );
    }

    if ( ( pContext->nStackTop                              )  >= pContext->cbStack
      || ( pContext->nStackTop + dwSize                     )  >= pContext->cbStack
      || ( pContext->nStackTop + dwSize                     )   < pContext->nStackTop
      || ( pContext->nStackTop + dwSize + SIZEOF(DRM_DWORD) )   > pContext->cbStack 
      || ( pContext->nStackTop + dwSize + SIZEOF(DRM_DWORD) )   < pContext->nStackTop )
    {
        ChkDR( DRM_E_OUTOFMEMORY );
    }

    DRM_BYT_CopyBytes((DRM_BYTE*)pContext->pbStack, pContext->nStackTop, (DRM_BYTE*)&dwSize, 0, SIZEOF(DRM_DWORD));
    *ppbBuffer = pContext->pbStack + ((pContext->nStackTop + SIZEOF(DRM_DWORD))/CB_NATIVE_BYTE);

    pContext->nStackTop += (DRM_DWORD)(dwSize+SIZEOF(DRM_DWORD));
    /*
    TRACE(("Alloc: top=0x%08X  pb=0x%08X  cb=%d\n", pContext->nStackTop, *ppbBuffer, dwSize));
    */
    if( pContext->fWasPreAlloc )
    {
        pContext->fWasPreAlloc = FALSE;
    }
    else
    {
#if DBG
        /* clear the buffer */
        MEMSET((DRM_BYTE*)*ppbBuffer, 0xa, dwSize);
#endif
    }

ErrorExit:    
    return dr;
}

/*********************************************************************
**
**  Function:  DRM_STK_Alloc_Aligned
**
**  Synopsis:  Allocates a buffer from a give stack context and align
**             the returned buffer pointer using the provided alignment
**             value.
**
**  Arguments:  
**  [pContext]      -- Stack allocator context to allocate from.
**  [cbSize]        -- Size of the buffer needed.
**  [cbAlign]       -- Value of the alignment.
**  [ppbBufferRaw]  -- Pointer to pointer to hold the new memory offset.
**                     This is the buffer to be freed using DRM_STK_Free().
**                     This parameter is optional if caller does not call
**                     DRM_STK_FREE() with the allocated buffer.
**  [ppbBufferAligned] -- Pointer to pointer to hold the aligned buffer.
**                      It may be the same as the buffer pointed by ppbBufferRaw
**                      if the buffer pointed by ppbBufferRaw is already
**                      aligned.
**
**  Notes:  Pointers must be freed in LIFO order ( just like a stack ).
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STK_Alloc_Aligned(
    IN  DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    IN  DRM_DWORD                    cbSize,
    IN  DRM_DWORD                    cbAlign,
    __out_opt DRM_VOID             **ppbBufferRaw,
    __deref_out_bcount( cbSize ) DRM_VOID  **ppbBufferAligned )
{
    DRM_RESULT dr      = DRM_SUCCESS;
    DRM_DWORD  dwSize  = cbSize;
    DRM_BYTE  *pbAlloc = NULL;
    DRM_DWORD  cbDiff  = 0;

    ChkArg( pContext  != NULL
         && ppbBufferAligned != NULL
         && cbSize     > 0
         && cbAlign > 0 );
    
    *ppbBufferAligned = NULL;

    if ( ppbBufferRaw != NULL )
    {
        *ppbBufferRaw = NULL;
    }

    /* allocate buffer from top of stack */
    if ( ( dwSize % SIZEOF(DRM_DWORD_PTR) )!=0 )
    {
        /* adjust cbSize for alignment of DRM_DWORD_PTR */
        dwSize += SIZEOF(DRM_DWORD_PTR) - ( dwSize % SIZEOF(DRM_DWORD_PTR) );
    }

    pbAlloc = pContext->pbStack + ((pContext->nStackTop + SIZEOF(DRM_DWORD))/CB_NATIVE_BYTE);

    if ( ppbBufferRaw != NULL )
    {
        *ppbBufferRaw = pbAlloc;
    }

    if (  ( ( DRM_DWORD_PTR )pbAlloc ) % cbAlign != 0 )
    {
        cbDiff = cbAlign - ( ( DRM_DWORD_PTR )pbAlloc ) % cbAlign;
        dwSize += cbAlign;

        *ppbBufferAligned = pbAlloc + cbDiff;
    }
    else
    {
        *ppbBufferAligned = pbAlloc;
    }

    if ( ( pContext->nStackTop                              )  >= pContext->cbStack
      || ( pContext->nStackTop + dwSize                     )  >= pContext->cbStack
      || ( pContext->nStackTop + dwSize                     )   < pContext->nStackTop
      || ( pContext->nStackTop + dwSize + SIZEOF(DRM_DWORD) )   > pContext->cbStack 
      || ( pContext->nStackTop + dwSize + SIZEOF(DRM_DWORD) )   < pContext->nStackTop )
    {
        *ppbBufferAligned = NULL;

        ChkDR( DRM_E_OUTOFMEMORY );
    }

    DRM_BYT_CopyBytes((DRM_BYTE*)pContext->pbStack, pContext->nStackTop, (DRM_BYTE*)&dwSize, 0, SIZEOF(DRM_DWORD));
    
    pContext->nStackTop += (DRM_DWORD)(dwSize+SIZEOF(DRM_DWORD));
    /*
    TRACE(("Alloc: top=0x%08X  pb=0x%08X  cb=%d\n", pContext->nStackTop, pbAlloc, dwSize));
    */
    if( pContext->fWasPreAlloc )
    {
        pContext->fWasPreAlloc = FALSE;
    }
    else
    {
#if DBG
        /* clear the buffer */
        MEMSET(pbAlloc, 0xa, dwSize);
#endif
    }

ErrorExit:    
    return dr;
}


/*
** Pop the stack to free the allocated buffer
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_STK_Free(
    IN DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    IN DRM_VOID                    *pbBuffer)
{
    DRM_RESULT dr     = DRM_SUCCESS;
    DRM_DWORD  dwSize = 0;
    
    if ( pbBuffer == NULL )
    {
        /* pbBuffer is NULL, simply return */
        ChkDR( DRM_E_LOGICERR );
    }

    ChkArg( pContext != NULL );

    /* verify the buffer with the stack */
    MEMCPY((DRM_BYTE*)&dwSize,(DRM_BYTE*)pbBuffer - sizeof(DRM_DWORD),SIZEOF(DRM_DWORD) );    
    /*
    TRACE((" Free: top=0x%08X  pb=0x%08X  cb=%d\n", pContext->nStackTop, pbBuffer, dwSize));
    */
    if ( ((DRM_BYTE*)pbBuffer+(dwSize/CB_NATIVE_BYTE)) != &pContext->pbStack[(pContext->nStackTop/CB_NATIVE_BYTE)])
    {
        TRACE(("\n\n***  DRM_STK_Free(): heap corrupted ***\n\n"));
        DRMASSERT( FALSE );
        ChkDR( DRM_E_STACK_CORRUPT ); /* internal stack corrupted */
    }

#if DBG
    /* clear the buffer */
    MEMSET((DRM_BYTE*)pbBuffer-sizeof(DRM_DWORD), 0xb, dwSize+SIZEOF(DRM_DWORD));
#endif

    pContext->nStackTop -= (DRM_DWORD)(dwSize+SIZEOF(DRM_DWORD));

ErrorExit:    
    return dr;
}

/* Init the stack. Return error if already initialized.
*/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_STK_Init(
    IN  DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    __in_bcount( cbSize) DRM_BYTE *pbBuffer,
    IN  DRM_DWORD                    cbSize   )

{   DRM_RESULT dr = DRM_SUCCESS;
    ChkArg( pContext != NULL && pbBuffer != NULL  && cbSize != 0  );
 /*  Check that stack was not initilized. */ 
    if ( pContext->pbStack != NULL )
    { ChkDR( DRM_E_STACK_ALREADY_INITIALIZED )
    }
#if DBG
    /* Set all memory to 0xcd, so we can see un-allocated memory. */
    MEMSET( pbBuffer, 0xCD, cbSize );
#endif
    
    pContext->pbStack = pbBuffer;
    pContext->cbStack = cbSize;
    pContext->nStackTop = 0;

ErrorExit:    
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmsoapxmlconstants.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmsoapxmlconstants.h>

ENTER_PK_NAMESPACE_CODE;

/*
** -------------------------------------------------------------------
** XML strings used in the parsing of status code from server response
** -------------------------------------------------------------------
*/
/* "detail/Exception" */
const DRM_CHAR g_rgchSOAPExceptionRootPath [] =
{
    TWO_BYTES( 'd', 'e' ), TWO_BYTES( 't', 'a' ), TWO_BYTES( 'i', 'l' ), TWO_BYTES( '/', 'E' ), 
    TWO_BYTES( 'x', 'c' ), TWO_BYTES( 'e', 'p' ), TWO_BYTES( 't', 'i' ), TWO_BYTES( 'o', 'n' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPExceptionRootPath = { g_rgchSOAPExceptionRootPath, 16 };


/* "detail/Signature" */
const DRM_CHAR g_rgchSOAPExceptionSignaturePath [] =
{
    TWO_BYTES( 'd', 'e' ), TWO_BYTES( 't', 'a' ), TWO_BYTES( 'i', 'l' ), TWO_BYTES( '/', 'S' ), 
    TWO_BYTES( 'i', 'g' ), TWO_BYTES( 'n', 'a' ), TWO_BYTES( 't', 'u' ), TWO_BYTES( 'r', 'e' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPExceptionSignaturePath = { g_rgchSOAPExceptionSignaturePath, 16 };


/* "detail/Exception/StatusCode" */
const DRM_CHAR g_rgchSOAPStatusCodePath [] =
{
    TWO_BYTES( 'd', 'e' ), TWO_BYTES( 't', 'a' ), TWO_BYTES( 'i', 'l' ), TWO_BYTES( '/', 'E' ), 
    TWO_BYTES( 'x', 'c' ), TWO_BYTES( 'e', 'p' ), TWO_BYTES( 't', 'i' ), TWO_BYTES( 'o', 'n' ), 
    TWO_BYTES( '/', 'S' ), TWO_BYTES( 't', 'a' ), TWO_BYTES( 't', 'u' ), TWO_BYTES( 's', 'C' ), 
    TWO_BYTES( 'o', 'd' ), TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPStatusCodePath = { g_rgchSOAPStatusCodePath, 27 };

/* "detail/Exception/CustomData" */
const DRM_CHAR g_rgchSOAPExceptionCustomDataPath [] =
{
    TWO_BYTES( 'd', 'e' ), TWO_BYTES( 't', 'a' ), TWO_BYTES( 'i', 'l' ), TWO_BYTES( '/', 'E' ), 
    TWO_BYTES( 'x', 'c' ), TWO_BYTES( 'e', 'p' ), TWO_BYTES( 't', 'i' ), TWO_BYTES( 'o', 'n' ), 
    TWO_BYTES( '/', 'C' ), TWO_BYTES( 'u', 's' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'm', 'D' ), 
    TWO_BYTES( 'a', 't' ), TWO_BYTES( 'a', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPExceptionCustomDataPath = { g_rgchSOAPExceptionCustomDataPath, 27 };

/* "CustomData" */
const DRM_CHAR g_rgchSOAPGARDCustomDataPath [] =
{
    TWO_BYTES( 'C', 'u' ), TWO_BYTES( 's', 't' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( 'D', 'a' ), 
    TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPGARDCustomDataPath = { g_rgchSOAPGARDCustomDataPath, 10 };


/* "RedirectUrl" */
const DRM_CHAR g_rgchSOAPGARDRedirectUrlPath [] =
{
    TWO_BYTES( 'R', 'e' ), TWO_BYTES( 'd', 'i' ), TWO_BYTES( 'r', 'e' ), TWO_BYTES( 'c', 't' ), 
    TWO_BYTES( 'U', 'r' ), TWO_BYTES( 'l', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPGARDRedirectUrlPath = { g_rgchSOAPGARDRedirectUrlPath, 11 };


/* "ServiceId" */
const DRM_CHAR g_rgchSOAPGARDServiceIdPath [] =
{
    TWO_BYTES( 'S', 'e' ), TWO_BYTES( 'r', 'v' ), TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'e', 'I' ), 
    TWO_BYTES( 'd', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPGARDServiceIdPath = { g_rgchSOAPGARDServiceIdPath, 9 };


/* "AccountId" */
const DRM_CHAR g_rgchSOAPGARDAccountIdPath [] =
{
    TWO_BYTES( 'A', 'c' ), TWO_BYTES( 'c', 'o' ), TWO_BYTES( 'u', 'n' ), TWO_BYTES( 't', 'I' ), 
    TWO_BYTES( 'd', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPGARDAccountIdPath = { g_rgchSOAPGARDAccountIdPath, 9 };



/*
** -----------------------------------------------------
** XML strings used in the construction of SOAP envelope
** -----------------------------------------------------
*/
/* "<?xml version= 1.0  encoding= utf-8 ?>" */
const DRM_CHAR g_rgchXMLRootTag [] =
{
    TWO_BYTES( '<', '?' ), TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', ' ' ), TWO_BYTES( 'v', 'e' ), 
    TWO_BYTES( 'r', 's' ), TWO_BYTES( 'i', 'o' ), TWO_BYTES( 'n', '=' ), TWO_BYTES( '"', '1' ), 
    TWO_BYTES( '.', '0' ), TWO_BYTES( '"', ' ' ), TWO_BYTES( 'e', 'n' ), TWO_BYTES( 'c', 'o' ), 
    TWO_BYTES( 'd', 'i' ), TWO_BYTES( 'n', 'g' ), TWO_BYTES( '=', '"' ), TWO_BYTES( 'u', 't' ), 
    TWO_BYTES( 'f', '-' ), TWO_BYTES( '8', '"' ), TWO_BYTES( '?', '>' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrXMLRootTag = { g_rgchXMLRootTag, 38 };


/* "soap:Envelope" */
const DRM_CHAR g_rgchSOAPEnvelopeTag [] =
{
    TWO_BYTES( 's', 'o' ), TWO_BYTES( 'a', 'p' ), TWO_BYTES( ':', 'E' ), TWO_BYTES( 'n', 'v' ), 
    TWO_BYTES( 'e', 'l' ), TWO_BYTES( 'o', 'p' ), TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeTag = { g_rgchSOAPEnvelopeTag, 13 };


/* "soap:Body" */
const DRM_CHAR g_rgchSOAPBodyTag [] =
{
    TWO_BYTES( 's', 'o' ), TWO_BYTES( 'a', 'p' ), TWO_BYTES( ':', 'B' ), TWO_BYTES( 'o', 'd' ), 
    TWO_BYTES( 'y', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPBodyTag = { g_rgchSOAPBodyTag, 9 };



/* "xmlns:xsi" */
const DRM_CHAR g_rgchSOAPEnvelopeAttrib1Name [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', ':' ), TWO_BYTES( 'x', 's' ), 
    TWO_BYTES( 'i', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib1Name = { g_rgchSOAPEnvelopeAttrib1Name, 9 };

/* "http://www.w3.org/2001/XMLSchema-instance" */
const DRM_CHAR g_rgchSOAPEnvelopeAttrib1Value [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 'w' ), 
    TWO_BYTES( 'w', 'w' ), TWO_BYTES( '.', 'w' ), TWO_BYTES( '3', '.' ), TWO_BYTES( 'o', 'r' ), 
    TWO_BYTES( 'g', '/' ), TWO_BYTES( '2', '0' ), TWO_BYTES( '0', '1' ), TWO_BYTES( '/', 'X' ), 
    TWO_BYTES( 'M', 'L' ), TWO_BYTES( 'S', 'c' ), TWO_BYTES( 'h', 'e' ), TWO_BYTES( 'm', 'a' ), 
    TWO_BYTES( '-', 'i' ), TWO_BYTES( 'n', 's' ), TWO_BYTES( 't', 'a' ), TWO_BYTES( 'n', 'c' ), 
    TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib1Value = { g_rgchSOAPEnvelopeAttrib1Value, 41 };


/* "xmlns:xsd" */
const DRM_CHAR g_rgchSOAPEnvelopeAttrib2Name [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', ':' ), TWO_BYTES( 'x', 's' ), 
    TWO_BYTES( 'd', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib2Name = { g_rgchSOAPEnvelopeAttrib2Name, 9 };

/* "http://www.w3.org/2001/XMLSchema" */
const DRM_CHAR g_rgchSOAPEnvelopeAttrib2Value [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 'w' ), 
    TWO_BYTES( 'w', 'w' ), TWO_BYTES( '.', 'w' ), TWO_BYTES( '3', '.' ), TWO_BYTES( 'o', 'r' ), 
    TWO_BYTES( 'g', '/' ), TWO_BYTES( '2', '0' ), TWO_BYTES( '0', '1' ), TWO_BYTES( '/', 'X' ), 
    TWO_BYTES( 'M', 'L' ), TWO_BYTES( 'S', 'c' ), TWO_BYTES( 'h', 'e' ), TWO_BYTES( 'm', 'a' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib2Value = { g_rgchSOAPEnvelopeAttrib2Value, 32 };


/* "xmlns:soap" */
const DRM_CHAR g_rgchSOAPEnvelopeAttrib3Name [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', ':' ), TWO_BYTES( 's', 'o' ), 
    TWO_BYTES( 'a', 'p' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib3Name = { g_rgchSOAPEnvelopeAttrib3Name, 10 };

/* "http://schemas.xmlsoap.org/soap/envelope/" */
const DRM_CHAR g_rgchSOAPEnvelopeAttrib3Value [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ), 
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'x' ), 
    TWO_BYTES( 'm', 'l' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'a', 'p' ), TWO_BYTES( '.', 'o' ), 
    TWO_BYTES( 'r', 'g' ), TWO_BYTES( '/', 's' ), TWO_BYTES( 'o', 'a' ), TWO_BYTES( 'p', '/' ), 
    TWO_BYTES( 'e', 'n' ), TWO_BYTES( 'v', 'e' ), TWO_BYTES( 'l', 'o' ), TWO_BYTES( 'p', 'e' ), 
    TWO_BYTES( '/', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib3Value = { g_rgchSOAPEnvelopeAttrib3Value, 41 };

/* "xml:space" */
const DRM_CHAR g_rgchSOAPPreserveSpaceAttribName [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', ':' ), TWO_BYTES( 's', 'p' ), TWO_BYTES( 'a', 'c' ), 
    TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPPreserveSpaceAttribName = { g_rgchSOAPPreserveSpaceAttribName, 9 };

/* "preserve" */
const DRM_CHAR g_rgchSOAPPreserveSpaceAttribValue [] =
{
    TWO_BYTES( 'p', 'r' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( 'e', 'r' ), TWO_BYTES( 'v', 'e' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSOAPPreserveSpaceAttribValue = { g_rgchSOAPPreserveSpaceAttribValue, 8 };

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmsoapxmlutility.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmhds.h>
#include <drmbcertparser.h>
#include <drmxmlparser.h>
#include <drmxmlbuildera.h>
#include <drmaescommon.h>
#include <drmaes.h>
#include <drmxmlsig.h>
#include <drmxmlsigconstants.h>
#include <drmsoapxmlconstants.h>
#include <drmsoapxmlutility.h>
#include <drmdomainconstants.h>
#include <drmlicacqv3constants.h>
#include <drmmeterconstants.h>
#include <drmcontract.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

const DRM_SOAPXML_PROTOCOL_INTERNAL_DEFINE g_rgSoapProtoDefines[ DRM_SOAPXML_PROTOCOL_MAXIMUM_DEFINED + 1 ] = {
      EMPTY_DRM_SOAPXML_PROTOCOL_INTERNAL_DEFINE,                                                                                              /* DRM_SOAPXML_PROTOCOL_UNKNOWN       */
      { &g_dastrSOAPExceptionCustomDataPath, &g_dastrSOAPExceptionRootPath,                    &g_dastrSOAPExceptionSignaturePath, FALSE },    /* DRM_SOAPXML_PROTOCOL_EXCEPTION     */
#if DRM_SUPPORT_DOMAINS
      { &g_dastrDomJoinCustomDataPath,       &g_dastrDomJoinDomainPath,                        &g_dastrDomJoinSignaturePath      , TRUE  },    /* DRM_SOAPXML_PROTOCOL_DOMAIN_JOIN   */
      { &g_dastrDomLeaveCustomDataPath,      &g_dastrDomLeaveDomainPath,                       &g_dastrDomLeaveSignaturePath     , TRUE  },    /* DRM_SOAPXML_PROTOCOL_DOMAIN_LEAVE  */
#else
      EMPTY_DRM_SOAPXML_PROTOCOL_INTERNAL_DEFINE,
      EMPTY_DRM_SOAPXML_PROTOCOL_INTERNAL_DEFINE,
#endif /* DRM_SUPPORT_DOMAINS */
#if DRM_SUPPORT_METERING
      { &g_dastrMeterCertCustomDataPath,     &g_dastrMeterCertMeteringCertificateResponsePath, &g_dastrMeterCertSignaturePath    , TRUE  },    /* DRM_SOAPXML_PROTOCOL_METERING_CERT */
      { &g_dastrMeterDataCustomDataPath,     &g_dastrMeterDataMeteringResponsePath,            &g_dastrMeterDataSignaturePath    , TRUE  },    /* DRM_SOAPXML_PROTOCOL_METERING_DATA */
#else
      EMPTY_DRM_SOAPXML_PROTOCOL_INTERNAL_DEFINE,
      EMPTY_DRM_SOAPXML_PROTOCOL_INTERNAL_DEFINE,
#endif /* DRM_SUPPORT_METERING */
      { &g_dastrLicAcqCustomDataPath,        &g_dastrLicLicenseResponsePath,                   &g_dastrLicSignaturePath          , FALSE },    /* DRM_SOAPXML_PROTOCOL_LIC_ACQ       */
      { &g_dastrLicAckCustomDataPath,        &g_dastrLicAcqLAckPath,                           &g_dastrLicAckSignaturePath       , TRUE  } };  /* DRM_SOAPXML_PROTOCOL_LIC_ACK       */


/*********************************************************************
**
** Function: DRM_SOAPXML_EncodeData
**
** Synopsis: Function that does XML encoding of the passed in UTF8/ANSI
**           string.
**
** Arguments:
**
** [f_pchData]              -- Pointer to a buffer that contains the
**                             string to be XML encoded.
** [f_cchData]              -- Number of characters of the string to be XML
**                             encoded.
** [f_pchEncodedData]       -- Pointer to buffer to receive the XML encoded
**                             string. If f_pchEncodedData is NULL. The size
**                             of required buffer is stored in
**                             in *f_pcchEncodedData.
** [f_pcchEncodedData]      -- Pointer to a variable to receive the size of
**                             buffer that contains the XML encoded string.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if f_pchEncodedData
**                          is not NULL and the size of the the buffer
**                          pointed by f_pchEncodedData is not big
**                          enough to receive the encoded result.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_EncodeData(
    __in_ecount( f_cchData ) const DRM_CHAR *f_pchData,
    IN DRM_DWORD f_cchData,
    __out_ecount_opt( *f_pcchEncodedData ) DRM_CHAR *f_pchEncodedData,
    OUT DRM_DWORD *f_pcchEncodedData )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_SOAPXML, PERF_FUNC_DRM_SOAPXML_EncodeData );

    ChkArg( f_pchData == NULL || f_cchData > 0 );
    ChkArg( f_pcchEncodedData != NULL );

    if ( f_pchData == NULL )
    {
        *f_pcchEncodedData = 0;

        goto ErrorExit;
    }

    dr = DRM_UTL_XMLEncodeA( f_pchData,
                             f_cchData,
                             f_pchEncodedData,
                             f_pcchEncodedData );

    if ( DRM_FAILED( dr ) )
    {
        if ( f_pchEncodedData == NULL && dr == DRM_E_BUFFERTOOSMALL )
        {
            ChkDR( DRM_SUCCESS );
        }
        else
        {
            ChkDR( dr );
        }
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_DecodeData
**
** Synopsis: Function that does XML decoding of the passed in
**           UTF8/ANSI string.
**
** Arguments:
**
** [f_pchData]              -- Pointer to a buffer that contains the
**                             UTF8/ANSI string to be XML decoded.
** [f_cchData]              -- Number of characters of the string to be XML
**                             decoded.
** [f_ppchDecodedData]      -- Pointer to buffer to receive the XML decoded
**                             string. If f_pchDecodedData is NULL, the size
**                             of required buffer is stored in
**                             *f_pcchDecodedData.
** [f_pcchDecodedData]      -- Pointer to a variable to receive the size of
**                             buffer that contains the XML decoded string.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if f_pchDecodedData
**                          is not NULL and the size of the the buffer
**                          pointed by f_pchDecodedData is not big
**                          enough to receive the decoded result.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_DecodeData(
    __in_ecount( f_cchData ) DRM_CHAR *f_pchData,
    IN DRM_DWORD f_cchData,
    __out_ecount_opt( *f_pcchDecodedData ) DRM_CHAR *f_pchDecodedData,
    OUT DRM_DWORD *f_pcchDecodedData )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_SOAPXML, PERF_FUNC_DRM_SOAPXML_DecodeData );

    ChkArg( f_pchData == NULL || f_cchData > 0 );
    ChkArg( f_pcchDecodedData != NULL );

    if ( f_pchData == NULL )
    {
        *f_pcchDecodedData = 0;

        goto ErrorExit;
    }

    ChkDR( DRM_UTL_XMLDecodeA( f_pchData,
                             f_cchData,
                             f_pchDecodedData,
                             f_pcchDecodedData ) );
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_PadANSIString
**
** Synopsis: Function that pad an ANSI string to make its length
**           multiples of a specific block size. The algorithm is
**           PKCS#7 which is defined in RFC 2898, section 6.11.
**
** Arguments:
**
** [f_pdastrIn]             -- Pointer to a DRM ANSI string to be padded.
** [f_cchPad]               -- Number of characters of each data block. The
**                             total length of the padded string will be
**                             the multiples of the block size. It should
**                             be in the range of [1, 255].
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Note:                    Caller must make sure the buffer underneath
**                          should be big enough to store the newly added
**                          padding characters. The extra bytes needed at
**                          the end of the buffer specified by f_pdastrIn
**                          should be in the range of [1, f_cchPad].
**
** Brief description of PKCS#7 padding algorithm (use block size 8 as example):
** Notation:
** ||  ||  : octet length operator
** ||      : concatenation operator
** Concatenate M and a padding string PS to form an encoded message EM:
** EM = M || PS ,
** where the padding string PS consists of 8 -( ||M|| mod 8 ) octets
** each with value 8 - ( ||M|| mod 8 ). The padding string PS will
** satisfy one of the following statements:
** PS = 01, if ||M|| mod 8 = 7 ;
** PS = 02 02, if ||M|| mod 8 = 6 ;
** ...
** PS = 08 08 08 08 08 08 08 08, if ||M|| mod 8 = 0.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_PadANSIString(
    IN OUT DRM_ANSI_STRING *f_pdastrIn,
    IN DRM_DWORD f_cchPad )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchNew = 0;
    DRM_BYTE chPadding = 0;

    ChkDRMANSIString( f_pdastrIn );
    ChkArg( f_cchPad > 0 && f_cchPad <= 255 );

    cchNew = f_cchPad - ( f_pdastrIn->cchString % f_cchPad );

    ChkOverflow( f_cchPad, cchNew );

    chPadding = ( DRM_BYTE )cchNew;

    DRM_BYT_SetBytes( f_pdastrIn->pszString,
                      f_pdastrIn->cchString,
                      cchNew,
                      chPadding );

    f_pdastrIn->cchString += cchNew;

ErrorExit:

    return dr;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_IsBlankGUID
**
** Synopsis: Function that checks whether a passed in DRM_GUID contains
**           all 0.
**
** Arguments:
**
** [f_poGUID]               -- Pointer to a variable of type DRM_GUID.
**
** Returns:                 TRUE: The GUID contains all zeros or the input
**                          pointer is NULL.
**                          FALSE: The GUID does not contain all zeros.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL DRM_SOAPXML_IsBlankGUID(
    IN DRM_GUID *f_poGUID )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BOOL fResult = TRUE;
    DRM_GUID oEmptyGUID = EMPTY_DRM_GUID;

    /* Return TRUE if the passed in GUID pointer is NULL. */
    ChkDR( f_poGUID != NULL );

    fResult = ( MEMCMP( &oEmptyGUID, f_poGUID, SIZEOF( DRM_GUID ) ) == 0 );

ErrorExit:

    return fResult;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_CalcDWORDCharCount
**
** Synopsis: Function that calculates the character count of a DWORD
**           decimal value when it is converted into a string.
**
** Arguments:
**
** [f_dwNumber]             -- The DWORD value to be calculated.
**
** Returns:                 A long integer value that is the character
**                          count of the DWORD value.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_DWORD DRM_CALL DRM_SOAPXML_CalcDWORDCharCount(
    IN DRM_DWORD f_dwNumber )
{
    DRM_DWORD cchCount = 1;

    while ( f_dwNumber >= 10 )
    {
        f_dwNumber /= 10;

        cchCount++;
    }

    return cchCount;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_GetDeviceCert
**
** Synopsis: Function that retrieves a device certificate and the
**           size (number of characters) of a device certificate.
**           The returned format can be B64 encoded or not.
**
** Arguments:
**
** [f_poOEMContext]         -- Pointer to an optional OEM context structure.
** [f_fB64Encoded]          -- Flag indicating whether the device certificate
**                             should be returned as B64 encoded.
** [f_pchDeviceCert]        -- Pointer to a character buffer that is used
**                             to receive the device certificate.
**                             It can be NULL, in which case only the size
**                             (number of characters) of the device
**                             certificate is returned.
** [f_pcchDeviceCert]       -- Pointer to a variable that contains the
**                             size (number of characters) of the buffer
**                             mentioned above during input and receives
**                             the size (number of characters) of the contained
**                             device certificate during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if f_pchDeviceCert is not
**                          NULL and *f_pcchDeviceCert is smaller than the
**                          size (number of characters) to store the device
**                          certificate.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_GetDeviceCert(
    __in_opt DRM_VOID *f_poOEMContext,
    IN DRM_BOOL f_fB64Encoded,
    __out_ecount_opt( *f_pcchDeviceCert ) DRM_CHAR  *f_pchDeviceCert,
    IN OUT DRM_DWORD *f_pcchDeviceCert )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cbBuffer = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_SOAPXML, PERF_FUNC_DRM_SOAPXML_GetDeviceCert );

    ChkArg( f_pcchDeviceCert != NULL );

    cbBuffer = *f_pcchDeviceCert;

    /*
    ** Retrieve the binary device certificate
    */
    dr = Oem_Device_GetCert( f_poOEMContext, DRM_DCT_PLAYREADY, (DRM_BYTE *) f_pchDeviceCert, &cbBuffer );

    if ( DRM_SUCCEEDED( dr ) )
    {
        if ( f_fB64Encoded )
        {
            /*
            ** If the supplied buffer is big enough, B64 encode the binary data to ASCII chars in place.
            */
            if ( *f_pcchDeviceCert < CCH_BASE64_EQUIV( cbBuffer ) )
            {
                dr = DRM_E_BUFFERTOOSMALL;
            }
            else
            {
                dr = DRM_B64_EncodeA( (DRM_BYTE *)f_pchDeviceCert,
                                      cbBuffer,
                                      (DRM_CHAR *)f_pchDeviceCert,
                                      f_pcchDeviceCert,
                                      0 );
            }
        }
    }

    if ( dr != DRM_E_BUFFERTOOSMALL )
    {
        ChkDR ( dr );
    }
    else
    {
        *f_pcchDeviceCert = f_fB64Encoded ? CCH_BASE64_EQUIV( cbBuffer ) : cbBuffer;

        if ( f_pchDeviceCert != NULL )
        {
            ChkDR( dr );
        }

        dr = DRM_SUCCESS;
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_InitXMLKey
**
** Synopsis: Function that creates a DRM_XML_KEY object, which is used
**           to improve the public key crypto performance. This object
**           contains a randomly generated AES key that is protected by
**           a pre-shared WMRM ECC-256 key pair.
**
** Arguments:
** [f_poOEMContext]         -- Pointer to an OEM implemented context.
** [f_poXMLKey]             -- Pointer to a DRM_XML_KEY structure to store
**                             the generated encrypted AES key.
** [f_pCryptoCtx]           -- Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_InitXMLKey(
    IN     DRM_VOID             *f_poOEMContext,
    OUT    DRM_XML_KEY          *f_poXMLKey,
    IN OUT DRM_CRYPTO_CONTEXT   *f_pCryptoCtx   )
{
    DRM_RESULT dr = DRM_SUCCESS;
    PLAINTEXT_P256 oPlainText = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_SOAPXML, PERF_FUNC_DRM_SOAPXML_InitXMLKey );

    ChkArg( f_poXMLKey != NULL );
    ChkArg( f_pCryptoCtx != NULL );

    ZEROMEM( f_poXMLKey, SIZEOF( DRM_XML_KEY ) );

    f_poXMLKey->m_eKeyInfoType = DRM_XML_KEYINFO_ENCRYPTED;

    f_poXMLKey->m_eKeyFormat = DRM_XML_ECC256_SERVER_PUBLIC_KEY_ID;

    /*
    ** Generate a random AES key (second 16 bytes).
    ** The second 16 bytes MUST be filled ealier than
    ** the first 16 bytes.
    */
    ChkDR( Oem_Random_GetBytes( f_poOEMContext,
                               &oPlainText.m_rgbPlaintext[ DRM_AES_KEYSIZE_128 ],
                               DRM_AES_KEYSIZE_128 ) );

    /* Generate a random AES initialization vector (first 16 bytes). */
    ChkDR( DRM_ECC_GenerateHMACKey_P256( &oPlainText, (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext ) );

    DRMCASSERT( DRM_XML_AES_KEY_SIZE == SIZEOF( PLAINTEXT_P256 ) );

    /* Store the 32 bytes generated as the AES key. */
    MEMCPY( f_poXMLKey->m_oAESKey.m_rgbClearAESKey,
            oPlainText.m_rgbPlaintext,
            DRM_XML_AES_KEY_SIZE );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_EncryptDataWithXMLKey
**
** Synopsis: Function that uses AES CBC mode to encrypt the passed in
**           data. Then it uses a pre-shared WMRM/Metering public ECC-256
**           key to encrypt the AES key in place.
**
** Arguments:
**
** [f_poOEMContext]         -- Pointer to an OEM implemented context.
** [f_poXMLKey]             -- Pointer to a DRM_XML_KEY structure to store
**                             the generated encrypted AES key.
** [f_pdastrData]           -- Pointer to a DRM string that is to be
**                             encrypted in place.
** [f_pCryptoCtx]           -- Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_EncryptDataWithXMLKey(
    IN DRM_VOID *f_poOEMContext,
    IN OUT DRM_XML_KEY *f_poXMLKey,
    IN OUT DRM_ANSI_CONST_STRING *f_pdastrData,
    IN OUT DRM_CRYPTO_CONTEXT *f_pCryptoCtx    )
{
    DRM_RESULT dr = DRM_SUCCESS;
    PLAINTEXT_P256 oPlainText = { 0 };
    CIPHERTEXT_P256 oCipherText = { 0 };
    DRM_AES_KEY oAESKey = { 0 };
    DRM_BYTE *pbData = NULL;
    DRM_DWORD cbData = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_SOAPXML, PERF_FUNC_DRM_SOAPXML_EncryptDataWithXMLKey );

    ChkArg( f_poXMLKey != NULL );
    ChkArg( f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_SERVER_PUBLIC_KEY_ID ||
            f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_METERING_PUBLIC_KEY_ID ||
            f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_PUBLIC_KEY_DATA );
    ChkArg( f_pCryptoCtx != NULL );
    ChkDRMANSIString( f_pdastrData );

    pbData = PB_DASTR( f_pdastrData );
    cbData = CB_DASTR( f_pdastrData );

    ChkDR( Oem_Aes_SetKey( &f_poXMLKey->m_oAESKey.m_rgbClearAESKey[ DRM_AES_KEYSIZE_128 ],
                           &oAESKey ) );

    /* Leave space for DRM_AES_KEYSIZE_128 bytes of IV at the beginning of the buffer. */
    DRM_BYT_MoveBytes( pbData + __CB_DECL( DRM_AES_KEYSIZE_128 ),
                       0,
                       pbData,
                       0,
                       cbData );

    /* Store DRM_AES_KEYSIZE_128 bytes of IV. */
    DRM_BYT_CopyBytes( pbData,
                       0,
                       f_poXMLKey->m_oAESKey.m_rgbClearAESKey,
                       0,
                       DRM_AES_KEYSIZE_128 );

    f_pdastrData->cchString += DRM_AES_KEYSIZE_128;

    /*
    ** Encrypt the passed in data in place with the random AES key just
    ** generated. It assumes AES CBC ciphering does not change the size
    ** of a packed data buffer.
    */
    ChkDR( DRM_Aes_CbcEncryptData( &oAESKey,
                                   pbData + __CB_DECL( DRM_AES_KEYSIZE_128 ),
                                   cbData,
                                   f_poXMLKey->m_oAESKey.m_rgbClearAESKey ) );

    ZEROMEM( &oPlainText, SIZEOF( PLAINTEXT_P256 ) );

    DRMCASSERT( DRM_XML_AES_KEY_SIZE == SIZEOF( PLAINTEXT_P256 ) );

    MEMCPY( oPlainText.m_rgbPlaintext,
            f_poXMLKey->m_oAESKey.m_rgbClearAESKey,
            DRM_XML_AES_KEY_SIZE );

    if ( f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_SERVER_PUBLIC_KEY_ID )
    {
        /*
        ** Encrypt the random AES key in place using a pre-shared WMRM public key.
        */
        ChkDR( DRM_ECC_Encrypt_P256( &g_oWMRMECC256PubKey,
                                     &oPlainText,
                                     &oCipherText,
                                     ( struct bigctx_t * )f_pCryptoCtx->rgbCryptoContext ) );
    }
    else if ( f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_PUBLIC_KEY_DATA ||
              f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_METERING_PUBLIC_KEY_ID )
    {
        ChkDR( DRM_ECC_Encrypt_P256( &f_poXMLKey->m_oECC256PubKey,
                                     &oPlainText,
                                     &oCipherText,
                                     ( struct bigctx_t * )f_pCryptoCtx->rgbCryptoContext ) );
    }

    /* Store the ECC-256 encrypted AES key in the passed in XML key structure. */
    MEMCPY( f_poXMLKey->m_oAESKey.m_rgbCipherAESKey,
            oCipherText.m_rgbCiphertext,
            ECC_P256_CIPHERTEXT_SIZE_IN_BYTES );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#if DRM_USE_SOAP

/*********************************************************************
**
** Function: DRM_SOAPXML_SkipSOAPHeaders
**
** Synopsis: Function that skips the SOAP headers of a passed in server
**           response string.
**
** Arguments:
**
** [f_pszResponse]          -- Pointer to a character buffer that contains
**                             the server response.
** [f_pdasstrResponse]      -- Pointer to a sub string that defines the range
**                             of the original server reponse during input
**                             and contains portion of the original server
**                             response that has the SOAP header skipped.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_SOAPXML_XML_FORMAT if expected XML node
**                          cannot be parsed out from the server response.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_SkipSOAPHeaders(
    __in_ecount( f_pdasstrResponse->m_ich + f_pdasstrResponse->m_cch ) DRM_CHAR *f_pszResponse,
    IN OUT DRM_SUBSTRING *f_pdasstrResponse )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrTemp = EMPTY_DRM_SUBSTRING;

    ChkArg( f_pszResponse != NULL );
    ChkArg( f_pdasstrResponse != NULL );

    /* Strip out the standard SOAP headers. */
    ChkDR( DRM_XML_GetNodeA( f_pszResponse,
                             f_pdasstrResponse,
                             &g_dastrSOAPEnvelopeTag,
                             NULL,
                             NULL,
                             0,
                             NULL,
                             &dasstrTemp ) );

    *f_pdasstrResponse = dasstrTemp;

    ChkDR( DRM_XML_GetNodeA( f_pszResponse,
                             f_pdasstrResponse,
                             &g_dastrSOAPBodyTag,
                             NULL,
                             NULL,
                             0,
                             NULL,
                             &dasstrTemp ) );

    *f_pdasstrResponse = dasstrTemp;

ErrorExit:

    if ( DRM_FAILED( dr ) && dr != DRM_E_INVALIDARG )
    {
        dr = DRM_E_SOAPXML_XML_FORMAT;
    }

    return dr;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_CalcSOAPHeaderCharCount
**
** Synopsis: Function that calculates the character count of a SOAP
**           header that has an envelope and a body tag.
**
** Arguments:               N/A
**
** Returns:                 A long integer value that is the character
**                          count of the calculated SOAP header.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_DWORD DRM_CALL DRM_SOAPXML_CalcSOAPHeaderCharCount( DRM_VOID )
{
    DRM_DWORD cchCount = 0;

    /* <soap12:Envelope ... > */
    cchCount += DRM_XMB_RequiredCharsForTag( g_dastrSOAPEnvelopeTag.cchString,
                                             0,
                                             g_dastrSOAPEnvelopeAttrib1Name.cchString,
                                             g_dastrSOAPEnvelopeAttrib1Value.cchString );

    cchCount += DRM_XMB_RequiredCharsForTag( 0,
                                             0,
                                             g_dastrSOAPEnvelopeAttrib2Name.cchString,
                                             g_dastrSOAPEnvelopeAttrib2Value.cchString );

    cchCount += DRM_XMB_RequiredCharsForTag( 0,
                                             0,
                                             g_dastrSOAPEnvelopeAttrib3Name.cchString,
                                             g_dastrSOAPEnvelopeAttrib3Value.cchString );

    /* <soap12:Body> */
    cchCount += DRM_XMB_RequiredCharsForTag( g_dastrSOAPBodyTag.cchString,
                                             0,
                                             0,
                                             0 );

    return cchCount;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_PrependXMLRoot
**
** Synopsis: Function that prepend a XML root tag at the beginning of
**           a XML string.
**
** Arguments:
**
** [f_pdastrXML]            -- Pointer to a DRM ANSI string that is the XML
**                             string where the XML root tag is going to
**                             be prepended.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Note:                    Caller needs to make sure the passed in string
**                          has a buffer that is big enough to accomodate
**                          the inserted XML root tag.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_PrependXMLRoot(
    IN OUT DRM_ANSI_STRING *f_pdastrXML )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDRMANSIString( f_pdastrXML );

    /* Reserve space at the beginning of the passed in XMLs string. */
    ChkDR( DRM_UTL_StringInsertBlankSubStringA( f_pdastrXML,
                                                0,
                                                g_dastrXMLRootTag.cchString ) );

    MEMCPY( f_pdastrXML->pszString,
            PB_DASTR( &g_dastrXMLRootTag ),
            CB_DASTR( &g_dastrXMLRootTag ) );

ErrorExit:

    return dr;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_BuildSOAPHeaderXML
**
** Synopsis: Function that constructs a SOAP header using the XML builder.
**
** Arguments:
**
** [f_poXMLContext]         -- Pointer to a XML builder context.
** [f_cbXMLContext]         -- Size (number of bytes) of internal buffer
**                             of a XML builder context.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_BuildSOAPHeaderXML(
    IN OUT _XMBContextA *f_poXMLContext,
    IN DRM_DWORD f_cbXMLContext )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_SOAPXML, PERF_FUNC_DRM_SOAPXML_BuildSOAPHeaderXML );

    ChkArg( f_poXMLContext != NULL );

    /*
    ** Add and open <soap12:Envelope> node.
    **
    ** Output:
    ** <soap12:Envelope ... >
    */
    ChkDR( DRM_XMB_CreateDocumentA( f_cbXMLContext,
                                    ( DRM_BYTE * )f_poXMLContext,
                                    &g_dastrSOAPEnvelopeTag ) );

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrSOAPEnvelopeAttrib1Name,
                                  &g_dastrSOAPEnvelopeAttrib1Value ) );

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrSOAPEnvelopeAttrib2Name,
                                  &g_dastrSOAPEnvelopeAttrib2Value ) );

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContext,
                                  &g_dastrSOAPEnvelopeAttrib3Name,
                                  &g_dastrSOAPEnvelopeAttrib3Value ) );

    /*
    ** Add and open <soap12:Body> node.
    **
    ** Output:
    ** <soap12:Body ... >
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContext,
                              &g_dastrSOAPBodyTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

#endif

/*********************************************************************
**
** Function: DRM_SOAPXML_PrepareXMLContext
**
** Synopsis: Function that initializes a XML builder context over the
**           passed in buffer.
**
** Arguments:
**
** [f_pbXMLContext]         -- Pointer to a buffer on which the XML builder
**                             context is to be created.
** [f_cbXMLContext]         -- Size (number of bytes) of the XML builder
**                             context to be created.
** [f_ppoXMLContext]        -- Pointer to a pointer to the created XML builder
**                             context.
** [f_pcbXMLContext]        -- Pointer to a variable that receives the total size
**                             (number of bytes) of the created XML builder context.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_PrepareXMLContext(
    __in_bcount( f_cbXMLContext ) DRM_BYTE *f_pbXMLContext,
    IN DRM_DWORD f_cbXMLContext,
    __deref_out_bcount( *f_pcbXMLContext ) _XMBContextA **f_ppoXMLContext,
    OUT DRM_DWORD *f_pcbXMLContext )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pbXMLContext != NULL );
    ChkArg( f_cbXMLContext > 0 );
    ChkArg( f_ppoXMLContext != NULL );
    ChkArg( f_pcbXMLContext != NULL );

    ZEROMEM( f_pbXMLContext, f_cbXMLContext );

    ChkDR( DRM_UTL_EnsureDataAlignment( f_pbXMLContext,
                                        f_cbXMLContext,
                                        ( DRM_BYTE ** )f_ppoXMLContext,
                                        f_pcbXMLContext,
                                        SIZEOF( DRM_DWORD ),
                                        NULL ) );

ErrorExit:

    return dr;
}

static DRM_NO_INLINE DRM_RESULT _GetProtocol(
    __in_bcount( f_cbResponse ) const DRM_BYTE       *f_pbResponse,
    __in                              DRM_DWORD       f_cbResponse,
    __out                             DRM_DWORD      *f_pdwProtocolType )
{
    DRM_RESULT            dr               = DRM_SUCCESS;
    DRM_DWORD             iProtocol        = DRM_SOAPXML_PROTOCOL_UNKNOWN+1;  /* Start at the first real protocol */
    DRM_BOOL              fDataFound       = FALSE;
    DRM_ANSI_CONST_STRING dastrResponse    = EMPTY_DRM_STRING;
    DRM_SUBSTRING         dasstrResponse   = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING         dasstrData       = EMPTY_DRM_SUBSTRING;

    ChkArg( f_pdwProtocolType != NULL );
    ChkArg( f_pbResponse != NULL );
    ChkArg( f_cbResponse > 0 );

    DASTR_FROM_PB( &dastrResponse, f_pbResponse, f_cbResponse );

    dasstrResponse.m_ich = 0;
    dasstrResponse.m_cch = dastrResponse.cchString;

#if DRM_USE_SOAP

    ChkDR( DRM_SOAPXML_SkipSOAPHeaders( ( DRM_CHAR * )dastrResponse.pszString,
                                        &dasstrResponse ) );
#endif

    /*
    ** Scan through the known protocols looking for data sections
    */
    while( !fDataFound && ( iProtocol <= DRM_SOAPXML_PROTOCOL_MAXIMUM_DEFINED ) )
    {
        if( g_rgSoapProtoDefines[iProtocol].pdastrDataPath != NULL )
        {
            dr = DRM_XML_GetSubNodeByPathA( ( DRM_CHAR * )dastrResponse.pszString,
                                             &dasstrResponse,
                                              g_rgSoapProtoDefines[iProtocol].pdastrDataPath,
                                              NULL,
                                              NULL,
                                             &dasstrData,
                                              NULL,
                                              g_chForwardSlash );
            if( DRM_SUCCEEDED( dr ) )
            {
                fDataFound = TRUE;
            }
        }
        if( !fDataFound )
        {
            iProtocol += 1;
        }
    }

    ChkBOOL( fDataFound, DRM_E_SOAPXML_PROTOCOL_NOT_SUPPORTED );

    *f_pdwProtocolType = iProtocol;


ErrorExit:
    return dr;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_ValidateProtocolSignature
**
** Synopsis: Loops through the known DRM Protocol Response types.
**           If the data section for the type is found then it looks for
**           a signature node. If the signature node is found, the signature
**           is validated against the data section. If there is no signature,
**           then we look for Custom Data. A signature must be included
**           when there is a custom data node.
**
**           If a protocol type is given, but doesn't match we will try to
**           validate for an Exception message.
**
** Arguments:
**
** [f_pbResponse]           -- Pointer to a buffer that contains the server
**                             response.
** [f_cbResponse]           -- Size (number of bytes) of the server response.
** [f_pbScratchBCertBuffer] -- Pointer to a scratch buffer for cert processing
** [f_cbScratchBCertBuffer] -- Size (number of bytes) of the scratch buffer.
**                             Return walue is size of meter cert.
** [f_poBBXContext]         -- Pointer to a BlackBox context for Signature validation.
** [f_pdwProtocolType]      -- Dword Protocol Type. If this is DRM_SOAPXML_PROTOCOL_UNKNOWN
**                             then we loop through all protocols. We store the protocol here
**                             exit.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_SOAPXML_SIGNATURE_MISSING if custom data is found
**                              without a signature node.
**                          DRM_E_XMLSIG_SHA_VERIFY_FAILURE - if signature validation is failing
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_ValidateProtocolSignature(
    __in_bcount( f_cbResponse )   const DRM_BYTE       *f_pbResponse,
    __in                                DRM_DWORD       f_cbResponse,
    __inout_bcount( f_cbScratchBCertBuffer )
                                        DRM_BYTE       *f_pbScratchBCertBuffer,
    __in                          const DRM_DWORD       f_cbScratchBCertBuffer,
    __in                                DRM_BB_CONTEXT *f_poBBXContext,
    __inout                             DRM_DWORD      *f_pdwProtocolType )
{
    DRM_RESULT            dr                         = DRM_SUCCESS;
    DRM_ANSI_CONST_STRING dastrResponse              = EMPTY_DRM_STRING;
    DRM_SUBSTRING         dasstrResponse             = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING         dasstrData                 = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING         dasstrCustomData           = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING         dasstrSignature            = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING         dasstrMeterCert            = EMPTY_DRM_SUBSTRING;
    DRM_DWORD             cbMeterCert                = 0;
    PUBKEY_P256           oECC256PubKey              = { 0 };
    DRM_BOOL              fPubKeyFromMeterCertIsUsed = FALSE;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_SOAPXML, PERF_FUNC_DRM_SOAPXML_ValidateProtocolSignature );

    ChkArg( f_pbResponse != NULL );
    ChkArg( f_cbResponse > 0 );
    ChkArg( f_pbScratchBCertBuffer != NULL );
    ChkArg( f_pdwProtocolType != NULL );
    ChkArg( *f_pdwProtocolType <= DRM_SOAPXML_PROTOCOL_MAXIMUM_DEFINED );

    DASTR_FROM_PB( &dastrResponse, f_pbResponse, f_cbResponse );

    dasstrResponse.m_ich = 0;
    dasstrResponse.m_cch = dastrResponse.cchString;

#if DRM_USE_SOAP

    ChkDR( DRM_SOAPXML_SkipSOAPHeaders( ( DRM_CHAR * )dastrResponse.pszString,
                                        &dasstrResponse ) );
#endif

    /*
    ** If they didn't tell use the protocol try to find out.
    */
    if ( *f_pdwProtocolType == DRM_SOAPXML_PROTOCOL_UNKNOWN )
    {
        ChkDR( _GetProtocol( f_pbResponse, f_cbResponse, f_pdwProtocolType ) );
    }

    if ( g_rgSoapProtoDefines[*f_pdwProtocolType].pdastrDataPath != NULL )
    {
        dr = DRM_XML_GetSubNodeByPathA( ( DRM_CHAR * )dastrResponse.pszString,
                                       &dasstrResponse,
                                        g_rgSoapProtoDefines[*f_pdwProtocolType].pdastrDataPath,
                                        NULL,
                                        NULL,
                                       &dasstrData,
                                        NULL,
                                        g_chForwardSlash );

        /*
        ** If we didn't match the protocol above, see if it's an exception
        */
        if ( DRM_FAILED(dr) )
        {
            ChkDR( DRM_XML_GetSubNodeByPathA( ( DRM_CHAR * )dastrResponse.pszString,
                                             &dasstrResponse,
                                              g_rgSoapProtoDefines[DRM_SOAPXML_PROTOCOL_EXCEPTION].pdastrDataPath,
                                              NULL,
                                              NULL,
                                             &dasstrData,
                                              NULL,
                                              g_chForwardSlash ) );
            /*
            ** Don't make the assignment to the variable until after checking.
            */
            *f_pdwProtocolType = DRM_SOAPXML_PROTOCOL_EXCEPTION;
        }
        else
        {
            if ( *f_pdwProtocolType == DRM_SOAPXML_PROTOCOL_METERING_DATA_RESPONSE )
            {
                dr =  DRM_XML_GetSubNodeByPathA( ( DRM_CHAR * )dastrResponse.pszString,
                                                 &dasstrData,
                                                 &g_dastrMeteringMeterCertTag,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 &dasstrMeterCert,
                                                 g_chForwardSlash );

                ChkBOOL( DRM_SUCCEEDED( dr ) || dr == DRM_E_XMLNOTFOUND, dr );

                /* if meter cert is found then obtain public key */
                if ( DRM_SUCCEEDED( dr ) )
                {
                    /* Clean out scratch buffer before use */
                    ZEROMEM( f_pbScratchBCertBuffer, f_cbScratchBCertBuffer );

                    cbMeterCert = f_cbScratchBCertBuffer;
                    ChkDR( DRM_B64_DecodeA( ( DRM_CHAR * )dastrResponse.pszString,
                                             &dasstrMeterCert,
                                             &cbMeterCert,
                                             f_pbScratchBCertBuffer,
                                             0 ) );

                    ChkDR( DRM_BCert_GetPublicKey( f_pbScratchBCertBuffer, f_cbScratchBCertBuffer, 0, &oECC256PubKey ) );

                    /* Clean out scratch buffer after use */
                    ZEROMEM( f_pbScratchBCertBuffer, f_cbScratchBCertBuffer );

                    fPubKeyFromMeterCertIsUsed = TRUE;
                }
            }
        }

    }

    /*
    ** Extract <Signature> node from the server response if exists.
    */
    dr = DRM_XML_GetSubNodeByPathA( dastrResponse.pszString,
                                   &dasstrResponse,
                                    g_rgSoapProtoDefines[*f_pdwProtocolType].pdastrSignaturePath,
                                    NULL,
                                    NULL,
                                   &dasstrSignature,
                                    NULL,
                                    g_chForwardSlash );

    if ( DRM_SUCCEEDED( dr ) )
    {
        ChkDR( DRM_XMLSIG_VerifySignature( dastrResponse.pszString,
                                           &dasstrData,
                                           dastrResponse.pszString,
                                           &dasstrSignature,
                                           (fPubKeyFromMeterCertIsUsed)?&oECC256PubKey:&g_oWMRMECC256PubKey,
                                           f_poBBXContext ) );
    }
    else /* If we don't have a Signature node, let's make sure we don't have custom data. */
    {
        dr = DRM_SUCCESS; /* Make sure this is success here, before checking for custom data. */

        /*
        ** Check that either the signature is not require or we don't have custom data.
        */
        ChkBOOL( !g_rgSoapProtoDefines[*f_pdwProtocolType].fSignatureRequired
               || DRM_FAILED(
                    DRM_XML_GetSubNodeByPathA( ( DRM_CHAR * )dastrResponse.pszString,
                                              &dasstrResponse,
                                               g_rgSoapProtoDefines[*f_pdwProtocolType].pdastrCustomDataPath,
                                               NULL,
                                               NULL,
                                              &dasstrCustomData,
                                               NULL,
                                               g_chForwardSlash ) ),
                 DRM_E_SOAPXML_SIGNATURE_MISSING );
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/*********************************************************************
**
** Function: _ParseCustomData
**
** Synopsis: Function that tries to parse out the custom data string from
**           the server response.
**           The function has no prior knowledge of the type of server
**           response it receives, so it tries all the possibilities by
**           using different XML paths until succeeded, or return failure
**           if none of the known XML path can be used to retrieve the
**           custom data string.
**
**
**
** Arguments:
**
** [f_pbResponse]           -- Pointer to a buffer that contains the server
**                             response.
** [f_cbResponse]           -- Size (number of bytes) of the server response.
** [f_pchCustomData]        -- Pointer to a character buffer to receive the parsed
**                             out custom string. If it is NULL, the function
**                             returns an error and the size of the required buffer
**                             is stored in *f_cchCustomData.
** [f_cchCustomData]        -- Pointer to a variable that contains the size (in
**                             characters) of the buffer mentioned above during
**                             input and receives the size (in characters) of the
**                             custom data during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the custom data is not big enough.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _ParseCustomData(
    IN const DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    OUT DRM_CHAR *f_pchCustomData,
    IN OUT DRM_DWORD *f_pcchCustomData )
{
    DRM_RESULT dr         = DRM_SUCCESS;
    DRM_DWORD  dwProtocol = DRM_SOAPXML_PROTOCOL_UNKNOWN;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_SOAPXML, PERF_FUNC__ParseCustomData );

    ChkArg( f_pbResponse != NULL );
    ChkArg( f_cbResponse > 0 );
    ChkArg( f_pcchCustomData != NULL );

    ChkDR( _GetProtocol( f_pbResponse, f_cbResponse, &dwProtocol ) );

    ChkDR( DRM_SOAPXML_ParseCustomDataForProtocol( f_pbResponse,
                                                   f_cbResponse,
                                                   dwProtocol,
                                                   f_pchCustomData,
                                                   f_pcchCustomData ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _ParseCustomDataByPath
**
** Synopsis: Function that tries to parse out the custom data string from
**           the server response using a particular XML path.
**
** Arguments:
**
** [f_pbResponse]           -- Pointer to a buffer that contains the server
**                             response.
** [f_cbResponse]           -- Size (number of bytes) of the server response.
** [f_pdastrPath]           -- Pointer to a DRM string that contains the XML
**                             path used to parse out the custom data.
** [f_pchCustomData]        -- Pointer to a character buffer to receive the parsed
**                             out custom string. If it is NULL, the function
**                             returns an error and the size of the required buffer
**                             is stored in *f_cchCustomData.
** [f_pcchCustomData]       -- Pointer to a variable that contains the size (in
**                             characters) of the buffer mentioned above during
**                             input and receives the size (in characters) of the
**                             custom data during output. If it is NULL, it means
**                             that the caller only wants to know whether there is
**                             custom data but is not interest in the size of the
**                             custom data. If f_pcchCustomData is NULL,
**                             f_pchCustomData must also be NULL.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the custom data is not big enough.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _ParseCustomDataByPath(
    __in_bcount( f_cbResponse ) const DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    IN const DRM_ANSI_CONST_STRING *f_pdastrPath,
    __out_ecount_opt( *f_pcchCustomData ) DRM_CHAR *f_pchCustomData,
    IN OUT DRM_DWORD *f_pcchCustomData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_ANSI_CONST_STRING dastrResponse = EMPTY_DRM_STRING;
    DRM_SUBSTRING dasstrResponse = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrNode = EMPTY_DRM_SUBSTRING;
    DRM_DWORD cchOffset = 0;
    DRM_BYTE bSave = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_SOAPXML, PERF_FUNC__ParseCustomDataByPath );

    ChkArg( f_pbResponse != NULL );
    ChkArg( f_cbResponse > 0 );
    ChkDRMANSIString( f_pdastrPath );
    ChkArg( f_pcchCustomData != NULL || f_pchCustomData == NULL );

    DASTR_FROM_PB( &dastrResponse, f_pbResponse, f_cbResponse );

    dasstrResponse.m_ich = 0;
    dasstrResponse.m_cch = dastrResponse.cchString;

#if DRM_USE_SOAP

    ChkDR( DRM_SOAPXML_SkipSOAPHeaders( ( DRM_CHAR * )dastrResponse.pszString,
                                        &dasstrResponse ) );

#endif

    ChkDR( DRM_XML_GetSubNodeByPathA( ( DRM_CHAR * )dastrResponse.pszString,
                                      &dasstrResponse,
                                      f_pdastrPath,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &dasstrNode,
                                      g_chForwardSlash ) );

    ChkBOOL( f_pcchCustomData != NULL, DRM_E_BUFFERTOOSMALL );

    /*
    ** DRM_SOAPXML_DecodeData() only takes an DRM_WORD aligned buffer so some
    ** manipulation is needed when the code is running on a 16-bits addressing
    ** system. The manipulation is to shift the data to be XML decoded one byte
    ** to have it start at a DRM_WORD aligned address. After the XML decoding,
    ** the data is shifted back to its original address. A byte at the end of
    ** the original data will be saved before the shift, and will be restored
    ** after the shift.
    ** Please note that the code assumes there is at least one byte that follows
    ** the data to be XML decoded. Since the data to be XML decoded is always
    ** wrapped in a XML node, the assumption is valid.
    */
    if ( dasstrNode.m_ich % CB_NATIVE_BYTE != 0 )
    {
        /* The buffer needd to be shifted for at most one byte. */
        cchOffset = 1;

        /* Save the one byte that will be overwritten. */
        bSave = GET_BYTE( ( DRM_BYTE * )dastrResponse.pszString, dasstrNode.m_ich + dasstrNode.m_cch );

        /* Shift the custom data string one byte ahead. */
        DRM_BYT_MoveBytes( ( DRM_BYTE * )dastrResponse.pszString,
                           dasstrNode.m_ich + 1,
                           ( DRM_BYTE * )dastrResponse.pszString,
                           dasstrNode.m_ich,
                           dasstrNode.m_cch );
    }

    dr = DRM_SOAPXML_DecodeData( ( DRM_CHAR * )dastrResponse.pszString + __CB_DECL( dasstrNode.m_ich + cchOffset ),
                                   dasstrNode.m_cch,
                                   f_pchCustomData,
                                   f_pcchCustomData );

    if ( dasstrNode.m_ich % CB_NATIVE_BYTE != 0 )
    {
        /* Restore the overwritten byte. */
        DRM_BYT_MoveBytes( ( DRM_BYTE * )dastrResponse.pszString,
                           dasstrNode.m_ich,
                           ( DRM_BYTE * )dastrResponse.pszString,
                           dasstrNode.m_ich + 1,
                           dasstrNode.m_cch );

        PUT_BYTE( ( DRM_BYTE * )dastrResponse.pszString, dasstrNode.m_ich + dasstrNode.m_cch, bSave );
    }

    ChkDR( dr );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_ParseCustomDataForProtocol
**
** Synopsis: Function that tries to parse out the custom data string from
**           the server response using a particular XML path.
**
** Arguments:
**
** [f_pbResponse]           -- Pointer to a buffer that contains the server
**                             response.
** [f_cbResponse]           -- Size (number of bytes) of the server response.
** [f_dwProtocolType]       -- Protocol Type ID, member of DRM_SOAPXML_PROTOCOL_TYPE.
** [f_pchCustomData]        -- Pointer to a character buffer to receive the parsed
**                             out custom string. If it is NULL, the function
**                             returns an error and the size of the required buffer
**                             is stored in *f_cchCustomData.
** [f_pcchCustomData]       -- Pointer to a variable that contains the size (in
**                             characters) of the buffer mentioned above during
**                             input and receives the size (in characters) of the
**                             custom data during output. If it is NULL, it means
**                             that the caller only wants to know whether there is
**                             custom data but is not interest in the size of the
**                             custom data. If f_pcchCustomData is NULL,
**                             f_pchCustomData must also be NULL.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_SOAPXML_PROTOCOL_NOT_SUPPORTED if the prtocol type given doesn't have an entry in the array.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the custom data is not big enough.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_ParseCustomDataForProtocol(
    __in_bcount( f_cbResponse )     const DRM_BYTE  *f_pbResponse,
    __in                                  DRM_DWORD  f_cbResponse,
    __in                                  DRM_DWORD  f_dwProtocolType,
    __out_ecount_opt( *f_pcchCustomData ) DRM_CHAR  *f_pchCustomData,
    __inout_opt                           DRM_DWORD *f_pcchCustomData )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_SOAPXML, PERF_FUNC_DRM_SOAPXML_ParseCustomDataForProtocol );

    ChkArg( f_dwProtocolType <= DRM_SOAPXML_PROTOCOL_MAXIMUM_DEFINED );

    ChkBOOL( g_rgSoapProtoDefines[ f_dwProtocolType ].pdastrCustomDataPath != NULL, DRM_E_SOAPXML_PROTOCOL_NOT_SUPPORTED );

    ChkDR( _ParseCustomDataByPath( f_pbResponse,
                                    f_cbResponse,
                                    g_rgSoapProtoDefines[ f_dwProtocolType ].pdastrCustomDataPath,
                                    f_pchCustomData,
                                    f_pcchCustomData ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_ParseStatusCodeAndChooseBest
**
** Synopsis: Function that parses a server response to look for the
**           status code and whether custom data exists. Also, the
**           caller can pass their current error code and this function
**           will decide whether to overwrite the caller's original code
**           with this new one or pass it as an optional f_pResult output
**           or ignore it.
**
** Arguments:
**
** [f_pbResponse]           -- Pointer to a buffer that contains the server
**                             response.
** [f_cbResponse]           -- Size (number of bytes) of the server response.
** [f_drOriginal]           -- Original error code from the calling function
** [f_pResult]              -- Pointer to a variable that receives the status code.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_SOAPXML_INVALID_STATUS_CODE if the status code
**                          cannot be parsed out from the server response.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_ParseStatusCodeAndChooseBest(
    __in_bcount( f_cbResponse ) const DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    IN DRM_RESULT f_drOriginal,
    OUT DRM_RESULT *f_pResult )
{
    DRM_RESULT dr = f_drOriginal;
    DRM_RESULT drSoapParsing = DRM_SUCCESS;

    if ( f_pResult != NULL )
    {
        *f_pResult = f_drOriginal;

        /* Try to parse out status code from the server response. */
        drSoapParsing = DRM_SOAPXML_ParseStatusCode( f_pbResponse,
                                           f_cbResponse,
                                           f_pResult );

        /* If the SOAP parsing failed and we didn't otherwise fail, we should use that SOAP parse error
        ** code unless it's the error code that happens when there just isn't a code present in the response
        */
        if( !DRM_FAILED(f_drOriginal)
          && drSoapParsing != DRM_E_SOAPXML_XML_FORMAT
          && DRM_FAILED(drSoapParsing) )
        {
            dr = drSoapParsing;
            *f_pResult = drSoapParsing;
        }
    }
    else if( f_pResult == NULL )
    {
        DRM_RESULT drSoap = DRM_SUCCESS;

        /* The caller didn't give us somewhere to output the SOAP error. If there was an error, we
        ** should return the code as part of our normal dr return
        */
        drSoapParsing = DRM_SOAPXML_ParseStatusCode( f_pbResponse,
                                           f_cbResponse,
                                          &drSoap );

        /* If the SOAP parsing failed and we didn't otherwise fail, we should use that SOAP parse error
        ** code unless it's the error code that happens when there just isn't a code present in the response.
        ** Also, if there was a failure code in the SOAP response but no other errors elsewhere, we should
        ** return that.
        */
        if( !DRM_FAILED(f_drOriginal) && drSoapParsing != DRM_E_SOAPXML_XML_FORMAT )
        {
            if( DRM_FAILED(drSoapParsing) )
            {
                /* SOAP parsing failed but the original function didn't, we should return that parsing
                ** error
                */
                dr = drSoapParsing;
            }
            else if( DRM_FAILED( drSoap ) )
            {
                /* There was a failure code in the SOAP message from the server, since nothing else
                ** failed we should return this
                */
                dr = drSoap;
            }
        }
    }

    return dr;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_ParseStatusCode
**
** Synopsis: Function that parses a server response to look for the
**           status code and whether custom data exists.
**
** Arguments:
**
** [f_pbResponse]           -- Pointer to a buffer that contains the server
**                             response.
** [f_cbResponse]           -- Size (number of bytes) of the server response.
** [f_pResult]              -- Pointer to a variable that receives the status code.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_SOAPXML_INVALID_STATUS_CODE if the status code
**                          cannot be parsed out from the server response.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_ParseStatusCode(
    __in_bcount( f_cbResponse ) const DRM_BYTE   *f_pbResponse,
    __in                              DRM_DWORD   f_cbResponse,
    __out                             DRM_RESULT *f_pResult )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_ANSI_CONST_STRING dastrResponse = EMPTY_DRM_STRING;
    DRM_SUBSTRING dasstrResponse = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrData = EMPTY_DRM_SUBSTRING;
    DRM_BYTE rgbStatusCode[ 2 * DRM_MAX_CCH_BASE16_DWORD_STRING ] = { 0 };
    DRM_DWORD dwStatusCode = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_SOAPXML, PERF_FUNC_DRM_SOAPXML_ParseStatusCode );

    ChkArg( f_pbResponse != NULL );
    ChkArg( f_cbResponse > 0 );
    ChkArg( f_pResult != NULL );

    DASTR_FROM_PB( &dastrResponse, f_pbResponse, f_cbResponse );

    dasstrResponse.m_ich = 0;
    dasstrResponse.m_cch = dastrResponse.cchString;

#if DRM_USE_SOAP

    ChkDR( DRM_SOAPXML_SkipSOAPHeaders( ( DRM_CHAR * )dastrResponse.pszString,
                                        &dasstrResponse ) );

#endif

    /* Extract <StatusCode> node from <soap:Fault>/<detail> node. */
    dr = DRM_XML_GetSubNodeByPathA( dastrResponse.pszString,
                                      &dasstrResponse,
                                      &g_dastrSOAPStatusCodePath,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &dasstrData,
                                      g_chForwardSlash );
    if( DRM_E_XMLNOTFOUND == dr )
    {
        ChkDR( DRM_E_SOAPXML_XML_FORMAT );
    }
    ChkDR( dr );

    ChkOverflow( dasstrData.m_cch + 1, dasstrData.m_cch );

    ChkBOOL( dasstrData.m_cch < SIZEOF( rgbStatusCode ), DRM_E_SOAPXML_INVALID_STATUS_CODE );

    ZEROMEM( rgbStatusCode, SIZEOF( rgbStatusCode ) );

    DRM_BYT_CopyBytes( rgbStatusCode,
                       0,
                       dastrResponse.pszString,
                       dasstrData.m_ich,
                       dasstrData.m_cch );

    /*
    ** Converts string with value to DWORD, count of valid characters is dasstrData.m_cch.
    */
    dr = DRMCRT_AtoDWORD( ( DRM_CHAR * )rgbStatusCode, dasstrData.m_cch, 16, &dwStatusCode );

    if ( DRM_FAILED( dr ) )
    {
        ChkDR( DRM_E_SOAPXML_INVALID_STATUS_CODE );
    }

    *f_pResult = ( DRM_RESULT )dwStatusCode;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_GetAdditionalResponseData
**
** Synopsis: Function that retrieves a piece of data element string from the
**           server response depending on the passed in data element type.
**
** Arguments:
**
** [f_poBBXContext]         -- Pointer to a black box context.
** [f_pbResponse]           -- Pointer to a buffer that contains the server
**                             response.
** [f_cbResponse]           -- Size (number of bytes) of the server response.
** [f_dwDataType]           -- The data element type of the data string to be
**                             retrieved. Should be one of the DRM_GARD values.
** [f_pchDataString]        -- Pointer to a buffer to receive the data string.
**                             If it is NULL, the function returns an error and
**                             the size of the required buffer is stored in
**                             *f_pcchDataString.
** [f_pcchDataString]       -- Pointer to a variable that contains the size
**                             (in characters) of the buffer to receive the data
**                             string during input and receives the size (in
**                             characters) of the data string during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the data is not big enough.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_GetAdditionalResponseData(
    __in_bcount( f_cbResponse ) const DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    IN DRM_DWORD f_dwDataType,
    __out_ecount_opt( *f_pcchDataString ) DRM_CHAR *f_pchDataString,
    IN OUT DRM_DWORD *f_pcchDataString )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_ANSI_CONST_STRING dastrResponse = EMPTY_DRM_STRING;
    DRM_SUBSTRING dasstrResponse = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrException = EMPTY_DRM_SUBSTRING;
    DRM_ANSI_CONST_STRING *pdastrDataStringPath = NULL;
    DRM_SUBSTRING dasstrData = EMPTY_DRM_SUBSTRING;
    DRM_DWORD cchInput = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_SOAPXML, PERF_FUNC_DRM_SOAPXML_GetAdditionalResponseData );

    ChkArg( f_pbResponse != NULL );
    ChkArg( f_cbResponse > 0 );
    ChkArg( f_pcchDataString != NULL );
    ChkArg( f_pchDataString == NULL || *f_pcchDataString > 0 );

    cchInput = *f_pcchDataString;

    /*
    ** If the data type to get is Custom Data, try to
    ** get custom data for known protocols, including exceptions.
    */
    if ( f_dwDataType == DRM_GARD_CUSTOM_DATA )
    {
        dr = _ParseCustomData( f_pbResponse,
                               f_cbResponse,
                               f_pchDataString,
                               f_pcchDataString );

        if ( dr == DRM_SUCCESS )
        {
            goto ErrorExit;
        }
        else if ( dr == DRM_E_BUFFERTOOSMALL )
        {
            /*
            ** At this point, we found a custom data node,
            ** but the buffer to receive it was too small
            */
            ChkDR( dr );
        }
    }

    /*
    ** At this point, assume the server response is an error response.
    */
    DASTR_FROM_PB( &dastrResponse, f_pbResponse, f_cbResponse );

    dasstrResponse.m_ich = 0;
    dasstrResponse.m_cch = dastrResponse.cchString;

#if DRM_USE_SOAP

    ChkDR( DRM_SOAPXML_SkipSOAPHeaders( ( DRM_CHAR * )dastrResponse.pszString,
                                        &dasstrResponse ) );

#endif

    /* Extract <Exception> node from the server response. */
    ChkDR( DRM_XML_GetSubNodeByPathA( dastrResponse.pszString,
                                      &dasstrResponse,
                                      &g_dastrSOAPExceptionRootPath,
                                      NULL,
                                      NULL,
                                      &dasstrException,
                                      NULL,
                                      g_chForwardSlash ) );

    switch ( f_dwDataType )
    {
        case DRM_GARD_REDIRECT_URL:
            pdastrDataStringPath = ( DRM_ANSI_CONST_STRING * )
                                   &g_dastrSOAPGARDRedirectUrlPath;
            break;

        case DRM_GARD_SERVICE_ID:
            pdastrDataStringPath = ( DRM_ANSI_CONST_STRING * )
                                   &g_dastrSOAPGARDServiceIdPath;
            break;

        case DRM_GARD_ACCOUNT_ID:
            pdastrDataStringPath = ( DRM_ANSI_CONST_STRING * )
                                   &g_dastrSOAPGARDAccountIdPath;
            break;

        default:
            ChkDR( DRM_E_INVALIDARG );
            break;
    }

    /* Extract the data string using the selected path. */
    dr = DRM_XML_GetSubNodeByPathA( dastrResponse.pszString,
                                    &dasstrException,
                                    pdastrDataStringPath,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &dasstrData,
                                    g_chForwardSlash );

    if ( f_pchDataString == NULL ||
         *f_pcchDataString < dasstrData.m_cch )
    {
        *f_pcchDataString = dasstrData.m_cch;

        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    if ( dasstrData.m_cch <= cchInput )
    {
        DRM_BYT_CopyBytes( f_pchDataString,
                           0,
                           dastrResponse.pszString,
                           dasstrData.m_ich,
                           dasstrData.m_cch );
    }

    *f_pcchDataString = dasstrData.m_cch;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: Drm_GetAdditionalResponseData
**
** Synopsis: API that retrieves a piece of data element string from the
**           server response depending on the passed in data element type.
**
** Arguments:
**
** [f_poAppContext]         -- Pointer to a DRM App context initialized via
**                             Drm_Initialize().
** [f_pbResponse]           -- Pointer to a buffer that contains the server
**                             response.
** [f_cbResponse]           -- Size (number of bytes) of the server response.
** [f_dwDataType]           -- The data element type of the data string to be
**                             retrieved. Should be one of the DRM_GARD values.
** [f_pchDataString]        -- Pointer to a buffer to receive the data string.
**                             If it is NULL, the function returns an error and
**                             the size of the required buffer is stored in
**                             *f_pcchDataString.
** [f_pcchDataString]       -- Pointer to a variable that contains the size
**                             (in characters) of the buffer to receive the data
**                             string during input and receives the size (in
**                             characters) of the data string during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to retrieve
**                          the data is not big enough.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_GetAdditionalResponseData(
    IN DRM_APP_CONTEXT *f_poAppContext,
    __in_bcount( f_cbResponse ) const DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    IN DRM_DWORD f_dwDataType,
    __out_ecount_opt( *f_pcchDataString ) DRM_CHAR *f_pchDataString,
    IN OUT DRM_DWORD *f_pcchDataString )
{
    DRM_RESULT                dr               = DRM_SUCCESS;
    DRM_DWORD                 dwProtocol       = DRM_SOAPXML_PROTOCOL_UNKNOWN;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_SOAPXML, PERF_FUNC_Drm_GetAdditionalResponseData );

    ChkArg( f_poAppContext != NULL );
    ChkArg( f_pbResponse != NULL );
    ChkArg( f_cbResponse > 0 );
    ChkArg( f_pcchDataString != NULL );
    ChkArg( f_pchDataString == NULL || *f_pcchDataString > 0 );

    /*
    ** Try to validate the signature before accessing the data.
    */
    ChkDR( _GetProtocol( f_pbResponse, f_cbResponse, &dwProtocol ) );

    ChkDR( DRM_SOAPXML_GetAdditionalResponseData( f_pbResponse,
                                                  f_cbResponse,
                                                  f_dwDataType,
                                                  f_pchDataString,
                                                  f_pcchDataString ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    ChkECC( ECC_Drm_GetAdditionalResponseData, dr );

    return dr;
}

/*********************************************************************
**
** Function: DRM_SOAPXML_EnsureTagValueNativeByteAligned
**
** Synopsis: Function that ensures the value of the XML tag begin at
**           a native byte aligned address in the ANSI/UTF8 XML builder
**           context.
**
** Arguments:
**
** [f_poXMLContext]         -- Pointer to a XML builder context.
** [f_pdstrTagName]         -- Pointer to DRM ANSI string of the XML tag name.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_SOAPXML_EnsureTagValueNativeByteAligned(
    __inout _XMBContextA *f_poXMLContext,
    __in const DRM_ANSI_CONST_STRING *f_pdastrTagName )
{
    DRM_RESULT dr = DRM_SUCCESS;    
    DRM_CHAR *pchCurr = NULL;
    DRM_BOOL fAdjust = FALSE;
        
    ChkArg( f_poXMLContext != NULL );
    ChkDRMANSIString( f_pdastrTagName );

    /* 
    ** Get the current location of the XML builder context. 
    ** This is the location to store the next data to be added
    ** to the XML builder context.
    */
    ChkDR( DRM_XMB_GetCurrentBufferPointerA( f_poXMLContext,
                                             FALSE,
                                             &pchCurr ) );

    DRMASSERT( pchCurr != NULL );

    /* Check whether the XML tag value can be aligned at the native byte boundary. */
    fAdjust = ( ( ( DRM_DWORD )( pchCurr + f_pdastrTagName->cchString ) % CB_NATIVE_BYTE ) != 0 );

    if ( fAdjust )
    {
        *pchCurr = ' ';

         /* 
         ** If the XML tag value is not going to be native byte aligned,
         ** shift the current XML builder context pointer forward by one character.
         */
         ChkDR( DRM_XMB_ShiftCurrentPointerA( f_poXMLContext, 1 ) );
    }

ErrorExit:
    
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmutf.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutf.h>
#include <drmcrt.h>
#include <drmbase64.h>
#include <drmutilities.h>
#include <drmcipher.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

/******************************************************************************
**  This information is from unicode.org specification.
**
**  Terminology:
**  1. "Code Point" - that which is displayed on the screen. Also called a
**                    linguistic character in Windows documentation.
**  2. "Code Unit" - that which is iterated through via index, each of size
**                   size 1, 2, or 4 8bit bytes. Also called a storage
**                   character in Windows documenation. cch always refers to
**                   these.
**
**  The maximum Code Point in unicode is U+10FFFF.
**  The Code Points in the range U+D800..U+DFFF are illegal and reserved for
**  encodings.
**
**
**  UTF-8 Encoding's Bit Distribution:
**  ==================================
**
**  unicode                     bytes   bits   UTF-8 representation
**  --------------------------  -----   ----   -----------------------------------
**  00000000 0xxxxxxx           1       7      0xxxxxxx
**  00000yyy yyxxxxxx           2       11     110yyyyy 10xxxxxx
**  zzzzyyyy yyxxxxxx           3       16     1110zzzz 10yyyyyy 10xxxxxx
**  000uuuuu zzzzyyyy yyxxxxxx  4       21     11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
**  --------------------------  -----   ----   -----------------------------------
**
**  Well-Formed UTF-8 Byte Sequences:
**
**  Unicode ranges      1st Byte  2nd Byte  3rd Byte  4th Byte
**  ------------------  --------  --------  --------  --------
**  U+0000..U+007F      00..7F
**  U+0080..U+07FF      C2..DF    80..BF
**  U+0800..U+0FFF      E0        A0..BF    80..BF
**  U+1000..U+CFFF      E1..EC    80..BF    80..BF
**  U+D000..U+D7FF      ED        80..9F    80..BF
**  U+E000..U+FFFF      EE..EF    80..BF    80..BF
**  U+10000..U+3FFFF    F0        90..BF    80..BF    80..BF
**  U+40000..U+FFFFF    F1..F3    80..BF    80..BF    80..BF
**  U+100000..U+10FFFF  F4        80..8F    80..BF    80..BF
**
**  Notes:
**  1. The special cases for 3 bytes characters are due to the illegality of
**     the range U+D800..U+DFFF.
**  2. UTF-8 rules do not allow using a larger format to represent a unicode
**     value encode-able with fewer bytes.
**
**
**  UTF-16 Encoding Rules:
**  ======================
**  1. Code points in the range U+0000..U+FFFF are encoded using one UTF-16
**     value.
**  2. Code points in the range U+10000..U+10FFFF are encoded first by
**     subtracting 0x10000 to get a 20bit number, then by storing them in two
**     UTF-16 values, each containing 10bits:
**       1. The first "surrogate" is in the range 0xD800-0xDBFF.
**       2. The second "surrogate" is in the range 0xDC00-0xDFFF.
**
**  Notes:
**  1. There is no confusion between surrogates and U+D800..U+DFFF as the
**     latter is an illegal range.
**  2. UTF-16 *is* endian-specific, and both little endian (UTF-16LE), big
**     endian (UTF-16BE), and auto-detection (via BOM) are defined. This file
**     only supports standard little-endian characters.
**
**     UTF-16LE encoding scheme: 
**     The Unicode encoding scheme that serializes a UTF-16
**     code unit sequence as a byte sequence in little-endian format.
**
**     In UTF-16LE, the UTF-16 code unit sequence <004D 0430 4E8C D800 DF02> is
**     serialized as <4D 00 30 04 8C 4E 00 D8 02 DF>.
** 
**     In UTF-16LE, an initial byte sequence <FF FE> is interpreted as 
**     U+FEFF zero width no-break space.
**
**
**  UTF-32 Encoding Rules:
**  ======================
**  A 32bit code unit has all the space and more necessary to hold the max
**  code point. As such, no conversion is necessary.
**
**  Notes: 
**     UTF-32 *is* endian-specific, and both little endian (UTF-32LE), big
**     endian (UTF-32BE), and auto-detection (via BOM) are defined. This file
**     only supports standard little-endian characters.
**
**     UTF-32LE encoding scheme: 
**     The Unicode encoding scheme that serializes a UTF-32
**     code unit sequence as a byte sequence in little-endian format.
**
**     In UTF-32LE, the UTF-32 code unit sequence 
**     <0000004D 00000430 00004E8C 00010302> is serialized as 
**     <4D 00 00 00 30 04 00 00 8C 4E 00 00 02 03 01 00>.
** 
**     In UTF-32LE, an initial byte sequence <FF FE 00 00> is interpreted as 
**     U+FEFF zero width no-break space.
**
******************************************************************************/

/*
** This file internally deals in code points, which use native endian-ness.
** When converting the DRM_WCHAR32, an endian conversion may be necessary.
*/
typedef DRM_UINT DRM_CODE_POINT;

/*
** Any code point greater than 0x10FFFF is ill-formed.
*/
#define UTF_MAX_CODE_POINT (DRM_WCHAR32)0x0010FFFFUL

/*
** Unicode has 17 "planes", each with 2^16 code points. The exception is the
** "Base Multilingual Plane" (#0) which lacks the values U+D800..U+DFFF.
*/
#define UTF_PLANE0_MAX     (DRM_WCHAR32)0x0000FFFFUL
#define UTF_PLANE1_MIN     (DRM_WCHAR32)0x00010000UL

/* ---------------------- UTF-8 constants and macros ---------------------- */

#define UTF8_MIN_TWO_BYTE_CP    0x80UL
#define UTF8_MIN_THREE_BYTE_CP  0x800UL
#define UTF8_MIN_FOUR_BYTE_CP   UTF_PLANE1_MIN

/*
** Test that this byte looks like 10vvvvvv
** so that its value is in 80..BF range
*/
#define IS_UTF8_TRAILING_CH(b) (((b) & 0xC0) == 0x80)

/*
** 110yyyyy 10xxxxxx -> 00000000 00000000 00000yyy yyxxxxxx
*/
#define UTF_CP_FROM_TWO_CH(b1,b2) \
    ( ( ( ( (b1) & 0x1FUL ) << 0x6 ) | ( (b2) & 0x3FUL ) ) & 0x7FF )
/*
** 1110zzzz 10yyyyyy 10xxxxxx -> 00000000 00000000 zzzzyyyy yyxxxxxx
*/
#define UTF_CP_FROM_THREE_CH(b1,b2,b3) \
    ( ( ( ( (b1) & 0xFUL ) << 0xC ) | ( ( (b2) & 0x3FUL ) << 0x6 ) | ( (b3) & 0x3FUL ) ) & 0xFFFFUL )

/*
** 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx -> 00000000 000uuuuu zzzzyyyy yyxxxxxx
*/
#define UTF_CP_FROM_FOUR_CH(b1,b2,b3,b4) \
    ( ( ( ( (b1) & 0x7UL ) << 0x12 ) | ( ( (b2) & 0x3FUL ) << 0xC ) | ( ( (b3) & 0x3FUL ) << 0x6 ) | ( (b4) & 0x3FUL ) ) & 0x1FFFFFUL )

/*
** Takes a 6 bit value and converts to a trailing UTF-8 code unit.
*/
#define UTF8_MAKE_TRAILING_CH(_b_) ( (_b_) | 0x80 )

/*
** Creates a lead ch for UTF8 given
** a) The number of code units /top bits (n = 2-4), and
** b) The value bits in the lead byte (max bits is 7-n, i.e. going from 5 to 3).
*/
#define UTF8_MAKE_LEAD_CH(_n_, _b_) \
    ( ( ( 0xF0 << ( 4 - (_n_) ) ) | (_b_) ) & 0xFF )


/* ---------------------- UTF-16 constants and macros --------------------- */

/*
** High-surrogate code unit: A 16-bit code unit in the range 0xD800 to 0xDBFF,
** used in UTF-16 as the leading code unit of a surrogate pair.
**
** Low-surrogate code unit: A 16-bit code unit in the range 0xDC00 to 0xDFFF,
** used in UTF-16 as the trailing code unit of a surrogate pair.
*/
#define UTF16_HIGH_SURROGATE_MIN_CP  (DRM_CODE_POINT)0xD800UL
#define UTF16_HIGH_SURROGATE_MAX_CP  (DRM_CODE_POINT)0xDBFFUL
#define UTF16_LOW_SURROGATE_MIN_CP   (DRM_CODE_POINT)0xDC00UL
#define UTF16_LOW_SURROGATE_MAX_CP   (DRM_CODE_POINT)0xDFFFUL

#define FLIP_DWORD_BYTES(_dw_) ( ((_dw_)&0xFF000000UL) >>24 | \
                                 ((_dw_)&0x00FF0000UL) >> 8 | \
                                 ((_dw_)&0x0000FF00UL) << 8 | \
                                 ((_dw_)&0x000000FFUL) <<24 )

#define FLIP_WORD_BYTES(_w_)  ( ((_w_)&0xFF00UL) >> 8 | \
                                ((_w_)&0x00FFUL) << 8 )

#if TARGET_LITTLE_ENDIAN 

#define IS_UTF16_HIGH_SURROGATE_WCH(_wch16_) \
    ( (_wch16_) >= UTF16_HIGH_SURROGATE_MIN_CP && \
      (_wch16_) <= UTF16_HIGH_SURROGATE_MAX_CP )

#define IS_UTF16_LOW_SURROGATE_WCH(_wch16_) \
    ( (_wch16_) >= UTF16_LOW_SURROGATE_MIN_CP && \
      (_wch16_) <= UTF16_LOW_SURROGATE_MAX_CP )

/* Each half has 10 bits of the 20 bit whole */
#define UTF32_FROM_SURROGATES_WCH(_wch16High_, _wch16Low_) \
    ( ( ( (_wch16High_) - UTF16_HIGH_SURROGATE_MIN_CP ) << 10UL ) + \
      ( (_wch16Low_) - UTF16_LOW_SURROGATE_MIN_CP ) + \
      UTF_PLANE1_MIN )

/* Rebase plane1 to zero (yielding a 20bit number instead of a 20bit + 16bit
** number), then take the top ten bits */
#define UTF16_HIGH_SURROGATE_FROM_CP(_cp_) \
    ( ( ( (_cp_) - UTF_PLANE1_MIN ) >> 10 ) + UTF16_HIGH_SURROGATE_MIN_CP )

/* Same as above, but take the bottom ten bits */
#define UTF16_LOW_SURROGATE_FROM_CP(_cp_) \
    ( ( ( (_cp_) - UTF_PLANE1_MIN ) & 0x3FFUL ) + UTF16_LOW_SURROGATE_MIN_CP )

#define UTF_CP_FROM_UTF32(_wch32_) (_wch32_)
#define UTF32_FROM_CP(_cp_) (_cp_)

#else

/*
** UTF-16BE encoding scheme: 
** The Unicode encoding scheme that serializes a UTF-16
** code unit sequence as a byte sequence in big-endian format.
**
** In UTF-16BE, the UTF-16 code unit sequence <004D 0430 4E8C D800 DF02> is
** serialized as <00 4D 04 30 4E 8C D8 00 DF 02>.
**
** In UTF-16BE, an initial byte sequence <FE FF> is interpreted as 
** U+FEFF zero width no-break space
**
**
** UTF-32BE encoding scheme: 
** The Unicode encoding scheme that serializes a UTF-32
** code unit sequence as a byte sequence in big-endian format.
**
** In UTF-32BE, the UTF-32 code unit sequence 
** <0000004D 00000430 00004E8C 00010302> is serialized as 
** <00 00 00 4D 00 00 04 30 00 00 4E 8C 00 01 03 02>.
** 
** In UTF-32BE, an initial byte sequence <00 00 FE FF> is interpreted as 
** U+FEFF zero width no-break space
**
*/

#define IS_UTF16_HIGH_SURROGATE_WCH(_wch16_) \
    ( ( FLIP_WORD_BYTES( _wch16_ ) ) >= UTF16_HIGH_SURROGATE_MIN_CP && \
      ( FLIP_WORD_BYTES( _wch16_ ) ) <= UTF16_HIGH_SURROGATE_MAX_CP )

#define IS_UTF16_LOW_SURROGATE_WCH(_wch16_) \
    ( ( FLIP_WORD_BYTES( _wch16_ ) ) >= UTF16_LOW_SURROGATE_MIN_CP && \
      ( FLIP_WORD_BYTES( _wch16_ ) ) <= UTF16_LOW_SURROGATE_MAX_CP )

/* Each half has 10 bits of the 20 bit whole */
#define UTF32_FROM_SURROGATES_WCH(_wch16High_, _wch16Low_) \
    FLIP_DWORD_BYTES( ( ( ( ( FLIP_WORD_BYTES( _wch16High_ ) ) - UTF16_HIGH_SURROGATE_MIN_CP ) << 10UL ) + \
                      ( ( FLIP_WORD_BYTES( _wch16Low_ ) ) - UTF16_LOW_SURROGATE_MIN_CP ) + \
                      UTF_PLANE1_MIN ) \
                    ) 

/* Rebase plane1 to zero (yielding a 20bit number instead of a 20bit + 16bit
** number), then take the top ten bits */
#define UTF16_HIGH_SURROGATE_FROM_CP(_cp_) \
    FLIP_WORD_BYTES( ( ( (_cp_) - UTF_PLANE1_MIN ) >> 10 ) + UTF16_HIGH_SURROGATE_MIN_CP ) 

/* Same as above, but take the bottom ten bits */
#define UTF16_LOW_SURROGATE_FROM_CP(_cp_) \
    FLIP_WORD_BYTES( ( ( (_cp_) - UTF_PLANE1_MIN ) & 0x3FFUL ) + UTF16_LOW_SURROGATE_MIN_CP )

#define UTF_CP_FROM_UTF32(_wch32_) FLIP_DWORD_BYTES(_wch32_)
#define UTF32_FROM_CP(_cp_) FLIP_DWORD_BYTES(_cp_)

#endif

/* Create a macro that tests for _both_ high and low surrogates. 
** Note: high surrogates are always numerically less than low surrogates
*/
#define IS_UTF16_SURROGATE_CP(_cp_) \
    ( ( _cp_ ) >= UTF16_HIGH_SURROGATE_MIN_CP && \
      ( _cp_ ) <= UTF16_LOW_SURROGATE_MAX_CP )


/*******************************************************************************
** Function: _ReadCodePoint16
**
** Synopsis: Reads a single code point from a buffer of UTF-16 code units.
**
** Arguments:
**
** [f_pwchSource]    -- Pointer to UTF-16 data buffer.
** [f_pdstrwSource]  -- Window covering a range of UTF-16 units.
**                      On success, left edge of window is advanced to the next 
**                      code point. On error, it is unchanged.
** [f_pcp]           -- Pointer that will receive the next code point. On
**                      error this is unchanged.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid (such as a
**                   window with zero or negative width).
**                   DRM_E_UTF_INVALID_CODE - if UTF-16 sequence is illegal
**                   DRM_E_UTF_UNEXPECTED_END - if parsing ended on a partial
**                       character.
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL _ReadCodePoint16(
    IN     const DRM_WCHAR         *f_pwchSource,
    IN OUT       DRM_STRING_WINDOW *f_pdstrwSource,
       OUT       DRM_CODE_POINT    *f_pcp )
{
    DRM_RESULT  dr         = DRM_SUCCESS;
    DRM_DWORD   ich        = 0;
    DRM_WCHAR32 wch32      = 0;
    DRM_WCHAR32 wch16_high = 0;
    DRM_WCHAR32 wch16_low  = 0;

    ChkArg( f_pwchSource != NULL );
    ChkArg( f_pdstrwSource != NULL );
    ChkArg( f_pcp != NULL );
    ChkArg( f_pdstrwSource->m_ichMin < f_pdstrwSource->m_ichMaxExclusive );

    ich = f_pdstrwSource->m_ichMin;

    /* Read the first code unit. It may or may not be part of a two code unit
    ** surrogate pair */
    wch32 = f_pwchSource[ich++];

    if( IS_UTF16_HIGH_SURROGATE_WCH( wch32 ) )
    {
        /* The high surrogate should always be followed by a low surrogate.
        ** First verify there is space. Then verify the subsequent value is
        ** in the correct range */
        ChkBOOL( ich < f_pdstrwSource->m_ichMaxExclusive, DRM_E_UTF_UNEXPECTED_END );

        wch16_high = wch32;
        wch16_low = f_pwchSource[ich++];

        /* Check if it is an unpaired high surrogate */
        ChkBOOL( IS_UTF16_LOW_SURROGATE_WCH( wch16_low ),
                 DRM_E_UTF_INVALID_CODE );

        wch32 = UTF32_FROM_SURROGATES_WCH( wch16_high, wch16_low );
    }
    else
    {
        /* Verify this isn't a low surrogate out on its own. This would
        ** represent and illegal code point */
        ChkBOOL( !IS_UTF16_LOW_SURROGATE_WCH( wch32 ), DRM_E_UTF_INVALID_CODE );
    }

    /* Success, update the output arguments */
    f_pdstrwSource->m_ichMin = ich;
    *f_pcp = UTF_CP_FROM_UTF32(wch32);

ErrorExit:

    return dr;
}


/*******************************************************************************
** Function: _WriteCodePoint16
**
** Synopsis: Converts a single code point into one or more UTF-16 code units.
**
** Arguments:
**
** [f_cp]            -- Code point to convert.
** [f_pwchTarget]    -- Pointer UTF-16 data buffer that used for result.
** [f_pdstrwTarget]  -- Window covering a range of UTF-16 units.
**                      On success, left edge of window is advanced to the next
**                      code point. On error, it is unchanged.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid (such as a
**                   window with zero or negative width).
**                   DRM_E_BUFFERTOOSMALL if f_pwchTarget size is insufficient for conversion
**                   DRM_E_UTF_INVALID_CODE - if code point is illegal
**
*******************************************************************************/
DRM_RESULT _WriteCodePoint16(
    IN     const DRM_CODE_POINT     f_cp,
       OUT       DRM_WCHAR         *f_pwchTarget,
    IN OUT       DRM_STRING_WINDOW *f_pdstrwTarget )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pdstrwTarget != NULL );
    ChkArg( f_pwchTarget != NULL );
    ChkBOOL( f_pdstrwTarget->m_ichMin < f_pdstrwTarget->m_ichMaxExclusive, DRM_E_BUFFERTOOSMALL );

    /* Target is a character <= 0xFFFF */
    if( f_cp <= UTF_PLANE0_MAX )
    {
        /* Verify this isn't an UTF-16 surrogate value. These are illegal code
        ** points */
        ChkBOOL( !IS_UTF16_SURROGATE_CP(f_cp), DRM_E_UTF_INVALID_CODE );

        /* normal case - process the symbol */
        f_pwchTarget[f_pdstrwTarget->m_ichMin++] = (DRM_WCHAR)UTF32_FROM_CP(f_cp);
    }
    else
    {
        /* check for legality of the code point */
        ChkBOOL( f_cp <= UTF_MAX_CODE_POINT, DRM_E_UTF_INVALID_CODE );

        /* As the target is in plane1 or later, it will take two UTF-16 code
        ** units, not one. Verify there is sufficient buffer size */
        ChkBOOL( f_pdstrwTarget->m_ichMin + 1 < f_pdstrwTarget->m_ichMaxExclusive, DRM_E_BUFFERTOOSMALL );

        /* Store the two values. High first, low second (the order is always
        ** the same, independent of endian */
        f_pwchTarget[f_pdstrwTarget->m_ichMin++] =
            (DRM_WCHAR)UTF16_HIGH_SURROGATE_FROM_CP(f_cp);

        f_pwchTarget[f_pdstrwTarget->m_ichMin++] =
            (DRM_WCHAR)UTF16_LOW_SURROGATE_FROM_CP(f_cp);
    }
ErrorExit:
    return dr;
}


/*******************************************************************************
** Function: _ReadCodePoint8
**
** Synopsis: Reads a single code point from a buffer of UTF-8 code units.
**
** Arguments:
**
** [f_pchSource]     -- Pointer to UTF-8 data buffer.
** [f_pdstrwSource]  -- Window covering a range of UTF-8 units.
**                      On success, left edge of window is advanced to the next
**                      code point. On error, it is unchanged.
** [f_pcp]           -- Pointer that will receive the next code point. On
**                      error this is unchanged.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid (such as a
**                   window with zero or negative width).
**                   DRM_E_UTF_INVALID_CODE - if UTF-8 sequence is illegal.
**                   DRM_E_UTF_UNEXPECTED_END - if parsing ended on a partial
**                       character.
**
*******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL _ReadCodePoint8(
    IN     const DRM_CHAR          *f_pchSource,
    IN OUT       DRM_STRING_WINDOW *f_pdstrwSource,
       OUT       DRM_CODE_POINT    *f_pcp )
{
    DRM_RESULT      dr              = DRM_SUCCESS;
    DRM_CODE_POINT  cp              = 0;
    DRM_BYTE        cLeadChar       = 0;
    DRM_DWORD       cchCodeUnits    = 0;
    DRM_DWORD       ich             = 0;
    DRM_DWORD       ichCurrentUnit  = 0;
    DRM_DWORD       ichMaxUnit      = 0;
    DRM_BYTE        rgbUnits[4]     = { 0 };

    ChkArg( f_pchSource != NULL );
    ChkArg( f_pdstrwSource != NULL );
    ChkArg( f_pcp != NULL );
    ChkArg( f_pdstrwSource->m_ichMin < f_pdstrwSource->m_ichMaxExclusive );

    ich = f_pdstrwSource->m_ichMin;

    cLeadChar = (DRM_BYTE) GET_CHAR( f_pchSource, ich ); /* grab one byte */

    /*
    ** The number of bits set at the top of the first code unit (aka first
    ** character if readers prefer) encodes the number of units that follow
    ** it. The below code does *some* range validation as well, but is not
    ** guaranteed to do all of it. Subsequent logic will do full validation!!
    */
    if( cLeadChar < 0x80UL )
    {
        /* It's an ASCII value, i.e. cchCodeUnits == 1. All validation is done
        ** at this point, so finish up. */
        *f_pcp = cLeadChar;
        f_pdstrwSource->m_ichMin = ich + 1;

        /* EXIT here (common case) */
        goto ErrorExit;
    }
    else if( cLeadChar >= 0xC2UL && cLeadChar < 0xE0UL )
    {
        cchCodeUnits = 2;
    }
    else if( cLeadChar >= 0xE0UL && cLeadChar < 0xF0UL )
    {
        cchCodeUnits = 3;
    }
    else if( cLeadChar >= 0xF0UL && cLeadChar < 0xF5UL )
    {
        cchCodeUnits = 4;
    }
    else
    {
        ChkDR( DRM_E_UTF_INVALID_CODE );
    }

    /*
    ** Ensure the buffer contains enough room for *all* characters. If
    ** cchCodeUnits is 2, the answer is one larger than the original ich.
    */
    ichMaxUnit = ich + cchCodeUnits - 1;
    ChkOverflow( ichMaxUnit, ich );

    ChkBOOL( ichMaxUnit < f_pdstrwSource->m_ichMaxExclusive, DRM_E_UTF_UNEXPECTED_END );

    /* Special case what's already been read. The for loop helps too by
    ** starting at 1 */
    ich++;
    rgbUnits[0] = cLeadChar;

    /* function min is used for rgbUnits array safety */
    for( ichCurrentUnit = 1; ichCurrentUnit < min(cchCodeUnits, 4); ichCurrentUnit++ )
    {
        /* Advance ich as well while in here */
        rgbUnits[ichCurrentUnit] = GET_CHAR( f_pchSource, ich++ );

        ChkBOOL( IS_UTF8_TRAILING_CH( rgbUnits[ichCurrentUnit] ),
                 DRM_E_UTF_INVALID_CODE );
    }

    switch ( cchCodeUnits )
    {
        case 2:
            cp = UTF_CP_FROM_TWO_CH( rgbUnits[0], rgbUnits[1] );
            ChkBOOL( cp >= UTF8_MIN_TWO_BYTE_CP && cp < UTF8_MIN_THREE_BYTE_CP,
                     DRM_E_UTF_INVALID_CODE );

            break;

        case 3:
            cp = UTF_CP_FROM_THREE_CH( rgbUnits[0], rgbUnits[1], rgbUnits[2] );
            ChkBOOL( ( cp >= UTF8_MIN_THREE_BYTE_CP &&
                       cp < UTF8_MIN_FOUR_BYTE_CP &&
                      !IS_UTF16_SURROGATE_CP(cp) ), DRM_E_UTF_INVALID_CODE );

            break;

        case 4:
            cp = UTF_CP_FROM_FOUR_CH( rgbUnits[0], rgbUnits[1], rgbUnits[2], rgbUnits[3] );
            ChkBOOL( cp >= UTF8_MIN_FOUR_BYTE_CP && cp <= UTF_MAX_CODE_POINT,
                     DRM_E_UTF_INVALID_CODE );

            break;

        default:
            DRMASSERT( FALSE ); /* we should never get here */

            ChkDR( DRM_E_FAIL );

            break;
    }

    *f_pcp = cp;
    f_pdstrwSource->m_ichMin = ich;

ErrorExit:

    return dr;
}


/*******************************************************************************
** Function: _WriteCodePoint8
**
** Synopsis: Converts a single code point into one or more UTF-8 code units.
**
** Arguments:
**
** [f_cp]            -- Code point to convert.
** [f_pchTarget]     -- Pointer UTF-8 data buffer that used for result.
** [f_pdstrwTarget]  -- Window covering a range of UTF-8 units.
**                      On success, left edge of window is advanced to the next
**                      code point. On error, it is unchanged.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid (such as a
**                   window with zero or negative width).
**                   DRM_E_BUFFERTOOSMALL if f_pchTarget size is insufficient for conversion
**                   DRM_E_UTF_INVALID_CODE - if code point is illegal
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL _WriteCodePoint8(
    IN     const DRM_CODE_POINT     f_cp,
       OUT       DRM_CHAR          *f_pchTarget,
    IN OUT       DRM_STRING_WINDOW *f_pdstrwTarget )
{
    DRM_RESULT      dr              = DRM_SUCCESS;
    DRM_CHAR        ch              = 0;
    DRM_CODE_POINT  cpBits          = 0;
    DRM_DWORD       cchCodeUnits    = 0;
    DRM_DWORD       ich             = 0;
    DRM_DWORD       ichMaxUnit      = 0;

    ChkArg( f_pdstrwTarget != NULL );
    ChkArg( f_pchTarget != NULL );

    ich = f_pdstrwTarget->m_ichMin;

    if( f_cp < UTF8_MIN_TWO_BYTE_CP )
    {
        /* It's an ASCII value, i.e. cchCodeUnits == 1. */
        ChkBOOL( ich < f_pdstrwTarget->m_ichMaxExclusive, DRM_E_BUFFERTOOSMALL );

        //
        // Xbox LIVE specific: disabling conversion warning (C4242) after review.
        //
        #pragma warning( disable:4242 )
        PUT_CHAR( f_pchTarget, ich, f_cp );
        #pragma warning( default:4242 )
        //
        // End Xbox LIVE specific
        //

        f_pdstrwTarget->m_ichMin = ich + 1;

        goto ErrorExit;
    }
    else if( f_cp < UTF8_MIN_THREE_BYTE_CP )
    {
        cchCodeUnits = 2;
    }
    else if( f_cp < UTF8_MIN_FOUR_BYTE_CP )
    {
        cchCodeUnits = 3;
        ChkBOOL( !IS_UTF16_SURROGATE_CP(f_cp), DRM_E_UTF_INVALID_CODE );
    }
    else
    {
        cchCodeUnits = 4;
        ChkBOOL( f_cp <= UTF_MAX_CODE_POINT, DRM_E_UTF_INVALID_CODE );
    }

    /*
    ** Ensure the buffer contains enough room for *all* characters. If
    ** cchCodeUnits is 1, the answer is identical to a standard single-char
    ** test.
    */
    ichMaxUnit = ich + cchCodeUnits - 1;
    ChkOverflow( ichMaxUnit, ich );

    ChkBOOL( ichMaxUnit < f_pdstrwTarget->m_ichMaxExclusive, DRM_E_BUFFERTOOSMALL );

    /*
    ** The simplest solution that works for 2, 3, and 4 is to write the values
    ** backwards. The last char/unit written, no matter the number, is always
    ** the bottom 6 bits. The 2nd-to-last written is the next 6 bits. This
    ** pattern continues up until the lead char/unit, which gets some extra
    ** bits at the top.
    */
    cpBits = f_cp;
    while ( ichMaxUnit > ich )
    {
        ch = UTF8_MAKE_TRAILING_CH( cpBits & 0x3F );
        PUT_CHAR( f_pchTarget, ichMaxUnit, ch );
        ichMaxUnit--;
        cpBits >>= 6;
    }

    DRMASSERT( ( cchCodeUnits == 4 ) && ( cpBits <= 0x7 ) ||
               ( cchCodeUnits == 3 ) && ( cpBits <= 0xF ) ||
               ( cchCodeUnits == 2 ) && ( cpBits <= 0x1F ) );

    ch = UTF8_MAKE_LEAD_CH( cchCodeUnits, cpBits );
    PUT_CHAR( f_pchTarget, ich, ch );

    f_pdstrwTarget->m_ichMin += cchCodeUnits;

    DRMASSERT( f_pdstrwTarget->m_ichMin <= f_pdstrwTarget->m_ichMaxExclusive );

ErrorExit:
    return dr;
}



/*******************************************************************************
** Function: DRM_UTF8_VerifyBytes
**
** Synopsis: Function that verifies validity of UTF-8 data
**           according to unicode.org specification.
**
** Arguments:
**
** [f_pbData]            -- Pointer to a data buffer that contains UTF-8.
**
** [f_cbData]            -- Size of f_pbData in bytes.
** [f_iMin]              -- Position in data buffer to begin reading (in
**                          code units, aka storage characters).
** [f_iMax]              -- Position in data buffer to stop reading (in
**                          code units, aka storage characters), inclusive.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Note: The first valid UTF-8 char should start right at f_iStart.
** If this assumption is too strong I can make a change.
*******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_UTF8_VerifyBytes(
    __in_bcount( f_cbData ) const DRM_BYTE  *f_pbData,
    IN const DRM_DWORD f_cbData,
    IN const DRM_DWORD f_iMin,
    IN const DRM_DWORD f_iMax )
{
    DRM_RESULT        dr    = DRM_SUCCESS;
    DRM_STRING_WINDOW dstrw = EMPTY_DRM_STRING_WINDOW;
    DRM_CODE_POINT    cp    = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_UTF8, PERF_FUNC_DRM_UTF8_VerifyBytes );

    ChkArg( f_pbData != NULL );
    ChkArg( f_cbData > 0 );

    ChkArg( f_iMax < f_cbData );
    ChkArg( f_iMax >= f_iMin );

    /* Simply read all the code points out to validate their correctness */
    dstrw.m_ichMin = f_iMin;
    dstrw.m_ichMaxExclusive = f_iMax + 1; /* f_iMax is included */

    while ( dstrw.m_ichMin < dstrw.m_ichMaxExclusive )
    {
        ChkDR( _ReadCodePoint8( ( const DRM_CHAR * ) f_pbData, &dstrw, &cp ) );
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*******************************************************************************
** Function: _GetUTF8UnitCount
**
** Synopsis: Calculates number of UTF-8 code units required to convert specified 
**           code point
**
** Arguments:
**
** [f_cp]        -- UTF-32 code point
** [f_pcchOut]   -- Pointer to code units counter. 
**                  If this value is NULL then DRM_E_INVALIDARG is returned.
**
** Returns:      DRM_SUCCESS
**               DRM_E_INVALIDARG if argument f_pcchOut is NULL.   
**               DRM_E_UTF_INVALID_CODE if code point is illegal
**
*******************************************************************************/
static DRM_RESULT _GetUTF8UnitCount(
    IN     const DRM_CODE_POINT  f_cp,
       OUT       DRM_DWORD      *f_pcchOut )
{
    DRM_RESULT dr = DRM_SUCCESS;
    ChkArg( f_pcchOut != NULL );

    if( f_cp < UTF8_MIN_TWO_BYTE_CP )
    {
        *f_pcchOut = 1;
    }
    else if( f_cp < UTF8_MIN_THREE_BYTE_CP )
    {
        *f_pcchOut = 2;
    }
    else if( f_cp < UTF8_MIN_FOUR_BYTE_CP )
    {
        *f_pcchOut = 3;
    }
    else if( f_cp <= UTF_MAX_CODE_POINT ) /* UTF_MAX_CODE_POINT is valid symbol */
    {
        *f_pcchOut = 4;
    }
    else
    {
        /* illegal UTF-32 code point */
        ChkDR( DRM_E_UTF_INVALID_CODE );
    }

ErrorExit:
    return dr;
}



/*******************************************************************************
** Function: _GetUTF16UnitCount
**
** Synopsis: Calculates number of 16-bit code units required to convert
**           specified code point
**
** Arguments:
**
** [f_cp]        --  Code point to convert
** [f_pcchOut]   --  Pointer to code units counter. 
**                   If this value is NULL then DRM_E_INVALIDARG is returned.
**
** Returns:          DRM_SUCCESS
**                   DRM_E_INVALIDARG if arguments f_pcchOut is NULL.    
**                   DRM_E_UTF_INVALID_CODE if code point cannot be converted
**
*******************************************************************************/
DRM_API DRM_DWORD DRM_CALL _GetUTF16UnitCount(
    IN     const DRM_CODE_POINT f_cp,
       OUT       DRM_DWORD     *f_pcchOut )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pcchOut != NULL );
    /* Target is a character <= 0xFFFF */
    if( f_cp <= UTF_PLANE0_MAX )
    {
        /* UTF-16 surrogate values are illegal in UTF-32 */
        ChkBOOL( !IS_UTF16_SURROGATE_CP(f_cp), DRM_E_UTF_INVALID_CODE );
        *f_pcchOut = 1;
    }
    else
    {
        /* check for legality of UTF-32 code */
        ChkBOOL( f_cp <= UTF_MAX_CODE_POINT, DRM_E_UTF_INVALID_CODE );
        *f_pcchOut = 2;
    }

ErrorExit:
    return dr;
}


/*******************************************************************************
** Function: _GetUTF16UnitCountForUTF32
**
** Synopsis: Calculates number of 16-bit code units required to convert
**           UTF-32 string. This function is agnostic as to NULL termination
**
** Arguments:
**
** [f_pw32szSource]  -- Pointer to UTF-32 data buffer.
** [f_cchSource]     -- Length of UTF-32 data buffer in UTF-32 code units
** [f_pcchTarget]    -- Pointer to code units counter. This value cannot be NULL.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_UTF_INVALID_CODE - if UTF32 sequence is illegal
**
*******************************************************************************/
DRM_RESULT _GetUTF16UnitCountForUTF32(
    IN     const DRM_WCHAR32 *f_pw32szSource,
    IN     const DRM_DWORD    f_cchSource,
       OUT       DRM_DWORD   *f_pcchTarget )
{
    DRM_RESULT     dr                    = DRM_SUCCESS;
    DRM_CODE_POINT cp                    = 0;
    DRM_WCHAR32   *pw32szCurSourceSymbol = (DRM_WCHAR32*) f_pw32szSource;
    DRM_WCHAR32   *pw32szSourceEnd       = NULL;
    DRM_DWORD      cchLocal              = 0;
    DRM_DWORD      cchOut                = 0;

    ChkArg( f_pw32szSource != NULL );
    ChkArg( f_pcchTarget != NULL );

    /* Initialize boundaries for source */
    pw32szSourceEnd = (DRM_WCHAR32*) (f_pw32szSource + f_cchSource);
    ChkOverflow( pw32szSourceEnd, f_pw32szSource );

    /* Do processing */
    while( pw32szCurSourceSymbol < pw32szSourceEnd )
    {
        cp = UTF_CP_FROM_UTF32( (*pw32szCurSourceSymbol) ); 
        pw32szCurSourceSymbol++; 
       
        ChkDR( _GetUTF16UnitCount( cp, &cchLocal ) );

        /* Check for cchOut overflow */
        ChkOverflow( cchOut + cchLocal, cchOut );
        cchOut += cchLocal;
    }
    /* Set the length of converted string */
    *f_pcchTarget = cchOut;

ErrorExit:
    return dr;
}

/*******************************************************************************
** Function: DRM_STR_UTF32toUTF16
**
** Synopsis: Converts UTF-32 string to UTF-16
**
** Arguments:
**
** [f_pw32szSource]  -- Pointer to UTF-32 data buffer.
** [f_cchSource]     -- Length of data buffer in UTF-32 code units
** [f_pwszTarget]    -- Pointer to UTF-16 data buffer. 
**                      After successful conversion this buffer will be NULL-terminated
**                      If value is NULL then method calculates number of code units
**                      that required for conversion. 
** [f_pcchTarget]    -- Pointer to DWORD containing UTF-16 buffer length in UTF-16 code
**                      units. After successful conversion it contains length 
**                      of UTF-16 string including NULL terminator. 
**                      In case of DRM_E_BUFFERTOOSMALL error it contains required length 
**                      of UTF-16 string including NULL terminator.  
**                      In case of error other than DRM_E_BUFFERTOOSMALL it remains unchanged.
**                      This value cannot be NULL.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if f_pwszTarget is null or it's size
**                   is insufficient for conversion
**                   DRM_E_UTF_INVALID_CODE - if UTF32 sequence is illegal
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF32toUTF16(
    __in_ecount( f_cchSource ) const DRM_WCHAR32 *f_pw32szSource,
    IN     const DRM_DWORD    f_cchSource,
    __out_ecount_z_opt( *f_pcchTarget ) DRM_WCHAR   *f_pwszTarget,
    IN OUT       DRM_DWORD   *f_pcchTarget )
{
    DRM_RESULT dr         = DRM_SUCCESS;
    DRM_STRING dstrTarget = EMPTY_DRM_STRING;

    ChkArg( f_pw32szSource != NULL );
    ChkArg( f_pcchTarget != NULL );

    /* Prepare parameters for DRM_STR_UTF32toDSTR */
    dstrTarget.pwszString = f_pwszTarget;
    if ( (*f_pcchTarget) > 0 )
    {
        dstrTarget.cchString = (*f_pcchTarget) - 1; /* reserve 1 symbol for NULL-terminator*/
    }

    /* Delegate processing */ 
    ChkDR( DRM_STR_UTF32toDSTR( f_pw32szSource, f_cchSource, &dstrTarget ) );
    
    if ( f_pwszTarget != NULL )
    {
        f_pwszTarget[ dstrTarget.cchString ] = 0; /* set NULL terminator */
    }
    *f_pcchTarget = dstrTarget.cchString + 1; /* Set length including NULL terminator */

ErrorExit:
    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        *f_pcchTarget = dstrTarget.cchString + 1; /* Set length including NULL terminator */
    }
    return dr;
}

/*******************************************************************************
** Function: DRM_STR_UTF32toDSTR
**
** Synopsis: Converts UTF-32 string to UTF-16 DRM string
**
** Arguments:
**
** [f_pw32szSource]  -- Pointer to UTF-32 data buffer.
** [f_cchSource]     -- Length of data buffer in UTF-32 code units
** [f_pdstrTarget]   -- Pointer to result DRM string. This value cannot be NULL.
**                      If f_pdstrTarget->pwszString is NULL then method calculates 
**                      number of code units that required for conversion.
**                      In case of error other than DRM_E_BUFFERTOOSMALL counter remains 
**                      unchanged.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if f_pdstrTarget->pwszString is NULL 
**                   or length of the string is insufficient for conversion
**                   DRM_E_UTF_INVALID_CODE - if UTF32 sequence is illegal
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF32toDSTR(
    __in_ecount( f_cchSource ) const DRM_WCHAR32 *f_pw32szSource,
    IN     const DRM_DWORD    f_cchSource,
    IN OUT       DRM_STRING  *f_pdstrTarget )
{
    DRM_RESULT         dr                    = DRM_SUCCESS;
    DRM_CODE_POINT     cp                    = 0;
    DRM_WCHAR32       *pw32szCurSourceSymbol = (DRM_WCHAR32*) f_pw32szSource;
    DRM_WCHAR32       *pw32szSourceEnd       = NULL;
    DRM_STRING_WINDOW  dstrwTarget           = EMPTY_DRM_STRING_WINDOW;

    /* Validate source data */
    ChkArg( f_pw32szSource != NULL );

    /* Initialize boundaries for source */
    pw32szSourceEnd = (DRM_WCHAR32*) (f_pw32szSource + f_cchSource);
    ChkOverflow( pw32szSourceEnd, f_pw32szSource );

    /* Validate target data */
    ChkArg( f_pdstrTarget != NULL );
    ChkBOOL( f_pdstrTarget->pwszString != NULL, DRM_E_BUFFERTOOSMALL );
    ChkBOOL( f_pdstrTarget->cchString > 0, DRM_E_BUFFERTOOSMALL );

    /* Initialize target substring */
    dstrwTarget.m_ichMin = 0;
    dstrwTarget.m_ichMaxExclusive = f_pdstrTarget->cchString;
 
    /* Do processing */
    while( pw32szCurSourceSymbol < pw32szSourceEnd )
    {
        cp = UTF_CP_FROM_UTF32( (*pw32szCurSourceSymbol) );
        pw32szCurSourceSymbol++; 
       
        ChkDR( _WriteCodePoint16( cp, f_pdstrTarget->pwszString, &dstrwTarget ) );
    }
    /* Set the length of converted string */
    f_pdstrTarget->cchString = dstrwTarget.m_ichMin;

ErrorExit:
    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        /* Calculate required length */
        dr = _GetUTF16UnitCountForUTF32( f_pw32szSource, f_cchSource, &(f_pdstrTarget->cchString) );
        if( DRM_SUCCEEDED( dr ) )
        {
            /* Need to return error */
            dr = DRM_E_BUFFERTOOSMALL;
        }
    }
    return dr;
}

/*******************************************************************************
** Function: _GetUTF32UnitCountForUTF16
**
** Synopsis: Calculates number of 32-bit code units required to convert
**           UTF-16 string. This function is agnostic as to NULL termination
**
** Arguments:
**
** [f_pdstrSource]   -- Pointer to UTF-16 drm string.
**                      f_pdstrSource->pwszString contains length of drm string 
**                      in UTF-16 code units
** [f_pcchTarget]    -- Pointer to code units counter. This value cannot be NULL.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_UTF_INVALID_CODE - if UTF-16 sequence is illegal
**
*******************************************************************************/
DRM_RESULT _GetUTF32UnitCountForUTF16 (
    IN     const DRM_STRING  *f_pdstrSource,
       OUT       DRM_DWORD   *f_pcchTarget )
{
    DRM_RESULT        dr           = DRM_SUCCESS;
    DRM_CODE_POINT    cp           = 0;
    DRM_STRING_WINDOW dstrwSource  = EMPTY_DRM_STRING_WINDOW;
    DRM_DWORD         cch          = 0;

    ChkArg( f_pdstrSource != NULL );
    ChkArg( f_pdstrSource->pwszString != NULL );
    ChkArg( f_pcchTarget != NULL );

    /* Initialize source substring */
    dstrwSource.m_ichMin = 0;
    dstrwSource.m_ichMaxExclusive = f_pdstrSource->cchString;

    /* Do processing */
    while( dstrwSource.m_ichMin < dstrwSource.m_ichMaxExclusive )
    {
        ChkDR( _ReadCodePoint16( f_pdstrSource->pwszString, &dstrwSource, &cp ) );
        
        cch++; /* One UTF-32 symbol per code point */
    }
    *f_pcchTarget = cch;  /* Set the result */

ErrorExit:
    return dr;
}

/*******************************************************************************
** Function: DRM_STR_UTF16toUTF32
**
** Synopsis: Converts UTF-16 string to UTF-32
**
** Arguments:
**
** [f_pwszSource]    -- Pointer to UTF-16 data buffer.
** [f_cchSource]     -- Length of data buffer in UTF-16 code units
** [f_pw32szTarget]  -- Pointer to result UTF-32 data buffer. 
**                      After successful conversion this buffer will be NULL-terminated
**                      If value is NULL then method calculates number of code units
**                      that required for conversion
** [f_pcchTarget]    -- Pointer to DWORD containing UTF-32 buffer length in UTF-32 code
**                      units. After successful conversion it contains length of UTF-32 
**                      string including NULL terminator. 
**                      In case of DRM_E_BUFFERTOOSMALL error it contains required length 
**                      of UTF-16 string including NULL terminator.  
**                      In case of error other than DRM_E_BUFFERTOOSMALL it remains unchanged.
**                      This value cannot be NULL.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if f_pw32szTarget is null or it's size
**                   is insufficient for conversion
**                   DRM_E_UTF_INVALID_CODE - if UTF32 sequence is illegal
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF16toUTF32 (
    __in_ecount( f_cchSource ) const DRM_WCHAR   *f_pwszSource,
    IN     const DRM_DWORD    f_cchSource,
    __out_ecount_z_opt( *f_pcchTarget ) DRM_WCHAR32 *f_pw32szTarget,
    IN OUT       DRM_DWORD   *f_pcchTarget )
{
    DRM_RESULT  dr         = DRM_SUCCESS;
    DRM_STRING  dstrSource = EMPTY_DRM_STRING;
    DRM_DWORD   cchTarget  = 0;

    ChkArg( f_pwszSource != NULL );
    ChkArg( f_pcchTarget != NULL );
 
    /* Prepare parameters for DRM_STR_DSTRtoUTF32 */
    dstrSource.cchString = f_cchSource;
    dstrSource.pwszString = (DRM_WCHAR*) f_pwszSource;
    if ( (*f_pcchTarget) > 0 )
    {
        cchTarget = (*f_pcchTarget) -1 ; /* reserve 1 symbol for NULL-terminator*/
    }

    /* Delegate processing */
    ChkDR( DRM_STR_DSTRtoUTF32( &dstrSource, f_pw32szTarget, &cchTarget ) );

    if ( f_pw32szTarget != NULL ) 
    {
        ChkBOOL( cchTarget < *f_pcchTarget, DRM_E_BUFFERTOOSMALL );
        
        f_pw32szTarget[ cchTarget ] = 0; /* set NULL terminator */
    }
    *f_pcchTarget = cchTarget + 1; /* Set length including NULL terminator */

ErrorExit:
    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        *f_pcchTarget = cchTarget + 1; /* Set length including NULL terminator */
    }
    return dr;
}

/*******************************************************************************
** Function: DRM_STR_DSTRtoUTF32
**
** Synopsis: Converts UTF-16 DRM string to UTF-32
**
** Arguments:
**
** [f_pdstrSource]   -- Pointer to UTF-16 DRM string.
**                      f_pdstrSource->cchString should contain length of DRM string
**                      in UTF-16 code units 
** [f_pw32szTarget]  -- Pointer to result UTF-32 data buffer. 
**                      If value is NULL then method calculates length that required 
**                      for conversion.
** [f_pcchTarget]    -- Pointer to DWORD containing UTF-32 buffer length in UTF-32 code
**                      units, After successful conversion it contains actual length 
**                      of UTF-32 string (not including any NULLs). 
**                      In case of DRM_E_BUFFERTOOSMALL error it contains required length 
**                      of UTF-16 string (not including any NULLs).  
**                      In case of error other than DRM_E_BUFFERTOOSMALL it remains unchanged.
**                      This value cannot be NULL.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if f_pw32szTarget is NULL or it's size
**                   is insufficient for conversion
**                   DRM_E_UTF_INVALID_CODE - if UTF-16 sequence is illegal
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_DSTRtoUTF32(
    IN     const DRM_STRING  *f_pdstrSource,
    __out_ecount_opt( *f_pcchTarget ) DRM_WCHAR32 *f_pw32szTarget,
    IN OUT       DRM_DWORD   *f_pcchTarget )
{
    DRM_RESULT        dr                    = DRM_SUCCESS;
    DRM_CODE_POINT    cp                    = 0;
    DRM_STRING_WINDOW dstrwSource           = EMPTY_DRM_STRING_WINDOW;
    DRM_WCHAR32      *pw32szCurTargetSymbol = f_pw32szTarget;
    DRM_WCHAR32      *pw32szTargetEnd       = NULL;

    /* Validate source data */
    ChkArg( f_pdstrSource != NULL );
    ChkArg( f_pdstrSource->pwszString != NULL );

    /* Initialize source substring */
    dstrwSource.m_ichMin = 0;
    dstrwSource.m_ichMaxExclusive = f_pdstrSource->cchString;

    /* Validate target data */
    ChkArg( f_pcchTarget != NULL );
    ChkBOOL( f_pw32szTarget != NULL, DRM_E_BUFFERTOOSMALL );
    ChkBOOL( (*f_pcchTarget) > 0, DRM_E_BUFFERTOOSMALL );

    /* Initialize boundaries for target */
    pw32szTargetEnd = f_pw32szTarget + (*f_pcchTarget);
    ChkOverflow( pw32szTargetEnd, f_pw32szTarget );

    /* Do processing */
    while( dstrwSource.m_ichMin < dstrwSource.m_ichMaxExclusive )
    {
        ChkDR( _ReadCodePoint16( f_pdstrSource->pwszString, &dstrwSource, &cp ) );

        ChkBOOL( pw32szCurTargetSymbol < pw32szTargetEnd, DRM_E_BUFFERTOOSMALL );
        *pw32szCurTargetSymbol++ = UTF32_FROM_CP( cp );
    }

    /* Set the length of converted string */
// Xbox LIVE specific: disabling conversion warning (C4242) after review.
//
    #pragma warning( disable:4242 )
    *f_pcchTarget = pw32szCurTargetSymbol - f_pw32szTarget;
    #pragma warning( default:4242 )
//
// End Xbox LIVE specific
//

ErrorExit:
    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        /* Calculate required length */
        dr = _GetUTF32UnitCountForUTF16( f_pdstrSource, f_pcchTarget );
        if( DRM_SUCCEEDED( dr ) )
        {
            /* Need to return error */
            dr = DRM_E_BUFFERTOOSMALL;
        }
    }
    return dr;
}

/*******************************************************************************
** Function: _GetUTF8UnitCountForUTF16
**
** Synopsis: Calculates number of 8-bit code units required to convert
**           UTF-16 string. This function is agnostic as to NULL termination.
**
** Arguments:
**
** [f_pdstrSource]   -- Pointer to UTF-16 DRM string.
** [f_pcchTarget]    -- Pointer to code units counter. This value cannot be NULL.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_UTF_INVALID_CODE - if UTF16 sequence is illegal
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL _GetUTF8UnitCountForUTF16(
        IN     const DRM_STRING  *f_pdstrSource,
        IN OUT       DRM_DWORD   *f_pcchTarget )
{
    DRM_RESULT        dr          = DRM_SUCCESS;
    DRM_STRING_WINDOW dstrwSource = EMPTY_DRM_STRING_WINDOW;
    DRM_CODE_POINT    cp          = 0;
    DRM_DWORD         cchLocal    = 0;
    DRM_DWORD         cchOut      = 0;

    ChkArg( f_pdstrSource != NULL );
    ChkArg( f_pdstrSource->pwszString != NULL ); 
    ChkArg( f_pcchTarget != NULL );

    /* Initialize source substring */
    dstrwSource.m_ichMin = 0;
    dstrwSource.m_ichMaxExclusive = f_pdstrSource->cchString;

    /* Do processing */
    while( dstrwSource.m_ichMin < dstrwSource.m_ichMaxExclusive )
    {
        ChkDR( _ReadCodePoint16( f_pdstrSource->pwszString, &dstrwSource, &cp ) );

        /* How many UTF-8 code units in current code point? */
        ChkDR( _GetUTF8UnitCount( cp, &cchLocal ) );

        /* Check for cchOut overflow */
        ChkOverflow( cchOut + cchLocal, cchOut );
        cchOut += cchLocal;
    }
    *f_pcchTarget = cchOut; /* Set the result */

ErrorExit:
    return dr;
}

/*******************************************************************************
** Function: DRM_STR_UTF16toUTF8
**
** Synopsis: Converts UTF-16 string to UTF-8
**
** Arguments:
**
** [f_pwszSource]    -- Pointer to UTF-16 data buffer.
** [f_cchSource]     -- Length of data buffer in UTF-16 code units
** [f_pchTarget]     -- Pointer to result UTF-8 data buffer. 
**                      After successful conversion this string will be NULL-terminated
**                      If value is NULL then method calculates number of code units
**                      that required for conversion
** [f_ichTarget]     -- Position (offset in 8-bit code points) of UTF-8 symbol to start writing
** [f_pcchTarget]    -- Pointer to DWORD containing UTF-8 buffer length in UTF-8 code
**                      units. After successful conversion it contains length 
**                      of UTF-8 string including NULL terminator. 
**                      In case of DRM_E_BUFFERTOOSMALL error it contains required length 
**                      of UTF-16 string including NULL terminator.  
**                      In case of error other than DRM_E_BUFFERTOOSMALL it remains unchanged.
**                      This value cannot be NULL.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if f_pchTarget is null or it's size
**                   is insufficient for conversion
**                   DRM_E_UTF_INVALID_CODE - if UTF-16 sequence is illegal
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF16toUTF8(
    __in_ecount( f_cchSource ) const DRM_WCHAR   *f_pwszSource,
    IN     const DRM_DWORD    f_cchSource,
    __out_ecount_z_opt( *f_pcchTarget ) DRM_CHAR *f_pchTarget,
    IN     const DRM_DWORD    f_ichTarget,
    IN OUT       DRM_DWORD   *f_pcchTarget )
{
    DRM_RESULT        dr          = DRM_SUCCESS;
    DRM_STRING        dstrSource  = EMPTY_DRM_STRING;
    DRM_STRING_WINDOW dstrwTarget = EMPTY_DRM_STRING_WINDOW;

    ChkArg( f_pwszSource != NULL );    
    ChkArg( f_pcchTarget != NULL );

    /* Prepare parameters for DRM_STR_DSTRtoUTF8 */
    dstrSource.cchString = f_cchSource;
    dstrSource.pwszString = (DRM_WCHAR*) f_pwszSource; /* NULL is handled by DRM_STR_DSTRtoUTF8 */
    dstrwTarget.m_ichMin = f_ichTarget;
    if ( (*f_pcchTarget) > 0 ) 
    {
        dstrwTarget.m_ichMaxExclusive = (*f_pcchTarget) - 1 ; /* Reserve 1 symbol for NULL terminator */
    }

    /* Delegate the processing */
    ChkDR( DRM_STR_DSTRtoUTF8_ByWindow( &dstrSource, f_pchTarget, &dstrwTarget ) );

    if ( f_pchTarget != NULL )
    {
        ChkBOOL( dstrwTarget.m_ichMaxExclusive < *f_pcchTarget, DRM_E_BUFFERTOOSMALL );
        
        PUT_BYTE( f_pchTarget, dstrwTarget.m_ichMaxExclusive, 0); /* Set NULL terminator */
    }
    *f_pcchTarget = dstrwTarget.m_ichMaxExclusive + 1; /* Set length including NULL terminator */

ErrorExit:
    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        *f_pcchTarget = dstrwTarget.m_ichMaxExclusive + 1 /* Set length including NULL terminator */;
    }
    return dr;
}

/*******************************************************************************
** Function: DRM_STR_DSTRtoUTF8_ByWindow
**
** Synopsis: Converts UTF-16 DRM substring to UTF-8 by using range window
**
** Arguments:
**
** [f_pdstrSource]   -- Pointer to UTF-16 DRM string.
** [f_pchTarget]     -- Pointer to UTF-8 buffer
** [f_pdstrwTarget]  -- Window covering a range of UTF-8 units.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if f_pchTarget is NULL or it's size
**                   is insufficient for conversion
**                   DRM_E_UTF_INVALID_CODE - if UTF-16 sequence is illegal
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_DSTRtoUTF8_ByWindow(
    IN     const DRM_STRING        *f_pdstrSource,
    __out_ecount_opt( f_pdstrwTarget->m_ichMaxExclusive ) DRM_CHAR *f_pchTarget,
    IN OUT       DRM_STRING_WINDOW *f_pdstrwTarget )
{
    DRM_RESULT        dr          = DRM_SUCCESS;
    DRM_CODE_POINT    cp          = 0;
    DRM_STRING_WINDOW dstrwSource = EMPTY_DRM_STRING_WINDOW;
    DRM_STRING_WINDOW dstrwTarget = EMPTY_DRM_STRING_WINDOW;

    /* Validate source data */
    ChkArg( f_pdstrSource != NULL );
    ChkArg( f_pdstrSource->pwszString != NULL );

    /* Initialize source substring */
    dstrwSource.m_ichMin = 0;
    dstrwSource.m_ichMaxExclusive = f_pdstrSource->cchString;

    /* Validate target data */
    ChkBOOL( f_pchTarget != NULL, DRM_E_BUFFERTOOSMALL );
    ChkBOOL( f_pdstrwTarget != NULL, DRM_E_BUFFERTOOSMALL );
    ChkBOOL( f_pdstrwTarget->m_ichMaxExclusive > 0, DRM_E_BUFFERTOOSMALL );
    ChkArg( f_pdstrwTarget->m_ichMin < f_pdstrwTarget->m_ichMaxExclusive );

    /* Initialize target substrings */
    dstrwTarget.m_ichMin = f_pdstrwTarget->m_ichMin;
    dstrwTarget.m_ichMaxExclusive = f_pdstrwTarget->m_ichMaxExclusive;
    
    /* Do processing */
    while( dstrwSource.m_ichMin < dstrwSource.m_ichMaxExclusive )
    {
        ChkDR( _ReadCodePoint16( f_pdstrSource->pwszString, &dstrwSource, &cp ) );

        ChkDR( _WriteCodePoint8( cp, f_pchTarget, &dstrwTarget ) );
    }

    /* Set the length of converted string */
    f_pdstrwTarget->m_ichMaxExclusive = dstrwTarget.m_ichMin;    

ErrorExit:
    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        /* Calculate required length */
        dr = _GetUTF8UnitCountForUTF16( f_pdstrSource, &(f_pdstrwTarget->m_ichMaxExclusive) );
        if( DRM_SUCCEEDED( dr ) )
        {
            /* Need to return error */
            dr = DRM_E_BUFFERTOOSMALL;
        }
    }
    return dr;
}

/*******************************************************************************
** Function: DRM_STR_DSTRtoUTF8
**
** Synopsis: Converts UTF-16 DRM string to UTF-8
**           This method is wrapper for method DRM_STR_DSTRtoUTF8_ByWindow.
**           It simplifies most useful case of output range window 
**           when min position is zero
**
** Arguments:
**
** [f_pdstrSource]      -- Pointer to UTF-16 DRM string.
** [f_pchTarget]        -- Pointer to UTF-8 buffer
** [f_pcchTarget]       -- Size of output UTF-8 buffer in 8-bit code units
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if f_pchTarget is null or 
**                   it's size (*f_pcchTarget)is insufficient for conversion
**                   DRM_E_UTF_INVALID_CODE - if UTF-16 sequence is illegal
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_DSTRtoUTF8(
    IN     const DRM_STRING *f_pdstrSource,
    __out_ecount_opt( *f_pcchTarget ) DRM_CHAR *f_pchTarget,
    IN OUT       DRM_DWORD  *f_pcchTarget )
{
    DRM_RESULT        dr          = DRM_SUCCESS;
    DRM_STRING_WINDOW dstrwTarget = EMPTY_DRM_STRING_WINDOW;    

    ChkArg( f_pcchTarget != NULL );

    dstrwTarget.m_ichMaxExclusive = *f_pcchTarget;

    /* Call the main method */
    ChkDR( DRM_STR_DSTRtoUTF8_ByWindow( f_pdstrSource, f_pchTarget, &dstrwTarget ) );

    /* Set the length of converted string */
    *f_pcchTarget = dstrwTarget.m_ichMaxExclusive;
    
ErrorExit:
    if ( dr == DRM_E_BUFFERTOOSMALL )
    {
        *f_pcchTarget = dstrwTarget.m_ichMaxExclusive;
    }
    return dr;
}

/*******************************************************************************
** Function: _GetUTF16UnitCountForUTF8
**
** Synopsis: Calculates number of 16-bit code units required to convert
**           UTF-8 string. This function is agnostic as to NULL termination.
**
** Arguments:
**
** [f_pchSource]     -- Pointer to UTF-8 data buffer.
** [f_dstrwSource]   -- Window covering a range of UTF-8 units.
**                      On success, left edge of window is advanced to the next 
**                      code point. On error, it is unchanged.
** [f_pcchTarget]    -- Pointer to code units counter. This value cannot be NULL.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_UTF_INVALID_CODE - if UTF16 sequence is illegal
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL _GetUTF16UnitCountForUTF8(
    IN     const DRM_CHAR          *f_pchSource,
    IN     const DRM_STRING_WINDOW *f_dstrwSource,
       OUT       DRM_DWORD         *f_pcchTarget )
{
    DRM_RESULT        dr          = DRM_SUCCESS;
    DRM_CODE_POINT    cp          = 0;
    DRM_STRING_WINDOW dstrwSource = EMPTY_DRM_STRING_WINDOW;
    DRM_DWORD         cchLocal    = 0;
    DRM_DWORD         cchOut      = 0;

    ChkArg( f_pchSource != NULL );
    ChkArg( f_dstrwSource != NULL );
    ChkArg( f_dstrwSource->m_ichMin < f_dstrwSource->m_ichMaxExclusive );
    ChkArg( f_pcchTarget != NULL );

    dstrwSource.m_ichMin = f_dstrwSource->m_ichMin;
    dstrwSource.m_ichMaxExclusive = f_dstrwSource->m_ichMaxExclusive;
    while( dstrwSource.m_ichMin < dstrwSource.m_ichMaxExclusive )
    {
        ChkDR( _ReadCodePoint8( f_pchSource, &dstrwSource, &cp ) );

        /* How many UTF-16 code units in current code point? */
        ChkDR( _GetUTF16UnitCount( cp, &cchLocal ) );
        cchOut += cchLocal;
    }
    *f_pcchTarget = cchOut; /* Set the result */

ErrorExit:
    return dr;
}

/*******************************************************************************
** Function: DRM_STR_UTF8toUTF16
**
** Synopsis: Converts UTF-8 string to UTF-16
**
** Arguments:
**
** [f_pchSource]     -- Pointer to UTF-8 data buffer.
** [f_ichSource]     -- Position (offset in 8-bit code points) of UTF-8 symbol to start reading
** [f_cchSource]     -- Length of 8 data buffer in 8-bit code points
** [f_pchTarget]     -- Pointer to UTF-16 data buffer. 
**                      After successful conversion this buffer will be NULL-terminated
**                      If value is NULL then method calculates number of code units
**                      that required for conversion
** [f_pcchTarget]    -- Pointer to DWORD containing UTF-16 buffer size in 16-bit code points
**                      After successful conversion it contains length of UTF-16 string 
**                      including NULL terminator.
**                      In case of DRM_E_BUFFERTOOSMALL error it contains required length 
**                      of UTF-16 string including NULL terminator.  
**                      In case of error other than DRM_E_BUFFERTOOSMALL it remains unchanged.
**                      This value cannot be NULL.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if f_pchTarget is null or it's size
**                   is insufficient for conversion
**                   DRM_E_UTF_INVALID_CODE - if UTF-16 sequence is illegal
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF8toUTF16(
    __in_ecount( f_ichSource+ f_cchSource ) const DRM_CHAR  *f_pchSource, 
    IN     const DRM_DWORD  f_ichSource,
    IN     const DRM_DWORD  f_cchSource, 
    __out_ecount_z_opt( *f_pcchTarget ) DRM_WCHAR *f_pchTarget, 
    IN OUT       DRM_DWORD *f_pcchTarget ) 
{
    DRM_RESULT        dr          = DRM_SUCCESS;
    DRM_STRING_WINDOW dstrwSource = EMPTY_DRM_STRING_WINDOW;
    DRM_STRING        dstrTarget  = EMPTY_DRM_STRING;

    ChkArg( f_pchSource != NULL );
    ChkArg( f_pcchTarget != NULL );

    /* Prepare parameters for DRM_STR_UTF8toDSTR */
    dstrwSource.m_ichMin = f_ichSource;
    dstrwSource.m_ichMaxExclusive = f_cchSource;
    dstrTarget.pwszString = f_pchTarget; /* NULL is handled by DRM_STR_UTF8toDSTR */
    if ( (*f_pcchTarget) > 0 )
    {
        dstrTarget.cchString = (*f_pcchTarget) - 1 ; /* Reserve 1 symbol for NULL terminator */
    }

    /* Delegate processing */
    ChkDR( DRM_STR_UTF8toDSTR_ByWindow( f_pchSource, &dstrwSource, &dstrTarget ) );

    if ( f_pchTarget != NULL )
    {
        f_pchTarget[dstrTarget.cchString] = 0; /* Set NULL terminator */
    }
    *f_pcchTarget = dstrTarget.cchString + 1;   /* Set length including NULL terminator */ 

ErrorExit:
    if( dr == DRM_E_BUFFERTOOSMALL )
    {        
        *f_pcchTarget = dstrTarget.cchString + 1; /* Set length including NULL terminator */
    }
    return dr;
}

/*******************************************************************************
** Function: DRM_STR_UTF8toDSTR_ByWindow
**
** Synopsis: Converts UTF-8 string to UTF-16 DRM string by using window range
**
** Arguments:
**
** [f_pchSource]     -- Pointer to UTF-8 data buffer.
** [f_pdstrwSource]  -- Window covering a range of UTF-8 units.
** [f_pdstrTarget]   -- Pointer to UTF-16 DRM string. If pointer to string itself is NULL
**                      then method return length (in 16-bit code units) that required 
**                      for conversion (not including any NULLs). 
**                      On error other than DRM_E_BUFFERTOOSMALL this length is unchanged.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if f_pdstrTarget is null or it's size
**                   is insufficient for conversion
**                   DRM_E_UTF_INVALID_CODE - if UTF-8 sequence is illegal
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF8toDSTR_ByWindow(
    __in_ecount( f_pdstrwSource->m_ichMaxExclusive ) const DRM_CHAR *f_pchSource,
    IN     const DRM_STRING_WINDOW *f_pdstrwSource,
    IN OUT       DRM_STRING        *f_pdstrTarget )
{
    DRM_RESULT        dr          = DRM_SUCCESS;
    DRM_CODE_POINT    cp          = 0;
    DRM_STRING_WINDOW dstrwSource = EMPTY_DRM_STRING_WINDOW;
    DRM_STRING_WINDOW dstrwTarget = EMPTY_DRM_STRING_WINDOW;

    /* Validate source data */
    ChkArg( f_pchSource != NULL );
    ChkArg( f_pdstrwSource != NULL );
    ChkArg( f_pdstrwSource->m_ichMin < f_pdstrwSource->m_ichMaxExclusive );

    /* Initialize source substring */
    dstrwSource.m_ichMin = f_pdstrwSource->m_ichMin;
    dstrwSource.m_ichMaxExclusive = f_pdstrwSource->m_ichMaxExclusive;

    /* Validate target data */
    ChkArg( f_pdstrTarget != NULL );
    ChkBOOL( f_pdstrTarget->pwszString != NULL, DRM_E_BUFFERTOOSMALL );
    ChkBOOL( f_pdstrTarget->cchString > 0, DRM_E_BUFFERTOOSMALL );

    /* Initialize target substring */
    dstrwTarget.m_ichMin = 0;
    dstrwTarget.m_ichMaxExclusive = f_pdstrTarget->cchString;

    /* Do processing */
    while( dstrwSource.m_ichMin < dstrwSource.m_ichMaxExclusive )
    {
        ChkDR( _ReadCodePoint8( f_pchSource, &dstrwSource, &cp ) );

        ChkDR( _WriteCodePoint16( cp, f_pdstrTarget->pwszString, &dstrwTarget ) );
    }

    /* Set the length of converted string */
    f_pdstrTarget->cchString = dstrwTarget.m_ichMin;

ErrorExit:
    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        /* Calculate required length */
        dr = _GetUTF16UnitCountForUTF8( f_pchSource, &dstrwSource, &(f_pdstrTarget->cchString) );
        if( DRM_SUCCEEDED( dr ) )
        {
            /* Need to return error */
            dr = DRM_E_BUFFERTOOSMALL;
        }
    }
    return dr;
}

/*******************************************************************************
** Function: DRM_STR_UTF8toDSTR
**
** Synopsis: Converts UTF-8 string to UTF-16 DRM string
**           This method is wrapper for method DRM_STR_UTF8toDSTR_ByWindow.
**           It simplifies most useful case of input range window 
**           when min position is zero
**
** Arguments:
**
** [f_pchSource]       -- Pointer to UTF-8 data buffer.
** [f_cchSource]       -- Size of UTF-8 data buffer in 8-bit code units
** [f_pdstrTarget]     -- Pointer to UTF-16 DRM string. If pointer to string itself is NULL
**                        then method return length (in 16-bit code units) that required 
**                        for conversion (not including any NULLs). 
**                        On error other than DRM_E_BUFFERTOOSMALL this length is unchanged.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if f_pdstrTarget is null or it's size
**                   is insufficient for conversion
**                   DRM_E_UTF_INVALID_CODE - if UTF-8 sequence is illegal
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF8toDSTR(
    __in_ecount( f_cchSource ) const DRM_CHAR *f_pchSource,
    IN     const DRM_DWORD   f_cchSource,
    IN OUT       DRM_STRING *f_pdstrTarget )
{
    DRM_RESULT        dr          = DRM_SUCCESS;
    DRM_STRING_WINDOW dstrwSource = EMPTY_DRM_STRING_WINDOW;

    ChkArg( f_pchSource != NULL &&
            f_cchSource > 0 &&
            f_pdstrTarget != NULL );

    dstrwSource.m_ichMaxExclusive = f_cchSource;

    /* Call the main method */
    ChkDR( DRM_STR_UTF8toDSTR_ByWindow( f_pchSource, &dstrwSource, f_pdstrTarget ) );

ErrorExit:

    return dr;
}

/*******************************************************************************
** Function: _ASCIItoUTF16
**
** Synopsis: Converts ASCII string to UTF-16 string
**
** Arguments:
**
** [f_pchSource]         -- Pointer to ASCII data buffer.
** [f_ichSource]         -- Start position of ASCII string
** [f_cchSource]         -- Number of characters, starting at f_pchSource + f_ichSource
** [f_pwchTarget]        -- Pointer to UTF-16 string. 
** [f_pcchTarget]        -- Pointer to UTF-16 string length. 
**                          Initially f_pcchTarget contains length of UTF-16 data buffer
**                          in characters. It should not be less than length of source string. 
**                          When function is successful then f_pcchTarget contains length of
**                          converted string. On error this length is unchanged.
** Note:             Conversion can be done in-place (i.e. f_pchSource and f_pwchTarget 
**                   point to the same address ) when size of target buffer allows
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if target's size is insufficient for conversion
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL _ASCIItoUTF16(
    __in_ecount( f_ichSource+f_cchSource ) const DRM_CHAR *f_pchSource,
    IN     const DRM_DWORD   f_ichSource,
    IN     const DRM_DWORD   f_cchSource, 
    __out_ecount( *f_pcchTarget ) DRM_WCHAR *f_pwchTarget,
    IN OUT       DRM_DWORD  *f_pcchTarget )
{
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_DWORD  ich = 0;

    ChkArg( f_pchSource != NULL );
    ChkArg( f_pwchTarget != NULL );
    ChkArg( f_pcchTarget != NULL );

    ChkBOOL( f_cchSource <= *f_pcchTarget, DRM_E_BUFFERTOOSMALL );

    ich = f_cchSource;
    while( ich > 0 )
    {
        ich--;  
        f_pwchTarget[ ich ] = WCHAR_CAST( GET_CHAR( f_pchSource, f_ichSource + ich ) );
    }
    *f_pcchTarget = f_cchSource;

ErrorExit:
    return dr;
}

/*******************************************************************************
** Function: _ASCIItoUTF16_NULL
**
** Synopsis: Converts ASCII string to UTF-16 string
**           This method is the same as _ASCIItoUTF16 except it adds NULL terminator
**
** Arguments:
**
** [f_pchSource]         -- Pointer to ASCII data buffer.
** [f_ichSource]         -- Start position of ASCII string
** [f_cchSource]         -- Number of characters, starting at f_pchSource + f_ichSource 
** [f_pwchTarget]        -- Pointer to UTF-16 string. 
** [f_pcchTarget]        -- Pointer to UTF-16 string length (including NULL terminator).
**                          Initially f_pcchTarget contains length of UTF-16 data buffer
**                          in characters. It should not be less than length of source string. 
**                          When function is successful then f_pcchTarget contains length of
**                          converted string. On error this length is unchanged.
** Note:             Conversion can be done in-place (i.e. f_pchSource and f_pwchTarget 
**                   point to the same address ) when size of target buffer allows
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if target's size is insufficient for conversion
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL _ASCIItoUTF16_NULL(
    __in_ecount( f_ichSource+f_cchSource ) const DRM_CHAR *f_pchSource,
    IN     const DRM_DWORD   f_ichSource,
    IN     const DRM_DWORD   f_cchSource, 
    __out_ecount( *f_pcchTarget ) DRM_WCHAR *f_pwchTarget,
    IN OUT       DRM_DWORD  *f_pcchTarget )
{
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_DWORD  cchTarget = 0;

    //
    // Xbox LIVE specific: disabling conversion warning (C4296) after review.
    //
    #pragma warning( disable:4296 )
    ChkArg( f_pchSource != NULL && f_ichSource >= 0 && f_cchSource > 0 );
    #pragma warning( default:4296 )
    //
    // End Xbox LIVE specific
    //

    ChkArg( f_pcchTarget != NULL && *f_pcchTarget != 0 );
    
    ChkBOOL( f_cchSource < *f_pcchTarget, DRM_E_BUFFERTOOSMALL );
    cchTarget = (*f_pcchTarget) - 1; /* Reserve space for NULL terminator */

    ChkDR( _ASCIItoUTF16( f_pchSource, f_ichSource, f_cchSource, f_pwchTarget, &cchTarget ) );

    /*  
    ** This ChkBOOL is required for PreFast only. It will not trigger because 
    ** there is buffer validation above and _ASCIItoUTF16 can only reduce cchTarget
    */ 
    ChkBOOL( cchTarget < *f_pcchTarget, DRM_E_FAIL );

    f_pwchTarget[ cchTarget ] = g_wchNull; /* set NULL terminator */
    *f_pcchTarget = cchTarget + 1; /* set length */
    
ErrorExit:
    return dr;
}

/*******************************************************************************
** Function: DRM_STR_ASCII_SUBSTRtoDSTR
**
** Synopsis: Converts ASCII string to UTF-16 DRM string
**
** Arguments:
**
** [f_pchSource]     -- Pointer to ASCII data buffer.
** [f_pdasstr]       -- Substring of ASCII data buffer representing string to process
** [f_pdstrTarget]   -- Pointer to UTF-16 DRM string. 
**                      Initally f_pdstrTarget->cchString contains size of 
**                      f_pdstrTarget->pwszString in characters and this value
**                      should not be less than length of source string. 
**                      When function is successful then cchString contains length of
**                      converted string. On error this length is unchanged.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if target's size is insufficient for conversion
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_ASCII_SUBSTRtoDSTR(
    __in_ecount( f_pdasstr->m_ich + f_pdasstr->m_cch ) const DRM_CHAR *f_pchSource,
    IN     const  DRM_SUBSTRING *f_pdasstr, 
    IN OUT        DRM_STRING    *f_pdstrTarget)
{
   DRM_RESULT dr = DRM_SUCCESS;

   ChkArg( f_pdasstr != NULL ); 
   ChkDRMString( f_pdstrTarget );

   ChkDR( _ASCIItoUTF16( f_pchSource, 
                         f_pdasstr->m_ich, 
                         f_pdasstr->m_cch, 
                         f_pdstrTarget->pwszString,
                        &f_pdstrTarget->cchString ) );

ErrorExit:
   return dr; 
}


/*******************************************************************************
** Function: DRM_STR_ASCIItoDSTR
**
** Synopsis: Converts ASCII string to UTF-16 DRM string
**           This method is wrapper for method _ASCIItoUTF16.
**           It simplifies most useful case of when start position 
**           of ASCII string is zero
**
** Arguments:
**
** [f_pchSource]     -- Pointer to ASCII data buffer.
** [f_cchSource]     -- Length of ASCII string. Start position is 0.
** [f_pdstrTarget]   -- Pointer to UTF-16 DRM string. Length of string (in cchString) 
**                      should not be less than length of source string. 
**                      When function is successful then cchString contains length of
**                      converted string. On error this length is unchanged.
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if target's size is insufficient for conversion
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_ASCIItoDSTR(
    __in_ecount( f_cchSource ) const DRM_CHAR *f_pchSource,
    IN const DRM_DWORD   f_cchSource, 
    IN OUT   DRM_STRING *f_pdstrTarget )
{
   return _ASCIItoUTF16( f_pchSource, 
                         0, 
                         f_cchSource, 
                         f_pdstrTarget->pwszString,
                        &f_pdstrTarget->cchString );
}

/*******************************************************************************
** Function: DRM_STR_UTF16toASCII
**
** Synopsis: Converts UTF-16 DRM string to ASCII string 
**           This method assumes that all UTF-16 characters are in ASCII range 
**           This method forces NULL termination for target ASCII string
**
** Arguments:
**
** [f_pwszSource]    -- Pointer to UTF-16 string.
** [f_cchSource]     -- Length of UTF-16 string in characters 
** [f_pszTarget]     -- Pointer to ASCII string. 
** [f_cchSource]     -- Size of ASCII string buffer in characters 
**                      This length should be greater than length of source string. 
** Note:             Conversion can be done in-place, i.e. when 
**                   f_pwszSource and f_pszTarget point to the same address
**
** Returns:          DRM_SUCCESS on success.
**                   DRM_E_INVALIDARG if the arguments are invalid.
**                   DRM_E_BUFFERTOOSMALL if target's size is insufficient for conversion
**
*******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF16toASCII( 
    __in_ecount(f_cchSource) const DRM_WCHAR *f_pwszSource,
    IN  const DRM_DWORD                       f_cchSource,
    __inout_ecount(f_cchTarget)    DRM_CHAR  *f_pszTarget,
    IN  const DRM_DWORD                       f_cchTarget )
{
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_DWORD  ich = 0;

    ChkArg( f_pwszSource != NULL );
    ChkArg( f_pszTarget != NULL );

    /* Reserve 1 space for NULL terminator */
    ChkBOOL( f_cchSource < f_cchTarget, DRM_E_BUFFERTOOSMALL );

    while( ich < f_cchSource ) 
    {
        PUT_BYTE( f_pszTarget, ich, (DRM_CHAR)NATIVE_WCHAR( f_pwszSource[ ich ] ) );
        ich++;
    }
    PUT_BYTE( f_pszTarget, ich, 0 ); /* Put NULL terminator */
 
ErrorExit:
    return dr;    
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmutilitiescertcache.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmxmlparser.h>
#include <drmrc4.h>
#include <byteorder.h>
#include <oem.h>

#if DRM_SUPPORT_CERTIFICATE_CACHING
#include <drmblackbox.h>
#endif

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_CERTIFICATE_CACHING

static const DRM_ID g_idCachedCert = { TWO_BYTES( 'C', 0 ), TWO_BYTES( 'E', 0 ), TWO_BYTES( 'R', 0 ), TWO_BYTES( 'T', 0 ),
                                       TWO_BYTES( 'C', 0 ), TWO_BYTES( 'A', 0 ), TWO_BYTES( 'C', 0 ), TWO_BYTES( 'H', 0 ) };

DRM_API DRM_BOOL DRM_CALL DRM_UTL_VerifyCachedCertificate (
    IN       DRM_BB_CONTEXT       *f_pcontextBBX,
    IN       DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN       DRM_DST              *f_pDatastore,
    IN const DRM_BYTE             *f_pbData,
    IN       DRM_DWORD             f_cbData )
{
    DRM_RESULT  dr        = DRM_SUCCESS;
    DRM_BOOL    fVerified = FALSE;
    DRM_MD5_CTX contextMD5;
    DRM_BYTE    rgbHash[__CB_DECL(DRM_SHA1_DIGEST_LEN)];
    DRM_BYTE    rgbSigDigest[__CB_DECL(MD5DIGESTLEN)];
    DRM_DWORD   cbSigDigest = SIZEOF( rgbSigDigest );

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMUTILITIES, PERF_FUNC__VerifyCachedCertificate);

    ChkArg( f_pcontextBBX           != NULL
         && f_pcontextSST           != NULL
         && f_pDatastore           != NULL
         && f_pbData                != NULL
         && f_cbData                 > 0 );

    ChkDR( DRM_BBX_HashValue( f_pbData, f_cbData, rgbHash, f_pcontextBBX ) );
    DRM_MD5_Init  ( &contextMD5 );
    DRM_MD5_Update( &contextMD5, f_pbData, f_cbData );
    DRM_MD5_Final ( &contextMD5 );

    DRMCASSERT( SIZEOF( contextMD5.digest ) == SIZEOF( DRM_ID ) );

    dr = DRM_SST_GetData( f_pcontextSST,
                 (DRM_ID*)contextMD5.digest,
                         &g_idCachedCert,
                          rgbHash,
                          SECURE_STORE_CACHED_CERTIFICATE_DATA,
                          f_pDatastore,
                          rgbSigDigest,
                         &cbSigDigest );
    if( DRM_SUCCEEDED( dr ) )
    {
        if( cbSigDigest == SIZEOF( rgbSigDigest )
         && 0 == MEMCMP( rgbSigDigest, contextMD5.digest, cbSigDigest ) )
        {
            fVerified = TRUE;
        }
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return fVerified;
}

DRM_API DRM_RESULT DRM_CALL  DRM_UTL_AddCachedCertificate (
    IN       DRM_BB_CONTEXT       *f_pcontextBBX,
    IN       DRM_SECSTORE_CONTEXT *f_pcontextSSTRevocation,
    IN       DRM_DST              *f_pDatastore,
    IN const DRM_BYTE             *f_pbData,
    IN       DRM_DWORD             f_cbData )
{
    DRM_RESULT  dr        = DRM_SUCCESS;
    DRM_MD5_CTX contextMD5;
    DRM_BYTE    rgbHash[__CB_DECL(DRM_SHA1_DIGEST_LEN)];

    ChkArg( f_pcontextBBX           != NULL
         && f_pDatastore           != NULL
         && f_pcontextSSTRevocation != NULL
         && f_pbData                != NULL
         && f_cbData                 > 0 );

    ChkDR( DRM_BBX_HashValue( f_pbData, f_cbData, rgbHash, f_pcontextBBX ) );
    DRM_MD5_Init  ( &contextMD5 );
    DRM_MD5_Update( &contextMD5, f_pbData, f_cbData );
    DRM_MD5_Final ( &contextMD5 );

    DRMCASSERT( SIZEOF( contextMD5.digest ) == SIZEOF( DRM_ID ) );

    dr = DRM_SST_SetData( f_pcontextSSTRevocation,
                 (DRM_ID*)contextMD5.digest,
                         &g_idCachedCert,
                          rgbHash,
                          SECURE_STORE_CACHED_CERTIFICATE_DATA,
                          f_pDatastore,
                          contextMD5.digest,
                   SIZEOF(contextMD5.digest) );
ErrorExit:
    return dr;
}

#endif

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmutilities.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmxmlparser.h>
#include <drmrc4.h>
#include <byteorder.h>
#include <oem.h>

#if DRM_SUPPORT_CERTIFICATE_CACHING
#include <drmblackbox.h>
#endif

ENTER_PK_NAMESPACE_CODE;

/*****************************************************************************
** Function: DRM_UTL_IsCertDateOK
**
** Synopsis: test whether a given date is before todays date.
**
** Arguments:
**   [f_pbDate]     -- date as a byte array
**   f_pbData [0] -- century, e.g. 20
**   f_pbData [1] -- year mod 100 e.g. 4
**   f_pbData [2] -- month, 1-based
**   f_pbData [3] -- day-of-month, 1-based
**
** Example: March 21, 2004 = |20|4|3|21|
**                            0  1 2 3
** Returns TRUE if the date is reasonable
*****************************************************************************/

DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL DRM_UTL_IsCertDateOK(
    __in_opt    DRM_VOID        *pOEMContext,
    __in_bcount( 4 ) const DRM_BYTE  *f_pbDate)
{
    DRMSYSTEMTIME systimeCurrent;
    DRM_BOOL      fOK = FALSE;
    DRM_BYTE      rgbDate[4]; /* Don't use __CB_DECL here */

    Oem_Clock_GetSystemTime(pOEMContext, &systimeCurrent);

    rgbDate[0] = GET_BYTE( f_pbDate, 0 );
    rgbDate[1] = GET_BYTE( f_pbDate, 1 );
    rgbDate[2] = GET_BYTE( f_pbDate, 2 );
    rgbDate[3] = GET_BYTE( f_pbDate, 3 );

    if ((rgbDate [0] * 100 + rgbDate [1]) > systimeCurrent.wYear)
    {
        fOK = TRUE;
    }
    else if ((rgbDate [0] * 100 + rgbDate [1]) < systimeCurrent.wYear)
    {
        fOK = FALSE;
    }
    else if (rgbDate [2] > systimeCurrent.wMonth)
    {
        fOK = TRUE;
    }
    else if (rgbDate [2] < systimeCurrent.wMonth)
    {
        fOK = FALSE;
    }
    else
    {
        fOK = (rgbDate [3] >= systimeCurrent.wDay);
    }

    return fOK;
}

/******************************************************************************
**
** Function :   _UTL_VerifySignature
**
** Synopsis :   Verify the xml signature over some data
**
** Arguments :  f_pdstrSignedData   -   The entire data that is signed
**              f_pdstrSignatureValue -   Sig value
**              f_pdstrCertChainXML -   <CERTIFICATECHAIN>...</CERTIFICATECHAIN>
**              f_fCheckExpiry      -   Check for cert expiration
**              f_fCheckCertChain   -   Verify cert chain. If this is false,
**                                      f_pcontextCrypto->pubKey must contain
**                                      the public key which will be used to
**                                      verify the signature.
**              f_eRootPubkey       -   Root Pubkey to use for cert verification
**              f_pcontextLEVL      -   License eval context.  The DST, pcontextSSTRevocation,
**                                      and BBX pointers must be valid
**
** Returns :    DRM_SUCCESS -   Signature verified successfully
**              DRM_E_INVALID_SIGNATURE -   Verification failed
**              some other problem
**
** Notes :
**
******************************************************************************/
static DRM_RESULT _UTL_VerifySignature(
    IN  const   DRM_CONST_STRING        *f_pdstrSignedData,
    IN  const   DRM_CONST_STRING        *f_pdstrSignatureValue,
    IN  const   DRM_CONST_STRING        *f_pdstrCertChainXML,
    IN          DRM_BOOL                 f_fCheckExpiry,
    IN          DRM_BOOL                 f_fCheckCertChain,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey,
    IN          DRM_LICEVAL_CONTEXT     *f_pcontextLEVL)
{
    DRM_BOOL         fFirstCertCheck =   TRUE;
    DRM_CONST_STRING dstrCert        =   EMPTY_DRM_STRING;
    DRM_DWORD        cbSignature     =   0;
    DRM_DWORD        iCert           =   0;
    DRM_RESULT       dr              =   DRM_SUCCESS;

    /*
    **  No need to verify input in internal function
    */

#if DRM_SUPPORT_CERTIFICATE_CACHING
    if( DRM_UTL_VerifyCachedCertificate( f_pcontextLEVL->pcontextBBX,
                                  f_pcontextLEVL->pcontextSSTRevocation,
                                  f_pcontextLEVL->pDatastore,
                                  PB_DSTR( f_pdstrSignedData ),
                                  CB_DSTR( f_pdstrSignedData ) ) )
    {
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }
#endif

    if (f_fCheckCertChain)
    {
        /*
        **  Verify cert chain
        */
        while( TRUE ) /*    Loop will break when DRM_E_XMLNOTFOUND is hit */
        {
            DRM_DWORD cbCert = SIZEOF(CERT);

            dr  =   DRM_XML_GetSubNode( f_pdstrCertChainXML,
                                       &g_dstrTagCertificate,
                                        NULL,
                                        NULL,
                                        iCert,
                                        NULL,
                                       &dstrCert,
                                        1);
            iCert++;

            if (dr == DRM_E_XMLNOTFOUND)
            {
                break;
            }
            ChkDR(dr);

            ChkDR(DRM_B64_DecodeW( &dstrCert,
                                   &cbCert,
                       (DRM_BYTE*) &f_pcontextLEVL->pcontextBBX->CryptoContext.union_cert.cert,
                                    0) );

            ChkDR(  DRM_UTL_CheckCertificate( &f_pcontextLEVL->pcontextBBX->CryptoContext.union_cert.cert,
                                               fFirstCertCheck ? NULL : &f_pcontextLEVL->pcontextBBX->CryptoContext.pubKey,
                                               f_fCheckExpiry,
                                               f_pcontextLEVL,
                                               f_eRootPubkey) );

            MEMCPY( &(f_pcontextLEVL->pcontextBBX->CryptoContext.pubKey),
                    &(f_pcontextLEVL->pcontextBBX->CryptoContext.union_cert.cert.cd.pk),
                      SIZEOF(PUBKEY) );

            fFirstCertCheck = FALSE;
        }

        if( iCert == 1 )
        {
            dr = DRM_E_INVALID_SIGNATURE;   /*  No certificates */
            goto ErrorExit;
        }
        /*
        **  f_pcontextCrypto->pubKey now contains the pubkey needed for verification
        */
    }

    cbSignature = SIZEOF(f_pcontextLEVL->pcontextBBX->CryptoContext.signature);
    ChkDR(DRM_B64_DecodeW( f_pdstrSignatureValue,
                          &cbSignature,
                           f_pcontextLEVL->pcontextBBX->CryptoContext.signature,
                           0) );

    ChkDR( DRM_PK_Verify( f_pcontextLEVL->pcontextBBX->CryptoContext.rgbCryptoContext,
                          eDRM_ECC_P160,
                          DRM_ECC160_PUBLIC_KEY_LEN,
                          ( const DRM_BYTE * )&f_pcontextLEVL->pcontextBBX->CryptoContext.pubKey,
                          CB_DSTR(f_pdstrSignedData),
                          PB_DSTR(f_pdstrSignedData),
                          DRM_ECC160_SIGNATURE_LEN,
                          f_pcontextLEVL->pcontextBBX->CryptoContext.signature) );

#if DRM_SUPPORT_CERTIFICATE_CACHING

    (void)DRM_UTL_AddCachedCertificate( f_pcontextLEVL->pcontextBBX,
                                 f_pcontextLEVL->pcontextSSTRevocation,
                                 f_pcontextLEVL->pDatastore,
                                 PB_DSTR( f_pdstrSignedData ),
                                 CB_DSTR( f_pdstrSignedData ) );

#endif


ErrorExit:
    return dr;
}

static DRM_NO_INLINE DRM_RESULT _CheckCertificate(
    const CERT                 *f_pcert,
    const PUBKEY               *f_ppubkey,
          DRM_BOOL              f_fCheckDate,
          DRM_BB_CONTEXT       *f_pcontextBBX,
          DRM_SECSTORE_CONTEXT *f_pcontextSSTRevocation,
          DRM_DST              *f_pDatastore,
          DRM_VOID             *f_pOEMContext )
{
    DRM_DWORD  cbData = 0;
    DRM_RESULT dr     = DRM_SUCCESS;

#if DRM_SUPPORT_CERTIFICATE_CACHING
    DRM_BOOL   fUseCache = ( f_pcontextSSTRevocation != NULL && f_pDatastore != NULL );
#endif

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMUTILITIES, PERF_FUNC__CheckCertificate);

    ChkArg(f_pcert       != NULL
        && f_ppubkey     != NULL
        && f_pcontextBBX != NULL );

    BYTES_TO_DWORD(cbData, f_pcert->datalen);

    if (MEMCMP(f_pcert->certVersion, (DRM_BYTE *)CERT_VER, VERSION_LEN) != 0)
    {
        ChkDR(DRMUTIL_UNSUPPORTED_VERSION);
    }

    if (f_fCheckDate && !DRM_UTL_IsCertDateOK( f_pOEMContext, f_pcert->cd.expiryDate))
    {
        ChkDR(DRMUTIL_EXPIRED_CERT);
    }

#if DRM_SUPPORT_CERTIFICATE_CACHING
    /*
    ** First check to see if the certificate signature is cached.
    ** If it is then we don't need to call DRM_PK_Verify
    */
    if( fUseCache == FALSE
     || !DRM_UTL_VerifyCachedCertificate( f_pcontextBBX, f_pcontextSSTRevocation, f_pDatastore, (const DRM_BYTE*) f_pcert, sizeof( *f_pcert ) ) )
#endif
    {
        if ( DRM_FAILED( DRM_PK_Verify( f_pcontextBBX->CryptoContext.rgbCryptoContext,
                                        eDRM_ECC_P160,
                                        DRM_ECC160_PUBLIC_KEY_LEN,
                                        ( const DRM_BYTE * )f_ppubkey,
                                        cbData,
                                        ( const DRM_BYTE * )&f_pcert->cd,
                                        DRM_ECC160_SIGNATURE_LEN,
                                        f_pcert->sign ) ) )
        {
            ChkDR(DRMUTIL_INVALID_CERT);
        }
#if DRM_SUPPORT_CERTIFICATE_CACHING
        (void)DRM_UTL_AddCachedCertificate( f_pcontextBBX, f_pcontextSSTRevocation, f_pDatastore, (const DRM_BYTE*) f_pcert, sizeof( *f_pcert ) );
#endif
    }

ErrorExit:

/*
    DRM_PROFILING_USER_DATA_1(DRM_PROFILING_BINARY_HASH((DRM_BYTE*)f_pcert,SIZEOF(CERT)), 1);
    DRM_PROFILING_USER_DATA_2(DRM_PROFILING_BINARY_HASH((DRM_BYTE*)f_ppubkey,SIZEOF(PUBKEY)), 1);
*/
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/******************************************************************************
**
** Function :   DRM_UTL_CheckCertificate
**
** Synopsis :   Verifies the signature on a certificate using either the
**              supplied public key, or the default for the supplied
**              DRM_ROOTPUBKEY_CATEGORY
**
** Arguments :  f_pcert     -   Cert to be checked
**              f_ppubkey   -   Pubkey to be used for verification - If it is
**                              NULL, use appropriate hard-coded key
**              f_fCheckCertDate    -   Check for expiration
**              f_pcontextCrypto   -   Crypto context
**              f_eRootPubkey   -   The root pubkey to use if f_ppubkey is NULL.
**                                  if it is WM_DRM_ROOTPUBKEY_CLK
**                                  f_pcontextCrypto->pubKey will hold the root
**                                  public key to use to verify the cert chain.
**
** Returns :    DRM_RESULT
**
** Notes :
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_UTL_CheckCertificate(
    IN  const   CERT                    *f_pcert,
    IN  const   PUBKEY                  *f_ppubkey,
    IN          DRM_BOOL                 f_fCheckCertDate,
    IN          DRM_LICEVAL_CONTEXT     *f_pcontextLEVL,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey)
{
    DRM_RESULT         dr         =   DRM_SUCCESS;
    const PUBKEY      *ppubkey    =   NULL;

    static PUBKEY const pubkeyMSCERT = { {
            TWO_BYTES(0x4D, 0xBF), TWO_BYTES(0xD9, 0x0D), TWO_BYTES(0xD9, 0x6E), TWO_BYTES(0x8C, 0x9E),
            TWO_BYTES(0x32, 0x5F), TWO_BYTES(0x4F, 0x3D), TWO_BYTES(0xEC, 0xA9), TWO_BYTES(0x84, 0x59),
            TWO_BYTES(0x6B, 0x5E), TWO_BYTES(0x06, 0x86), TWO_BYTES(0xE7, 0xE2), TWO_BYTES(0xC2, 0x8B),
            TWO_BYTES(0xDE, 0x14), TWO_BYTES(0x4B, 0x29), TWO_BYTES(0x2C, 0xEC), TWO_BYTES(0x4D, 0x1D),
            TWO_BYTES(0x76, 0xFD), TWO_BYTES(0x5A, 0x14), TWO_BYTES(0x90, 0x3A), TWO_BYTES(0x10, 0x77)
    } };

    static PUBKEY const pubkeyMSSecureClock = { {
            TWO_BYTES(0xF8, 0x23), TWO_BYTES(0x61, 0xBE), TWO_BYTES(0xFC, 0xF5), TWO_BYTES(0x59, 0xA3),
            TWO_BYTES(0x55, 0xD4), TWO_BYTES(0x01, 0x54), TWO_BYTES(0x99, 0xEB), TWO_BYTES(0x71, 0x92),
            TWO_BYTES(0xF9, 0xBD), TWO_BYTES(0x88, 0x3E), TWO_BYTES(0x14, 0xAC), TWO_BYTES(0x4F, 0x5C),
            TWO_BYTES(0x9C, 0x65), TWO_BYTES(0x22, 0xFA), TWO_BYTES(0xA7, 0x2A), TWO_BYTES(0x77, 0x13),
            TWO_BYTES(0x22, 0x5E), TWO_BYTES(0x60, 0xF5), TWO_BYTES(0xFE, 0x29), TWO_BYTES(0x18, 0x18)
    } };
    static PUBKEY const pubkeyRootMeteringCert =
    {
        TWO_BYTES(0x45, 0xB1), TWO_BYTES(0xA7, 0xE1), TWO_BYTES(0x90, 0x81), TWO_BYTES(0x98, 0x37),
        TWO_BYTES(0x00, 0xCC), TWO_BYTES(0x89, 0xA7), TWO_BYTES(0x57, 0x24), TWO_BYTES(0x72, 0xB9),
        TWO_BYTES(0xC1, 0x29), TWO_BYTES(0xA3, 0x62), TWO_BYTES(0xD9, 0x55), TWO_BYTES(0x74, 0x04),
        TWO_BYTES(0x02, 0x7D), TWO_BYTES(0x6E, 0x69), TWO_BYTES(0x79, 0xE9), TWO_BYTES(0x6A, 0xD9),
        TWO_BYTES(0x7A, 0x92), TWO_BYTES(0xE4, 0xF3), TWO_BYTES(0x4B, 0x6B), TWO_BYTES(0x42, 0x6C)
    };

    ChkArg( f_pcontextLEVL              != NULL
         && f_pcontextLEVL->pcontextBBX != NULL);

    if (f_ppubkey != NULL)
    {
        ppubkey = (PUBKEY *)f_ppubkey;
    }
    else
    {
        switch(f_eRootPubkey)
        {
        case WM_DRM_ROOTPUBKEY_LRB:
        case WM_DRM_ROOTPUBKEY_LICENSES:
            ppubkey = &pubkeyMSCERT;
            break;

        case WM_DRM_ROOTPUBKEY_CLK:
            ppubkey = &(f_pcontextLEVL->pcontextBBX->CryptoContext.pubKey);
            break;

        case WM_DRM_ROOTPUBKEY_MTR:
            ppubkey = &pubkeyRootMeteringCert;
            break;

        default :
            ChkDR(DRM_E_INVALIDARG);
        }
    }

    ChkDR( _CheckCertificate( f_pcert,
                              ppubkey,
                              f_fCheckCertDate,
                              f_pcontextLEVL->pcontextBBX,
                              f_pcontextLEVL->pcontextSSTRevocation,
                              f_pcontextLEVL->pDatastore,
                              f_pcontextLEVL->pcontextBBX->pOEMContext ) );

ErrorExit:
    return dr;
}

static const PUBKEY pubkeyMS =
{
    {
        TWO_BYTES(0x4D, 0xBF), TWO_BYTES(0xD9, 0x0D), TWO_BYTES(0xD9, 0x6E), TWO_BYTES(0x8C, 0x9E),
        TWO_BYTES(0x32, 0x5F), TWO_BYTES(0x4F, 0x3D), TWO_BYTES(0xEC, 0xA9), TWO_BYTES(0x84, 0x59),
        TWO_BYTES(0x6B, 0x5E), TWO_BYTES(0x06, 0x86), TWO_BYTES(0xE7, 0xE2), TWO_BYTES(0xC2, 0x8B),
        TWO_BYTES(0xDE, 0x14), TWO_BYTES(0x4B, 0x29), TWO_BYTES(0x2C, 0xEC), TWO_BYTES(0x4D, 0x1D),
        TWO_BYTES(0x76, 0xFD), TWO_BYTES(0x5A, 0x14), TWO_BYTES(0x90, 0x3A), TWO_BYTES(0x10, 0x77)
    }
};

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_UTL_CheckCert(
    IN const CERT                *f_pcert,
    IN const PUBKEY              *f_ppubkey,
    IN       DRM_BOOL             f_fCheckDate,
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pcontextLEVL              != NULL
         && f_pcontextLEVL->pcontextBBX != NULL);

    ChkDR(_CheckCertificate( f_pcert,
                            (f_ppubkey != NULL) ? f_ppubkey : &pubkeyMS,
                             f_fCheckDate,
                             f_pcontextLEVL->pcontextBBX,
                             f_pcontextLEVL->pcontextSSTRevocation,
                             f_pcontextLEVL->pDatastore,
                             f_pcontextLEVL->pcontextBBX->pOEMContext ) );

ErrorExit:
    return (dr);
}

DRM_API DRM_RESULT DRM_CALL DRM_UTL_CheckCertNoCache(
    IN const CERT               *f_pcert,
    IN const PUBKEY             *f_ppubkey,
    IN       DRM_BOOL            f_fCheckDate,
    IN       DRM_CRYPTO_CONTEXT *f_pcontextCRYP,
    IN       DRM_VOID            *f_pOEMContext )
{
    DRM_RESULT dr = DRM_SUCCESS;

    /*
    ** The casting of f_pcontextCRYP to (DRM_BB_CONTEXT*) below is a safe cast.  When
    ** the underlying CheckCert functions are called, they will not use the BBX as a
    ** BBX, instead they will just use it as a crypto context.
    */

    ChkDR(_CheckCertificate( f_pcert,
                            (f_ppubkey != NULL) ? f_ppubkey : &pubkeyMS,
                             f_fCheckDate,
                             (DRM_BB_CONTEXT*)f_pcontextCRYP,
                             NULL,
                             NULL,
                             f_pOEMContext ) );

ErrorExit:
    return (dr);
}

DRM_API DRM_RESULT DRM_CALL DRM_UTL_CheckDACCert(
    IN const CERT                *f_pcert,
    IN const PUBKEY              *f_ppubkey,
    IN       DRM_BOOL             f_fCheckDate,
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL )
{
    DRM_RESULT    dr = DRM_SUCCESS;

    static const PUBKEY pubkeyDeviceAuthorizationCertificate =
    {
        {
            TWO_BYTES(0x4D, 0xBF), TWO_BYTES(0xD9, 0x0D), TWO_BYTES(0xD9, 0x6E), TWO_BYTES(0x8C, 0x9E),
            TWO_BYTES(0x32, 0x5F), TWO_BYTES(0x4F, 0x3D), TWO_BYTES(0xEC, 0xA9), TWO_BYTES(0x84, 0x59),
            TWO_BYTES(0x6B, 0x5E), TWO_BYTES(0x06, 0x86), TWO_BYTES(0xE7, 0xE2), TWO_BYTES(0xC2, 0x8B),
            TWO_BYTES(0xDE, 0x14), TWO_BYTES(0x4B, 0x29), TWO_BYTES(0x2C, 0xEC), TWO_BYTES(0x4D, 0x1D),
            TWO_BYTES(0x76, 0xFD), TWO_BYTES(0x5A, 0x14), TWO_BYTES(0x90, 0x3A), TWO_BYTES(0x10, 0x77)
        }
    };

    ChkArg( f_pcontextLEVL              != NULL
         && f_pcontextLEVL->pcontextBBX != NULL);

    ChkDR(_CheckCertificate( f_pcert,
                            (f_ppubkey != NULL) ? f_ppubkey : &pubkeyDeviceAuthorizationCertificate,
                             f_fCheckDate,
                             f_pcontextLEVL->pcontextBBX,
                             f_pcontextLEVL->pcontextSSTRevocation,
                             f_pcontextLEVL->pDatastore,
                             f_pcontextLEVL->pcontextBBX->pOEMContext ) );

ErrorExit:
    return (dr);
}

/**********************************************************************
** Function:    PKEncryptLarge
**
** Synopsis:    Encrypt large amoutn of data (using PKEncrypt with large data is slow, this is fast)
**
** Arguments:   [f_ppubkey]        -- Caller supplied public key to encrypt with
**              [f_pbClear]        -- Array of bytes to encrypt
**              [f_cbClear]        -- Length ob f_pbClear in bytes
**              [f_pbCipher]       -- Buffer to hold encrypted data
**              [f_cbKeySymmetric] -- Desired length of internal symmertic key to be created
**              [f_pcontextCRYP]   -- A DRM_CRYPTO_CONTEXT so PKCrypto operations can be performed.
**
** Notes:       out must be of length f_cbClear + DRM_ECC160_CIPHERTEXT_LEN
**              Internally a rc4 symmetric key will be created to encrypt the content (because it's fast) &
**              that symmertic key will be encrypted with the PUBKEY.
**              In place encryption is possible if f_pbCipher equals to f_pbClear.
***********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_PK_EncryptLarge(
    IN       DRM_VOID            *f_pOEMContext,
    IN const PUBKEY              *f_ppubkey,
    __inout_bcount( f_cbClear ) DRM_BYTE *f_pbClear,
    IN       DRM_DWORD            f_cbClear,
    __out_bcount( f_cbClear + DRM_ECC160_CIPHERTEXT_LEN ) DRM_BYTE *f_pbCipher,
    IN       DRM_DWORD            f_cbKeySymmetric,
    IN       DRM_CRYPTO_CONTEXT  *f_pcontextCRYP)
{
    DRM_RESULT     dr          = DRM_SUCCESS;
    DRM_BYTE      *pbKey       = NULL; /* This needs __CB_DECL(DRM_ECC160_PLAINTEXT_LEN) bytes */
    RC4_KEYSTRUCT  rc4KS       = { 0 };
    DRM_DWORD      cbEncrypted = DRM_ECC160_CIPHERTEXT_LEN;

    ChkArg(f_ppubkey      != NULL
        && f_pbClear      != NULL
        && f_pbCipher     != NULL
        && f_pcontextCRYP != NULL);

    ChkArg(f_cbKeySymmetric <= (DRM_ECC160_PLAINTEXT_LEN - 2))

    if (f_cbKeySymmetric > DRMCIPHERKEYLEN_RC4)
    {
        f_cbKeySymmetric = DRMCIPHERKEYLEN_RC4;
    }

    /* Ensure the temporary buffer we are using is big enough */
    DRMCASSERT( DRM_ECC160_PLAINTEXT_LEN <= SIZEOF( f_pcontextCRYP->signature ) );
    pbKey = f_pcontextCRYP->signature;

    DRM_BYT_MoveBytes(f_pbCipher, DRM_ECC160_CIPHERTEXT_LEN, f_pbClear, 0, f_cbClear);

    PUT_BYTE( pbKey, 0, (DRM_BYTE) f_cbKeySymmetric );
    PUT_BYTE( pbKey, 1, (DRM_BYTE) PKSYMM_ALG_TYPE_RC4 );

    ChkDR(Oem_Random_GetBytes(f_pOEMContext, pbKey + __CB_DECL(2), f_cbKeySymmetric));
    ChkDR( DRM_PK_Encrypt( NULL,
                           f_pcontextCRYP->rgbCryptoContext,
                           eDRM_ECC_P160,
                           DRM_ECC160_PUBLIC_KEY_LEN,
                           ( DRM_BYTE * )f_ppubkey,
                           DRM_ECC160_PLAINTEXT_LEN,
                           pbKey,
                           &cbEncrypted,
                           f_pbCipher ) );

    DRM_RC4_KeySetup(&rc4KS, f_cbKeySymmetric, pbKey      + __CB_DECL(2));
    DRM_RC4_Cipher  (&rc4KS, f_cbClear,        f_pbCipher + __CB_DECL(DRM_ECC160_CIPHERTEXT_LEN));

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_PK_DecryptLarge
**
** Synopsis:    Dencrypt data encrypted with DRM_PK_EncryptLarge
**
** Arguments:   [f_ppubkey] -- Caller supplied private key to decrypt with
**              [f_pbCipher]    -- Array of bytes to decrypt
**              [f_cbCipher]    -- Length of f_pbCipher in bytes
**              [f_pbClear]   -- Buffer to hold decrypted data
**              [f_pcontextCRYP] -- A DRM_CRYPT_CONTEXT so PKCrypto operations can be performed.
**
** Notes:       out must be at least f_cbCipher - DRM_ECC160_CIPHERTEXT_LEN in length.
**              In place decryption is possible if f_pbClear equals to f_pbCipher.
***********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_PK_DecryptLarge(
    IN const PRIVKEY            *f_ppubkey,
    __inout_bcount( f_cbCipher) DRM_BYTE  *f_pbCipher,
    IN       DRM_DWORD           f_cbCipher,
    __out_bcount( f_cbCipher - DRM_ECC160_CIPHERTEXT_LEN ) DRM_BYTE *f_pbClear,
    IN       DRM_CRYPTO_CONTEXT *f_pcontextCRYP)
{
    DRM_RESULT     dr    = DRM_SUCCESS;
    DRM_BYTE      *pbKey = NULL;
    DRM_DWORD      cbKey = SIZEOF( f_pcontextCRYP->signature );
    RC4_KEYSTRUCT  rc4KS;

    ChkArg(f_ppubkey      != NULL
        && f_pbCipher     != NULL
        && f_pbClear      != NULL
        && f_pcontextCRYP != NULL);

    /* Ensure the temporary buffer we are using is big enough */
    DRMCASSERT( DRM_ECC160_PLAINTEXT_LEN <= SIZEOF( f_pcontextCRYP->signature ) );
    pbKey = f_pcontextCRYP->signature;

    ChkDR( DRM_PK_Decrypt( f_pcontextCRYP->rgbCryptoContext,
                           eDRM_ECC_P160,
                           DRM_ECC160_PRIVATE_KEY_LEN,
                           ( const DRM_BYTE * )f_ppubkey,
                           DRM_ECC160_CIPHERTEXT_LEN,
                           f_pbCipher,
                           &cbKey,
                           pbKey ) );

    if (GET_BYTE(pbKey,1) != PKSYMM_ALG_TYPE_RC4)
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    ChkOverflow( f_cbCipher, f_cbCipher - DRM_ECC160_CIPHERTEXT_LEN );

    DRM_BYT_MoveBytes(f_pbClear,
                      0,
                      f_pbCipher,
                      DRM_ECC160_CIPHERTEXT_LEN,
                      f_cbCipher - DRM_ECC160_CIPHERTEXT_LEN);

    DRM_RC4_KeySetup(&rc4KS, GET_BYTE(pbKey,0),                  pbKey + __CB_DECL(2));
    DRM_RC4_Cipher  (&rc4KS, f_cbCipher - DRM_ECC160_CIPHERTEXT_LEN, f_pbClear);

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_UTL_VerifyXMLSignature
**
** Synopsis :   Verify the xml signature over some data
**
** Arguments :  f_pdstrSignedData   -   The entire data that is signed
**              f_pdstrSignatureXML -   <SIGNATURE>...</SIGNATURE>
**              f_pdstrCertChainXML -   <CERTIFICATECHAIN>...</CERTIFICATECHAIN>
**              f_fCheckExpiry      -   Check for cert expiration
**              f_fCheckCertChain   -   Verify cert chain. If this is false,
**                                      f_pcontextCrypto->pubKey must contain
**                                      the public key which will be used to
**                                      verify the signature.
**              f_eRootPubkey       -   Root Pubkey to use for cert verification
**                                      if it is WM_DRM_ROOTPUBKEY_CLK,
**              f_pcontextLEVL      -   License eval context.  The BBX pointer must be valid.
**                                      The DST and pcontextSSTRevocation pointers must be valid to perform cert caching.
**
** Returns :    DRM_SUCCESS -   Signature verified successfully
**              DRM_E_INVALID_SIGNATURE -   Verification failed
**              some other problem
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_UTL_VerifyXMLSignature(
    IN  const   DRM_CONST_STRING        *f_pdstrSignedData,
    IN  const   DRM_CONST_STRING        *f_pdstrSignatureXML,
    IN  const   DRM_CONST_STRING        *f_pdstrCertChainXML,
    IN          DRM_BOOL                 f_fCheckExpiry,
    IN          DRM_BOOL                 f_fCheckCertChain,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey,
    IN          DRM_LICEVAL_CONTEXT     *f_pcontextLEVL)
{
    DRM_CONST_STRING dstrSignature = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrTmp       = EMPTY_DRM_STRING;
    DRM_RESULT       dr            = DRM_SUCCESS;

    /*
    **  Verify input
    */
    ChkDRMString(f_pdstrSignedData);
    ChkDRMString(f_pdstrSignatureXML);
    if (f_fCheckCertChain)
    {
        ChkDRMString(f_pdstrCertChainXML);
    }

    ChkArg( f_pcontextLEVL              != NULL
         && f_pcontextLEVL->pcontextBBX != NULL );

    /*
    **  Verify Hashing algorithm
    */
    dr = DRM_XML_GetSubNode( f_pdstrSignatureXML,
                            &g_dstrTagHashAlg,
                            &g_dstrAttributeType,
                            &g_dstrSHA,
                             0,
                             NULL,
                            &dstrTmp,
                             1);
    if( DRM_FAILED(dr) )
    {
        ChkDR(DRM_E_UNSUPPORTEDALGORITHM);
    }

    /*
    **  Verify Signature algorithm
    */
    dr = DRM_XML_GetSubNode( f_pdstrSignatureXML,
                            &g_dstrTagSignAlg,
                            &g_dstrAttributeType,
                            &g_dstrMSDRM,
                             0,
                             NULL,
                            &dstrTmp,
                            1);
    if( DRM_FAILED(dr) )
    {
        ChkDR(DRM_E_UNSUPPORTEDALGORITHM);
    }

    /*
    **  Get Signature value
    */
    ChkDR( DRM_XML_GetSubNode( f_pdstrSignatureXML,
                              &g_dstrTagValue,
                               NULL,
                               NULL,
                               0,
                               NULL,
                              &dstrSignature,
                               1)  );

    dr = _UTL_VerifySignature( f_pdstrSignedData,
                              &dstrSignature,
                               f_pdstrCertChainXML,
                               f_fCheckExpiry,
                               f_fCheckCertChain,
                               f_eRootPubkey,
                               f_pcontextLEVL );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_UTL_VerifyXMLSignatureEx
**
** Synopsis :   Verify the xml signature over some data
**
** Arguments :  f_pdstrSignedData   -   The entire data that is signed
**              f_pdstrSignatureValue -   Sig value
**              f_pdstrCertChainXML -   <CERTIFICATECHAIN>...</CERTIFICATECHAIN>
**              f_fCheckExpiry      -   Check for cert expiration
**              f_fCheckCertChain   -   Verify cert chain. If this is false,
**                                      f_pcontextCrypto->pubKey must contain
**                                      the public key which will be used to
**                                      verify the signature.
**              f_eRootPubkey       -   Root Pubkey to use for cert verification
**              f_pcontextLEVL      -   License eval context.  The BBX pointer must be valid.
**                                      The DST and pcontextSSTRevocation pointers must be valid to perform cert caching.
**
** Returns :    DRM_SUCCESS -   Signature verified successfully
**              DRM_E_INVALID_SIGNATURE -   Verification failed
**              some other problem
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_UTL_VerifyXMLSignatureEx(
    IN  const   DRM_CONST_STRING        *f_pdstrSignedData,
    IN  const   DRM_CONST_STRING        *f_pdstrSignatureValue,
    IN  const   DRM_CONST_STRING        *f_pdstrCertChainXML,
    IN          DRM_BOOL                 f_fCheckExpiry,
    IN          DRM_BOOL                 f_fCheckCertChain,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey,
    IN          DRM_LICEVAL_CONTEXT     *f_pcontextLEVL)
{
    DRM_RESULT dr = DRM_SUCCESS;

    /*
    **  Verify input
    */
    ChkDRMString(f_pdstrSignedData);
    ChkDRMString(f_pdstrSignatureValue);
    if (f_fCheckCertChain)
    {
        ChkDRMString(f_pdstrCertChainXML);
    }
    ChkArg( f_pcontextLEVL              != NULL
         && f_pcontextLEVL->pcontextBBX != NULL );

    dr = _UTL_VerifySignature( f_pdstrSignedData,
                               f_pdstrSignatureValue,
                               f_pdstrCertChainXML,
                               f_fCheckExpiry,
                               f_fCheckCertChain,
                               f_eRootPubkey,
                               f_pcontextLEVL );

ErrorExit:
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmstrsafe.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmstrings.h>
#include <drmstrsafe.h>

ENTER_PK_NAMESPACE_CODE;

static DRM_RESULT DRM_CALL _DrmStringLengthWorkerW(
    __in_ecount(f_cchMax) const DRM_WCHAR *f_pwsz,
    __in                        DRM_DWORD  f_cchMax,
    __out_opt                   DRM_DWORD *f_pcchLength)
{
    DRM_RESULT dr           = DRM_SUCCESS;
    DRM_DWORD  cchMaxPrev   = f_cchMax;

    while ((f_cchMax != 0) && (*f_pwsz != g_wchNull))
    {
        f_pwsz++;
        f_cchMax--;
    }

    /* Check if the string is longer than cchMax */
    ChkArg( f_cchMax != 0 );
    
ErrorExit:

    if (f_pcchLength != NULL)
    {
        if (DRM_SUCCEEDED(dr))
        {
            *f_pcchLength = cchMaxPrev - f_cchMax;
        }
        else
        {
            *f_pcchLength = 0;
        }
    }
    
    return dr;
}

static DRM_RESULT DRM_CALL _DrmStringLengthWorkerA(
    __in_z              const DRM_CHAR  *f_psz,
    __in                      DRM_DWORD  f_cchMax,
    __out_opt                 DRM_DWORD *f_pcchLength)
{
    DRM_RESULT dr           = DRM_SUCCESS;
    DRM_DWORD  cchMaxPrev   = f_cchMax;
    DRM_DWORD  ib           = 0;

    while (f_cchMax && (GET_BYTE(f_psz, ib) != '\0'))
    {
        ib++;
        f_cchMax--;
    }

    /* Check if the string is longer than cchMax */
    ChkArg( f_cchMax != 0 );

ErrorExit:
    
    if (f_pcchLength != NULL)
    {
        if (DRM_SUCCEEDED(dr))
        {
            *f_pcchLength = cchMaxPrev - f_cchMax;
        }
        else
        {
            *f_pcchLength = 0;
        }
    }

    return dr;
}

static DRM_NO_INLINE DRM_RESULT DRM_CALL _DrmStringCopyNWorkerW(
    __out_ecount_z(f_cchDest)       DRM_WCHAR *f_pwszDest,
    __in                            DRM_DWORD  f_cchDest,
    __in_ecount(f_cchToCopy)  const DRM_WCHAR *f_pwszSrc,
    __in                            DRM_DWORD  f_cchToCopy )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pwszSrc != NULL );
    ChkArg( f_pwszDest != NULL );
    ChkArg( f_cchDest != 0 );

    while (f_cchDest && f_cchToCopy && (*f_pwszSrc != g_wchNull))
    {
        *f_pwszDest++ = *f_pwszSrc++;
        f_cchDest--;
        f_cchToCopy--;
    }

    if (f_cchDest == 0)
    {
        /* We are going to truncate f_pwszDest */
        f_pwszDest--;
        dr = DRM_E_BUFFERTOOSMALL;
    }

    *f_pwszDest = g_wchNull;
        
ErrorExit:
    return dr;
}

static DRM_RESULT DRM_CALL _DrmStringCopyWorkerW(
    __out_ecount_z(f_cchDest) DRM_WCHAR *f_pwszDest,
    __in                      DRM_DWORD  f_cchDest,
    __in_z              const DRM_WCHAR *f_pwszSrc)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_cchDest != 0 );

    while (f_cchDest && (*f_pwszSrc != g_wchNull))
    {
        *f_pwszDest++ = *f_pwszSrc++;
        f_cchDest--;
    }

    if (f_cchDest == 0)
    {
        /* we are going to truncate f_pwszDest */
        f_pwszDest--;
        dr = DRM_E_BUFFERTOOSMALL;
    }

    *f_pwszDest = g_wchNull;

ErrorExit:
    return dr;
}


static DRM_RESULT DRM_CALL _DrmStringCopyWorkerA(
    __out_ecount_z(f_cchDest) DRM_CHAR *f_pszDest,
    __in                      DRM_DWORD f_cchDest,
    __in_z              const DRM_CHAR *f_pszSrc)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  ib = 0;

    ChkArg(f_cchDest != 0)

    while (f_cchDest && (GET_BYTE(f_pszSrc, ib) != '\0'))
    {
        PUT_BYTE( f_pszDest, ib, GET_BYTE(f_pszSrc, ib) );
        ib++;
        f_cchDest--;
    }

    if (f_cchDest == 0)
    {
        // we are going to truncate f_pszDest
        ib--;
        dr = DRM_E_BUFFERTOOSMALL;
    }

    PUT_BYTE( f_pszDest, ib, '\0' );

ErrorExit:
    return dr;
}

static DRM_RESULT DRM_CALL _DrmStringCopyNWorkerA(
    __out_ecount_z(f_cchDest)   DRM_CHAR *f_pszDest,
    __in                        DRM_DWORD f_cchDest,
    __in_ecount(f_cchSrc) const DRM_CHAR *f_pszSrc,
    __in                        DRM_DWORD f_cchSrc)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  ib = 0;

    ChkArg(f_cchDest != 0)

    while (f_cchDest && f_cchSrc && (GET_BYTE(f_pszSrc, ib) != '\0'))
    {
        PUT_BYTE( f_pszDest, ib, GET_BYTE(f_pszSrc, ib) );
        ib++;
        f_cchDest--;
        f_cchSrc--;
    }

    if (f_cchDest == 0)
    {
        // we are going to truncate f_pszDest
        ib--;
        dr = DRM_E_BUFFERTOOSMALL;
    }

    PUT_BYTE( f_pszDest, ib, '\0' );
ErrorExit:
    return dr;
}

static DRM_RESULT DRM_CALL _DrmStringCatNWorkerW(
    __inout_ecount_z(f_cchDest)       DRM_WCHAR *f_pwszDest,
    __in                              DRM_DWORD  f_cchDest,
    __in_ecount(f_cchToAppend) const  DRM_WCHAR *f_pwszSrc,
    __in                              DRM_DWORD  f_cchToAppend)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cchDestLength = 0;

    ChkDR( _DrmStringLengthWorkerW(f_pwszDest, f_cchDest, &cchDestLength) );

    ChkDR( _DrmStringCopyNWorkerW(f_pwszDest + cchDestLength,
                        f_cchDest - cchDestLength,
                        f_pwszSrc,
                        f_cchToAppend) );

ErrorExit:
    return dr;
}

static DRM_RESULT DRM_CALL _DrmStringCatWorkerW(
    __inout_ecount_z(f_cchDest) DRM_WCHAR *f_pwszDest,
    __in                        DRM_DWORD  f_cchDest,
    __in_z                const DRM_WCHAR *f_pwszSrc)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cchDestLength = 0;

    ChkDR( _DrmStringLengthWorkerW(f_pwszDest, f_cchDest, &cchDestLength) );

    ChkDR( _DrmStringCopyWorkerW(f_pwszDest + cchDestLength,
                          f_cchDest - cchDestLength,
                          f_pwszSrc) );
ErrorExit:
   return dr;
}

static DRM_RESULT DRM_CALL _DrmStringCatWorkerA(
    __inout_ecount_z(f_cchDest) DRM_CHAR *f_pszDest,
    __in                        DRM_DWORD f_cchDest,
    __in_z                const DRM_CHAR *f_pszSrc)
{
    DRM_RESULT dr;
    DRM_DWORD  cchDestLength;

    ChkDR( _DrmStringLengthWorkerA(f_pszDest, f_cchDest, &cchDestLength) );

    ChkOverflow( f_cchDest, f_cchDest - cchDestLength );
    
    ChkDR( _DrmStringCopyWorkerA(f_pszDest + cchDestLength,
                                 f_cchDest - cchDestLength,
                                 f_pszSrc) );
ErrorExit:
    return dr;
}

static DRM_RESULT DRM_CALL _DrmStringCatNWorkerA(
    __inout_ecount_z(f_cchDest)       DRM_CHAR *f_pszDest,
    __in                              DRM_DWORD f_cchDest,
    __in_ecount(f_cchToAppend) const  DRM_CHAR *f_pszSrc,
    __in                              DRM_DWORD f_cchToAppend)
{
    DRM_RESULT dr;
    DRM_DWORD  cchDestLength;

    ChkDR( _DrmStringLengthWorkerA(f_pszDest, f_cchDest, &cchDestLength) );

    ChkOverflow( f_cchDest, f_cchDest - cchDestLength );

    ChkDR( _DrmStringCopyNWorkerA(f_pszDest + cchDestLength,
                                  f_cchDest - cchDestLength,
                                  f_pszSrc,
                                  f_cchToAppend) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_STR_StringCchLengthW
** 
** Synopsis:    This function is a replacement for strlen. 
**
**              It is used to ensure that a string is not larger than a 
**              given length, in characters. If that condition is met, 
**              StringCchLength returns the current length of the string 
**              in characters, not including the terminating null character.
**
** Arguments:   [f_pwsz]    Pointer to a buffer containing the string whose 
**                          length is being checked.
**              [f_cchMax]  The maximum number of characters allowed in f_pwsz,
**                          including the terminating null character. 
**                          This value cannot exceed DRM_STRSAFE_MAX_CCH.
**              [f_pcch]    Pointer to a variable of type DRM_DWORD 
**                          containing the number of characters in f_pwsz, 
**                          excluding the terminating null character. 
**                          This value is valid only if f_pcch is not null 
**                          and the function succeeds. 
**
** Returns:     DRM_SUCCESS
**                  The string at f_pwsz was not null, and the length of the
**                  string (including the terminating null character) is less 
**                  than or equal to f_cchMax characters. 
**              DRM_E_INVALIDARG
**                  The value in f_pwsz is NULL, f_cchMax is larger than 
**                  DRM_STRSAFE_MAX_CCH, or f_pwsz is longer than cchMax. 
**              DRM_E_BUFFERTOOSMALL
**                  f_cchSrc is larger than f_cchDest
** 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchLengthW
(
    __in_z const DRM_WCHAR *f_pwsz,
    __in         DRM_DWORD  f_cchMax,
    __out_opt    DRM_DWORD *f_pcchLength )
{
    DRM_RESULT  dr = DRM_SUCCESS;

    ChkArg( (f_pwsz != NULL) && (f_cchMax <= DRM_STRSAFE_MAX_CCH) );

    ChkDR( _DrmStringLengthWorkerW(f_pwsz, f_cchMax, f_pcchLength) );

ErrorExit:
    if (DRM_FAILED(dr) && f_pcchLength != NULL)
    {
        *f_pcchLength = 0;
    }
    return dr;
}

/**********************************************************************
** Function:    DRM_STR_StringCchLengthA
** 
** Synopsis:    This function is a replacement for strlen. 
**
**              It is used to ensure that a string is not larger than a 
**              given length, in characters. If that condition is met, 
**              StringCchLength returns the current length of the string 
**              in characters, not including the terminating null character.
**
** Arguments:   [f_psz]     Pointer to a buffer containing the string whose 
**                          length is being checked.
**              [f_cchMax]  The maximum number of characters allowed in f_pwsz,
**                          including the terminating null character. 
**                          This value cannot exceed DRM_STRSAFE_MAX_CCH.
**              [f_pcch]    Pointer to a variable of type DRM_DWORD 
**                          containing the number of characters in f_pwsz, 
**                          excluding the terminating null character. 
**                          This value is valid only if f_pcch is not null 
**                          and the function succeeds. 
**
** Returns:     DRM_SUCCESS
**                  The string at f_pwsz was not null, and the length of the
**                  string (including the terminating null character) is less 
**                  than or equal to f_cchMax characters. 
**              DRM_E_INVALIDARG
**                  The value in f_pwsz is NULL, f_cchMax is larger than 
**                  DRM_STRSAFE_MAX_CCH, or f_pwsz is longer than f_cchMax. 
**              DRM_E_BUFFERTOOSMALL
**                  f_cchSrc is larger than f_cchDest
** 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchLengthA(
    __in_z              const DRM_CHAR  *f_psz,
    __in                      DRM_DWORD  f_cchMax,
    __out_opt                 DRM_DWORD *f_pcchLength)
{
    DRM_RESULT  dr = DRM_SUCCESS;

    ChkArg( (f_psz != NULL) && (f_cchMax <= DRM_STRSAFE_MAX_CCH) );
    
    ChkDR( _DrmStringLengthWorkerA(f_psz, f_cchMax, f_pcchLength) );

ErrorExit:
    if (DRM_FAILED(dr) && f_pcchLength != NULL)
    {
        *f_pcchLength = 0;
    }

    return dr;
}

/**********************************************************************
** Function:    DRM_STR_StringCchCopyNW
** 
** Synopsis:    Copies a null-terminated wide character buffer from source
**              to destination. If the source buffer is longer than the
**              destination buffer, sets the last byte of the destination
**              buffer to 0 and returns DRM_E_BUFFERTOOSMALL
**
** Arguments:   [f_pwszDest] The destination buffer
**              [f_cchDest]  The character count of the destination buffer
**              [f_pwszSrc]  The source buffer
**              [f_cchSrc]   The character count of the source buffer
**
** Returns:     DRM_SUCCESS
**                  Success
**              DRM_E_INVALIDARG
**                  One of the byte counts is too large, or either the source
**                  or destination buffer is NULL, or the destination byte count
**                  is 0.
**              DRM_E_BUFFERTOOSMALL
**                  f_cchSrc is larger than f_cchDest
** 
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_STR_StringCchCopyNW( 
    __out_ecount_z(f_cchDest)     DRM_WCHAR  *f_pwszDest,
    __in                          DRM_DWORD   f_cchDest,
    __in_ecount( f_cchSrc ) const DRM_WCHAR  *f_pwszSrc,
    __in                          DRM_DWORD   f_cchSrc )
{
    DRM_RESULT  dr = DRM_SUCCESS;

    ChkArg( (f_cchDest <= DRM_STRSAFE_MAX_CCH) && (f_cchSrc <= DRM_STRSAFE_MAX_CCH) );
    
    ChkArg( f_pwszDest != NULL
         && f_pwszSrc  != NULL );

    ChkDR( _DrmStringCopyNWorkerW(f_pwszDest, f_cchDest, f_pwszSrc, f_cchSrc) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_STR_StringCchCopyNA
** 
** Synopsis:    Copies a null-terminated character buffer from source
**              to destination. If the source buffer is longer than the
**              destination buffer, sets the last byte of the destination
**              buffer to 0 and returns DRM_E_BUFFERTOOSMALL
**
** Arguments:   [f_pszDest]  The destination buffer
**              [f_cchDest]  The byte count of the destination buffer
**              [f_pszSrc]   The source buffer
**              [f_cchSrc]   The byte count of the source buffer
**
** Returns:     DRM_SUCCESS
**                  Success
**              DRM_E_INVALIDARG
**                  One of the byte counts is too large, or either the source
**                  or destination buffer is NULL, or the destination byte count
**                  is 0.
**              DRM_E_BUFFERTOOSMALL
**                  f_cchSrc is larger than f_cchDest
** 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCopyNA(
    __out_ecount_z(f_cchDest)       DRM_CHAR *f_pszDest,
    __in                            DRM_DWORD f_cchDest,
    __in_ecount(f_cchToCopy)  const DRM_CHAR *f_pszSrc,
    __in                            DRM_DWORD f_cchToCopy)
{
    DRM_RESULT dr;

    ChkArg( (f_cchDest <= DRM_STRSAFE_MAX_CCH) );
    ChkArg( (f_cchToCopy <= DRM_STRSAFE_MAX_CCH) );

    ChkArg( f_pszDest != NULL
         && f_pszSrc  != NULL );
    
    ChkDR( _DrmStringCopyNWorkerA(f_pszDest, f_cchDest, f_pszSrc, f_cchToCopy) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_STR_StringCchCopyW
** 
** Synopsis:    Copies a null-terminated wide character buffer from source
**              to destination. If the source buffer is longer than the
**              destination buffer, sets the last byte of the destination
**              buffer to 0 and returns DRM_E_BUFFERTOOSMALL
**
** Arguments:   [f_pwszDest] The destination buffer
**              [f_cchDest]  The byte count of the destination buffer
**              [f_pwszSrc]  The NULL terminated source buffer
**
** Returns:     DRM_SUCCESS
**                  Success
**              DRM_E_INVALIDARG
**                  One of the byte counts is too large, or either the source
**                  or destination buffer is NULL, or the destination byte count
**                  is 0.
**              DRM_E_BUFFERTOOSMALL
**                  f_cchSrc is larger than f_cchDest
** 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCopyW( 
    __out_ecount_z(f_cchDest) DRM_WCHAR  *f_pwszDest,
    __in                      DRM_DWORD   f_cchDest,
    __in_z              const DRM_WCHAR  *f_pwszSrc )
{
    DRM_RESULT  dr = DRM_SUCCESS;

    ChkArg( (f_cchDest <= DRM_STRSAFE_MAX_CCH) );
    
    ChkArg( f_pwszDest != NULL
         && f_pwszSrc  != NULL );

    ChkDR( _DrmStringCopyWorkerW(f_pwszDest, f_cchDest, f_pwszSrc) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_STR_StringCchCopyA
** 
** Synopsis:    Copies a null-terminated wide character buffer from source
**              to destination. If the source buffer is longer than the
**              destination buffer, sets the last byte of the destination
**              buffer to 0 and returns DRM_E_BUFFERTOOSMALL
**
** Arguments:   [f_pszDest]  The destination buffer
**              [f_cchDest]  The byte count of the destination buffer
**              [f_pszSrc]   The NULL terminated source buffer
**
** Returns:     DRM_SUCCESS
**                  Success
**              DRM_E_INVALIDARG
**                  One of the byte counts is too large, or either the source
**                  or destination buffer is NULL, or the destination byte count
**                  is 0.
**              DRM_E_BUFFERTOOSMALL
**                  f_cchSrc is larger than f_cchDest
** 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCopyA(
    __out_ecount_z(f_cchDest) DRM_CHAR *f_pszDest,
    __in                      DRM_DWORD f_cchDest,
    __in_z              const DRM_CHAR *f_pszSrc)
{
    DRM_RESULT dr;

    ChkArg( (f_cchDest <= DRM_STRSAFE_MAX_CCH) );

    ChkArg( f_pszDest != NULL
         && f_pszSrc  != NULL );
    
    ChkDR( _DrmStringCopyWorkerA(f_pszDest, f_cchDest, f_pszSrc) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_STR_StringCchCatW
** 
** Synopsis:    This function is a replacement for strcat. The size, in 
**              characters, of the destination buffer is provided to the 
**              function to ensure that StringCchCat does not write past 
**              the end of this buffer.
**
** Arguments:   [f_pwszDest] Pointer to a buffer containing the string 
**                           that f_pwszSrc is concatenated to, and which 
**                           contains the entire resultant string. The 
**                           string at f_pwszSrc is added to the end of the 
**                           string at f_pwszDest. 
**              [f_cchDest]  Size of the destination buffer, in characters. 
**                           This value must equal the length of f_pwszSrc 
**                           plus the length of f_pwszDest plus 1 to account 
**                           for both strings and the terminating null character.
**                           The maximum number of characters allowed is 
**                           DRM_STRSAFE_MAX_CCH. 
**              [f_pwszSrc]  Pointer to a buffer containing the source string 
**                           that is concatenated to the end of f_pwszDest. This 
**                           source string must be null-terminated. 
**
** Returns:     DRM_SUCCESS
**                  Source data was present, the strings were fully concatenated 
**                  without truncation, and the resultant destination buffer is 
**                  null-terminated.
**              DRM_E_INVALIDARG
**                  The value in f_cchDest is 0 or larger than STRSAFE_MAX_CCH, or 
**                  the destination buffer is already full.
**              DRM_E_BUFFERTOOSMALL
**                  The concatenation operation failed due to insufficient buffer 
**                  space. The destination buffer contains a truncated, 
**                  null-terminated version of the intended result. Where 
**                  truncation is acceptable, this is not necessarily a failure 
**                  condition.
** 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCatW
(   __out_ecount_z(f_cchDest) DRM_WCHAR *f_pwszDest,
    __in                      DRM_DWORD  f_cchDest,
    __in_z              const DRM_WCHAR *f_pwszSrc )

{   DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg( f_pwszDest != NULL && f_cchDest <= DRM_STRSAFE_MAX_CCH && f_pwszSrc != NULL );

    ChkDR( _DrmStringCatWorkerW(f_pwszDest, f_cchDest, f_pwszSrc) );
    
ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_STR_StringCchCatA
** 
** Synopsis:    This function is a replacement for strcat. The size, in 
**              characters, of the destination buffer is provided to the 
**              function to ensure that StringCchCat does not write past 
**              the end of this buffer.
**
** Arguments:   [f_pszDest] Pointer to a buffer containing the string 
**                          that f_pszSrc is concatenated to, and which 
**                          contains the entire resultant string. The 
**                          string at f_pszSrc is added to the end of the 
**                          string at f_pszDest. 
**              [f_cchDest] Size of the destination buffer, in characters. 
**                          This value must equal the length of f_pszSrc 
**                          plus the length of f_pszDest plus 1 to account 
**                          for both strings and the terminating null character.
**                          The maximum number of characters allowed is 
**                          DRM_STRSAFE_MAX_CCH. 
**              [f_pszSrc]  Pointer to a buffer containing the source string 
**                          that is concatenated to the end of f_pszDest. This 
**                          source string must be null-terminated. 
**
** Returns:     DRM_SUCCESS
**                  Source data was present, the strings were fully concatenated 
**                  without truncation, and the resultant destination buffer is 
**                  null-terminated.
**              DRM_E_INVALIDARG
**                  The value in f_cchDest is 0 or larger than STRSAFE_MAX_CCH, or 
**                  the destination buffer is already full.
**              DRM_E_BUFFERTOOSMALL
**                  The concatenation operation failed due to insufficient buffer 
**                  space. The destination buffer contains a truncated, 
**                  null-terminated version of the intended result. Where 
**                  truncation is acceptable, this is not necessarily a failure 
**                  condition.
** 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCatA
(   __out_ecount_z(f_cchDest) DRM_CHAR  *f_pszDest,
    __in                      DRM_DWORD  f_cchDest,
    __in_z              const DRM_CHAR  *f_pszSrc )

{   DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg( f_pszDest != NULL && f_cchDest <= DRM_STRSAFE_MAX_CCH && f_pszSrc != NULL );

    ChkDR( _DrmStringCatWorkerA(f_pszDest, f_cchDest, f_pszSrc) );
    
ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_STR_StringCchCatNW
** 
** Synopsis:    This function is a replacement for strcat. The size, in 
**              characters, of the destination buffer is provided to the 
**              function to ensure that StringCchCat does not write past 
**              the end of this buffer.
**
** Arguments:   [f_pwszDest] Pointer to a buffer containing the string 
**                           that f_pwszSrc is concatenated to, and which 
**                           contains the entire resultant string. The 
**                           string at f_pwszSrc is added to the end of the 
**                           string at f_pwszDest. 
**              [f_cchDest]  Size of the destination buffer, in characters. 
**                           This value must equal the length of f_pwszSrc 
**                           plus the length of f_pwszDest plus 1 to account 
**                           for both strings and the terminating null character.
**                           The maximum number of characters allowed is 
**                           DRM_STRSAFE_MAX_CCH. 
**              [f_pwszSrc]  Pointer to a buffer containing the source string 
**                           that is concatenated to the end of f_pwszDest. This 
**                           source string must be null-terminated. 
**              [f_cchToAppend] The maximum number of characters to append to f_pwszDest. 
**
** Returns:     DRM_SUCCESS
**                  Source data was present, the strings were fully concatenated 
**                  without truncation, and the resultant destination buffer is 
**                  null-terminated.
**              DRM_E_INVALIDARG
**                  The value in f_cchDest is 0 or larger than STRSAFE_MAX_CCH, or 
**                  the destination buffer is already full.
**              DRM_E_BUFFERTOOSMALL
**                  The concatenation operation failed due to insufficient buffer 
**                  space. The destination buffer contains a truncated, 
**                  null-terminated version of the intended result. Where 
**                  truncation is acceptable, this is not necessarily a failure 
**                  condition.
** 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCatNW
(   __out_ecount_z(f_cchDest)        DRM_WCHAR *f_pwszDest,
    __in                             DRM_DWORD  f_cchDest,
    __in_ecount(f_cchToAppend) const DRM_WCHAR *f_pwszSrc,
    __in                             DRM_DWORD  f_cchToAppend )

{   DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg( f_pwszDest != NULL && f_cchDest <= DRM_STRSAFE_MAX_CCH && f_pwszSrc != NULL );

    ChkDR( _DrmStringCatNWorkerW(f_pwszDest, f_cchDest, f_pwszSrc, f_cchToAppend) );
    
ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_STR_StringCchCatNA
** 
** Synopsis:    This function is a replacement for strcat. The size, in 
**              characters, of the destination buffer is provided to the 
**              function to ensure that StringCchCat does not write past 
**              the end of this buffer.
**
** Arguments:   [f_pszDest] Pointer to a buffer containing the string 
**                          that f_pszSrc is concatenated to, and which 
**                          contains the entire resultant string. The 
**                          string at f_pszSrc is added to the end of the 
**                          string at f_pszDest. 
**              [f_cchDest] Size of the destination buffer, in characters. 
**                          This value must equal the length of f_pszSrc 
**                          plus the length of f_pszDest plus 1 to account 
**                          for both strings and the terminating null character.
**                          The maximum number of characters allowed is 
**                          DRM_STRSAFE_MAX_CCH. 
**              [f_pszSrc]  Pointer to a buffer containing the source string 
**                          that is concatenated to the end of f_pszDest. This 
**                          source string must be null-terminated. 
**              [f_cchToAppend] The maximum number of characters to append 
**                              to f_pwszDest. 
**
** Returns:     DRM_SUCCESS
**                  Source data was present, the strings were fully concatenated 
**                  without truncation, and the resultant destination buffer is 
**                  null-terminated.
**              DRM_E_INVALIDARG
**                  The value in f_cchDest is 0 or larger than STRSAFE_MAX_CCH, or 
**                  the destination buffer is already full.
**              DRM_E_BUFFERTOOSMALL
**                  The concatenation operation failed due to insufficient buffer 
**                  space. The destination buffer contains a truncated, 
**                  null-terminated version of the intended result. Where 
**                  truncation is acceptable, this is not necessarily a failure 
**                  condition.
** 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCatNA
(   __out_ecount_z(f_cchDest)        DRM_CHAR  *f_pszDest,
    __in                             DRM_DWORD  f_cchDest,
    __in_ecount(f_cchToAppend) const DRM_CHAR  *f_pszSrc,
    __in                             DRM_DWORD  f_cchToAppend )

{   DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg( f_pszDest != NULL && f_cchDest <= DRM_STRSAFE_MAX_CCH && f_pszSrc != NULL );

    ChkDR( _DrmStringCatNWorkerA(f_pszDest, f_cchDest, f_pszSrc, f_cchToAppend) );
    
ErrorExit:
    return dr;
}

static DRM_CHAR _ByteValueToASCII( DRM_BYTE f_bVal )

{   
    DRM_CHAR chReturnValue = '?';
    
    /* Do not have valid ASCII representation for values more that 36. Return '?' as default */
    if ( f_bVal >= 36 )
    {  
        goto ErrorExit;
    }

    /* Base 10 digit */
    if ( f_bVal < 10 )
    {   
        chReturnValue = '0' + f_bVal;
    }
    else 
    {   
        /* Hex Symbol */
        chReturnValue = 'A' - 10 + f_bVal;
    }

ErrorExit :
    return chReturnValue;
}


/*****************************************************************************
** Function: DRM_STR_NumberToString
**
** Synopsis: express an unsigned long as a UNICODE string.  
**
** Arguments:
** [f_dwValue]      -- value to translate
** [f_pwszBuffer]   -- output buffer
** [f_cchBuffer]    -- output buffer size
** [f_dwPadZeros]   -- pad the buffer with 0s to specified length, or 0 for no padding
** [f_dwRadix]      -- use specified radix value, 10 for decimal
** [*f_pcchRLength] -- optional pointer to DWORD containing output size, 
**                     if the value is NULL then result size is not returned
**
** Notes:    - Output is NUL-terminated 
**           - Padding is from left side. Example: 1 -> 001, 0 -> 00
*****************************************************************************/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_STR_NumberToString(
    __in                          DRM_DWORD  f_dwValue, 
    __out_ecount_z( f_cchBuffer ) DRM_WCHAR *f_pwszBuffer, 
    __in                          DRM_DWORD  f_cchBuffer,
    __in                          DRM_DWORD  f_dwPadZeros,
    __in                          DRM_DWORD  f_dwRadix,
    __out_opt                     DRM_DWORD *f_pcchRLength )
{
    DRM_RESULT dr         = DRM_SUCCESS;
    DRM_WCHAR *pwszBuffer = f_pwszBuffer + (f_cchBuffer  - 1);   /* last digit at end of buffer */
    DRM_DWORD  cchOut     = 0;

    /* Check that the input buffer exists, large enough for data and NUL-terminator, and radix is valid */
    ChkArg( f_dwRadix > 1 && f_dwRadix < 36 );
    ChkArg( f_dwPadZeros < f_cchBuffer );
    ChkArg( f_pwszBuffer != NULL && f_cchBuffer > 1 )
    
    if ( f_pcchRLength != NULL ) 
    {
        *f_pcchRLength = 0;
    }

    /* Set NUL-terminators */ 
    *f_pwszBuffer = g_wchNull;
    *pwszBuffer-- = g_wchNull;
    cchOut++;
 
    if( f_dwValue == 0 )
    {
        *pwszBuffer-- = g_wch0;
        cchOut++;
    }
    else 
    {
        while( f_dwValue != 0 )
        {
            if ( pwszBuffer < f_pwszBuffer )
            {
               ChkDR( DRM_E_BUFFERTOOSMALL );
            }

            /* store the digit */
            *pwszBuffer-- = WCHAR_CAST(_ByteValueToASCII((DRM_BYTE)(f_dwValue % f_dwRadix))); 
            cchOut++;

            /* reduce number */
            f_dwValue /= f_dwRadix;
        }
    }    

    if( f_dwPadZeros > 0 )
    {
        while( pwszBuffer >= f_pwszBuffer && cchOut <= f_dwPadZeros ) 
        {
            /* add zeros before the number*/ 
            *pwszBuffer-- = g_wch0; 
            cchOut++;
        }
    }

    if ( f_pcchRLength != NULL ) 
    {
        /* Exclude NUL-terminator */ 
        *f_pcchRLength = (cchOut - 1);
    }

    /* Shift string to begin offset */
    DRM_BYT_MoveBytes(f_pwszBuffer, 0, pwszBuffer, 1, cchOut * SIZEOF (DRM_WCHAR)); 

ErrorExit:
    return dr; 
}


/**********************************************************************
** Function:    DRM_STR_StringCchPrintfExW_1
** 
** Synopsis:    This function is a replacement for sprintf. It accepts 
**              a format string and a list of arguments and returns a 
**              formatted string.
**              StringCchPrintfEx adds to the functionality of 
**              StringCchPrintf by returning a pointer to the end of 
**              the destination string, and by returning the number of 
**              characters left unused in that string. 
**              This version takes only a single format argument
**
** Arguments:   [f_pwszDest] Pointer to a buffer that receives the formatted,
**                           null-terminated string created from f_pwszFormat 
**                           and its arguments
**              [f_cchDest]  Size of the destination buffer, in characters. 
**                           This value must equal the length of f_pwszSrc 
**                           plus the length of f_pwszDest plus 1 to account 
**                           for both strings and the terminating null character.
**                           The maximum number of characters allowed is 
**                           DRM_STRSAFE_MAX_CCH. 
**              [f_ppwszDestEnd] Address of a pointer to the end of f_pwszDest. 
**                           If f_ppszDestEnd is non-NULL and data is copied 
**                           into the destination buffer, this points to the 
**                           terminating null character at the end of the string. 
**              [f_pcchRemaining] Pointer to a variable that indicates the number 
**                           of unused characters in f_pwszDest, including the 
**                           terminating null character. If f_pcchRemaining is NULL,
**                           the count is not kept or returned. 
**              [f_dwFlags]  For future expansion, currently should be 0.
**              [f_pwszFormat] Pointer to a buffer containing a printf-style 
**                           format string. This string must be null-terminated. 
**              [f_dwValue]  Argument to be inserted into f_pwszFormat
**
** Returns:     DRM_SUCCESS
**                  Source data was present, the strings were fully concatenated 
**                  without truncation, and the resultant destination buffer is 
**                  null-terminated.
**              DRM_E_INVALIDARG
**                  The value in f_cchDest is 0 or larger than STRSAFE_MAX_CCH, or 
**                  the destination buffer is already full.
**              DRM_E_BUFFERTOOSMALL
**                  The copy operation failed due to insufficient buffer 
**                  space. The destination buffer contains a truncated, 
**                  null-terminated version of the intended result. Where 
**                  truncation is acceptable, this is not necessarily a failure 
**                  condition.
** 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchPrintfExW_1
(   __out_ecount_z(f_cchDest)                DRM_WCHAR *f_pwszDest,
    __in                                     DRM_DWORD  f_cchDest,
    __deref_opt_out_ecount(*f_pcchRemaining) DRM_WCHAR**f_ppwszDestEnd,
    __out_opt                                DRM_DWORD *f_pcchRemaining,
    __in                                     DRM_DWORD  f_dwFlags,
    __in_z __format_string             const DRM_WCHAR *f_pwszFormat,
    __in                                     DRM_DWORD  f_dwValue )
{   DRM_RESULT dr       = DRM_SUCCESS;
    DRM_BOOL   fIsToken = FALSE;
    DRM_DWORD  dwTokensHit = 0;
    
    ChkArg( f_pwszDest != NULL );
    ChkArg( f_cchDest <= DRM_STRSAFE_MAX_CCH );
    ChkArg( f_pwszFormat != NULL );
    ChkArg( f_cchDest != 0 );

    while (f_cchDest && (*f_pwszFormat != g_wchNull))
    {
        if( *f_pwszFormat == WCHAR_CAST('%') )
        {
            if( !fIsToken )
            {
                fIsToken = TRUE;
                f_pwszFormat++;
                continue;
            }
            /* Double % means they're escaping a % */
            fIsToken = FALSE;
        }
        else if( fIsToken )
        {
            /* Only parse the first token */
            if( dwTokensHit < 1 )
            {
                DRM_WCHAR wcToken = *f_pwszFormat++;
                DRM_DWORD cchRet = 0;

                switch(wcToken)
                {
                    case WCHAR_CAST('d'):
                        ChkDR( DRM_STR_NumberToString( f_dwValue, f_pwszDest, f_cchDest, 0, 10, &cchRet ) );
                        f_cchDest -= cchRet;
                        f_pwszDest += cchRet;
                        break;

                    case WCHAR_CAST('x'):
                    case WCHAR_CAST('X'):
                        ChkDR( DRM_STR_NumberToString( f_dwValue, f_pwszDest, f_cchDest, 0, 16, &cchRet ) );
                        f_cchDest -= cchRet;
                        f_pwszDest += cchRet;
                        break;

                    default:
                        ChkArg( FALSE );
                }
                
                fIsToken = FALSE;
                dwTokensHit++;
                
                continue;
            }
            else
            {
                fIsToken = FALSE;
            }
        }

        *f_pwszDest++ = *f_pwszFormat++;
        f_cchDest--;
    }

    if (f_cchDest == 0)
    {
        /* we are going to truncate f_pwszDest */
        f_pwszDest--;
        dr = DRM_E_BUFFERTOOSMALL;
    }

    *f_pwszDest = g_wchNull;

    if( f_ppwszDestEnd != NULL )
    {
        *f_ppwszDestEnd = f_pwszDest;
    }

    if( f_pcchRemaining != NULL )
    {
        *f_pcchRemaining = f_cchDest;
    }
    
ErrorExit:
    return dr;
}


/**********************************************************************
** Function:    DRM_STR_StringCchPrintfW_1
** 
** Synopsis:    This function is a replacement for sprintf. It accepts 
**              a format string and a list of arguments and returns a 
**              formatted string.
**              This version takes only a single format argument
**
** Arguments:   [f_pwszDest] Pointer to a buffer that receives the formatted,
**                           null-terminated string created from f_pwszFormat 
**                           and its arguments
**              [f_cchDest]  Size of the destination buffer, in characters. 
**                           This value must equal the length of f_pwszSrc 
**                           plus the length of f_pwszDest plus 1 to account 
**                           for both strings and the terminating null character.
**                           The maximum number of characters allowed is 
**                           DRM_STRSAFE_MAX_CCH. 
**              [f_pwszFormat] Pointer to a buffer containing a printf-style 
**                           format string. This string must be null-terminated. 
**              [f_dwValue]  Argument to be inserted into f_pwszFormat
**
** Returns:     DRM_SUCCESS
**                  Source data was present, the strings were fully concatenated 
**                  without truncation, and the resultant destination buffer is 
**                  null-terminated.
**              DRM_E_INVALIDARG
**                  The value in f_cchDest is 0 or larger than STRSAFE_MAX_CCH, or 
**                  the destination buffer is already full.
**              DRM_E_BUFFERTOOSMALL
**                  The copy operation failed due to insufficient buffer 
**                  space. The destination buffer contains a truncated, 
**                  null-terminated version of the intended result. Where 
**                  truncation is acceptable, this is not necessarily a failure 
**                  condition.
** 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchPrintfW_1
(   __out_ecount_z(f_cchDest) DRM_WCHAR       *f_pwszDest,
    __in                      DRM_DWORD        f_cchDest,
    __in __format_string      DRM_WCHAR const *f_pwszFormat,
    __in                      DRM_DWORD        f_dwValue )
{
    return DRM_STR_StringCchPrintfExW_1( f_pwszDest, f_cchDest, NULL, NULL, 0, f_pwszFormat, f_dwValue );
}

/**********************************************************************
** Function:    DRM_STR_DstrCat
**
** Synopsis:    Concatenate a DRM string struct to the target DRM string struct
**
** Arguments:   [f_pdstrTarget]  -- target string
**              [f_pdstrAdd]     -- string to be added at the end
**              [f_cchTargetMax] -- maximum number of chars in the target DRM_STRING
**
** Notes:       None.
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_DstrCat(
    __inout    DRM_STRING       *f_pdstrTarget,
    __in const DRM_CONST_STRING *f_pdstrAdd,
    __in const DRM_DWORD         f_cchTargetMax )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pdstrTarget             != NULL
         && f_pdstrTarget->pwszString != NULL );
    
    ChkDRMString( f_pdstrAdd );

    ChkBOOL( (f_pdstrTarget->cchString + f_pdstrAdd->cchString) <= f_cchTargetMax, DRM_E_BUFFERTOOSMALL );

    ChkDR( DRM_STR_StringCchCatNW( f_pdstrTarget->pwszString, 
                            f_cchTargetMax, 
                            f_pdstrAdd->pwszString, 
                            f_pdstrAdd->cchString ) );
    
    /* adjust destination string length */
    f_pdstrTarget->cchString += f_pdstrAdd->cchString;

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_STR_StringCchToLower
**
** Synopsis:    Converts DRM string to lower case DRM string
**
** Arguments:   [f_pwszToLower] -- Pointer to a buffer that contains
**                                 wide character string to convert to lowercase
**              [f_cchToLower]  -- Size of string to convert 
**
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchToLower(
    __inout_ecount_nz(f_cchToLower) DRM_WCHAR *f_prgwchToLower,
    __in                            DRM_DWORD  f_cchToLower )
{
    DRM_RESULT dr          = DRM_SUCCESS;
    DRM_DWORD  dwCount     = 0;
    DRM_WCHAR *pwchCurrent = f_prgwchToLower;
    
    ChkArg( f_prgwchToLower!=NULL );
    
    for ( dwCount = 0; dwCount<f_cchToLower; dwCount++ )
    {
        *pwchCurrent = DRMCRT_towlower( *pwchCurrent );
        pwchCurrent++;
    }
        
ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_STR_DstrTowLower
**
** Synopsis:    Converts DRM string to lower case DRM string
**
** Arguments:   [f_pdstrToLower] -- DRM string to convert
**
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STR_DstrToLower(
    __inout DRM_STRING *f_pdstrToLower )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDRMString(f_pdstrToLower);

    ChkDR( DRM_STR_StringCchToLower( f_pdstrToLower->pwszString,
                                     f_pdstrToLower->cchString ) );
    
ErrorExit:
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmutilitieslite.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmxmlparser.h>
#include <drmrc4.h>
#include <byteorder.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

/*****************************************************************************
** Function: DRM_UTL_IsCertDateOK
**
** Synopsis: test whether a given date is before todays date.
**
** Arguments:
**   [f_pbDate]     -- date as a byte array
**   f_pbData [0] -- century, e.g. 20
**   f_pbData [1] -- year mod 100 e.g. 4
**   f_pbData [2] -- month, 1-based
**   f_pbData [3] -- day-of-month, 1-based
**
** Example: March 21, 2004 = |20|4|3|21|
**                            0  1 2 3
** Returns TRUE if the date is reasonable
*****************************************************************************/


DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL DRM_UTL_DateLessThan(
    IN const DRMFILETIME* f_pFileTime1, 
    IN const DRMFILETIME* f_pFileTime2)
{
    DRM_UINT64 u641;
    DRM_UINT64 u642;

    FILETIME_TO_UI64( *f_pFileTime1, u641 );
    FILETIME_TO_UI64( *f_pFileTime2, u642 );
    return DRM_UI64Les( u641, u642);
}


static DRM_NO_INLINE DRM_BOOL HexStringToDword(
    IN const DRM_WCHAR *f_pwsz,
       OUT   DRM_DWORD *f_pdwValue,
    IN       DRM_INT    f_cDigits)
{
    DRM_INT  iDigit;    
    DRM_BOOL fOK = TRUE;
    DRM_DWORD dwValue = 0;
    
    *f_pdwValue = 0;
    
    for (iDigit = 0; 
         iDigit < f_cDigits; 
         iDigit++)
    {
        dwValue <<= 4;
        if( NATIVE_WCHAR(f_pwsz[iDigit]) >= NATIVE_WCHAR(g_wch0) 
         && NATIVE_WCHAR(f_pwsz[iDigit]) <= NATIVE_WCHAR(g_wch9))
        {
            dwValue += NATIVE_WCHAR(f_pwsz[iDigit]) - NATIVE_WCHAR(g_wch0);
        }
        else if( NATIVE_WCHAR(f_pwsz[iDigit]) >= NATIVE_WCHAR(g_wchA)
              && NATIVE_WCHAR(f_pwsz[iDigit]) <= NATIVE_WCHAR(g_wchF) )
        {
            
            dwValue += NATIVE_WCHAR(f_pwsz[iDigit]) - NATIVE_WCHAR(g_wchA) + 10;            
        }
        else if( NATIVE_WCHAR(f_pwsz[iDigit]) >= NATIVE_WCHAR(g_wcha) 
              && NATIVE_WCHAR(f_pwsz[iDigit]) <= NATIVE_WCHAR(g_wchf) )
        {
            dwValue += NATIVE_WCHAR(f_pwsz[iDigit]) - NATIVE_WCHAR(g_wcha) + 10;
        }
        else
        {
            /* Reverse the shift operation if all the range checks failed */
            dwValue >>= 4;
            fOK = FALSE;
        }
    }
    
    MEMCPY( f_pdwValue, &dwValue, SIZEOF( dwValue ) );

    return fOK;
}

/*****************************************************************************
** Function: DRM_UTL_GetVersionAsString
**
** Synopsis: express n version binary as a base10 dotted UNICODE string.  
**
** Arguments:
** [f_rgbVersion]   -- version as binary
** [f_wszVerString] -- output buffer
**
** Returns string length
**
** Notes:    Output is NUL-terminated 
*****************************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_UTL_GetVersionAsString(
    __in_bcount( VERSION_LEN ) DRM_BYTE  f_rgbVersion   [__CB_DECL(VERSION_LEN)],
    __out_ecount( VER_STRING_MAX_LEN ) DRM_WCHAR f_wszVerString [VER_STRING_MAX_LEN])
{
    DRM_RESULT dr      = DRM_SUCCESS;
    DRM_INT    ich     = 0;
    DRM_INT    ib      = 0;
    DRM_DWORD  cchTemp = 0;
    
    /* 
    ** (VER_STRING_MAX_LEN - 4) / VERSION_LEN :
    ** This is 4 characters for the 3 periods and the NULL terminator.
    ** We divide by VERSION_LEN because we have to perform the operation VERSION_LEN times
    ** and give an equal buffer size to each operation
    **
    ** ich <= (VER_STRING_MAX_LEN-(VER_STRING_MAX_LEN/VERSION_LEN)) :
    ** This is to ensure that there is enough room for the last segment of the version
    */
       
    for (ib = 0; (ib < VERSION_LEN) && (ich <= (VER_STRING_MAX_LEN-(VER_STRING_MAX_LEN/VERSION_LEN))); ib++)
    {
        ChkDR( DRM_STR_NumberToString( GET_BYTE(f_rgbVersion, ib), 
                                       &f_wszVerString[ich], 
                                       (VER_STRING_MAX_LEN - 4) / VERSION_LEN + 1,
                                       0, 10, &cchTemp) );
        ich += cchTemp;

        if (ich < VER_STRING_MAX_LEN)
        {
            f_wszVerString [ich++] = g_wchPeriod;
        }
        else
        {
            ich = VER_STRING_MAX_LEN;
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }
    }

    /* Check to see if we fell out of the loop because of the second loop condition */
    if ((ib < VERSION_LEN) && (ich > (VER_STRING_MAX_LEN-(VER_STRING_MAX_LEN/VERSION_LEN))))
    {
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }
    
    /* Overwrite that last g_wchPeriod with the NULL terminator */
    f_wszVerString [ich-1] = g_wchNull;

ErrorExit:
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_UTL_GetVersionFromString(
   __in_ecount( cchVersion ) const DRM_WCHAR  *pwszVersion,
   IN       DRM_DWORD   cchVersion,
   __out_ecount( VERSION_LEN ) DRM_WORD rgwVersion[VERSION_LEN] )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_UINT uVer[VERSION_LEN];
    DRM_DWORD iCount = 0;
    DRM_DWORD ich = 0;
    
    for( iCount = 0; iCount < VERSION_LEN - 1; iCount++ )
    {
        ich = 0;
        while( ich < cchVersion )
        {
            if( pwszVersion[ich] == g_wchPeriod )
            {
                break;
            }
            ich++;
        }
        
        if ( ich == cchVersion)
        {
            ChkDR( CPRMEXP_INVALID_ARGUMENT );
        }
        
        if( pwszVersion[ich] != g_wchPeriod                                        /* Didn't find a . seperator */
         || DRM_FAILED( DRMCRT_wcsntol( pwszVersion, ich, (DRM_LONG *) &uVer [iCount] ) ) /* Couldn't extract a number */
         || uVer[iCount]     != (DRM_WORD) uVer[iCount] )                          /* Not in a valid range      */
        {
            ChkDR( CPRMEXP_INVALID_ARGUMENT );
        }

        cchVersion -= (ich+1);
        pwszVersion = pwszVersion + (ich + 1);
    }

    if( DRM_FAILED( DRMCRT_wcsntol( pwszVersion, cchVersion, (DRM_LONG *) &uVer [iCount] ) ) /* Couldn't extract a number */
     || uVer[iCount] != (DRM_WORD) uVer[iCount] )                                     /* Not in a valid range      */
    {
        ChkDR( CPRMEXP_INVALID_ARGUMENT );
    }

    for( iCount = 0; iCount < VERSION_LEN; iCount++ )
    {
        rgwVersion[iCount] = (DRM_WORD)uVer[iCount];
    }
    
ErrorExit:
        
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_UTL_StringToGuid(
    IN const DRM_CONST_STRING *pdstrString,
    OUT      DRM_GUID         *pGuid)
{
    DRM_RESULT dr      = DRM_SUCCESS;
    DRM_DWORD  dwValue = 0;
    DRM_INT ib;

    ChkArg(pdstrString != NULL 
        && pGuid       != NULL 
        && pdstrString->pwszString != NULL 
        && pdstrString->cchString  == DRM_GUID_STRING_LEN); /* 38 characters in a proper Guid String - including { } */

    ChkArg(pdstrString->pwszString [0]  == g_wchOpenCurly 
        && pdstrString->pwszString [37] == g_wchCloseCurly); /* First and last char must be { & } */

    /* Validate the delimitar characters */

    if (pdstrString->pwszString [9]  != g_wchMinus 
     || pdstrString->pwszString [14] != g_wchMinus 
     || pdstrString->pwszString [19] != g_wchMinus 
     || pdstrString->pwszString [24] != g_wchMinus)
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    /* Convert pieces to BYTES */
    
    if (! HexStringToDword(pdstrString->pwszString + 1, &pGuid->Data1, 8))
    {
        ChkDR(DRM_E_INVALIDARG);
    }
    if (! HexStringToDword(pdstrString->pwszString + 10, &dwValue, 4))
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    pGuid->Data2 = (DRM_SHORT) dwValue;

    if (! HexStringToDword(pdstrString->pwszString + 15, &dwValue, 4))
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    pGuid->Data3 = (DRM_SHORT) dwValue;

    if (! HexStringToDword(pdstrString->pwszString + 20, &dwValue, 2))
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    PUT_BYTE(pGuid->Data4, 0, (DRM_BYTE) dwValue);

    if (! HexStringToDword(pdstrString->pwszString + 22, &dwValue, 2))
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    PUT_BYTE(pGuid->Data4, 1, (DRM_BYTE) dwValue);

    for (ib = 2; ib < 8; ib++)
    {
        if (! HexStringToDword(pdstrString->pwszString  + (((ib - 1) * 2) + 23), &dwValue, 2))
        {
            ChkDR(DRM_E_INVALIDARG);
        }

        PUT_BYTE(pGuid->Data4,ib, (DRM_BYTE) dwValue);
    }
    
    FIX_ENDIAN_DWORD( pGuid->Data1 );
    FIX_ENDIAN_WORD(  pGuid->Data2 );
    FIX_ENDIAN_WORD(  pGuid->Data3 );

    /* We have validated the string && now the bits are converted. */
ErrorExit:
    return dr;
}

DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL DRM_UTL_DASSSTRStringsEqual(
    __in_ecount( f_pdasstr0->m_ich + f_pdasstr0->m_cch ) const DRM_CHAR *f_pszBase0,
    const DRM_SUBSTRING *f_pdasstr0,
    __in_ecount( f_pdasstr1->m_ich + f_pdasstr1->m_cch ) const DRM_CHAR *f_pszBase1,
    const DRM_SUBSTRING *f_pdasstr1)
{
    return (f_pdasstr0->m_cch == f_pdasstr1->m_cch
        &&  DRM_BYT_CompareBytes(f_pszBase0, 
                                 f_pdasstr0->m_ich, 
                                 f_pszBase1, 
                                 f_pdasstr1->m_ich,
                                 f_pdasstr1->m_cch) == 0);
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_UTL_GuidToString
( 
    IN                                    const  DRM_GUID  *pGuid, 
        __out_ecount(DRM_GUID_STRING_LEN)        DRM_WCHAR  rgwszString[DRM_GUID_STRING_LEN]
)
{
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_DWORD  dwCount   = 0;
    DRM_DWORD  cchString = 0;
    /* OACR complains if datais written directly to rgwszString.
    ** Need local string of larger size
    */    
    DRM_WCHAR  rgwszLocalString[DRM_GUID_STRING_LEN + 1] = {0};
    
    ChkArg(  pGuid != NULL && rgwszString != NULL );
    
    
    /* Buffer is large enough, we put the data.*/
    rgwszLocalString[cchString++] = g_wchOpenCurly;    
    
    /* First DWORD */
    ChkDR( DRM_STR_NumberToString( pGuid->Data1, rgwszLocalString + cchString, NO_OF(rgwszLocalString) - cchString, DRM_MAX_CCH_BASE16_DWORD_STRING, 16, NULL ) );
    cchString += 8;
    /* - */
    rgwszLocalString[cchString] = g_wchMinus;
    cchString += 1;
    
    /* WORD 2 */
    ChkDR( DRM_STR_NumberToString( pGuid->Data2, rgwszLocalString + cchString, NO_OF(rgwszLocalString) - cchString, DRM_MAX_CCH_BASE16_WORD_STRING, 16, NULL ) );
    cchString += 4;
    /* - */
    rgwszLocalString[cchString] = g_wchMinus;
    cchString += 1;
    
    /* WORD 3 */
    ChkDR( DRM_STR_NumberToString( pGuid->Data3, rgwszLocalString + cchString, NO_OF(rgwszLocalString) - cchString, DRM_MAX_CCH_BASE16_WORD_STRING, 16, NULL ) );
    cchString += 4;
    /* - */
    rgwszLocalString[cchString] = g_wchMinus;
    cchString += 1;
    
    /* byte array 2 */
    for ( dwCount = 0;  dwCount < 2;  dwCount++ )
    {   
        DRM_BYTE bVal = GET_BYTE( pGuid->Data4, dwCount );
        ChkDR( DRM_STR_NumberToString( bVal, rgwszLocalString + cchString, NO_OF(rgwszLocalString) - cchString, 2, 16, NULL ) );
        cchString += 2;
    }
    /* - */
    rgwszLocalString[cchString] = g_wchMinus;
    cchString += 1;
    
    /* byte array 6 */
    for ( dwCount = 2;  dwCount < 8;  dwCount++ )
    {   
        DRM_BYTE bVal = GET_BYTE( pGuid->Data4, dwCount );
        ChkDR( DRM_STR_NumberToString( bVal, rgwszLocalString + cchString, NO_OF(rgwszLocalString) - cchString, DRM_MAX_CCH_BASE16_BYTE_STRING, 16, NULL ) );
        cchString += 2;
    }
    
    /* } */
    rgwszLocalString[cchString] = g_wchCloseCurly; 
    cchString += 1;

    /* Copy data to original string
    */
    MEMCPY( rgwszString, rgwszLocalString, cchString * SIZEOF( DRM_WCHAR ) );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    PKEncryptLarge
**
** Synopsis:    Encrypt large amoutn of data (using PKEncrypt with large data is slow, this is fast)
**
** Arguments:   [f_ppubkey]        -- Caller supplied public key to encrypt with
**              [f_pbClear]        -- Array of bytes to encrypt
**              [f_cbClear]        -- Length ob f_pbClear in bytes
**              [f_pbCipher]       -- Buffer to hold encrypted data
**              [f_cbKeySymmetric] -- Desired length of internal symmertic key to be created
**              [f_pcontextCRYP]   -- A DRM_CRYPTO_CONTEXT so PKCrypto operations can be performed.
**
** Notes:       out must be of length f_cbClear + DRM_ECC160_CIPHERTEXT_LEN
**              Internally a rc4 symmetric key will be created to encrypt the content (because it's fast) &
**              that symmertic key will be encrypted with the PUBKEY.
**              In place encryption is possible if f_pbCipher equals to f_pbClear.
***********************************************************************/


/**********************************************************************
** Function:    DRM_UTL_StringInsertBlankSubString
**
** Synopsis:    Insert blanks to a target string at specific insertion point
**
** Arguments:   [f_pdstrTarget]  -- target string
**              [f_ichInsertion] -- insertion position of target string: index of f_pwsz.
**              [f_cch]          -- # of blank char to insert
**
** Notes:       
** - Caller is responsible to make sure there is enough room in target string.
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_UTL_StringInsertBlankSubString(
    IN OUT DRM_STRING *f_pdstrTarget,
    IN     DRM_DWORD   f_ichInsertion,
    IN     DRM_DWORD   f_cch)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cchToMove     = 0;
    DRM_DWORD  ich           = 0;

    ChkDRMString(f_pdstrTarget);
    ChkArg(f_ichInsertion <= f_pdstrTarget->cchString);

    cchToMove = f_pdstrTarget->cchString - f_ichInsertion;
    
    MEMMOVE(&f_pdstrTarget->pwszString[f_ichInsertion+f_cch],
            &f_pdstrTarget->pwszString[f_ichInsertion], 
            cchToMove*SIZEOF(DRM_WCHAR));

    /* fill the hole in the blanks */
    for (ich=0; ich<f_cch; ich++)
    {
        f_pdstrTarget->pwszString[f_ichInsertion+ich] = g_wchSpace;
    }

    /* adjust destination string length */
    f_pdstrTarget->cchString += f_cch;

ErrorExit:
    return dr;
}

/**********************************************************************
**
** Function:    DRM_UTL_StringInsertBlankSubStringA
**
** Synopsis:    Insert blanks to a target string at specific insertion point.
**
** Arguments:
**
** [f_pdastrTarget]              -- Pointer to a target DRM ANSI string.
** [f_ichInsertion]              -- Insertion position of target string.
** [f_cch]                       -- Number of blank characters to insert.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Notes:                   Caller is responsible to make sure there is enough
**                          room in target string.
**
***********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_UTL_StringInsertBlankSubStringA(
    IN OUT DRM_ANSI_STRING *f_pdastrTarget,
    IN DRM_DWORD f_ichInsertion,
    IN DRM_DWORD f_cch )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchToMove = 0;
    DRM_DWORD ich = 0;

    ChkDRMANSIString( f_pdastrTarget );
    ChkArg( f_ichInsertion <= f_pdastrTarget->cchString );

    cchToMove = f_pdastrTarget->cchString - f_ichInsertion;
    
    MEMMOVE( &f_pdastrTarget->pszString[ f_ichInsertion + f_cch ],
             &f_pdastrTarget->pszString[ f_ichInsertion ], 
             cchToMove );

    /* Fill the hole with blanks. */
    for ( ich = 0; ich < f_cch; ich++ )
    {
        PUT_CHAR( f_pdastrTarget->pszString, f_ichInsertion + ich, ' ' );
    }

    /* Adjust the length of the target string. */
    f_pdastrTarget->cchString += f_cch;

ErrorExit:
    
    return dr;
}

/**********************************************************************
** Function:    DRM_UTL_StringInsertSubString
**
** Synopsis:    Insert a substring to a target string at specific insertion point
**
** Arguments:   [f_pdstrTarget]  -- target string
**              [f_ichInsertion] -- insertion position of target string: index of f_pwsz.
**              [f_pdstrSub]     -- sub string to be inserted
**
** Notes:       
** - Caller is responsible to make sure there is enough room in target string.
***********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_UTL_StringInsertSubString(
    IN OUT   DRM_STRING       *f_pdstrTarget,
    IN       DRM_DWORD         f_ichInsertion,
    IN const DRM_CONST_STRING *f_pdstrSub)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDRMString(f_pdstrTarget);
    ChkDRMString(f_pdstrSub);
    ChkArg(f_ichInsertion <= f_pdstrTarget->cchString);

    ChkDR(DRM_UTL_StringInsertBlankSubString(f_pdstrTarget, f_ichInsertion, f_pdstrSub->cchString));

    /* copy the source string to target point */
    MEMCPY( (DRM_BYTE *) (f_pdstrTarget->pwszString + f_ichInsertion),
            PB_DSTR(f_pdstrSub), 
            CB_DSTR(f_pdstrSub));

ErrorExit:
    return dr;
}



/**********************************************************************
** Function:    DRM_UTL_StringRemoveSubString
** Synopsis:    remove a substring from the target string
** Arguments:   [f_pdstrSource] -- Source string
**              [f_pdstrSub]    -- A substring within f_pdstrSource
** Notes:       
** - Caller is responsible for sufficient buffer in destination string
***********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_UTL_StringRemoveSubString(
    IN OUT   DRM_STRING       *f_pdstrSource,
    IN const DRM_CONST_STRING *f_pdstrSub)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cchToMove = 0;
    DRM_DWORD  ich       = 0;
    DRM_WCHAR *pwsz       = NULL;

    ChkDRMString(f_pdstrSource);
    if ( f_pdstrSub             == NULL 
      || f_pdstrSub->pwszString == NULL 
      || f_pdstrSub->cchString  == 0 )
    {
        goto ErrorExit;
    }

    /* make sure f_pdstrSub is within f_pdstrSource */
    ChkArg(f_pdstrSource->pwszString <= f_pdstrSub->pwszString);
     
    ChkArg((f_pdstrSub->pwszString    + f_pdstrSub->cchString) 
        <= (f_pdstrSource->pwszString + f_pdstrSource->cchString));
    
    cchToMove = f_pdstrSource->cchString 
              - f_pdstrSub->cchString 
              - (DRM_DWORD)(f_pdstrSub->pwszString 
              - f_pdstrSource->pwszString);

    /* move the rest of the string to cover the hole.
    ** alternative way: use memmove().
    */
    
    pwsz = (DRM_WCHAR *) f_pdstrSub->pwszString;
    
    for (ich = cchToMove; 
         ich > 0; 
         ich--)
    {
        *pwsz = pwsz [f_pdstrSub->cchString];
        pwsz++;
    }

    /* adjust string length */
    f_pdstrSource->cchString -= f_pdstrSub->cchString;

ErrorExit:
    return dr;
}

/*****************************************************************************
** Function : DRM_UTL_DSTRStringsEqual
**            DRM_UTL_DASTRStringsEqual
**
** Synopsis: case-sensitive comparison of two DRM_CONST_STRINGs or 
**           DRM_ANSI_CONST_STRINGs
**
** Arguments:
** [f_pdstr1]
** [f_pdstr2] -- strings to compare
**
** Return: TRUE if strings are same length and identical
**
** Note: No argument checking; make sure you pass valid strings
*****************************************************************************/

DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL DRM_UTL_DSTRStringsEqual(
    const DRM_CONST_STRING *pdstr1,
    const DRM_CONST_STRING *pdstr2)
{
    return (pdstr1->cchString == pdstr2->cchString
        &&  DRMCRT_wcsncmp(pdstr1->pwszString, pdstr2->pwszString, pdstr1->cchString) == 0);
}

DRM_API DRM_BOOL DRM_CALL DRM_UTL_DASTRStringsEqual(
    const DRM_ANSI_CONST_STRING *f_pdastr1,
    const DRM_ANSI_CONST_STRING *f_pdastr2)
{
    return (f_pdastr1->cchString == f_pdastr2->cchString
        &&  DRMCRT_strncmp(f_pdastr1->pszString, f_pdastr2->pszString, f_pdastr1->cchString) == 0);
}

/*****************************************************************************
** Function : DRM_UTL_DASSTRStringsEqual
**
** Synopsis: case-sensitive comparison of an ANSI substring with a
**           DRM_ANSI_CONST_STRING
** Arguments:
** [f_pszBase] -- base of buffer into which f_pdasstr is an offset
** [f_pdasstr] -- substring of f_pszBase to compare
** [f_pdastr]  -- constant or literal string to compare
**
** Return: TRUE if strings are same length and identical
**
** Note: No argument checking; make sure you pass valid strings
*****************************************************************************/

DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL DRM_UTL_DASSTRStringsEqual(
    __in_ecount( f_pdasstr->m_ich + f_pdasstr->m_cch ) const DRM_CHAR *f_pszBase,
    const DRM_SUBSTRING         *f_pdasstr,
    const DRM_ANSI_CONST_STRING *f_pdastr)
{
    return (f_pdasstr->m_cch  == f_pdastr->cchString
        &&  DRM_BYT_CompareBytes(f_pszBase, 
                                 f_pdasstr->m_ich, 
                                 f_pdastr->pszString, 
                                 0, 
                                 f_pdasstr->m_cch) == 0);
}

/*****************************************************************************
** Function : DRM_UTL_DASSTRStrings_CI_Equal
**
** Synopsis: case-INsensitive comparison of an ANSI substring with a
**           DRM_ANSI_CONST_STRING
** Arguments:
** [f_pszBase] -- base of buffer into which f_pdasstr is an offset
** [f_pdasstr] -- substring of f_pszBase to compare
** [f_pdastr]  -- constant or literal string to compare
**
** Return: TRUE if strings are same length and identical
**
** Note: No argument checking; make sure you pass valid strings
*****************************************************************************/
DRM_API DRM_BOOL DRM_CALL DRM_UTL_DASSTRStrings_CI_Equal(
    __in_ecount( f_pdasstr->m_ich + f_pdasstr->m_cch ) const DRM_CHAR      *f_pszBase,
    const DRM_SUBSTRING *f_pdasstr,
    const DRM_ANSI_CONST_STRING *f_pdastr )
{
    if( f_pdasstr->m_cch != f_pdastr->cchString )
    {
        return FALSE;
    }
    else
    {
        DRM_DWORD i;

        for( i=0; i<f_pdasstr->m_cch; i++ )
        {
            if( DRMCRT_towlower( WCHAR_CAST( GET_BYTE( f_pszBase, f_pdasstr->m_ich + i ) ) )
	        != DRMCRT_towlower( WCHAR_CAST( GET_BYTE( f_pdastr->pszString, i ) ) ) )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

/**********************************************************************
** Function:    DRM_UTL_EnsureDataAlignment
**
** Synopsis:    return a pointer aligned on the specified data boundary
**
** Arguments:   [f_pbOriginal] -- original pointer, potentially misaligned
**              [f_cbOriginal] -- maximum size of f_pbOriginal
**              [f_ppbAligned] -- filled in with adjusted pointer
**              [f_pcbAligned] -- adjusted size, <= f_cbOriginal
**              [f_cbDataType] -- SIZEOF data type to align
**
** Notes:       address is moved forward from the original to the next
**              aligned boundary
***********************************************************************/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_UTL_EnsureDataAlignment(
    __in_bcount( f_cbOriginal )IN  const DRM_BYTE *f_pbOriginal,
    IN  const DRM_DWORD   f_cbOriginal,
    __deref_out_bcount( *f_pcbAligned ) DRM_BYTE **f_ppbAligned,
    OUT       DRM_DWORD  *f_pcbAligned,
    IN  const DRM_DWORD   f_cbDataType,
    OUT       DRM_DWORD  *f_pcbAdjustment)
{
    DRM_RESULT      dr         = DRM_SUCCESS;
    DRM_DWORD_PTR   pvOriginal = (DRM_DWORD_PTR) f_pbOriginal;
    DRM_DWORD       cbScrap    = 0;
    DRM_DWORD       cbAdjust   = 0;

    ChkArg (f_pbOriginal != NULL
        &&  f_cbOriginal  > 0
        &&  f_ppbAligned != NULL
        &&  f_pcbAligned != NULL
        &&  f_cbDataType >= 1);

    /* e.g. for a DWORD on an 4n + 1 address, cbScrap = 1 */
        
    cbScrap  = (DRM_DWORD) (pvOriginal % (f_cbDataType / CB_NATIVE_BYTE));

    /* e.g. for a DWORD on an 4n + 1 address, cbAdjust = 3 */
        
    if (cbScrap > 0)        
    {
        cbAdjust = (DRM_DWORD) ((f_cbDataType / CB_NATIVE_BYTE) - cbScrap);
    }
    
    /* check to see if it's already aligned */
        
    if (cbScrap == 0)
    {
        *f_ppbAligned = (DRM_BYTE*)f_pbOriginal;
        *f_pcbAligned = f_cbOriginal;
    }
    else
    {
        /* verify that an adjusted pointer won't straddle the boundary */
        
        if ((f_cbDataType + cbAdjust) < f_cbOriginal)
        {
            *f_ppbAligned = (DRM_BYTE *) (pvOriginal) + (DRM_WORD) cbAdjust;
            *f_pcbAligned =  f_cbOriginal - cbAdjust;
        }
        else
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }
    }

    if (f_pcbAdjustment != NULL)
    {
        *f_pcbAdjustment = cbAdjust;
    }
    
ErrorExit:    
    return dr;
} /* DRM_UTL_EnsureDataAlignment */

/*********************************************************************
**
**  Function:  DRM_UTL_DecodeKID
**
**  Synopsis:  Decode a KID value.  In general it just performs a Base64 decode but
**             also takes into account the possibility that a header or license
**             may technically have an invalid KID in it (wrong size) and we need
**             to work with it correctly.
**
**  Arguments:  
**     [f_pdstrKID] -- String representation of the KID
**     [f_pkid]     -- Binary KID will be copied to this out buffer.
**
**  Notes:     KIDs should really be 24 characters long when encoded but
**             some licenses and content have these strings incorrectly set
**             so this function compensates for that possiblity.
**
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_UTL_DecodeKID( 
    IN const DRM_CONST_STRING *f_pdstrKID, 
       OUT   DRM_KID          *f_pkid )
{    
    DRM_RESULT          dr      = DRM_SUCCESS;
    DRM_CONST_STRING    dstrKID = EMPTY_DRM_STRING;
    DRM_DWORD           cb      = SIZEOF(DRM_KID);
    DRM_WCHAR           wszKID[ CCH_BASE64_EQUIV(SIZEOF(DRM_KID)) + 1 ];
    DRM_DWORD           cchKID  = NO_OF( wszKID ) - 1 ;

   
    /* If count of characters in the string is less than cchKID ( 24 )
    ** The we prepend the caracters in the string with '*'
    */
    
    
    if ( f_pdstrKID->cchString <= cchKID )
    {
        DRM_DWORD cchDiff  = cchKID - f_pdstrKID->cchString;
        dstrKID.pwszString = wszKID, 
        dstrKID.cchString  = cchKID;

        for( cb = 0; cb < cchDiff; cb++ )
        {
            wszKID[cb] = g_wchAsterisk;
        }
    
        ChkDR( DRM_STR_StringCchCopyNW( wszKID + cchDiff,
                                   NO_OF( wszKID ) - cchDiff,
                                   f_pdstrKID->pwszString,
                                   f_pdstrKID->cchString ) );

        cb = SIZEOF( DRM_KID );
        dr = DRM_B64_DecodeW( &dstrKID, &cb, (DRM_BYTE*)f_pkid, 0 );    
    }
    else
    {
        dstrKID.pwszString = f_pdstrKID->pwszString, 
        dstrKID.cchString  = f_pdstrKID->cchString;
    }
    
    
    if (   DRM_FAILED( dr ) 
        || f_pdstrKID->cchString > cchKID )
    {                        
        /*
        **  Bad KID - Let's just take the first 16 bytes from original ANSI KID
        */ 
        DRM_DWORD   iKID = 0;        
       
        /*
        **  Now convert it ansi - Note we cannot use DRM_UTL_DemoteUNICODEtoASCII
        **  here because we are writing to DRM_KID directly instead of a string
        **  So we do not want the trailing '\0'
        **  We need to remember that dstrKID.pwszString may have prepended with '*'
        **  We copy last 16 characters from dstrKID.pwszString to ensure that all
        **  significant characters from f_pdstrKID were used.
        */        
        while( iKID < DRM_ID_SIZE )
        {
            /*
            **  Test if string was prepended with '*'. Then take last 16 characters to preserve data in f_pdstrKID.
            **  Otherwize take first 16. 
            */           
            
            if ( f_pdstrKID->cchString <= NO_OF( wszKID ) - 1 )
            {
                PUT_BYTE( f_pkid->rgb, iKID, (DRM_CHAR)NATIVE_WCHAR(dstrKID.pwszString[iKID + (dstrKID.cchString - DRM_ID_SIZE)]) );
            }
            else
            {   
                PUT_BYTE( f_pkid->rgb, iKID, (DRM_CHAR)NATIVE_WCHAR(dstrKID.pwszString[iKID]) );
            }
            iKID++;
        } 
        dr = DRM_SUCCESS;
    }

ErrorExit:
    return dr;
}

/*****************************************************************************
** Function: DRM_UTL_PromoteASCIItoUNICODE
**
** Synopsis: copies an ASCII ANSI string to wide-ASCII
**
** Arguments:
** [f_pszBase]  -- Base pointer to ANSI original string
** [f_pdasstr]  -- Pointer to substring specification (within f_pszBase)
** [f_pdstrOut] -- UNICODE copy
*****************************************************************************/

/* This function exists to allow for SAL annotation of DRM_STRING elements */
DRM_API DRM_NO_INLINE DRM_VOID DRM_CALL _promoteASCIItoUNICODE(
    const                DRM_CHAR      *f_pszBase,
    const                DRM_SUBSTRING *f_pdasstr,
    __out_ecount(f_cch)  DRM_WCHAR     *f_pwszString,
    const                DRM_DWORD      f_cch)
{
    DRM_DWORD ich = 0;
 
    for (ich = 0; ich < f_cch; ich++)
    {
        f_pwszString [ich] = WCHAR_CAST(GET_CHAR(f_pszBase, f_pdasstr->m_ich + ich));
    }

}

DRM_API DRM_NO_INLINE DRM_VOID DRM_CALL DRM_UTL_PromoteASCIItoUNICODE(
    __in_ecount( f_pdasstr->m_ich + f_pdasstr->m_cch ) const DRM_CHAR      *f_pszBase,
    const DRM_SUBSTRING *f_pdasstr, 
          DRM_STRING    *f_pdstrOut)
{
    DRM_DWORD cch = min(f_pdasstr->m_cch, f_pdstrOut->cchString); 

    _promoteASCIItoUNICODE(f_pszBase, f_pdasstr, f_pdstrOut->pwszString, cch);
    
    f_pdstrOut->cchString = cch;
}
    
DRM_API DRM_NO_INLINE DRM_VOID DRM_CALL DRM_UTL_DemoteUNICODEtoASCII( 
    __in_ecount(cchMax) const DRM_WCHAR *pwszFileName, 
    __out_ecount(cchMax) DRM_CHAR  *pszFileName, 
                         DRM_DWORD  cchMax )
{
    DRM_DWORD ich = 0;

    while( cchMax                           > 0 &&
           NATIVE_WCHAR(pwszFileName[ich]) != g_wchNull )

    {
        PUT_BYTE( pszFileName, ich, (DRM_CHAR)NATIVE_WCHAR(pwszFileName[ich]) );
        cchMax--;
        ich++;
    }
    
    if( cchMax > 0 )
    {
        /* NULL terminate if there is room */
        PUT_BYTE(pszFileName, ich, '\0');
    }
}


DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL DRM_UTL_DSTRSearch( 
    IN const DRM_CONST_STRING *f_pdstrString,
    IN const DRM_CONST_STRING *f_pdstrSubString,
       OUT   DRM_CONST_STRING *f_pdstrFoundString )
{
    DRM_RESULT       dr            = DRM_SUCCESS;
    DRM_CONST_STRING dstrString    = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrSubString = EMPTY_DRM_STRING;

    /*
    ** NOTE:  All dr's in this function are meaningless.
    ** They will be masked before return into a TRUE/FALSE
    ** return value.
    */
    ChkArg( f_pdstrFoundString != NULL );

    ChkDRMString( f_pdstrString );
    ChkDRMString( f_pdstrSubString );

    dstrString    = *f_pdstrString;
    dstrSubString = *f_pdstrSubString;
    
    while( dstrString.cchString >= dstrSubString.cchString )
    {
        DRM_DWORD ich = 0;

        while( ich                        <  dstrSubString.cchString
            && dstrString.pwszString[ich] == dstrSubString.pwszString[ich] )
        {
            ich++;
        }

        if( ich == dstrSubString.cchString )
        {
            /* 
            ** We looped through all the characters in dstrSubString
            ** so there must have been a match 
            */

            *f_pdstrFoundString = dstrString;
            goto ErrorExit;
        }

        dstrString.cchString--;
        dstrString.pwszString++;
    }

    dr = DRM_E_FAIL;

ErrorExit:

    if( DRM_FAILED( dr ) )
    {
        return FALSE;
    }
    return TRUE;    
}

DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL DRM_UTL_DSTRSearchReverse( 
    IN const DRM_CONST_STRING *f_pdstrString,
    IN const DRM_CONST_STRING *f_pdstrSubString,
       OUT   DRM_CONST_STRING *f_pdstrFoundString )
{
    DRM_RESULT       dr            = DRM_SUCCESS;
    DRM_CONST_STRING dstrString    = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrSubString = EMPTY_DRM_STRING;

    /*
    ** NOTE:  All dr's in this function are meaningless.
    ** They will be masked before return into a TRUE/FALSE
    ** return value.
    */

    ChkArg( f_pdstrFoundString != NULL );

    ChkDRMString( f_pdstrString );
    ChkDRMString( f_pdstrSubString );

    dstrString    = *f_pdstrString;
    dstrSubString = *f_pdstrSubString;
    
    if( dstrSubString.cchString == 0 )
    {
        *f_pdstrFoundString = dstrString;
        goto ErrorExit;
    }

    if( dstrString.cchString < dstrSubString.cchString )
    {
        ChkDR( DRM_E_INVALIDARG );
    }
    
    dstrString.pwszString += (f_pdstrString->cchString - dstrSubString.cchString);
    dstrString.cchString   =  dstrSubString.cchString;
    
    while( dstrString.cchString <= f_pdstrString->cchString )
    {
        DRM_DWORD ich = 0;

        while( ich                        <  dstrSubString.cchString
            && dstrString.pwszString[ich] == dstrSubString.pwszString[ich] )
        {
            ich++;
        }

        if( ich == dstrSubString.cchString )
        {
            /* 
            ** We looped through all the characters in dstrSubString
            ** so there must have been a match 
            */
            *f_pdstrFoundString = dstrString;
            goto ErrorExit;
        }

        dstrString.cchString++;
        dstrString.pwszString--;
    }

    dr = DRM_E_FAIL;

ErrorExit:

    if( DRM_FAILED( dr ) )
    {
        return FALSE;
    }
    return TRUE;    
}

/*
**  Add encoding-decoding strings in pairs
*/

const DRM_WCHAR g_rgwchEncodedAmpersand[]   =  { ONE_WCHAR('&', '\0'), ONE_WCHAR('a', '\0'), ONE_WCHAR('m', '\0'), ONE_WCHAR('p', '\0'), ONE_WCHAR(';', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_WCHAR g_rgwchEncodedQuote[]       =  { ONE_WCHAR('&', '\0'), ONE_WCHAR('q', '\0'), ONE_WCHAR('u', '\0'), ONE_WCHAR('o', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR(';', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_WCHAR g_rgwchEncodedLesserThan[]  =  { ONE_WCHAR('&', '\0'), ONE_WCHAR('l', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR(';', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_WCHAR g_rgwchEncodedGreaterThan[] =  { ONE_WCHAR('&', '\0'), ONE_WCHAR('g', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR(';', '\0'), ONE_WCHAR('\0', '\0')};

const DRM_CONST_STRING g_dstrEncodedAmpersand    =  CREATE_DRM_STRING( g_rgwchEncodedAmpersand );
const DRM_CONST_STRING g_dstrEncodedQuote        =  CREATE_DRM_STRING( g_rgwchEncodedQuote );
const DRM_CONST_STRING g_dstrEncodedLesserThan   =  CREATE_DRM_STRING( g_rgwchEncodedLesserThan );
const DRM_CONST_STRING g_dstrEncodedGreaterThan  =  CREATE_DRM_STRING( g_rgwchEncodedGreaterThan );

const DRM_CHAR g_rgchEncodedAmpersand[]   =  { TWO_BYTES('&', 'a'), TWO_BYTES('m', 'p'), TWO_BYTES(';', '\0'), TWO_BYTES('\0', '\0') };
const DRM_CHAR g_rgchEncodedQuote[]       =  { TWO_BYTES('&', 'q'), TWO_BYTES('u', 'o'), TWO_BYTES('t', ';'), TWO_BYTES('\0', '\0') };
const DRM_CHAR g_rgchEncodedLesserThan[]  =  { TWO_BYTES('&', 'l'), TWO_BYTES('t', ';'), TWO_BYTES('\0', '\0') };
const DRM_CHAR g_rgchEncodedGreaterThan[] =  { TWO_BYTES('&', 'g'), TWO_BYTES('t', ';'), TWO_BYTES('\0', '\0') };

const DRM_ANSI_CONST_STRING g_dastrEncodedAmpersand    =  { g_rgchEncodedAmpersand, 5 };
const DRM_ANSI_CONST_STRING g_dastrEncodedQuote        =  { g_rgchEncodedQuote, 6 };
const DRM_ANSI_CONST_STRING g_dastrEncodedLesserThan   =  { g_rgchEncodedLesserThan, 4 };
const DRM_ANSI_CONST_STRING g_dastrEncodedGreaterThan  =  { g_rgchEncodedGreaterThan, 4 };

typedef struct tagXMLEncodeMapping {
    const DRM_CONST_STRING  *pdstrEncoding;
    const DRM_WCHAR         wchEncodedCharacter;
} XMLEncodeMapping;

typedef struct tagXMLEncodeMappingUA {
    const DRM_CONST_STRING  *pdstrEncoding;
    const DRM_CHAR chEncodedCharacter;
} XMLEncodeMappingUA;

typedef struct tagXMLEncodeMappingA {
    const DRM_ANSI_CONST_STRING  *pdastrEncoding;
    const DRM_CHAR chEncodedCharacter;
} XMLEncodeMappingA;

static const XMLEncodeMapping   g_rgXMLEncodeMapping[] = 
{
    { &g_dstrEncodedAmpersand,    WCHAR_CAST( '&' ) }, 
    { &g_dstrEncodedQuote,        WCHAR_CAST( '\"' ) },
    { &g_dstrEncodedLesserThan,   WCHAR_CAST( '<' ) },
    { &g_dstrEncodedGreaterThan,  WCHAR_CAST( '>' ) }
};

static const XMLEncodeMappingUA g_rgXMLEncodeMappingUA[] =
{
    { &g_dstrEncodedAmpersand, '&' },
    { &g_dstrEncodedQuote, '\"' },
    { &g_dstrEncodedLesserThan, '<' },
    { &g_dstrEncodedGreaterThan, '>' }
};

static const XMLEncodeMappingA g_rgXMLEncodeMappingA[] =
{
    { &g_dastrEncodedAmpersand, '&' },
    { &g_dastrEncodedQuote, '\"' },
    { &g_dastrEncodedLesserThan, '<' },
    { &g_dastrEncodedGreaterThan, '>' }
};

/******************************************************************************
** 
** Function :   DRM_UTL_XMLDecode
** 
** Synopsis :   Decode special characters like "&amp;" to plain old"&"
** 
** Arguments :  f_pwszEncoded   : Encoded string
**              f_cchEncoded    : Length of encoded string
**              f_pwszDecoded   : Buffer for decoded string; if NULL, the
**                                length of buffer required is returned and 
**                                errcode is DRM_E_BUFFERTOOSMALL
**              f_pcchDecoded   : Length of buffer for decoded string. After 
**                                returning, it contains length of decoded buffer,
**                                or length of buffer required.
**                              
** 
** Returns :    DRM_E_BUFFERTOOSMALL, if buffer for decoded string is not long 
**              enough  
** 
** Notes :      
** 
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_UTL_XMLDecode(
    __in_ecount( f_cchEncoded ) const DRM_WCHAR *f_pwszEncoded,
    IN          DRM_DWORD    f_cchEncoded,
    __out_ecount_opt(*f_pcchDecoded) DRM_WCHAR *f_pwszDecoded,
    IN  OUT     DRM_DWORD   *f_pcchDecoded )
{
    DRM_RESULT      dr                  = DRM_SUCCESS;
    DRM_DWORD       iEncoded            = 0;
    DRM_DWORD       iDecoded            = 0;
    DRM_DWORD       iEncoding           = 0;
    DRM_BOOL        fFoundEncodedChar   = FALSE; 
    
    ChkArg( f_pwszEncoded != NULL && f_pcchDecoded != NULL );

    while ( iEncoded < f_cchEncoded )
    {                
        /*
        **  Check whether the next character is an encoded character
        */
        fFoundEncodedChar = FALSE; 
        for ( iEncoding = 0; 
              iEncoding < NO_OF( g_rgXMLEncodeMapping );
              iEncoding ++ )
        {
            if ( ( f_cchEncoded >= iEncoded + g_rgXMLEncodeMapping[iEncoding].pdstrEncoding->cchString )
              && DRMCRT_wcsncmp( f_pwszEncoded + iEncoded, 
                          g_rgXMLEncodeMapping[iEncoding].pdstrEncoding->pwszString, 
                          g_rgXMLEncodeMapping[iEncoding].pdstrEncoding->cchString ) == 0 )
            {
                if ( f_pwszDecoded != NULL && iDecoded < (*f_pcchDecoded) )
                {
                    f_pwszDecoded[ iDecoded ] =   g_rgXMLEncodeMapping[iEncoding].wchEncodedCharacter;
                }
                iEncoded += g_rgXMLEncodeMapping[iEncoding].pdstrEncoding->cchString;
                fFoundEncodedChar = TRUE;
                break;
            }            
        }        
        
        if ( !fFoundEncodedChar )
        {
            if ( f_pwszDecoded != NULL && iDecoded < (*f_pcchDecoded) )
            {
                f_pwszDecoded[ iDecoded ] = f_pwszEncoded[ iEncoded ];
            }
            iEncoded++;
        }

        iDecoded++;        
    }
    
    if ( iDecoded > *f_pcchDecoded || f_pwszDecoded == NULL )
    {        
        dr = DRM_E_BUFFERTOOSMALL;
    }
    *f_pcchDecoded = iDecoded;
    
ErrorExit:    
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_UTL_XMLDecodeUA
** 
** Synopsis :   Convert special characters in a Unicode URL string according
**              to XML decoding standard. The output is a UTF8/ANSI string.
**              For example, "&amp;" will be converted to "&".
** 
** Arguments :  
** [f_pwchEncoded]          - Pointer to a buffer that contains the source URL string.
** [f_cchEncoded]           - Size (number of wide characters) of the source URL string.
** [f_pchDecoded]           - Pointer to a buffer to receive the decoded URL string.
**                            If it is NULL, the function returns an error and the
**                            size of the required buffer is stored in *f_pcchDecoded.
** [f_pcchDecoded]          - Pointer to a variable that contains the size (in characters
**                            of the decode buffer during input and receives the
**                            size (in characterss) of the decoded string during output.
**
** Returns:                 DRM_SUCCESS on success
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the decode buffer is too small.
** 
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_UTL_XMLDecodeUA(
    __in_ecount( f_cchEncoded ) const DRM_WCHAR *f_pwchEncoded,
    IN DRM_DWORD f_cchEncoded,
    __out_ecount_opt(*f_pcchDecoded) DRM_CHAR *f_pchDecoded,
    IN OUT DRM_DWORD *f_pcchDecoded )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD iEncoded = 0;
    DRM_DWORD iDecoded = 0;
    DRM_DWORD iEncoding = 0;
    DRM_BOOL fFoundEncodedChar = FALSE; 
    DRM_WCHAR wchTmp = 0;
    
    ChkArg( f_pwchEncoded != NULL && f_pcchDecoded != NULL );

    while ( iEncoded < f_cchEncoded )
    {                
        fFoundEncodedChar = FALSE;
        
        /*
        ** Check whether the next character is an encoded character.
        */
        for ( iEncoding = 0; 
              iEncoding < NO_OF( g_rgXMLEncodeMappingUA );
              iEncoding ++ )
        {
            if ( ( f_cchEncoded >= iEncoded + g_rgXMLEncodeMappingUA[ iEncoding ].pdstrEncoding->cchString ) &&
                 DRMCRT_wcsncmp( f_pwchEncoded + iEncoded, 
                          g_rgXMLEncodeMappingUA[ iEncoding ].pdstrEncoding->pwszString,
                          g_rgXMLEncodeMappingUA[ iEncoding ].pdstrEncoding->cchString ) == 0 )
            {
                if ( f_pchDecoded != NULL && iDecoded < *f_pcchDecoded )
                {
                    f_pchDecoded[ iDecoded ] = g_rgXMLEncodeMappingUA[ iEncoding ].chEncodedCharacter;
                }
                
                iEncoded += g_rgXMLEncodeMappingUA[ iEncoding ].pdstrEncoding->cchString;
                
                fFoundEncodedChar = TRUE;
                
                break;
            }            
        }        
        
        if ( !fFoundEncodedChar )
        {
            if ( f_pchDecoded != NULL && iDecoded < *f_pcchDecoded )
            {
                wchTmp = f_pwchEncoded[ iEncoded ];
                FIX_ENDIAN_WORD( wchTmp );
                
                f_pchDecoded[ iDecoded ] = ( DRM_CHAR )wchTmp;
            }
            
            iEncoded++;
        }

        iDecoded++;        
    }
    
    if ( iDecoded > *f_pcchDecoded || f_pchDecoded == NULL )
    {        
        dr = DRM_E_BUFFERTOOSMALL;
    }
    
    *f_pcchDecoded = iDecoded;
    
ErrorExit:
    
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_UTL_XMLDecodeA
** 
** Synopsis :   Convert special characters in an ANSI/UTF8 URL string according
**              to XML decoding standard. The output is a UTF8/ANSI string.
**              For example, "&amp;" will be converted to "&".
** 
** Arguments :  
** [f_pchEncoded]           - Pointer to a buffer that contains the source URL string.
** [f_cchEncoded]           - Size (number of characters) of the source URL string.
** [f_pchDecoded]           - Pointer to a buffer to receive the decoded URL string.
**                            If it is NULL, the function returns an error and the
**                            size of the required buffer is stored in *f_pcchDecoded.
** [f_pcchDecoded]          - Pointer to a variable that contains the size (in characters
**                            of the decode buffer during input and receives the
**                            size (in characterss) of the decoded string during output.
**
** Returns:                 DRM_SUCCESS on success
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the decode buffer is too small.
** 
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_UTL_XMLDecodeA(
    __in_ecount( f_cchEncoded ) const DRM_CHAR *f_pchEncoded,
    IN DRM_DWORD f_cchEncoded,
    __out_ecount_opt(*f_pcchDecoded) DRM_CHAR *f_pchDecoded,
    IN OUT DRM_DWORD *f_pcchDecoded )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD iEncoded = 0;
    DRM_DWORD iDecoded = 0;
    DRM_DWORD iEncoding = 0;
    DRM_BOOL fFoundEncodedChar = FALSE; 
    
    ChkArg( f_pchEncoded != NULL && f_pcchDecoded != NULL );

    while ( iEncoded < f_cchEncoded )
    {                
        fFoundEncodedChar = FALSE;
        
        /*
        ** Check whether the next character is an encoded character.
        */
        for ( iEncoding = 0; 
              iEncoding < NO_OF( g_rgXMLEncodeMappingA );
              iEncoding ++ )
        {
            if ( ( f_cchEncoded >= iEncoded + g_rgXMLEncodeMappingA[ iEncoding ].pdastrEncoding->cchString ) &&
                 MEMCMP( f_pchEncoded + iEncoded, 
                          g_rgXMLEncodeMappingA[ iEncoding ].pdastrEncoding->pszString,
                          g_rgXMLEncodeMappingA[ iEncoding ].pdastrEncoding->cchString ) == 0 )
            {
                if ( f_pchDecoded != NULL && iDecoded < *f_pcchDecoded )
                {
                    f_pchDecoded[ iDecoded ] = g_rgXMLEncodeMappingA[ iEncoding ].chEncodedCharacter;
                }
                
                iEncoded += g_rgXMLEncodeMappingA[ iEncoding ].pdastrEncoding->cchString;
                
                fFoundEncodedChar = TRUE;
                
                break;
            }            
        }        
        
        if ( !fFoundEncodedChar )
        {
            if ( f_pchDecoded != NULL && iDecoded < *f_pcchDecoded )
            {
                f_pchDecoded[ iDecoded ] = f_pchEncoded[ iEncoded ];
            }
            
            iEncoded++;
        }

        iDecoded++;        
    }
    
    if ( iDecoded > *f_pcchDecoded || f_pchDecoded == NULL )
    {        
        dr = DRM_E_BUFFERTOOSMALL;
    }

    *f_pcchDecoded = iDecoded;
    
ErrorExit:
    
    return dr;
}

/*********************************************************************
**
** Function: DRM_UTL_XMLEncodeA
**
** Synopsis: Function that does XML encoding of a UTF8/ANSI string.
**
** Arguments:
**
** [f_pchDecoded]           -- Pointer to a buffer that contains the string
**                             to be XML encoded.
** [f_cchDecoded]           -- Size (number of characters) of the input string.
** [f_pchEncoded]           -- Pointer to a buffer to receive the XML encoded
**                             string. If it is NULL, the required size will
**                             be stored in *f_pcchEncoded.
** [f_pcchEncoded]          -- Pointer to a variable that contains the size
**                             of buffer to receive the XML encoded string
**                             during input and received the actual size of
**                             XML encoded string during output.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the buffer to receive
**                          the XML encoded string is NULL or not big enough.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_UTL_XMLEncodeA(
    __in_ecount( f_cchDecoded ) const DRM_CHAR *f_pchDecoded,
    IN DRM_DWORD f_cchDecoded,
    __out_ecount_opt(*f_pcchEncoded) DRM_CHAR *f_pchEncoded,
    IN OUT DRM_DWORD *f_pcchEncoded )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD i = 0, j = 0, k = 0;
    DRM_DWORD cchEncoded = 0;
    DRM_CHAR *pchEncodedCurr = f_pchEncoded;
    DRM_BOOL fBufferTooSmall = FALSE;
    DRM_DWORD cchInput = 0;
    DRM_DWORD cchMapping = 0;
    DRM_WCHAR wchTmp = 0;
    
    ChkArg( f_pchDecoded != NULL && f_pcchEncoded != NULL );

    if ( f_pchEncoded == NULL && f_cchDecoded > 0 )
    {
        fBufferTooSmall = TRUE;
    }

    cchInput = *f_pcchEncoded;

    while ( i < f_cchDecoded )
    {
        for ( j = 0; j < NO_OF( g_rgXMLEncodeMappingUA ); j++ )
        {
            if ( f_pchDecoded[ i ] == g_rgXMLEncodeMappingUA[ j ].chEncodedCharacter )
            {
                break;
            }
        }

        if ( j < NO_OF( g_rgXMLEncodeMappingUA ) )
        {
            /* Found a mapping. */

            cchMapping = g_rgXMLEncodeMappingUA[ j ].pdstrEncoding->cchString;
            
            cchEncoded += cchMapping;

            if ( f_pchEncoded != NULL )
            {
                if ( cchEncoded <= *f_pcchEncoded )
                {
                    for ( k = 0; k < cchMapping; k++ )
                    {
                        if ( pchEncodedCurr < f_pchEncoded + cchInput )
                        {
                            wchTmp = g_rgXMLEncodeMappingUA[ j ].pdstrEncoding->pwszString[ k ];
                            FIX_ENDIAN_WORD( wchTmp );
                            
                            *pchEncodedCurr = ( DRM_CHAR )wchTmp;
                            
                            pchEncodedCurr++;
                        }
                    }
                }
                else
                {
                    fBufferTooSmall = TRUE;
                }
            }
        }
        else
        {
            cchEncoded++;

            if ( f_pchEncoded != NULL )
            {
                if ( cchEncoded <= *f_pcchEncoded )
                {
                    if ( pchEncodedCurr < f_pchEncoded + cchInput )
                    {
                        *pchEncodedCurr = f_pchDecoded[ i ];
                        
                        pchEncodedCurr++;
                    }
                }
                else
                {
                    fBufferTooSmall = TRUE;
                }
            }
        }

        i++;
    }

    *f_pcchEncoded = cchEncoded;

    if ( fBufferTooSmall )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

ErrorExit:

    return dr;    
}

DRM_API DRM_NO_INLINE DRM_VOID DRM_CALL DRM_XOR( 
    __inout_bcount(cb) DRM_BYTE  *pbLHS, 
    __in_bcount(cb) const DRM_BYTE  *pbRHS, 
    IN                   DRM_DWORD  cb )
{
    DRM_DWORD i;
    for( i = 0; i < cb; i++ )
    {
        PUT_BYTE(pbLHS, i, GET_BYTE(pbLHS, i) ^ GET_BYTE(pbRHS,i) );
    }
}

DRM_API DRM_RESULT DRM_CALL DRM_UTL_ReadGUID(
   __in_bcount( cbData ) const DRM_BYTE *pbData, 
   IN  const    DRM_DWORD cbData,
   IN           DRM_DWORD ibGuidOffset,
   OUT          DRM_GUID *pDrmGuid )
{   
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg( pbData != NULL );
    ChkArg( pDrmGuid != NULL );

    ChkOverflow( cbData, ibGuidOffset );

    ChkBOOL( cbData - ibGuidOffset >= DRM_GUID_LEN, DRM_E_BUFFERTOOSMALL );

    /*  Convert field by field */
    LITTLEENDIAN_BYTES_TO_DWORD( pDrmGuid->Data1, pbData, ibGuidOffset );
    ibGuidOffset += SIZEOF( DRM_DWORD );
    
    LITTLEENDIAN_BYTES_TO_DWORD( pDrmGuid->Data2,  pbData, ibGuidOffset );
    ibGuidOffset += SIZEOF( DRM_WORD );
    
    LITTLEENDIAN_BYTES_TO_WORD( pDrmGuid->Data3, pbData, ibGuidOffset );
    ibGuidOffset += SIZEOF( DRM_WORD );

    /*  Copy last 8 bytes */    
    DRM_BYT_CopyBytes( pDrmGuid->Data4, 0, pbData, ibGuidOffset, 8 ); 

ErrorExit :   
    return dr;
}

DRM_API DRM_BOOL DRM_CALL DRM_UTL_AreGUIDEqual( const DRM_GUID *pDrmGuid1, const DRM_GUID *pDrmGuid2 )
{
    if( pDrmGuid1 == NULL || pDrmGuid2 == NULL )
        return FALSE;
    else
        return 0 == MEMCMP( pDrmGuid1, pDrmGuid2, SIZEOF( DRM_GUID ) );
}

/**********************************************************************
** Function:    DRM_UTL_IsZeros
** Synopsis:    check if the given byte array contains all zero bytes.
** Arguments:   [pbBuff] -- byte array to be checked
**              [cbBuff[ -- size of pbBuff
** Returns:     TRUE if all zeros
** Notes:       
***********************************************************************
*/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL DRM_UTL_IsZeros(
    __in_bcount( cbBuff )const DRM_BYTE *pbBuff,
    IN DRM_DWORD cbBuff )
{
    DRM_DWORD i = 0;

    for ( i = 0; i < cbBuff; i++)
    {
        if (GET_BYTE(pbBuff, i) != 0)
        {
            return FALSE;
        }
    }

    return TRUE;
}



/*********************************************************************
**
**  Function:  DRM_UTL_LShift
**
**  Synopsis:  Left-shift on a byte buffer (not done in place)
**
**  Arguments:  
**     f_pbIn  :  Input buffer
**     f_pbOut :  Output (result) buffer       
**     f_cb    :  Byte count to shift
**
**  Returns: DRM_SUCCESS
**              Success   
**           DRM_E_INVALIDARG
**              One of the pointer arguments was NULL
**
*********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_UTL_LShift( 
    __in_bcount( f_cb ) const DRM_BYTE *f_pbIn, 
    __out_ecount(f_cb) DRM_BYTE *f_pbOut, 
    IN                 DRM_DWORD f_cb )    
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  i  = 0;
    DRM_BYTE   b  = 0; 

    ChkArg( f_pbIn != NULL
         && f_pbOut != NULL );
 
    for( i = 0; i < f_cb; i++ )
    {
        b = GET_BYTE( f_pbIn, i ) << 1;
                
        if( i < f_cb - 1 )
        {
            PUT_BYTE( f_pbOut, i, b | ( GET_BYTE( f_pbIn, i + 1 ) >> 7 ) );
        }
        else
        {
            PUT_BYTE( f_pbOut, i, b );
        }
    }

ErrorExit:
    return dr;
}

/*********************************************************************
**
**  Function:  DRM_UTL_RShift
**
**  Synopsis:  Right-shift on a byte buffer (not done in place)
**
**  Arguments:  
**     f_pbIn  :  Original buffer
**     f_pbOut :  Output (result) buffer       
**     f_cb    :  Byte count to shift
**
**  Returns: DRM_SUCCESS
**              Success   
**           DRM_E_INVALIDARG
**              One of the pointer arguments was NULL    
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_UTL_RShift( 
    __in_bcount( f_cb ) const DRM_BYTE *f_pbIn, 
    __out_ecount(f_cb) DRM_BYTE *f_pbOut, 
    IN                 DRM_DWORD f_cb )     
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  i  = 0;
    DRM_BYTE   b  = 0; 

    ChkArg( f_pbIn != NULL
         && f_pbOut != NULL );

    for( i = 0; i < f_cb; i++ )
    {
        b = GET_BYTE( f_pbIn, i ) >> 1;
                
        if( i > 0 )
        {
            PUT_BYTE( f_pbOut, i, b | ( GET_BYTE( f_pbIn, i - 1 ) << 7 ) );
        }
        else
        {
            PUT_BYTE( f_pbOut, i, b );
        }
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_MultiplyDWORDs
**
** Synopsis :   Multiplies two DWORDs while checking for arithmetic overflows
**
** Parameters:
**      [f_dwFirst]   : Specifies the first DWORD to multiply
**      [f_dwSecond]  : Specifies the second DWORD to multiply
**      [f_pdwResult] : Returns the result of the multiplication
**              
**
** Returns :    
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pdwResult was NULL
**      DRM_E_ARITHMETIC_OVERFLOW
**          An overflow occurred during multiplication
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_UTL_MultiplyDWORDs(
    IN      DRM_DWORD   f_dwFirst,
    IN      DRM_DWORD   f_dwSecond,
        OUT DRM_DWORD  *f_pdwResult )
{
    DRM_RESULT dr         = DRM_SUCCESS;
    DRM_UINT64 ui64Result = DRM_UI64Mul( DRM_UI64( f_dwFirst ), DRM_UI64( f_dwSecond ) );

    ChkArg( f_pdwResult != NULL );
    
    *f_pdwResult = 0;    
    ChkBOOL( DRM_UI64High32( ui64Result ) == 0, DRM_E_ARITHMETIC_OVERFLOW );
    *f_pdwResult = DRM_UI64Low32( ui64Result );
    
ErrorExit:    
    return dr;
}



EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmversionconstants.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>

ENTER_PK_NAMESPACE_CODE;


const DRM_WCHAR g_rgwchReqTagPlayReadyClientVersionData[] = { ONE_WCHAR('1', '\0'), ONE_WCHAR('.', '\0'), ONE_WCHAR('2', '\0'), ONE_WCHAR('.', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('.', '\0'), ONE_WCHAR('1', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('\0', '\0') };
const DRM_CONST_STRING g_dstrReqTagPlayReadyClientVersionData = CREATE_DRM_STRING( g_rgwchReqTagPlayReadyClientVersionData );


const DRM_WCHAR g_rgwchReqTagWMDRMPDClientVersionData[] = { ONE_WCHAR('1', '\0'), ONE_WCHAR('1', '\0'), ONE_WCHAR('.', '\0'), ONE_WCHAR('2', '\0'), ONE_WCHAR('.', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('.', '\0'), ONE_WCHAR('1', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('\0', '\0') };
const DRM_CONST_STRING g_dstrReqTagWMDRMPDClientVersionData = CREATE_DRM_STRING( g_rgwchReqTagWMDRMPDClientVersionData );


const DRM_DWORD g_dwWMDRMPDVersionMajor = 11;
const DRM_DWORD g_dwWMDRMPDVersionMinor = 2;
const DRM_DWORD g_dwWMDRMPDVersionRevision = 0;
const DRM_DWORD g_dwWMDRMPDVersionBuild = 1404;


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmviewrights.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmlicenseparser.h>
#include <drmsecurestore.h>
#include <drmblackbox.h>
#include <drmlicstore.h>
#include <drmliceval.h>
#include <drmexpreval.h>
#include <drmmanager.h>
#include <drmlicreason.h>
#include <drmviewprops.h>
#if DRM_SUPPORT_DELETEDSTORE
#include <drmrecentexpired.h>
#endif

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
/* Get the "machine.datetime" for the antirollback clock */
extern DRM_RESULT DRM_CALL GetMachineDatetime(
    IN OUT DRM_LICEVAL_CONTEXT *f_pContextLicEval,
    OUT    DRM_UINT64          *f_u64MachineDateTime
);
#endif /* DRM_SUPPORT_ANTIROLLBACK_CLOCK */

/* Is the date a Negative Infinity representation? */
static DRMINLINE DRM_BOOL _NegInfDate( IN const DRMFILETIME *f_pft )
{
    return ( f_pft->dwLowDateTime  == 0
          && f_pft->dwHighDateTime == 0 );
}

/* Is the date a Positive Infinity representation? */
static DRMINLINE DRM_BOOL _InfDate( IN const DRMFILETIME *f_pft )
{
    return ( f_pft->dwLowDateTime  == 0xFFFFFFFF
          && f_pft->dwHighDateTime == 0xFFFFFFFF );
}

/* Initilize a date to a Negative Infinity representation */
static DRMINLINE DRM_VOID _InitNegInfDate(
    OUT DRMFILETIME *f_pDate )
{
    ZEROMEM( f_pDate, SIZEOF( DRMFILETIME ) );
}

/* Initilize a date to a Positive Infinity representation */
static DRMINLINE DRM_VOID _InitInfDate(
    OUT DRMFILETIME *f_pDate )
{
    MEMSET( f_pDate, 0xFF, SIZEOF( DRMFILETIME ) );
}

/* Is the date an already expired? */
static DRMINLINE DRM_BOOL _IsExpired( IN DRM_VOID *pOEMContext, IN const DRMFILETIME *f_pft )
{
    if( _InfDate( f_pft ) )
    {
        return FALSE;
    }
    else
    {
        DRMFILETIME ftNow;

        Oem_Clock_GetSystemTimeAsFileTime( pOEMContext, &ftNow );

        return ( DRM_UTL_DateLessThan( f_pft, &ftNow ) );
    }
}

/* Does today fall between Begin and End (inclusive)? */
static DRMINLINE DRM_BOOL _IsDateUsable(
    IN       DRM_VOID    *pOEMContext,
    IN const DRMFILETIME *f_pftBegin,
    IN const DRMFILETIME *f_pftEnd )
{
    if( _NegInfDate( f_pftBegin )
     && _InfDate(    f_pftEnd ) )
    {
        return TRUE;
    }
    else
    {
        DRMFILETIME ftNow;

        Oem_Clock_GetSystemTimeAsFileTime( pOEMContext, &ftNow );

        /* Use !(b<a) to achive a<=b (so that the check is inclusive) */
        return (  !DRM_UTL_DateLessThan( &ftNow,     f_pftBegin )
               && !DRM_UTL_DateLessThan(  f_pftEnd, &ftNow ) );
    }
}

/* Do 2 sets of begin/end dates overlap each other? */
static DRMINLINE DRM_BOOL _OverlappingDates(
    IN const DRMFILETIME *f_pftBeginDate1,
    IN const DRMFILETIME *f_pftEndDate1,
    IN const DRMFILETIME *f_pftBeginDate2,
    IN const DRMFILETIME *f_pftEndDate2 )
{
    return !( DRM_UTL_DateLessThan( f_pftEndDate2, f_pftBeginDate1 )
           || DRM_UTL_DateLessThan( f_pftEndDate1, f_pftBeginDate2 ) );
}

/* Read out BegDate and EndDate from State Data */
static DRMINLINE DRM_VOID _ReadDates(
    IN const DRM_LICENSE_STATE_DATA    *f_pstatedata,
       OUT   DRMFILETIME               *f_pstateBegDate,
       OUT   DRMFILETIME               *f_pstateEndDate )
{
    /* Initialize stateBegDate and stateEndDate. */
    _InitNegInfDate( f_pstateBegDate );
    _InitInfDate(    f_pstateEndDate );

    /* Handle dates */
    if( f_pstatedata->dwCategory == DRM_LICENSE_STATE_FROM
     || f_pstatedata->dwCategory == DRM_LICENSE_STATE_COUNT_FROM )
    {
        *f_pstateBegDate = f_pstatedata->datetime[0];
    }
    else if( f_pstatedata->dwCategory == DRM_LICENSE_STATE_FROM_UNTIL
          || f_pstatedata->dwCategory == DRM_LICENSE_STATE_COUNT_FROM_UNTIL )
    {
        *f_pstateBegDate = f_pstatedata->datetime[0];
        *f_pstateEndDate = f_pstatedata->datetime[1];
    }
    else if( f_pstatedata->dwCategory == DRM_LICENSE_STATE_UNTIL
          || f_pstatedata->dwCategory == DRM_LICENSE_STATE_COUNT_UNTIL )
    {
        *f_pstateEndDate = f_pstatedata->datetime[0];
    }
}

#if DRM_SUPPORT_DELETEDSTORE
/*
** Check whether there's a recent expired license.
** If so, set *f_pfRecentExpired to TRUE.
** Also, clean up the store for this KID if the entry is old enough.
*/
static DRM_RESULT _CheckRecentExpired(
             DRM_VOID                *f_pcontextOEM,
    IN       DRM_DST                 *f_pDatastore,
    IN       DRM_KID                 *f_pKID,               /* kid to query */
       OUT   DRM_BOOL                *f_pfRecentExpired )   /* query result */
{
    DRM_RESULT                  dr              = DRM_SUCCESS;
    DRM_RECENTEXPIRED_CONTEXT   contextRCX;
    DRM_RECENTEXPIRED_DATA      data;
    DRMFILETIME                 ftCurrentTime;
    DRM_UINT64                  u64currentTime;
    DRM_UINT64                  u64currentTimeMinus3Months;
    DRMFILETIME                 ftCurrentTimeMinus3Months;

    ChkArg( f_pDatastore      != NULL
         && f_pKID            != NULL
         && f_pfRecentExpired != NULL );

    /*
    ** Note: Even if the result is already success for all actions,
    ** we should still hit the store to perform cleanup on old entries.
    */

    ZEROMEM( &contextRCX, SIZEOF( contextRCX ) );

    ChkDR( DRM_RCX_OpenStore( f_pDatastore,
                              &contextRCX ) );

    dr = DRM_RCX_GetKIDStoreData( &contextRCX,
                                   f_pKID,
                                  &data );
    if( dr == DRM_E_DSTSLOTNOTFOUND )
    {
        /* No recent expired - nothing to do */
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }
    else
    {
        ChkDR( dr );
    }

    /*
    **  Note that the mere existance of the entry is enough
    **  to add expired error to return value
    */

    *f_pfRecentExpired = TRUE;

    /* Now we're going to check if the entry is too old and should be deleted */

    Oem_Clock_GetSystemTimeAsFileTime( f_pcontextOEM, &ftCurrentTime );

    FILETIME_TO_UI64( ftCurrentTime, u64currentTime );
    /*
    ** Offset by 84 days (12 weeks)
    ** Filetime is measured in "100 nanosecond intervals"
    ** 84 days
    ** 24 hrs in a day
    ** 3600 secs in an hr
    ** 1000 ms in a sec
    ** 10000 "100 nanosecond intervals" in a ms
    */
    u64currentTimeMinus3Months = DRM_UI64Sub(
        u64currentTime,
        DRM_UI64Mul( DRM_UI64Mul( DRM_UI64Mul( DRM_UI64(84),
                                               DRM_UI64(24) ),
                                  DRM_UI64Mul( DRM_UI64(3600),
                                               DRM_UI64(1000) ) ),
                                  DRM_UI64(10000) ) );

    UI64_TO_FILETIME( u64currentTimeMinus3Months, ftCurrentTimeMinus3Months );

    /*
    **  if ( date.datetime < the current time - 3 months)
    */
    if( DRM_UTL_DateLessThan( &data.datetime, &ftCurrentTimeMinus3Months ) )
    {
        /*
        **  then entry is too old [delete it]
        */

        ChkDR( DRM_RCX_DeleteKID( &contextRCX, f_pKID ) );
    }

ErrorExit:
    (void) DRM_RCX_CloseStore( &contextRCX );

    return dr;
}
#endif

/*****************************************************************************/

static DRM_RESULT _GetSecStateAttr(
    IN       DRM_SECSTORE_CONTEXT *f_contextSST,
    IN const DRM_CONST_STRING     *f_pdstrAttribute,
       OUT   DRM_DWORD            *f_pdwValue,
       OUT   DRMFILETIME          *f_pft )
{
    DRM_RESULT dr = DRM_SUCCESS;
    TOKEN      token;

    dr = DRM_SST_GetTokenValue( f_contextSST, f_pdstrAttribute, &token );
    if( DRM_FAILED(dr)
     || dr == DRM_S_FALSE )
    {
        /* Unable to retrieve the value. */
        ChkDR( CPRMEXP_RETRIEVAL_FAILURE );
    }

    switch(token.TokenType)
    {
    case TOKEN_LONG:
        if( f_pdwValue != NULL )
        {
            *f_pdwValue = token.val.lValue;
        }
        else
        {
            dr = DRM_S_FALSE; /* We are not passing any data back */
        }
        break;
    case TOKEN_DATETIME:
        if( f_pft != NULL )
        {
            UI64_TO_FILETIME( token.val.u64DateTime, *f_pft );
        }
        else
        {
            dr = DRM_S_FALSE; /* We are not passing any data back */
        }
        break;
    default:
        dr = DRM_S_FALSE; /* We don't retrieve any string data for license view. */
    }

ErrorExit:
    return dr;
}

/*****************************************************************************/

static DRM_VOID _SetExpiryCategory(
    IN OUT   DRM_LICENSE_STATE_DATA    *f_pstatedata,
    IN const DRMFILETIME               *f_pftBeginDate,
    IN const DRMFILETIME               *f_pftEndDate )
{
    DRM_DWORD dwExpiryType = ( ( !_NegInfDate( f_pftBeginDate ) ) << 1 ) + !_InfDate( f_pftEndDate );

    switch( dwExpiryType )
    {
    case 0:
        f_pstatedata->dwCategory    = DRM_LICENSE_STATE_UNLIM;
        f_pstatedata->dwNumDates    = 0;
        f_pstatedata->dwNumCounts   = 0;
        f_pstatedata->dwCount[0]    = 0;
        f_pstatedata->dwCount[1]    = 0;
        /*
        ** If only basic vagueness is set, we can remove it
        ** because this license is now unlimited type.
        ** But, if other vagueness like OPL or SAP is set, then we do nothing
        ** because even an unlimited type license can fail to be usable
        ** for those types of reasons (and is thus still vague).
        */
        if( f_pstatedata->dwVague == DRM_ASD_VAGUE )
        {
            f_pstatedata->dwVague   = 0;
        }
        break;
    case 1:
        f_pstatedata->dwCategory    = DRM_LICENSE_STATE_UNTIL;
        f_pstatedata->dwNumDates    = 1;
        MEMCPY( &f_pstatedata->datetime[0], f_pftEndDate,   SIZEOF( DRMFILETIME ) );
        break;
    case 2:
        f_pstatedata->dwCategory    = DRM_LICENSE_STATE_FROM;
        f_pstatedata->dwNumDates    = 1;
        MEMCPY( &f_pstatedata->datetime[0], f_pftBeginDate, SIZEOF( DRMFILETIME ) );
        break;
    case 3:
        f_pstatedata->dwCategory    = DRM_LICENSE_STATE_FROM_UNTIL;
        f_pstatedata->dwNumDates    = 2;
        MEMCPY( &f_pstatedata->datetime[0], f_pftBeginDate, SIZEOF( DRMFILETIME ) );
        MEMCPY( &f_pstatedata->datetime[1], f_pftEndDate,   SIZEOF( DRMFILETIME ) );
        break;
    }
}

/*****************************************************************************/

static DRM_VOID _SetCountedExpiryCategory(
    IN OUT   DRM_LICENSE_STATE_DATA    *f_pstatedata,
    IN const DRMFILETIME               *f_pftBeginDate,
    IN const DRMFILETIME               *f_pftEndDate )
{
    DRM_DWORD dwExpiryType = ( ( !_NegInfDate( f_pftBeginDate ) ) << 1 ) + !_InfDate( f_pftEndDate );

    switch( dwExpiryType )
    {
    case 0:
        f_pstatedata->dwCategory    = DRM_LICENSE_STATE_COUNT;
        f_pstatedata->dwNumDates    = 0;
        break;
    case 1:
        f_pstatedata->dwCategory    = DRM_LICENSE_STATE_COUNT_UNTIL;
        f_pstatedata->dwNumDates    = 1;
        MEMCPY( &f_pstatedata->datetime[0], f_pftEndDate,   SIZEOF( DRMFILETIME ) );
        break;
    case 2:
        f_pstatedata->dwCategory    = DRM_LICENSE_STATE_COUNT_FROM;
        f_pstatedata->dwNumDates    = 1;
        MEMCPY( &f_pstatedata->datetime[0], f_pftBeginDate, SIZEOF( DRMFILETIME ) );
        break;
    case 3:
        f_pstatedata->dwCategory    = DRM_LICENSE_STATE_COUNT_FROM_UNTIL;
        f_pstatedata->dwNumDates    = 2;
        MEMCPY( &f_pstatedata->datetime[0], f_pftBeginDate, SIZEOF( DRMFILETIME ) );
        MEMCPY( &f_pstatedata->datetime[1], f_pftEndDate,   SIZEOF( DRMFILETIME ) );
        break;
    }
}

/*****************************************************************************/

#if DRM_SUPPORT_PMLICENSE
static DRM_BOOL _HaveRights(
    IN const DRM_BYTE f_pbCriteria[__CB_DECL(RIGHTS_LEN)],
    IN const DRM_BYTE f_pbRights  [__CB_DECL(RIGHTS_LEN)] )
{
    DRM_BYTE rgbCrit[__CB_DECL(RIGHTS_LEN)]; /* Local copy. */
    DRM_BYTE rgbTemp[__CB_DECL(RIGHTS_LEN)] = {0};
    DRM_BYTE bTemp = 0;
    DRM_SHORT i;

    MEMCPY( rgbCrit, f_pbCriteria, RIGHTS_LEN );

    /* Check if all bits are 0. If then, indicate that the right is not allowed. */
    /* This is to prevent from reporting TRUE for non-existing rights. */

    if( MEMCMP( rgbCrit, rgbTemp, RIGHTS_LEN ) == 0 )
    {
        return FALSE;
    }

    /* It is not all 0. Check if the rights requested exist. */
    /* Handle backup bit separately since the logic in for loop below does not work for this case. */
    if( ( GET_BYTE( rgbCrit,    0 ) & GET_BYTE( RIGHT_NO_RESTORE, 0 ) )
     && ( GET_BYTE( f_pbRights, 0 ) & GET_BYTE( RIGHT_NO_RESTORE, 0 ) ) )
    {
        /* We want backup/restore but the license does not have it. */
        return FALSE;
    }

    /* Set the backup/restore bit to 0 since we don't care about it anymore.     */
    bTemp  =  GET_BYTE( rgbCrit,          0 );
    bTemp &= ~GET_BYTE( RIGHT_NO_RESTORE, 0 );
    PUT_BYTE( rgbCrit, 0, bTemp );

    for( i = 0; i < RIGHTS_LEN; i++ )
    {
        bTemp = GET_BYTE( rgbCrit, i );
        if( ( bTemp & GET_BYTE( f_pbRights, i ) ) != bTemp )
        {
            return FALSE;
        }
    }
    return TRUE;
}

/*****************************************************************************/

static DRMINLINE DRM_BOOL _HaveRightsLong(
    IN const DRM_BYTE f_pbCriteria[__CB_DECL(RIGHTS_LEN)],
    IN       DRM_LONG f_lRights )
{
    DRM_BYTE  rgbRights[__CB_DECL(RIGHTS_LEN)];

    PUT_BYTE( rgbRights, 0, (DRM_BYTE)((f_lRights >>  0) & 0x00FF) );
    PUT_BYTE( rgbRights, 1, (DRM_BYTE)((f_lRights >>  8) & 0x00FF) );
    PUT_BYTE( rgbRights, 2, (DRM_BYTE)((f_lRights >> 16) & 0x00FF) );
    PUT_BYTE( rgbRights, 3, (DRM_BYTE)((f_lRights >> 24) & 0x00FF) );

    return _HaveRights( f_pbCriteria, rgbRights );
}

#endif /* DRM_SUPPORT_PMLICENSE */



/*****************************************************************************/

static DRM_RESULT _GetV2LicenseInfo(
    IN OUT   DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN const DRM_CONST_STRING        *f_pdstrLicense,
       OUT   LicenseInfo             *f_plicenseInfo,
    IN const DRM_CONST_STRING        *f_pdstrAction,
    IN       DRM_SECSTORE_CONTEXT    *f_pcontextSST )
{
    DRM_RESULT              dr               = DRM_SUCCESS;
    DRM_CONST_STRING        dstrCountString  = EMPTY_DRM_STRING;
    const DRM_CONST_STRING *pdstrCountString = NULL;
    DRM_WCHAR               rgwchCountString[100];
    DRM_DWORD               dwDeleted        = 0;
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
    DRM_BOOL                fCheckRollback   = FALSE;
#endif /* DRM_SUPPORT_ANTIROLLBACK_CLOCK */

    ZEROMEM( f_plicenseInfo, SIZEOF( LicenseInfo ) );
    _InitInfDate( &f_plicenseInfo->endDate );
    f_plicenseInfo->dwCategory = LIC_TYPE_EXPIRY; /* Treat all licenses as expiry license for now.  */

    /* RETRIEVE ATTRIBUTES ONE BY ONE AND SET THE FIELDS. */

    /* Check for license deleted */
    if( ( DRM_SUCCESS == _GetSecStateAttr( f_pcontextSST, &g_dstrDRM_LS_DELETED_ATTR, &dwDeleted, NULL ) )
     && ( dwDeleted != 0 ) )
    {
        /* This license is deleted - we can't get any info about it */
        dr = DRM_S_FALSE;
        goto ErrorExit;
    }

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
    if( f_pcontextLQ->pLicEval->fLicenseIsXMR )
    {
        if( XMR_HAS_TIME_BASED_RESTRICTIONS( f_pcontextLQ->pLicEval->plicenseXMR ) )
        {
            /*
            ** Always check rollback for XMR licenses with
            ** time-based restrictions
            */
            fCheckRollback = TRUE;
        }
    }
    else
    {
        DRM_CONST_STRING    dstrExpr    = EMPTY_DRM_STRING;
        /*
        ** For XML licenses, there are 3 possibilities:
        ** 1. No action on clock rollback
        **      In this case, this call will fail or not init dstrExpr
        ** 2. Delete on rollback
        **      If in rollback, the license is deleted and we caught it above
        **      Else, we won't get a value for OldSaveTime below and
        **            we won't actually check for rollback below
        ** 3. Disable on rollback
        **      If in rollback, we'll get a value for OldSaveTime below and
        **            we'll actually check for rollback below and
        **            we'll recognize rollback and disable the license
        **      Else, we'll get a value for OldSaveTime below and
        **            we'll actually check for rollback below but
        **            we'll recognize that rollback did not occur
        ** Therefore, it's safe to check for rollback any time
        **  this call succeeds and inits dstrExpr
        */
        dr = DRM_LIC_GetEvent( &(f_pcontextLQ->pLicEval->dstrContentLicense),
                               &g_dstrLicEvalOnClockRollback,
                                NULL,
                                NULL,
                                NULL,
                               &dstrExpr,
                                NULL);
        if( DRM_SUCCEED