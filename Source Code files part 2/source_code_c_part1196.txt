ore than one.

    PeripheralInformation - Arrya of pointers to the three pieces of
                            registry information.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the adapter object, or
    all of the resource information couldn't be acquired.

--*/
{

    PFDC_FDO_EXTENSION fdoExtension = (PFDC_FDO_EXTENSION)Context;
    NTSTATUS ntStatus;
    UNICODE_STRING pdoName;
    PDEVICE_OBJECT newPdo;
    PFDC_PDO_EXTENSION pdoExtension;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    ULONG apiSupported;
    WCHAR idstr[200];
    UNICODE_STRING str;
    USHORT i;
    BOOLEAN foundPort = FALSE;
    BOOLEAN foundInterrupt = FALSE;
    BOOLEAN foundDma = FALSE;

    FdcDump( FDCSHOW, ("FdcFdoConfigCallBack:\n") );

    //
    //  The first thing to do is to go out and look for an enabler.  We
    //  know we are dealing with one if there is a registry value called
    //  APISupported.
    //
    str.Length = 0;
    str.MaximumLength = 200;
    str.Buffer = idstr;

    RtlZeroMemory( &paramTable[0], sizeof(paramTable) );

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"APISupported";
    paramTable[0].EntryContext = &str;
    paramTable[0].DefaultType = REG_SZ;
    paramTable[0].DefaultData = L"";
    paramTable[0].DefaultLength = sizeof(WCHAR);

    ntStatus = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                       PathName->Buffer,
                                       &paramTable[0],
                                       NULL,
                                       NULL);
    if ( !NT_SUCCESS( ntStatus ) ) {
        str.Buffer[0] = 0;
    }

    if ( str.Buffer[0] != 0 ) {

        FdcDump(FDCINFO,
               ("FdcFdoConfigCallBack: Got registry setting for EnablerAPI = %ls\n",
                (ULONG_PTR)str.Buffer) );

        ntStatus = IoGetDeviceObjectPointer( &str,
                                             FILE_READ_ACCESS,
                                             &fdoExtension->FdcEnablerFileObject,
                                             &fdoExtension->FdcEnablerDeviceObject);
    }

    if ( fdoExtension->FdcEnablerDeviceObject != NULL ) {

        PCM_FULL_RESOURCE_DESCRIPTOR controllerData =
            (PCM_FULL_RESOURCE_DESCRIPTOR)
            (((PUCHAR)ControllerInformation[IoQueryDeviceConfigurationData]) +
            ControllerInformation[IoQueryDeviceConfigurationData]->DataOffset);

        //
        // We have the pointer.  Save off the interface type and
        // the busnumber for use when we call the Hal and the
        // Io System.
        //
        fdoExtension->BusType = BusType;
        fdoExtension->BusNumber = BusNumber;
        fdoExtension->SharableVector = TRUE;
        fdoExtension->SaveFloatState = FALSE;

        //
        // We need to get the following information out of the partial
        // resource descriptors.
        //
        // The irql and vector.
        //
        // The dma channel.
        //
        // The base address and span covered by the floppy controllers
        // registers.
        //
        // It is not defined how these appear in the partial resource
        // lists, so we will just loop over all of them.  If we find
        // something we don't recognize, we drop that information on
        // the floor.  When we have finished going through all the
        // partial information, we validate that we got the above
        // three.
        //
        for ( i = 0;
              i < controllerData->PartialResourceList.Count;
              i++ ) {

            PCM_PARTIAL_RESOURCE_DESCRIPTOR partial =
                &controllerData->PartialResourceList.PartialDescriptors[i];

            switch ( partial->Type ) {

            case CmResourceTypePort: {

                foundPort = TRUE;

                //
                // Save of the pointer to the partial so
                // that we can later use it to report resources
                // and we can also use this later in the routine
                // to make sure that we got all of our resources.
                //
                fdoExtension->SpanOfControllerAddress = partial->u.Port.Length;
                fdoExtension->ControllerAddress.StatusA =
                    FdcGetControllerBase(
                        BusType,
                        BusNumber,
                        partial->u.Port.Start,
                        fdoExtension->SpanOfControllerAddress,
                        (BOOLEAN)!!partial->Flags );

                if ( fdoExtension->ControllerAddress.StatusA == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    fdoExtension->ControllerAddress.StatusB       = fdoExtension->ControllerAddress.StatusA + 1;
                    fdoExtension->ControllerAddress.DriveControl  = fdoExtension->ControllerAddress.StatusA + 2;
                    fdoExtension->ControllerAddress.Tape          = fdoExtension->ControllerAddress.StatusA + 3;
                    fdoExtension->ControllerAddress.Status        = fdoExtension->ControllerAddress.StatusA + 4;
                    fdoExtension->ControllerAddress.Fifo          = fdoExtension->ControllerAddress.StatusA + 5;
                    fdoExtension->ControllerAddress.DRDC.DataRate = fdoExtension->ControllerAddress.StatusA + 7;

                }

                break;
            }
            case CmResourceTypeInterrupt: {

                foundInterrupt = TRUE;

                if ( partial->Flags & CM_RESOURCE_INTERRUPT_LATCHED ) {

                    fdoExtension->InterruptMode = Latched;

                } else {

                    fdoExtension->InterruptMode = LevelSensitive;

                }

                fdoExtension->ControllerVector =
                    HalGetInterruptVector(
                        BusType,
                        BusNumber,
                        partial->u.Interrupt.Level,
                        partial->u.Interrupt.Vector,
                        &fdoExtension->ControllerIrql,
                        &fdoExtension->ProcessorMask
                        );

                break;
            }
            case CmResourceTypeDma: {

                DEVICE_DESCRIPTION deviceDesc = {0};

                //
                // Use IgnoreCount equal to TRUE to fix PS/1000.
                //
                foundDma = TRUE;

                deviceDesc.Version = DEVICE_DESCRIPTION_VERSION1;

                if ( partial->u.Dma.Channel > 3 ) {
                    deviceDesc.DmaWidth = Width16Bits;
                } else {
                    deviceDesc.DmaWidth = Width8Bits;
                }

                deviceDesc.DemandMode    = TRUE;
                deviceDesc.MaximumLength = MAX_BYTES_PER_SECTOR * MAX_SECTORS_PER_TRACK;
                deviceDesc.IgnoreCount   = TRUE;

                deviceDesc.DmaChannel = partial->u.Dma.Channel;
                deviceDesc.InterfaceType = BusType;
                deviceDesc.DmaSpeed = DEFAULT_DMA_SPEED;
                fdoExtension->AdapterObject =
                    HalGetAdapter(
                        &deviceDesc,
                        &fdoExtension->NumberOfMapRegisters
                        );

                if ( fdoExtension->AdapterObject == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                break;
            }
            default:

                break;
            }
        }
        //
        // If we didn't get all the information then we return
        // insufficient resources.
        //
        if ( !foundPort || !foundInterrupt || !foundDma ) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return ntStatus;
}

PVOID
FdcGetControllerBase(
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InIoSpace
    )
/*++

Routine Description:

    This routine maps an IO address to system address space.

Arguments:

    BusType - what type of bus - eisa, mca, isa
    IoBusNumber - which IO bus (for machines with multiple buses).
    IoAddress - base device address to be mapped.
    NumberOfBytes - number of bytes for which address is valid.
    InIoSpace - indicates an IO address.

Return Value:

    Mapped address

--*/
{
    PHYSICAL_ADDRESS cardAddress;
    ULONG addressSpace = InIoSpace;
    PVOID Address;

    if ( !HalTranslateBusAddress( BusType,
                                  BusNumber,
                                  IoAddress,
                                  &addressSpace,
                                  &cardAddress ) ){
        return NULL;
    }

    //
    // Map the device base address into the virtual address space
    // if the address is in memory space.
    //

    if ( !addressSpace ) {

        Address = MmMapIoSpace( cardAddress,
                                NumberOfBytes,
                                FALSE );

    } else {

        Address = (PCONTROLLER)cardAddress.LowPart;
    }
    return Address;
}

NTSTATUS
FcAllocateCommonBuffers(
    IN PFDC_FDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine allocates buffers for use by a tape drive if
    there is one.  These buffers will later be deallocated if
    no device claims them within a reasonable amount of time.
    This routine starts a thread that will set a timer to
    free up the unclaimed buffers.

Arguments:

    FdoExtension - A pointer to our extension data.

Return Value:

--*/
{
    PTRANSFER_BUFFER transferBuffers;
    PHYSICAL_ADDRESS paddress;
    PVOID address;
    ULONG count = 0;
    HANDLE      threadHandle;
    NTSTATUS ntStatus;

    FdoExtension->BufferSize = BufferSize;

    if ( NumberOfBuffers == 0 || BufferSize == 0 ) {

        FdoExtension->BufferCount = 0;
        return STATUS_SUCCESS;
    }

    transferBuffers = ExAllocatePool( NonPagedPool,
                                     sizeof(TRANSFER_BUFFER) * NumberOfBuffers);

    if ( transferBuffers == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    FdoExtension->TransferBuffers = transferBuffers;

    do {
        address = HalAllocateCommonBuffer( FdoExtension->AdapterObject,
                                           BufferSize,
                                           &paddress,
                                           FALSE );
        if (address != NULL) {
            transferBuffers[count].Virtual = address;
            transferBuffers[count].Logical = paddress;
            ++FdoExtension->BufferCount;
        }
    } while ( ++count < NumberOfBuffers && address != NULL );

    if ( FdoExtension->BufferCount == 0 ) {

        ExFreePool(transferBuffers);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (FdoExtension->BufferCount > 0) {

        FdoExtension->TapeEnumerationPending = TRUE;

        KeResetEvent( &FdoExtension->TapeEnumerationEvent );

        ntStatus = PsCreateSystemThread( &threadHandle,
                                        (ACCESS_MASK) 0L,
                                        NULL,
                                        NULL,
                                        NULL,
                                        (PKSTART_ROUTINE)FdcBufferThread,
                                        FdoExtension);

        ZwClose(threadHandle);

    }

    return STATUS_SUCCESS;
}

VOID
FdcBufferThread(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine starts a timer then, after the timer expires,
    it attempts to enumerate any floppy tape drives that may be
    present on the floppy bus.  If no tape drives are found it frees
    up the tape buffers that were allocated earlier.

Arguments:

    Context - A pointer to our extension data.

Return Value:

--*/
{
    NTSTATUS ntStatus;
    PFDC_FDO_EXTENSION fdoExtension;
    LARGE_INTEGER bufferTimeout;
    ULONG i;

    fdoExtension = (PFDC_FDO_EXTENSION)Context;

    KeInitializeTimer( &fdoExtension->BufferTimer );

    bufferTimeout.QuadPart = -((LONGLONG)ONE_SECOND * (LONGLONG)60); // 10 Minutes

    KeSetTimer ( &fdoExtension->BufferTimer,
                 bufferTimeout,
                 NULL );

    KeWaitForSingleObject( &fdoExtension->BufferTimer,
                           Executive,
                           KernelMode,
                           FALSE,
                           &bufferTimeout );

    ntStatus = FdcEnumerateQ117( fdoExtension );

    if ( !NT_SUCCESS(ntStatus) ) {

        for ( i = fdoExtension->BuffersRequested ;
              i < fdoExtension->BufferCount ;
              i++) {

            HalFreeCommonBuffer( fdoExtension->AdapterObject,
                                 fdoExtension->BufferSize,
                                 fdoExtension->TransferBuffers[i].Logical,
                                 fdoExtension->TransferBuffers[i].Virtual,
                                 FALSE );

        }
        fdoExtension->BufferCount = 0;
    }

    fdoExtension->TapeEnumerationPending = FALSE;

    PsTerminateSystemThread( STATUS_SUCCESS );
}
NTSTATUS
FdcEnumerateQ117(
    IN PFDC_FDO_EXTENSION FdoExtension
    )
{
    NTSTATUS ntStatus;
    CqdContextPtr qicCqdContext;
    KdiContextPtr qicKdiContext;
    BOOLEAN vendorDetected;

    if (IsNEC_98) {
        //
        // NEC98 have no tape which is controlled by FDC.
        //

        return STATUS_UNSUCCESSFUL;

    } // (IsNEC_98)

    //
    //  Initiate the QIC-117 find sequence to attempt to find any floppy
    //  tape drives attached to this controller.
    //
    //  First allocate and initialize a context for the find operation.
    //
    qicCqdContext = ExAllocatePool( NonPagedPool, sizeof(CqdContext) );

    if ( qicCqdContext == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( qicCqdContext, sizeof(CqdContext) );

    qicKdiContext = ExAllocatePool( NonPagedPool, sizeof(KdiContext) );

    if ( qicKdiContext == NULL ) {
        ExFreePool( qicCqdContext );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( qicKdiContext, sizeof(KdiContext) );

    cqd_InitializeContext( qicCqdContext, qicKdiContext );

    qicKdiContext->controller_data.fdcDeviceObject = FdoExtension->Self;
    qicCqdContext->device_descriptor.fdc_type = FdoExtension->FdcType;

    if ( !FdoExtension->FdcEnablerSupported ) {

        //
        //  If we are not already an enabler FDO, query the registry hardware
        //  tree to find out how many floppy controllers have been registered.
        //  We only ever expect 1 unless a tape enabler card has been
        //  installed.
        //
        INTERFACE_TYPE InterfaceType;

        for ( InterfaceType = 0;
              InterfaceType < MaximumInterfaceType;
              InterfaceType++ ) {

            CONFIGURATION_TYPE Dc = DiskController;

            ntStatus = IoQueryDeviceDescription( &InterfaceType,
                                                 NULL,
                                                 &Dc,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 FdcBusConfigCallBack,
                                                 FdoExtension );

            if (!NT_SUCCESS(ntStatus) && (ntStatus != STATUS_OBJECT_NAME_NOT_FOUND)) {

                return ntStatus;
            }
        }
    }

    ntStatus = FcAcquireFdc( FdoExtension, NULL );

    if ( NT_SUCCESS(ntStatus) ) {

        ntStatus = cqd_LocateDevice( qicCqdContext, &vendorDetected );

        if ( ntStatus != STATUS_SUCCESS ) {
          ntStatus = STATUS_UNSUCCESSFUL;
        }

        FcReleaseFdc( FdoExtension );
    }

    KeSetEvent( &FdoExtension->TapeEnumerationEvent, 0, FALSE );

    if ( NT_SUCCESS(ntStatus) ) {

        UNICODE_STRING pdoName;
        WCHAR pdoNameBuffer[32];
        USHORT nameIndex = 0;
        PDEVICE_OBJECT newPdo;
        PFDC_PDO_EXTENSION pdoExtension;

        do {
            swprintf(pdoNameBuffer, L"\\Device\\q117PDO%d", nameIndex++);
            RtlInitUnicodeString(&pdoName, pdoNameBuffer);

            ntStatus = IoCreateDevice( FdoExtension->Self->DriverObject,
                                       sizeof(FDC_PDO_EXTENSION),
                                       &pdoName,
                                       FILE_DEVICE_TAPE,
                                       (FILE_REMOVABLE_MEDIA |
                                        FILE_DEVICE_SECURE_OPEN),
                                       FALSE,
                                       &newPdo);

        } while ( ntStatus == STATUS_OBJECT_NAME_COLLISION );

        FdcDump( FDCSHOW, ("FdcBufferThread: Created Device %d\n", nameIndex) );

        if ( NT_SUCCESS(ntStatus) ) {

            pdoExtension = (PFDC_PDO_EXTENSION) newPdo->DeviceExtension;

            pdoExtension->TargetObject = FdoExtension->Self;

            pdoExtension->IsFDO = FALSE;
            pdoExtension->Self = newPdo;
            pdoExtension->DeviceType = FloppyTapeDevice;

            if ( vendorDetected ) {
                pdoExtension->TapeVendorId = (qicCqdContext->device_descriptor.vendor << 6)
                                               + qicCqdContext->device_descriptor.model;
            } else {
                pdoExtension->TapeVendorId = -1;
            }

            pdoExtension->ParentFdo = FdoExtension->Self;

            pdoExtension->Instance = nameIndex;
            pdoExtension->Removed = FALSE; // no irp_mn_remove as of yet

            newPdo->StackSize += FdoExtension->Self->StackSize;
            newPdo->Flags &= ~DO_DEVICE_INITIALIZING;
            newPdo->Flags |= DO_POWER_PAGABLE;

            InsertTailList(&FdoExtension->PDOs, &pdoExtension->PdoLink);
            FdoExtension->NumPDOs++;

            IoInvalidateDeviceRelations (FdoExtension->UnderlyingPDO, BusRelations);
        }
    }

    return ntStatus;
}

NTSTATUS
FcInitializeControllerHardware(
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is called at initialization time by FcInitializeDevice()
    - once for each controller that we have to support.

    When this routine is called, the controller data structures have all
    been allocated.

Arguments:

    ControllerData - the completed data structure associated with the
    controller hardware being initialized.

    DeviceObject - a pointer to a device object; this routine will cause
    an interrupt, and the ISR requires CurrentDeviceObject to be filled
    in.

Return Value:

    STATUS_SUCCESS if this controller appears to have been reset properly,
    error otherwise.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    UCHAR statusRegister0;
    UCHAR cylinder;
    UCHAR driveNumber;
    UCHAR retrycnt;

    FdcDump( FDCSHOW, ("Fdc: FcInitializeControllerHardware...\n") );

    for (retrycnt = 0; ; retrycnt++) {

        //
        // Reset the controller.  This will cause an interrupt.  Reset
        // CurrentDeviceObject until after the 10ms wait, in case any
        // stray interrupts come in.
        //
        DISABLE_CONTROLLER_IMAGE (FdoExtension);

        WRITE_CONTROLLER(
            FdoExtension->ControllerAddress.DriveControl,
            FdoExtension->DriveControlImage );

        KeStallExecutionProcessor( 10 );

        FdoExtension->CurrentDeviceObject = DeviceObject;
        FdoExtension->AllowInterruptProcessing = TRUE;
        FdoExtension->CommandHasResultPhase = FALSE;
        KeResetEvent( &FdoExtension->InterruptEvent );

        ENABLE_CONTROLLER_IMAGE (FdoExtension);

        WRITE_CONTROLLER(
            FdoExtension->ControllerAddress.DriveControl,
            FdoExtension->DriveControlImage );

        if (IsNEC_98) {
            //
            // NEC98 don't have to wait for interrupt.
            //

            ntStatus = STATUS_SUCCESS;

        } else { // (IsNEC_98)
            //
            // Wait for an interrupt.  Note that STATUS_TIMEOUT and
            // STATUS_SUCCESS are the only possible return codes, since we
            // aren't alertable and won't get APCs.
            //
            ntStatus = KeWaitForSingleObject( &FdoExtension->InterruptEvent,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              &FdoExtension->InterruptDelay );
        } // (IsNEC_98)

        if (ntStatus == STATUS_TIMEOUT) {

            if (retrycnt >= 1) {
                break;
            }

            // Retry reset after configure command to enable polling
            // interrupt.

            FdoExtension->FifoBuffer[0] = COMMND_CONFIGURE;

            if (FdoExtension->Clock48MHz) {
                FdoExtension->FifoBuffer[0] |= COMMND_OPTION_CLK48;
            }

            FdoExtension->FifoBuffer[1] = 0;
            FdoExtension->FifoBuffer[2] = COMMND_CONFIGURE_FIFO_THRESHOLD;
            FdoExtension->FifoBuffer[3] = 0;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if (!NT_SUCCESS(ntStatus)) {
                ntStatus = STATUS_TIMEOUT;
                break;
            }

            KeStallExecutionProcessor( 500 );

        } else {

            break;

        }
    }

    if ( ntStatus == STATUS_TIMEOUT ) {

        //
        // Change info to an error.
        //

        ntStatus = STATUS_IO_TIMEOUT;

        FdoExtension->HardwareFailed = TRUE;
    }

    if ( !NT_SUCCESS( ntStatus ) ) {

        FdcDump(FDCDBGP,("Fdc: controller didn't interrupt after reset\n"));

        return ntStatus;
    }

    if (!IsNEC_98) {

        ntStatus = FcFinishReset( FdoExtension );

    } // (!IsNEC_98)

    return ntStatus;
}

NTSTATUS
FcGetFdcInformation(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine will attempt to identify the type of Floppy Controller

Arguments:

    FdoExtension - a pointer to our data area for the drive being
    accessed (any drive if a controller command is being given).

Return Value:

--*/
{
    NTSTATUS ntStatus;
    FDC_INFORMATION fdcInfo;

    if (FdoExtension->FdcEnablerSupported) {

        fdcInfo.structSize = sizeof(fdcInfo);

        ntStatus = FcFdcEnabler( FdoExtension->FdcEnablerDeviceObject,
                                 IOCTL_GET_FDC_INFO,
                                 &fdcInfo);

        if ( NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FdcType = (UCHAR)fdcInfo.FloppyControllerType;
            FdoExtension->Clock48MHz =
                            (fdcInfo.ClockRatesSupported == FDC_CLOCK_48MHZ);
            FdoExtension->FdcSpeeds = (UCHAR)fdcInfo.SpeedsAvailable;

        }

    } else {

        //
        // First, assume that we don't know what kind of FDC is attached.
        //

        FdoExtension->FdcType = FDC_TYPE_UNKNOWN;


        // Check for an enhanced type controller by issuing the version command.

        FdoExtension->FifoBuffer[0] = COMMND_VERSION;

        ntStatus = FcIssueCommand( FdoExtension,
                                FdoExtension->FifoBuffer,
                                FdoExtension->FifoBuffer,
                                NULL,
                                0,
                                0 );

        if ( NT_SUCCESS( ntStatus ) ) {

            if (FdoExtension->FifoBuffer[0] == VALID_NEC_FDC) {

                FdoExtension->FdcType = FDC_TYPE_ENHANCED;

            } else {

                FdoExtension->FdcType = FDC_TYPE_NORMAL;

            }
        }

        // Determine if the controller is a National 8477 by issuing the NSC
        // command which is specific to National parts and returns 0x71. (This
        // command happens to be the same as the Intel Part ID command so we
        // will use it instead.) The lower four bits are subject to change by
        // National and will reflect the version of the part in question.  At
        // this point we will only test the high four bits.

        if ( FdoExtension->FdcType == FDC_TYPE_ENHANCED &&
             NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FifoBuffer[0] = COMMND_PART_ID;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if ( NT_SUCCESS( ntStatus ) ) {

                if ( (FdoExtension->FifoBuffer[0] & NSC_MASK) ==
                     NSC_PRIMARY_VERSION) {

                    FdoExtension->FdcType = FDC_TYPE_NATIONAL;

                }
            }
        }

        // Determine if the controller is an 82077 by issuing the perpendicular
        // mode command which at this time is only valid on 82077's.

        if ( FdoExtension->FdcType == FDC_TYPE_ENHANCED &&
             NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FifoBuffer[0] = COMMND_PERPENDICULAR_MODE;
            FdoExtension->FifoBuffer[1] = COMMND_PERPENDICULAR_MODE_OW;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if (ntStatus != STATUS_DEVICE_NOT_READY) {

                FdoExtension->FdcType = FDC_TYPE_82077;

            }
        }

        // Determine if the controller is an Intel 82078 by issuing the part id
        // command which is specific to Intel 82078 parts.

        if ( FdoExtension->FdcType == FDC_TYPE_82077 &&
             NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FifoBuffer[0] = COMMND_PART_ID;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if ( NT_SUCCESS( ntStatus ) ) {

                if ((FdoExtension->FifoBuffer[0] & INTEL_MASK) ==
                    INTEL_64_PIN_VERSION) {

                    FdoExtension->FdcType = FDC_TYPE_82078_64;
                } else {
                    if ((FdoExtension->FifoBuffer[0] & INTEL_MASK) ==
                        INTEL_44_PIN_VERSION) {

                        FdoExtension->FdcType = FDC_TYPE_82078_44;
                    }
                }
            }
        }

        switch (FdoExtension->FdcType) {

        case FDC_TYPE_UNKNOWN   :
        case FDC_TYPE_NORMAL    :
        case FDC_TYPE_ENHANCED  :
        default:

            FdoExtension->FdcSpeeds = FDC_SPEED_250KB |
                                      FDC_SPEED_300KB |
                                      FDC_SPEED_500KB;
            break;

        case FDC_TYPE_82077     :
        case FDC_TYPE_82077AA   :
        case FDC_TYPE_82078_44  :
        case FDC_TYPE_NATIONAL  :

            FdoExtension->FdcSpeeds = FDC_SPEED_250KB |
                                      FDC_SPEED_300KB |
                                      FDC_SPEED_500KB |
                                      FDC_SPEED_1MB;
            break;

        case FDC_TYPE_82078_64  :

            FdoExtension->FdcSpeeds = FDC_SPEED_250KB |
                                      FDC_SPEED_300KB |
                                      FDC_SPEED_500KB |
                                      FDC_SPEED_1MB;

            if ( FdoExtension->Clock48MHz ) {

                FdoExtension->FdcSpeeds |= FDC_SPEED_2MB;
            }

            break;
        }
    }

    FdcDump( FDCINFO, ("Fdc: FdcType - %x\n", FdoExtension->FdcType));

    return ntStatus;
}
#define IO_PORT_REQ_MASK 0xbc

NTSTATUS
FdcFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine examines the supplied resource list and adds resources if
    necessary.  The only resources that it is concerned with adding are io port
    resources.  Adding io port resources is necessary because of different bios
    configurations and specifications.

    The PC97(98) hardware specification defines only 3f2, 3f4, and 3f5 as
    io port resources for standard floppy controllers (based on IBM PC floppy
    controller configurations).  In addition to these resources, fdc.sys
    requires 3f7 for disk change detection and data rate programming and
    optionally 3f3 for floppy tape support.  In addition, some bioses define
    aliased resources (e.g. 3f2 & 7f2, etc.)

    This routine first forwards the irp to the underlying PDO.  Upon return,
    it examines the io resource list to determine if any additional resources
    will be required.  It maintains a linked list of all io port base addresses
    that it encounters, assuming that they define aliased resources.  N.B. - if
    alternative lists are present in the io resource requirements list, only the
    first list is examined.  If additional resources are required a new io
    resource list is created.  The first io resource list in the new resource
    requirements list will contain the original resources as well as the
    additional resources required.  If it was necessary to request the tape mode
    register (3f3), i.e. 3f3 was not in the original list, a second list is
    generated that is identical to the first new list except that 3f3 is excluded.
    This list is for the case where the tape mode register is not available.
    Finally, the original list(s) is(are) copied to the end of the new list and
    are treated as alternative io resource lists.

Arguments:

    DeviceObject - a pointer to the device object being started.
    Irp - a pointer to the start device Irp.

Return Value:

--*/
{
    NTSTATUS ntStatus;
    PFDC_FDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;
    PIO_RESOURCE_REQUIREMENTS_LIST resourceRequirementsIn;
    PIO_RESOURCE_REQUIREMENTS_LIST resourceRequirementsOut;
    ULONG listSize;
    ULONG i,j;
    PIO_RESOURCE_LIST ioResourceListIn;
    PIO_RESOURCE_LIST ioResourceListOut;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptorIn;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptorOut;
    LIST_ENTRY ioPortList;
    PLIST_ENTRY links;
    PIO_PORT_INFO ioPortInfo;
    BOOLEAN foundBase;
    ULONG newDescriptors;
    BOOLEAN interruptResource = FALSE;
    BOOLEAN dmaResource = FALSE;
    UCHAR newPortMask;
    BOOLEAN requestTapeModeRegister = FALSE;
    USHORT in,out;

#ifdef TOSHIBAJ
    BOOLEAN foundConfigPort = FALSE;
    struct {
        ULONG start;
        ULONG length;
    } configNewPort = {0, 0};
#endif

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;
    InitializeListHead( &ioPortList );

    FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_FILTER_RESOURCE_REQUIREMENTS - Irp: %p\n", Irp) );

    //
    // Pass this irp down to the PDO before proceeding.
    //
    KeInitializeEvent( &doneEvent, NotificationEvent, FALSE );

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine( Irp,
                            FdcPnpComplete,
                            &doneEvent,
                            TRUE,
                            TRUE,
                            TRUE );

    ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

    if ( ntStatus == STATUS_PENDING ) {

        KeWaitForSingleObject( &doneEvent, Executive, KernelMode, FALSE, NULL );
    }

    //
    //  Modified resources are returned in Irp-IoStatus.Information, otherwise
    //  just use what's in the parameter list.
    //
    if ( Irp->IoStatus.Information == 0 ) {

        Irp->IoStatus.Information = (UINT_PTR)irpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;

        if ( Irp->IoStatus.Information == (UINT_PTR)NULL ) {
            //
            //  NULL List, the PDO freed the incoming resource list but did not
            //  provide a new list.  Complete the IRP with the PDO's status.
            //
            ntStatus = Irp->IoStatus.Status;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return( ntStatus );
        }

    }

    resourceRequirementsIn = (PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;

    FdcDump( FDCSHOW, ("Resource Requirements List = %p\n", resourceRequirementsIn) );

    if (IsNEC_98) {
        //
        // It is not necessary to modify the resources.
        //
        ntStatus = STATUS_SUCCESS;

        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return ntStatus;
    }

    //
    //  Make a pass through the resource list and determine what resources are
    //  already there as well as the base address for the io port and any
    //  alias ioports.
    //
    ioResourceListIn  = resourceRequirementsIn->List;
    ioResourceDescriptorIn  = ioResourceListIn->Descriptors;

    ntStatus = STATUS_SUCCESS;

    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: examining %d resources\n", ioResourceListIn->Count));

    for ( i = 0; i < ioResourceListIn->Count && NT_SUCCESS(ntStatus); i++ ) {

        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: IoResourceDescritporIn = %p\n",ioResourceDescriptorIn));

        switch ( ioResourceDescriptorIn->Type ) {

        case CmResourceTypeInterrupt:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found Interrupt Resource\n"));
            interruptResource = TRUE;
            break;

        case CmResourceTypeDma:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found Dma Resource \n"));
            dmaResource = TRUE;
            break;

        case CmResourceTypePort:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found Port Resource\n"));
            //
            //  For the ioPorts we will make a list containing each detected
            //  'base' address as well as the currently allocated addresses
            //  on that base.  Later we will use this to request additional
            //  resources if necessary.
            //
            //  First, if this base isn't already in the list, create a new
            //  list entry for it.
            //

            foundBase = FALSE;

            for ( links = ioPortList.Flink;
                  links != &ioPortList;
                  links = links->Flink) {

                ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Examining %p for match\n",ioPortInfo));
                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   Base Address = %08x\n",ioPortInfo->BaseAddress.LowPart));
                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   Desc Address = %08x\n",ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0xfffffff8));

                if ( ioPortInfo->BaseAddress.LowPart ==
                     (ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0xfffffff8) ) {

                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found %08x in the ioPortList\n",ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart));

                    foundBase = TRUE;
                    //
                    //  Add these resources into the resource map for this base
                    //  address.
                    //
                    for ( j = 0; j < ioResourceDescriptorIn->u.Port.Length; j++ ) {

                        ioPortInfo->Map |= 0x01 << ((ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0x07) + j);
                    }
                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: New IoPortInfo->Map = %x\n",ioPortInfo->Map));
                    break;
                }
            }

            if ( !foundBase ) {

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Creating new ioPortList entry for %08x\n",ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart));
                ioPortInfo = ExAllocatePool( PagedPool, sizeof(IO_PORT_INFO) );
                if ( ioPortInfo == NULL ) {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    RtlZeroMemory( ioPortInfo, sizeof(IO_PORT_INFO) );
                    ioPortInfo->BaseAddress = ioResourceDescriptorIn->u.Port.MinimumAddress;
                    ioPortInfo->BaseAddress.LowPart &= 0xfffffff8;
                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   Base Address = %08x\n",ioPortInfo->BaseAddress.LowPart));
                    for ( j = 0; j < ioResourceDescriptorIn->u.Port.Length; j++ ) {
                        ioPortInfo->Map |= 0x01 << ((ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0x07) + j);
                    }
                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   New IoPortInfo->Map = %x\n",ioPortInfo->Map));
                    InsertTailList( &ioPortList, &ioPortInfo->ListEntry );
                }
            }
            break;

        default:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found unknown resource\n"));
            break;
        }
        ioResourceDescriptorIn++;
    }

    //
    //  If we didn't see any io port resources, we will just return now
    //  since we can't be sure of what to ask for.  The subsequent start
    //  device will surely fail.  This also goes for the interrupt and
    //  dma resource.
    //
    if ( !NT_SUCCESS(ntStatus) ||
         IsListEmpty( &ioPortList ) ||
         !interruptResource ||
         !dmaResource ) {
        //
        //  Clean up the ioPortInfo list
        //
        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Bad Resources, Go directly to jail\n"));
        while ( !IsListEmpty( &ioPortList ) ) {
            links = RemoveHeadList( &ioPortList );
            ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);
            ExFreePool( ioPortInfo );
        }

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return ntStatus;
    }

#ifdef TOSHIBAJ
    if (SmcConfigBase) {
        PHYSICAL_ADDRESS    configPort;
        ULONG               ioSpace;

        // Map I/O port
        configPort.QuadPart = 0;
        configPort.LowPart = SmcConfigBase;
        ioSpace = 1;                       // I/O port
        if (HalTranslateBusAddress(resourceRequirementsIn->InterfaceType,
                                    resourceRequirementsIn->BusNumber,
                                    configPort,
                                    &ioSpace,
                                    &configPort)) {
            TranslatedConfigBase = (PUCHAR)configPort.LowPart;
            if (FcCheckConfigPort(TranslatedConfigBase)) {
            FdcDump( FDCINFO,
                ("FdcFilterResourceRequirements: Configuration port %x\n",
                TranslatedConfigBase) );
            } else {
                SmcConfigBase = 0;
                TranslatedConfigBase = NULL;
            }
        } else {
            SmcConfigBase = 0;
            TranslatedConfigBase = NULL;
        }
    }
#endif

    //
    //  At this point, we know what resources we are currently assigned so
    //  we can determine what additional resources we need to request.  We
    //  need to know the size of the list we need to create so first count
    //  the number of resource descriptors we will have to add to the current
    //  list.
    //
    newDescriptors = 0;

    for ( links = ioPortList.Flink;
          links != &ioPortList;
          links = links->Flink) {

        ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);

        newPortMask = ~ioPortInfo->Map & IO_PORT_REQ_MASK;

        if ( newPortMask & 0x08 ) {
            requestTapeModeRegister = TRUE;
        }

        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Counting bits in %x\n",newPortMask));

        while ( newPortMask > 0 ) {
            if ( newPortMask & 0x01 ) {
                newDescriptors++;
            }
            newPortMask >>= 1;
        }

#ifdef TOSHIBAJ
        // Are there configuration ports in assigned resources ?
        if (SmcConfigBase && (ioPortInfo->BaseAddress.LowPart == SmcConfigBase)) {
            foundConfigPort = TRUE;
            if (!(ioPortInfo->Map & 0x01)) {
                configNewPort.start = SmcConfigBase;
                ++configNewPort.length;
            }
            if (!(ioPortInfo->Map & 0x02)) {
                if (!configNewPort.start) {
                    configNewPort.start = SmcConfigBase + 1;
                }
                configNewPort.length++;
            }
        }
#endif
    }

#ifdef TOSHIBAJ
    // Deteremine the address and length of the additional descriptor
    // for configuration ports.
    if (SmcConfigBase && !foundConfigPort) {
        configNewPort.start = SmcConfigBase;
        configNewPort.length = 2;
    }
    if (configNewPort.start) {
        newDescriptors++;
    }
#endif

    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Create %d new descriptors\n", newDescriptors) );

    //
    //  If we need resources that were not in the list, we will need to
    //  allocate a new resource requirements list that includes these
    //  new resources.
    //
    if ( newDescriptors > 0 ) {

        //
        //  Allocate and initialize a resource requirements list.  Make it big
        //  enough to hold whatever was in the list to start with along with
        //  the new resource list.
        //
        listSize = resourceRequirementsIn->ListSize +
                   resourceRequirementsIn->ListSize +
                   newDescriptors * sizeof(IO_RESOURCE_DESCRIPTOR);

        //
        //  If we will be requesting the tape mode register we will need to
        //  make an alternate list without it in case we cannot get it.
        //
        if ( requestTapeModeRegister ) {

            listSize = listSize +
                       resourceRequirementsIn->ListSize +
                       newDescriptors * sizeof(IO_RESOURCE_DESCRIPTOR);
        }

        resourceRequirementsOut = ExAllocatePool( NonPagedPool, listSize );

        if ( resourceRequirementsOut == NULL ) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            RtlZeroMemory( resourceRequirementsOut, listSize);

            //
            //  Initialize the IO_RESOURCE_REQUIREMENTS_LIST header.
            //
            resourceRequirementsOut->ListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) -
                                                 sizeof(IO_RESOURCE_LIST);
            resourceRequirementsOut->InterfaceType = resourceRequirementsIn->InterfaceType;
            resourceRequirementsOut->BusNumber = resourceRequirementsIn->BusNumber;
            resourceRequirementsOut->SlotNumber = resourceRequirementsIn->SlotNumber;
            resourceRequirementsOut->Reserved[0] = resourceRequirementsIn->Reserved[0];
            resourceRequirementsOut->Reserved[1] = resourceRequirementsIn->Reserved[1];
            resourceRequirementsOut->Reserved[2] = resourceRequirementsIn->Reserved[2];
            resourceRequirementsOut->AlternativeLists = resourceRequirementsIn->AlternativeLists + 1;
            if ( requestTapeModeRegister ) {
                ++resourceRequirementsOut->AlternativeLists;
            }

            //
            //  Copy the primary list from the incoming IO_RESOURCE_REQUIREMENTS_LIST
            //  to the new list.
            //
            ioResourceListIn  = resourceRequirementsIn->List;
            ioResourceListOut = resourceRequirementsOut->List;

            listSize = sizeof(IO_RESOURCE_LIST) +
                      (ioResourceListIn->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);
            RtlCopyMemory( ioResourceListOut, ioResourceListIn, listSize );

            resourceRequirementsOut->ListSize += listSize;

            //
            //  Add any additional resources that we are requesting.
            //
            ioResourceDescriptorOut = (PIO_RESOURCE_DESCRIPTOR)((ULONG_PTR)resourceRequirementsOut +
                                                                       resourceRequirementsOut->ListSize);
            for ( links = ioPortList.Flink;
                  links != &ioPortList;
                  links = links->Flink) {

                ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);

                newPortMask = ~ioPortInfo->Map & IO_PORT_REQ_MASK;
                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add resource desc for each bit in %x\n",newPortMask));

                i = 0;
                while ( newPortMask != 0 ) {

                    if ( newPortMask & 0x01 ) {

                        ioResourceDescriptorOut->Option = IO_RESOURCE_PREFERRED;
                        ioResourceDescriptorOut->Type = CmResourceTypePort;
                        ioResourceDescriptorOut->ShareDisposition = CmResourceShareDeviceExclusive;
                        ioResourceDescriptorOut->Flags = CM_RESOURCE_PORT_IO;

                        ioResourceDescriptorOut->u.Port.Length = 1;
                        ioResourceDescriptorOut->u.Port.Alignment = 1;
                        ioResourceDescriptorOut->u.Port.MinimumAddress.QuadPart =
                        ioResourceDescriptorOut->u.Port.MaximumAddress.QuadPart =
                        ioPortInfo->BaseAddress.QuadPart + (ULONGLONG)i;

                        ++ioResourceListOut->Count;
                        resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_DESCRIPTOR);

                        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add resource descriptor: %p\n",ioResourceDescriptorOut));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Option           = %x\n",ioResourceDescriptorOut->Option          ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Type             = %x\n",ioResourceDescriptorOut->Type            ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->ShareDisposition = %x\n",ioResourceDescriptorOut->ShareDisposition));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Flags            = %x\n",ioResourceDescriptorOut->Flags           ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.Length    = %x\n",ioResourceDescriptorOut->u.Port.Length   ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.Alignment = %x\n",ioResourceDescriptorOut->u.Port.Alignment));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart = %08x\n",ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart));

                        ioResourceDescriptorOut++;
                    }
                    newPortMask >>= 1;
                    i++;
                }
            }

#ifdef TOSHIBAJ
            // Add the descriptor for configuration ports
            if (configNewPort.start) {
                ioResourceDescriptorOut->Option = IO_RESOURCE_PREFERRED;
                ioResourceDescriptorOut->Type = CmResourceTypePort;
                ioResourceDescriptorOut->ShareDisposition = CmResourceShareDeviceExclusive;
                ioResourceDescriptorOut->Flags = CM_RESOURCE_PORT_IO;

                ioResourceDescriptorOut->u.Port.Length = configNewPort.length;
                ioResourceDescriptorOut->u.Port.Alignment = 1;
                ioResourceDescriptorOut->u.Port.MinimumAddress.QuadPart =
                ioResourceDescriptorOut->u.Port.MaximumAddress.QuadPart = 0;
                ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart =
                    configNewPort.start;
                ioResourceDescriptorOut->u.Port.MaximumAddress.LowPart =
                    configNewPort.start + configNewPort.length - 1;

                ++ioResourceListOut->Count;
                resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_DESCRIPTOR);

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add resource descriptor: %p\n",ioResourceDescriptorOut));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Option           = %x\n",ioResourceDescriptorOut->Option          ));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Type             = %x\n",ioResourceDescriptorOut->Type            ));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->ShareDisposition = %x\n",ioResourceDescriptorOut->ShareDisposition));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Flags            = %x\n",ioResourceDescriptorOut->Flags           ));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.Length    = %x\n",ioResourceDescriptorOut->u.Port.Length   ));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.Alignment = %x\n",ioResourceDescriptorOut->u.Port.Alignment));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart = %08x\n",ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart));

                ioResourceDescriptorOut++;
            }
#endif

            if ( requestTapeModeRegister ) {

                ioResourceListIn = ioResourceListOut;
                ioResourceListOut = (PIO_RESOURCE_LIST)ioResourceDescriptorOut;

                ioResourceListOut->Version  = ioResourceListIn->Version;
                ioResourceListOut->Revision = ioResourceListIn->Revision;
                ioResourceListOut->Count    = 0;

                resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_LIST) -
                                                      sizeof(IO_RESOURCE_DESCRIPTOR);

                in = out = 0;

                do {

                    if ( (ioResourceListIn->Descriptors[in].Type != CmResourceTypePort) ||
                         ((ioResourceListIn->Descriptors[in].u.Port.MinimumAddress.LowPart & 0x07) != 0x03) ) {

                        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add %08x to alternate list\n", resourceRequirementsOut->List[0].Descriptors[out]));
                        ioResourceListOut->Descriptors[out++] = ioResourceListIn->Descriptors[in++];
                        ++ioResourceListOut->Count;
                        resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_DESCRIPTOR);
                    } else {
                        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Don't add %08x to alternate list\n", resourceRequirementsOut->List[0].Descriptors[out]));
                        in++;
                    }
                } while ( in < ioResourceListIn->Count );
            }

            //
            //  Copy the original list(s) to the end of our new list.
            //
            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Copy %d existing resource list(s)\n",resourceRequirementsIn->AlternativeLists));
            ioResourceListIn = resourceRequirementsIn->List;
            ioResourceListOut = (PIO_RESOURCE_LIST)((ULONG_PTR)resourceRequirementsOut +
                                                           resourceRequirementsOut->ListSize);

            for ( in = 0; in < resourceRequirementsIn->AlternativeLists; in++ ) {

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Copy list %p\n",ioResourceListIn));

                listSize = sizeof(IO_RESOURCE_LIST) +
                          (ioResourceListIn->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);
                RtlCopyMemory( ioResourceListOut, ioResourceListIn, listSize );

                ioResourceListOut = (PIO_RESOURCE_LIST)((ULONG_PTR)ioResourceListOut + listSize);
                ioResourceListIn = (PIO_RESOURCE_LIST)((ULONG_PTR)ioResourceListIn + listSize);
                resourceRequirementsOut->ListSize += listSize;
            }

            FdcDump( FDCSHOW, ("Resource Requirements List = %p\n", resourceRequirementsOut) );

            Irp->IoStatus.Information = (UINT_PTR)resourceRequirementsOut;

            //
            // Free the caller's list
            //
            ExFreePool( resourceRequirementsIn );
            ntStatus = STATUS_SUCCESS;
        }
    }
    //
    //  Clean up the ioPortInfo list
    //
    while ( !IsListEmpty( &ioPortList ) ) {
        links = RemoveHeadList( &ioPortList );
        ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);
        ExFreePool( ioPortInfo );
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return ntStatus;
}

NTSTATUS
FdcQueryDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine will report any devices that have been enumerated on the
    floppy controller.  If we don't know of any devices yet we will
    enumerate the registry hardware tree.

Arguments:

    DeviceObject - a pointer to the device object being started.
    Irp - a pointer to the start device Irp.

Return Value:

--*/
{
    PFDC_FDO_EXTENSION fdoExtension;
    PFDC_PDO_EXTENSION pdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    ULONG relationCount;
    ULONG relationLength;
    PDEVICE_RELATIONS relations;
    PLIST_ENTRY entry;

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;

    FdcDump( FDCSHOW, ("FdcQueryDeviceRelations:\n"));

    if ( irpSp->Parameters.QueryDeviceRelations.Type != BusRelations ) {
        //
        // We don't support this
        //
        FdcDump( FDCSHOW, ("FdcQueryDeviceRelations: Type = %d\n", irpSp->Parameters.QueryDeviceRelations.Type));

        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        return ntStatus;
    }

    //
    // Tell the plug and play system about all the PDOs.
    //
    // There might also be device relations below and above this FDO,
    // so, be sure to propagate the relations from the upper drivers.
    //

    //
    //  The current number of PDOs
    //
    relationCount = ( Irp->IoStatus.Information == 0 ) ? 0 :
        ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Count;

    //
    //  If we have not yet enumerated the hardware tree or all of our
    //  devices have been removed, enumerate it now.
    //
    if ( fdoExtension->NumPDOs == 0 ) {

        INTERFACE_TYPE InterfaceType;
        //
        //  Query the registry hardware tree to find out how many floppy
        //  drives were reported by the firmware.
        //
        for ( InterfaceType = 0;
              InterfaceType < MaximumInterfaceType;
              InterfaceType++ ) {

            CONFIGURATION_TYPE Dc = DiskController;
            CONFIGURATION_TYPE Fp = FloppyDiskPeripheral;

            ntStatus = IoQueryDeviceDescription(&InterfaceType,
                                              NULL,
                                              &Dc,
                                              NULL,
                                              &Fp,
                                              NULL,
                                              FdcConfigCallBack,
                                              fdoExtension );

            if (!NT_SUCCESS(ntStatus) && (ntStatus != STATUS_OBJECT_NAME_NOT_FOUND)) {

                return ntStatus;
            }
        }
    }

    FdcDump( FDCSHOW, ("FdcQueryDeviceRelations: My relations count - %d\n", fdoExtension->NumPDOs));

    relationLength = sizeof(DEVICE_RELATIONS) +
        (relationCount + fdoExtension->NumPDOs) * sizeof (PDEVICE_OBJECT);

    relations = (PDEVICE_RELATIONS) ExAllocatePool (NonPagedPool, relationLength);

    if ( relations == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy in the device objects so far
    //
    if ( relationCount ) {
        RtlCopyMemory( relations->Objects,
                       ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Objects,
                       relationCount * sizeof (PDEVICE_OBJECT));
    }
    relations->Count = relationCount + fdoExtension->NumPDOs;

    //
    // For each PDO on this bus add a pointer to the device relations
    // buffer, being sure to take out a reference to that object.
    // The PlugPlay system will dereference the object when it is done with
    // it and free the device relations buffer.
    //
    for (entry = fdoExtension->PDOs.Flink;
         entry != &fdoExtension->PDOs;
         entry = entry->Flink, relationCount++) {

        pdoExtension = CONTAINING_RECORD( entry, FDC_PDO_EXTENSION, PdoLink );
        relations->Objects[relationCount] = pdoExtension->Self;
        ObReferenceObject( pdoExtension->Self );
    }

    //
    // Set up and pass the IRP further down the stack
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    if ( Irp->IoStatus.Information != 0) {

        ExFreePool ((PVOID) Irp->IoStatus.Information);
    }

    Irp->IoStatus.Information = (UINT_PTR) relations;

    IoSkipCurrentIrpStackLocation( Irp );
    ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

    return ntStatus;
}

NTSTATUS
FdcBusConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
/*++

Routine Description:

    This routine is used to acquire all of the configuration
    information for a floppy disk controller.

Arguments:

    Context - Pointer to our FDO extension

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Should always be DiskController.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should always be FloppyDiskPeripheral.

    PeripheralNumber - Which floppy if this controller is maintaining
                       more than one.

    PeripheralInformation - Arrya of pointers to the three pieces of
                            registry information.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the adapter object, or
    all of the resource information couldn't be acquired.

--*/
{

    PFDC_FDO_EXTENSION fdoExtension = (PFDC_FDO_EXTENSION)Context;
    NTSTATUS ntStatus;
    UNICODE_STRING pdoName;
    PDEVICE_OBJECT newPdo;
    PFDC_PDO_EXTENSION pdoExtension;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    ULONG apiSupported;
    WCHAR idstr[200];
    UNICODE_STRING str;
    PFILE_OBJECT enablerFileObject;      // file object is not needed,  but returned by API
    PDEVICE_OBJECT enablerDeviceObject;
    BOOLEAN enablerSupported;

    FdcDump( FDCSHOW, ("FdcBusConfigCallBack:\n") );

    //
    //  The first thing to do is to go out and look for an enabler.  We
    //  know we are dealing with one if there is a registry value called
    //  APISupported.
    //
    str.Length = 0;
    str.MaximumLength = 200;
    str.Buffer = idstr;

    RtlZeroMemory( &paramTable[0], sizeof(paramTable) );

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"APISupported";
    paramTable[0].EntryContext = &str;
    paramTable[0].DefaultType = REG_SZ;
    paramTable[0].DefaultData = L"";
    paramTable[0].DefaultLength = sizeof(WCHAR);


    ntStatus = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                       PathName->Buffer,
                                       &paramTable[0],
                                       NULL,
                                       NULL);
    if ( !NT_SUCCESS( ntStatus ) ) {
        str.Buffer[0] = 0;
    }

    enablerSupported = FALSE;

    if (str.Buffer[0] != 0) {

        FdcDump(FDCINFO,
               ("FdcBusConfigCallBack: Got registry setting for EnablerAPI = %ls\n",
                (ULONG_PTR)str.Buffer) );

        ntStatus = IoGetDeviceObjectPointer( &str,
                                             FILE_READ_ACCESS,
                                             &enablerFileObject,
                                             &enablerDeviceObject);

        if ( NT_SUCCESS(ntStatus) ) {

            //
            //  Dereference the object since we don't need it any more.
            //
            ObDereferenceObject( enablerFileObject );
            enablerSupported = TRUE;

        } else {

            FdcDump( FDCDBGP,
                     ("FdcBusConfigCallBack: failed to open channel to device %ls\n",
                     (ULONG_PTR)str.Buffer) );
        }
    }

    //
    //  Only create a device here if we found an enabler device.  We assume that
    //  all of the legitimate floppy controllers have been or will be firmware
    //  enumerated.
    //
    if ( enablerSupported ) {

        RtlInitUnicodeString( &pdoName, L"\\Device\\TapeEnabler" );

        ntStatus = IoCreateDevice( fdoExtension->Self->DriverObject,
                                   sizeof(FDC_PDO_EXTENSION),
                                   &pdoName,
                                   FILE_DEVICE_BUS_EXTENDER,
                                   FILE_DEVICE_SECURE_OPEN,
                                   FALSE,
                                   &newPdo);

        FdcDump( FDCSHOW, ("FdcBusConfigCallBack: Created Tape Enabler Device\n") );

        if ( !NT_SUCCESS(ntStatus) ) {

            FdcDump( FDCSHOW, ("FdcBusConfigCallBack: Error - %08x\n", ntStatus) );
            return ntStatus;

        }

        pdoExtension = (PFDC_PDO_EXTENSION) newPdo->DeviceExtension;

        pdoExtension->TargetObject = fdoExtension->Self;

        pdoExtension->IsFDO = FALSE;
        pdoExtension->Self = newPdo;
        pdoExtension->DeviceType = FloppyControllerDevice;

        pdoExtension->ParentFdo = fdoExtension->Self;

        pdoExtension->Instance = 1; // Assume only 1 instance.
        pdoExtension->Removed = FALSE; // no irp_mn_remove as of yet

        newPdo->Flags |= DO_DIRECT_IO;
        newPdo->Flags |= DO_POWER_PAGABLE;
        newPdo->StackSize += fdoExtension->Self->StackSize;
        newPdo->Flags &= ~DO_DEVICE_INITIALIZING;

        InsertTailList(&fdoExtension->PDOs, &pdoExtension->PdoLink);
        fdoExtension->NumPDOs++;

        IoInvalidateDeviceRelations( fdoExtension->UnderlyingPDO, BusRelations );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FdcConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
/*++

Routine Description:

Arguments:

    Context - Pointer to our FDO extension

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Should always be DiskController.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should always be FloppyDiskPeripheral.

    PeripheralNumber - Which floppy if this controller is maintaining
                       more than one.

    PeripheralInformation - Arrya of pointers to the three pieces of
                            registry information.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the adapter object, or
    all of the resource information couldn't be acquired.

--*/
{

    PFDC_FDO_EXTENSION fdoExtension = (PFDC_FDO_EXTENSION)Context;
    NTSTATUS ntStatus;
    UNICODE_STRING pdoName;
    WCHAR   pdoNameBuffer[32];
    PDEVICE_OBJECT newPdo;
    PFDC_PDO_EXTENSION pdoExtension;
    USHORT floppyCount;

    FdcDump( FDCSHOW, ("FdcConfigCallBack:\n") );

    //
    //  Verify that this floppy disk drive is on the current
    //  floppy disk controller.
    //
    {
        USHORT i;
        BOOLEAN thisController = FALSE;
        PCM_FULL_RESOURCE_DESCRIPTOR controllerData =
            (PCM_FULL_RESOURCE_DESCRIPTOR)
            (((PUCHAR)ControllerInformation[IoQueryDeviceConfigurationData]) +
            ControllerInformation[IoQueryDeviceConfigurationData]->DataOffset);

        for ( i = 0;
              i < controllerData->PartialResourceList.Count;
              i++ ) {

            PCM_PARTIAL_RESOURCE_DESCRIPTOR partial =
                &controllerData->PartialResourceList.PartialDescriptors[i];

            FdcDump( FDCSHOW, ("FdcConfigCallBack: resource type = %x\n",partial->Type) );

            switch (partial->Type) {

            case CmResourceTypePort: {

                PUCHAR address;

                address = FdcGetControllerBase( BusType,
                                                BusNumber,
                                                partial->u.Port.Start,
                                                partial->u.Port.Length,
                                                (BOOLEAN)!!partial->Flags );

                FdcDump( FDCSHOW, ("FdcConfigCallBack: DriveControl = %04x %04x\n",fdoExtension->ControllerAddress.DriveControl,address + (IsNEC_98 ? 4 : 2) ));
                if ( fdoExtension->ControllerAddress.DriveControl == address + (IsNEC_98 ? 4 : 2)) {
                    thisController = TRUE;
                }
                }
                break;

            default:

                break;
            }
        }
        if ( !thisController ) {
            return STATUS_SUCCESS;
        }
    }

    floppyCount = (USHORT)(IoGetConfigurationInformation()->FloppyCount);
    swprintf(pdoNameBuffer, L"\\Device\\FloppyPDO%d", floppyCount);
    RtlInitUnicodeString(&pdoName, pdoNameBuffer);

    ntStatus = IoCreateDevice( fdoExtension->Self->DriverObject,
                               sizeof(FDC_PDO_EXTENSION),
                               &pdoName,
                               FILE_DEVICE_DISK,
                               (FILE_REMOVABLE_MEDIA |
                                FILE_FLOPPY_DISKETTE |
                                FILE_DEVICE_SECURE_OPEN),
                               FALSE,
                               &newPdo);

    if ( !NT_SUCCESS(ntStatus) ) {

        FdcDump( FDCSHOW, ("FdcConfigCallBack: Error - %08x\n", ntStatus) );
        return ntStatus;
    }

    FdcDump( FDCSHOW, ("FdcConfigCallBack: Created Device %d\n", floppyCount) );

    IoGetConfigurationInformation()->FloppyCount += 1;

    pdoExtension = (PFDC_PDO_EXTENSION) newPdo->DeviceExtension;

    pdoExtension->TargetObject = fdoExtension->Self;

    pdoExtension->IsFDO = FALSE;
    pdoExtension->Self = newPdo;
    pdoExtension->DeviceType = FloppyDiskDevice;

    pdoExtension->ParentFdo = fdoExtension->Self;

    pdoExtension->Instance = floppyCount + 1;
    pdoExtension->Removed = FALSE; // no irp_mn_remove as of yet

    fdoExtension->BusType = BusType;
    fdoExtension->BusNumber = BusNumber;
    fdoExtension->ControllerNumber = ControllerNumber;
    pdoExtension->PeripheralNumber = PeripheralNumber;

    newPdo->Flags |= DO_DIRECT_IO;
    newPdo->Flags |= DO_POWER_PAGABLE;
    newPdo->StackSize += fdoExtension->Self->StackSize;
    newPdo->Flags &= ~DO_DEVICE_INITIALIZING;

    InsertTailList(&fdoExtension->PDOs, &pdoExtension->PdoLink);
    fdoExtension->NumPDOs++;

    return STATUS_SUCCESS;
}

NTSTATUS
FdcCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called only rarely by the I/O system; it's mainly
    for layered drivers to call.  All it does is complete the IRP
    successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    Always returns STATUS_SUCCESS, since this is a null operation.

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );

    FdcDump(
        FDCSHOW,
        ("FdcCreateClose...\n")
        );

    //
    // Null operation.  Do not give an I/O boost since
    // no I/O was actually done.  IoStatus.Information should be
    // FILE_OPENED for an open; it's undefined for a close.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = FILE_OPENED;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return STATUS_SUCCESS;
}

NTSTATUS
FdcInternalDeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Determine if this Pnp request is directed towards an FDO or a PDO and
    pass the Irp on the the appropriate routine.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_EXTENSION_HEADER extensionHeader;
    KIRQL oldIrq;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    extensionHeader = (PFDC_EXTENSION_HEADER)DeviceObject->DeviceExtension;

    if ( extensionHeader->IsFDO ) {

        ntStatus = FdcFdoInternalDeviceControl( DeviceObject, Irp );

    } else {

        ntStatus = FdcPdoInternalDeviceControl( DeviceObject, Irp );
    }

    return ntStatus;
}

NTSTATUS
FdcPdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a device I/O
    control function.

    Most irps are put onto the driver queue (IoStartPacket).  Some irps do not
    require touching the hardware and are handled right here.

    In some cases the irp cannot be put on the queue because it cannot be
    completed at IRQL_DISPATCH_LEVEL.  However, the driver queue must be empty
    before the irp can be completed.  In these cases, the queue is
    'synchronized' before completing the irp.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
    PFDC_PDO_EXTENSION pdoExtension;
    PFDC_FDO_EXTENSION fdoExtension;
    BOOLEAN isFDO;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    PIO_STACK_LOCATION nextIrpSp;
    PISSUE_FDC_ADAPTER_BUFFER_PARMS adapterBufferParms;

    pdoExtension = (PFDC_PDO_EXTENSION)DeviceObject->DeviceExtension;
    fdoExtension = (PFDC_FDO_EXTENSION)pdoExtension->ParentFdo->DeviceExtension;

    if ( pdoExtension->Removed) {
        //
        // This bus has received the PlugPlay remove IRP.  It will no longer
        // respond to external requests.
        //
        ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest( Irp, IO_DISK_INCREMENT );
        return ntStatus;
    }

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    FdcDump( FDCSHOW,
             ("FdcPdoInternalDeviceControl: %x\n",
             irpSp->Parameters.DeviceIoControl.IoControlCode) );

    switch ( irpSp->Parameters.DeviceIoControl.IoControlCode ) {

    case IOCTL_DISK_INTERNAL_GET_ENABLER: {

        if ( pdoExtension->DeviceType == FloppyControllerDevice ) {

            *(PBOOLEAN)irpSp->Parameters.DeviceIoControl.Type3InputBuffer = TRUE;

        } else {

            *(PBOOLEAN)irpSp->Parameters.DeviceIoControl.Type3InputBuffer = FALSE;
        }

        ntStatus = STATUS_SUCCESS;

        break;
        }

    case IOCTL_DISK_INTERNAL_GET_FDC_INFO:

        FcReportFdcInformation( pdoExtension, fdoExtension, irpSp );

        ntStatus = STATUS_SUCCESS;

        break;

#ifdef TOSHIBAJ
    case IOCTL_DISK_INTERNAL_ENABLE_3_MODE:
        FdcDump(FDCSHOW,("IOCTL_Enable_3_MODE\n"));
        ntStatus = FcFdcEnable3Mode( fdoExtension , Irp );
        break;

    case    IOCTL_DISK_INTERNAL_AVAILABLE_3_MODE:
        FdcDump(FDCSHOW,("IOCTL_Availabe_3_MODE\n"));
        ntStatus = FcFdcAvailable3Mode( fdoExtension , Irp );
        break;
#endif

    default:

        IoSkipCurrentIrpStackLocation( Irp );

        //
        // Call the driver and request the operation
        //
        return IoCallDriver( pdoExtension->TargetObject, Irp );
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest( Irp, IO_DISK_INCREMENT );

    return ntStatus;
}

NTSTATUS
FdcFdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a device I/O
    control function.

    Most irps are put onto the driver queue (IoStartPacket).  Some irps do not
    require touching the hardware and are handled right here.

    In some cases the irp cannot be put on the queue because it cannot be
    completed at IRQL_DISPATCH_LEVEL.  However, the driver queue must be empty
    before the irp can be completed.  In these cases, the queue is
    'synchronized' before completing the irp.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    PIO_STACK_LOCATION nextIrpSp;
    PISSUE_FDC_ADAPTER_BUFFER_PARMS adapterBufferParms;
    BOOLEAN powerQueueClear = FALSE;
    PLIST_ENTRY deferredRequest;
    PIRP currentIrp;
    ULONG ioControlCode;
    PFDC_DISK_CHANGE_PARMS fdcDiskChangeParms;
    PUCHAR dataRate;
    UCHAR tapeMode;
    PUCHAR precomp;
    PISSUE_FDC_COMMAND_PARMS issueCommandParms;
    PSET_HD_BIT_PARMS setHdBitParams;

    fdoExtension = (PFDC_FDO_EXTENSION)DeviceObject->DeviceExtension;

    InterlockedIncrement( &fdoExtension->OutstandingRequests );

    if ( fdoExtension->Removed ) {
        //
        // This device has received the PlugPlay remove IRP.  It will no longer
        // respond to external requests.
        //
        if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
            KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
        }
        ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return ntStatus;
    }

    //
    //  If we are in a non-working power state then just queue the irp
    //  for later execution.
    //
    if ( fdoExtension->CurrentPowerState > PowerSystemWorking ) {

        ExInterlockedInsertTailList( &fdoExtension->PowerQueue,
                                     &Irp->Tail.Overlay.ListEntry,
                                     &fdoExtension->PowerQueueSpinLock );

        ntStatus = STATUS_PENDING;

        IoMarkIrpPending( Irp );

        return ntStatus;

    }

    do {

        deferredRequest = ExInterlockedRemoveHeadList( &fdoExtension->PowerQueue,
                                                       &fdoExtension->PowerQueueSpinLock );

        if ( deferredRequest == NULL ) {

            currentIrp = Irp;
            powerQueueClear = TRUE;

        } else {

            currentIrp = CONTAINING_RECORD( deferredRequest, IRP, Tail.Overlay.ListEntry );
        }

        irpSp = IoGetCurrentIrpStackLocation( currentIrp );

        FdcDump( FDCSHOW,
                 ("FdcFdoInternalDeviceControl: %x\n",
                 irpSp->Parameters.DeviceIoControl.IoControlCode) );

        ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;

        //
        //  GET_ENABLER and GET_FDC_INFO are handled in the PDO, not the FDO.
        //
        if ( ioControlCode == IOCTL_DISK_INTERNAL_GET_ENABLER ||
             ioControlCode == IOCTL_DISK_INTERNAL_GET_FDC_INFO ) {

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        //
        //  If the controller is not acquired (in use) then then only
        //  operation that is allowed is to acquire the fdc.
        //
        } else if ( !fdoExtension->ControllerInUse &&
                    ioControlCode != IOCTL_DISK_INTERNAL_ACQUIRE_FDC ) {

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        } else {

            switch ( ioControlCode ) {

            case IOCTL_DISK_INTERNAL_ACQUIRE_FDC:

                //
                // Try to Acquire the Fdc.  If the Fdc is busy, this call will
                // time out.
                //
                ntStatus = FcAcquireFdc(
                                    fdoExtension,
                                    (PLARGE_INTEGER)irpSp->
                                    Parameters.DeviceIoControl.Type3InputBuffer );
                //
                // Return the device object of the last device that called this
                // driver.  This can be used to determine if any other drivers
                // have messed with the fdc since it was last acquired.
                //
                if ( NT_SUCCESS(ntStatus) ) {

                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer =
                                                    fdoExtension->LastDeviceObject;
                }
                break;

            case IOCTL_DISK_INTERNAL_ENABLE_FDC_DEVICE:

                //
                // Turn the motor on and select a floppy channel
                //
                ntStatus = FcTurnOnMotor( fdoExtension, irpSp );

                break;

            case IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND:

                issueCommandParms =
                    (PISSUE_FDC_COMMAND_PARMS)
                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                ntStatus = FcIssueCommand( fdoExtension,
                                           issueCommandParms->FifoInBuffer,
                                           issueCommandParms->FifoOutBuffer,
                                           issueCommandParms->IoHandle,
                                           issueCommandParms->IoOffset,
                                           issueCommandParms->TransferBytes );


                break;

            case IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED:

                IoMarkIrpPending( Irp );

                IoStartPacket( DeviceObject,
                               Irp,
                               NULL,
                               NULL );

                ntStatus = STATUS_PENDING;

                break;

            case IOCTL_DISK_INTERNAL_RESET_FDC:

                ntStatus = FcInitializeControllerHardware( fdoExtension,
                                                           DeviceObject );
                break;

            case IOCTL_DISK_INTERNAL_RELEASE_FDC:

                ntStatus = FcReleaseFdc( fdoExtension );
                //
                // Save the DeviceObject of the releasing device.  This is
                // returned with the subsequent acquire fdc request and
                // can be used to determine whether the floppy controller
                // has been messed with between release and acquisition
                //
                if ( NT_SUCCESS(ntStatus) ) {

                    fdoExtension->LastDeviceObject =
                        irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                }

                break;

            case IOCTL_DISK_INTERNAL_GET_ADAPTER_BUFFER:
                //
                // Allocate an MDL for the passed in buffer.
                //
                adapterBufferParms = (PISSUE_FDC_ADAPTER_BUFFER_PARMS)
                            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                adapterBufferParms->Handle =
                             IoAllocateMdl( adapterBufferParms->IoBuffer,
                                            adapterBufferParms->TransferBytes,
                                            FALSE,
                                            FALSE,
                                            NULL );

                if ( adapterBufferParms->Handle == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    MmBuildMdlForNonPagedPool( adapterBufferParms->Handle );

                    ntStatus = STATUS_SUCCESS;
                }

                break;

            case IOCTL_DISK_INTERNAL_FLUSH_ADAPTER_BUFFER:
                //
                // Free the MDL
                //
                adapterBufferParms = (PISSUE_FDC_ADAPTER_BUFFER_PARMS)
                            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                if ( adapterBufferParms->Handle != NULL ) {

                    IoFreeMdl( adapterBufferParms->Handle );
                }

                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_FDC_START_READ:
            case IOCTL_DISK_INTERNAL_FDC_START_WRITE:

                ntStatus = STATUS_SUCCESS;

                if ( fdoExtension->FdcEnablerSupported ) {

                    FDC_MODE_SELECT fdcModeSelect;

                    fdcModeSelect.structSize = sizeof(fdcModeSelect);
                    //
                    // Reading from the media means writing to DMA memory and
                    // visa-versa for writing to the media.
                    //
                    if ( irpSp->Parameters.DeviceIoControl.IoControlCode ==
                         IOCTL_DISK_INTERNAL_FDC_START_READ ) {

                        fdcModeSelect.DmaDirection = FDC_WRITE_TO_MEMORY;

                    } else {

                        fdcModeSelect.DmaDirection = FDC_READ_FROM_MEMORY;
                    }

                    ntStatus = FcFdcEnabler(
                                    fdoExtension->FdcEnablerDeviceObject,
                                    IOCTL_SET_FDC_MODE,
                                    &fdcModeSelect);
                }
                break;

            case IOCTL_DISK_INTERNAL_DISABLE_FDC_DEVICE:

                ntStatus = FcTurnOffMotor( fdoExtension );

                break;

            case IOCTL_DISK_INTERNAL_GET_FDC_DISK_CHANGE:

                FdcDump(FDCINFO, ("Fdc: Read Disk Change\n") );

                fdcDiskChangeParms =
                    (PFDC_DISK_CHANGE_PARMS)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                if (IsNEC_98) {
                    if((fdoExtension->ResultStatus0[fdcDiskChangeParms->DriveOnValue] &
                        STREG0_END_MASK) == STREG0_END_DRIVE_NOT_READY){

                        fdcDiskChangeParms->DriveStatus = DSKCHG_DISKETTE_REMOVED;
                    } else {

                        fdoExtension->ResultStatus0[fdcDiskChangeParms->DriveOnValue] = 0;
                        fdcDiskChangeParms->DriveStatus = DSKCHG_RESERVED;
                    }
                } else { // (IsNEC_98)
                    fdcDiskChangeParms->DriveStatus = READ_CONTROLLER(
                                                            fdoExtension->ControllerAddress.DRDC.DiskChange );
                    //
                    //  If we just waked up from hibernation, simulate a disk
                    //  change event so the upper levels will be sure to check
                    //  this disk.
                    //
                    if ( fdoExtension->WakeUp ) {

                        fdcDiskChangeParms->DriveStatus |= DSKCHG_DISKETTE_REMOVED;
                        fdoExtension->WakeUp = FALSE;
                    }
                } // (IsNEC_98)

                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_FDC_DATA_RATE:

                if (IsNEC_98) {
                    //
                    // NEC98 have no function and have no DRDC.DataRate register.
                    //
                } else { // (IsNEC_98)
                    dataRate =
                        (PUCHAR)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                    FdcDump(FDCINFO, ("Fdc: Write Data Rate: %x\n", *dataRate) );

                    WRITE_CONTROLLER( fdoExtension->ControllerAddress.DRDC.DataRate,
                                      *dataRate );

                } // (IsNEC_98)
                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_FDC_TAPE_MODE:

                if (IsNEC_98) {
                    //
                    // NEC98 have no Tape register.
                    //
                } else { // (IsNEC_98)

                    tapeMode = READ_CONTROLLER( fdoExtension->ControllerAddress.Tape );
                    tapeMode &= 0xfc;
                    tapeMode |=
                        *((PUCHAR)irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

                    FdcDump(FDCINFO,
                            ("Fdc: Write Tape Mode Register: %x\n", tapeMode)
                            );

                    WRITE_CONTROLLER(
                        fdoExtension->ControllerAddress.Tape,
                        tapeMode );

                } // (IsNEC_98)
                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_FDC_PRECOMP:

                precomp = (PUCHAR)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                FdcDump(FDCINFO,
                        ("Fdc: Write Precomp: %x\n", *precomp)
                        );

                WRITE_CONTROLLER(
                    fdoExtension->ControllerAddress.Status,
                    *precomp );

                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_HD_BIT:

                if (IsNEC_98) {

                    FdcDump(FDCINFO,
                            ("Fdc: Set Hd Bit: \n")
                            );
                    setHdBitParams = (PSET_HD_BIT_PARMS)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                    FdcHdbit(DeviceObject, fdoExtension, setHdBitParams);

                    ntStatus = STATUS_SUCCESS;

                    break;
                } // (IsNEC_98)

                //
                // If not NEC98, then pass through to "default:".
                //

            default:
                //
                // Mark the Irp pending and queue it.
                //
                ntStatus = STATUS_INVALID_DEVICE_REQUEST;

                break;
            }
        }

        if ( ntStatus != STATUS_PENDING ) {

            if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
                KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
            }
            currentIrp->IoStatus.Status = ntStatus;
            IoCompleteRequest( currentIrp, IO_DISK_INCREMENT );
        }

    } while ( !powerQueueClear );

    return ntStatus;
}

VOID
FcReportFdcInformation(
    IN      PFDC_PDO_EXTENSION PdoExtension,
    IN      PFDC_FDO_EXTENSION FdoExtension,
    IN OUT  PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine reports information about the Floppy Disk Controller
    that a higher level driver might need; primarily information
    regarding the DMA Adapter.

Arguments:

    fdoExtension    - Pointer to this device's extension data.

    IrpSp           - Pointer to the current Irp

Return Value:

    STATUS_SUCCESS

--*/

{
    PFDC_INFO fdcInfo;
    ULONG bufferCount;
    ULONG bufferSize;
    ULONG i;

    FdcDump( FDCINFO, ("Fdc: Report FDC Information\n") );

    fdcInfo = (PFDC_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    //
    // save the requested buffer count and buffer size.
    //
    bufferCount = fdcInfo->BufferCount;
    bufferSize =  fdcInfo->BufferSize;

    //
    // fill in the floppy controller hardware information
    //
    fdcInfo->BusType = FdoExtension->BusType;
    fdcInfo->BusNumber = FdoExtension->BusNumber;
    fdcInfo->ControllerNumber = FdoExtension->ControllerNumber;
    if (IsNEC_98) {
        UCHAR floppyEquip;
        ULONG disketteCount = 0;
        ULONG i;

        floppyEquip = FdoExtension->FloppyEquip;

        //
        // Make PeripheralNumber.
        //
        for (i = 0 ; i < 4 ; i++) {

            if ((floppyEquip & 0x1) != 0) {

                disketteCount++;

                if(disketteCount > PdoExtension->PeripheralNumber){

                    break;
                }
            }
            floppyEquip = floppyEquip >> 1;
        }

        fdcInfo->UnitNumber = (UCHAR)i;
    } else {
        //
        // Only NEC98 is using it now, put Zero into UnitNumber.
        //
        fdcInfo->UnitNumber = 0;
    }
    fdcInfo->PeripheralNumber = PdoExtension->PeripheralNumber;

    fdcInfo->FloppyControllerType = FdoExtension->FdcType;
    fdcInfo->SpeedsAvailable = FdoExtension->FdcSpeeds;

    fdcInfo->MaxTransferSize = FdoExtension->NumberOfMapRegisters * PAGE_SIZE;

    fdcInfo->BufferSize = 0;
    fdcInfo->BufferCount = 0;

    if ( bufferSize <= FdoExtension->BufferSize ) {

        fdcInfo->BufferSize = bufferSize;
        fdcInfo->BufferCount = MIN( bufferCount,
                                    FdoExtension->BufferCount );
        FdoExtension->BuffersRequested = MAX( fdcInfo->BufferCount,
                                              FdoExtension->BuffersRequested );
    }

    for ( i = 0 ; i < fdcInfo->BufferCount ; i++ ) {

        fdcInfo->BufferAddress[i].Logical =
                                    FdoExtension->TransferBuffers[i].Logical;
        fdcInfo->BufferAddress[i].Virtual =
                                    FdoExtension->TransferBuffers[i].Virtual;
    }
}

VOID
FdcStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS ntStatus;
    ULONG formatExParametersSize;
    PUCHAR diskChange;
    PUCHAR dataRate;
    PUCHAR tapeMode;
    PUCHAR precomp;
    PFDC_FDO_EXTENSION fdoExtension;
    PISSUE_FDC_COMMAND_PARMS issueCommandParms;
    PKDEVICE_QUEUE_ENTRY request;

    FdcDump( FDCSHOW, ("FdcStartIo...\n") );

    fdoExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;

    switch( irpSp->Parameters.DeviceIoControl.IoControlCode ) {

        case IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED:

            issueCommandParms =
                (PISSUE_FDC_COMMAND_PARMS)
                irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

            if ( CommandTable[issueCommandParms->FifoInBuffer[0] &
                                            COMMAND_MASK].InterruptExpected ) {

                fdoExtension->CurrentDeviceObject = DeviceObject;
                fdoExtension->AllowInterruptProcessing = TRUE;
                fdoExtension->CommandHasResultPhase = FALSE;
                fdoExtension->InterruptTimer =
                    issueCommandParms->TimeOut ?
                    issueCommandParms->TimeOut + 1 : START_TIMER;
                fdoExtension->CurrentIrp = Irp;

            }

            ntStatus = FcStartCommand( fdoExtension,
                                       issueCommandParms->FifoInBuffer,
                                       issueCommandParms->FifoOutBuffer,
                                       issueCommandParms->IoHandle,
                                       issueCommandParms->IoOffset,
                                       issueCommandParms->TransferBytes,
                                       FALSE );

            if ( NT_SUCCESS( ntStatus )) {

                if ( CommandTable[issueCommandParms->FifoInBuffer[0] &
                                            COMMAND_MASK].InterruptExpected ) {

                    ntStatus = STATUS_PENDING;

                } else {

                    ntStatus = FcFinishCommand(
                                    fdoExtension,
                                    issueCommandParms->FifoInBuffer,
                                    issueCommandParms->FifoOutBuffer,
                                    issueCommandParms->IoHandle,
                                    issueCommandParms->IoOffset,
                                    issueCommandParms->TransferBytes,
                                    FALSE );

                }

            }

            break;

        default: {

            FdcDump(
                FDCDBGP,
                ("Fdc: invalid device request %x\n",
                irpSp->Parameters.DeviceIoControl.IoControlCode)
                );

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }
    }

    if ( ntStatus != STATUS_PENDING ) {
        Irp->IoStatus.Status = ntStatus;
        if (!NT_SUCCESS( ntStatus ) &&
            IoIsErrorUserInduced( ntStatus )) {

            IoSetHardErrorOrVerifyDevice( Irp, DeviceObject );
        }

        IoStartNextPacket( DeviceObject, FALSE );
    }
}

NTSTATUS
FcAcquireFdc(
    IN      PFDC_FDO_EXTENSION  FdoExtension,
    IN      PLARGE_INTEGER  TimeOut
    )

/*++

Routine Description:

    This routine acquires the floppy disk controller.  This includes
    allocating the adapter channel and connecting the interrupt.

    NOTE - This is where the sharing mechanism will be put into
    this driver.  That is, higher level drivers will 'reserve' the
    floppy controller with this ioctl.  Subsequent calls to this driver
    that are not from the 'reserving' drive will be rejected with a
    BUSY status.

Arguments:

    DeviceObject    - Device object for the current device

Return Value:

    STATUS_DEVICE_BUSY if we don't have the controller, otherwise
    STATUS_SUCCESS

--*/

{
    NTSTATUS ntStatus;

    FdcDump(FDCINFO,
           ("Fdc: Acquire the Floppy Controller\n")
           );

    //
    // Wait for the Fdc, either from the enabler or directly here.  Semaphores
    // are used to synchronize usage of the Fdc hardware.  If somebody else is
    // using the floppy controller now we must wait for them to finish.  If
    // this takes too long we will just let the caller know that the device is
    // busy.
    //
    if (FdoExtension->FdcEnablerSupported) {

        ntStatus = FcFdcEnabler( FdoExtension->FdcEnablerDeviceObject,
//                               IOCTL_ACQUIRE_FDC, // For spelling miss in flpyenbl.h
                                 IOCTL_AQUIRE_FDC,
                                 TimeOut);
    } else {

        ntStatus = KeWaitForSingleObject( FdoExtension->AcquireEvent,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          TimeOut );

        if ( ntStatus == STATUS_TIMEOUT ) {

            ntStatus = STATUS_DEVICE_BUSY;
        }
    }

    if ( NT_SUCCESS(ntStatus) ) {
        //
        // Lock down the driver code in memory.
        //

        FDC_PAGE_RESET_DRIVER_WITH_MUTEX;

        //
        // Allocate the adapter channel
        //
        FcAllocateAdapterChannel( FdoExtension );

        IoStartTimer(FdoExtension->Self);

        if (IsNEC_98) {
            //
            // NEC98's FDD driver can't not disconnect interrupt,
            // and can't not page out this driver. Because when a FD is inserted in FDD or
            // is ejected from FDD, then H/W calls FDD driver's interrupt routine.
            //
            ntStatus = STATUS_SUCCESS;

        } else { // (IsNEC_98)

            //
            // Connect the Interrupt
            //
            ntStatus = IoConnectInterrupt(&FdoExtension->InterruptObject,
                                        FdcInterruptService,
                                        FdoExtension,
                                        NULL,
                                        FdoExtension->ControllerVector,
                                        FdoExtension->ControllerIrql,
                                        FdoExtension->ControllerIrql,
                                        FdoExtension->InterruptMode,
                                        FdoExtension->SharableVector,
                                        FdoExtension->ProcessorMask,
                                        FdoExtension->SaveFloatState);
        } // (IsNEC_98)

        if ( NT_SUCCESS( ntStatus ) ) {
            FdoExtension->ControllerInUse = TRUE;
        } else {
            FcFreeAdapterChannel( FdoExtension );
            IoStopTimer(FdoExtension->Self);
        }
    } else {

        ntStatus = STATUS_DEVICE_BUSY;
    }

    return ntStatus;
}

NTSTATUS
FcReleaseFdc(
    IN      PFDC_FDO_EXTENSION  FdoExtension
    )

/*++

Routine Description:

    This routine releaese the floppy disk controller.  This includes
    freeing the adapter channel and disconnecting the interrupt.

    NOTE - This is where the sharing mechanism will be put into
    this driver.  That is, higher level drivers will 'reserve' the
    floppy controller with this ioctl.  Subsequent calls to this driver
    that are not from the 'reserving' drive will be rejected with a
    BUSY status.

Arguments:

    fdoExtension    - Pointer to this device's extension data.

Return Value:

    STATUS_DEVICE_BUSY if we don't have the controller, otherwise
    STATUS_SUCCESS

--*/

{
    FdcDump(FDCINFO, ("Fdc: Release the Floppy Controller\n") );

    //
    // Free the Adapter Channel
    //
    FcFreeAdapterChannel( FdoExtension );

    FdoExtension->AllowInterruptProcessing = FALSE;
    FdoExtension->ControllerInUse = FALSE;

    if (IsNEC_98) {
        //
        // NEC98's FDD driver can't not disconnect interrupt,
        // and can't not page out this driver. Because when a FD is inserted in FDD or
        // is ejected from FDD, then H/W calls FDD driver's interrupt routine.
        //

    } else { // (IsNEC_98)
        //
        // Disconnect the Interrupt
        //
        IoDisconnectInterrupt(FdoExtension->InterruptObject);

    } // (IsNEC_98)

    IoStopTimer(FdoExtension->Self);

    FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;

    //
    // Release the Fdc Enabler card if there is one.  Otherwise, set the
    // floppy synchronization event.
    //
    if (FdoExtension->FdcEnablerSupported) {

        FcFdcEnabler( FdoExtension->FdcEnablerDeviceObject,
                      IOCTL_RELEASE_FDC,
                      NULL);
    } else {

        KeSetEvent( FdoExtension->AcquireEvent,
                    (KPRIORITY) 0,
                    FALSE );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FcTurnOnMotor(
    IN      PFDC_FDO_EXTENSION  FdoExtension,
    IN OUT  PIO_STACK_LOCATION   IrpSp
    )

/*++

Routine Description:

    This routine turns on the motor if it not already running.

Arguments:

    fdoExtension    - Pointer to this device's extension data.

    IrpSp           - Pointer to the current Irp

Return Value:

    STATUS_DEVICE_BUSY if we don't have the controller, otherwise
    STATUS_SUCCESS

--*/

{
    UCHAR driveStatus;
    UCHAR newStatus;
    LARGE_INTEGER motorOnDelay;
    PFDC_ENABLE_PARMS fdcEnableParms;

    USHORT      lpc;
    UCHAR       resultStatus0Save[4];

    fdcEnableParms =
        (PFDC_ENABLE_PARMS)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    FdcDump(FDCINFO,
           ("Fdc: Turn Motor On: %x\n",fdcEnableParms->DriveOnValue)
           );

    driveStatus = FdoExtension->DriveControlImage;
    if (IsNEC_98) {

        newStatus = DRVCTL_MOTOR_MASK;

    } else { // (IsNEC_98)

        newStatus = fdcEnableParms->DriveOnValue |
                                    DRVCTL_ENABLE_CONTROLLER |
                                    DRVCTL_ENABLE_DMA_AND_INTERRUPTS;
    } // (IsNEC_98)

    if ( driveStatus != newStatus ) {

        // If the drive is not on then check to see if we have
        // the controller.  Otherwise we assume that we have
        // the controller since we give it up only when we
        // turn off the motor.

        if (IsNEC_98) {
            if(FdoExtension->MotorRunning == 0){

                //
                // save status
                //
                for(lpc=0;lpc<4;lpc++){
                    resultStatus0Save[lpc] = FdoExtension->ResultStatus0[lpc];
                }

                FdcDump(
                    FDCSHOW,
                    ("Floppy: Turn on motor!\n")
                    );

                FdoExtension->DriveControlImage = 0x18;
                FdoExtension->DriveControlImage |= DRVCTL_AI_ENABLE;

                WRITE_CONTROLLER(
                     FdoExtension->ControllerAddress.DriveControl,
                     FdoExtension->DriveControlImage );
                FdoExtension->MotorRunning = 1;
            }
        } else { // (IsNEC_98)

            if (!FdoExtension->CurrentInterrupt) {

                FdoExtension->CurrentInterrupt = TRUE;

                driveStatus = FdoExtension->DriveControlImage;
            }

            FdoExtension->AllowInterruptProcessing = TRUE;

            FdoExtension->DriveControlImage = newStatus;

            WRITE_CONTROLLER(
                FdoExtension->ControllerAddress.DriveControl,
                FdoExtension->DriveControlImage );

        } // (IsNEC_98)


        if (fdcEnableParms->TimeToWait > 0) {

            if (IsNEC_98) {

                //
                // check if motor is on or not.
                //
                if(FdoExtension->MotorRunning == 1){
                    FdoExtension->MotorRunning = 2;
                    motorOnDelay.LowPart = (unsigned long)(- ( 10 * 1000 * 1000 ));
                    motorOnDelay.HighPart = -1;
                    KeDelayExecutionThread( KernelMode, FALSE, &motorOnDelay );

                    //
                    // after sense, restore status
                    //
                    for(lpc=0;lpc<4;lpc++){
                        FdoExtension->ResultStatus0[lpc] = resultStatus0Save[lpc];
                    }
                }

            } else { // (IsNEC_98)

                motorOnDelay.LowPart =
                    - ( 10 * 1000 * fdcEnableParms->TimeToWait );
                motorOnDelay.HighPart = -1;

                FdoExtension->LastMotorSettleTime = motorOnDelay;

                KeDelayExecutionThread( KernelMode, FALSE, &motorOnDelay );

            } // (IsNEC_98)

        }

        fdcEnableParms->MotorStarted = TRUE;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FcTurnOffMotor(
    IN      PFDC_FDO_EXTENSION  FdoExtension
    )

/*++

Routine Description:

    This routine turns off all motors.  By default, Drive A is left selected
    by this routine since it is not possible to deselect all drives.  On a
    Power PC, drive D is left selected.

Arguments:

    fdoExtension   - Supplies the fdc extension.

Return Value:

    None.

--*/

{

    FdcDump(FDCINFO,
           ("Fdc: Turn Motor Off\n")
           );

    if (IsNEC_98) {

        if (FdoExtension->MotorRunning != 0){

            FdoExtension->DriveControlImage
                    = READ_CONTROLLER(FdoExtension->ControllerAddress.DriveControl);

            FdoExtension->DriveControlImage = 0x10;
            FdoExtension->DriveControlImage |= DRVCTL_AI_ENABLE;

            WRITE_CONTROLLER(
                    FdoExtension->ControllerAddress.DriveControl,
                    FdoExtension->DriveControlImage );

            if (FdoExtension->CurrentInterrupt) {
                FdoExtension->CurrentInterrupt = FALSE;

                KeSetEvent(FdoExtension->AcquireEvent,
                    (KPRIORITY) 0,
                    FALSE);
            }
            FdoExtension->MotorRunning = 0;
        }
    } else { // (IsNEC_98)

        FdoExtension->DriveControlImage =
            DRVCTL_ENABLE_DMA_AND_INTERRUPTS +
#ifdef _PPC_
            DRVCTL_DRIVE_MASK +
#endif
            DRVCTL_ENABLE_CONTROLLER;

        WRITE_CONTROLLER(
            FdoExtension->ControllerAddress.DriveControl,
            FdoExtension->DriveControlImage );

    } // (IsNEC_98)

    return STATUS_SUCCESS;
}

VOID
FcAllocateAdapterChannel(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine allocates an adapter channel.  The caller of
    IoAllocateAdapterChannel routine must wait for the
    'AllocateAdapterChannelEvent' to be signalled before trying to use the
    adapter channel.

Arguments:

    fdoExtension   - Supplies the fdc extension.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    if ( (FdoExtension->AdapterChannelRefCount)++ ) {
        return;
    }

    KeResetEvent( &FdoExtension->AllocateAdapterChannelEvent );

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    IoAllocateAdapterChannel( FdoExtension->AdapterObject,
                              FdoExtension->Self,
                              FdoExtension->NumberOfMapRegisters,
                              FdcAllocateAdapterChannel,
                              FdoExtension );

    KeLowerIrql( oldIrql );

    KeWaitForSingleObject( &FdoExtension->AllocateAdapterChannelEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL);
}

VOID
FcFreeAdapterChannel(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine frees the previously allocated adapter channel.

Arguments:

    fdoExtension   - Supplies the fdc extension.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    if ( --(FdoExtension->AdapterChannelRefCount) ) {
        return;
    }

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    IoFreeAdapterChannel( FdoExtension->AdapterObject );

    KeLowerIrql( oldIrql );
}

IO_ALLOCATION_ACTION
FdcAllocateAdapterChannel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )

/*++

Routine Description:

    This DPC is called whenever the fdc.sys driver is trying to allocate
    the adapter channel.  It saves the MapRegisterBase in the controller data
    area, and sets the AllocateAdapterChannelEvent to awaken the thread.

Arguments:

    DeviceObject - unused.

    Irp - unused.

    MapRegisterBase - the base of the map registers that can be used
    for this transfer.

    Context - a pointer to our controller data area.

Return Value:

    Returns Allocation Action 'KeepObject' which means that the adapter
    object will be held for now (to be released explicitly later).

--*/
{
    PFDC_FDO_EXTENSION fdoExtension = Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    fdoExtension->MapRegisterBase = MapRegisterBase;

    KeSetEvent( &fdoExtension->AllocateAdapterChannelEvent,
                0L,
                FALSE );

    return KeepObject;
}

VOID
FcLogErrorDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to log an error that we had to reset the device.

Arguments:

    Dpc - The dpc object.

    DeferredContext - A pointer to the controller data.

    SystemContext1 - Unused.

    SystemContext2 - Unused.

Return Value:

    Mapped address

--*/

{

    PIO_ERROR_LOG_PACKET errorLogEntry;
    PFDC_FDO_EXTENSION fdoExtension = DeferredContext;

    errorLogEntry = IoAllocateErrorLogEntry(
                        fdoExtension->DriverObject,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET))
                        );

    if ( errorLogEntry != NULL) {

        errorLogEntry->ErrorCode = IO_ERR_RESET;
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize = 0;

        IoWriteErrorLogEntry(errorLogEntry);

    }

}

NTSTATUS
FcIssueCommand(
    IN OUT  PFDC_FDO_EXTENSION  FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes
    )

/*++

Routine Description:

    This routine sends the command and all parameters to the controller,
    waits for the command to interrupt if necessary, and reads the result
    bytes from the controller, if any.

    Before calling this routine, the caller should put the parameters for
    the command in ControllerData->FifoBuffer[].  The result bytes will
    be returned in the same place.

    This routine runs off the CommandTable.  For each command, this says
    how many parameters there are, whether or not there is an interrupt
    to wait for, and how many result bytes there are.  Note that commands
    without result bytes actually have two, since the ISR will issue a
    SENSE INTERRUPT STATUS command on their behalf.

Arguments:

    Command - a byte specifying the command to be sent to the controller.

    fdoExtension - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if the command was sent and bytes received properly;
    appropriate error propogated otherwise.

--*/

{
    NTSTATUS ntStatus;
    NTSTATUS ntStatus2;
    UCHAR i;
    PUCHAR fifoBuffer;
    UCHAR Command;
    BOOLEAN NeedToFlush = FALSE;


    //
    // If this command causes an interrupt, set CurrentDeviceObject and
    // reset the interrupt event.
    //

    Command = FifoInBuffer[0];

    FdcDump( FDCINFO,
             ("FcIssueCommand: Issue Command : %x\n",
             CommandTable[Command & COMMAND_MASK].OpCode)
             );


    if ( CommandTable[Command & COMMAND_MASK].InterruptExpected ) {

        FdoExtension->CurrentDeviceObject = FdoExtension->Self;
        FdoExtension->AllowInterruptProcessing = TRUE;
        FdoExtension->CommandHasResultPhase =
            !!CommandTable[Command & COMMAND_MASK].FirstResultByte;

        KeResetEvent( &FdoExtension->InterruptEvent );
    }

    //
    // Start up the command
    //

    ntStatus = FcStartCommand( FdoExtension,
                               FifoInBuffer,
                               FifoOutBuffer,
                               IoHandle,
                               IoOffset,
                               TransferBytes,
                               TRUE );

    if ( NT_SUCCESS( ntStatus ) ) {

        //
        // If there is an interrupt, wait for it.
        //

        if ( CommandTable[Command & COMMAND_MASK].InterruptExpected ) {

            ntStatus = KeWaitForSingleObject(
                &FdoExtension->InterruptEvent,
                Executive,
                KernelMode,
                FALSE,
                &FdoExtension->InterruptDelay );

            if ( ntStatus == STATUS_TIMEOUT ) {

                //
                // Change info to an error.  We'll just say
                // that the device isn't ready.
                //

                ntStatus = STATUS_DEVICE_NOT_READY;

                FdoExtension->HardwareFailed = TRUE;
            }
        }

        //
        // If successful so far, get the result bytes.
        //

        if ( NT_SUCCESS( ntStatus ) ) {

            ntStatus = FcFinishCommand( FdoExtension,
                                        FifoInBuffer,
                                        FifoOutBuffer,
                                        IoHandle,
                                        IoOffset,
                                        TransferBytes,
                                        TRUE );

        }
    }

    return ntStatus;
}

NTSTATUS
FcStartCommand(
    IN OUT  PFDC_FDO_EXTENSION  FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS ntStatus;
    NTSTATUS ntStatus2;
    UCHAR i = 0;
    PUCHAR fifoBuffer;
    UCHAR Command;
    BOOLEAN NeedToFlush = FALSE;
    PIO_STACK_LOCATION irpSp;
    UCHAR status0;

    //
    // If this command causes an interrupt, set CurrentDeviceObject and
    // reset the interrupt event.
    //

    Command = FifoInBuffer[0];

    FdcDump( FDCINFO,
             ("FcStartCommand: Issue Command : %x\n",
             CommandTable[Command & COMMAND_MASK].OpCode)
             );

    FdoExtension->CommandHasResultPhase =
        !!CommandTable[Command & COMMAND_MASK].FirstResultByte;

    // First we will need to set up the data transfer if there is one associated
    // with this request.
    //
    if (CommandTable[Command & COMMAND_MASK].DataTransfer == FDC_READ_DATA ) {
        //
        // Setup Adapter Channel for Read
        //
        IoMapTransfer(FdoExtension->AdapterObject,
                      IoHandle,
                      FdoExtension->MapRegisterBase,
                      (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                      &TransferBytes,
                      FALSE);

    } else if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
               FDC_WRITE_DATA ) {
        //
        // Setup Adapter Channel for Write
        //

        IoMapTransfer(FdoExtension->AdapterObject,
                      IoHandle,
                      FdoExtension->MapRegisterBase,
                      (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                      &TransferBytes,
                      TRUE);

    }

    //
    // Send the command to the controller.
    //
    if ( Command == COMMND_CONFIGURE ) {
        if ( FdoExtension->Clock48MHz ) {
            Command |= COMMND_OPTION_CLK48;
        }
    }
    ntStatus = FcSendByte( (UCHAR)(CommandTable[Command & COMMAND_MASK].OpCode |
                                  (Command & ~COMMAND_MASK)),
                           FdoExtension,
                           AllowLongDelay );

    //
    // If the command was successfully sent, we can proceed.
    //

    if ( NT_SUCCESS( ntStatus ) ) {

        //
        // Send the parameters as long as we succeed.
        //

        for ( i = 1;
            ( i <= CommandTable[Command & COMMAND_MASK].NumberOfParameters ) &&
                ( NT_SUCCESS( ntStatus ) );
            i++ ) {

            ntStatus = FcSendByte( FifoInBuffer[i],
                                   FdoExtension,
                                   AllowLongDelay );
            //
            // The Drive Specification is a special case since we don't really know
            // how many bytes to send until we encounter the DONE bit (or we have sent
            // the maximum allowable bytes).
            //
            if ((Command == COMMND_DRIVE_SPECIFICATION) &&
                (FifoInBuffer[i] & COMMND_DRIVE_SPECIFICATION_DONE) ) {
                break;
            }
        }

    }

    //
    // If there was a problem, check to see if it was caused by an
    // unimplemented command.
    //

    if ( !NT_SUCCESS( ntStatus ) ) {

        if ( ( i == 2 ) &&
            ( !CommandTable[Command & COMMAND_MASK].AlwaysImplemented ) ) {

            //
            // This error is probably caused by a command that's not
            // implemented on this controller.  Read the error from the
            // controller, and we should be in a stable state.
            //

            ntStatus2 = FcGetByte( &status0,
                                   FdoExtension,
                                   AllowLongDelay );

            //
            // If GetByte went as planned, we'll return the original error.
            //

            if ( NT_SUCCESS( ntStatus2 ) ) {

                if ( status0 != STREG0_END_INVALID_COMMAND ) {

                    //
                    // Status isn't as we expect, so return generic error.
                    //

                    ntStatus = STATUS_FLOPPY_BAD_REGISTERS;

                    FdoExtension->HardwareFailed = TRUE;
                    FdcDump( FDCINFO,
                             ("FcStartCommand: unexpected error value %2x\n",
                             status0) );
                } else {
                    FdcDump( FDCINFO,
                             ("FcStartCommand: Invalid command error returned\n") );
                }

            } else {

                //
                // GetByte returned an error, so propogate THAT.
                //

                FdcDump( FDCINFO,
                         ("FcStartCommand: FcGetByte returned error %x\n",
                         ntStatus2) );
                ntStatus = ntStatus2;
            }
        }

        //
        // Flush the Adapter Channel if we allocated it.
        //

        if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
            FDC_READ_DATA) {

            IoFlushAdapterBuffers( FdoExtension->AdapterObject,
                                   (PMDL)IoHandle,
                                   FdoExtension->MapRegisterBase,
                                   (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle) + IoOffset ),
                                   TransferBytes,
                                   FALSE);

        } else if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
                   FDC_WRITE_DATA) {

            IoFlushAdapterBuffers( FdoExtension->AdapterObject,
                                   (PMDL)IoHandle,
                                   FdoExtension->MapRegisterBase,
                                   (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle) + IoOffset ),
                                   TransferBytes,
                                   TRUE);

        }
    }

    if ( !NT_SUCCESS( ntStatus ) ) {

        //
        // Print an error message unless the command isn't always
        // implemented, ie CONFIGURE.
        //

        if ( !( ( ntStatus == STATUS_DEVICE_NOT_READY ) &&
            ( !CommandTable[Command & COMMAND_MASK].AlwaysImplemented ) ) ) {

            FdcDump( FDCDBGP,
                     ("Fdc: err %x ------  while giving command %x\n",
                     ntStatus, Command) );
        }
    }

    return ntStatus;
}

NTSTATUS
FcFinishCommand(
    IN OUT  PFDC_FDO_EXTENSION  FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    )

/*++

Routine Description:

    This function is called to complete a command to the floppy controller.
    At this point the floppy controller has successfully been sent a command
    and has either generated an interrupt or is ready with its result phase.
    This routine will also flush the DMA Adapter Buffers if they have been
    allocated.

Arguments:

    FdoExtension - a pointer to our data area for this controller.

    IssueCommandParms - Floppy controller command parameters.

Return Value:

    STATUS_SUCCESS if the command is successfully completed.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    NTSTATUS ntStatus2;
    UCHAR i;
    UCHAR Command;

    Command = FifoInBuffer[0];

    FdcDump(
        FDCSHOW,
        ("Fdc: FcFinishCommand...\n")
        );

    if (IsNEC_98) {

        if (Command == COMMND_SENSE_DRIVE_STATUS) {

            ntStatus = FcGetByte(
                &FdoExtension->FifoBuffer[0],
                FdoExtension,
                AllowLongDelay );

            if (NT_SUCCESS(ntStatus) && (FdoExtension->FifoBuffer[0] & STREG3_DRIVE_READY)) {

                FdoExtension->ResultStatus0[FifoInBuffer[1]] = 0;
            }

        }

        FifoOutBuffer[0] = FdoExtension->FifoBuffer[0];

        for ( i = 1;
            ( i < CommandTable[Command & COMMAND_MASK].NumberOfResultBytes ) &&
                ( NT_SUCCESS( ntStatus ) );
            i++ ) {

            ntStatus = FcGetByte(
                &FifoOutBuffer[i],
                FdoExtension,
                AllowLongDelay );
        }

        FdcRqmReadyWait(FdoExtension, 0);

    } else { // (IsNEC_98)

        if (CommandTable[Command & COMMAND_MASK].FirstResultByte > 0) {

            FifoOutBuffer[0] = FdoExtension->FifoBuffer[0];

        }

        for ( i = CommandTable[Command & COMMAND_MASK].FirstResultByte;
            ( i < CommandTable[Command & COMMAND_MASK].NumberOfResultBytes ) &&
                ( NT_SUCCESS( ntStatus ) );
            i++ ) {

            ntStatus = FcGetByte(
                &FifoOutBuffer[i],
                FdoExtension,
                AllowLongDelay );
        }
    } // (IsNEC_98)

    //
    // Flush the Adapter Channel
    //

    if (CommandTable[Command & COMMAND_MASK].DataTransfer == FDC_READ_DATA) {

       IoFlushAdapterBuffers(FdoExtension->AdapterObject,
                             (PMDL)IoHandle,
                             FdoExtension->MapRegisterBase,
                             (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                             TransferBytes,
                             FALSE);

    } else if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
               FDC_WRITE_DATA) {
        //
        // Setup Adapter Channel for Write
        //

       IoFlushAdapterBuffers(FdoExtension->AdapterObject,
                             (PMDL)IoHandle,
                             FdoExtension->MapRegisterBase,
                             (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                             TransferBytes,
                             TRUE);

    }

    return ntStatus;
}

NTSTATUS
FcSendByte(
    IN UCHAR ByteToSend,
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    )

/*++

Routine Description:

    This routine is called to send a byte to the controller.  It won't
    send the byte unless the controller is ready to receive a byte; if
    it's not ready after checking FIFO_TIGHTLOOP_RETRY_COUNT times, we
    delay for the minimum possible time (10ms) and then try again.  It
    should always be ready after waiting 10ms.

Arguments:

    ByteToSend - the byte to send to the controller.

    ControllerData - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if the byte was sent to the controller;
    STATUS_DEVICE_NOT_READY otherwise.

--*/

{
    ULONG i = 0;
    BOOLEAN byteWritten = FALSE;

    if (IsNEC_98) {

        // Always FALSE;
        AllowLongDelay = FALSE;
    }

    //
    // Sit in a tight loop for a while.  If the controller becomes ready,
    // send the byte.
    //

    do {

        if ( ( READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
            & STATUS_IO_READY_MASK ) == STATUS_WRITE_READY ) {

            WRITE_CONTROLLER(
                FdoExtension->ControllerAddress.Fifo,
                ByteToSend );

            byteWritten = TRUE;

        } else {
            KeStallExecutionProcessor(1);
        }

        i++;

    } while ( (!byteWritten) && ( i < FIFO_TIGHTLOOP_RETRY_COUNT ) );

    //
    // We hope that in most cases the FIFO will become ready very quickly
    // and the above loop will have written the byte.  But if the FIFO
    // is not yet ready, we'll loop a few times delaying for 10ms and then
    // try it again.
    //

    if ( AllowLongDelay ) {

        i = 0;

        while ( ( !byteWritten ) && ( i < FIFO_DELAY_RETRY_COUNT ) ) {

            FdcDump(
                FDCINFO,
                ("Fdc: waiting for 10ms for controller write\n")
                );

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &FdoExtension->Minimum10msDelay );

            i++;

            if ( (READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
                & STATUS_IO_READY_MASK) == STATUS_WRITE_READY ) {

                WRITE_CONTROLLER(
                    FdoExtension->ControllerAddress.Fifo,
                    ByteToSend );

                byteWritten = TRUE;
            }
        }
    }

    if ( byteWritten ) {

        return STATUS_SUCCESS;

    } else {

        //
        // We've waited over 30ms, and the FIFO *still* isn't ready.
        // Return an error.
        //

        FdcDump(
            FDCWARN,
            ("Fdc: FIFO not ready to write after 30ms\n")
            );

        FdoExtension->HardwareFailed = TRUE;

        return STATUS_DEVICE_NOT_READY;
    }
}

NTSTATUS
FcGetByte(
    OUT PUCHAR ByteToGet,
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    )

/*++

Routine Description:

    This routine is called to get a byte from the controller.  It won't
    read the byte unless the controller is ready to send a byte; if
    it's not ready after checking FIFO_RETRY_COUNT times, we delay for
    the minimum possible time (10ms) and then try again.  It should
    always be ready after waiting 10ms.

Arguments:

    ByteToGet - the address in which the byte read from the controller
    is stored.

    ControllerData - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if a byte was read from the controller;
    STATUS_DEVICE_NOT_READY otherwise.

--*/

{
    ULONG i = 0;
    BOOLEAN byteRead = FALSE;

    if (IsNEC_98) {

        // Always FALSE;
        AllowLongDelay = FALSE;
    }

    //
    // Sit in a tight loop for a while.  If the controller becomes ready,
    // read the byte.
    //

    do {

        if ( ( READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
            & STATUS_IO_READY_MASK ) == STATUS_READ_READY ) {

            *ByteToGet = READ_CONTROLLER(
                FdoExtension->ControllerAddress.Fifo );

            byteRead = TRUE;

        } else {
            KeStallExecutionProcessor(1);
        }

        i++;

    } while ( ( !byteRead ) && ( i < FIFO_TIGHTLOOP_RETRY_COUNT ) );

    //
    // We hope that in most cases the FIFO will become ready very quickly
    // and the above loop will have read the byte.  But if the FIFO
    // is not yet ready, we'll loop a few times delaying for 10ms and then
    // trying it again.
    //

    if ( AllowLongDelay ) {

        i = 0;

        while ( ( !byteRead ) && ( i < FIFO_DELAY_RETRY_COUNT ) ) {

            FdcDump(
                FDCINFO,
                ("Fdc: waiting for 10ms for controller read\n")
                );

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &FdoExtension->Minimum10msDelay );

            i++;

            if ( (READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
                & STATUS_IO_READY_MASK) == STATUS_READ_READY ) {

                *ByteToGet = READ_CONTROLLER(
                    FdoExtension->ControllerAddress.Fifo );

                byteRead = TRUE;

            }
        }
    }

    if ( byteRead ) {

        return STATUS_SUCCESS;

    } else {

        //
        // We've waited over 30ms, and the FIFO *still* isn't ready.
        // Return an error.
        //

        FdcDump(
            FDCWARN,
            ("Fdc: FIFO not ready to read after 30ms\n")
            );

        FdoExtension->HardwareFailed = TRUE;

        return STATUS_DEVICE_NOT_READY;
    }

}

VOID
FdcCheckTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL once every second by the
    I/O system.

    If the timer is "set" (greater than 0) this routine will KeSync a
    routine to decrement it.  If it ever reaches 0, the hardware is
    assumed to be in an unknown state, and so we log an error and
    initiate a reset.

    If a timeout occurs while resetting the controller, the KeSync'd
    routine will return an error, and this routine will fail any IRPs
    currently being processed.  Future IRPs will try the hardware again.

    When this routine is called, the driver state is impossible to
    predict.  However, when it is called and the timer is running, we
    know that one of the disks on the controller is expecting an
    interrupt.  So no new packets are starting on the current disk due
    to device queues, and no code should be processing this packet since
    the packet is waiting for an interrupt.

Arguments:

    DeviceObject - a pointer to the device object associated with this
    timer.

    Fdcxtension - a pointer to the fdc extension data.

Return Value:

    None.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;
    PIRP irp;

    fdoExtension = (PFDC_FDO_EXTENSION)Context;
    irp = DeviceObject->CurrentIrp;

    //
    // When the counter is -1, the timer is "off" so we don't want to do
    // anything.  If it's on, we'll have to synchronize execution with
    // other routines while we mess with the variables (and, potentially,
    // the hardware).
    //

    if ( fdoExtension->InterruptTimer == CANCEL_TIMER ) {

        return;
    }

    //
    // In the unlikely event that we attempt to reset the controller due
    // to a timeout AND that reset times out, we will need to fail the
    // IRP that was in progress at the first timeout occurred.
    //

    if ( !KeSynchronizeExecution( fdoExtension->InterruptObject,
                                  FdcTimerSync,
                                  fdoExtension ) ) {

        //
        // We're done with the reset.  Return the IRP that was being
        // processed with an error, and release the controller object.
        //

        fdoExtension->ResettingController = RESET_NOT_RESETTING;

        irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;

        IoSetHardErrorOrVerifyDevice( irp, DeviceObject );

        if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
            KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
        }
        IoCompleteRequest( irp, IO_DISK_INCREMENT );

        IoStartNextPacket( DeviceObject, FALSE );

    }
}

BOOLEAN
FdcTimerSync(
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is called at DIRQL by FdcCheckTimer() when
    InterruptTimer is greater than 0.

    If the timer is "set" (greater than 0) this routine will decrement
    it.  If it ever reaches 0, the hardware is assumed to be in an
    unknown state, and so we log an error and initiate a reset.

    When this routine is called, the driver state is impossible to
    predict.  However, when it is called and the timer is running, we
    know that one of the disks on the controller is expecting an
    interrupt.  So, no new packets are starting on the current disk due
    to device queues, and no code should be processing this packet since
    the packet is waiting for an interrupt.  The controller object must
    be held.

Arguments:

    Context - a pointer to the controller extension.

Return Value:

    Generally TRUE.

    FALSE is only returned if the controller timed out while resetting
    the drive, so this means that the hardware state is unknown.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;

    fdoExtension = (PFDC_FDO_EXTENSION)Context;

    //
    // When the counter is -1, the timer is "off" so we don't want to do
    // anything.  It may have changed since we last checked it in
    // FdcCheckTimer().
    //

    if ( fdoExtension->InterruptTimer == CANCEL_TIMER ) {

        return TRUE;
    }

    //
    // The timer is "on", so decrement it.
    //

    fdoExtension->InterruptTimer--;

    //
    // If we hit zero, the timer has expired and we'll reset the
    // controller.
    //

    if ( fdoExtension->InterruptTimer == EXPIRED_TIMER ) {

        //
        // If we were ALREADY resetting the controller when it timed out,
        // there's something seriously wrong.
        //

        FdcDump( FDCDBGP, ("Fdc: Operation Timed Out.\n") );

        if ( fdoExtension->ResettingController != RESET_NOT_RESETTING ) {

            //
            // Returning FALSE will cause the current IRP to be completed
            // with an error.  Future IRPs will probably get a timeout and
            // attempt to reset the controller again.  This will probably
            // never happen.
            //

            FdcDump( FDCDBGP, ("Fdc: Timeout Reset timed out.\n") );

            fdoExtension->InterruptTimer = CANCEL_TIMER;
            return FALSE;
        }

        //
        // Reset the controller.  This will cause an interrupt.  Reset
        // CurrentDeviceObject until after the 10ms wait, in case any
        // stray interrupts come in.
        //

        fdoExtension->ResettingController = RESET_DRIVE_RESETTING;

        DISABLE_CONTROLLER_IMAGE (fdoExtension);

#ifdef _PPC_
        fdoExtension->DriveControlImage |= DRVCTL_DRIVE_MASK;
#endif

        WRITE_CONTROLLER(
            fdoExtension->ControllerAddress.DriveControl,
            fdoExtension->DriveControlImage );

        KeStallExecutionProcessor( 10 );

        fdoExtension->CommandHasResultPhase = FALSE;
        fdoExtension->InterruptTimer = START_TIMER;

        ENABLE_CONTROLLER_IMAGE (fdoExtension);

        WRITE_CONTROLLER(
            fdoExtension->ControllerAddress.DriveControl,
            fdoExtension->DriveControlImage );

    }

    return TRUE;
}

BOOLEAN
FdcInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called at DIRQL by the system when the controller
    interrupts.

Arguments:

    Interrupt - a pointer to the interrupt object.

    Context - a pointer to our controller data area for the controller
    that interrupted.  (This was set up by the call to
    IoConnectInterrupt).

Return Value:

    Normally returns TRUE, but will return FALSE if this interrupt was
    not expected.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;
    PDEVICE_OBJECT currentDeviceObject;
    ULONG i;
    UCHAR statusByte;
    BOOLEAN controllerStateError;

    UCHAR resultStatus0;
    UCHAR aiStatus=0;
    UCHAR aiInterrupt=0;
    ULONG rqmReadyRetryCount;
    BOOLEAN Response;

    UNREFERENCED_PARAMETER( Interrupt );

#ifdef KEEP_COUNTERS
    FloppyIntrTime = KeQueryPerformanceCounter((PVOID)NULL);
    FloppyInterrupts++;
#endif

    FdcDump( FDCSHOW, ("FdcInterruptService: ") );

    fdoExtension = (PFDC_FDO_EXTENSION) Context;

    if (!IsNEC_98) {
        if (!fdoExtension->AllowInterruptProcessing) {
            FdcDump( FDCSHOW, ("processing not allowed\n") );
            return FALSE;
        }
    } // (!IsNEC_98)

    //
    // CurrentDeviceObject is set to the device object that is
    // expecting an interrupt.
    //

    currentDeviceObject = fdoExtension->CurrentDeviceObject;
    fdoExtension->CurrentDeviceObject = NULL;
    controllerStateError = FALSE;
    fdoExtension->InterruptTimer = CANCEL_TIMER;

    KeStallExecutionProcessor(10);

    if (IsNEC_98) {
        do {

            resultStatus0 = READ_CONTROLLER( fdoExtension->ControllerAddress.Status );

            resultStatus0 &= STATUS_DATA_REQUEST;

        } while (resultStatus0 != STATUS_DATA_REQUEST);
    } // (IsNEC_98)

    if ( fdoExtension->CommandHasResultPhase ) {

        //
        // Result phase of previous command.  (Note that we can't trust
        // the CMD_BUSY bit in the status register to tell us whether
        // there's result bytes or not; it's sometimes wrong).
        // By reading the first result byte, we reset the interrupt.
        // The other result bytes will be read by a thread.
        // Note that we want to do this even if the interrupt is
        // unexpected, to make sure the interrupt is dismissed.
        //

        FdcDump(
            FDCSHOW,
            ("have result phase\n")
            );

        if (IsNEC_98) {

            rqmReadyRetryCount = 0;

            while ( ( READ_CONTROLLER( fdoExtension->ControllerAddress.Status)
                    & STATUS_IO_READY_MASK1) != STATUS_RQM_READY ) {
                //
                // RQM READY CHECK**
                //

                rqmReadyRetryCount++;

                if( rqmReadyRetryCount > RQM_READY_RETRY_COUNT ) {
                    break;
                }

                KeStallExecutionProcessor( 10 );
            }

            if( rqmReadyRetryCount > ( RQM_READY_RETRY_COUNT - 1 ) ) {
                FdcDump(
                   FDCDBGP,
                   ("Floppy: Int RQM ready wait 1 error! \n")
                    );

                KeStallExecutionProcessor( 10 );
                goto FdcInterruptMidterm;

            }
        } // (IsNEC_98)

        if ( ( READ_CONTROLLER( fdoExtension->ControllerAddress.Status )
            & STATUS_IO_READY_MASK ) == STATUS_READ_READY ) {

            fdoExtension->FifoBuffer[0] =
                READ_CONTROLLER( fdoExtension->ControllerAddress.Fifo );

            FdcDump( FDCSHOW,
                     ("FdcInterruptService: 1st fifo byte %2x\n",
                     fdoExtension->FifoBuffer[0])
                     );

        } else {

            if (IsNEC_98) {

                FdcRqmReadyWait(fdoExtension, 2);

            } // (IsNEC_98)

            //
            // Should never get here.  If we do, DON'T wake up the thread;
            // let it time out and reset the controller, or let another
            // interrupt handle this.
            //

            FdcDump(
               FDCDBGP,
               ("FdcInterruptService: controller not ready to be read in ISR\n")
               );

            controllerStateError = TRUE;
        }

    } else {

        //
        // Previous command doesn't have a result phase. To read how it
        // completed, issue a sense interrupt command.  Don't read
        // the result bytes from the sense interrupt; that is the
        // responsibility of the calling thread.
        // Note that we want to do this even if the interrupt is
        // unexpected, to make sure the interrupt is dismissed.
        //

        FdcDump(
            FDCSHOW,
            ("no result phase\n")
            );
        i = 0;

        do {

            KeStallExecutionProcessor( 1 );
            statusByte =
                READ_CONTROLLER(fdoExtension->ControllerAddress.Status);
            i++;

        } while ( ( i < FIFO_ISR_TIGHTLOOP_RETRY_COUNT ) &&
            ( ( statusByte & STATUS_CONTROLLER_BUSY ) ||
            ( ( statusByte & STATUS_IO_READY_MASK ) != STATUS_WRITE_READY ) ) );

        if ( !( statusByte & STATUS_CONTROLLER_BUSY ) &&
            ( ( statusByte & STATUS_IO_READY_MASK ) == STATUS_WRITE_READY ) ) {

            WRITE_CONTROLLER(
                fdoExtension->ControllerAddress.Fifo,
                0x08 );
//                COMMND_SENSE_INTERRUPT_STATUS );

            //
            // Wait for the controller to ACK the SenseInterrupt command, by
            // showing busy.  On very fast machines we can end up running
            // driver's system-thread before the controller has had time to
            // set the busy bit.
            //

            for (i = ISR_SENSE_RETRY_COUNT; i; i--) {

                statusByte =
                    READ_CONTROLLER( fdoExtension->ControllerAddress.Status );
                if (statusByte & STATUS_CONTROLLER_BUSY) {
                    break;
                }

                KeStallExecutionProcessor( 1 );
            }

            if (!i) {
                FdcDump(
                    FDCSHOW,
                    ("FdcInterruptService: spin loop complete and controller NOT busy\n")
                    );
            }

            if ( currentDeviceObject == NULL ) {

                //
                // This is an unexpected interrupt, so nobody's going to
                // read the result bytes.  Read them now.
                //

                if (IsNEC_98) {

                    resultStatus0 = FdcRqmReadyWait(fdoExtension, 0);

                    if ((resultStatus0 & STREG0_END_DRIVE_NOT_READY) != STREG0_END_INVALID_COMMAND ) {

                        resultStatus0 = FdcRqmReadyWait(fdoExtension, 1);
                    }
                } else { // (IsNEC_98)

                    FdcDump(
                        FDCSHOW,
                        ("FdcInterruptService: Dumping fifo bytes!\n")
                        );
                    READ_CONTROLLER( fdoExtension->ControllerAddress.Fifo );
                    READ_CONTROLLER( fdoExtension->ControllerAddress.Fifo );
                } // (IsNEC_98)
            }

            if (IsNEC_98) {
                if ( currentDeviceObject != NULL ) {
                    FdcDump(
                            FDCSHOW,
                            ("Floppy: FloppyInt.---Deviceobject!=NULL2\n")
                            );

                    resultStatus0 = FdcRqmReadyWait(fdoExtension, 0);

                    //
                    // Check move state.
                    //

                    if((resultStatus0 & STREG0_END_MASK) == STREG0_END_DRIVE_NOT_READY) {

                        if(fdoExtension->ResetFlag){
                            aiStatus=1;
                            fdoExtension->CurrentDeviceObject = currentDeviceObject;
                        }

                    } else {

                        fdoExtension->FifoBuffer[0] = resultStatus0;

                        aiStatus=0;
                        aiInterrupt=1;
                    }


                    if (aiInterrupt == 0){
                        while( ((resultStatus0 & STREG0_END_DRIVE_NOT_READY) != STREG0_END_INVALID_COMMAND) && aiInterrupt==0 ) {

                            resultStatus0 = FdcRqmReadyWait(fdoExtension, 3);

                            do {
                                //
                                // Check move state.
                                //

                                if((resultStatus0 & STREG0_END_MASK) == STREG0_END_DRIVE_NOT_READY) {

                                     if(fdoExtension->ResetFlag){

                                        aiStatus=1;
                                        fdoExtension->CurrentDeviceObject = currentDeviceObject;
                                     }

                                } else {

                                    fdoExtension->FifoBuffer[0] = resultStatus0;

                                    aiStatus=0;
                                    aiInterrupt=1;
                                    break;
                                }

                                resultStatus0 = FdcRqmReadyWait(fdoExtension, 0);

                            } while ( aiInterrupt == 0 );
                        }

                        FdcDump(
                                FDCSHOW,
                                ("Floppy: FloppyInt.---Deviceobject!=NULL_out\n")
                                );
                    }
                }
            } // (IsNEC_98)

        } else {

            //
            // Shouldn't get here.  If we do, DON'T wake up the thread;
            // let it time out and reset the controller, or let another
            // interrupt take care of it.
            //

            FdcDump(
                FDCDBGP,
                ("Fdc: no result, but can't write SenseIntr\n")
                );

            controllerStateError = TRUE;
        }
    }

FdcInterruptMidterm:

    //
    // We've written to the controller, and we're about to leave.  On
    // machines with levelsensitive interrupts, we'll get another interrupt
    // if we RETURN before the port is flushed.  To make sure that doesn't
    // happen, we'll do a read here.
    //

    statusByte = READ_CONTROLLER( fdoExtension->ControllerAddress.Status );

    //
    // Let the interrupt settle.
    //

    KeStallExecutionProcessor(10);

#ifdef KEEP_COUNTERS
    FloppyEndIntrTime = KeQueryPerformanceCounter((PVOID)NULL);
    FloppyIntrDelay.QuadPart = FloppyIntrDelay.QuadPart +
                               (FloppyEndIntrTime.QuadPart -
                                FloppyIntrTime.QuadPart);
#endif

    if (IsNEC_98) {
        if(!(fdoExtension->ResetFlag)){
            fdoExtension->ResetFlag = TRUE;
        }
    } // (IsNEC_98)

    if ( currentDeviceObject == NULL ) {

        //
        // We didn't expect this interrupt.  We've dismissed it just
        // in case, but now return FALSE withOUT waking up the thread.
        //

        FdcDump(FDCDBGP,
                   ("Fdc: unexpected interrupt\n"));

        return FALSE;
    }

    if ( !controllerStateError ) {

        //
        // Request a DPC for execution later to get the remainder of the
        // floppy state.
        //

        fdoExtension->IsrReentered = 0;
        fdoExtension->AllowInterruptProcessing = FALSE;

        if (IsNEC_98) {
            if(aiStatus==0){
                IoRequestDpc(currentDeviceObject,
                             currentDeviceObject->CurrentIrp,
                             (PVOID) NULL );
            }
        } else { // (IsNEC_98)

            IoRequestDpc(currentDeviceObject,
                         currentDeviceObject->CurrentIrp,
                         (PVOID) NULL);

        } // (IsNEC_98)

    } else {

        //
        // Running the floppy (at least on R4000 boxes) we've seen
        // examples where the device interrupts, yet it never says
        // it *ISN'T* busy.  If this ever happens on non-MCA x86 boxes
        // it would be ok since we use latched interrupts.  Even if
        // the device isn't touched so that the line would be pulled
        // down, on the latched machine, this ISR wouldn't be called
        // again.  The normal timeout code for a request would eventually
        // reset the controller and retry the request.
        //
        // On the R4000 boxes and on MCA machines, the floppy is using
        // level sensitive interrupts.  Therefore if we don't do something
        // to lower the interrupt line, we will be called over and over,
        // *forever*.  This makes it look as though the machine is hung.
        // Unless we were lucky enough to be on a multiprocessor, the
        // normal timeout code would NEVER get a chance to run because
        // the timeout code runs at dispatch level, and we will never
        // leave device level.
        //
        // What we will do is keep a counter that is incremented every
        // time we reach this section of code.  When the counter goes
        // over the threshold we will do a hard reset of the device
        // and reset the counter down to zero.  The counter will be
        // initialized when the device is first initialized.  It will
        // be set to zero in the other arm of this if, and it will be
        // reset to zero by the normal timeout logic.
        //

        fdoExtension->CurrentDeviceObject = currentDeviceObject;
        if (fdoExtension->IsrReentered > FLOPPY_RESET_ISR_THRESHOLD) {

            //
            // Reset the controller.  This could cause an interrupt
            //

            fdoExtension->IsrReentered = 0;

            DISABLE_CONTROLLER_IMAGE (fdoExtension);

#ifdef _PPC_
            fdoExtension->DriveControlImage |= DRVCTL_DRIVE_MASK;
#endif

            WRITE_CONTROLLER(fdoExtension->ControllerAddress.DriveControl,
                             fdoExtension->DriveControlImage);

            KeStallExecutionProcessor( 10 );

            ENABLE_CONTROLLER_IMAGE (fdoExtension);

            WRITE_CONTROLLER(fdoExtension->ControllerAddress.DriveControl,
                             fdoExtension->DriveControlImage);

            if (IsNEC_98) {

                fdoExtension->ResetFlag = TRUE;

            } // (IsNEC_98)

            //
            // Give the device plenty of time to be reset and
            // interrupt again.  Then just do the sense interrupt.
            // this should quiet the device.  We will then let
            // the normal timeout code do its work.
            //

            KeStallExecutionProcessor(500);
            WRITE_CONTROLLER(fdoExtension->ControllerAddress.Fifo,
                             0x08 );
//                           COMMND_SENSE_INTERRUPT_STATUS );
            KeStallExecutionProcessor(500);

            KeInsertQueueDpc(&fdoExtension->LogErrorDpc,
                             NULL,
                             NULL);
        } else {

            fdoExtension->IsrReentered++;
        }

    }
    return TRUE;
}

VOID
FdcDeferredProcedure(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL by the system at the
    request of FdcInterruptService().  It simply sets the interrupt
    event, which wakes up the floppy thread.

Arguments:

    Dpc - a pointer to the DPC object used to invoke this routine.

    DeferredContext - a pointer to the device object associated with this
    DPC.

    SystemArgument1 - unused.

    SystemArgument2 - unused.

Return Value:

    None.

--*/

{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
//    PFDC_PDO_EXTENSION pdoExtension;
    PFDC_FDO_EXTENSION fdoExtension;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PLIST_ENTRY request;
    PISSUE_FDC_COMMAND_PARMS issueCommandParms;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

#ifdef KEEP_COUNTERS
    FloppyDPCs++;
    FloppyDPCTime = KeQueryPerformanceCounter((PVOID)NULL);

    FloppyDPCDelay.QuadPart = FloppyDPCDelay.QuadPart +
                              (FloppyDPCTime.QuadPart -
                               FloppyIntrTime.QuadPart);
#endif

    deviceObject = (PDEVICE_OBJECT) DeferredContext;
    fdoExtension = deviceObject->DeviceExtension;

    irp = deviceObject->CurrentIrp;

    if ( irp != NULL ) {

        irpSp = IoGetCurrentIrpStackLocation( irp );
    }

    if ( irp != NULL &&
         irpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED ) {

        issueCommandParms =
            (PISSUE_FDC_COMMAND_PARMS)
            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

        ntStatus = FcFinishCommand(
                        fdoExtension,
                        issueCommandParms->FifoInBuffer,
                        issueCommandParms->FifoOutBuffer,
                        issueCommandParms->IoHandle,
                        issueCommandParms->IoOffset,
                        issueCommandParms->TransferBytes,
                        FALSE );

        irp->IoStatus.Status = ntStatus;

        if ( !NT_SUCCESS( ntStatus ) &&
            IoIsErrorUserInduced( ntStatus ) ) {

            IoSetHardErrorOrVerifyDevice( irp, deviceObject );
        }

        if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
            KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
        }
        IoCompleteRequest( irp, IO_NO_INCREMENT );

        IoStartNextPacket( deviceObject, FALSE );

    } else {

        FdcDump( FDCSHOW, ("FdcDeferredProcedure: Set Event\n") );

        KeSetEvent( &fdoExtension->InterruptEvent, (KPRIORITY) 0, FALSE );
    }
}

NTSTATUS
FcFinishReset(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine is called to complete a reset operation which entails
    reading the interrupt status from each active channel on the floppy
    controller.

Arguments:

    FdoExtension - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if this controller appears to have been reset properly,
    error otherwise.

--*/

{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    UCHAR       statusRegister0;
    UCHAR       cylinder;
    UCHAR       driveNumber;

    FdcDump(
        FDCSHOW,
        ("Fdc: FcFinishReset\n")
        );

    //
    // Sense interrupt status for all drives.
    //
    for ( driveNumber = 0;
        ( driveNumber < MAXIMUM_DISKETTES_PER_CONTROLLER ) &&
            ( NT_SUCCESS( ntStatus ) );
        driveNumber++ ) {

        if ( driveNumber != 0 ) {

            //
            // Note that the ISR issued first SENSE INTERRUPT for us.
            //

            ntStatus = FcSendByte(
                          CommandTable[COMMND_SENSE_INTERRUPT_STATUS].OpCode,
                          FdoExtension,
                          TRUE );
        }

        if ( NT_SUCCESS( ntStatus ) ) {

            ntStatus = FcGetByte( &statusRegister0, FdoExtension, TRUE );

            if ( NT_SUCCESS( ntStatus ) ) {

                ntStatus = FcGetByte( &cylinder, FdoExtension, TRUE );
            }
        }
    }

    return ntStatus;
}

NTSTATUS
FcFdcEnabler(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    )
/*++

Routine Description:

    Call the floppy enabler driver to execute a command.  This is always a
    synchronous call and, since it includes waiting for an event, should only
    be done at IRQL_PASSIVE_LEVEL.

    All communication with the Floppy Enabler driver is carried out through
    device i/o control requests.  Any data that is to be sent to or received
    from the floppy enabler driver is included in the Type3InputBuffer section
    of the irp.

Arguments:

    DeviceObject - a pointer to the current device object.

    Ioctl - the IoControl code that will be sent to the Floppy Enabler.

    Data - a pointer to data that will be sent to or received from the Floppy
           Enabler.

Return Value:

    STATUS_TIMEOUT if the Floppy Enabler does not respond in a timely manner.
    otherwise IoStatus.Status from the Floppy Enabler is returned.

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT doneEvent;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS ntStatus;

    FdcDump(FDCINFO,("FcFdcEnabler: Calling fdc enabler with %x\n", Ioctl));

    KeInitializeEvent( &doneEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Create an IRP for enabler
    //
    irp = IoBuildDeviceIoControlRequest( Ioctl,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,
                                         &doneEvent,
                                         &ioStatus );

    if (irp == NULL) {

        FdcDump(FDCDBGP,("FcFdcEnabler: Can't allocate Irp\n"));
        //
        // If an Irp can't be allocated, then this call will
        // simply return. This will leave the queue frozen for
        // this device, which means it can no longer be accessed.
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->Parameters.DeviceIoControl.Type3InputBuffer = Data;

    //
    // Call the driver and request the operation
    //
    ntStatus = IoCallDriver(DeviceObject, irp);

    if ( ntStatus == STATUS_PENDING ) {

        //
        // Now wait for operation to complete (should already be done,  but
        // maybe not)
        //
        KeWaitForSingleObject( &doneEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        ntStatus = ioStatus.Status;
    }

    return ntStatus;
}
VOID
FdcGetEnablerDevice(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    )
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS ntStatus;

    FdcDump(FDCINFO,("FdcGetEnablerDevice:\n"));

    KeInitializeEvent( &doneEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Create an IRP for enabler
    //
    irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_INTERNAL_GET_ENABLER,
                                         FdoExtension->TargetObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,
                                         &doneEvent,
                                         &ioStatus );

    if (irp == NULL) {

        FdcDump(FDCDBGP,("FdcGetEnablerDevice: Can't allocate Irp\n"));
        //
        // If an Irp can't be allocated, then this call will
        // simply return. This will leave the queue frozen for
        // this device, which means it can no longer be accessed.
        //
        return;
    }

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = &FdoExtension->FdcEnablerSupported;

    //
    // Call the driver and request the operation
    //
    ntStatus = IoCallDriver( FdoExtension->TargetObject, irp );

    //
    // Now wait for operation to complete (should already be done,  but
    // maybe not)
    //
    if ( ntStatus == STATUS_PENDING ) {

        ntStatus = KeWaitForSingleObject( &doneEvent,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL);
    }
    return;
}


ULONG
FdcFindIsaBusNode(
    IN OUT VOID
    )

/*++

Routine Description:

    Find Isa bus node in the registry.

Arguments:


Return Value:

    Node number.

--*/

{
    ULONG   NodeNumber = 0;
    BOOLEAN FoundBus = FALSE;

    NTSTATUS Status;

    RTL_QUERY_REGISTRY_TABLE parameters[2];

    UNICODE_STRING invalidBusName;
    UNICODE_STRING targetBusName;
    UNICODE_STRING isaBusName;

    //
    // Initialize invalid bus name.
    //
    RtlInitUnicodeString(&invalidBusName,L"BADBUS");

    //
    // Initialize "ISA" bus name.
    //
    RtlInitUnicodeString(&isaBusName,L"ISA");

    parameters[0].QueryRoutine = NULL;
    parameters[0].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                          RTL_QUERY_REGISTRY_DIRECT;
    parameters[0].Name = L"Identifier";
    parameters[0].EntryContext = &targetBusName;
    parameters[0].DefaultType = REG_SZ;
    parameters[0].DefaultData = &invalidBusName;
    parameters[0].DefaultLength = 0;

    parameters[1].QueryRoutine = NULL;
    parameters[1].Flags = 0;
    parameters[1].Name = NULL;
    parameters[1].EntryContext = NULL;

    do {
        CHAR AnsiBuffer[512];

        ANSI_STRING AnsiString;
        UNICODE_STRING registryPath;

        //
        // Build path buffer...
        //
        sprintf(AnsiBuffer,ISA_BUS_NODE,NodeNumber);
        RtlInitAnsiString(&AnsiString,AnsiBuffer);
        Status = RtlAnsiStringToUnicodeString(&registryPath,&AnsiString,TRUE);

        if (!(NT_SUCCESS(Status))) {
            break;
        }

        //
        // Initialize recieve buffer.
        //
        targetBusName.Buffer = NULL;

        //
        // Query it.
        //
        Status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                        registryPath.Buffer,
                                        parameters,
                                        NULL,
                                        NULL);

        RtlFreeUnicodeString(&registryPath);

        if (!NT_SUCCESS(Status) || (targetBusName.Buffer == NULL)) {
            break;
        }

        //
        // Is this "ISA" node ?
        //
        if (RtlCompareUnicodeString(&targetBusName,&isaBusName,TRUE) == 0) {
            //
            // Found.
            //
            FoundBus = TRUE;
            break;
        }

        //
        // Can we find any node for this ??
        //
        if (RtlCompareUnicodeString(&targetBusName,&invalidBusName,TRUE) == 0) {
            //
            // Not found.
            //
            break;
        }

        RtlFreeUnicodeString(&targetBusName);

        //
        // Next node number..
        //
        NodeNumber++;

    } while (TRUE);

    if (targetBusName.Buffer) {
        RtlFreeUnicodeString(&targetBusName);
    }

    if (!FoundBus) {
        NodeNumber = (ULONG)-1;
    }

    return (NodeNumber);
}


NTSTATUS
FdcHdbit(
    IN PDEVICE_OBJECT      DeviceObject,
    IN PFDC_FDO_EXTENSION  FdoExtension,
    IN PSET_HD_BIT_PARMS   SetHdBitParams
    )

/*++

Routine Description:

    Set a Hd bit or a FDD EXC bit.

Arguments:

    fdoExtension - a pointer to our data area for the device extension.


Return Value:

        TRUE : Changed HD bit
        FALSE: No changed HD bit

--*/

{
    NTSTATUS ntStatus;
    USHORT   st;                // State of HD bit
    USHORT   st2;               // Set on/off HD bit
    USHORT   st3;               // When set HD bit, then st3=1
    USHORT   st4;               // 1.44MB bit for 1.44MB media
    SHORT    sel;               // 1.44MB Selector No for 1.44MB media
    SHORT    st5=0;             // 1.44MB on: wait for spin for 1.44MB media
    LARGE_INTEGER motorOnDelay;

    USHORT      lpc;
    UCHAR       resultStatus0Save[4];
    USHORT      resultStatus0;
    ULONG       getStatusRetryCount;
    ULONG       rqmReadyRetryCount;

    BOOLEAN     media144MB;
    BOOLEAN     mediaMore120MB;
    BOOLEAN     supportDrive;

    media144MB      = SetHdBitParams->Media144MB;
    mediaMore120MB  = SetHdBitParams->More120MB;
    sel             = SetHdBitParams->DeviceUnit;
    SetHdBitParams->ChangedHdBit = FALSE;


    ASSERT( FdoExtension->ControllerAddress.ModeChange   == (PUCHAR)0xbe );
    ASSERT( FdoExtension->ControllerAddress.ModeChangeEx == (PUCHAR)0x4be );

    supportDrive    = TRUE;

    st3=0;

    ntStatus=0;

    //
    // Normal mode.
    //

    st = READ_CONTROLLER(FdoExtension->ControllerAddress.ModeChange);
    st2 = st & 0x02;

    //
    // Normal mode.
    // Check dip switch.
    //

    st4 = READ_CONTROLLER(FdoExtension->ControllerAddress.DriveControl);
    st4 = st4 & 0x04;

    if (((FdoExtension->FloppyEquip) & 0x0c) != 0) {
        //
        // Exist out side FDD unit.
        //

        if ( st4 == 0 ) {
            //
            // DIP SW 1-4 on
            //

            sel = sel - 2;

            if( sel < 0 ) {
                sel = sel + 4;
            }
        }
    }

    if ( supportDrive ) {

        for( lpc = 0 ; lpc < 4 ; lpc++ ) {

            resultStatus0Save[lpc]=FdoExtension->ResultStatus0[lpc];
        }

        if ( SetHdBitParams->DriveType144MB ) {
            //
            // 1.44MB drive.
            //

            st4=sel*32;
            WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChangeEx,st4);

            st4 = READ_CONTROLLER(FdoExtension->ControllerAddress.ModeChangeEx);
            st4 = st4 & 0x01;

            if ( media144MB ) {

                //
                // 1.44MB media.
                //

                if(st4==0){

                    //
                    // WRE on, IHMD off.
                    //

                    st4=sel*32+0x11;
                    WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChangeEx,st4);
                    st5=1;
                }

            } else {

                //
                // Not 1.44MB media.
                //

                if(st4!=0){

                    //
                    // WRE on, IHMD off.
                    //

                    st4=sel*32+0x10;
                    WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChangeEx,st4);
                    st5=1;
                }
            }
        }

        if ( mediaMore120MB ) {
            //
            // Media 1.2MB and More.
            //

            if(st2==0){
                //
                // When FDD exc bit is on,
                // then set  FDD exc bit off,
                // and set emotion bit on.
                //
                st |= 0x02;
                st |= 0x04;

                WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChange,st);
                st3 = 1;

            }
        } else {
            //
            // Media between 160 and 720
            //

            if ( st2 != 0 ) {
                //
                // When FDD exc bit is on,
                // then set  FDD exc bit off,
                // and set emotion bit on.
                //

                st &= 0xfd;
                st |= 0x04;

                WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChange,st);
                st3 = 1;

            }
        }

        if(st5==1){

            //
            // Wait until motor spin up.
            //

            motorOnDelay.LowPart = (unsigned long)(- ( 10 * 1000 * 600 ));   /*500ms*/
            motorOnDelay.HighPart = -1;
            (VOID) KeDelayExecutionThread( KernelMode, FALSE, &motorOnDelay );

            //
            // Sense target drive and get all data at transition of condistion.
            //

            FdoExtension->FifoBuffer[0] = COMMND_SENSE_DRIVE_STATUS;
            FdoExtension->FifoBuffer[1] = SetHdBitParams->DeviceUnit;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            resultStatus0 = FdcRqmReadyWait(FdoExtension, 0);

        }

        for(lpc=0;lpc<4;lpc++){
            FdoExtension->ResultStatus0[lpc] = resultStatus0Save[lpc];
        }

        //
        // Change HD bit?
        //

        if(st3==1){
            FcInitializeControllerHardware(FdoExtension,DeviceObject);
            SetHdBitParams->ChangedHdBit = TRUE;
        }

    }

    FdcDump(
            FDCSTATUS,
            ("Floppy : HdBit resultStatus0 = %x \n",
            resultStatus0)
            );

    return ntStatus;
}


ULONG
FdcGet0Seg(
    IN PUCHAR   ConfigurationData1,
    IN ULONG    Offset
    )

/*++

Routine Description:

    This routine get BIOS common area data and return it.
        0x500 :    1MB port or not
        0x501 :    High resolution/Normal, 386/768KB
        0x55c :    1MB drive : [#0,#1] or [#0,#1,#2,#3]

Arguments:

    Offset - Offset value from 0 segment(0:<Offset>).

Return Value:

        BIOS common area data.

--*/

{
        UCHAR           biosCommonAreaData   = 0;

        if ((Offset<0x400) || (Offset>0x5ff)) {

                return (ULONG)0xffff;
        }

        //
        // Get BIOS common area data.
        //

        biosCommonAreaData = ConfigurationData1[40+(Offset-0x400)];

        return (ULONG)biosCommonAreaData;
}

UCHAR
FdcRqmReadyWait(
    IN PFDC_FDO_EXTENSION  FdoExtension,
    IN ULONG               IssueSenseInterrupt
    )

/*++

Routine Description:

    RQM Ready wait

Arguments:

    FdoExtension         - a pointer to our data area for the device extension.
    IssueSenseInterrupt  - Indicate issue COMMND_SENSE_INTERRUPT_STATUS.
                            0 - Issue no COMMND_SENSE_INTERRUPT_STATUS.
                            1 - Issue COMMND_SENSE_INTERRUPT_STATUS with RQM Check.
                            2 - Issue COMMND_SENSE_INTERRUPT_STATUS without RQM Check.
                            3 - Issue COMMND_SENSE_INTERRUPT_STATUS for AI Interrupt.


Return Value:

    ntStatus - STATUS_SUCCESS

--*/

{

    ULONG       getStatusRetryCount;
    ULONG       rqmReadyRetryCount;
    ULONG       j;
    UCHAR       resultStatus0;
    UCHAR       statusByte;

    ASSERT(IssueSenseInterrupt < 4);

    do{
        if (IssueSenseInterrupt != 0) {

            //
            // Sense Interrupt status.
            // RQM ready wait.
            //

            if ((IssueSenseInterrupt == 1) || (IssueSenseInterrupt == 3)) {

                rqmReadyRetryCount=0;
                //
                // RQM ready check.
                //
                while ((READ_CONTROLLER( FdoExtension->ControllerAddress.Status)
                        & STATUS_IO_READY_MASK1) != STATUS_RQM_READY){

                    rqmReadyRetryCount++;

                    if(rqmReadyRetryCount > RQM_READY_RETRY_COUNT){
                            break;
                    }
                    KeStallExecutionProcessor( 1 );
                }
                if(rqmReadyRetryCount > (RQM_READY_RETRY_COUNT-1)){
                    FdcDump(
                            FDCDBGP,
                            ("Floppy: Issue RQM ready wait 1 error! \n")
                             );
                    if (IssueSenseInterrupt == 1) {
                        break;
                    }
                }

            }

            //
            // Issue sense interrupt forcibly.
            //

            WRITE_CONTROLLER(
                  FdoExtension->ControllerAddress.Fifo,
                  0x08);
//                  COMMND_SENSE_INTERRUPT_STATUS ); //******C-Phase DATA WRITE*

            //
            // Wait for busy.
            //
            for (rqmReadyRetryCount = ISR_SENSE_RETRY_COUNT; rqmReadyRetryCount; rqmReadyRetryCount--) {
                statusByte = READ_CONTROLLER(
                FdoExtension->ControllerAddress.Status );
                if (statusByte & STATUS_CONTROLLER_BUSY)
                    break;

                KeStallExecutionProcessor( 1 );

            }
        }

        //
        // Get status.
        //

        getStatusRetryCount = 0;

        j = 0;

        do {
            //
            // Check RQM ready.
            //

            rqmReadyRetryCount=0;

            while ((READ_CONTROLLER( FdoExtension->ControllerAddress.Status)
                  & STATUS_IO_READY_MASK1) != STATUS_RQM_READY){

                rqmReadyRetryCount++;

                if(rqmReadyRetryCount > RQM_READY_RETRY_COUNT){
                    break;
                }

                KeStallExecutionProcessor( 1 );
            }

            if(rqmReadyRetryCount > (RQM_READY_RETRY_COUNT-1)){

                FdcDump(
                    FDCDBGP,
                    ("Floppy: Int RQM ready wait \n")
                     );

                KeStallExecutionProcessor( 1 );
                break;
            }

            //
            // Get status even if it is transition of condition.
            //

            statusByte = READ_CONTROLLER(FdoExtension->ControllerAddress.Status);

            if ((statusByte & STATUS_IO_READY_MASK) == STATUS_WRITE_READY) {

                //
                // DIO is 1.
                //

                break;
            }

            if (j == 0) {

                //
                // R-Phase: Data read.
                //

                resultStatus0 = READ_CONTROLLER( FdoExtension->ControllerAddress.Fifo );

                j=1;

                //
                // Check transition of condition.
                //

                if((resultStatus0 & STREG0_END_MASK)==STREG0_END_INVALID_COMMAND){
                    //
                    // Invalid
                    //
                    break;
                }

                if((resultStatus0 & STREG0_END_MASK) == STREG0_END_DRIVE_NOT_READY){
                    if(FdoExtension->ResetFlag){
                        FdoExtension->ResultStatus0[resultStatus0 & 3] = resultStatus0;
                    }
                }

            } else {

                //
                // R-Phase: Data read.
                //
                READ_CONTROLLER( FdoExtension->ControllerAddress.Fifo );
            }

            getStatusRetryCount++;

        } while (getStatusRetryCount > RQM_READY_RETRY_COUNT);

        if(getStatusRetryCount > RQM_READY_RETRY_COUNT-1){

            KeStallExecutionProcessor( 1 );
            FdcDump(
                FDCDBGP,
                ("Floppy: Issue status overflow error! \n")
                );
        }

    } while ((IssueSenseInterrupt != 0) &&
             ((resultStatus0 & STREG0_END_MASK) != STREG0_END_INVALID_COMMAND));

    return resultStatus0;

}

#ifdef TOSHIBAJ
/*
    IOCTL_DISK_INTERNAL_ENABLE_3_MODE:

    Media   Speed   T/F
  -------------------------
    1.44MB  300RPM  FALSE
    1.23MB  360RPM  TRUE

*/
#define RPM_300 1   // 1.44MB media format
#define RPM_360 2   // 1.2MB,1.23MB media format
NTSTATUS FcFdcEnable3Mode(
    IN      PFDC_FDO_EXTENSION FdoExtension,
    IN      PIRP Irp
    )
{   NTSTATUS    ntStatus;
    PENABLE_3_MODE  param;
    PIO_STACK_LOCATION irpSp;
    UCHAR           motorSpeed;
    UCHAR           unitNumber;
    PUCHAR          configPort;
    UCHAR           configDataValue = 0;
    LARGE_INTEGER   changeRotationDelay;

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    param = (PENABLE_3_MODE)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    FdcDump(FDCSHOW,("FcFdcEnable3MODE()\n"));
    if( param == NULL )
        return STATUS_SUCCESS;  // may be later...

    FdcDump(FDCSHOW,("Parameters...%d %d\n",
//          param->DeviceUnit, param->Enable3Mode, param->Context));
            param->DeviceUnit, param->Enable3Mode));

    if (FdoExtension->Available3Mode==FALSE)
        return STATUS_SUCCESS;

//  if(param->Context==TRUE)
//      return  STATUS_SUCCESS;

    unitNumber = param->DeviceUnit;
    motorSpeed = (param->Enable3Mode)? SMC_DENSEL_LOW: SMC_DELSEL_HIGH; // 360:300

    // Feb.9.1998 KIADP013 Change Speed
    // Change speed
    // 1.Enter configuration state
    // 2.Select device
    // 3.Change speed
    //   Write 'f1h' to index port
    //   Read from data port
    //   Rewrite to data port
    //     bit [3:2] Densel speed
    //       10       H     360rpm
    //       11       L     300rpm
    // 4.Exit configuration state

    configPort = FdoExtension->ConfigBase;

    FdcDump(
        FDCSHOW,
        ("Config: index port %x, data port %x\n",
         SMC_INDEX_PORT(configPort), SMC_DATA_PORT(configPort))
    );

    // Must change data transfer rate to 500BPS when change FDD rotation.
    WRITE_CONTROLLER(FdoExtension->ControllerAddress.DRDC.DataRate, DATART_0500 );

    // Change speed
    WRITE_PORT_UCHAR(configPort, SMC_KEY_ENTER_CONFIG);   // Enter config state

    // Select FDD
    WRITE_PORT_UCHAR(SMC_INDEX_PORT(configPort), SMC_INDEX_DEVICE);
    WRITE_PORT_UCHAR(SMC_DATA_PORT(configPort), SMC_DEVICE_FDC);

    // Get current value
    WRITE_PORT_UCHAR(SMC_INDEX_PORT(configPort), SMC_INDEX_FDC_OPT);
    configDataValue = READ_PORT_UCHAR(SMC_DATA_PORT(configPort));
    if ((configDataValue & SMC_MASK_DENSEL) == motorSpeed) {
        WRITE_PORT_UCHAR(configPort, SMC_KEY_EXIT_CONFIG);
        return STATUS_SUCCESS;
    }
    // Set speed
    configDataValue &= ~SMC_MASK_DENSEL;
    configDataValue |= motorSpeed;
    WRITE_PORT_UCHAR(SMC_DATA_PORT(configPort), configDataValue);

    WRITE_PORT_UCHAR(configPort, SMC_KEY_EXIT_CONFIG);    // Exit config state

    if (motorSpeed == SMC_DENSEL_LOW) {
        FdcDump(
            FDCSHOW,
            ("------- FDD rotation change: 300rpm -> 360rpm\n")
        );
    } else {
        FdcDump(
            FDCSHOW,
            ("------- FDD rotation change: 360rpm -> 300rpm\n")
        );
    }

    // Set Delay time to 500ms
    changeRotationDelay.LowPart =(ULONG)( - ( 10 * 1000 * 500 ));   // 17-Oct-1994 RKBUG001
    changeRotationDelay.HighPart = -1;

    FdoExtension->LastMotorSettleTime = changeRotationDelay;

    // Delay 500ms
    KeDelayExecutionThread( KernelMode, FALSE, &changeRotationDelay );

    return STATUS_SUCCESS;
}

NTSTATUS FcFdcAvailable3Mode(
    IN      PFDC_FDO_EXTENSION FdoExtension,
    IN      PIRP Irp
    )
{
    PIO_STACK_LOCATION irpSp;

    FdcDump(FDCSHOW,("FcFdcAvailabe3MODE\n"));
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    // Feb.9.1998 KIADP012 Identify controller
    // Feb.12.1998 KIADP014 Get the address of config port

    return (FdoExtension->Available3Mode)? STATUS_SUCCESS: STATUS_UNSUCCESSFUL;
}

//  Feb.12.1998 KIADP014 Get the address of config port
BOOLEAN
FcCheckConfigPort(
    IN PUCHAR  ConfigPort
    )
{
    BOOLEAN             found = FALSE;
    ULONG               configAddr = 0;
    UCHAR               controllerId = 0;

    FdcDump( FDCSHOW, ("FcCheckConfigPort: Configuration Port %x\n", ConfigPort) );

    if (!SmcConfigID) {
        return found;
    }

    // Get data
    if (ConfigPort) {
        WRITE_PORT_UCHAR(ConfigPort, SMC_KEY_ENTER_CONFIG);

        // Controller ID
        if (SmcConfigID) {
            WRITE_PORT_UCHAR(SMC_INDEX_PORT(ConfigPort), SMC_INDEX_IDENTIFY);
            controllerId = READ_PORT_UCHAR(SMC_DATA_PORT(ConfigPort));
            FdcDump( FDCINFO, ("Fdc: Controller ID %x\n", controllerId) );
        }

        WRITE_PORT_UCHAR(ConfigPort,SMC_KEY_EXIT_CONFIG);
    }


    // Check data
    if (controllerId == SmcConfigID) {
            found = TRUE;
    }

    return found;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\inc\flpyenbl.h ===
/*++

Copyright (c) 1996  Hewlett-Packard Corporation

Module Name:

    cmsfcxx.h

Abstract:

    This file includes data declarations for Floppy Controller Enabling

Author:

    Kurt Godwin (v-kurtg) 26-Mar-1996.

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#define FDC_VALUE_API_SUPPORTED L"APISupported"
#define FDC_VALUE_CLOCK_48MHZ   L"Clock48MHz"

//
// Floppy controler data rates (to be OR'd together)
//
#define FDC_SPEED_250KB     0x0001
#define FDC_SPEED_300KB     0x0002
#define FDC_SPEED_500KB     0x0004
#define FDC_SPEED_1MB       0x0008
#define FDC_SPEED_2MB       0x0010

//
// Dma Width supported
//
#define FDC_8_BIT_DMA       0x0001
#define FDC_16_BIT_DMA      0x0002

//
// Dma direction
//
#define FDC_READ_FROM_MEMORY 0x0000
#define FDC_WRITE_TO_MEMORY  0x0001

//
// Clock Rate to the FDC (FDC_82078 only)
//
#define FDC_CLOCK_NORMAL      0x0000    // Use this for non 82078 parts
#define FDC_CLOCK_48MHZ       0x0001    // 82078 with a 48MHz clock
#define FDC_CLOCK_24MHZ       0x0002    // 82078 with a 24MHz clock

//
// Floppy controler types
//
#define FDC_TYPE_NORMAL          2  // Any NEC 768 compatible, 250Kb/sec 500Kb/sec
#define FDC_TYPE_ENHANCED        3  // Any NEC 768 compatible that supports the version command, 250Kb/sec 500Kb/sec
#define FDC_TYPE_82077           4  // National 8477, 250Kb/sec 500Kb/sec 1Mb/sec
#define FDC_TYPE_82077AA         5  // Intel 82077, 250Kb/sec 500Kb/sec 1Mb/sec
#define FDC_TYPE_82078_44        6  // Intel 82077AA, 250Kb/sec 500Kb/sec 1Mb/sec
#define FDC_TYPE_82078_64        7  // Intel 82078 44 Pin Version, 250Kb/sec 500Kb/sec 1Mb/sec(2Mb/sec capable)
#define FDC_TYPE_NATIONAL        8  // Intel 82078 64 Pin Version, 250Kb/sec 500Kb/sec 1Mb/sec(2Mb/sec capable)


typedef struct _FDC_MODE_SELECT {
    ULONG structSize;       // Size of this structure (inclusive)

    ULONG Speed;            // Should be only ONE of the data rates (i.e. FDC_SPEED_XXX)
                            // ONLY select speeds that were available from FDC_INFORMATION

    ULONG DmaWidth;         // Should be only ONE of the dma widths (i.e. FDC_16_BIT_DMA)
                            // ONLY select DMA Widths that were available from FDC_INFORMATION
    ULONG DmaDirection;     // Should be FDC_READ_FROM_MEMORY or FDC_WRITE_TO_MEMORY

    ULONG ClockRate;        // Should be FDC_48MHZ, FDC_24MHZ or zero

} FDC_MODE_SELECT, *PFDC_MODE_SELECT;

typedef struct _FDC_INFORMATION {
    ULONG structSize;       // Size of this structure (inclusive)

    ULONG SpeedsAvailable;      // Any combination of FDC_SPEED_xxxx or'd together

    ULONG DmaWidthsSupported;   // Any combination of FDC_xx_BIT_DMA

    ULONG ClockRatesSupported;  // Should be FDC_48MHZ, FDC_24MHZ or zero
                                // If the part is capable of both speeds
                                // return both OR'd together.  It is then
                                // the caller's responsiblity to set the
                                // proper data rate with FDC_MODE_SELECT

    ULONG FloppyControllerType; // Should be any ONE of type FDC_TYPE_XXXX

} FDC_INFORMATION, *PFDC_INFORMATION;

#define IOCTL_FLPENBL_BASE                 FILE_DEVICE_TAPE

//
// IOCTL Codes set to the enabler driver's IRP_MJ_INTERNAL_DEVICE_CONTROL
//
//
//


//
// ACQUIRE_FDC:
//
// input: Type3InputBuffer = PLARGE_INTEGER timeout;
// output:
//
// status:
//      Completion status will be STATUS_SUCCESS or STATUS_IN_USE
//
#define IOCTL_AQUIRE_FDC     CTL_CODE(IOCTL_FLPENBL_BASE, 0x0001, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_ACQUIRE_FDC    CTL_CODE(IOCTL_FLPENBL_BASE, 0x0001, METHOD_NEITHER, FILE_ANY_ACCESS)


//
// RELEASE_FDC
//
// input:
// output:
//
// status:
//      Completion status will be STATUS_SUCCESS or STATUS_INVALID_PARAMETER
//
#define IOCTL_RELEASE_FDC   CTL_CODE(IOCTL_FLPENBL_BASE, 0x0002, METHOD_NEITHER, FILE_ANY_ACCESS)


//
// GET_FDC_INFO
//
//
// input:
//      For this function,
//      (irp stack)->Parameters.DeviceIoControl.Type3InputBuffer
//      will point to a FDC_INFORMATION buffer (output only)
//
// output:
//
// status:
//      ioCompletion status will allways be STATUS_SUCCESS
//
#define IOCTL_GET_FDC_INFO  CTL_CODE(IOCTL_FLPENBL_BASE, 0x0003, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// SET_FDC_MODE
//
// input:
//      For this function,
//      (irp stack)->Parameters.DeviceIoControl.Type3InputBuffer
//      will point to a FDC_MODE_SELECT buffer (input only)
//
//
// output:
//
// status:
//
// ioCompletion status will be STATUS_SUCCESS or STATUS_INVALID_PARAMETER
//
#define IOCTL_SET_FDC_MODE  CTL_CODE(IOCTL_FLPENBL_BASE, 0x0004, METHOD_NEITHER, FILE_ANY_ACCESS)

// ADD_CONTENDER
//
// input:
//      controller # (as in FloppyController#) of the controller that
//      wants to contend for resources used by this controller
//
// output:
//      NOTHING
//
#define IOCTL_ADD_CONTENDER  CTL_CODE(IOCTL_FLPENBL_BASE, 0x0005, METHOD_NEITHER, FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\flpydisk\flo_data.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    flo_data.h

Abstract:

    This file includes data and hardware declarations for the NEC PD765
    (aka AT, ISA, and ix86) and Intel 82077 (aka MIPS) floppy driver for
    NT.

Author:


Environment:

    Kernel mode only.

Notes:


--*/


#if DBG
//
// For checked kernels, define a macro to print out informational
// messages.
//
// FloppyDebug is normally 0.  At compile-time or at run-time, it can be
// set to some bit patter for increasingly detailed messages.
//
// Big, nasty errors are noted with DBGP.  Errors that might be
// recoverable are handled by the WARN bit.  More information on
// unusual but possibly normal happenings are handled by the INFO bit.
// And finally, boring details such as routines entered and register
// dumps are handled by the SHOW bit.
//
#define FLOPDBGP              ((ULONG)0x00000001)
#define FLOPWARN              ((ULONG)0x00000002)
#define FLOPINFO              ((ULONG)0x00000004)
#define FLOPSHOW              ((ULONG)0x00000008)
#define FLOPIRPPATH           ((ULONG)0x00000010)
#define FLOPFORMAT            ((ULONG)0x00000020)
#define FLOPSTATUS            ((ULONG)0x00000040)
#define FLOPPNP               ((ULONG)0x00000080)
extern ULONG FloppyDebugLevel;
#define FloppyDump(LEVEL,STRING) \
        do { \
            if (FloppyDebugLevel & (LEVEL)) { \
                DbgPrint STRING; \
            } \
        } while (0)
#else
#define FloppyDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif

//
//  Define macros for driver paging
//
#define FloppyPageEntireDriver()            \
{                                           \
    ExAcquireFastMutex(PagingMutex);        \
    if (--PagingReferenceCount == 0) {      \
        MmPageEntireDriver(DriverEntry);    \
    }                                       \
    ExReleaseFastMutex(PagingMutex);        \
}

#define FloppyResetDriverPaging()           \
{                                           \
    ExAcquireFastMutex(PagingMutex);        \
    if (++PagingReferenceCount == 1) {      \
        MmResetDriverPaging(DriverEntry);   \
    }                                       \
    ExReleaseFastMutex(PagingMutex);        \
}




//
// If we don't get enough map registers to handle the maximum track size,
// we will allocate a contiguous buffer and do I/O to/from that.
//
// On MIPS, we should always have enough map registers.  On the ix86 we
// might not, and when we allocate the contiguous buffer we have to make
// sure that it's in the first 16Mb of RAM to make sure the DMA chip can
// address it.
//

#define MAXIMUM_DMA_ADDRESS                0xFFFFFF

//
// The byte in the boot sector that specifies the type of media, and
// the values that it can assume.  We can often tell what type of media
// is in the drive by seeing which controller parameters allow us to read
// the diskette, but some different densities are readable with the same
// parameters so we use this byte to decide the media type.
//

typedef struct _BOOT_SECTOR_INFO {
    UCHAR   JumpByte[1];
    UCHAR   Ignore1[2];
    UCHAR   OemData[8];
    UCHAR   BytesPerSector[2];
    UCHAR   Ignore2[6];
    UCHAR   NumberOfSectors[2];
    UCHAR   MediaByte[1];
    UCHAR   Ignore3[2];
    UCHAR   SectorsPerTrack[2];
    UCHAR   NumberOfHeads[2];
} BOOT_SECTOR_INFO, *PBOOT_SECTOR_INFO;


//
// Retry counts -
//
// When attempting I/O, we may run into many different errors.  The
// hardware retries things 8 times invisibly.  If the hardware reports
// any type of error, we will recalibrate and retry the operation
// up to RECALIBRATE_RETRY_COUNT times.  When this expires, we check to
// see if there's an overrun - if so, the DMA is probably being hogged
// by a higher priority device, so we repeat the earlier loop up to
// OVERRUN_RETRY_COUNT times.
//
// Any packet that is about to be returned with an error caused by an
// unexpected hardware error or state will be restarted from the very
// beginning after resetting the hardware HARDWARE_RESET_RETRY_COUNT
// times.
//

#define RECALIBRATE_RETRY_COUNT            3
#define OVERRUN_RETRY_COUNT                1
#define HARDWARE_RESET_RETRY_COUNT         2

//
// The I/O system calls our timer routine once every second.  If the timer
// counter is -1, the timer is "off" and the timer routine will just return.
// By setting the counter to 3, the timer routine will decrement the
// counter every second, so the timer will expire in 2 to 3 seconds.  At
// that time the drive motor will be turned off.
//

#define TIMER_CANCEL                       -1
#define TIMER_EXPIRED                      0
#define FDC_TIMEOUT                        4


//
// Define drive types.  Numbers are read from CMOS, translated to these
// numbers, and then used as an index into the DRIVE_MEDIA_LIMITS table.
//

#define DRIVE_TYPE_0360                    0
#define DRIVE_TYPE_1200                    1
#define DRIVE_TYPE_0720                    2
#define DRIVE_TYPE_1440                    3
#define DRIVE_TYPE_2880                    4
#define DRIVE_TYPE_1200_E                  5  // NEC98: 5.25" 1.2Mb  externel drive

#define NUMBER_OF_DRIVE_TYPES              5
#define NUMBER_OF_DRIVE_TYPES_NEC98        6
#define DRIVE_TYPE_NONE                    NUMBER_OF_DRIVE_TYPES
#define DRIVE_TYPE_INVALID                 DRIVE_TYPE_NONE + 1

#define BOOT_SECTOR_SIZE      (IsNEC_98 ? 1024 : 512)

//
// Media types are defined in ntdddisk.h, but we'll add one type here.
// This keeps us from wasting time trying to determine the media type
// over and over when, for example, a fresh floppy is about to be
// formatted.
//

#define Undetermined                       -1

//
// Define all possible drive/media combinations, given drives listed above
// and media types in ntdddisk.h.
//
// These values are used to index the DriveMediaConstants table.
//

#define _NUMBER_OF_DRIVE_MEDIA_COMBINATIONS_             17
#define _NUMBER_OF_DRIVE_MEDIA_COMBINATIONS_NEC98_       21

#define NUMBER_OF_DRIVE_MEDIA_COMBINATIONS \
        (ULONG)(IsNEC_98 ? _NUMBER_OF_DRIVE_MEDIA_COMBINATIONS_NEC98_ : _NUMBER_OF_DRIVE_MEDIA_COMBINATIONS_)

typedef enum _DRIVE_MEDIA_TYPE {
    Drive360Media160,                      // 5.25"  360k  drive;  160k   media
    Drive360Media180,                      // 5.25"  360k  drive;  180k   media
    Drive360Media320,                      // 5.25"  360k  drive;  320k   media
    Drive360Media32X,                      // 5.25"  360k  drive;  320k 1k secs
    Drive360Media360,                      // 5.25"  360k  drive;  360k   media
    Drive720Media720,                      // 3.5"   720k  drive;  720k   media
    Drive120Media160,                      // 5.25" 1.2Mb  drive;  160k   media
    Drive120Media180,                      // 5.25" 1.2Mb  drive;  180k   media
    Drive120Media320,                      // 5.25" 1.2Mb  drive;  320k   media
    Drive120Media32X,                      // 5.25" 1.2Mb  drive;  320k 1k secs
    Drive120Media360,                      // 5.25" 1.2Mb  drive;  360k   media
    Drive120Media120,                      // 5.25" 1.2Mb  drive; 1.2Mb   media
    Drive144Media720,                      // 3.5"  1.44Mb drive;  720k   media
    Drive144Media144,                      // 3.5"  1.44Mb drive; 1.44Mb  media
    Drive288Media720,                      // 3.5"  2.88Mb drive;  720k   media
    Drive288Media144,                      // 3.5"  2.88Mb drive; 1.44Mb  media
    Drive288Media288                       // 3.5"  2.88Mb drive; 2.88Mb  media
} DRIVE_MEDIA_TYPE;

//
// for NEC98
//
typedef enum _DRIVE_MEDIA_TYPE_NEC98 {
    Drive360Media160Nec98,                 // 5.25"  360k  drive;  160k   media
    Drive360Media180Nec98,                 // 5.25"  360k  drive;  180k   media
    Drive360Media320Nec98,                 // 5.25"  360k  drive;  320k   media
    Drive360Media32XNec98,                 // 5.25"  360k  drive;  320k 1k secs
    Drive360Media360Nec98,                 // 5.25"  360k  drive;  360k   media

    Drive120Media160Nec98,                 //  5.25" 1.2Mb drive;  160k   media
    Drive120Media180Nec98,                 //  5.25" 1.2Mb drive;  180k   media
    Drive120Media320Nec98,                 //  5.25" 1.2Mb drive;  320k   media
    Drive120Media32XNec98,                 //  5.25" 1.2Mb drive;  320k 1k secs
    Drive120Media360Nec98,                 //  5.25" 1.2Mb drive;  360k   media
    Drive120Media640Nec98,                 //  5.25" 1.2Mb drive;  640k   media
    Drive120Media720Nec98,                 //  5.25" 1.2Mb drive;  720k   media
    Drive120Media120Nec98,                 //  5.25" 1.2Mb drive; 1.2Mb   media
    Drive120Media123Nec98,                 //  5.25" 1.2Mb drive;1.25Mb   media

    Drive144Media640Nec98,                 //  3.5"  1.44Mb drive;  640k   media
    Drive144Media720Nec98,                 //  3.5"  1.44Mb drive;  720k   media
    Drive144Media120Nec98,                 //  3.5"  1.44Mb drive; 1.2Mb   media
    Drive144Media123Nec98,                 //  3.5"  1.44Mb drive; 1.25Mb   media
    Drive144Media144Nec98,                 //  3.5"  1.44Mb drive; 1.44Mb  media

    Drive12EMedia120Nec98,                 //  5.25" 1.2Mb externel drive; 1.2Mb   media
    Drive12EMedia123Nec98,                 //  5.25" 1.2Mb externel drive; 1.25Mb   media
} DRIVE_MEDIA_TYPE_NEC98;

//
// When we want to determine the media type in a drive, we will first
// guess that the media with highest possible density is in the drive,
// and keep trying lower densities until we can successfully read from
// the drive.
//
// These values are used to select a DRIVE_MEDIA_TYPE value.
//
// The following table defines ranges that apply to the DRIVE_MEDIA_TYPE
// enumerated values when trying media types for a particular drive type.
// Note that for this to work, the DRIVE_MEDIA_TYPE values must be sorted
// by ascending densities within drive types.  Also, for maximum track
// size to be determined properly, the drive types must be in ascending
// order.
//

typedef struct _DRIVE_MEDIA_LIMITS {
    DRIVE_MEDIA_TYPE HighestDriveMediaType;
    DRIVE_MEDIA_TYPE LowestDriveMediaType;
} DRIVE_MEDIA_LIMITS, *PDRIVE_MEDIA_LIMITS;

DRIVE_MEDIA_LIMITS _DriveMediaLimits[NUMBER_OF_DRIVE_TYPES] = {

    { Drive360Media360, Drive360Media160 }, // DRIVE_TYPE_0360
    { Drive120Media120, Drive120Media160 }, // DRIVE_TYPE_1200
    { Drive720Media720, Drive720Media720 }, // DRIVE_TYPE_0720
    { Drive144Media144, Drive144Media720 }, // DRIVE_TYPE_1440
    { Drive288Media288, Drive288Media720 }  // DRIVE_TYPE_2880
};

//
// for NEC98
//
typedef struct _DRIVE_MEDIA_LIMITS_NEC98 {
    DRIVE_MEDIA_TYPE_NEC98 HighestDriveMediaType;
    DRIVE_MEDIA_TYPE_NEC98 LowestDriveMediaType;
} DRIVE_MEDIA_LIMITS_NEC98, *PDRIVE_MEDIA_LIMITS_NEC98;

DRIVE_MEDIA_LIMITS_NEC98 _DriveMediaLimits_NEC98[NUMBER_OF_DRIVE_TYPES_NEC98] = {

    { Drive360Media360Nec98, Drive360Media160Nec98 }, // DRIVE_TYPE_0360
    { Drive120Media123Nec98, Drive120Media160Nec98 }, // DRIVE_TYPE_1200
    { Drive120Media720Nec98, Drive120Media160Nec98 }, // DRIVE_TYPE_0720
    { Drive144Media144Nec98, Drive144Media640Nec98 }, // DRIVE_TYPE_1440
    { Drive144Media144Nec98, Drive144Media640Nec98 }, // DRIVE_TYPE_2880 - dummy, never be used.
    { Drive12EMedia123Nec98, Drive12EMedia120Nec98 }  // DRIVE_TYPE_1200_E
};

PDRIVE_MEDIA_LIMITS DriveMediaLimits;

//
// For each drive/media combination, define important constants.
//

typedef struct _DRIVE_MEDIA_CONSTANTS {
    MEDIA_TYPE MediaType;
    UCHAR      StepRateHeadUnloadTime;
    UCHAR      HeadLoadTime;
    UCHAR      MotorOffTime;
    UCHAR      SectorLengthCode;
    USHORT     BytesPerSector;
    UCHAR      SectorsPerTrack;
    UCHAR      ReadWriteGapLength;
    UCHAR      FormatGapLength;
    UCHAR      FormatFillCharacter;
    UCHAR      HeadSettleTime;
    USHORT     MotorSettleTimeRead;
    USHORT     MotorSettleTimeWrite;
    UCHAR      MaximumTrack;
    UCHAR      CylinderShift;
    UCHAR      DataTransferRate;
    UCHAR      NumberOfHeads;
    UCHAR      DataLength;
    UCHAR      MediaByte;
    UCHAR      SkewDelta;
} DRIVE_MEDIA_CONSTANTS, *PDRIVE_MEDIA_CONSTANTS;

//
// Magic value to add to the SectorLengthCode to use it as a shift value
// to determine the sector size.
//

#define SECTORLENGTHCODE_TO_BYTESHIFT      7

//
// The following values were gleaned from many different sources, which
// often disagreed with each other.  Where numbers were in conflict, I
// chose the more conservative or most-often-selected value.
//

DRIVE_MEDIA_CONSTANTS _DriveMediaConstants[_NUMBER_OF_DRIVE_MEDIA_COMBINATIONS_] =
{
    { F5_160_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2, 0x1, 0xff, 0xfe, 0 },
    { F5_180_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2, 0x1, 0xff, 0xfc, 0 },
    { F5_320_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2, 0x2, 0xff, 0xff, 0 },
    { F5_320_1024,  0xdf, 0x2, 0x25, 0x3, 0x400, 0x04, 0x80, 0xf0, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2, 0x2, 0xff, 0xff, 0 },
    { F5_360_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xf6, 0xf,  250, 1000, 0x27, 0, 0x2, 0x2, 0xff, 0xfd, 0 },
    { F3_720_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xf6, 0xf,  500, 1000, 0x4f, 0, 0x2, 0x2, 0xff, 0xf9, 2 },
    { F5_160_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 1, 0x1, 0x1, 0xff, 0xfe, 0 },
    { F5_180_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 1, 0x1, 0x1, 0xff, 0xfc, 0 },
    { F5_320_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 1, 0x1, 0x2, 0xff, 0xff, 0 },
    { F5_320_1024,  0xdf, 0x2, 0x25, 0x3, 0x400, 0x04, 0x80, 0xf0, 0xf6, 0xf, 1000, 1000, 0x27, 1, 0x1, 0x2, 0xff, 0xff, 0 },
    { F5_360_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xf6, 0xf,  625, 1000, 0x27, 1, 0x1, 0x2, 0xff, 0xfd, 0 },
    { F5_1Pt2_512,  0xdf, 0x2, 0x25, 0x2, 0x200, 0x0f, 0x1b, 0x54, 0xf6, 0xf,  625, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf9, 0 },
    { F3_720_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xf6, 0xf,  500, 1000, 0x4f, 0, 0x2, 0x2, 0xff, 0xf9, 2 },
    { F3_1Pt44_512, 0xaf, 0x2, 0x25, 0x2, 0x200, 0x12, 0x1b, 0x65, 0xf6, 0xf,  500, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf0, 3 },
    { F3_720_512,   0xe1, 0x2, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xf6, 0xf,  500, 1000, 0x4f, 0, 0x2, 0x2, 0xff, 0xf9, 2 },
    { F3_1Pt44_512, 0xd1, 0x2, 0x25, 0x2, 0x200, 0x12, 0x1b, 0x65, 0xf6, 0xf,  500, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf0, 3 },
    { F3_2Pt88_512, 0xa1, 0x2, 0x25, 0x2, 0x200, 0x24, 0x38, 0x53, 0xf6, 0xf,  500, 1000, 0x4f, 0, 0x3, 0x2, 0xff, 0xf0, 6 }
};

//
// for NEC98
//
DRIVE_MEDIA_CONSTANTS _DriveMediaConstants_NEC98[_NUMBER_OF_DRIVE_MEDIA_COMBINATIONS_NEC98_] =
{
    //
    // 5.25" 360k drive
    //
    { F5_160_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2, 0x1, 0xff, 0xfe, 0 },
    { F5_180_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2, 0x1, 0xff, 0xfc, 0 },
    { F5_320_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2, 0x2, 0xff, 0xff, 0 },
    { F5_320_1024,  0xdf, 0x2, 0x25, 0x3, 0x400, 0x04, 0x80, 0xf0, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2, 0x2, 0xff, 0xff, 0 },
    { F5_360_512,   0xdf, 0x2, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xf6, 0xf, 250, 1000, 0x27, 0, 0x2, 0x2, 0xff, 0xfd, 0 },

    //
    // 5.25" 1.2Mb drive
    //
    { F5_160_512,   0xdf, 0x16, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xe5, 0xf, 1000, 1000, 0x27, 1, 0x2, 0x1, 0xff, 0xfe, 0 },
    { F5_180_512,   0xdf, 0x16, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xe5, 0xf, 1000, 1000, 0x27, 1, 0x2, 0x1, 0xff, 0xfc, 0 },
    { F5_320_512,   0xdf, 0x16, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xe5, 0xf, 1000, 1000, 0x27, 1, 0x2, 0x2, 0xff, 0xff, 0 },
    { F5_320_1024,  0xdf, 0x16, 0x25, 0x3, 0x400, 0x04, 0x80, 0xf0, 0xe5, 0xf, 1000, 1000, 0x27, 1, 0x2, 0x2, 0xff, 0xff, 0 },
    { F5_360_512,   0xdf, 0x16, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xe5, 0xf, 1000, 1000, 0x27, 1, 0x2, 0x2, 0xff, 0xfd, 0 },
    { F5_640_512,   0xdf, 0x16, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xe5, 0xf, 1000, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xfb, 0 },
    { F5_720_512,   0xdf, 0x16, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xe5, 0xf, 1000, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf9, 2 },
    { F5_1Pt2_512,  0xcf, 0x24, 0x25, 0x2, 0x200, 0x0f, 0x1b, 0x54, 0xe5, 0xf, 1000, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf9, 0 },
    { F5_1Pt23_1024,0xcf, 0x24, 0x25, 0x3, 0x400, 0x08, 0x35, 0x74, 0xe5, 0xf, 1000, 1000, 0x4c, 0, 0x0, 0x2, 0xff, 0xfe, 0 },

    //
    // 3.5"  1.44Mb drive
    //
    { F3_640_512,   0xdf, 0x16, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xe5, 0xf, 1000, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xfb, 0 },
    { F3_720_512,   0xdf, 0x16, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xe5, 0xf, 1000, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf9, 2 },
    { F3_1Pt2_512,  0xcf, 0x24, 0x25, 0x2, 0x200, 0x0f, 0x1b, 0x54, 0xe5, 0xf, 1000, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf9, 0 },
    { F3_1Pt23_1024,0xcf, 0x24, 0x25, 0x3, 0x400, 0x08, 0x35, 0x74, 0xe5, 0xf, 1000, 1000, 0x4c, 0, 0x0, 0x2, 0xff, 0xfe, 0 },
    { F3_1Pt44_512, 0xdf, 0x24, 0x25, 0x2, 0x200, 0x12, 0x1b, 0x6c, 0xe5, 0xf, 1000, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf0, 3 },

    //
    // 5.25" 1.2Mb externel drive
    //
    { F5_1Pt2_512,  0xbf, 0x32, 0x25, 0x2, 0x200, 0x0f, 0x1b, 0x54, 0xe5, 0xf, 1000, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf9, 0 },
    { F5_1Pt23_1024,0xbf, 0x32, 0x25, 0x3, 0x400, 0x08, 0x35, 0x74, 0xe5, 0xf, 1000, 1000, 0x4c, 0, 0x0, 0x2, 0xff, 0xfe, 0 },

};

PDRIVE_MEDIA_CONSTANTS DriveMediaConstants;



//
// Parameter fields passed to the CONFIGURE command.
//
#define COMMND_CONFIGURE_IMPLIED_SEEKS     0x40
#define COMMND_CONFIGURE_FIFO_THRESHOLD    0x0F
#define COMMND_CONFIGURE_DISABLE_FIFO      0x20
#define COMMND_CONFIGURE_DISABLE_POLLING   0x10

//
// Write Enable bit for PERPENDICULAR MODE command.
//
#define COMMND_PERPENDICULAR_MODE_OW       0x80

//
// Bits in the DRIVE_CONTROL register.
//
#define DRVCTL_RESET                       0x00
#define DRVCTL_ENABLE_CONTROLLER           0x04
#define DRVCTL_ENABLE_DMA_AND_INTERRUPTS   0x08
#define DRVCTL_DRIVE_0                     0x10
#define DRVCTL_DRIVE_1                     0x21
#define DRVCTL_DRIVE_2                     0x42
#define DRVCTL_DRIVE_3                     0x83
#define DRVCTL_DRIVE_MASK                  0x03
#define DRVCTL_MOTOR_MASK                  0xf0

//
// Bits in the STATUS register.
//
#define STATUS_DRIVE_0_BUSY                0x01
#define STATUS_DRIVE_1_BUSY                0x02
#define STATUS_DRIVE_2_BUSY                0x04
#define STATUS_DRIVE_3_BUSY                0x08
#define STATUS_CONTROLLER_BUSY             0x10
#define STATUS_DMA_UNUSED                  0x20
#define STATUS_DIRECTION_READ              0x40
#define STATUS_DATA_REQUEST                0x80

#define STATUS_IO_READY_MASK               0xc0
#define STATUS_READ_READY                  0xc0
#define STATUS_WRITE_READY                 0x80

//
// Bits in the DATA_RATE register.
//
#define DATART_0125                        0x03
#define DATART_0250                        0x02
#define DATART_0300                        0x01
#define DATART_0500                        0x00
#define DATART_1000                        0x03
#define DATART_RESERVED                    0xfc

//
// Bits in the DISK_CHANGE register.
//
#define DSKCHG_RESERVED                    0x7f
#define DSKCHG_DISKETTE_REMOVED            0x80

//
// Bits in status register 0.
//
#define STREG0_DRIVE_0                     0x00
#define STREG0_DRIVE_1                     0x01
#define STREG0_DRIVE_2                     0x02
#define STREG0_DRIVE_3                     0x03
#define STREG0_HEAD                        0x04
#define STREG0_DRIVE_NOT_READY             0x08
#define STREG0_DRIVE_FAULT                 0x10
#define STREG0_SEEK_COMPLETE               0x20
#define STREG0_END_NORMAL                  0x00
#define STREG0_END_ERROR                   0x40
#define STREG0_END_INVALID_COMMAND         0x80
#define STREG0_END_DRIVE_NOT_READY         0xC0
#define STREG0_END_MASK                    0xC0

//
// Bits in status register 1.
//
#define STREG1_ID_NOT_FOUND                0x01
#define STREG1_WRITE_PROTECTED             0x02
#define STREG1_SECTOR_NOT_FOUND            0x04
#define STREG1_RESERVED1                   0x08
#define STREG1_DATA_OVERRUN                0x10
#define STREG1_CRC_ERROR                   0x20
#define STREG1_RESERVED2                   0x40
#define STREG1_END_OF_DISKETTE             0x80

//
// Bits in status register 2.
//
#define STREG2_SUCCESS                     0x00
#define STREG2_DATA_NOT_FOUND              0x01
#define STREG2_BAD_CYLINDER                0x02
#define STREG2_SCAN_FAIL                   0x04
#define STREG2_SCAN_EQUAL                  0x08
#define STREG2_WRONG_CYLINDER              0x10
#define STREG2_CRC_ERROR                   0x20
#define STREG2_DELETED_DATA                0x40
#define STREG2_RESERVED                    0x80

//
// Bits in status register 3.
//
#define STREG3_DRIVE_0                     0x00
#define STREG3_DRIVE_1                     0x01
#define STREG3_DRIVE_2                     0x02
#define STREG3_DRIVE_3                     0x03
#define STREG3_HEAD                        0x04
#define STREG3_TWO_SIDED                   0x08
#define STREG3_TRACK_0                     0x10
#define STREG3_DRIVE_READY                 0x20
#define STREG3_WRITE_PROTECTED             0x40
#define STREG3_DRIVE_FAULT                 0x80


//
// Runtime device structures
//
//
// There is one DISKETTE_EXTENSION attached to the device object of each
// floppy drive.  Only data directly related to that drive (and the media
// in it) is stored here; common data is in CONTROLLER_DATA.  So the
// DISKETTE_EXTENSION has a pointer to the CONTROLLER_DATA.
//

typedef struct _DISKETTE_EXTENSION {

    KSPIN_LOCK              FlCancelSpinLock;
    PDEVICE_OBJECT          UnderlyingPDO;
    PDEVICE_OBJECT          TargetObject;

    BOOLEAN                 IsStarted;
    BOOLEAN                 IsRemoved;
    BOOLEAN                 HoldNewRequests;
    LIST_ENTRY              NewRequestQueue;
    KSPIN_LOCK              NewRequestQueueSpinLock;

    PDEVICE_OBJECT          DeviceObject;
    KSEMAPHORE              RequestSemaphore;
    KSPIN_LOCK              ListSpinLock;
    FAST_MUTEX              ThreadReferenceMutex;
    LONG                    ThreadReferenceCount;
    PKTHREAD                FloppyThread;
    LIST_ENTRY              ListEntry;
    BOOLEAN                 HardwareFailed;
    UCHAR                   HardwareFailCount;
    ULONG                   MaxTransferSize;
    UCHAR                   FifoBuffer[10];
    PUCHAR                  IoBuffer;
    PMDL                    IoBufferMdl;
    ULONG                   IoBufferSize;
    PDRIVER_OBJECT          DriverObject;
    DRIVE_MEDIA_TYPE        LastDriveMediaType;
    BOOLEAN                 FloppyControllerAllocated;
    BOOLEAN                 ACPI_BIOS;
    UCHAR                   DriveType;
    ULONG                   BytesPerSector;
    ULONG                   ByteCapacity;
    MEDIA_TYPE              MediaType;
    DRIVE_MEDIA_TYPE        DriveMediaType;
    UCHAR                   DeviceUnit;
    UCHAR                   DriveOnValue;
    BOOLEAN                 IsReadOnly;
    DRIVE_MEDIA_CONSTANTS   BiosDriveMediaConstants;
    DRIVE_MEDIA_CONSTANTS   DriveMediaConstants;
    UCHAR                   PerpendicularMode;
    BOOLEAN                 ControllerConfigurable;
    UNICODE_STRING          DeviceName;
    UNICODE_STRING          InterfaceString;
    UNICODE_STRING          ArcName;
    BOOLEAN                 ReleaseFdcWithMotorRunning;

    //
    // For power management
    //
    KEVENT                  QueryPowerEvent;
    BOOLEAN                 PoweringDown;
    BOOLEAN                 ReceivedQueryPower;
    FAST_MUTEX              PowerDownMutex;

    FAST_MUTEX              HoldNewReqMutex;
} DISKETTE_EXTENSION;

typedef DISKETTE_EXTENSION *PDISKETTE_EXTENSION;

//
// for NEC98.
// IOCTL_DISK_SENSE_DEVICE
//

typedef struct _SENSE_DEVISE_STATUS_PTOS {
    UCHAR ST3_PTOS;
} SENSE_DEVISE_STATUS_PTOS, *PSENSE_DEVISE_STATUS_PTOS;

SENSE_DEVISE_STATUS_PTOS Result_Status3_PTOS[4];



//
// Prototypes of driver routines.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
FloppyUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
FlConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
FlInitializeControllerHardware(
    IN PDISKETTE_EXTENSION disketteExtension
    );

NTSTATUS
FloppyCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FloppyDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FloppyReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FlRecalibrateDrive(
    IN PDISKETTE_EXTENSION DisketteExtension
    );

NTSTATUS
FlDatarateSpecifyConfigure(
    IN PDISKETTE_EXTENSION DisketteExtension
    );

NTSTATUS
FlStartDrive(
    IN OUT PDISKETTE_EXTENSION DisketteExtension,
    IN PIRP Irp,
    IN BOOLEAN WriteOperation,
    IN BOOLEAN SetUpMedia,
    IN BOOLEAN IgnoreChange
    );

VOID
FlFinishOperation(
    IN OUT PIRP Irp,
    IN PDISKETTE_EXTENSION DisketteExtension
    );

NTSTATUS
FlDetermineMediaType(
    IN OUT PDISKETTE_EXTENSION DisketteExtension
    );

VOID
FloppyThread(
    IN PVOID Context
    );

NTSTATUS
FlReadWrite(
    IN OUT PDISKETTE_EXTENSION DisketteExtension,
    IN OUT PIRP Irp,
    IN BOOLEAN DriveStarted
    );

NTSTATUS
FlFormat(
    IN PDISKETTE_EXTENSION DisketteExtension,
    IN PIRP Irp
    );

NTSTATUS
FlIssueCommand(
    IN OUT PDISKETTE_EXTENSION DisketteExtension,
    IN     PUCHAR FifoInBuffer,
    OUT    PUCHAR FifoOutBuffer,
    IN     PMDL   IoMdl,
    IN OUT ULONG  IoBuffer,
    IN     ULONG  TransferBytes
    );

BOOLEAN
FlCheckFormatParameters(
    IN PDISKETTE_EXTENSION DisketteExtension,
    IN PFORMAT_PARAMETERS Fp
    );

VOID
FlLogErrorDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
FlQueueIrpToThread(
    IN OUT  PIRP                Irp,
    IN OUT  PDISKETTE_EXTENSION DisketteExtension
    );

NTSTATUS
FlInterpretError(
    IN UCHAR StatusRegister1,
    IN UCHAR StatusRegister2
    );

VOID
FlAllocateIoBuffer(
    IN OUT  PDISKETTE_EXTENSION DisketteExtension,
    IN      ULONG               BufferSize
    );

VOID
FlFreeIoBuffer(
    IN OUT  PDISKETTE_EXTENSION DisketteExtension
    );

VOID
FlConsolidateMediaTypeWithBootSector(
    IN OUT  PDISKETTE_EXTENSION DisketteExtension,
    IN      PBOOT_SECTOR_INFO   BootSector
    );

VOID
FlCheckBootSector(
    IN OUT  PDISKETTE_EXTENSION DisketteExtension
    );

NTSTATUS
FlReadWriteTrack(
    IN OUT  PDISKETTE_EXTENSION DisketteExtension,
    IN OUT  PMDL                IoMdl,
    IN OUT  ULONG               IoOffset,
    IN      BOOLEAN             WriteOperation,
    IN      UCHAR               Cylinder,
    IN      UCHAR               Head,
    IN      UCHAR               Sector,
    IN      UCHAR               NumberOfSectors,
    IN      BOOLEAN             NeedSeek
    );

NTSTATUS
FlFdcDeviceIo(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    );

VOID
FlTerminateFloppyThread(
    PDISKETTE_EXTENSION DisketteExtension
    );

NTSTATUS
FloppyAddDevice(
    IN      PDRIVER_OBJECT DriverObject,
    IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
FloppyPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FloppyPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FloppyPnpComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
FloppyQueueRequest    (
    IN OUT PDISKETTE_EXTENSION DisketteExtension,
    IN PIRP Irp
    );

NTSTATUS
FloppyStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
FloppyProcessQueuedRequests    (
    IN OUT PDISKETTE_EXTENSION DisketteExtension
    );

VOID
FloppyCancelQueuedRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
FlAcpiConfigureFloppy(
    PDISKETTE_EXTENSION DisketteExtension,
        PFDC_INFO FdcInfo
    );

NTSTATUS
FlHdbit(
    IN OUT PDISKETTE_EXTENSION DisketteExtension
    );

NTSTATUS
FloppySystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\mode3fdc\desk2fdc\fdc_data.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    fdc_data.h

Abstract:

    This file includes data and hardware declarations for the NEC PD765
    (aka AT, ISA, and ix86) and Intel 82077 (aka MIPS) floppy driver for
    NT.

Author:


Environment:

    Kernel mode only.

Notes:


--*/


#if DBG
//
// For checked kernels, define a macro to print out informational
// messages.
//
// FdcDebug is normally 0.  At compile-time or at run-time, it can be
// set to some bit pattern for increasingly detailed messages.
//
// Big, nasty errors are noted with DBGP.  Errors that might be
// recoverable are handled by the WARN bit.  More information on
// unusual but possibly normal happenings are handled by the INFO bit.
// And finally, boring details such as routines entered and register
// dumps are handled by the SHOW bit.
//
#define FDCDBGP              ((ULONG)0x00000001)
#define FDCWARN              ((ULONG)0x00000002)
#define FDCINFO              ((ULONG)0x00000004)
#define FDCSHOW              ((ULONG)0x00000008)
#define FDCIRPPATH           ((ULONG)0x00000010)
#define FDCFORMAT            ((ULONG)0x00000020)
#define FDCSTATUS            ((ULONG)0x00000040)

extern ULONG FdcDebugLevel;
#define FdcDump(LEVEL,STRING) \
        do { \
            if (FdcDebugLevel & LEVEL) { \
                DbgPrint STRING; \
            } \
        } while (0)
#else
#define FdcDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif


//
// Macros to access the controller.  Note that the *_PORT_UCHAR macros
// work on all machines, whether the I/O ports are separate or in
// memory space.
//

#define READ_CONTROLLER( Address )                         \
    READ_PORT_UCHAR( ( PUCHAR )Address )

#define WRITE_CONTROLLER( Address, Value )                 \
    WRITE_PORT_UCHAR( ( PUCHAR )Address, ( UCHAR )Value )


//
// Retry counts -
//
// When moving a byte to/from the FIFO, we sit in a tight loop for a while
// waiting for the controller to become ready.  The number of times through
// the loop is controlled by FIFO_TIGHTLOOP_RETRY_COUNT.  When that count
// expires, we'll wait in 10ms increments.  FIFO_DELAY_RETRY_COUNT controls
// how many times we wait.
//
// The ISR_SENSE_RETRY_COUNT is the maximum number of 1 microsecond
// stalls that the ISR will do waiting for the controller to accept
// a SENSE INTERRUPT command.  We do this because there is a hardware
// quirk in at least the NCR 8 processor machine where it can take
// up to 50 microseconds to accept the command.
//
// When attempting I/O, we may run into many different errors.  The
// hardware retries things 8 times invisibly.  If the hardware reports
// any type of error, we will recalibrate and retry the operation
// up to RECALIBRATE_RETRY_COUNT times.  When this expires, we check to
// see if there's an overrun - if so, the DMA is probably being hogged
// by a higher priority device, so we repeat the earlier loop up to
// OVERRUN_RETRY_COUNT times.
//
// Any packet that is about to be returned with an error caused by an
// unexpected hardware error or state will be restarted from the very
// beginning after resetting the hardware HARDWARE_RESET_RETRY_COUNT
// times.
//

#define FIFO_TIGHTLOOP_RETRY_COUNT         500
#define FIFO_ISR_TIGHTLOOP_RETRY_COUNT     25
#define ISR_SENSE_RETRY_COUNT              50
#define FIFO_DELAY_RETRY_COUNT             5
#define RECALIBRATE_RETRY_COUNT            3
#define OVERRUN_RETRY_COUNT                1
#define HARDWARE_RESET_RETRY_COUNT         2
#define FLOPPY_RESET_ISR_THRESHOLD         20
#define RQM_READY_RETRY_COUNT              100

#define ONE_SECOND                         (10 * 1000 * 1000) // 100ns increments
#define CANCEL_TIMER                       -1
#define START_TIMER                        (IsNEC_98 ? 15 : 9)
#define EXPIRED_TIMER                      0

#define RESET_NOT_RESETTING                 0
#define RESET_DRIVE_RESETTING               1

//
// Need some maximum size values so that we can appropriately set up the DMA
// channels
//

#define MAX_BYTES_PER_SECTOR              (IsNEC_98 ? 1024 : 512)
#define MAX_SECTORS_PER_TRACK             36


//
// Boot Configuration Information
//

//
// Define the maximum number of controllers and floppies per controller
// that this driver will support.
//
// The number of floppies per controller is fixed at 4, since the
// controllers don't have enough bits to select more than that (and
// actually, many controllers will only support 2).  The number of
// controllers per machine is arbitrary; 3 should be more than enough.
//

#define MAXIMUM_CONTROLLERS_PER_MACHINE    3
#define MAXIMUM_DISKETTES_PER_CONTROLLER   4

//
// Floppy register structure.  The base address of the controller is
// passed in by configuration management.  Note that this is the 82077
// structure, which is a superset of the PD765 structure.  Not all of
// the registers are used.
//

typedef union _CONTROLLER {

    struct {
        PUCHAR StatusA;
        PUCHAR StatusB;
        PUCHAR DriveControl;
        PUCHAR Tape;
        PUCHAR Status;
        PUCHAR Fifo;
        PUCHAR Reserved;
        union {
            PUCHAR DataRate;
            PUCHAR DiskChange;
        } DRDC;
        PUCHAR ModeChange;   // for NEC98 : 0xbe
        PUCHAR ModeChangeEx; // for NEC98 : 0x4be
    };

    PUCHAR Address[8];

} CONTROLLER, *PCONTROLLER;

//
//  Io Port address information structure.  This structure is used to save
//  information about ioport addresses as it is collected from a resource
//  requirements list.
//
typedef struct _IO_PORT_INFO {
    LARGE_INTEGER BaseAddress;
    UCHAR Map;
    LIST_ENTRY ListEntry;
} IO_PORT_INFO, *PIO_PORT_INFO;


//
// Parameter fields passed to the CONFIGURE command.
//

#define COMMND_CONFIGURE_IMPLIED_SEEKS     0x40
#define COMMND_CONFIGURE_FIFO_THRESHOLD    0x0F
#define COMMND_CONFIGURE_DISABLE_FIFO      0x20
#define COMMND_CONFIGURE_DISABLE_POLLING   0x10

//
// Write Enable bit for PERPENDICULAR MODE command.
//

#define COMMND_PERPENDICULAR_MODE_OW       0x80

//
// The command table is used by FlIssueCommand() to determine how many
// bytes to get and receive, and whether or not to wait for an interrupt.
// Some commands have extra bits; COMMAND_MASK takes these off.
// FirstResultByte indicates whether the command has a result stage
// or not; if so, it's 1 because the ISR read the 1st byte, and
// NumberOfResultBytes is 1 less than expected.  If not, it's 0 and
// NumberOfResultBytes is 2, since the ISR will have issued a SENSE
// INTERRUPT STATUS command.
//

#define COMMAND_MASK        0x1f
#define FDC_NO_DATA         0x00
#define FDC_READ_DATA       0x01
#define FDC_WRITE_DATA      0x02

typedef struct _COMMAND_TABLE {
    UCHAR   OpCode;
    UCHAR   NumberOfParameters;
    UCHAR   FirstResultByte;
    UCHAR   NumberOfResultBytes;
    BOOLEAN InterruptExpected;
    BOOLEAN AlwaysImplemented;
    UCHAR    DataTransfer;
} COMMAND_TABLE;

//
// Bits in the DRIVE_CONTROL register.
//

#define DRVCTL_RESET                       0x00
#define DRVCTL_ENABLE_CONTROLLER           (IsNEC_98 ? 0x80 : 0x04)
#define DRVCTL_ENABLE_DMA_AND_INTERRUPTS   (IsNEC_98 ? 0x10 : 0x08)
#define DRVCTL_DRIVE_0                     0x10
#define DRVCTL_DRIVE_1                     0x21
#define DRVCTL_DRIVE_2                     0x42
#define DRVCTL_DRIVE_3                     0x83
#define DRVCTL_DRIVE_MASK                  0x03
#define DRVCTL_MOTOR_MASK                  (IsNEC_98 ? 0x08 : 0xf0)
#define DRVCTL_HD_BIT                      0x20 // for NEC98
#define DRVCTL_AI_ENABLE                   0x20 // for NEC98. Indicate AI enable bit.

//
// Bits in the STATUS register.
//

#define STATUS_DRIVE_0_BUSY                0x01
#define STATUS_DRIVE_1_BUSY                0x02
#define STATUS_DRIVE_2_BUSY                0x04
#define STATUS_DRIVE_3_BUSY                0x08
#define STATUS_CONTROLLER_BUSY             0x10
#define STATUS_DMA_UNUSED                  0x20
#define STATUS_DIRECTION_READ              0x40
#define STATUS_DATA_REQUEST                0x80

#define STATUS_IO_READY_MASK               0xc0
#define STATUS_READ_READY                  0xc0
#define STATUS_WRITE_READY                 0x80
#define STATUS_IO_READY_MASK1              0x80 // for NEC98.
#define STATUS_RQM_READY                   0x80 // for NEC98.

//
// Bits in the DATA_RATE register.
//

#define DATART_0125                        0x03
#define DATART_0250                        0x02
#define DATART_0300                        0x01
#define DATART_0500                        0x00
#define DATART_1000                        0x03
#define DATART_RESERVED                    0xfc

//
// Bits in the DISK_CHANGE register.
//

#define DSKCHG_RESERVED                    0x7f
#define DSKCHG_DISKETTE_REMOVED            0x80

//
// Bits in status register 0.
//

#define STREG0_DRIVE_0                     0x00
#define STREG0_DRIVE_1                     0x01
#define STREG0_DRIVE_2                     0x02
#define STREG0_DRIVE_3                     0x03
#define STREG0_HEAD                        0x04
#define STREG0_DRIVE_NOT_READY             0x08
#define STREG0_DRIVE_FAULT                 0x10
#define STREG0_SEEK_COMPLETE               0x20
#define STREG0_END_NORMAL                  0x00
#define STREG0_END_ERROR                   0x40
#define STREG0_END_INVALID_COMMAND         0x80
#define STREG0_END_DRIVE_NOT_READY         0xC0
#define STREG0_END_MASK                    0xC0

//
// Bits in status register 1.
//

#define STREG1_ID_NOT_FOUND                0x01
#define STREG1_WRITE_PROTECTED             0x02
#define STREG1_SECTOR_NOT_FOUND            0x04
#define STREG1_RESERVED1                   0x08
#define STREG1_DATA_OVERRUN                0x10
#define STREG1_CRC_ERROR                   0x20
#define STREG1_RESERVED2                   0x40
#define STREG1_END_OF_DISKETTE             0x80

//
// Bits in status register 2.
//

#define STREG2_SUCCESS                     0x00
#define STREG2_DATA_NOT_FOUND              0x01
#define STREG2_BAD_CYLINDER                0x02
#define STREG2_SCAN_FAIL                   0x04
#define STREG2_SCAN_EQUAL                  0x08
#define STREG2_WRONG_CYLINDER              0x10
#define STREG2_CRC_ERROR                   0x20
#define STREG2_DELETED_DATA                0x40
#define STREG2_RESERVED                    0x80

//
// Bits in status register 3.
//

#define STREG3_DRIVE_0                     0x00
#define STREG3_DRIVE_1                     0x01
#define STREG3_DRIVE_2                     0x02
#define STREG3_DRIVE_3                     0x03
#define STREG3_HEAD                        0x04
#define STREG3_TWO_SIDED                   0x08
#define STREG3_TRACK_0                     0x10
#define STREG3_DRIVE_READY                 0x20
#define STREG3_WRITE_PROTECTED             0x40
#define STREG3_DRIVE_FAULT                 0x80

#define VALID_NEC_FDC                      0x90    // version number
#define NSC_PRIMARY_VERSION                0x70    // National 8477 verion number
#define NSC_MASK                           0xF0    // mask for National version number
#define INTEL_MASK                         0xe0
#define INTEL_44_PIN_VERSION               0x40
#define INTEL_64_PIN_VERSION               0x00

#define DMA_DIR_UNKNOWN    0xff   /* The DMA direction is not currently known */
#define DMA_WRITE          0   /* Program the DMA to write (FDC->DMA->RAM) */
#define DMA_READ           1   /* Program the DMA to read (RAM->DMA->FDC) */

//
//  Strings for PnP Identification.
//
#define FDC_FLOPPY_COMPATIBLE_IDS L"*PNP0700\0GenFloppyDisk\0\0"
#define FDC_FLOPPY_COMPATIBLE_IDS_LENGTH 24 // NB wide characters.

#define FDC_TAPE_COMPATIBLE_IDS L"QICPNP\0\0"
#define FDC_TAPE_COMPATIBLE_IDS_LENGTH 8 // NB wide characters.

#define FDC_CONTROLLER_COMPATIBLE_IDS L"*PNP0700\0\0"
#define FDC_CONTROLLER_COMPATIBLE_IDS_LENGTH 10 // NB wide characters.



//
// Runtime device structures
//

//
// There is one FDC_EXTENSION attached to the device object of each
// floppy drive.  Only data directly related to that drive (and the media
// in it) is stored here; common data is in CONTROLLER_DATA.  So the
// FDC_EXTENSION has a pointer to the CONTROLLER_DATA.
//

typedef struct _FDC_EXTENSION_HEADER {

    //
    //  A flag to indicate whether this is a FDO or a PDO
    //
    BOOLEAN             IsFDO;

    //
    //  A pointer to our own device object.
    //
    PDEVICE_OBJECT      Self;

} FDC_EXTENSION_HEADER, *PFDC_EXTENSION_HEADER;

typedef enum _FDC_DEVICE_TYPE {

    FloppyControllerDevice,
    FloppyDiskDevice,
    FloppyTapeDevice

} FDC_DEVICE_TYPE;

typedef struct _FDC_PDO_EXTENSION {

    FDC_EXTENSION_HEADER;

    //
    //  A pointer to the FDO that created us.
    //
    PDEVICE_OBJECT  ParentFdo;

    //
    //  The instance number for this PDO.  Determined by the order of the
    //  callbacks from IoQueryDeviceDescription.
    //
    USHORT          Instance;

    //
    //  The type of device this PDO supports.  Currently disk or tape.
    //
    FDC_DEVICE_TYPE DeviceType;

    SHORT           TapeVendorId;

    //
    //  A flag that indicates whether this PDO is pending removal.
    //
    BOOLEAN         Removed;

    //
    //  This PDO's entry in its parent's list of related PDOs.
    //
    LIST_ENTRY      PdoLink;

    //
    //  The enumerated  number of this specific device, as returned from
    //  IoQueryDeviceDescription.
    //
    ULONG           PeripheralNumber;

    PDEVICE_OBJECT  TargetObject;

} FDC_PDO_EXTENSION, *PFDC_PDO_EXTENSION;

typedef struct _FDC_FDO_EXTENSION {

    FDC_EXTENSION_HEADER;

    //
    //  A kernel resource for controlling access to the FDC.
    //
    ERESOURCE Resource;
    //
    //  A pointer to the PDO to which this FDO is attached.
    //
    PDEVICE_OBJECT      UnderlyingPDO;

    //
    //  The top of the object stack to which this FDO is attached.
    //
    PDEVICE_OBJECT      TargetObject;

    //
    //  A list and count of PDOs that were created by this FDO.
    //
    LIST_ENTRY          PDOs;
    ULONG               NumPDOs;
    BOOLEAN             Removed;
    ULONG               OutstandingRequests;
    KEVENT              RemoveEvent;
    BOOLEAN             TapeEnumerationPending;
    KEVENT              TapeEnumerationEvent;

    //
    //  Some stuff for power management
    //
    LIST_ENTRY          PowerQueue;
    KSPIN_LOCK          PowerQueueSpinLock;
    KEVENT              PowerEvent;
    SYSTEM_POWER_STATE  CurrentPowerState;
    LARGE_INTEGER       LastMotorSettleTime;
    BOOLEAN             WakeUp;

    //
    //  The bus number on which this physical device lives.
    //
    INTERFACE_TYPE      BusType;
    ULONG               BusNumber;
    ULONG               ControllerNumber;

    BOOLEAN             DeviceObjectInitialized;
    LARGE_INTEGER       InterruptDelay;
    LARGE_INTEGER       Minimum10msDelay;
    KEVENT              InterruptEvent;
    LONG                InterruptTimer;
    CCHAR               ResettingController;
    KEVENT              AllocateAdapterChannelEvent;
    LONG                AdapterChannelRefCount;
    PKEVENT             AcquireEvent;
    HANDLE              AcquireEventHandle;
    KEVENT              SynchEvent;
    KDPC                LogErrorDpc;
    KDPC                BufferTimerDpc;
    KTIMER              BufferTimer;
    PKINTERRUPT         InterruptObject;
    PVOID               MapRegisterBase;
    PADAPTER_OBJECT     AdapterObject;
    PDEVICE_OBJECT      CurrentDeviceObject;
    PDRIVER_OBJECT      DriverObject;
    CONTROLLER          ControllerAddress;
    ULONG               SpanOfControllerAddress;
    ULONG               NumberOfMapRegisters;
    ULONG               BuffersRequested;
    ULONG               BufferCount;
    ULONG               BufferSize;
    PTRANSFER_BUFFER    TransferBuffers;
    ULONG               IsrReentered;
    ULONG               ControllerVector;
    KIRQL               ControllerIrql;
    KINTERRUPT_MODE     InterruptMode;
    KAFFINITY           ProcessorMask;
    UCHAR               FifoBuffer[10];
    BOOLEAN             AllowInterruptProcessing;
    BOOLEAN             SharableVector;
    BOOLEAN             SaveFloatState;
    BOOLEAN             HardwareFailed;
    BOOLEAN             CommandHasResultPhase;
    BOOLEAN             ControllerConfigurable;
    BOOLEAN             MappedControllerAddress;
    BOOLEAN             CurrentInterrupt;
    BOOLEAN             Model30;
    UCHAR               PerpendicularDrives;
    UCHAR               NumberOfDrives;
    UCHAR               DriveControlImage;
    UCHAR               HardwareFailCount;
    BOOLEAN             ControllerInUse;
    UCHAR               FdcType;
    UCHAR               FdcSpeeds;
    PIRP                CurrentIrp;
    UCHAR               DriveOnValue;
    PDEVICE_OBJECT      LastDeviceObject;
    BOOLEAN             Clock48MHz;
    BOOLEAN             FdcEnablerSupported;
    PDEVICE_OBJECT      FdcEnablerDeviceObject;
    PFILE_OBJECT        FdcEnablerFileObject;
    BOOLEAN             ResetFlag;              // for NEC98
    BOOLEAN             FloppyEquip;            // for NEC98
    UCHAR               MotorRunning;           // for NEC98
    UCHAR               ResultStatus0[4];       // for NEC98

#ifdef TOSHIBAJ
    // For 3mode support
	BOOLEAN		Available3Mode;
    //	Feb.9.1998 KIADP010 Assign Toshiba special registers.
    PUCHAR      ConfigBase;
#endif

} FDC_FDO_EXTENSION, *PFDC_FDO_EXTENSION;


#ifdef TOSHIBAJ
	// Feb.9.1998 KIADP011 Get base address and identifier
	// Feb.9.1998 KIADP012 Identify controller
	// Feb.9.1998 KIADP013 Change Speed

// Definitions for SMC 37C67X/777

// Ports
#define SMC_INDEX_PORT(port) (port)
#define SMC_DATA_PORT(port)  (port)+1

// Key
#define SMC_KEY_ENTER_CONFIG    0x55
#define SMC_KEY_EXIT_CONFIG     0xaa

#define SMC_CONFIG_PORT_LENGTH  2

// Index
#define SMC_INDEX_DEVICE        0x07
#define SMC_INDEX_IDENTIFY      0x20
#define SMC_INDEX_CONF_ADDR_0   0x26
#define SMC_INDEX_CONF_ADDR_1   0x27
#define SMC_INDEX_FDC_OPT       0xf1

// Device
#define SMC_DEVICE_FDC 0x00

// Mask
#define SMC_MASK_DENSEL 0x0c

// Dencity select
#define SMC_DELSEL_HIGH 0x08  // 300rpm
#define SMC_DENSEL_LOW  0x0c  // 360rpm

#endif

//
// NEC98: Registory path of MultifunctionAdapter.
//
#define ISA_BUS_NODE \
        "\\Registry\\MACHINE\\HARDWARE\\DESCRIPTION\\System\\MultifunctionAdapter\\%d"

//
// Macro
//

//
// Enable/Disable Controller
//

#define DISABLE_CONTROLLER_IMAGE(FdoExtension) \
{ \
    if (IsNEC_98) { \
        FdoExtension->DriveControlImage |= DRVCTL_ENABLE_DMA_AND_INTERRUPTS; \
        FdoExtension->DriveControlImage |= DRVCTL_ENABLE_CONTROLLER; \
        FdoExtension->ResetFlag          = FALSE; \
    } else { \
        FdoExtension->DriveControlImage |= DRVCTL_ENABLE_DMA_AND_INTERRUPTS; \
        FdoExtension->DriveControlImage &= ~( DRVCTL_ENABLE_CONTROLLER ); \
    } \
}

#define ENABLE_CONTROLLER_IMAGE(FdoExtension) \
{ \
    if (IsNEC_98) { \
        FdoExtension->DriveControlImage &= ~( DRVCTL_ENABLE_CONTROLLER ); \
        FdoExtension->DriveControlImage |= DRVCTL_AI_ENABLE; \
    } else { \
        FdoExtension->DriveControlImage |= DRVCTL_ENABLE_CONTROLLER; \
    } \
}

//
// Dma speed
//
#define DEFAULT_DMA_SPEED      (IsNEC_98 ? Compatible : TypeA)

//
// Paging Driver with Mutex
//
#define FDC_PAGE_INITIALIZE_DRIVER_WITH_MUTEX \
{ \
    if (!IsNEC_98) { \
        PagingMutex = ExAllocatePool(NonPagedPool, sizeof(FAST_MUTEX)); \
        if (!PagingMutex) { \
            return STATUS_INSUFFICIENT_RESOURCES; \
        } \
        ExInitializeFastMutex(PagingMutex); \
        MmPageEntireDriver(DriverEntry); \
    } \
}

#define FDC_PAGE_RESET_DRIVER_WITH_MUTEX \
{ \
    if (!IsNEC_98) { \
        ExAcquireFastMutex( PagingMutex ); \
        if ( ++PagingReferenceCount == 1 ) { \
            MmResetDriverPaging( DriverEntry ); \
        } \
        ExReleaseFastMutex( PagingMutex ); \
    } \
}

#define FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX \
{ \
    if (!IsNEC_98) { \
        ExAcquireFastMutex(PagingMutex); \
        if (--PagingReferenceCount == 0) { \
            MmPageEntireDriver(DriverEntry); \
        } \
        ExReleaseFastMutex(PagingMutex); \
    } \
}


//
// Prototypes of external routines.
//

/*
LONG
sprintf(
    CHAR *,
    const CHAR *,
    ...
    );
    */

//
// Prototypes of driver routines.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
FcAllocateCommonBuffers(
    IN PFDC_FDO_EXTENSION FdoExtension
    );

NTSTATUS
FcInitializeControllerHardware(
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FdcCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcAddDevice(
    IN      PDRIVER_OBJECT DriverObject,
    IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
    );

BOOLEAN
FdcInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    );

VOID
FdcDeferredProcedure(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
FcAcquireFdc(
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN      PLARGE_INTEGER  TimeOut
    );

NTSTATUS
FcReleaseFdc(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FcReportFdcInformation(
    IN      PFDC_PDO_EXTENSION PdoExtension,
    IN      PFDC_FDO_EXTENSION FdcExtension,
    IN OUT  PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FcTurnOnMotor(
    IN      PFDC_FDO_EXTENSION  FdcExtension,
    IN OUT  PIO_STACK_LOCATION  irpSp
    );

NTSTATUS
FcTurnOffMotor(
    IN      PFDC_FDO_EXTENSION  FdoExtension
    );

VOID
FcAllocateAdapterChannel(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FcFreeAdapterChannel(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

IO_ALLOCATION_ACTION
FdcAllocateAdapterChannel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

NTSTATUS
FcSendByte(
    IN UCHAR ByteToSend,
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    );

NTSTATUS
FcGetByte(
    OUT PUCHAR ByteToGet,
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    );

NTSTATUS
FcIssueCommand(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes
    );

VOID
FcLogErrorDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

BOOLEAN
FcClearIsrReentered(
    IN PVOID Context
    );

NTSTATUS
FcGetFdcInformation(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FdcCheckTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Context
    );

BOOLEAN
FdcTimerSync(
    IN OUT PVOID Context
    );

VOID
FdcStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FcStartCommand(
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    );

NTSTATUS
FcFinishCommand(
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    );

NTSTATUS
FcFinishReset(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FdcBufferThread(
    IN PVOID Context
    );

NTSTATUS
FcFdcEnabler(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    );

NTSTATUS
FcSynchronizeQueue(
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN PIRP Irp
    );

NTSTATUS
FdcPnpComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

NTSTATUS
FdcStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcInitializeDeviceObject( 
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FdcFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcPdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcFilterResourceRequirements( 
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcQueryDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
FdcBusConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
FdcFdoConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
FdcEnumerateQ117(
    IN PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FdcGetEnablerDevice(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

NTSTATUS
FdcPdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcFdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PVOID
FdcGetControllerBase(
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InIoSpace
    );

//
// For NEC98
//

NTSTATUS
FdcHdbit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFDC_FDO_EXTENSION  FdoExtension,
    IN PSET_HD_BIT_PARMS   SetHdBitParams
    );

ULONG
FdcGet0Seg(
    IN PUCHAR   ConfigrationData1,
    IN ULONG   Offset
    );

ULONG
FdcFindIsaBusNode(
    IN OUT VOID
    );

UCHAR
FdcRqmReadyWait(
    IN PFDC_FDO_EXTENSION  FdoExtension,
    IN ULONG               IssueSenseInterrupt
    );


#ifdef TOSHIBAJ

NTSTATUS FcFdcEnable3Mode(
    IN      PFDC_FDO_EXTENSION FdoExtension,
    IN      PIRP Irp
    );

NTSTATUS FcFdcAvailable3Mode(
    IN      PFDC_FDO_EXTENSION FdoExtension,
    IN      PIRP Irp
    );

BOOLEAN
FcCheckConfigPort(
    IN PUCHAR  ConfigPort
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fpfilter\fpfilter.c ===
/*++
Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    fpfilter.c

Abstract:

    This driver is a sample that shows how a Failure Prediction Filter
    driver could be written. A failure prediction filter driver allows
    hardware or software to predict if a disk will fail and if so report
    this fact to the operating system.

    NT automatically supports failure prediction for SCSI and ATAPI disks
    that follow the SMART specification. A failure prediction filter driver
    can enhance or ignore this support as it sees fit.

    A failure prediction filter driver is polled periodically by disk.sys
    to determine if the disk might fail in the future. And it is called
    whenever an application requests the current failure prediction status.

    Note that the underlying disk stack can support failure prediction.
    This would be the case if another failure prediction filter driver
    was installed lower in the stack and/or the disk supports SMART
    and the disk stack itself uses SMART to predict failure. This driver
    can forward the failure prediction ioctl to the stack to find out
    if the lower filter drivers and/or device stack are predicting failure
    and then include that information in its results.

Environment:

    kernel mode only

Notes:

--*/


#define INITGUID

#include "ntddk.h"
#include "ntdddisk.h"
#include "stdarg.h"
#include "stdio.h"


//
// Bit Flag Macros
//

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) & (Bit)) != 0)

//
// Remove lock
//
#define REMLOCK_TAG 'lfpF'
#define REMLOCK_MAXIMUM 1      // Max minutes system allows lock to be held
#define REMLOCK_HIGHWATER 250  // Max number of irps holding lock at one time


//
// Device Extension
//

typedef struct _DEVICE_EXTENSION {

    //
    // Back pointer to device object
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Target Device Object
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    // must synchronize paging path notifications
    //
    KEVENT PagingPathCountEvent;
    ULONG  PagingPathCount;

    //
    // Since we may hold onto irps for an arbitrarily long time
    // we need a remove lock so that our device does not get removed
    // while an irp is being processed.
    IO_REMOVE_LOCK RemoveLock;

    //
    // Flag that specifies if we should predict failure or not. More
    // sophisticated drivers can use statistical or proprietary hardware
    // mechanisms to predict failure.
    BOOLEAN PredictFailure;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define DEVICE_EXTENSION_SIZE sizeof(DEVICE_EXTENSION)


//
// Function declarations
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
FPFilterForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FPFilterAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );


NTSTATUS
FPFilterDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FPFilterDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FPFilterStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FPFilterRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FPFilterSendToNextDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FPFilterCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FPFilterReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FPFilterDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FPFilterShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
FPFilterUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS FPFilterWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FPFilterIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


VOID
FPFilterSyncFilterWithTarget(
    IN PDEVICE_OBJECT FilterDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

#if DBG

#define DEBUG_BUFFER_LENGTH 256

ULONG FPFilterDebug = 0;
UCHAR FPFilterDebugBuffer[DEBUG_BUFFER_LENGTH];

VOID
FPFilterDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define DebugPrint(x)   FPFilterDebugPrint x

#else

#define DebugPrint(x)

#endif

//
// Define the sections that allow for discarding (i.e. paging) some of
// the code.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, FPFilterAddDevice)
#pragma alloc_text (PAGE, FPFilterDispatchPnp)
#pragma alloc_text (PAGE, FPFilterStartDevice)
#pragma alloc_text (PAGE, FPFilterRemoveDevice)
#pragma alloc_text (PAGE, FPFilterUnload)
#pragma alloc_text (PAGE, FPFilterWmi)
#pragma alloc_text (PAGE, FPFilterSyncFilterWithTarget)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O manager to set up the disk
    failure prediction filter driver. The driver object is set up and
    then the Pnp manager calls FPFilterAddDevice to attach to the boot
    devices.

Arguments:

    DriverObject - The disk performance driver object.

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful

--*/

{

    ULONG               ulIndex;
    PDRIVER_DISPATCH  * dispatch;

    //
    // Create dispatch points
    //
    for (ulIndex = 0, dispatch = DriverObject->MajorFunction;
         ulIndex <= IRP_MJ_MAXIMUM_FUNCTION;
         ulIndex++, dispatch++) {

        *dispatch = FPFilterSendToNextDriver;
    }

    //
    // Set up the device driver entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = FPFilterDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = FPFilterDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = FPFilterDispatchPower;

    DriverObject->DriverExtension->AddDevice            = FPFilterAddDevice;
    DriverObject->DriverUnload                          = FPFilterUnload;

    return(STATUS_SUCCESS);

} // end DriverEntry()

#define FILTER_DEVICE_PROPOGATE_FLAGS            0
#define FILTER_DEVICE_PROPOGATE_CHARACTERISTICS (FILE_REMOVABLE_MEDIA |  \
                                                 FILE_READ_ONLY_DEVICE | \
                                                 FILE_FLOPPY_DISKETTE    \
                                                 )

VOID
FPFilterSyncFilterWithTarget(
    IN PDEVICE_OBJECT FilterDevice,
    IN PDEVICE_OBJECT TargetDevice
    )
{
    ULONG                   propFlags;

    PAGED_CODE();

    //
    // Propogate all useful flags from target to FPFilter. MountMgr will look
    // at the FPFilter object capabilities to figure out if the disk is
    // a removable and perhaps other things.
    //
    propFlags = TargetDevice->Flags & FILTER_DEVICE_PROPOGATE_FLAGS;
    SET_FLAG(FilterDevice->Flags, propFlags);

    propFlags = TargetDevice->Characteristics & FILTER_DEVICE_PROPOGATE_CHARACTERISTICS;
    SET_FLAG(FilterDevice->Characteristics, propFlags);


}

NTSTATUS
FPFilterAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:

    Creates and initializes a new filter device object FiDO for the
    corresponding PDO.  Then it attaches the device object to the device
    stack of the drivers for the device.

Arguments:

    DriverObject - Disk performance driver object.
    PhysicalDeviceObject - Physical Device Object from the underlying layered driver

Return Value:

    NTSTATUS
--*/

{
    NTSTATUS                status;
    PDEVICE_OBJECT          filterDeviceObject;
    PDEVICE_EXTENSION       deviceExtension;
    PIRP                    irp;
    ULONG                   registrationFlag = 0;
    PCHAR                   buffer;
    ULONG                   buffersize;

    PAGED_CODE();

    //
    // Create a filter device object for this device (partition).
    //

    DebugPrint((2, "FPFilterAddDevice: Driver %p Device %p\n",
            DriverObject, PhysicalDeviceObject));

    status = IoCreateDevice(DriverObject,
                            DEVICE_EXTENSION_SIZE,
                            NULL,
                            FILE_DEVICE_DISK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &filterDeviceObject);

    if (!NT_SUCCESS(status)) {
       DebugPrint((1, "FPFilterAddDevice: Cannot create filterDeviceObject\n"));
       return status;
    }

    SET_FLAG(filterDeviceObject->Flags, DO_DIRECT_IO);

    deviceExtension = (PDEVICE_EXTENSION) filterDeviceObject->DeviceExtension;

    RtlZeroMemory(deviceExtension, DEVICE_EXTENSION_SIZE);

    //
    // Attaches the device object to the highest device object in the chain and
    // return the previously highest device object, which is passed to
    // IoCallDriver when pass IRPs down the device stack
    //

    deviceExtension->TargetDeviceObject =
        IoAttachDeviceToDeviceStack(filterDeviceObject, PhysicalDeviceObject);

    if (deviceExtension->TargetDeviceObject == NULL) {
        IoDeleteDevice(filterDeviceObject);
        DebugPrint((1, "FPFilterAddDevice: Unable to attach %X to target %X\n",
            filterDeviceObject, PhysicalDeviceObject));
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Save the filter device object in the device extension
    //
    deviceExtension->DeviceObject = filterDeviceObject;

    KeInitializeEvent(&deviceExtension->PagingPathCountEvent,
                      NotificationEvent, TRUE);

    //
    // default to DO_POWER_PAGABLE
    //

    SET_FLAG(filterDeviceObject->Flags,  DO_POWER_PAGABLE);

    //
    // Initialize the remove lock
    //
    IoInitializeRemoveLock(&deviceExtension->RemoveLock,
                           REMLOCK_TAG,
                           REMLOCK_MAXIMUM,
                           REMLOCK_HIGHWATER);

    //
    // Clear the DO_DEVICE_INITIALIZING flag
    //

    CLEAR_FLAG(filterDeviceObject->Flags, DO_DEVICE_INITIALIZING);

    return STATUS_SUCCESS;

} // end FPFilterAddDevice()


NTSTATUS
FPFilterDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch for PNP

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    BOOLEAN lockHeld;
    BOOLEAN irpCompleted;

    PAGED_CODE();

    DebugPrint((2, "FPFilterDispatchPnp: Device %X Irp %X\n",
        DeviceObject, Irp));


    //
    // Acquire the remove lock so that device will not be removed while
    // processing this irp.
    //
    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status))
    {
        DebugPrint((3, "FpFilterPnp: Remove lock failed PNP Irp type [%#02x]\n",
                      irpSp->MinorFunction));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    lockHeld = TRUE;
    irpCompleted = FALSE;

    switch(irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:
        {
            //
            // Call the Start Routine handler. 
            //
            DebugPrint((3,
               "FPFilterDispatchPnp: Schedule completion for START_DEVICE"));
            status = FPFilterStartDevice(DeviceObject, Irp);
            break;
        }

        case IRP_MN_REMOVE_DEVICE:
        {
            //
            // Call the Remove Routine handler. 
            //
            DebugPrint((3,
               "FPFilterDispatchPnp: Schedule completion for REMOVE_DEVICE"));
            status = FPFilterRemoveDevice(DeviceObject, Irp);
            
            //
            // Remove locked released by FpFilterRemoveDevice
            //
            lockHeld = FALSE;
            break;
        }
        
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
        {
            PIO_STACK_LOCATION irpStack;
            ULONG count;
            BOOLEAN setPagable;

            DebugPrint((3,
               "FPFilterDispatchPnp: Processing DEVICE_USAGE_NOTIFICATION"));
            irpStack = IoGetCurrentIrpStackLocation(Irp);

            if (irpStack->Parameters.UsageNotification.Type != DeviceUsageTypePaging) {
                IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
                lockHeld = FALSE;
                status = FPFilterSendToNextDriver(DeviceObject, Irp);
                irpCompleted = TRUE;
                break; // out of case statement
            }

            deviceExtension = DeviceObject->DeviceExtension;

            //
            // wait on the paging path event
            //

            status = KeWaitForSingleObject(&deviceExtension->PagingPathCountEvent,
                                           Executive, KernelMode,
                                           FALSE, NULL);

            //
            // if removing last paging device, need to set DO_POWER_PAGABLE
            // bit here, and possible re-set it below on failure.
            //

            setPagable = FALSE;
            if (!irpStack->Parameters.UsageNotification.InPath &&
                deviceExtension->PagingPathCount == 1 ) {

                //
                // removing the last paging file
                // must have DO_POWER_PAGABLE bits set
                //

                if (TEST_FLAG(DeviceObject->Flags, DO_POWER_INRUSH)) {
                    DebugPrint((3, "FPFilterDispatchPnp: last paging file "
                                "removed but DO_POWER_INRUSH set, so not "
                                "setting PAGABLE bit "
                                "for DO %p\n", DeviceObject));
                } else {
                    DebugPrint((2, "FPFilterDispatchPnp: Setting  PAGABLE "
                                "bit for DO %p\n", DeviceObject));
                    SET_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                    setPagable = TRUE;
                }

            }

            //
            // send the irp synchronously
            //

            status = FPFilterForwardIrpSynchronous(DeviceObject, Irp);

            //
            // now deal with the failure and success cases.
            // note that we are not allowed to fail the irp
            // once it is sent to the lower drivers.
            //

            if (NT_SUCCESS(status)) {

                IoAdjustPagingPathCount(
                    &deviceExtension->PagingPathCount,
                    irpStack->Parameters.UsageNotification.InPath);

                if (irpStack->Parameters.UsageNotification.InPath) {
                    if (deviceExtension->PagingPathCount == 1) {

                        //
                        // first paging file addition
                        //

                        DebugPrint((3, "FPFilterDispatchPnp: Clearing PAGABLE bit "
                                    "for DO %p\n", DeviceObject));
                        CLEAR_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                    }
                }

            } else {

                //
                // cleanup the changes done above
                //

                if (setPagable == TRUE) {
                    CLEAR_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                    setPagable = FALSE;
                }

            }

            //
            // set the event so the next one can occur.
            //

            KeSetEvent(&deviceExtension->PagingPathCountEvent,
                       IO_NO_INCREMENT, FALSE);
        }

        default:
        {
            DebugPrint((3,
               "FPFilterDispatchPnp: Forwarding irp"));
            //
            // Simply forward all other Irps
            //
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            lockHeld = FALSE;
            status = FPFilterSendToNextDriver(DeviceObject, Irp);
            irpCompleted = TRUE;
        }
    }

    if (! irpCompleted)
    {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    
    if (lockHeld)
    {
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    }

    return status;

} // end FPFilterDispatchPnp()


NTSTATUS
FPFilterIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Forwarded IRP completion routine. Set an event and return
    STATUS_MORE_PROCESSING_REQUIRED. Irp forwarder will wait on this
    event and then re-complete the irp after cleaning up.

Arguments:

    DeviceObject is the device object of the WMI driver
    Irp is the WMI irp that was just completed
    Context is a PKEVENT that forwarder will wait on

Return Value:

    STATUS_MORE_PORCESSING_REQUIRED

--*/

{
    PKEVENT Event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // end FPFilterIrpCompletion()


NTSTATUS
FPFilterStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when a Pnp Start Irp is received.
    It will schedule a completion routine to initialize and register with WMI.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp


Return Value:

    Status of processing the Start Irp

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    KEVENT              event;
    NTSTATUS            status;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = FPFilterForwardIrpSynchronous(DeviceObject, Irp);

    FPFilterSyncFilterWithTarget(DeviceObject,
                                 deviceExtension->TargetDeviceObject);

    return status;
}


NTSTATUS
FPFilterRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the device is to be removed.
    It will de-register itself from WMI first, detach itself from the
    stack before deleting itself.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp


Return Value:

    Status of removing the device

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = FPFilterForwardIrpSynchronous(DeviceObject, Irp);

    IoReleaseRemoveLockAndWait(&deviceExtension->RemoveLock, Irp);

    IoDetachDevice(deviceExtension->TargetDeviceObject);
    IoDeleteDevice(DeviceObject);

    return status;
}


NTSTATUS
FPFilterSendToNextDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp is not processed by this driver.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

} // end FPFilterSendToNextDriver()

NTSTATUS
FPFilterDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension;

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    return PoCallDriver(deviceExtension->TargetDeviceObject, Irp);

} // end FPFilterDispatchPower

NTSTATUS
FPFilterForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp needs to be processed by the lower drivers
    prior to being processed by this one.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension;
    KEVENT event;
    NTSTATUS status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // copy the irpstack for the next device
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // set a completion routine
    //

    IoSetCompletionRoutine(Irp, FPFilterIrpCompletion,
                            &event, TRUE, TRUE, TRUE);

    //
    // call the next lower device
    //

    status = IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

    //
    // wait for the actual completion
    //

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;

} // end FPFilterForwardIrpSynchronous()


NTSTATUS
FPFilterDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This device control dispatcher handles only the failure prediction
    device control. All others are passed down to the disk drivers.

Arguments:

    DeviceObject - Context for the activity.
    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PSTORAGE_PREDICT_FAILURE checkFailure;
    NTSTATUS status;

    DebugPrint((2, "FPFilterDeviceControl: DeviceObject %X Irp %X\n",
                    DeviceObject, Irp));

    //
    // Acquire the remove lock so that device will not be removed while
    // processing this irp.
    //
    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status))
        {
        DebugPrint((3, "FpFilterDeviceControl: Remove lock failed IOCTL Irp type [%x]\n",
                 currentIrpStack->Parameters.DeviceIoControl.IoControlCode));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }


    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_STORAGE_PREDICT_FAILURE)
    {

        //
        // Verify user buffer is large enough for the failure prediction data
        //

        if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(STORAGE_PREDICT_FAILURE))
        {
            //
            // Indicate unsuccessful status and no data transferred.
            //

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(STORAGE_PREDICT_FAILURE);

        } else {

            //
            // If underlying device stack supports failure prediction then
            // most likely there is another filter driver and/or support for
            // SMART in the disk stack. We'll call down to get its opinion
            // first before making our own decision as to if the device
            // is predicting failure.

            status = FPFilterForwardIrpSynchronous(DeviceObject, Irp);

            //
            // Here we decide if  we want to predict whether the device
            // will fail or not. We can do many interesting things such
            // as sending a hardware request to the physical device,
            // doing some statistical analysis, whatever makes sense for
            // the device in question.
            //
            checkFailure = Irp->AssociatedIrp.SystemBuffer;

            if (NT_SUCCESS(status))
            {
                //
                // Since a driver lower on the stack has an opinion then we
                // abide by it. We could also do more sophisticated analysis

            } else {
                RtlZeroMemory(checkFailure, sizeof(STORAGE_PREDICT_FAILURE));

                checkFailure->PredictFailure = (deviceExtension->PredictFailure) ?
                                                      1 : 0;
                status = STATUS_SUCCESS;
                Irp->IoStatus.Information = sizeof(STORAGE_PREDICT_FAILURE);
            }
        }

        //
        // Complete request.
        //

        Irp->IoStatus.Status = status;

        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    } else {

        //
        // Pass unrecognized device control requests
        // down to next driver layer.
        //

        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        status = FPFilterSendToNextDriver(DeviceObject, Irp);
    }
    
    return(status);
} // end FPFilterDeviceControl()



VOID
FPFilterUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PAGED_CODE();

    return;
}

#if DBG

VOID
FPFilterDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all FPFilter

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);


    if ((DebugPrintLevel <= (FPFilterDebug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & FPFilterDebug)) {

        _vsnprintf(FPFilterDebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        DbgPrint(FPFilterDebugBuffer);
    }

    va_end(ap);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\mode3fdc\desk2fdc\q117_dat.h ===
/*****************************************************************************
*
* COPYRIGHT 1993 - COLORADO MEMORY SYSTEMS, INC.
* COPYRIGHT 1996, 1997 - COLORADO SOFTWARE ARCHITECTS, INC.
* ALL RIGHTS RESERVED.
*
******************************************************************************
*
* PURPOSE: This file contains all of the API's necessary to access
*               the ADI interface.
*
* HISTORY:
*       $Log: /ddk/src/nt50/storage/fdc/qic117/q117_dat.h $
 * 
 * 3     11/15/97 3:06p John Moore
 * Added NTMS support.
 * 
 * 2     11/10/97 9:28a John Moore
 * Update PnP.
 * 
 * 1     11/01/97 11:30a John Moore
*
*****************************************************************************/

#include "ntddk.h"                     /* various NT definitions */
#include "ntdddisk.h"                  /* disk device driver I/O control codes */

NTSTATUS
q117Initialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT q117iDeviceObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
q117Unload(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
q117Read(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Write(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117DeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Create (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Close (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

/* QIC117 device specific ioctls. *********************************************/

#define IOCTL_QIC117_BASE                 FILE_DEVICE_TAPE

#define IOCTL_QIC117_DRIVE_REQUEST        CTL_CODE(IOCTL_QIC117_BASE, 0x0001, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_QIC117_CLEAR_QUEUE          CTL_CODE(IOCTL_QIC117_BASE, 0x0002, METHOD_NEITHER, FILE_ANY_ACCESS)

/* ADI PUBLIC DATA STRUCTURES ***********************************************/

#pragma pack(4)

struct S_ADIRequestHdr {

    NTSTATUS    status;             /* O: Status returned from device */
    VOID        (*callback_ptr)(dUDWord, dUDWord, dUWord, dStatus);
    ULONG       callback_host_id;   /* I: (Optional) Add'l routing info for host */
    PVOID       cmd_buffer_ptr;     /* I: Logical buffer pointer passed to ADI */
    PVOID       drv_physical_ptr;   /* X: KDI physical pointer - internal use */
    PVOID       drv_logical_ptr;    /* X: Common driver logical pointer - internal use */
    USHORT      driver_cmd;         /* I: Device driver specific command */
    USHORT      drive_handle;       /* I: Host generated device identifier */
    BOOLEAN     blocking_call;      /* I: TRUE implies block until completion */
};
typedef struct S_ADIRequestHdr ADIRequestHdr, *ADIRequestHdrPtr;

#pragma pack()

/* ERROR CODES: *************************************************************/

#define GROUPID_CQD             (UCHAR)0x11    /* GG = 11, CQD Common QIC117 Device Driver */
#define GROUPID_CSD             (UCHAR)0x12    /* GG = 12, CSD Common SCSI Device Driver */
#define GROUPID_ADI             (UCHAR)0x15    /* GG = 15, Application Driver Interface */

#define ERR_NO_ERR              (NTSTATUS)0
#define ERR_SHIFT               (UCHAR)8

#define ERR_SEQ_1               (UCHAR)0x01
#define ERR_SEQ_2               (UCHAR)0x02
#define ERR_SEQ_3               (UCHAR)0x03
#define ERR_SEQ_4               (UCHAR)0x04
#define ERR_SEQ_5               (UCHAR)0x05
#define ERR_SEQ_6               (UCHAR)0x06

/* ERROR ENCODE MACRO: **************************************************/

#define ERROR_ENCODE(m_error, m_fct, m_seq) \
     (((m_fct & 0x00000fff) << 4) | m_seq) | ((unsigned long)m_error << 16)

/* RAW FIRMWARE ERROR CODES: *************** Hex **** Decimal ***********/

#define FW_NO_COMMAND               (UCHAR)0x0000      /* 0    */
#define FW_NO_ERROR                 (UCHAR)0x0000      /* 0    */
#define FW_DRIVE_NOT_READY          (UCHAR)0x0001      /* 1    */
#define FW_CART_NOT_IN              (UCHAR)0x0002      /* 2    */
#define FW_MOTOR_SPEED_ERROR        (UCHAR)0x0003      /* 3    */
#define FW_STALL_ERROR              (UCHAR)0x0004      /* 4    */
#define FW_WRITE_PROTECTED          (UCHAR)0x0005      /* 5    */
#define FW_UNDEFINED_COMMAND        (UCHAR)0x0006      /* 6    */
#define FW_ILLEGAL_TRACK            (UCHAR)0x0007      /* 7    */
#define FW_ILLEGAL_CMD              (UCHAR)0x0008      /* 8    */
#define FW_ILLEGAL_ENTRY            (UCHAR)0x0009      /* 9    */
#define FW_BROKEN_TAPE              (UCHAR)0x000a      /* 10   */
#define FW_GAIN_ERROR               (UCHAR)0x000b      /* 11   */
#define FW_CMD_WHILE_ERROR          (UCHAR)0x000c      /* 12   */
#define FW_CMD_WHILE_NEW_CART       (UCHAR)0x000d      /* 13   */
#define FW_CMD_UNDEF_IN_PRIME       (UCHAR)0x000e      /* 14   */
#define FW_CMD_UNDEF_IN_FMT         (UCHAR)0x000f      /* 15   */
#define FW_CMD_UNDEF_IN_VERIFY      (UCHAR)0x0010      /* 16   */
#define FW_FWD_NOT_BOT_IN_FMT       (UCHAR)0x0011      /* 17   */
#define FW_EOT_BEFORE_ALL_SEGS      (UCHAR)0x0012      /* 18   */
#define FW_CART_NOT_REFERENCED      (UCHAR)0x0013      /* 19   */
#define FW_SELF_DIAGS_FAILED        (UCHAR)0x0014      /* 20   */
#define FW_EEPROM_NOT_INIT          (UCHAR)0x0015      /* 21   */
#define FW_EEPROM_CORRUPTED         (UCHAR)0x0016      /* 22   */
#define FW_TAPE_MOTION_TIMEOUT      (UCHAR)0x0017      /* 23   */
#define FW_DATA_SEG_TOO_LONG        (UCHAR)0x0018      /* 24   */
#define FW_CMD_OVERRUN              (UCHAR)0x0019      /* 25   */
#define FW_PWR_ON_RESET             (UCHAR)0x001a      /* 26   */
#define FW_SOFTWARE_RESET           (UCHAR)0x001b      /* 27   */
#define FW_DIAG_MODE_1_ERROR        (UCHAR)0x001c      /* 28   */
#define FW_DIAG_MODE_2_ERROR        (UCHAR)0x001d      /* 29   */
#define FW_CMD_REC_DURING_CMD       (UCHAR)0x001e      /* 30   */
#define FW_SPEED_NOT_AVAILABLE      (UCHAR)0x001f      /* 31   */
#define FW_ILLEGAL_CMD_HIGH_SPEED   (UCHAR)0x0020      /* 32   */
#define FW_ILLEGAL_SEEK_SEGMENT     (UCHAR)0x0021      /* 33   */
#define FW_INVALID_MEDIA            (UCHAR)0x0022      /* 34   */
#define FW_HEADREF_FAIL_ERROR       (UCHAR)0x0023      /* 35   */
#define FW_EDGE_SEEK_ERROR          (UCHAR)0x0024      /* 36   */
#define FW_MISSING_TRAINING_TABLE   (UCHAR)0x0025      /* 37   */
#define FW_INVALID_FORMAT           (UCHAR)0x0026      /* 38   */
#define FW_SENSOR_ERROR             (UCHAR)0x0027      /* 39   */
#define FW_TABLE_CHECKSUM_ERROR     (UCHAR)0x0028      /* 40   */
#define FW_WATCHDOG_RESET           (UCHAR)0x0029      /* 41   */
#define FW_ILLEGAL_ENTRY_FMT_MODE   (UCHAR)0x002a      /* 42   */
#define FW_ROM_CHECKSUM_FAILURE     (UCHAR)0x002b      /* 43   */
#define FW_ILLEGAL_ERROR_NUMBER     (UCHAR)0x002c      /* 44   */
#define FW_NO_DRIVE                 (UCHAR)0x00ff    /*255 */


/* DRIVER FIRMWARE ERROR CODES: ******* Range: 0x1100 - 0x112a & 0x11ff *****/

#define ERR_CQD                         (USHORT)(GROUPID_CQD<<ERR_SHIFT)

#define ERR_FW_NO_COMMAND               (USHORT)(ERR_CQD + FW_NO_COMMAND)
#define ERR_FW_NO_ERROR                 (USHORT)(ERR_CQD + FW_NO_ERROR)
#define ERR_FW_DRIVE_NOT_READY          (USHORT)(ERR_CQD + FW_DRIVE_NOT_READY)
#define ERR_FW_CART_NOT_IN              (USHORT)(ERR_CQD + FW_CART_NOT_IN)
#define ERR_FW_MOTOR_SPEED_ERROR        (USHORT)(ERR_CQD + FW_MOTOR_SPEED_ERROR)
#define ERR_FW_STALL_ERROR              (USHORT)(ERR_CQD + FW_STALL_ERROR)
#define ERR_FW_WRITE_PROTECTED          (USHORT)(ERR_CQD + FW_WRITE_PROTECTED)
#define ERR_FW_UNDEFINED_COMMAND        (USHORT)(ERR_CQD + FW_UNDEFINED_COMMAND)
#define ERR_FW_ILLEGAL_TRACK            (USHORT)(ERR_CQD + FW_ILLEGAL_TRACK)
#define ERR_FW_ILLEGAL_CMD              (USHORT)(ERR_CQD + FW_ILLEGAL_CMD)
#define ERR_FW_ILLEGAL_ENTRY            (USHORT)(ERR_CQD + FW_ILLEGAL_ENTRY)
#define ERR_FW_BROKEN_TAPE              (USHORT)(ERR_CQD + FW_BROKEN_TAPE)
#define ERR_FW_GAIN_ERROR               (USHORT)(ERR_CQD + FW_GAIN_ERROR)
#define ERR_FW_CMD_WHILE_ERROR          (USHORT)(ERR_CQD + FW_CMD_WHILE_ERROR)
#define ERR_FW_CMD_WHILE_NEW_CART       (USHORT)(ERR_CQD + FW_CMD_WHILE_NEW_CART)
#define ERR_FW_CMD_UNDEF_IN_PRIME       (USHORT)(ERR_CQD + FW_CMD_UNDEF_IN_PRIME)
#define ERR_FW_CMD_UNDEF_IN_FMT         (USHORT)(ERR_CQD + FW_CMD_UNDEF_IN_FMT)
#define ERR_FW_CMD_UNDEF_IN_VERIFY      (USHORT)(ERR_CQD + FW_CMD_UNDEF_IN_VERIFY)
#define ERR_FW_FWD_NOT_BOT_IN_FMT       (USHORT)(ERR_CQD + FW_FWD_NOT_BOT_IN_FMT)
#define ERR_FW_EOT_BEFORE_ALL_SEGS      (USHORT)(ERR_CQD + FW_EOT_BEFORE_ALL_SEGS)
#define ERR_FW_CART_NOT_REFERENCED      (USHORT)(ERR_CQD + FW_CART_NOT_REFERENCED)
#define ERR_FW_SELF_DIAGS_FAILED        (USHORT)(ERR_CQD + FW_SELF_DIAGS_FAILED)
#define ERR_FW_EEPROM_NOT_INIT          (USHORT)(ERR_CQD + FW_EEPROM_NOT_INIT)
#define ERR_FW_EEPROM_CORRUPTED         (USHORT)(ERR_CQD + FW_EEPROM_CORRUPTED)
#define ERR_FW_TAPE_MOTION_TIMEOUT      (USHORT)(ERR_CQD + FW_TAPE_MOTION_TIMEOUT)
#define ERR_FW_DATA_SEG_TOO_LONG        (USHORT)(ERR_CQD + FW_DATA_SEG_TOO_LONG)
#define ERR_FW_CMD_OVERRUN              (USHORT)(ERR_CQD + FW_CMD_OVERRUN)
#define ERR_FW_PWR_ON_RESET             (USHORT)(ERR_CQD + FW_PWR_ON_RESET)
#define ERR_FW_SOFTWARE_RESET           (USHORT)(ERR_CQD + FW_SOFTWARE_RESET)
#define ERR_FW_DIAG_MODE_1_ERROR        (USHORT)(ERR_CQD + FW_DIAG_MODE_1_ERROR)
#define ERR_FW_DIAG_MODE_2_ERROR        (USHORT)(ERR_CQD + FW_DIAG_MODE_2_ERROR)
#define ERR_FW_CMD_REC_DURING_CMD       (USHORT)(ERR_CQD + FW_CMD_REC_DURING_CMD)
#define ERR_FW_SPEED_NOT_AVAILABLE      (USHORT)(ERR_CQD + FW_SPEED_NOT_AVAILABLE)
#define ERR_FW_ILLEGAL_CMD_HIGH_SPEED   (USHORT)(ERR_CQD + FW_ILLEGAL_CMD_HIGH_SPEED)
#define ERR_FW_ILLEGAL_SEEK_SEGMENT     (USHORT)(ERR_CQD + FW_ILLEGAL_SEEK_SEGMENT)
#define ERR_FW_INVALID_MEDIA            (USHORT)(ERR_CQD + FW_INVALID_MEDIA)
#define ERR_FW_HEADREF_FAIL_ERROR       (USHORT)(ERR_CQD + FW_HEADREF_FAIL_ERROR)
#define ERR_FW_EDGE_SEEK_ERROR          (USHORT)(ERR_CQD + FW_EDGE_SEEK_ERROR)
#define ERR_FW_MISSING_TRAINING_TABLE   (USHORT)(ERR_CQD + FW_MISSING_TRAINING_TABLE)
#define ERR_FW_INVALID_FORMAT           (USHORT)(ERR_CQD + FW_INVALID_FORMAT)
#define ERR_FW_SENSOR_ERROR             (USHORT)(ERR_CQD + FW_SENSOR_ERROR)
#define ERR_FW_TABLE_CHECKSUM_ERROR     (USHORT)(ERR_CQD + FW_TABLE_CHECKSUM_ERROR)
#define ERR_FW_WATCHDOG_RESET           (USHORT)(ERR_CQD + FW_WATCHDOG_RESET)
#define ERR_FW_ILLEGAL_ENTRY_FMT_MODE   (USHORT)(ERR_CQD + FW_ILLEGAL_ENTRY_FMT_MODE)
#define ERR_FW_ROM_CHECKSUM_FAILURE     (USHORT)(ERR_CQD + FW_ROM_CHECKSUM_FAILURE)
#define ERR_FW_ILLEGAL_ERROR_NUMBER     (USHORT)(ERR_CQD + FW_ILLEGAL_ERROR_NUMBER)
#define ERR_FW_NO_DRIVE                 (USHORT)(ERR_CQD + FW_NO_DRIVE)

/* JUMBO DRIVER ERROR CODES: ********** Range: 0x1150 - 0x116f **************/

#define ERR_ABORT                       (USHORT)(ERR_CQD + 0x0050)
#define ERR_BAD_BLOCK_FDC_FAULT         (USHORT)(ERR_CQD + 0x0051)
#define ERR_BAD_BLOCK_HARD_ERR          (USHORT)(ERR_CQD + 0x0052)
#define ERR_BAD_BLOCK_NO_DATA           (USHORT)(ERR_CQD + 0x0053)
#define ERR_BAD_FORMAT                  (USHORT)(ERR_CQD + 0x0054)
#define ERR_BAD_MARK_DETECTED           (USHORT)(ERR_CQD + 0x0055)
#define ERR_BAD_REQUEST                 (USHORT)(ERR_CQD + 0x0056)
#define ERR_CMD_FAULT                   (USHORT)(ERR_CQD + 0x0057)
#define ERR_CMD_OVERRUN                 (USHORT)(ERR_CQD + 0x0058)
#define ERR_DEVICE_NOT_CONFIGURED       (USHORT)(ERR_CQD + 0x0059)
#define ERR_DEVICE_NOT_SELECTED         (USHORT)(ERR_CQD + 0x005a)
#define ERR_DRIVE_FAULT                 (USHORT)(ERR_CQD + 0x005b)
#define ERR_DRV_NOT_READY               (USHORT)(ERR_CQD + 0x005c)
#define ERR_FDC_FAULT                   (USHORT)(ERR_CQD + 0x005d)
#define ERR_FMT_MOTION_TIMEOUT          (USHORT)(ERR_CQD + 0x005e)
#define ERR_FORMAT_TIMED_OUT            (USHORT)(ERR_CQD + 0x005f)
#define ERR_INCOMPATIBLE_MEDIA          (USHORT)(ERR_CQD + 0x0060)
#define ERR_INCOMPATIBLE_PARTIAL_FMT    (USHORT)(ERR_CQD + 0x0061)
#define ERR_INVALID_COMMAND             (USHORT)(ERR_CQD + 0x0062)
#define ERR_INVALID_FDC_STATUS          (USHORT)(ERR_CQD + 0x0063)
#define ERR_NEW_TAPE                    (USHORT)(ERR_CQD + 0x0064)
#define ERR_NO_DRIVE                    (USHORT)(ERR_CQD + 0x0065)
#define ERR_NO_FDC                      (USHORT)(ERR_CQD + 0x0066)
#define ERR_NO_TAPE                     (USHORT)(ERR_CQD + 0x0067)
#define ERR_SEEK_FAILED                 (USHORT)(ERR_CQD + 0x0068)
#define ERR_SPEED_UNAVAILBLE            (USHORT)(ERR_CQD + 0x0069)
#define ERR_TAPE_STOPPED                (USHORT)(ERR_CQD + 0x006a)
#define ERR_UNKNOWN_TAPE_FORMAT         (USHORT)(ERR_CQD + 0x006b)
#define ERR_UNKNOWN_TAPE_LENGTH         (USHORT)(ERR_CQD + 0x006c)
#define ERR_UNSUPPORTED_FORMAT          (USHORT)(ERR_CQD + 0x006d)
#define ERR_UNSUPPORTED_RATE            (USHORT)(ERR_CQD + 0x006e)
#define ERR_WRITE_BURST_FAILURE         (USHORT)(ERR_CQD + 0x006f)
#define ERR_MODE_CHANGE_FAILED          (USHORT)(ERR_CQD + 0x0070)
#define ERR_CONTROLLER_STATE_ERROR      (USHORT)(ERR_CQD + 0x0071)
#define ERR_TAPE_FAULT                  (USHORT)(ERR_CQD + 0x0072)
#define ERR_FORMAT_NOT_SUPPORTED        (USHORT)(ERR_CQD + 0x0073)

/* ADI ERROR CODES: **************** Range: 0x1500 - 0x157F *******************/

#define ERR_ADI                         (USHORT)(GROUPID_ADI<<ERR_SHIFT)

#define ERR_NO_VXD                      (USHORT)(ERR_ADI + 0x0000)
#define ERR_QUEUE_FULL                  (USHORT)(ERR_ADI + 0x0001)
#define ERR_REQS_PENDING                (USHORT)(ERR_ADI + 0x0002)
#define ERR_OUT_OF_MEMORY               (USHORT)(ERR_ADI + 0x0003)
#define ERR_ALREADY_CLOSED              (USHORT)(ERR_ADI + 0x0004)
#define ERR_OUT_OF_HANDLES              (USHORT)(ERR_ADI + 0x0005)
#define ERR_ABORTED_COMMAND             (USHORT)(ERR_ADI + 0x0006)
#define ERR_NOT_INITIALIZED             (USHORT)(ERR_ADI + 0x0007)
#define ERR_NO_REQS_PENDING             (USHORT)(ERR_ADI + 0x0008)
#define ERR_CHANNEL_NOT_OPEN            (USHORT)(ERR_ADI + 0x0009)
#define ERR_NO_HOST_ADAPTER             (USHORT)(ERR_ADI + 0x000a)
#define ERR_CMD_IN_PROGRESS             (USHORT)(ERR_ADI + 0x000b)
#define ERR_IGNORE_ECC                  (USHORT)(ERR_ADI + 0x000c)

#define ERR_INVALID_VXD                 (USHORT)(ERR_ADI + 0x0010)
#define ERR_INVALID_CMD                 (USHORT)(ERR_ADI + 0x0011)
#define ERR_INVALID_CMD_ID              (USHORT)(ERR_ADI + 0x0012)
#define ERR_INVALID_HANDLE              (USHORT)(ERR_ADI + 0x0013)
#define ERR_INVALID_DEVICE_CLASS        (USHORT)(ERR_ADI + 0x0014)

#define ERR_NO_ASPI_VXD                 (USHORT)(ERR_ADI + 0x0020)
#define ERR_INVALID_ASPI_VXD            (USHORT)(ERR_ADI + 0x0021)

#define ERR_END_OF_TAPE                 (USHORT)(ERR_ADI + 0x0060)
#define ERR_TAPE_FULL                   (USHORT)(ERR_ADI + 0x0061)
#define ERR_TAPE_READ_FAILED            (USHORT)(ERR_ADI + 0x0062)
#define ERR_TAPE_WRITE_FAILED           (USHORT)(ERR_ADI + 0x0063)
#define ERR_TAPE_SEEK_FAILED            (USHORT)(ERR_ADI + 0x0064)
#define ERR_TAPE_INFO_FAILED            (USHORT)(ERR_ADI + 0x0065)
#define ERR_TAPE_WRITE_PROTECT          (USHORT)(ERR_ADI + 0x0066)

#define ERR_INTERNAL_ERROR              (USHORT)(ERR_ADI + 0x007f)

/* KDI ERROR CODES: **************** Range: 0x1580 - 0x15FF *******************/

#define ERR_HANDLE_EXISTS               (USHORT)(ERR_ADI + 0x0080)
#define ERR_KDI_NOT_OPEN                (USHORT)(ERR_ADI + 0x0081)
#define ERR_OUT_OF_BUFFERS              (USHORT)(ERR_ADI + 0x0082)
#define ERR_INT13_HOOK_FAILED           (USHORT)(ERR_ADI + 0x0083)
#define ERR_IO_VIRTUALIZE_FAILED        (USHORT)(ERR_ADI + 0x0084)
#define ERR_INVALID_ADDRESS             (USHORT)(ERR_ADI + 0x0085)
#define ERR_JUMPERLESS_CFG_FAILED       (USHORT)(ERR_ADI + 0x0086)
#define ERR_TRK_NO_MEMORY               (USHORT)(ERR_ADI + 0x0090)
#define ERR_TRK_MEM_TEST_FAILED         (USHORT)(ERR_ADI + 0x0091)
#define ERR_TRK_MODE_NOT_SET            (USHORT)(ERR_ADI + 0x0092)
#define ERR_TRK_MODE_SET_FAILED         (USHORT)(ERR_ADI + 0x0093)
#define ERR_TRK_FIFO_FAILED             (USHORT)(ERR_ADI + 0x0094)
#define ERR_TRK_DELAY_NOT_SET           (USHORT)(ERR_ADI + 0x0095)
#define ERR_TRK_BAD_DATA_XFER           (USHORT)(ERR_ADI + 0x0096)
#define ERR_TRK_BAD_CTRL_XFER           (USHORT)(ERR_ADI + 0x0097)
#define ERR_TRK_TEST_WAKE_FAIL          (USHORT)(ERR_ADI + 0x0098)
#define ERR_TRK_AUTO_CFG_FAIL           (USHORT)(ERR_ADI + 0x0099)
#define ERR_TRK_CFG_NEEDS_UPDATE        (USHORT)(ERR_ADI + 0x009A)
#define ERR_TRK_NO_IRQ_AVAIL            (USHORT)(ERR_ADI + 0x009B)
#define ERR_DMA_CONFLICT                (USHORT)(ERR_ADI + 0x009C)
#define ERR_DMA_BUFFER_NOT_AVAIL        (USHORT)(ERR_ADI + 0x009D)
#define ERR_KDI_TO_EXPIRED              (USHORT)(ERR_ADI + 0x00A0)
#define ERR_KDI_CONTROLLER_BUSY         (USHORT)(ERR_ADI + 0x00A1)
#define ERR_KDI_CLAIMED_CONTROLLER      (USHORT)(ERR_ADI + 0x00A2)
#define ERR_KDI_NO_VFBACKUP             (USHORT)(ERR_ADI + 0x00A3)
#define ERR_LAST_KDI_ERROR              (USHORT)(ERR_ADI + 0x00ff)

/* KDI ENTRY POINT DEFINES: *************************************************/

#define KDI_GET_VERSION                 (USHORT)0x0000
#define KDI_OPEN_DRIVER                 (USHORT)0x0101
#define KDI_CLOSE_DRIVER                (USHORT)0x0102
#define KDI_SEND_DRIVER_CMD             (USHORT)0x0103
#define KDI_GET_ASYNC_STATUS            (USHORT)0x0104
#define KDI_DEBUG_OUTPUT                (USHORT)0x0105
#define KDI_COPY_BUFFER                 (USHORT)0x0106

/* Trakker specific entry points */
#define KDI_CHECKXOR                    (USHORT)0x0201
#define KDI_FLUSHFIFOX                  (USHORT)0x0202
#define KDI_POPMASKTRAKKERINT           (USHORT)0x0203
#define KDI_PUSHMASKTRAKKERINT          (USHORT)0x0204
#define KDI_READREG                     (USHORT)0x0205
#define KDI_RECEIVEDATA                 (USHORT)0x0206
#define KDI_SENDDATA                    (USHORT)0x0207
#define KDI_SETFIFOXADDRESS             (USHORT)0x0208
#define KDI_SWITCHTODATA                (USHORT)0x0209
#define KDI_TRAKKERXFER                 (USHORT)0x020A
#define KDI_WRITEREG                    (USHORT)0x020B
#define KDI_FINDIRQ                     (USHORT)0x020C
#define KDI_CREATE_TRAKKER_CONTEXT      (USHORT)0x020D

/*--------------------------------------------------
 * This define is needed until the cbw.2 codebase
 * goes away
 *--------------------------------------------------*/
#define KDI_CONFIG_TRAKKER              KDI_CREATE_TRAKKER_CONTEXT


#define KDI_CONFIGURE_TRAKKER           (USHORT)0x020E
#define KDI_TRISTATE                    (USHORT)0x020F
#define KDI_AGRESSIVE_FINDIRQ           (USHORT)0x0210
#define KDI_LOCATE_JUMPERLESS           (USHORT)0x0211
#define KDI_ACTIVATE_JUMPERLESS         (USHORT)0x0212

/* Miscellaneous functions */
#define KDI_PROGRAM_DMA                 (USHORT)0x0301
#define KDI_HALT_DMA                    (USHORT)0x0302
#define KDI_SHORT_TIMER                 (USHORT)0x0303
#define KDI_GET_DMA_BUFFER              (USHORT)0x0304
#define KDI_FREE_DMA_BUFFER             (USHORT)0x0305
#define KDI_GET_VALID_INTERRUPTS        (USHORT)0x0306

/* KDI DEFINES: *************************************************************/

/* KDI_CLOSE_DRIVER parameter options */
#define KDI_ABORT_CLOSE     (USHORT)0x1
#define KDI_NORMAL_CLOSE    (USHORT)0x2


/*****************************************************************************
*
* FILE: microsol.h
*
* PURPOSE:  This file contains all of the defines necessary to access
*               the microsolutions API's
*
*****************************************************************************/

#ifndef _MICROSOL_H_
#define _MICROSOL_H_

#define msiWord unsigned short
#define msiDWord unsigned long
#define msiByte unsigned char

#pragma warning(disable:4001)  //who says double slash is not nice

typedef struct S_MsiPPC {

// API portion of structure

    msiWord
        flag_word,
        lpt_addr,
        lpt_type,
        fdc_type,
        fdc_loops,
        chip_type,
        chip_mode,
        irq_level,
        max_secs,
        rx_mode,
        tx_mode,
        rx_margin,
        tx_margin,
        tx_to_rx,
        rx_factor,
        tx_factor,
        reserved[64];

} MsiPPC;

typedef struct S_MicroSol {
    MsiPPC      ppc_channel;    /* MicroSolutions IO structure */
    msiWord     lpt_number;     /* (I/O) parallel port number */
    msiWord     open_flags;     /* flags to use on open call */
} MicroSol;

//
// Control Flags
//
#define MSI_NO_EEPROM           0x0001
#define MSI_NO_BIDIR            0x0002
#define MSI_NO_FWRITE           0x0004
#define MSI_NO_IBMPS2           0x0008
#define MSI_NO_EPP              0x0010
#define MSI_NO_IRQ              0x0020
#define MSI_NO_AUTOIRQ          0x0040
#define MSI_IRQ_MODE1           0x0080
#define MSI_IRQ_MODE2           0x0100
#define MSI_IRQ_MODE4           0x0200
#define MSI_NO_TPWIZARD         0x0400

//
// DMA Read and Write codes
//
#define MSI_FDC_2_PC            0x0001
#define MSI_PC_2_FDC            0x0000
#define MSI_MAP_MEM             0x0002
#define MSI_USE_CRC             0x0004      // OBSOLETE Always used on 50772
#define MSI_USE_ECC             0x0008

//
// Fault codes
//
#define MSI_FC_NOT_OPEN     0x0101
#define MSI_FC_NOT_CLOSED   0x0102

#define MSI_FC_CON_FAIL     0x0201

#define MSI_FC_FDC_RQM      0x0301
#define MSI_FC_FDC_DIO      0x0302
#define MSI_FC_FDC_BSY      0x0303

#define MSI_FC_DMA_ACT      0x0401
#define MSI_FC_DMA_ABORT    0x0402
#define MSI_FC_DMA_DIR      0x0403
#define MSI_FC_DMA_SIZE     0x0404
#define MSI_FC_DMA_FLOW     0x0405
#define MSI_FC_DMA_CRC      0x0406
#define MSI_FC_DMA_ECC      0x0407
#define MSI_FC_DMA_ZONE     0x0408
#define MSI_FC_DMA_ILLEGAL  0x0409

#define MSI_FC_NOT_IRQ      0x0501
#define MSI_FC_IRQ_ACT      0x0601
#define MSI_FC_EEP_BAD      0x0701

#define MSI_FC_REP_BIT      0x8001      // Application Fault Codes
#define MSI_FC_WRONG_BIT    0x8002
#define MSI_FC_ERR_STATUS   0x8003
#define MSI_FC_NO_CART      0x8004
#define MSI_FC_NEW_CART     0x8005
#define MSI_FC_ECC_FAIL     0x8006

#define MSI_FC_FDC_ABNORMAL 0x8040
#define MSI_FC_FDC_INVALID  0x8080
#define MSI_FC_FDC_CHANGED  0x80C0

//
// Interrupt type (for fc_par_execute_int)
//
#define MSI_FC_INT_HARDWARE 0       // a result of a hardware interrupt
#define MSI_FC_INT_SOFTWARE 1       // a result of a software poll
#define MSI_FC_INT_FORCE    2       // forced software interrupt
#define MSI_FC_INT_INTERNAL 3       // internally generated interrupt?

//
// Function Prototypes
//

extern msiWord cdecl fc_par_version(void);

extern msiWord cdecl fc_par_open(MsiPPC *,msiWord);
extern msiWord cdecl fc_par_close(void);

extern msiWord cdecl fc_par_rd_fdc(msiByte  *, msiWord);
extern msiWord cdecl fc_par_wr_fdc(msiByte  *, msiWord);

extern msiWord cdecl fc_par_rd_port(msiWord);
extern msiWord cdecl fc_par_wr_port(msiWord, msiByte);

extern msiWord cdecl fc_par_rd_eeprom(msiWord);
extern msiWord cdecl fc_par_wr_eeprom(msiWord, msiWord);

extern msiWord cdecl fc_par_rd_dma(msiByte  *, msiWord, msiDWord);
extern msiWord cdecl fc_par_wr_dma(msiByte  *, msiWord, msiDWord);
extern msiWord cdecl fc_par_chk_dma(msiByte  *, msiWord, msiDWord);

extern msiWord cdecl fc_par_clr_dma(msiWord);
extern msiWord cdecl fc_par_prog_dma(msiWord, msiWord, msiDWord);
extern msiWord cdecl fc_par_term_dma(msiWord, msiWord);

extern msiWord cdecl fc_par_execute_int(msiWord);
extern msiWord cdecl fc_par_handle_int(void (cdecl *)(msiWord));

#ifdef NOT_NOW // As of version 6.02 of the microsolutions API,  the code below is obsolete (EBX saved now)

//
// If this is a 32-bit compiler (not 8086 or 80286) then we need to preserve
// the EBX register on fc_par calls.  The code below will do so.
//
#if !defined(M_I8086) && !defined(M_I286)

#pragma warning(disable:4505)

static __inline msiWord msifix_open(MsiPPC *a,msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_open(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_close(void)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_close();
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_rd_fdc(msiByte  *a, msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_rd_fdc(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_wr_fdc(msiByte  *a, msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_wr_fdc(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_rd_port(msiWord a)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_rd_port(a);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_wr_port(msiWord a, msiByte b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_wr_port(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_rd_eeprom(msiWord a)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_rd_eeprom(a);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_wr_eeprom(msiWord a, msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_wr_eeprom(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_rd_dma(msiByte  *a, msiWord b, msiDWord c)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_rd_dma(a,b,c);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_wr_dma(msiByte  *a, msiWord b, msiDWord c)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_wr_dma(a,b,c);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_chk_dma(msiByte  *a, msiWord b, msiDWord c)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_chk_dma(a,b,c);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_clr_dma(msiWord a)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_clr_dma(a);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_prog_dma(msiWord a, msiWord b, msiDWord c)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_prog_dma(a,b,c);
    _asm pop ebx;
    return ret;
    };

static __inline msiWord msifix_term_dma(msiWord a, msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_term_dma(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_execute_int(msiWord a)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_execute_int(a);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_handle_int(void (cdecl *a)(msiWord))
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_handle_int(a);
    _asm pop ebx;
    return ret;
    }

// now use inline functions (that preserve ebx) for all calls into
// microsolutions api
#define fc_par_open(a,b)            msifix_open(a,b)
#define fc_par_close                msifix_close
#define fc_par_rd_port(a)           msifix_rd_port(a)
#define fc_par_wr_port(a, b)        msifix_wr_port(a, b)
#define fc_par_rd_eeprom(a)         msifix_rd_eeprom(a)
#define fc_par_wr_eeprom(a, b)  msifix_wr_eeprom(a, b)
#define fc_par_rd_dma(a, b, c)  msifix_rd_dma(a, b, c)
#define fc_par_wr_dma(a, b, c)  msifix_wr_dma(a, b, c)
#define fc_par_chk_dma(a, b, c) msifix_chk_dma(a, b, c)
#define fc_par_clr_dma(a)           msifix_clr_dma(a)
#define fc_par_prog_dma(a, b, c)    msifix_prog_dma(a, b, c)
#define fc_par_term_dma(a, b)       msifix_term_dma(a, b)
#define fc_par_execute_int(a)       msifix_execute_int(a)
#define fc_par_handle_int(a)        msifix_handle_int(a)
#endif // !defined(M_I8086) && !defined(M_I286)
#endif // NOT_NOW
#endif // _MICROSOL_H_

/*****************************************************************************
*
* FILE: FRB_API.H
*
* PURPOSE: This file contains all of the API's necessary to access
*               the common QIC117 device driver and build FRB's.
*
*****************************************************************************/

/* Valid Tape Formats *******************************************************/
/* S_CQDTapeCfg.tape_class */

#define QIC40_FMT               (UCHAR)1    /* QIC-40 formatted tape  */
#define QIC80_FMT               (UCHAR)2    /* QIC-80 formatted tape  */
#define QIC3010_FMT             (UCHAR)3    /* QIC-3010 formatted tape */
#define QIC3020_FMT             (UCHAR)4    /* QIC-3020 formatted tape */
#define QIC80W_FMT              (UCHAR)5    /* QIC-80W formatted tape */
#define QIC3010W_FMT            (UCHAR)6    /* QIC-3010W formatted tape */
#define QIC3020W_FMT            (UCHAR)7    /* QIC-3020W formatted tape */

/* The following parameters are used to indicate the tape format code *******/
/* S_CQDTapeCfg.tape_format_code */

#define QIC_FORMAT                  (UCHAR)2    /* Indicates a standard or extended length tape */
#define QICEST_FORMAT               (UCHAR)3    /* Indicates a 1100 foot tape   */
#define QICFLX_FORMAT               (UCHAR)4    /* Indicates a flexible format tape foot tape */
#define QIC_XLFORMAT            (UCHAR)5    /* Indicates a 425ft tape */

/* Valid Drive Classes ******************************************************/
/* S_DeviceDescriptor.drive_class */
/* S_DeviceInfo.drive_class */

#define UNKNOWN_DRIVE               (UCHAR)1    /* Unknown drive class  */
#define QIC40_DRIVE              (UCHAR)2   /* QIC-40 drive        */
#define QIC80_DRIVE              (UCHAR)3   /* QIC-80 drive        */
#define QIC3010_DRIVE            (UCHAR)4   /* QIC-3010 drive      */
#define QIC3020_DRIVE            (UCHAR)5   /* QIC-3020 drive      */
#define QIC80W_DRIVE             (UCHAR)6   /* QIC-80W drive       */
#define QIC3010W_DRIVE           (UCHAR)7   /* QIC-3010W drive     */
#define QIC3020W_DRIVE           (UCHAR)8   /* QIC-3020W drive     */

/* Valid Tape Types *********************************************************/
/* The defined values match the QIC117-G spec. except for TAPE_205 */
/* S_CQDTapeCfg.tape_type */

#define TAPE_UNKNOWN            (UCHAR)0x00 /* Unknown tape type           */
#define TAPE_205                (UCHAR)0x11     /* 205 foot 550 Oe             */
#define TAPE_425                (UCHAR)0x01     /* 425 foot 550 Oe             */
#define TAPE_307                (UCHAR)0x02     /* 307.5 foot 550 Oe           */
#define TAPE_FLEX_550           (UCHAR)0x03 /* Flexible Format 550 Oe      */
#define TAPE_FLEX_900           (UCHAR)0x06     /* Flexible Format 900 Oe      */
#define TAPE_FLEX_550_WIDE      (UCHAR)0x0B /* Flexible Format 550 Oe Wide */
#define TAPE_FLEX_900_WIDE      (UCHAR)0x0E     /* Flexible Format 900 Oe Wide */

/* Valid Transfer Rates ******************************************************/

#define XFER_250Kbps            (UCHAR)1   /* 250 Kbps transfer rate supported */
#define XFER_500Kbps            (UCHAR)2   /* 500 Kbps transfer rate supported */
#define XFER_1Mbps              (UCHAR)4   /* 1 Mbps transfer rate supported   */
#define XFER_2Mbps              (UCHAR)8   /* 2Mbps transfer rate supported    */

/* Valid Commands for the driver ********************************************/

#define CMD_LOCATE_DEVICE       (USHORT)0x1100
#define CMD_REPORT_DEVICE_CFG   (USHORT)0x1101
#define CMD_SELECT_DEVICE       (USHORT)0x1102
#define CMD_DESELECT_DEVICE     (USHORT)0x1103
#define CMD_LOAD_TAPE           (USHORT)0x1104
#define CMD_UNLOAD_TAPE         (USHORT)0x1105
#define CMD_SET_SPEED           (USHORT)0x1106
#define CMD_REPORT_STATUS       (USHORT)0x1107
#define CMD_SET_TAPE_PARMS      (USHORT)0x1108
#define CMD_READ                (USHORT)0x1109
#define CMD_READ_RAW            (USHORT)0x110A
#define CMD_READ_HEROIC         (USHORT)0x110B
#define CMD_READ_VERIFY         (USHORT)0x110C
#define CMD_WRITE               (USHORT)0x110D
#define CMD_WRITE_DELETED_MARK  (USHORT)0x110E
#define CMD_FORMAT              (USHORT)0x110F
#define CMD_RETENSION           (USHORT)0x1110
#define CMD_ISSUE_DIAGNOSTIC    (USHORT)0x1111
#define CMD_ABORT               (USHORT)0x1112
#define CMD_DELETE_DRIVE        (USHORT)0x1113
#define CMD_REPORT_DEVICE_INFO  (USHORT)0x1114

/* FC20 jumperless sequence size */
/* NOTE: This is a mirror of the SEQUENCE SIZE define in task.h and needs
 * to be in sync with that define */
#define FC20_SEQUENCE_SIZE      (UCHAR)0x10

/* DATA STRUCTURES: *********************************************************/
/* Note:  The following structures are not aligned on DWord boundaries */
#pragma pack(4)

typedef struct S_DeviceCfg {                /* QIC117 device configuration information */
    BOOLEAN speed_change;                   /* device/FDC combination supports dual speeds */
    BOOLEAN alt_retrys;                     /* Enable reduced retries */
    BOOLEAN new_drive;                      /* indicates whether or not drive has been configured */
    UCHAR   select_byte;                    /* FDC select byte */
    UCHAR   deselect_byte;                  /* FDC deselect byte */
    UCHAR   drive_select;                   /* FDC drive select byte */
    UCHAR   perp_mode_select;               /* FDC perpendicular mode select byte */
    UCHAR   supported_rates;                /* Transfer rates supported by the device/FDC combo */
    UCHAR   drive_id;                       /* Tape device id */
} DeviceCfg, *DeviceCfgPtr;

typedef struct S_DeviceDescriptor {     /* Physical characteristics of the tape device */
    USHORT  sector_size;                    /* sector size in bytes */
    USHORT  segment_size;                   /* Number of sectors per segment */
    UCHAR   ecc_blocks;                     /* Number of ECC sectors per segment */
    USHORT  vendor;                         /* Manufacturer of the tape drive */
    UCHAR   model;                          /* Model of the tape drive */
    UCHAR   drive_class;                    /* Class of tape drive. (QIC-40, QIC-80, etc) */
    UCHAR   native_class;                   /* Native class of tape drive (QIC-40, QIC-80, etc) */
    UCHAR   fdc_type;                       /* Floppy disk controller type */
} DeviceDescriptor, *DeviceDescriptorPtr;

typedef struct S_DeviceInfo {       /* Physical information from the tape device */
    UCHAR   drive_class;                    /* Class of tape drive. (QIC-40, QIC-80, etc) */
    USHORT  vendor;                         /* Manufacturer of the tape drive */
    UCHAR   model;                          /* Model of the tape drive */
    USHORT  version;                            /* Firmware Version */
    USHORT  manufacture_date;               /* days since Jan 1, 1992 */
    ULONG   serial_number;                  /* Cnnnnnnn where 'C' is an alpha character */
                                                    /* in the highest byte, and nnnnnnn is a 7 */
                                                    /* digit decimal number in the remaining 3 bytes */
    UCHAR   oem_string[20];             /* OEM the device is destined for */
    UCHAR   country_code[2];                /* Country code chars, "US", "UK", ... */
} DeviceInfo, *DeviceInfoPtr;

typedef struct S_CQDTapeCfg {               /* Physical characteristics of the tape */
    ULONG   log_segments;                   /* number of logical segments on a tape UDWord  formattable_segs */
    ULONG   formattable_segments;       /* the number of formattable segments */
    ULONG   formattable_tracks;         /* the number of formattable tracks */
    ULONG   seg_tape_track;             /* segments per tape track */
    USHORT  num_tape_tracks;                /* number of tape tracks */
    BOOLEAN write_protected;                /* tape is write protected */
    BOOLEAN read_only_media;                /* tape is read only by the current device i.e QIC40 in a QIC80 */
    BOOLEAN formattable_media;          /* tape can be formatted by the current device */
    BOOLEAN speed_change_ok;                /* tape/device combo supports dual speeds */
    UCHAR   tape_class;                     /* Format of tape in drive */
    UCHAR   max_floppy_side;                /* maximum floppy side */
    UCHAR   max_floppy_track;               /* maximum floppy track */
    UCHAR   max_floppy_sector;          /* maximum floppy sector */
    UCHAR   xfer_slow;                      /* slow transfer rate */
    UCHAR   xfer_fast;                      /* fast transfer rate */
    UCHAR   tape_format_code;
    UCHAR   tape_type;                      /* from status bits 4-7, includes wide bit */
} CQDTapeCfg, *CQDTapeCfgPtr;

typedef struct S_RepositionData {       /* reposition counts */
    USHORT  overrun_count;                  /* data overruns/underruns */
    USHORT  reposition_count;               /* tape repositions */
    USHORT  hard_retry_count;               /* tape repositions due to no data errors */
} RepositionData, *RepositionDataPtr;

typedef struct S_OperationStatus {      /* Driver status */
    ULONG   current_segment;                /* current logical segment */
    USHORT  current_track;                  /* current physical track */
    BOOLEAN new_tape;                       /* new cartridge detected */
    BOOLEAN no_tape;                            /* no tape in the deivce */
    BOOLEAN cart_referenced;                /* tape is not referenced */
    BOOLEAN retry_mode;                     /* device is currently retrying an io operation */
    UCHAR   xfer_rate;                      /* Current transfer rate */
} OperationStatus, *OperationStatusPtr;

typedef struct  S_QIC117 {
    USHORT      r_dor;                  /* Tape adapter board digital output register. */
    USHORT      dor;                        /* Floppy disk controller digital output register. */
    UCHAR       drive_id;               /* Physical tape drive id. */
    UCHAR       reserved[3];
} QIC117;

typedef struct S_Trakker {
    USHORT      r_dor;                  /* Tape adapter board digital output register. */
    USHORT      dor;                        /* Floppy disk controller digital output register. */
    ULONG        trakbuf;                    /* pointer to the dymanic trakker buffer */
    ULONG        mem_size;                       /* Number of bytes on the Trakker */
    UCHAR       drive_id;               /* Physical tape drive id. */
    UCHAR    port_mode;                      /* Current mode that the parallel port is operating in communication eith Trakker */
    UCHAR       lpt_type;                       /* 0=none, 1=uni, 2=bidi */
    UCHAR       lpt_number;                     /* 0=none, 1=LPT1, 2=LPT2, 3=LPT3 */
    UCHAR       wake_index;                     /* the wakeup sequence (of 8 possible) used to access the TRAKKER ASIC */
} Trakker;

/* port_mode:   0 - Unidirectional, Full Handshake, 500Kb, Full Delay
 *              1 - Unidirectional, Full Handshake, 500Kb, Optimize Delays
 *              2 - Unidirectional, Full Handshake, 1Mb,   Optimize Delays
 *              3 - Unidirectional, Self Latch,     1Mb,   Optimize Delays
 *              4 - Bidirectional,  Full Handshake, 500Kb, Optimize Delays
 *              5 - Bidirectional,  Full Handshake, 1Mb,   Optimize Delays
 *              6 - Bidirectional,  Self Latch,     1Mb,   Optimize Delays */


/* Duplicated Grizzly Structure */ /* ------------------------- */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ----------------                             --------------- */
/* ----------------                             --------------- */
/* ----------------   This structure is         --------------- */
/* ----------------                             --------------- */
/* ----------------   must be kept in perfect   --------------- */
/* ----------------                             --------------- */
/* ----------------   synce with its evil twin  --------------- */
/* ----------------                             --------------- */
/* ----------------   struct S_GrizzlyDevice    --------------- */
/* ----------------                             --------------- */
/* ----------------   located in                --------------- */
/* ----------------                             --------------- */
/* ----------------   cbw\code\include\task.h   --------------- */
/* ----------------                             --------------- */
/* ----------------                             --------------- */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */

typedef struct S_Grizzly {
    UCHAR       drive_id;       /* Physical tape drive id. */
    USHORT      grizzly_ctrl;   /* Grizzly special config control options */
    USHORT      xfer_mode;      /* (I/O) parallel port transfer mode */
    UCHAR       xfer_rate;      /* (I/O) device transfer rate selection */
    SHORT       lpt_type;       /* (O) parallel port type */
    UCHAR       lpt_number;     /* (I/O) parallel port number */
} Grizzly;

/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */

typedef union   U_DevSpecific {
    QIC117  q117_dev;           /* Interface specific device parameters for QIC 117 */
    Trakker trakker_dev;        /* Interface specific device parameters for Trakker */
    Grizzly grizzly_dev;
    MicroSol microsol_dev;
} DevSpecific;

typedef struct S_DriveParms {                           /* Hardware parameters for DMA & IRQ enable. */
    DevSpecific dev_parm;                               /* Interface specific device parameters */
    USHORT      drive_handle;                           /* Unique identifier for tape drive. */
    USHORT      base_address;                           /* Controller base address. */
    USHORT      mca_dma_address;                        /* DMA base address on MCA. */
    USHORT      mca_cdma_address;                       /* Compression DMA base address on MCA. */
    BOOLEAN     irq_share;                              /* (TRUE) interrupt sharing enabled. */
    BOOLEAN     io_card;                                    /* (TRUE) IO controller present. */
    BOOLEAN     compress_hard;                          /* (TRUE) hardware compression present. */
    BOOLEAN     micro_channel;                          /* (TRUE) Micro Channel Architecture. */
    BOOLEAN     dual_port_mode;                     /* (TRUE) dual port mode enabled. */
    BOOLEAN     dma_width_mca;                          /* TRUE = 16-bit; FALSE = 8-bit */
    UCHAR       board_type;                             /* Identifies type of controller board */
    UCHAR       clk48mhz;                               /* if true,  then use 48mhz clock if it's an 82078 */
    UCHAR       board_id;                               /* Hard-wired id of board, 0 - 3 */
    UCHAR       irq;                                        /* Hardware interrupt vector. */
    UCHAR       dma;                                        /* Tape drive dma channel. */
    UCHAR       compression_dma;                        /* Compression dma channel. */
    UCHAR       data_dma_16bit;                     /* TRUE-controller is in a 16bit slot */
    UCHAR       extended_irq;                           /* TRUE-IRQ is 10 or 11 */
    UCHAR       setup_reg_shadow;                       /* copy of the setup register used in hio */
    UCHAR       sequence[FC20_SEQUENCE_SIZE];       /* the jumperless sequence used to wake up the FC20 */
} DriveParms, *DriveParmsPtr;

/* JUMBO DRIVER FRB STRUCTURES **********************************************/

typedef struct S_ReportDeviceInfo {             /* Device Information FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    DeviceInfo          device_info;            /* O device information */
} ReportDeviceInfo, *ReportDeviceInfoPtr;

typedef struct S_DriveCfgData {             /* Device Configuration FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    DeviceCfg           device_cfg;             /* I/O device configuration */
    DriveParms          hardware_cfg;           /* I the Hardware I/O Parameters of the drive */
    DeviceDescriptor    device_descriptor;  /* O device description */
    OperationStatus operation_status;       /* O Current status of the device */
} DriveCfgData, *DriveCfgDataPtr;

typedef struct S_DeviceOp {                 /* Generic Device operation FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    OperationStatus operation_status;       /* O Current status of the device */
    ULONG               data;                       /* Command dependent data area */
} DeviceOp, *DeviceOpPtr;

typedef struct S_LoadTape {                 /* New Tape configuration FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    CQDTapeCfg          tape_cfg;               /* O Tape configuration information */
    OperationStatus operation_status;       /* O Current status of the device */
} LoadTape, *LoadTapePtr;

typedef struct S_TapeParms {                    /* Tape length configuration FRB */
    ADIRequestHdr   adi_hdr;                        /* I/O ADI packet header */
    ULONG           segments_per_track;     /* I Segments per tape track */
    CQDTapeCfg      tape_cfg;                   /* O Tape configuration information */
} TapeLength, *TapeLengthPtr;

typedef struct S_DeviceIO {                 /* Device I/O FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    ULONG               starting_sector;        /* I Starting sector for the I/O operation */
    ULONG               number;                 /* I Number of sectors in the I/O operation (including bad) */
    ULONG               bsm;                        /* I Bad sector map for the requested I/O operation */
    ULONG               crc;                        /* O map of sectors that failed CRC check */
    ULONG               retrys;                 /* O map of sectors that had to be retried */
    RepositionData      reposition_data;        /* O reposition counts for the current operation */
    OperationStatus operation_status;       /* O Current status of the device */
} DeviceIO, *DeviceIOPtr;

typedef struct S_FormatRequest {                /* Format request FRB */
    ADIRequestHdr   adi_hdr;                        /* I/O ADI packet header */
    CQDTapeCfg      tape_cfg;                   /* O Tape configuration information */
    USHORT          start_track;                /* I Starting track */
    USHORT          tracks;                     /* I Number of tracks to format */
} FormatRequest, *FormatRequestPtr;

typedef struct S_DComFirm {                 /* Direct firmware communication FRB */
    ADIRequestHdr   adi_hdr;                        /* I/O ADI packet header */
    UCHAR           command_str[32];            /* I Firmware command sequence */
} DComFirm, *DComFirmPtr;

#pragma pack()

/*****************************************************************************
*
* FILE: VENDOR.H
*
* PURPOSE: This file contains all of the defines for each of the vendor
*          numbers and model numbers.  The vendor number data is from the
*          QIC 117 specification.
*
*****************************************************************************/

/* Valid Drive Vendors ******************************************************/
/* The defined values match the QIC117-G spec. */
/* S_DeviceDescriptor.vendor */
/* S_DeviceInfo.vendor */

#define VENDOR_UNASSIGNED       (USHORT)0
#define VENDOR_ALLOY_COMP       (USHORT)1
#define VENDOR_3M               (USHORT)2
#define VENDOR_TANDBERG         (USHORT)3
#define VENDOR_CMS_OLD          (USHORT)4
#define VENDOR_CMS              (USHORT)71
#define VENDOR_ARCHIVE_CONNER   (USHORT)5
#define VENDOR_MOUNTAIN_SUMMIT  (USHORT)6
#define VENDOR_WANGTEK_REXON    (USHORT)7
#define VENDOR_SONY             (USHORT)8
#define VENDOR_CIPHER           (USHORT)9
#define VENDOR_IRWIN            (USHORT)10
#define VENDOR_BRAEMAR          (USHORT)11
#define VENDOR_VERBATIM         (USHORT)12
#define VENDOR_CORE             (USHORT)13
#define VENDOR_EXABYTE          (USHORT)14
#define VENDOR_TEAC             (USHORT)15
#define VENDOR_GIGATEK          (USHORT)16
#define VENDOR_COMBYTE          (USHORT)17
#define VENDOR_PERTEC           (USHORT)18
#define VENDOR_IOMEGA           (USHORT)546
#define VENDOR_CMS_ENHANCEMENTS (USHORT)1021   /* drive_type = CMS Enhancements */
#define VENDOR_UNSUPPORTED      (USHORT)1022   /* drive_type = Unsupported */
#define VENDOR_UNKNOWN          (USHORT)1023   /* drive_type = unknown */

/* Valid Drive Models *******************************************************/
/* S_DeviceDescriptor.model */
/* S_DeviceInfo.model */

#define MODEL_CMS_QIC40           (UCHAR)0x00  /* CMS QIC40 Model # */
#define MODEL_CMS_QIC80           (UCHAR)0x01  /* CMS QIC80 Model # */
#define MODEL_CMS_QIC3010         (UCHAR)0x02  /* CMS QIC3010 Model # */
#define MODEL_CMS_QIC3020         (UCHAR)0x03  /* CMS QIC3020 Model # */
#define MODEL_CMS_QIC80_STINGRAY  (UCHAR)0x04  /* CMS QIC80 STINGRAY Model # */
#define MODEL_CMS_QIC80W          (UCHAR)0x05  /* CMS QIC80W Model # */
#define MODEL_CMS_TR3             (UCHAR)0x06  /* CMS TR3 Model # */
#define MODEL_CONNER_QIC80        (UCHAR)0x0e  /* Conner QIC80 Model # */
#define MODEL_CONNER_QIC80W       (UCHAR)0x10  /* Conner QIC80 Wide Model # */
#define MODEL_CONNER_QIC3010      (UCHAR)0x12  /* Conner QIC3010 Model # */
#define MODEL_CONNER_QIC3020      (UCHAR)0x14  /* Conner QIC3020 Model # */
#define MODEL_CORE_QIC80          (UCHAR)0x21  /* Core QIC80 Model # */
#define MODEL_IOMEGA_QIC80        (UCHAR)0x00  /* Iomega QIC80 Model # */
#define MODEL_IOMEGA_QIC3010      (UCHAR)0x01  /* Iomega QIC3010 Model # */
#define MODEL_IOMEGA_QIC3020      (UCHAR)0x02  /* Iomega QIC3020 Model # */
#define MODEL_SUMMIT_QIC80        (UCHAR)0x01  /* Summit QIC80 Model # */
#define MODEL_SUMMIT_QIC3010      (UCHAR)0x15  /* Summit QIC 3010 Model # */
#define MODEL_WANGTEK_QIC80       (UCHAR)0x0a  /* Wangtek QIC80 Model # */
#define MODEL_WANGTEK_QIC40       (UCHAR)0x02  /* Wangtek QIC40 Model # */
#define MODEL_WANGTEK_QIC3010     (UCHAR)0x0C  /* Wangtek QIC3010 Model # */
#define MODEL_TEAC_TR1            (UCHAR)0x0e
#define MODEL_TEAC_TR2            (UCHAR)0x0f
#define MODEL_PERTEC_TR1          (UCHAR)0x01
#define MODEL_PERTEC_TR2          (UCHAR)0x02
#define MODEL_PERTEC_TR3          (UCHAR)0x03
#define MODEL_UNKNOWN             (UCHAR)0xFF   /* drive_model = unknown */

/*****************************************************************************
*
* FILE: KDIWPRIV.H
*
* PURPOSE: This file contains all of the internal structures and types needed
*          in the KDI.
*
*****************************************************************************/

/* Miscellaneous defines. */
#define NANOSEC_PER_MILLISEC    0x0004f2f0


/* STRUCTURES: **************************************************************/

/* Define the maximum number of controllers and floppies per controller */
/* that this driver will support. */

/* The number of floppies per controller is fixed at 4, since the */
/* controllers don't have enough bits to select more than that (and */
/* actually, many controllers will only support 2).  The number of */
/* controllers per machine is arbitrary; 3 should be more than enough. */

#define MAXIMUM_CONTROLLERS_PER_MACHINE    3

/* MACROS to access the controller.  Note that the *_PORT_UCHAR macros */
/* work on all machines, whether the I/O ports are separate or in */
/* memory space. */

#define READ_CONTROLLER( Address )                         \
    READ_PORT_UCHAR( ( PUCHAR )Address )

#define WRITE_CONTROLLER( Address, Value )                 \
    WRITE_PORT_UCHAR( ( PUCHAR )Address, ( UCHAR )Value )


/* Define the maximum number of tape drives per controller */
/* that this driver will support. */

/* The number of tape drives per controller is fixed at 1, since the */
/* software select schemes generally work for one drive only. */

#define MAXIMUM_TAPE_DRIVES_PER_CONTROLLER 1

/* This structure holds all of the configuration data.  It is filled in */
/* by FlGetConfigurationInformation(), which gets the information from */
/* the configuration manager or the hardware architecture layer (HAL). */

typedef struct s_controllerInfo {
    UCHAR           floppyEnablerApiSupported;
    UCHAR           dmaDirection;
    PDEVICE_OBJECT  apiDeviceObject;
    BOOLEAN         fdcSupported;
    PDEVICE_OBJECT  fdcDeviceObject;
    UNICODE_STRING  fdcUnicodeString;
    WCHAR           idstr[200];
} ControllerInfo;

typedef struct S_KdiContext {
    KEVENT          interrupt_event;
    KEVENT          allocate_adapter_channel_event;
    PKINTERRUPT     interrupt_object;
    PVOID           map_register_base;
    LONG            actual_controller_number;
    PDEVICE_OBJECT  device_object;
    ULONG           base_address;
    PVOID           cqd_context;
    UCHAR           interface_type;
    BOOLEAN         own_floppy_event;
    BOOLEAN         current_interrupt;
    BOOLEAN         interrupt_pending;
    NTSTATUS        interrupt_status;
    BOOLEAN         adapter_locked;
    LIST_ENTRY      list_entry;
    KSEMAPHORE      request_semaphore;
    KSPIN_LOCK      list_spin_lock;
    KEVENT          clear_queue_event;
    BOOLEAN         unloading_driver;
    UCHAR           number_of_tape_drives;
    BOOLEAN         clear_queue;
    BOOLEAN         abort_requested;
    ULONG           error_sequence;
    ULONG           tape_number;
    ControllerInfo  controller_data;
    HANDLE          thread_handle;
} KdiContext, *KdiContextPtr;

typedef struct S_QICDeviceContext {

    PDEVICE_OBJECT      UnderlyingPDO;
    PDEVICE_OBJECT      TargetObject;

    BOOLEAN             DeviceInitialized;
    UNICODE_STRING      InterfaceString;

    PDEVICE_OBJECT  device_object;
    PDEVICE_OBJECT  TapeDeviceObject;
    KdiContextPtr   kdi_context;

    BOOLEAN Paused;
    LIST_ENTRY PauseQueue;
    KSPIN_LOCK PauseQueueSpinLock;

} QICDeviceContext, *QICDeviceContextPtr;


/* PROTOTYPES: **************************************************************/

NTSTATUS 
DriverEntry(
    IN PDRIVER_OBJECT driver_object_ptr,
    IN PUNICODE_STRING registry_path
    );

NTSTATUS 
kdi_DispatchDeviceControl(
    IN    PDEVICE_OBJECT device_object_ptr,
    IN OUT PIRP irp
    );

BOOLEAN 
kdi_Hardware(
    IN PKINTERRUPT interrupt,
    IN PVOID context
    );

VOID 
kdi_DeferredProcedure(
    IN PKDPC dpc,
    IN PVOID deferred_context,
    IN PVOID system_argument_1,
    IN PVOID system_argument_2
    );

VOID 
kdi_UnloadDriver(
    IN PDRIVER_OBJECT driver_object
    );

VOID 
kdi_ThreadRun(
    IN KdiContextPtr kdi_context
    );

IO_ALLOCATION_ACTION 
kdi_AllocateAdapterChannel(
    IN PDEVICE_OBJECT device_object,
    IN PIRP irp,
    IN PVOID map_register_base,
    IN PVOID context
    );

NTSTATUS 
kdi_ConfigCallBack(
    IN PVOID context,
    IN PUNICODE_STRING path_name,
    IN INTERFACE_TYPE bus_type,
    IN ULONG bus_number,
    IN PKEY_VALUE_FULL_INFORMATION *bus_information,
    IN CONFIGURATION_TYPE controller_type,
    IN ULONG controller_number,
    IN PKEY_VALUE_FULL_INFORMATION *controller_information,
    IN CONFIGURATION_TYPE peripheral_type,
    IN ULONG peripheral_number,
    IN PKEY_VALUE_FULL_INFORMATION *peripheral_information
    );

NTSTATUS 
kdi_InitializeDrive(
    IN KdiContextPtr kdi_context,
    IN PVOID cqd_context,
    IN PDRIVER_OBJECT driver_object_ptr,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#if 0
//
// (fcf) kdi_GetControllerBase() does not appear to be used, so I removed it
//       to get rid of the 64bit-related warnings it was generating.
// 
ULONG 
kdi_GetControllerBase(
    IN INTERFACE_TYPE bus_type,
    IN ULONG bus_number,
    IN PHYSICAL_ADDRESS io_address,
    IN ULONG number_of_bytes,
    IN BOOLEAN in_io_space,
    IN PBOOLEAN mapped_address
    );
#endif

NTSTATUS
kdi_TranslateError(
    IN PDEVICE_OBJECT device_object,
    IN NTSTATUS return_value
    );

NTSTATUS 
kdi_ClearIO(
    IN PIRP irp
    );

NTSTATUS 
q117MapStatus(
    IN NTSTATUS status
    );

VOID
q117LogError(
    PDEVICE_OBJECT device_object,
    ULONG sequence_number,
    UCHAR major_function_code,
    UCHAR retry_count,
    ULONG unique_error_value,
    NTSTATUS final_status,
    NTSTATUS specific_IO_status
);

NTSTATUS kdi_FloppyEnabler(
    PDEVICE_OBJECT device_object,
    int ioctl,
    void *data
);


/*****************************************************************************
*
* FILE: KDI_PUB.H
*
* PURPOSE: Prototypes for the functions required by the common driver.
*
*****************************************************************************/

#if DBG

#define DBG_SEEK_FWD        ((ULONG)0x1234566d)
#define DBG_SEEK_REV        ((ULONG)0x1234566f)
#define DBG_SEEK_OFFSET     ((ULONG)0x12345670)
#define DBG_RW_NORMAL       ((ULONG)0x12345671)
#define DBG_SEEK_PHASE      ((ULONG)0x12345672)
#define DBG_L_SECT          ((ULONG)0x12345673)
#define DBG_C_SEG           ((ULONG)0x12345674)
#define DBG_D_SEG           ((ULONG)0x12345675)
#define DBG_C_TRK           ((ULONG)0x12345676)
#define DBG_D_TRK           ((ULONG)0x12345677)
#define DBG_SEEK_ERR        ((ULONG)0x12345678)
#define DBG_IO_TYPE         ((ULONG)0x12345679)
#define DBG_PGM_FDC         ((ULONG)0x1234567a)
#define DBG_READ_FDC        ((ULONG)0x1234567b)
#define DBG_PGM_DMA         ((ULONG)0x1234567c)
#define DBG_SEND_BYTE       ((ULONG)0x1234567d)
#define DBG_RECEIVE_BYTE    ((ULONG)0x1234567e)
#define DBG_IO_CMD_STAT     ((ULONG)0x1234567f)
#define DBG_TIMER_ACK       ((ULONG)0x12345680)
#define DBG_INT_ACK         ((ULONG)0x12345681)
#define DBG_SLEEP           ((ULONG)0x12345682)
#define DBG_WAKEUP          ((ULONG)0x12345683)
#define DBG_ARMINT          ((ULONG)0x12345684)
#define DBG_STATUS          ((ULONG)0x12345685)
#define DBG_READ_BUF        ((ULONG)0x12345686)
#define DBG_WRITE_BUF       ((ULONG)0x12345687)
#define DBG_CALLBACK        ((ULONG)0x12345688)
#define DBG_WAITCC          ((ULONG)0x12345689)
#define DBG_WAITFAULT       ((ULONG)0x1234568a)
#define DBG_FIFO_FDC        ((ULONG)0x1234568b)

extern ULONG kdi_debug_level;

#define KDI_SET_DEBUG_LEVEL(X)    (kdi_debug_level = X)

#else

#define KDI_SET_DEBUG_LEVEL(X)
#define kdi_CheckedDump(X,Y,Z)

#endif


#define MACHINE_TYPE_MASK  0x0F
#define MICRO_CHANNEL      0x01
#define ISA                0x02
#define EISA               0x03
#define PCMCIA             0x04
#define PCI_BUS            0x05
#define CPU_486            0x10

#define DMA_DIR_UNKNOWN    0xff   /* The DMA direction is not currently known */
#define DMA_WRITE          0   /* Program the DMA to write (FDC->DMA->RAM) */
#define DMA_READ           1   /* Program the DMA to read (RAM->DMA->FDC) */

#define NO_ABORT_PENDING    (UCHAR)0xFF
#define ABORT_LEVEL_0       (UCHAR)0
#define ABORT_LEVEL_1       (UCHAR)1

/* Definitions for the bits in the interrupt status/clear register */
#define INTS_FLOP                   0x01    /* Floppy controller interrupt status */

/* Status & control registers */
#define ASIC_INT_STAT           26  /* Interrupt status / clear register */
#define ASIC_DATA_XOR           27  /* data XOR register */


/* DATA TYPES: **************************************************************/

/* Timing values for kdi_Sleep */

#define kdi_wt10us      (ULONG)10l
#define kdi_wt12us      (ULONG)12l
#define kdi_wt500us     (ULONG)500l
#define kdi_wt0ms       (ULONG)0l
#define kdi_wt001ms     (ULONG)1l
#define kdi_wt002ms     (ULONG)2l
#define kdi_wt003ms     (ULONG)3l
#define kdi_wt004ms     (ULONG)4l
#define kdi_wt005ms     (ULONG)5l
#define kdi_wt010ms     (ULONG)10l
#define kdi_wt025ms     (ULONG)25l
#define kdi_wt031ms     (ULONG)31l
#define kdi_wt090ms     (ULONG)90l
#define kdi_wt100ms     (ULONG)100l
#define kdi_wt200ms     (ULONG)200l
#define kdi_wt265ms     (ULONG)265l
#define kdi_wt390ms     (ULONG)390l
#define kdi_wt500ms     (ULONG)500l
#define kdi_wt001s      (ULONG)1000l
#define kdi_wt003s      (ULONG)3000l
#define kdi_wt004s      (ULONG)4000l
#define kdi_wt005s      (ULONG)5000l
#define kdi_wt007s      (ULONG)7000l
#define kdi_wt010s      (ULONG)10000l
#define kdi_wt016s      (ULONG)16000l
#define kdi_wt035s      (ULONG)35000l
#define kdi_wt045s      (ULONG)45000l
#define kdi_wt050s      (ULONG)50000l
#define kdi_wt055s      (ULONG)55000l
#define kdi_wt060s      (ULONG)60000l
#define kdi_wt065s      (ULONG)65000l
#define kdi_wt085s      (ULONG)85000l
#define kdi_wt090s      (ULONG)90000l
#define kdi_wt100s      (ULONG)100000l
#define kdi_wt105s      (ULONG)105000l
#define kdi_wt125s      (ULONG)125000l
#define kdi_wt130s      (ULONG)130000l
#define kdi_wt150s      (ULONG)150000l
#define kdi_wt180s      (ULONG)180000l
#define kdi_wt200s      (ULONG)200000l
#define kdi_wt228s      (ULONG)228000l
#define kdi_wt250s      (ULONG)250000l
#define kdi_wt260s      (ULONG)260000l
#define kdi_wt300s      (ULONG)300000l
#define kdi_wt350s      (ULONG)350000l
#define kdi_wt455s      (ULONG)455000l
#define kdi_wt460s      (ULONG)460000l
#define kdi_wt475s      (ULONG)475000l
#define kdi_wt650s      (ULONG)650000l
#define kdi_wt670s      (ULONG)670000l
#define kdi_wt700s      (ULONG)700000l
#define kdi_wt910s      (ULONG)910000l
#define kdi_wt1300s     (ULONG)1300000l

/* PROTOTYPES: *** ***********************************************************/

VOID 
kdi_ClaimInterrupt(
    IN PVOID kdi_context
    );

NTSTATUS 
kdi_Error(
    IN USHORT  group_and_type,
    IN ULONG   grp_fct_id,
    IN UCHAR   sequence
    );

VOID 
kdi_FlushDMABuffers(
    IN PVOID kdi_context,
    IN BOOLEAN write_operation,
    IN PVOID phy_data_ptr,
    IN ULONG  bytes_transferred_so_far,
    IN ULONG  total_bytes_of_transfer,
    IN BOOLEAN xfer_error
    );

VOID 
kdi_FlushIOBuffers(
    IN PVOID   physical_addr,
    IN BOOLEAN dma_direction,
    IN BOOLEAN flag
    );

USHORT 
kdi_GetErrorType(
    IN NTSTATUS    status
    );

NTSTATUS 
kdi_GetFloppyController(
    IN PVOID kdi_context
    );

UCHAR 
kdi_GetInterfaceType(
    IN PVOID kdi_context
    );


VOID 
kdi_LockUnlockDMA(
    IN PVOID kdi_context,
    IN BOOLEAN lock
    );


VOID 
kdi_ProgramDMA(
    IN     PVOID kdi_context,
    IN     BOOLEAN write_operation,
    IN     PVOID phy_data_ptr,
    IN     ULONG  bytes_transferred_so_far,
    IN OUT PULONG  total_bytes_of_transfer
    );

BOOLEAN 
kdi_QueueEmpty(
    IN PVOID   kdi_context
    );

UCHAR 
kdi_ReadPort(
    IN PVOID kdi_context,
    IN ULONG   address
    );

VOID 
kdi_ReleaseFloppyController(
    IN PVOID kdi_context
    );

BOOLEAN 
kdi_ReportAbortStatus(
    IN PVOID   kdi_context
    );

VOID 
kdi_ResetInterruptEvent(
    IN PVOID kdi_context
    );

VOID 
kdi_ClearInterruptEvent(
    IN PVOID kdi_context
    );

VOID 
kdi_ShortTimer(
    IN USHORT  time
    );

NTSTATUS 
kdi_Sleep(
    IN PVOID   kdi_context,
    IN ULONG   time
    );

BOOLEAN 
kdi_SetDMADirection(
    IN PVOID   kdi_context,
    IN BOOLEAN dma_direction
    );

NTSTATUS 
kdi_FdcDeviceIo(
    IN     PDEVICE_OBJECT DeviceObject,
    IN     ULONG Ioctl,
    IN OUT PVOID Data
    );

BOOLEAN 
kdi_Trakker(
    IN PVOID   kdi_context
    );

BOOLEAN 
kdi_ParallelDriveSlowRate(
    IN PVOID   kdi_context
    );

NTSTATUS 
kdi_CheckXOR(
    IN USHORT  xor_register
    );

VOID 
kdi_PopMaskTrakkerInt(
    );


UCHAR 
kdi_PushMaskTrakkerInt(
    );


NTSTATUS 
kdi_TrakkerXfer(
    IN PVOID       host_data_ptr,
    IN ULONG       trakker_address,
    IN USHORT      count,
    IN UCHAR       direction,
    IN BOOLEAN     in_format
    );

VOID 
kdi_UpdateRegistryInfo(
    IN PVOID kdi_context,
    IN PVOID device_descriptor,
    IN PVOID device_cfg
    );

VOID 
kdi_WritePort(
    IN PVOID kdi_context,
    IN ULONG   address,
    IN UCHAR   byte
    );

#if DBG
VOID 
kdi_CheckedDump(
    IN ULONG       debug_level,
    IN PCHAR       format_str,
    IN ULONG_PTR    argument
    );
#endif

VOID 
kdi_DumpDebug(
   IN PVOID cqd_context
    );

VOID 
kdi_Nuke(
    IN PVOID io_req,
    IN ULONG index,
    IN BOOLEAN destruct
    );

ULONG 
kdi_Rand(
    );

VOID 
kdi_SetFloppyRegisters(
    IN PVOID kdi_context,
    IN ULONG   r_dor,
    IN ULONG   dor
    );

ULONG 
kdi_GetSystemTime(
    );


VOID 
kdi_QIC117ClearIRQ(
    IN PVOID kdi_context
    );

UCHAR
kdi_GetFDCSpeed(
    IN PVOID kdi_context,
    IN UCHAR dma
    );

BOOLEAN
kdi_Grizzly(
    IN PVOID   kdi_context
    );

BOOLEAN 
kdi_Backpack( // a microsolutions chipset
    IN PVOID   kdi_context
    );

NTSTATUS 
kdi_GrizzlyXfer(
    IN PVOID       host_data_ptr,          /* Address of ADI data buffer */
    IN ULONG       grizzly_address,        /* Address of Grizzly RAM buffer */
    IN USHORT      count,                  /* Number of bytes to be transferred */
    IN UCHAR       direction,              /* SEND_DATA or RECEIVE_DATA */
    IN BOOLEAN     in_format,              /* TRUE if performing format operation */
    IN PVOID       kdi_context             /* Ptr to kdi context */
    );

NTSTATUS 
kdi_CloseGrizzly(
    );

/*****************************************************************************
*
* FILE: CQD_PUB.h
*
* PURPOSE: Public KDI->CQD entry points.
*
*****************************************************************************/

/* CQD Function Templates: ****************************************************/

BOOLEAN 
cqd_CheckFormatMode(
    IN PVOID cqd_context
    );

NTSTATUS 
cqd_ClearInterrupt(
    IN PVOID cqd_context,
    IN BOOLEAN expected_interrupt
    );

VOID 
cqd_ConfigureBaseIO(
    IN PVOID cqd_context,
    IN ULONG base_io
    );

BOOLEAN 
cqd_FormatInterrupt(
    IN PVOID cqd_context
    );

VOID 
cqd_InitializeContext(
    IN PVOID cqd_context,
    IN PVOID kdi_context
    );

NTSTATUS 
cqd_LocateDevice(
    IN PVOID cqd_context,
    IN BOOLEAN *vendor_detected
    );

NTSTATUS 
cqd_ProcessFRB(
    IN     PVOID cqd_context,
    IN OUT PVOID frb
    );

VOID 
cqd_ReportAsynchronousStatus(
    IN     PVOID cqd_context,
    IN OUT PVOID dev_op_ptr
    );

USHORT 
cqd_ReportContextSize(
    );

VOID 
cqd_InitializeCfgInformation(
    IN PVOID cqd_context,
    IN PVOID dev_cfg_ptr
    );

/*****************************************************************************
*
* FILE: CQD_DEFS.H
*
* PURPOSE: This file contains all of the defines required by the common driver.
*
****************************************************************************/

// Drive timeing constants 

#define INTERVAL_CMD            kdi_wt031ms
#define INTERVAL_WAIT_ACTIVE    kdi_wt031ms
#define INTERVAL_TRK_CHANGE     kdi_wt007s
#define INTERVAL_LOAD_POINT     kdi_wt670s
#define INTERVAL_SPEED_CHANGE   kdi_wt010s

// Drive firmware revisions 

#define FIRM_VERSION_38         38    // First jumbo A firmware version 
#define FIRM_VERSION_40         40    // Last jumbo A firmware version 
#define FIRM_VERSION_60         60    // First jumbo B firmware version 
#define FIRM_VERSION_63         63    // Cart in problems 
#define FIRM_VERSION_64         64    // First Firmware version to support Skip_n_Seg through the Erase Gap 
#define FIRM_VERSION_65         65    // First Firmware version to support Pegasus 
#define FIRM_VERSION_80         80    // First Firmware version to support Jumbo c 
#define FIRM_VERSION_87         87    // First Firmware revision to support QIC-117 C 
#define FIRM_VERSION_88         88    // First Firmware revision to support no reverse seek slop 
#define FIRM_VERSION_110        110   // First Firmware version to support Eagle 
#define FIRM_VERSION_112        112   // First Firmware version to support QIC-117 E 
#define FIRM_VERSION_128        128   // First Firmware version to support set n segments in qic 80 
#define PROTOTYPE_BIT           0x80  // 8th bit in the firmware is prototype flag 

// Drive status bit masks 

#define STATUS_READY            (UCHAR)0x01
#define STATUS_ERROR            (UCHAR)0x02
#define STATUS_CART_PRESENT     (UCHAR)0x04
#define STATUS_WRITE_PROTECTED  (UCHAR)0x08
#define STATUS_NEW_CART         (UCHAR)0x10
#define STATUS_CART_REFERENCED  (UCHAR)0x20
#define STATUS_BOT              (UCHAR)0x40
#define STATUS_EOT              (UCHAR)0x80


// Drive config bit masks 

#define CONFIG_QIC80        (UCHAR)0x80
#define CONFIG_XL_TAPE      (UCHAR)0x40
#define CONFIG_SPEED        (UCHAR)0x38
#define CONFIG_250KBS       (UCHAR)0x00
#define CONFIG_500KBS       (UCHAR)0x10
#define CONFIG_1MBS         (UCHAR)0x18
#define CONFIG_2MBS         (UCHAR)0x08
#define XFER_RATE_MASK      (UCHAR)0x18
#define XFER_RATE_SHIFT     (UCHAR)0x03

// CMS proprietary status bit masks 

#define CMS_STATUS_NO_BURST_SEEK    (UCHAR)0x01
#define CMS_STATUS_CMS_MODE         (UCHAR)0x02
#define CMS_STATUS_THRESHOLD_LOAD   (UCHAR)0x04
#define CMS_STATUS_DENSITY          (UCHAR)0x08
#define CMS_STATUS_BURST_ONLY_GAIN  (UCHAR)0x10
#define CMS_STATUS_PEGASUS_CART     (UCHAR)0x20
#define CMS_STATUS_EAGLE            (UCHAR)0x40


#define CMS_STATUS_DRIVE_MASK   (UCHAR)0x48

#define CMS_STATUS_QIC_40   (UCHAR)0x08
#define CMS_STATUS_QIC_80   (UCHAR)0x00


// Tape Types 

#define QIC40_SHORT         (UCHAR)1    // normal length cart (205 ft) 
#define QIC40_LONG          (UCHAR)2    // extended length cart (310 ft) 
#define QICEST_40           (UCHAR)3    // QIC-40 formatted tape (1100 ft) 
#define QIC80_SHORT         (UCHAR)4    // QIC-80 format 205 ft tape 
#define QIC80_LONG          (UCHAR)5    // QIC-80 format 310 ft tape 
#define QICEST_80           (UCHAR)6    // QIC-80 formatted tape (1100 ft) 
#define QIC3010_SHORT       (UCHAR)7    // QIC-3010 formatted tape 
#define QICEST_3010         (UCHAR)8    // QIC-3010 formatted tape (1100 ft) 
#define QICFLX_3010         (UCHAR)9    // QIC-3010 formatted tape (Flexible length) 
#define QIC3020_SHORT       (UCHAR)9    // QIC-3020 formatted tape 
#define QICEST_3020         (UCHAR)10   // QIC-3020 formatted tape (1100 ft) 
#define QICFLX_3020         (UCHAR)11   // QIC-3020 formatted tape (Flexible length) 
#define QIC40_XLONG         (UCHAR)12   // QIC-40 format 425 ft tape 
#define QIC80_XLONG         (UCHAR)13   // QIC-80 format 425 ft tape 
#define QICFLX_80W          (UCHAR)14   // QIC-80W formatted tape (Flexible length) 
#define QIC80_EXLONG        (UCHAR)15   // QIC-80 format 1000 ft tape 
#define QICFLX_3010_WIDE    (UCHAR)16   // QIC-3010 formatted tape (Flexible length) Wide tape 
#define QICFLX_3020_WIDE    (UCHAR)17   // QIC-3020 formatted tape (Flexible length) Wide tape 


// EQU's for QIC-40 firmware commands 

#define FW_CMD_SOFT_RESET               (UCHAR)1    // soft reset of tape drive 
#define FW_CMD_RPT_NEXT_BIT             (UCHAR)2    // report next bit (in report subcontext) 
#define FW_CMD_PAUSE                    (UCHAR)3    // pause tape motion 
#define FW_CMD_MICRO_PAUSE              (UCHAR)4    // pause and microstep the head 
#define FW_CMD_ALT_TIMEOUT              (UCHAR)5    // set alternate command timeout 
#define FW_CMD_REPORT_STATUS            (UCHAR)6    // report drive status 
#define FW_CMD_REPORT_ERROR             (UCHAR)7    // report drive error code 
#define FW_CMD_REPORT_CONFG             (UCHAR)8    // report drive configuration 
#define FW_CMD_REPORT_ROM               (UCHAR)9    // report ROM version 
#define FW_CMD_RPT_SIGNATURE            (UCHAR)9    // report drive signature (model dependant diagnostic mode) 
#define FW_CMD_LOGICAL_FWD              (UCHAR)10   // move tape in logical forward mo 
#define FW_CMD_PHYSICAL_REV             (UCHAR)11   // move tape in physical reverse mode 
#define FW_CMD_PHYSICAL_FWD             (UCHAR)12   // move tape in physical forward mode 
#define FW_CMD_SEEK_TRACK               (UCHAR)13   // seek head to track position 
#define FW_CMD_SEEK_LP                  (UCHAR)14   // seek load poSWord 
#define FW_CMD_FORMAT_MODE              (UCHAR)15   // enter format mode 
#define FW_CMD_WRITE_REF                (UCHAR)16   // write reference burst 
#define FW_CMD_VERIFY_MODE              (UCHAR)17   // enter verify mode 
#define FW_CMD_PARK_HEAD                (UCHAR)17   // park head (model dependant diagnostic mode) 
#define FW_CMD_TOGGLE_PARAMS            (UCHAR)17   // toggle internal modes (model dependant diagnostic mode) 
#define FW_CMD_STOP_TAPE                (UCHAR)18   // stop the tape 
#define FW_CMD_READ_NOISE_CODE          (UCHAR)18   // check noise on drive (model dependent diagnostic mode) 
#define FW_CMD_MICROSTEP_UP             (UCHAR)21   // microstep head up 
#define FW_CMD_DISABLE_WP               (UCHAR)21   // disable write protect line (model dependent diagnostic mode) 
#define FW_CMD_MICROSTEP_DOWN           (UCHAR)22   // microstep head down 
#define FW_CMD_SET_GAIN                 (UCHAR)22   // set absolute drive gain (model dependant diagnostic mode) 
#define FW_CMD_READ_PORT2               (UCHAR)23   // read the drive processor port 2 (diagnostic command) 
#define FW_CMD_REPORT_VENDOR            (UCHAR)24   // report vendor number 
#define FW_CMD_SKIP_N_REV               (UCHAR)25   // skip n segments reverse 
#define FW_CMD_SKIP_N_FWD               (UCHAR)26   // skip n segments forward 
#define FW_CMD_SELECT_SPEED             (UCHAR)27   // select tape speed 
#define FW_CMD_DIAG_1_MODE              (UCHAR)28   // enter diagnostic mode 1 
#define FW_CMD_DIAG_2_MODE              (UCHAR)29   // enter diagnostic mode 2 
#define FW_CMD_PRIMARY_MODE             (UCHAR)30   // enter primary mode 
#define FW_CMD_REPORT_VENDOR32          (UCHAR)32   // report vendor number (for firmware versions > 33) 
#define FW_CMD_REPORT_TAPE_STAT         (UCHAR)33   // reports the tape format of the currently loaded tape 
#define FW_CMD_SKIP_N_REV_EXT           (UCHAR)34   // skip n segments reverse (extended format) 
#define FW_CMD_SKIP_N_FWD_EXT           (UCHAR)35   // skip n segments forward (extended format) 
#define FW_CMD_CAL_TAPE_LENGTH          (UCHAR)36   // Determine the number of seg/trk available on the tape 
#define FW_CMD_REPORT_TAPE_LENGTH       (UCHAR)37   // Report the number of seg/trk available on the tape 
#define FW_CMD_SET_FORMAT_SEGMENTS      (UCHAR)38   // Set the number of segments the drive shall use for generating index pulses 
#define FW_CMD_RPT_CMS_STATUS           (UCHAR)37   // report CMS status byte (model dependant - diagnostic mode) 
#define FW_CMD_SET_RAM_HIGH             (UCHAR)40   // set the high nibble of the ram 
#define FW_CMD_SET_RAM_LOW              (UCHAR)41   // set the low nibble of the ram 
#define FW_CMD_SET_RAM_PTR_HIGH         (UCHAR)42   // set the high nibble of the ram address 
#define FW_CMD_SET_RAM_PTR_LOW          (UCHAR)43   // set the low nibble of the ram address 
#define FW_CMD_READ_RAM                 (UCHAR)44   // read tape drive RAM 
#define FW_CMD_NEW_TAPE                 (UCHAR)45   // load tape sequence 
#define FW_CMD_SELECT_DRIVE             (UCHAR)46   // select the tape drive 
#define FW_CMD_DESELECT_DRIVE           (UCHAR)47   // deselect the tape drive 
#define FW_CMD_REPORTPROTOVER           (UCHAR)50   // reports firmware prototype version number (model dependant - diagnostic mode) 
#define FW_CMD_DTRAIN_INFO              (UCHAR)53   // enter Drive Train Information mode (model dependant - diagnostic mode) 
#define FW_CMD_GDESP_INFO               (UCHAR)5     // display drive train information 
#define FW_CMD_CONNER_SELECT_1          (UCHAR)23   // Mountain select byte 1 
#define FW_CMD_CONNER_SELECT_2          (UCHAR)20   // Mountain select byte 2 
#define FW_CMD_CONNER_DESELECT          (UCHAR)24   // Mountain deselect byte 
#define FW_CMD_RPT_CONNER_NATIVE_MODE   (UCHAR)40   // Conner Native Mode diagnostic command 
#define FW_CMD_CMS_MODE_OLD             (UCHAR)32   // toggle CMS mode (model dependant - diagnostic mode) 

// Floppy Disk Command Bit defines 
#define FIFO_MASK           (UCHAR)0x0f    // Mask for FIFO threshold field in config cmd 
#define FDC_EFIFO           (UCHAR)0x20    // Mask for disabling FIFO in config cmd 
#define FDC_CLK48           (UCHAR)0x80    // Bit of config command that enables 48Mhz clocks on 82078 
#define FDC_PRECOMP_ON      (UCHAR)0x00    // Mask for enabling write precomp 
#define FDC_PRECOMP_OFF     (UCHAR)0x1C    // Mask for disabling write precomp 

// Floppy Disk Controller I/O Ports 

#define FDC_NORM_BASE   (ULONG)0x000003f0     // base for normal floppy controller 
#define DCR_OFFSET      (ULONG)0X00000007     // Digital control register offset 
#define DOR_OFFSET      (ULONG)0X00000002     // Digital-output Register offset 
#define RDOR_OFFSET     (ULONG)0X00000002     // Digital-output Register offset 
#define MSR_OFFSET      (ULONG)0X00000004     // Main Status Register offset 
#define DSR_OFFSET      (ULONG)0X00000004     // Data Rate Select Register offset 
#define TDR_OFFSET      (ULONG)0X00000003     // Tape drive register offset 
#define DR_OFFSET       (ULONG)0X00000005     // Data Register offset 
#define DUAL_PORT_MASK  (ULONG)0x00000080     

// Floppy Disk Port constants 

// normal drive B 
#define curb                1
#define selb                0x2d    // 00101101: motor B + enable DMA/IRQ/FDC + sel B 
#define dselb               0x0c    // 00001100: enable DMA/IRQ/FDC + sel A 
// unselected drive 
#define curu                0
#define selu                0x0d    // 00001101: enable DMA/IRQ/FDC + sel B 
#define dselu               0x0c    // 00001100: enable DMA/IRQ/FDC + sel A 
// normal drive D 
#define curd                3
#define seld                0x8f    // 10001111: motor D + enable DMA/IRQ/FDC + sel D 
#define dseld               0x0e    // 00001110  motor D + enable DMA/IRQ/FDC + sel C 
// laptop unselected drive 
#define curub               0
#define selub               0x2d    // 00101101: motor B + enable DMA/IRQ/FDC + sel B 
#define dselub              0x0c    // 00001100: enable DMA/IRQ/FDC + sel A 

#define alloff              0x08    // no motor + enable DMA/IRQ + disable FDC + sel A 
#define fdc_idle            0x0c    // no motor + enable DMA/IRQ/FDC + sel A 

#define DRIVE_ID_MASK       0x03
#define DRIVE_SELECT_OFFSET 0x05
#define DRIVE_SPECIFICATION 0x8E
#define DRIVE_SPEC          0x08
#define DONE_MARKER         0xC0

// Floppy configuration parameters 

#define FMT_DATA_PATTERN    0x6b    // Format data pattern 
#define FDC_FIFO            15      // FIFO size for an 82077 
#define FDC_HLT             0x02    // FDC head load time 
#define FMT_GPL             233     // gap length for format (QIC-40 QIC-80) 
#define FMT_GPL_3010        241     // gap length for format (QIC-3010) 
#define FMT_GPL_3020        248     // gap length for format (QIC-3020) 
#define WRT_GPL             1       // gap length for write (QIC-40 QIC-80 QIC-3010 QIC-3020) 
#define FMT_BPS             03      // bytes per sector for formatting(1024) 
#define WRT_BPS             FMT_BPS // bytes per sector for reading/writing (1024) 
#define FSC_SEG             32      // floppy sectors per segment (QIC-40 205ft & 310ft) 
#define SEG_FTK             4       // segments per floppy track (QIC-40 205ft & 310ft) 
#define FSC_FTK             (FSC_SEG*SEG_FTK)    // floppy sectors per floppy track (QIC-40 205ft & 310ft) 
#define SEG_TTRK_40         68      // segments per tape track (QIC-40 205ft) 
#define SEG_TTRK_40L        102     // segments per tape track (QIC-40 310ft) 
#define SEG_TTRK_40XL       141     // segments per tape track (QIC-40 425ft) 
#define SEG_TTRK_80         100     // segments per tape track (QIC-80 205ft) 
#define SEG_TTRK_80L        150     // segments per tape track (QIC-80 310ft) 
#define SEG_TTRK_80W        365     // segments per tape track (QIC-80 310ft) 
#define SEG_TTRK_80XL       207     // segments per tape track (QIC-80 425ft) 
#define SEG_TTRK_80EX       490     // segments per tape track (QIC-80 1000ft) 
#define SEG_TTRK_QICEST_40  365     // segments per tape track (QIC-40 QICEST) 
#define SEG_TTRK_QICEST_80  537     // segments per tape track (QIC-80 QICEST) 
#define SEG_TTRK_3010       800     // segments per tape track (QIC-3010 1000ft) 
#define SEG_TTRK_3020       1480    // segments per tape track (QIC-3020 1000ft) 
#define SEG_TTRK_3010_400ft 300     // segments per tape track (QIC-3010 400ft) 
#define SEG_TTRK_3020_400ft 422     // segments per tape track (QIC-3020) 



#define FTK_FSD_40          170     // floppy tracks per floppy side (QIC-40 205ft)     
#define FTK_FSD_40L         255     // floppy tracks per floppy side (QIC-40 310ft)     
#define FTK_FSD_40XL        170     // floppy tracks per floppy side (QIC-40 425ft)     
#define FTK_FSD_80          150     // floppy tracks per floppy side (QIC-80 205ft)     
#define FTK_FSD_80L         150     // floppy tracks per floppy side (QIC-80 310ft)     
#define FTK_FSD_80XL        150     // floppy tracks per floppy side (QIC-80 425ft)     
#define FTK_FSD_QICEST_40   254     // floppy tracks per floppy side (QIC-40 QICEST)    
#define FTK_FSD_QICEST_80   254     // floppy tracks per floppy side (QIC-80 QICEST)    
#define FTK_FSD_FLEX80      255     // floppy tracks per floppy side (QIC-80 Flexible)  
#define FTK_FSD_3010        255     // floppy tracks per floppy side (QIC-3010)         
#define FTK_FSD_3020        255     // floppy tracks per floppy side (QIC-3020)         

#define NUM_TTRK_40         20      // number of tape tracks (QIC-40 205ft & 310ft) 
#define NUM_TTRK_80         28      // number of tape tracks (QIC-40 205ft & 310ft) 
#define NUM_TTRK_80W        36      // 
#define NUM_TTRK_3010       40      // number of tape tracks (QIC-3010) 
#define NUM_TTRK_3020       40      // number of tape tracks (QIC-3020) 
#define NUM_TTRK_3010W      50      // number of tape tracks (QIC-3010 wide) 
#define NUM_TTRK_3020W      50      // number of tape tracks (QIC-3020 wide) 
#define PHY_SECTOR_SIZE     (USHORT)1024    // number of bytes per sector 
#define ECC_SEG             (UCHAR)3        // ecc sectors per segment 
#define MAX_FDC_SEEK        (USHORT)128


// Tape Format Types and lengths/Coercivity 


#define QIC_UNKNOWN         0       // Unknown Tape Format and Length 
#define QIC_40              1       // QIC-40 Tape Format 
#define QIC_80              2       // QIC-80 Tape Format 
#define QIC_3020            3       // QIC-3020 Tape Format 
#define QIC_3010            4       // QIC-3010 Tape Format 

#define QIC_SHORT           1       // Length = 205 & Coercivity = 550 Oe 
                                                // or Length = 425 & Coercivity = 550 Oe 
#define QIC_LONG            2       // Length = 307.5 & Coercivity = 550 Oe 
#define QIC_SHORT_900       3       // Length = 295 & Coercivity = 900 Oe 
#define QICEST              4       // Length = 1100 & Coercivity = 550 Oe 
#define QICEST_900          5       // Length = 1100 & Coercivity = 900 Oe 
#define QIC_FLEXIBLE_550_WIDE  0x0B    // Flexible format tape 550 Oe Wide tape 
#define QIC_FLEXIBLE_900       6       // Flexible format tape 900 Oe 
#define QIC_FLEXIBLE_900_WIDE  0x0E    // Flexible format tape 900 Oe Wide tape 

// Floppy disk controller misc constants 

// 82077 version number 
#define VALID_NEC_FDC           0x90    // version number 
#define NSC_PRIMARY_VERSION     0x70    // National 8477 verion number 
#define NSC_MASK                0xF0    // mask for National version number 
#define FDC_82078_44_MASK       0x40    // mask for 82078 44 pin part id 
#define FDC_DCR_MASK            0x03    // mask for fdc's configuration control register xfer rates 
#define FDC_CONFIG_NULL_BYTE    0x00
#define FDC_CONFIG_PRETRACK     0x00

// main status register 
#define MSR_RQM     0x80    // request for master 
#define MSR_DIO     0x40    // data input/output (0=input, 1=output) 
#define MSR_EXM     0x20    // execution mode 
#define MSR_CB      0x10    // FDC busy 
#define MSR_D3B     0x08    // FDD 3 busy 
#define MSR_D2B     0x04    // FDD 2 busy 
#define MSR_D1B     0x02    // FDD 1 busy 
#define MSR_D0B     0x01    // FDD 0 busy 

// status register 0 
#define ST0_IC      0xC0    // Interrupt code (00=Normal, 01=Abnormal, 10=Illegal cmd, 11=Abnormal) 
#define ST0_SE      0x20    // Seek end 
#define ST0_EC      0x10    // Equipment check 
#define ST0_NR      0x08    // Not Ready 
#define ST0_HD      0x04    // Head Address 
#define ST0_US      0x03    // Unit Select (0-3) 

// status register 1 
#define ST1_EN      0x80    // End of Cylinder 
#define ST1_DE      0x20    // Data Error (CRC error) 
#define ST1_OR      0x10    // Over Run 
#define ST1_ND      0x04    // No Data 
#define ST1_NW      0x02    // Not Writable (write protect error) 
#define ST1_MA      0x01    // Missing Address Mark 

// status register 2 
#define ST2_CM      0x40    // Control Mark (Deleted Data Mark) 
#define ST2_DD      0x20    // Data Error in Data Field 
#define ST2_WC      0x10    // Wrong Cylinder 
#define ST2_SH      0x08    // Scan Equal Hit 
#define ST2_SN      0x04    // Scan Not Satisfied 
#define ST2_BC      0x02    // Bad Cylinder 
#define ST2_MD      0x01    // Missing Address Mark in Data Field 

// status register 3 
#define ST3_FT      0x80    // Fault 
#define ST3_WP      0x40    // Write Protected 
#define ST3_RY      0x20    // Ready 
#define ST3_T0      0x10    // Track 0 
#define ST3_TS      0x08    // Two Side 
#define ST3_HD      0x04    // Head address 
#define ST3_US      0x03    // Unit Select (0-3) 

// Misc. constants 

#define FWD                 0       // seek in the logical forward direction 
#define REV                 1       // seek in the logical reverse direction 
#define STOP_LEN            5       // approximate number of blocks used to stop the tape 
#define SEEK_SLOP           3       // number of blocks to overshoot at high speed in a seek 
#define SEEK_TIMED          0x01    // Perform a timed seek 
#define SEEK_SKIP           0x02    // perform a skip N segemnts seek 
#define SEEK_SKIP_EXTENDED  0x03    // perform an extended skip N segemnts seek 

// number of blocks to overshoot when performing a high speed reverve seek 
#define QIC_REV_OFFSET      3
#define QIC_REV_OFFSET_L    4
#define QICEST_REV_OFFSET   14
#define MAX_SKIP            255     // Max number of segments that a Skip N Segs command can skip 
#define MAX_SEEK_NIBBLES    3       // Maximum number of nibbles in an extended mode seek 

#define TRACK_0             (UCHAR)0
#define TRACK_5             (UCHAR)5
#define TRACK_7             (UCHAR)7
#define TRACK_9             (UCHAR)9
#define TRACK_11            (UCHAR)11
#define TRACK_13            (UCHAR)13
#define TRACK_15            (UCHAR)15
#define TRACK_17            (UCHAR)17
#define TRACK_19            (UCHAR)19
#define TRACK_21            (UCHAR)21
#define TRACK_23            (UCHAR)23
#define TRACK_25            (UCHAR)25
#define TRACK_27            (UCHAR)27
#define ILLEGAL_TRACK       (USHORT)0xffff
#define ODD_TRACK           (USHORT)0x0001
#define EVEN_TRACK          (USHORT)0x0000
#define ALL_BAD             (ULONG)0xffffffff
#define QIC3010_OFFSET      (ULONG)2
#define QIC3020_OFFSET      (ULONG)4

#define NUM_BAD             10      // number of bad READ ID's in row for no_data error 
#define OR_TRYS             10      // number of Over Runs ignored per block (system 50) 

#define PRIMARY_MODE        0       // tape drive is in primary mode 
#define FORMAT_MODE         1       // tape drive is in format mode 
#define VERIFY_MODE         2       // tape drive is in verify mode 
#define DIAGNOSTIC_1_MODE   3       // tape drive is in diagnostic mode 1 
#define DIAGNOSTIC_2_MODE   4       // tape drive is in diagnostic mode 2 

#define READ_BYTE           8       // Number of Bytes to receive from the tape 
#define READ_WORD           16      //  drive during communication. 

#define HD_SELECT           0x01    // High Density Select bit from the PS/2 DCR 


#define TAPE_250Kbps        0       // Program drive for 250 Kbps transfer rate 
#define TAPE_2Mbps          1       // Program drive for 2Mbps transfer rate 
#define TAPE_500Kbps        2       // Program drive for 500 Kbps transfer rate 
#define TAPE_1Mbps          3       // Program drive for 1 Mbps transfer rate 
#define FDC_250Kbps         2       // Program FDC for 250 Kbps transfer rate 
#define FDC_500Kbps         0       // Program FDC for 500 Kbps transfer rate 
#define FDC_1Mbps           3       // Program FDC for 1 Mbps transfer rate 
#define FDC_2Mbps           1       // Program FDC for 2 Mbps transfer rate 
#define SRT_250Kbps         0xff    // FDC step rate for 250 Kbps transfer rate 
#define SRT_500Kbps         0xef    // FDC step rate for 500 Kbps transfer rate 
#define SRT_1Mbps           0xcf    // FDC step ratefor 1 Mbps transfer rate 
#define SRT_2Mbps           0x8f    // FDC step rate for 2 Mbps transfer rate 
#define SPEED_MASK          0x03    // FDC speed mask for lower bits 
#define FDC_2MBPS_TABLE     2       // 2 Mbps data rate table for the 82078 


#define CMS_SIG             0xa5    // drive signature for CMS drives 
#define CMS_VEND_NO_OLD     0x0047  // CMS vendor number old 
#define CMS_VEND_NO_NEW     0x11c0  // CMS vendor number new 
#define CMS_QIC40           0x0000  // CMS QIC40 Model # 
#define CMS_QIC80           0x0001  // CMS QIC80 Model # 
#define CMS_QIC3010         0x0002  // CMS QIC3010 Model # 
#define CMS_QIC3020         0x0003  // CMS QIC3020 Model # 
#define CMS_QIC80_STINGRAY  0x0004  // CMS QIC80 STINGRAY Model # 
#define CMS_QIC80W          0x0005  // CMS QIC80W Model # 
#define CMS_TR3             0x0006  // CMS TR3 Model # 
#define EXABYTE_VEND_NO     0x0380  // Summit vendor number 
#define SUMMIT_VEND_NO      0x0180  // Summit vendor number 
#define IOMEGA_VEND_NO      0x8880  // Iomega vendor number 
#define WANGTEK_VEND_NO     0x01c0  // Wangtek vendor number 
#define TECHMAR_VEND_NO     0x01c0  // Techmar vendor number 
#define CORE_VEND_NO        0x0000  // Core vendor number 
#define CONNER_VEND_NO_OLD  0x0005  // Conner vendor number (old mode) 
#define CONNER_VEND_NO_NEW  0x0140  // Conner vendor number (new mode) 
#define VENDOR_MASK         0xffc0  // Vendor id mask 
#define IOMEGA_QIC80        0x0000  // Iomega QIC80 Model # 
#define IOMEGA_QIC3010      0x0001  // Iomega QIC3010 Model # 
#define IOMEGA_QIC3020      0x0002  // Iomega QIC3020 Model # 
#define SUMMIT_QIC80        0x0001  // Summit QIC80 Model # 
#define SUMMIT_QIC3010      0x0015  // Summit QIC 3010 Model # 
#define WANGTEK_QIC80       0x000a  // Wangtek QIC80 Model # 
#define WANGTEK_QIC40       0x0002  // Wangtek QIC40 Model # 
#define WANGTEK_QIC3010     0x000C  // Wangtek QIC3010 Model # 
#define CORE_QIC80          0x0021  // Core QIC80 Model # 
#define TEAC_VEND_NO        0x03c0  // TEAC vendor number 
#define TEAC_TR1            0x000e  // TEAC TR-1 Model 
#define TEAC_TR2            0x000f  // TEAC TR-2 Model 
#define GIGATEC_VEND_NO     0x0400
#define COMBYTE_VEND_NO     0x0440
#define PERTEC_VEND_NO      0x0480
#define PERTEC_TR1          0x0001  // TR-1 drive 
#define PERTEC_TR2          0x0002  // TR-2 drive 
#define PERTEC_TR3          0x0003  // TR-3 drive 

// Conner Native mode defines 

#define CONNER_500KB_XFER   0x0400  // 500 KB xfer rate 
#define CONNER_1MB_XFER     0x0800  // 1 MB xfer rate 
#define CONNER_20_TRACK     0x0001  // Drive supports 20 tracks 
#define CONNER_28_TRACK     0x000e  // Drive supports 28 tracks 
#define CONNER_40_TRACK     0x0020  // Drive supports 40 tracks 
#define CONNER_MODEL_5580   0x0002  // Conner Model 5580 series (Hornet) 
#define CONNER_MODEL_XKE    0x0004  // Conner 11250 series (1" drives) XKE 
#define CONNER_MODEL_XKEII  0x0008  // Conner 11250 series (1" drives) XKEII 


#define FDC_INVALID_CMD         0x80    // invalid cmd sent to FDC returns this value 
#define RTIMES                  3       // times to retry on a read of a sector (retry mode) 
#define NTIMES                  2       // times to retry on a read of a sector (normaly) 
#define WTIMES                  10      // times to retry on a write of a sector 
#define VTIMES                  0       // times to retry on verify 
#define ANTIMES                 0
#define ARTIMES                 6
#define DRIVE_SPEC_SAVE         2       // sizeof the drive spec save command 
#define INTEL_MASK              0xe0
#define INTEL_44_PIN_VERSION    0x40
#define INTEL_64_PIN_VERSION    0x00

#define FIND_RETRIES        2
#define REPORT_RPT          6       // Number of times to attempt drive communication when 
                                    //  an ESD induced error is suspected. 

//
//   Kurt changed the timeout count for program/read nec from 40 to 20000
//   This was done because the kdi_ShortTimer was removed from these routines
//   Microsoft's floppy driver does NOT use a timer and works,  so
//   this fix is being tested in M8 Windows 95 beta.  If it does not work,
//   then we probably need to change it back (see read/program NEC).

#define FDC_MSR_RETRIES     50  // Number of times to read the FDC Main 

#define DRIVEA              0
#define DRIVEB              1
#define DRIVEC              2
#define DRIVED              3
#define DRIVEU              4
#define DRIVEUB             5

#define DISABLE_PRECOMP     1       // Value used by the 82078's Drive Spec 
                                    // command to disable Precomp 

#define FDC_BOOT_MASK     0x06      // Mask used to isolate the Boot Select 
                                    // Bits in the TDR Register 

#define MAX_SEEK_COUNT_SKIP 10
#define MAX_SEEK_COUNT_TIME 10

#define WRITE_REF_RPT       2

#define _DISK_RESET         0

#define WRITE_PROTECT_MASK  0x20    // bit from byte from port 2 of the jumbo B
                                    // processor that indicates write protect 

// Constants for sense_speed algorithm 
// These ranges are based on 1.5 sec @ 250kb.  The units are 54.95ms (1 IBM PC 
// timer tick (18.2 times a second)) and are +-1 tick from nominal due to time 
// base fluctuation (in FDC and IBM PC TIMER). 
// The threshold for the 750kb transfer rate is < 11 ticks due to the 
// uncertaSWordy of this future transfer rate. 
// If a transfer rate of 750kb is needed code MUST be added to verify that 
// 750kb does exist 

#define sect_cnt            35      // .04285 sec. per sector * 35 = 1.4997 sec. 
#define MIN1000             0
#define MAX1000             11
#define MIN500              12
#define MAX500              15
#define MIN250              26
#define MAX250              29

// Array indices and size for the time_out array. The time out array contains the  * 
// time outs for the QIC-117 commands. 
#define L_SLOW          0
#define L_FAST          1
#define PHYSICAL        2
#define TIME_OUT_SIZE   3

// Constants for the arrays defined in the S_O_DGetInfo structure 
#define OEM_LENGTH              20
#define SERIAL_NUM_LENGTH       4
#define MAN_DATE_LENGTH         2
#define PEGASUS_START_DATE      517
#define PLACE_OF_ORIGIN_LENGTH  2

// Constant for the array dimension used in q117i_HighSpeedSeek 
#define  FOUR_NIBS  4

// Constants for identifing bytes in a word array 
#define LOW_BYTE    0
#define HI_BYTE     1

#define DCOMFIRM_MAX_BYTES          10  // Max number of SBytes in a DComFirm string 
#define FDC_ISR_RESET_THRESHOLD     20

#define SINGLE_BYTE     (UCHAR)0x01     
#define REPORT_BYTE     (UCHAR)0x08     // Number of Bits to receive from the tape  
#define REPORT_WORD     (UCHAR)0x10     // drive during communication.                  
#define DATA_BIT        (USHORT)0x8000  // data bit to or into the receive word 
#define SINGLE_SHIFT    (USHORT)0x0001  // number of bits to shift the receive data when adding a bit 
#define NIBBLE_SHIFT    (USHORT)0x0004  // number of bits to shift the receive data when adding a bit 
#define BYTE_SHIFT      (USHORT)0x0008  // number of bits to shift the receive data when size is byte 
#define NIBBLE_MASK     (USHORT)0x000f
#define BYTE_MASK       (USHORT)0x00ff  // byte mask 
#define SEGMENT_MASK    0x1f


// Various addresses used as arguments in the set ram command for the Sankyo 
// motor fix hack 
#define DOUBLE_HOLE_CNTR_ADDRESS    0x5d
#define HOLE_FLAG_BYTE_ADDRESS      0x48
#define TAPE_ZONE_ADDRESS           0x68

// Miscellaneous defines used in the Sankyo Motor fix hack 
#define REVERSE                 0
#define FORWARD                 1
#define HOLE_INDICATOR_MASK     0X40
#define EOT_ZONE_COUNTER        0x29
#define BOT_ZONE_COUNTER        0x23

#define FDC_TDR_MASK        0x03        // mask for 82077aa tdr test 
#define FDC_REPEAT          0x04        // number of times to loop through the tdr test 
#define CMD_OFFSET          (UCHAR)0x02
#define MAX_FMT_NIBBLES     3
#define MAX_FDC_STATUS      16
#define CLOCK_48            (UCHAR)0x80

// Toggle parameter command arguements 
#define WRITE_EQ                    0
#define AUTO_FILTER_PROG            1
#define AGC_ENABLE                  2
#define DISABLE_FIND_BOT            3
#define WRITE_DATA_DELAY_ENABLE     4
#define REF_HEAD_ON_AUTOLOAD        5
#define DRIVE_CLASS                 6
#define CUE_INDEX_PULSE_SHUTOFF     7
#define CMS_MODE                    8

#define SEG_LENGTH_80W          (ULONG)246  // unit in inches * 10 
#define SEG_LENGTH_3010         (ULONG)165  // unit in inches * 10 
#define SEG_LENGTH_3020         (ULONG)84   // unit in inches * 10 
#define SPEED_SLOW_30n0         (ULONG)226
#define SPEED_FAST_30n0         (ULONG)452
#define SPEED_PHYSICAL_30n0     (ULONG)900
#define SPEED_TOLERANCE         (ULONG)138
#define SPEED_FACTOR            (ULONG)100
#define SPEED_ROUNDING_FACTOR   (ULONG)50


// Perpendicular mode setup values 

#define PERP_OVERWRITE_ON   (UCHAR)0x80
#define PERP_WGATE_ON       (UCHAR)0x01
#define PERP_GAP_ON         (UCHAR)0x02
#define PERP_SELECT_SHIFT   (UCHAR)0x02

// Misc format defines 

#define HDR_1               (USHORT)0
#define HDR_2               (USHORT)1
#define MAX_HDR_BLOCKS      (USHORT)2
#define CQD_DMA_PAGE_SIZE   (ULONG)0x00000800

// Select Format defines, from QIC117 spec, command 27 

#define SELECT_FORMAT_80            (UCHAR)0x09
#define SELECT_FORMAT_80W           (UCHAR)0x0b
#define SELECT_FORMAT_3010          (UCHAR)0x11
#define SELECT_FORMAT_3010W         (UCHAR)0x13
#define SELECT_FORMAT_3020          (UCHAR)0x0d
#define SELECT_FORMAT_3020W         (UCHAR)0x0f
#define SELECT_FORMAT_UNSUPPORTED   (UCHAR)0x00


// Issue Diagnostic defines 
#define DIAG_WAIT_CMD_COMPLETE      (UCHAR)0xff
#define DIAG_WAIT_INTERVAL          (UCHAR)0xfe
#define DIAG_NO_PAUSE_RECEIVE       (UCHAR)0xfd

/****************************************************************************
*
* FILE: CQD_STRC.H
*
* PURPOSE: This file contains all of the structures
*                   required by the common driver.
*
*****************************************************************************/

#pragma pack(1)

typedef struct _TAPE_FORMAT_LENGTH {
    UCHAR format;           // Format of the tape 
    UCHAR length;           // Length of the tape 
} TAPE_FORMAT_LENGTH, *PTAPE_FORMAT_LENGTH;


//                                                                                                          
//   Commands to the Floppy Controller.  FDC commands and the corresponding         
//    driver structures are listed below.                                                   
//                                                                                                          
//         FDC Command                     Command Struct      Response Struct  
//         -----------                     --------------      ---------------  
//         Read Data                       rdv_command         stat                     
//         Read Deleted Data               N/A                 N/A                  
//         Write Data                      rdv_command         stat                     
//         Write Deleted Data              rdv_command         stat                     
//         Read a Track                    N/A                 N/A                  
//         Verify (82077)                  N/A                 N/A                  
//         Version (82077)                 version_cmd         N/A                  
//         Read ID                         read_id_cmd         stat                     
//         Format a Track                  format_cmd          stat                     
//         Scan Equal (765)                N/A                 N/A                  
//         Scan Low or Equal (765)         N/A                 N/A                  
//         Scan High or Equal (765)        N/A                 N/A                  
//         Recalibrate                     N/A                 N/A                  
//         Sense Interrupt Status          sns_SWord_cmd       fdc_result           
//         Specify                         specify_cmd         N/A                  
//         Sense Drive Status              sns_stat_cmd        stat                     
//         Seek                            seek_cmd            N/A                  
//         Configure (82077)               config_cmd          N/A                  
//         Relative Seek (82077)           N/A                 N/A                  
//         Dump Registers (82077)          N/A                 N/A                  
//         Perpendicular Mode (82077)      N/A                 N/A                  
//         Invalid                         invalid_cmd         N/A                  
//                                                                                                          

typedef struct _FDC_CMD_READ_DATA {
    UCHAR   command;            // command UCHAR 
    UCHAR   drive;              // drive specifier 
    UCHAR   C;                  // cylinder number 
    UCHAR   H;                  // head address 
    UCHAR   R;                  // record (sector number) 
    UCHAR   N;                  // number of UCHARs per sector 
    UCHAR   EOT;                // end of track 
    UCHAR   GPL;                // gap length 
    UCHAR   DTL;                // data length 
} FDC_CMD_READ_DATA, *PFDC_CMD_READ_DATA;

typedef struct  _FDC_CMD_READ_ID {   
    UCHAR command;              // command byte 
    UCHAR drive;                // drive specifier 
} FDC_CMD_READ_ID, *PFDC_CMD_READ_ID;

typedef struct _FDC_CMD_FORMAT {
    UCHAR command;              // command byte 
    UCHAR drive;                // drive specifier 
    UCHAR N;                    // number of bytes per sector 
    UCHAR SC;                   // sectors per track (segment) 
    UCHAR GPL;                  // gap length 
    UCHAR D;                    // format filler byte 
} FDC_CMD_FORMAT, *PFDC_CMD_FORMAT;

typedef struct _FDC_CMD_SENSE_INTERRUPT_STATUS {
    UCHAR command;              // command byte 
} FDC_CMD_SENSE_INTERRUPT_STATUS, *PFDC_CMD_SENSE_INTERRUPT_STATUS;

typedef struct _FDC_CMD_VERSION {
    UCHAR command;              // command byte 
} FDC_CMD_VERSION, *PFDC_CMD_VERSION;

typedef struct _FDC_CMD_SPECIFY {
    UCHAR command;              // command byte 
    UCHAR SRT_HUT;              // step rate time (bits 7-4) 
                                // head unload time bits (3-0) 
    UCHAR HLT_ND;               // head load time (bits 7-1) 
                                // non-DMA mode flag (bit 0) 
} FDC_CMD_SPECIFY, *PFDC_CMD_SPECIFY;

typedef struct _FDC_CMD_SENSE_DRIVE_STATUS {
    UCHAR command;              // command byte 
    UCHAR drive;                // drive specifier 
} FDC_CMD_SENSE_DRIVE_STATUS, *PFDC_CMD_SENSE_DRIVE_STATUS;

typedef struct _FDC_CMD_RECALIBRATE {
    UCHAR command;              // command byte 
    UCHAR drive;                // drive specifier 
} FDC_CMD_RECALIBRATE, *PFDC_CMD_RECALIBRATE;               
                                
typedef struct _FDC_CMD_SEEK {     
    UCHAR cmd;                  // command byte 
    UCHAR drive;                // drive specifier 
    UCHAR NCN;                  // new cylinder number 
} FDC_CMD_SEEK, *PFDC_CMD_SEEK;

typedef struct _FDC_CMD_CONFIGURE {
    UCHAR cmd;                  // command byte 
    UCHAR czero;                // null byte 
    UCHAR config;               // FDC configuration info  (EIS EFIFO POLL FIFOTHR) 
    UCHAR pretrack;             // Pre-compensation start track number 
} FDC_CMD_CONFIGURE, *PFDC_CMD_CONFIGURE;

typedef struct _FDC_CMD_INVALID {
    UCHAR command;              // command byte 
} FDC_CMD_INVALID, *PFDC_CMD_INVALID;

typedef struct _FDC_STATUS {
    UCHAR ST0;                  // status register 0 
    UCHAR ST1;                  // status register 1 
    UCHAR ST2;                  // status register 2 
    UCHAR C;                    // cylinder number 
    UCHAR H;                    // head address 
    UCHAR R;                    // record (sector number) 
    UCHAR N;                    // number of bytes per sector 
} FDC_STATUS, *PFDC_STATUS;     
                                
typedef struct _FDC_RESULT {    
    UCHAR ST0;                  // status register 0 
    UCHAR PCN;                  // present cylinder number 
} FDC_RESULT, *PFDC_RESULT;

typedef struct _FDC_CMD_PERPENDICULAR_MODE {
    UCHAR command;
    UCHAR perp_setup;
} FDC_CMD_PERPENDICULAR_MODE, *PFDC_CMD_PERPENDICULAR_MODE;

// This command is only valid on the 82078 64 pin Enhanced controller 

typedef struct _FDC_CMD_DRIVE_SPECIFICATION {
    UCHAR command;
    UCHAR drive_spec;
    UCHAR done;
} FDC_CMD_DRIVE_SPECIFICATION, *PFDC_CMD_DRIVE_SPECIFICATION;

typedef struct _FDC_CMD_SAVE {
    UCHAR command;
} FDC_CMD_SAVE, *PFDC_CMD_SAVE;

typedef struct _FDC_SAVE_RESULT {
    UCHAR clk48;
    UCHAR reserved2;
    UCHAR reserved3;
    UCHAR reserved4;
    UCHAR reserved5;
    UCHAR reserved6;
    UCHAR reserved7;
    UCHAR reserved8;
    UCHAR reserved9;
    UCHAR reserved10;
    UCHAR reserved11;
    UCHAR reserved12;
    UCHAR reserved13;
    UCHAR reserved14;
    UCHAR reserved15;
    UCHAR reserved16;
} FDC_SAVE_RESULT, *PFDC_SAVE_RESULT;

//   FDC Sector Header Data used for formatting 

typedef union U_FormatHeader {
    struct {
        UCHAR C;                // cylinder number 
        UCHAR H;                // head address 
        UCHAR R;                // record (sector number) 
        UCHAR N;                // bytes per sector 
    } hdr_struct;
    ULONG hdr_all;
} FormatHeader, *FormatHeaderPtr;

#pragma pack()

//   Tape Drive Parameters 


typedef struct S_DriveParameters {
    UCHAR   seek_mode;                 // seek mode supported by the drive 
    CHAR    mode;                      // drive mode (Primary, Format, Verify) 
    USHORT  conner_native_mode;        // Conner Native Mode Data 
} DriveParameters, *DriveParametersPtr;


//   Tape Parameters 


typedef struct S_FloppyTapeParameters {
    USHORT              fsect_seg;      //  floppy sectors per segment 
    USHORT              seg_ftrack;     //  segments per floppy track 
    USHORT              fsect_ftrack;   //  floppy sectors per floppy track 
    USHORT              rw_gap_length;  //  write gap length 
    USHORT              ftrack_fside;   //  floppy tracks per floppy side 
    ULONG               fsect_fside;    //  floppy sectors per floppy side 
    ULONG               log_sectors;    //  number of logical sectors on a tape 
    ULONG               fsect_ttrack;   //  floppy sectors per tape track 
    UCHAR               tape_rates;     //  supported tape transfer rates 
    UCHAR               tape_type;      //  tape type 
    TAPE_FORMAT_LENGTH  tape_status;
    ULONG               time_out[3];    //  time_out for the QIC-117 commands 
                                        //  time_out[0] = logical_slow, time_out[1] = logical_fast, 
                                        //  time[2] = physical. 
} FloppyTapeParameters, *FloppyTapeParametersPtr;


//   Transfer Rate Parameters 

typedef struct S_TransferRate {
    UCHAR   tape;               // Program tape drive slow (250 or 500 Kbps) 
    UCHAR   fdc;                // Program FDC slow (250 or 500 Kbps) 
    UCHAR   srt;                // FDC step rate for slow xfer rate 
} TransferRate, *TransferRatePtr;

struct S_FormatParameters {
    UCHAR   cylinder;           // floppy cylinder number 
    UCHAR   head;               // floppy head number 
    UCHAR   sector;             // floppy sector number 
    UCHAR   NCN;                // new cylinder number 
    ULONG   *hdr_ptr[2];        // pointer to sector id data for format 
    ULONG   hdr_offset[2];      // offset of header_ptr 
    ULONG   *phy_ptr;           // pointer to physical sector id data for format 
    USHORT  current_hdr;        // current format hdr 
    USHORT  next_hdr;           // next format hdr 
    NTSTATUS retval;             // Format status 
};

typedef struct S_FormatParameters FormatParameters;



// Floppy register structure.  The base address of the controller is 
// passed in by configuration management.  Note that this is the 82077 
// structure, which is a superset of the PD765 structure.  Not all of 
// the registers are used. 

typedef struct S_FDCAddress {
    ULONG   dcr;
    ULONG   dr;
    ULONG   msr;
    ULONG   dsr;
    ULONG   tdr;
    ULONG   dor;
    ULONG   r_dor;
    BOOLEAN dual_port;
} FDCAddress, *FDCAddressPtr;


typedef struct S_FDControllerData {
    FDCAddress      fdc_addr;
    FDC_CMD_FORMAT  fmt_cmd;
    FDC_STATUS      fdc_stat;
    USHORT          isr_reentered;
    BOOLEAN         command_has_result_phase;
    UCHAR           number_of_tape_drives;
    UCHAR           fdc_pcn;
    UCHAR           fifo_byte;
    BOOLEAN         perpendicular_mode;
    BOOLEAN         start_format_mode;
    BOOLEAN         end_format_mode;
} FDControllerData, *FDControllerDataPtr;

typedef struct S_TapeOperationStatus {
    ULONG       bytes_transferred_so_far;
    ULONG       total_bytes_of_transfer;
    ULONG       cur_lst;
    USHORT      data_amount;
    USHORT      s_count;
    USHORT      no_data;
    USHORT      d_amt;
    USHORT      retry_count;
    USHORT      retry_times;
    ULONG       d_segment;        // desired tape segment, (floppy track) 
    USHORT      d_track;          // desired physical tape track 
    UCHAR       d_ftk;
    UCHAR       d_sect;
    UCHAR       d_head;
    UCHAR       retry_sector_id;
    UCHAR       seek_flag;
    UCHAR       s_sect;
    BOOLEAN     log_fwd;          // indicates that the tape is going logical forward 
    BOOLEAN     bot;
    BOOLEAN     eot;
} TapeOperationStatus, *TapeOperationStatusPtr;


typedef struct S_CqdContext {
    DeviceCfg               device_cfg;
    DeviceDescriptor        device_descriptor;
    OperationStatus         operation_status;
    DriveParameters         drive_parms;
    TransferRate            xfer_rate;
    FloppyTapeParameters    floppy_tape_parms;
    CQDTapeCfg              tape_cfg;
    TapeOperationStatus     rd_wr_op;
    FormatParameters        fmt_op;
    FDControllerData        controller_data;
    PVOID                   kdi_context;
    USHORT                  retry_seq_num;
    UCHAR                   firmware_cmd;
    UCHAR                   firmware_error;
    UCHAR                   firmware_version;
    UCHAR                   drive_type;
    UCHAR                   device_unit;
    UCHAR                   drive_on_value;
    UCHAR                   deselect_cmd;
    UCHAR                   drv_stat;
    ULONG                   media_change_count;
    BOOLEAN                 configured;
    BOOLEAN                 selected;
    BOOLEAN                 cmd_selected;
    BOOLEAN                 no_pause;
    BOOLEAN                 cms_mode;
    BOOLEAN                 persistent_new_cart;
    BOOLEAN                 pegasus_supported;
    BOOLEAN                 trakker;
#if DBG
#define DBG_SIZE  (1024*4)
    ULONG                   dbg_command[DBG_SIZE];
    ULONG                   dbg_head;
    ULONG                   dbg_tail;
    BOOLEAN dbg_lockout;
#endif

} CqdContext, *CqdContextPtr;

#if DBG
#define DBG_ADD_ENTRY(dbg_level, dbg_context, data) \
        if (((dbg_level) & kdi_debug_level) != 0 &&  \
        (((kdi_debug_level & QIC117BYPASSLOCKOUT) == 0) || (dbg_context)->dbg_lockout == 0)) {\
            (dbg_context)->dbg_command[(dbg_context)->dbg_tail] = (data); \
            (dbg_context)->dbg_tail = ((dbg_context)->dbg_tail + 1) % DBG_SIZE; \
        }
#else
#define DBG_ADD_ENTRY(dbg_level, dbg_context, data)
#endif

/*****************************************************************************
*
* FILE: CQD_HDRI.H
*
* PURPOSE: This file contains all of the headers for the common driver.
*
*****************************************************************************/

/* CQD Function Templates: **************************************************/

NTSTATUS 
cqd_CmdReportStatus(
    IN CqdContextPtr cqd_context,
    IN DeviceOpPtr dev_op_ptr
    );

NTSTATUS 
cqd_CmdRetension(
    IN CqdContextPtr cqd_context,
    OUT PULONG segments_per_track
    );

NTSTATUS 
cqd_CmdSetSpeed(
    IN CqdContextPtr cqd_context,
    IN UCHAR tape_speed
    );

NTSTATUS 
cqd_CmdReportDeviceCfg(
    IN CqdContextPtr cqd_context,
    IN DriveCfgDataPtr drv_cfg
    );

NTSTATUS 
cqd_CmdUnloadTape(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_DeselectDevice(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_Seek(
    IN CqdContextPtr cqd_context
    );

VOID 
cqd_CmdDeselectDevice(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN drive_selected
    );

NTSTATUS 
cqd_GetFDCType(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_ConfigureDevice(
    IN CqdContextPtr cqd_context
    );

VOID 
cqd_GetRetryCounts(
    IN CqdContextPtr cqd_context,
    IN USHORT command
    );

NTSTATUS 
cqd_NextTry(
    IN CqdContextPtr cqd_context,
    IN USHORT command
    );

NTSTATUS 
cqd_CmdFormat(
    IN CqdContextPtr cqd_context,
    IN FormatRequestPtr fmt_request
    );  

NTSTATUS 
cqd_GetDeviceInfo(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN report_failed,
    IN USHORT vendor_id
    );

NTSTATUS 
cqd_DoReadID(
    IN CqdContextPtr cqd_context,
    IN ULONG read_id_delay,
    IN PFDC_STATUS read_id_status
    );

NTSTATUS 
cqd_GetDeviceError(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_GetDeviceType(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN vendor_detected
    );

NTSTATUS 
cqd_FormatTrack(
    IN CqdContextPtr cqd_context,
    IN USHORT track
    );

NTSTATUS 
cqd_CmdReportDeviceInfo(
    IN CqdContextPtr cqd_context,
    IN DeviceInfoPtr device_info
    );

NTSTATUS 
cqd_LookForDevice(
    IN CqdContextPtr cqd_context,
    IN UCHAR drive_selector,
    IN BOOLEAN *vendor_detected,
    IN BOOLEAN *found
    );

NTSTATUS 
cqd_ChangeTrack(
    IN CqdContextPtr cqd_context,
    IN USHORT destination_track
    );

NTSTATUS 
cqd_LogicalBOT(
    IN CqdContextPtr cqd_context,
    IN USHORT destination_track
    );

NTSTATUS 
cqd_ConnerPreamble(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN select
    );

NTSTATUS 
cqd_RWTimeout(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request,
       OUT NTSTATUS *drv_status
    );

NTSTATUS 
cqd_HighSpeedSeek(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_GetStatus(
    IN CqdContextPtr cqd_context,
    OUT PUCHAR status_register_3
    );

NTSTATUS 
cqd_CmdReadWrite(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request
    );

NTSTATUS 
cqd_ReadIDRepeat(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_CmdLoadTape(
    IN CqdContextPtr cqd_context,
    IN LoadTapePtr load_tape_ptr
    );

VOID 
cqd_NextGoodSectors(
    IN CqdContextPtr cqd_context
    );

NTSTATUS
cqd_PauseTape(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_CmdSelectDevice(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SendPhantomSelect(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_RWNormal(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request,
       OUT NTSTATUS *drv_status
    );

NTSTATUS 
cqd_ReadFDC(
    IN CqdContextPtr cqd_context,
    OUT UCHAR *drv_status,
    OUT USHORT length
    );

NTSTATUS 
cqd_SetDeviceMode(
    IN CqdContextPtr cqd_context,
    IN UCHAR mode
    );

NTSTATUS 
cqd_ProgramFDC(
    IN CqdContextPtr cqd_context,
    IN PUCHAR command,
    IN USHORT length,
    IN BOOLEAN result
    );

NTSTATUS 
cqd_IssueFDCCommand(
    IN CqdContextPtr cqd_context,
    IN PUCHAR FifoIn,
    IN PUCHAR FifoOut,
    IN PVOID  IoHandle,
    IN ULONG  IoOffset,
    IN ULONG  TransferBytes,
    IN ULONG  TimeOut
    );

NTSTATUS 
cqd_ReadWrtProtect(
    IN CqdContextPtr cqd_context,
    OUT PBOOLEAN write_protect
    );

NTSTATUS 
cqd_ReceiveByte(
    IN CqdContextPtr cqd_context,
    IN USHORT receive_length,
    OUT PUSHORT receive_data
    );

NTSTATUS 
cqd_SendByte(
    IN CqdContextPtr cqd_context,
    IN UCHAR command
    );

NTSTATUS 
cqd_DispatchFRB(
    IN     CqdContextPtr cqd_context,
    IN OUT ADIRequestHdrPtr frb
    );

NTSTATUS 
cqd_Report(
    IN     CqdContextPtr cqd_context,
    IN     UCHAR command,
    IN     PUSHORT report_data,
    IN     USHORT report_size,
    IN OUT PBOOLEAN esd_retry
    );

NTSTATUS 
cqd_RetryCode(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request,
       OUT PFDC_STATUS fdc_status,
       OUT PNTSTATUS op_status
    );

NTSTATUS 
cqd_SetBack(
    IN CqdContextPtr cqd_context,
    IN USHORT command
    );

NTSTATUS 
cqd_SenseSpeed(
    IN CqdContextPtr cqd_context,
    IN UCHAR        dma
    );

NTSTATUS 
cqd_WaitSeek(
    IN CqdContextPtr cqd_context,
    IN ULONG seek_delay
    );

NTSTATUS 
cqd_StartTape(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_StopTape(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_WaitActive(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_WaitCommandComplete(
    IN CqdContextPtr cqd_context,
    IN ULONG wait_time,
    IN BOOLEAN non_interruptible
    );

NTSTATUS 
cqd_WriteReferenceBurst(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_CalcPosition(
    IN CqdContextPtr cqd_context,
    IN ULONG block,
    IN ULONG number
    );

NTSTATUS 
cqd_DCROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR speed
    );

NTSTATUS 
cqd_DSROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR precomp
    );

NTSTATUS 
cqd_TDROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR tape_mode
    );

VOID 
cqd_ResetFDC(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_ClearTapeError(
    IN CqdContextPtr cqd_context
    );

VOID 
cqd_CalcFmtSegmentsAndTracks(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_GetTapeParameters(
    IN CqdContextPtr cqd_context,
    IN ULONG segments_per_track
    );

NTSTATUS 
cqd_ConfigureFDC(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SetRamPtr(
    IN CqdContextPtr cqd_context,
    IN UCHAR ram_addr
    );

NTSTATUS 
cqd_CmdIssueDiagnostic(
    IN     CqdContextPtr cqd_context,
    IN OUT PUCHAR command_string
    );

VOID 
cqd_InitDeviceDescriptor(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_CmdSetTapeParms(
    IN CqdContextPtr cqd_context,
    IN ULONG segments_per_track,
    IN TapeLengthPtr tape_length_ptr
    );

NTSTATUS 
cqd_PrepareTape(
    IN CqdContextPtr cqd_context,
    OUT FormatRequestPtr fmt_request
    );

VOID 
cqd_InitializeRate(
    IN CqdContextPtr cqd_context,
    IN UCHAR   tape_xfer_rate
    );

NTSTATUS 
cqd_GetTapeFormatInfo(
    IN CqdContextPtr cqd_context,
    IN FormatRequestPtr fmt_request,
    OUT PULONG segments_per_track
    );

NTSTATUS 
cqd_SetRam(
    IN CqdContextPtr cqd_context,
    IN UCHAR ram_data
    );

NTSTATUS 
cqd_CMSSetupTrack(
    IN CqdContextPtr cqd_context,
    OUT PBOOLEAN new_track
    );

NTSTATUS 
cqd_ReportCMSVendorInfo(
    IN CqdContextPtr cqd_context,
    IN USHORT vendor_id
    );

NTSTATUS 
cqd_ReportConnerVendorInfo(
    IN CqdContextPtr cqd_context,
    IN USHORT vendor_id
    );

NTSTATUS 
cqd_ReportSummitVendorInfo(
    IN CqdContextPtr cqd_context,
    IN USHORT vendor_id
    );

NTSTATUS 
cqd_ToggleParams(
    IN CqdContextPtr cqd_context,
    IN UCHAR parameter
    );


NTSTATUS 
cqd_EnablePerpendicularMode(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN enable_perp_mode
    );

BOOLEAN 
cqd_AtLogicalBOT(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_DoFormat(
   IN CqdContextPtr cqd_context
    );

VOID 
cqd_BuildFormatHdr(
    IN CqdContextPtr cqd_context,
    IN USHORT header
    );

NTSTATUS 
cqd_VerifyMapBad(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request
    );

NTSTATUS 
cqd_CheckMediaCompatibility(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SetFWTapeSegments(
    IN CqdContextPtr cqd_context,
    IN ULONG segments_per_track
    );

VOID 
cqd_SetTempFDCRate(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SelectFormat(
    IN CqdContextPtr cqd_context
    );

VOID 
cqd_SetXferRates(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SetFormatSegments(
    IN CqdContextPtr cqd_context,
    IN ULONG       segments_per_track
    );

NTSTATUS 
cqd_PrepareIomega3010PhysRev(
    IN CqdContextPtr cqd_context
    );

/*++

Copyright (c) 1993 - Colorado Memory Systems, Inc.
All Rights Reserved

Module Name:

   common.h

Abstract:

   Data structures shared by drivers q117 and q117i

Revision History:

--*/


#if DBG
//
// For checked kernels, define a macro to print out informational
// messages.
//
// QIC117Debug is normally 0.  At compile-time or at run-time, it can be
// set to some bit patter for increasingly detailed messages.
//
// Big, nasty errors are noted with DBGP.  Errors that might be
// recoverable are handled by the WARN bit.  More information on
// unusual but possibly normal happenings are handled by the INFO bit.
// And finally, boring details such as routines entered and register
// dumps are handled by the SHOW bit.
//

// Lower level driver defines (do not change)  These mirror kdi_pub.h.

#define QIC117DBGP              0x00000001     // Display error information

#define QIC117WARN              0x00000002     // Displays seek warings (from low level driver)

#define QIC117INFO              0x00000004      // Display extra info (brief)

#define QIC117SHOWTD            0x00000008     // Display KDI tape commands (verbose)

#define QIC117SHOWMCMDS         0x00000010     // does nothing unless QIC117DBGARRAY is on
                                               // shows drive commands,  and FDC information
                                               // This is VERY VERBOSE and will affect system
                                               // performance

#define QIC117SHOWPOLL          0x00000020     // unused

#define QIC117STOP              0x00000080     // only one info message (not very useful)

#define QIC117MAKEBAD           0x00000100     // Creates (simulated) bad sectors to test bad
                                               // sector re-mapping code

#define QIC117SHOWBAD           0x00000200     // unused

#define QIC117DRVSTAT           0x00000400      // Show drive status (verbose)

#define QIC117SHOWINT           0x00000800     // unused

#define QIC117DBGSEEK           0x00001000     // (does nothing unless QIC117DBGARRAY is on)
                                               // Shows drive seek information (verbose)

#define QIC117DBGARRAY          0x00002000     // Shows async messages (does nothing unless
                                               // QIC117DBGSEEK and/or QIC117SHOWMCMDS is set)
                                               // Displays VERBOSE FDC command information if
                                               // QIC117SHOWMCMDS is set.
#define QIC117BYPASSLOCKOUT     0x00004000

// Upper level driver defines (only used in upper level driver)

#define QIC117SHOWAPI           ((ULONG)0x00010000)     // Shows Tape API commands

#define QIC117SHOWAPIPOLL       ((ULONG)0x00020000)     // Shows Tape API commands used in NTBACKUP polling
                                                        // These are not displayed with QIC117SHOWAPI

#define QIC117SHOWKDI           ((ULONG)0x00040000)     // Shows request to KDI (VERBOSE)

#define QIC117SHOWBSM           ((ULONG)0x00080000)     // Display bad sector information (brief)

#define Q117DebugLevel kdi_debug_level

extern unsigned long kdi_debug_level;

#define CheckedDump(LEVEL,STRING) \
            if (kdi_debug_level & LEVEL) { \
               DbgPrint STRING; \
            }
#else
#define CheckedDump(LEVEL,STRING)
#endif


#define BUFFER_SPLIT

typedef unsigned char UBYTE;
typedef unsigned short UWORD;
typedef unsigned short SEGMENT;
typedef unsigned long BLOCK;

#ifndef TRUE
#define TRUE 1
#endif

#ifndef NULL
#define NULL 0
#endif

#ifndef FALSE
#define FALSE 0
#endif

#define MAXLINE 100

//
// The following parameters are used to indicate the tape format code
//


#define MAX_PASSWORD_SIZE   8           // max volume password size
#define QIC_END             0xffea6dff  // 12-31-2097, 23:59:59 in qictime


//
// Tape Constants
//
#define UNIX_MAXBFS     4               // max. data buffers supported in the UNIX kernel

#define MAGIC           0x636d  // "cm"

#define DRIVER_COMMAND USHORT

//
// Prototypes for common functions
//

VOID
q117LogError(
   IN PDEVICE_OBJECT DeviceObject,
   IN ULONG SequenceNumber,
   IN UCHAR MajorFunctionCode,
   IN UCHAR RetryCount,
   IN ULONG UniqueErrorValue,
   IN NTSTATUS FinalStatus,
   IN NTSTATUS SpecificIOStatus
   );

NTSTATUS q117MapStatus(
    IN NTSTATUS Status
    );

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'h71q')
#endif

/*++

Module Name:

    q117.h

Abstract:

    Data structures used only by q117 driver.  Contains QIC-40 structures
    and Context for q117.

Revision History:

--*/

//
//  For NTBACKUP to work,  an early warning is required to allow the
//  application to perform tape linking.  To achive this,  a 5 segment
//  region at the end of the tape is RESERVED to genterate early warning
//  status.  This value is used in q117WriteTape for this purpose.
//
#define SEGMENTS_OF_EARLY_WARNING   5


#define FORMAT_BYTE             0x6b

#define MAX_BAD_BLOCKS          ((1024*27)/sizeof(ULONG))
#define LIST_ENTRY_SIZE         3
#define MAX_BAD_LIST            (((1024*27)/LIST_ENTRY_SIZE) - 1)

#define MAX_TITLE_SIZE          44      // max volume title entry size in far memory array
#define MAX_PASSWORD_SIZE       8       // max volume password size

#define MAX_QIC40_FILENAME      13
#define MAX_HEADER_SIZE         256     // maximum QIC-40 header size
#define DATA_HEADER_SIG_SIZE    4       // data header signature size

#define ECC_BLOCKS_PER_SEGMENT  3       // number of correction sectors ber block
#define BLOCKS_PER_SEGMENT      32      // Number of sectors per block on the tape.
                                        // number of data sectors per block

#define DATA_BLOCKS_PER_SEGMENT (BLOCKS_PER_SEGMENT - ECC_BLOCKS_PER_SEGMENT)

#define BYTES_PER_SECTOR    1024
#define BYTES_PER_SEGMENT   (BYTES_PER_SECTOR*BLOCKS_PER_SEGMENT)

#define TapeHeaderSig       0xaa55aa55l
#define VolumeTableSig      (((ULONG)'L'<<24) + ((ULONG)'B'<<16) + ('T'<<8) + 'V')
#define FileHeaderSig       0x33cc33ccl

#define QIC40_VENDOR_UNIQUE_SIZE        106


#define VENDOR_TYPE_NONE    0
#define VENDOR_TYPE_CMS     1

#define MOUNTAIN_SEMISPECED_SPACE       9

#define VU_SIGNATURE_SIZE           4
#define VU_TAPE_NAME_SIZE           11

#define VU_SEGS_PER_TRACK           68
#define VU_SEGS_PER_TRACK_XL        102
#define VU_80SEGS_PER_TRACK         100
#define VU_80SEGS_PER_TRACK_XL      150

#define VU_MAX_FLOPPY_TRACK         169
#define VU_MAX_FLOPPY_TRACK_XL      254
#define VU_80MAX_FLOPPY_TRACK       149
#define VU_80MAX_FLOPPY_TRACK_XL    149

#define VU_TRACKS_PER_CART          20
#define VU_80TRACKS_PER_CART        28

#define VU_MAX_FLOPPY_SIDE          1
#define VU_80MAX_FLOPPY_SIDE        4
#define VU_80MAX_FLOPPY_SIDE_XL     6

#define VU_MAX_FLOPPY_SECT          128

#define NEW_SPEC_TAPE_NAME_SIZE     44

#define FILE_VENDOR_SPECIFIC        0
#define FILE_UNIX_SPECIFIC          1
#define FILE_DATA_BAD               2

#define OP_MS_DOS           0
#define OP_UNIX             1
#define OP_UNIX_PUBLIC      2
#define OP_OS_2             3
#define OP_WINDOWS_NT       4

// Valid values for compression code
#define COMP_STAC 0x01
#define COMP_VEND 0x3f

//
// The following section specifies QIC-40 data structures.
// These structures are aligned on byte boundaries.
//

typedef struct _SEGMENT_BUFFER {
    PVOID logical;
    PHYSICAL_ADDRESS physical;
} SEGMENT_BUFFER, *PSEGMENT_BUFFER;

typedef struct _IO_REQUEST {
    union {
        ADIRequestHdr adi_hdr;

        /* Device Configuration FRB */
        struct S_DriveCfgData ioDriveCfgData;

        /* Generic Device operation FRB */
        struct S_DeviceOp ioDeviceOp;

        /* New Tape configuration FRB */
        struct S_LoadTape ioLoadTape;

        /* Tape length configuration FRB */
        struct S_TapeParms ioTapeLength;

        /* Device I/O FRB */
        struct S_DeviceIO ioDeviceIO;

        /* Format request FRB */
        struct S_FormatRequest ioFormatRequest;

        /* Direct firmware communication FRB */
        struct S_DComFirm ioDComFirm;

        /* Direct firmware communication FRB */
        struct S_TapeParms ioTapeParms;

        /* device info FRB (CMD_REPORT_DEVICE_INFO) */
        struct S_ReportDeviceInfo ioDeviceInfo;
    } x;

    KEVENT DoneEvent;               // Event that IoCompleteReqeust will set
    IO_STATUS_BLOCK IoStatus;       // Status of request
    PSEGMENT_BUFFER BufferInfo;     // Buffer information
    struct _IO_REQUEST *Next;



} *PIO_REQUEST, IO_REQUEST;

#pragma pack(1)

struct _FAIL_DATE {
    UWORD   Year:7;                     // year +1970 (1970-2097)
    UWORD   Month:4;                        // month (1-12)
    UWORD   Day:5;                      // day (1-31)
};


struct _CMS_VENDOR_UNIQUE {
    UBYTE   type;                           // 0 = none; 1 = CMS
    CHAR    signature[VU_SIGNATURE_SIZE];   // "CMS" , ASCIIZ string
    ULONG   creation_time;                  // QIC40/QIC113 date/time format
    CHAR    tape_name[VU_TAPE_NAME_SIZE];   // space padded name
    CHAR    checksum;                       // checksum of UBYTEs 0 - 19 of this struct
};

struct _CMS_NEW_TAPE_NAME {
    CHAR reserved[MOUNTAIN_SEMISPECED_SPACE];   // leave room for Mountain stuff
    CHAR tape_name[NEW_SPEC_TAPE_NAME_SIZE];    // space padded name
    ULONG creation_time;                        // QIC40/QIC113 date/time format
};

struct _CMS_CORRECT_TAPE_NAME {
    UWORD   unused2;
    UWORD  TrackSeg;                           // Tape segments per tape track
    UBYTE  CartTracks;                         // Tape tracks per cartridge
    UBYTE  MaxFlopSide;                        // Maximum floppy sides
    UBYTE  MaxFlopTrack;                       // Maximum floppy tracks
    UBYTE  MaxFlopSect;                        // Maximum floppy sectors
    CHAR  tape_name[NEW_SPEC_TAPE_NAME_SIZE];  // space padded name
    ULONG creation_time;                       // QIC40/QIC113 date/time format
};

typedef union _QIC40_VENDOR_UNIQUE {
        struct _CMS_VENDOR_UNIQUE cms;
        CHAR vu[QIC40_VENDOR_UNIQUE_SIZE];
        struct _CMS_NEW_TAPE_NAME new_name;
        struct _CMS_CORRECT_TAPE_NAME correct_name;
} QIC40_VENDOR_UNIQUE, *PQIC40_VENDOR_UNIQUE;

typedef struct S_BadList {
    UBYTE ListEntry[LIST_ENTRY_SIZE];
} BAD_LIST, *BAD_LIST_PTR;

typedef union U_BadMap {
    ULONG BadSectors[MAX_BAD_BLOCKS];
    BAD_LIST BadList[MAX_BAD_LIST];
} BAD_MAP, *BAD_MAP_PTR;




// Tape Header (sectors 0-1) and BadSector Array (2-13)
typedef struct _TAPE_HEADER {
    ULONG   Signature;                  // set to 0xaa55aa55l
    UBYTE   FormatCode;                 // set to 0x01
    UBYTE   SubFormatCode;              // Zero for pre-rev L tapes and
                                        //  value + 'A' for rev L and above
    SEGMENT HeaderSegment;              // segment number of header
    SEGMENT DupHeaderSegment;           // segment number of duplicate header
    SEGMENT FirstSegment;               // segment number of Data area
    SEGMENT LastSegment;                // segment number of End of Data area
    ULONG   CurrentFormat;              // time of most recent format
    ULONG   CurrentUpdate;              // time of most recent write to cartridge
    union _QIC40_VENDOR_UNIQUE VendorUnique; // Vendor unique stuff
    UBYTE   ReformatError;              // 0xff if any of remaining data is lost
    UBYTE   unused3;
    ULONG   SegmentsUsed;               // incremented every time a segment is used
    UBYTE   unused4[4];
    ULONG   InitialFormat;              // time of initial format
    UWORD   FormatCount;                // number of times tape has been formatted
    UWORD   FailedSectors;              // the number entries in failed sector log
    CHAR    ManufacturerName[44];       // name of manufacturer that pre-formatted
    CHAR    LotCode[44];                // pre-format lot code
    UBYTE   unused5[22];
    struct S_Failed {
        SEGMENT  Segment;               // number of segment that failed
        struct _FAIL_DATE DateFailed;       // date of failure
    } Failed[(1024+768)/4];             // fill out remaining UBYTEs of sector + next
    BAD_MAP BadMap;
} TAPE_HEADER, *PTAPE_HEADER;

//
// CMS Vendor specific area
//
typedef struct _CMS_VOLUME_VENDOR {
    CHAR Signature[4];          // set to "CMS" (null terminated) if it is our backup
    UWORD FirmwareRevision;     // firmware version
    UWORD SoftwareRevision;     // software version
    CHAR RightsFiles;           // if 0xff = novell rights information present
    UWORD NumFiles;             // number of files in volume
    CHAR OpSysType;             // flavor of operating system at creation
} CMS_VOLUME_VENDOR, PCMS_VOLUME_VENDOR;

//
// QIC-40 Volume table structure
//
typedef struct _VOLUME_TABLE_ENTRY {
    ULONG   Signature;                  // this entry will be "VTBL" if volume exists
    SEGMENT StartSegment;               // starting segment of volume for this cart
    SEGMENT EndingSegment;              // ending segment of volume for this cart
    CHAR    Description[MAX_TITLE_SIZE]; // user description of volume
    ULONG   CreationTime;               // time of creation of the volume
    UWORD   VendorSpecific:1;           // set if remainder of volume entry is vend spec
    UWORD   MultiCartridge:1;           // set if volume spans another tape
    UWORD   NotVerified:1;              // set if volume not verified yet
    UWORD   NoNewName:1;                // set if new file names (redirection) disallowed
    UWORD   StacCompress:1;
    UWORD   reserved:3;
    UWORD   SequenceNumber:8;           // multi-cartridge sequence number
    union {
        CMS_VOLUME_VENDOR cms_QIC40;
        UBYTE reserved[26];             // vendor extension data
    } Vendor;
    CHAR    Password[MAX_PASSWORD_SIZE];// password for volume
    ULONG   DirectorySize;              // number of UBYTEs reserved for directory
    ULONG   DataSize;                   // size of data area (includes other cartridges)
    UWORD   OpSysVersion;               // operating system version
    CHAR    VolumeLabel[16];            // volume label of source drive
    UBYTE   LogicalDevice;              // who knows
    UBYTE   PhysicalDevice;             // who knows
    UWORD   CompressCode:6;             // type of compression, 3Fh = vendor specific
    UWORD   CompressAlwaysZero:1;       // must be 0
    UWORD   CompressSwitch:1;           // compression use flag
    UWORD   reserved1:8;
    UBYTE   reserved2[6];
} VOLUME_TABLE_ENTRY, *PVOLUME_TABLE_ENTRY;

#pragma pack()


//
// The following structure is the context for the q117 driver.  It contains
// all current "state" information for the tape drive.
//
typedef struct _Q117_CONTEXT {

    struct {
        BOOLEAN VerifyOnlyOnFormat;     // Verify only on format.  If TRUE
                                        // Then do NOT perform LOW-LEVEL
                                        // Format

        BOOLEAN DetectOnly;             // If TRUE,  allow only the CMS_DETECT
                                        // ioctl,  and do not allocate memory

        BOOLEAN FormatDisabled;         // If TRUE,  Tape API format will be
                                        // Disabled.

    } Parameters;

    ULONG TapeNumber;                   // Tape number of this context (used
                                        // for DEVICEMAP\tape\Unit {x} and
                                        // device \\.\tape{x}

    BOOLEAN DriverOpened;               // Set if q117Create called (this driver opened)
    BOOLEAN DeviceConfigured;           // Set if CMD_REPORT_DEVICE_CFG performed
    BOOLEAN DeviceSelected;             // Set if CMD_SELECT_DEVICE performed,
                                        // Reset if CMD_DESELECT_DEVICE performed

    struct S_DriveCfgData DriveCfg;


    PVOID PageHandle;

    VOLUME_TABLE_ENTRY ActiveVolume;    // volume currently being saved to (nt volume)
    USHORT ActiveVolumeNumber;          // The sequence number of the current struct VolDir.

    PDEVICE_OBJECT q117iDeviceObject;
    PDEVICE_OBJECT FdcDeviceObject;
    ULONG MaxTransferPages;

    //
    // Error tracking
    //

    ULONG ErrorSequence;
    UCHAR MajorFunction;

    //
    // Queue management globals
    //

    SEGMENT_BUFFER SegmentBuffer[UNIX_MAXBFS];    // Array of segment buffers

    ULONG SegmentBuffersAvailable;

    ULONG QueueTailIndex;               // Index in the IORequest array that indexes the tail.

    ULONG QueueHeadIndex;               // This is the head of the Filer IORequest ring-tail array.

    PIO_REQUEST IoRequest;              // pointer to array of IORequests

    //
    // current buffer information
    //

    struct {

        enum {
            NoOperation,
            BackupInProgress,
            RestoreInProgress
            } Type;

        //
        // Information associated with currently active segment
        //
        PVOID   SegmentPointer;
        USHORT  SegmentBytesRemaining;
        SEGMENT LastSegmentRead;
        SEGMENT CurrentSegment;         // in backup (active segment) in restore (read-ahead segment)
        USHORT  BytesZeroFilled;        // Bytes at end of backup that were zeroed (not part of backup)
        NTSTATUS  SegmentStatus;
        SEGMENT EndOfUsedTape;
        SEGMENT LastSegment;            // Last segment of volume
        ULONG   BytesOnTape;
        BOOLEAN UpdateBadMap;           // if true then update bad sector map
        ULONG   BytesRead;
        ULONG   Position;               // type of last IOCTL_TAPE_SET_POSITION

        } CurrentOperation;

    //
    // current tape information
    //

    struct {
        enum {
            TapeInfoLoaded,
            BadTapeInDrive,
            NeedInfoLoaded
            }   State;

        NTSTATUS BadTapeError;
        SEGMENT LastUsedSegment;
        SEGMENT VolumeSegment;
        ULONG   BadSectors;
        SEGMENT LastSegment;            // Last formatted segment.
        USHORT  MaximumVolumes;         // Maximum volumes entries available
        PTAPE_HEADER TapeHeader;        // Header from tape
        struct _TAPE_GET_MEDIA_PARAMETERS *MediaInfo;
        BAD_MAP_PTR BadMapPtr;
        ULONG BadSectorMapSize;
        USHORT CurBadListIndex;
        USHORT TapeFormatCode;
        enum {
            BadMap3ByteList,
            BadMap8ByteList,
            BadMap4ByteArray,
            BadMapFormatUnknown
            } BadSectorMapFormat;


        } CurrentTape;



    // if this global is set then the tape directory has been loaded
    PIO_REQUEST tapedir;

    char drive_type;                    // QIC40 or QIC80

    //
    // The following pointers are allocated when open is called and
    //  freed at close time.
    //

#ifndef NO_MARKS
#define MAX_MARKS 255
    ULONG CurrentMark;
    struct _MARKENTRIES {
        ULONG TotalMarks;
        ULONG MarksAllocated;       // size of mark entry buffer (in entries not bytes)
        ULONG MaxMarks;
        struct _MARKLIST {
            ULONG Type;
            ULONG Offset;
        } *MarkEntry;
    } MarkArray;
#endif

} Q117_CONTEXT, *PQ117_CONTEXT;


typedef enum _DEQUEUE_TYPE {
    FlushItem,
    WaitForItem
} DEQUEUE_TYPE;

//
// Common need:  convert block into segment
//
#define BLOCK_TO_SEGMENT(block) ((SEGMENT)((block) / BLOCKS_PER_SEGMENT))
#define SEGMENT_TO_BLOCK(segment) ((BLOCK)(segment) * BLOCKS_PER_SEGMENT)


//
// This define is the block size used by position commands
// Note:  It is 512 to be compatible with the Maynstream backup
// that does not do a getmedia parameters
//
#define BLOCK_SIZE  BYTES_PER_SECTOR



#define ERROR_DECODE(val) (val >> 16)

#define ERR_BAD_TAPE                0x0101  /* BadTape */
#define ERR_BAD_SIGNATURE           0x0102  /* Unformat */
#define ERR_UNKNOWN_FORMAT_CODE     0x0103  /* UnknownFmt */
#define ERR_CORRECTION_FAILED       0x0104  /* error recovery failed */
#define ERR_PROGRAM_FAILURE         0x0105  /* coding error */
#define ERR_WRITE_PROTECTED         0x0106
#define ERR_TAPE_NOT_FORMATED       0x0107
#define ERR_UNRECOGNIZED_FORMAT     0x0108 /* badfmt */
#define ERR_END_OF_VOLUME           0x0109 /*EndOfVol */
#define ERR_UNUSABLE_TAPE           0x010a /* badtape - could not format */
#define ERR_SPLIT_REQUESTS          0x010b /* SplitRequests */
#define ERR_EARLY_WARNING           0x010c
#define ERR_SET_MARK                0x010d
#define ERR_FILE_MARK               0x010e
#define ERR_LONG_FILE_MARK          0x010f
#define ERR_SHORT_FILE_MARK         0x0110
#define ERR_NO_VOLUMES              0x0111
#define ERR_NO_MEMORY               0x0112
#define ERR_ECC_FAILED              0x0113
//#define ERR_END_OF_TAPE             0x0114
//#define ERR_TAPE_FULL               0x0115
#define ERR_WRITE_FAILURE           0x0116
#define ERR_BAD_BLOCK_DETECTED      0x0117
#define ERR_OP_PENDING_COMPLETION   0x0118
#define ERR_INVALID_REQUEST         0x0119

/*++

Module Name:

   protos.h

Abstract:

   Prototypes for internal functions of the High-Level portion (data
   formatter) of the QIC-117 device driver.

Revision History:


--*/

NTSTATUS
q117Format(
   OUT LONG *NumberBad,
   IN UCHAR DoFormat,
   IN PQIC40_VENDOR_UNIQUE VendorUnique,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ReqIO(
   IN PIO_REQUEST IoRequest,
   IN PSEGMENT_BUFFER BufferInfo,
   IN PIO_COMPLETION_ROUTINE CompletionRoutine,
   IN PVOID CompletionContext,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117WaitIO(
   IN PIO_REQUEST IoRequest,
   IN BOOLEAN Wait,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117DoIO(
   IN PIO_REQUEST IoRequest,
   IN PSEGMENT_BUFFER BufferInfo,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117AbortIo(
   IN PQ117_CONTEXT Context,
   IN PKEVENT DoneEvent,
   IN PIO_STATUS_BLOCK IoStatus
   );

NTSTATUS
q117AbortIoDone(
   IN PQ117_CONTEXT Context,
   IN PKEVENT DoneEvent
   );

NTSTATUS
q117DoCmd(
   IN OUT PIO_REQUEST IoRequest,
   IN DRIVER_COMMAND Command,
   IN PVOID Data,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117EndRest(
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117MapBadBlock (
   IN PIO_REQUEST IoRequest,
   OUT PVOID *DataPointer,
   IN OUT USHORT *BytesLeft,
   IN OUT SEGMENT *CurrentSegment,
   IN OUT USHORT *Remainder,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117NewTrkRC(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117SelectVol(
   IN PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117UpdateHeader(
   IN PTAPE_HEADER Header,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117Update(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117DoUpdateBad(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117DoUpdateMarks(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117GetMarks(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117FillTapeBlocks(
   IN OUT DRIVER_COMMAND Command,
   IN SEGMENT CurrentSegment,
   IN SEGMENT EndSegment,
   IN OUT PVOID Buffer,
   IN SEGMENT FirstGood,
   IN SEGMENT SecondGood,
   IN PSEGMENT_BUFFER BufferInfo,
   IN PQ117_CONTEXT Context
   );
NTSTATUS
q117IssIOReq(
   IN OUT PVOID Data,
   IN DRIVER_COMMAND Command,
   IN LONG Block,
   IN OUT PSEGMENT_BUFFER BufferInfo,
   IN OUT PQ117_CONTEXT Context
   );

BOOLEAN
q117QueueFull(
   IN PQ117_CONTEXT Context
   );

BOOLEAN
q117QueueEmpty(
   IN PQ117_CONTEXT Context
   );

PVOID
q117GetFreeBuffer(
   OUT PSEGMENT_BUFFER *BufferInfo,
   IN PQ117_CONTEXT Context
   );

PVOID
q117GetLastBuffer(
   IN PQ117_CONTEXT Context
   );

PIO_REQUEST
q117Dequeue(
   IN DEQUEUE_TYPE Type,
   IN OUT PQ117_CONTEXT Context
   );

VOID
q117ClearQueue(
   IN OUT PQ117_CONTEXT Context
   );

VOID
q117QueueSingle(
   IN OUT PQ117_CONTEXT Context
   );

VOID
q117QueueNormal(
   IN OUT PQ117_CONTEXT Context
   );

PIO_REQUEST
q117GetCurReq(
   IN PQ117_CONTEXT Context
   );

ULONG
q117GetQueueIndex(
   IN PQ117_CONTEXT Context
   );

VOID
q117SetQueueIndex(
   IN ULONG Index,
   OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117LoadTape (
   IN OUT PTAPE_HEADER*HeaderPointer,
   IN OUT PQ117_CONTEXT Context,
   IN PUCHAR driver_format_code
   );

NTSTATUS
q117InitFiler (
   IN OUT PQ117_CONTEXT Context
   );

void
q117GetBadSectors (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ReadHeaderSegment (
   OUT PTAPE_HEADER*HeaderPointer,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117WriteTape(
   IN OUT PVOID FromWhere,
   IN OUT ULONG HowMany,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117EndBack(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ReadVolumeEntry(
   PVOLUME_TABLE_ENTRY VolumeEntry,
   PQ117_CONTEXT Context
   );

VOID
q117FakeDataSize(
   IN OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117AppVolTD(
   IN OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117SelectTD(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117Start (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117Stop (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117OpenForWrite (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117EndWriteOperation (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117OpenForRead (
    IN ULONG StartPosition,
    IN OUT PQ117_CONTEXT Context,
    IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS
q117EndReadOperation (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117StartBack(
   IN OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117StartAppend(
   IN OUT ULONG BytesAlreadyThere,
   IN PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117StartComm(
   OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117SelVol (
   PVOLUME_TABLE_ENTRY TheVolumeTable,
   PQ117_CONTEXT Context
   );

NTSTATUS
q117ReadTape (
   OUT PVOID ToWhere,
   IN OUT ULONG *HowMany,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ConvertStatus(
   IN PDEVICE_OBJECT DeviceObject,
   IN NTSTATUS status
   );

VOID
q117SetTpSt(
   PQ117_CONTEXT Context
   );

NTSTATUS
q117GetEndBlock (
   OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   OUT LONG *NumberVolumes,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117BuildHeader(
   OUT PQIC40_VENDOR_UNIQUE VendorUnique,
   IN SEGMENT *HeaderSect,
   IN OUT PTAPE_HEADER Header,
   IN CQDTapeCfg *tparms,      // tape parameters from the driver
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117IoCtlGetMediaParameters (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetMediaTypesEx (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117IoCtlSetMediaParameters (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetDeviceNumber (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetDriveParameters (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlSetDriveParameters (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlWriteMarks (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlSetPosition (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117FindMark(
   ULONG Type,
   LONG Number,
   PQ117_CONTEXT Context,
   IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS
q117SeekToOffset(
   ULONG Offset,
   PQ117_CONTEXT Context,
   IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS
q117IoCtlErase (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlPrepare (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetStatus (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetPosition (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117CheckNewTape (
   PQ117_CONTEXT             Context
   );

NTSTATUS
q117NewTrkBk(
   PQ117_CONTEXT Context
   );

NTSTATUS
q117GetTapeCapacity(
   struct S_O_DGetCap *ptr,
   PQ117_CONTEXT Context
   );

VOID
q117RdsInitReed (
   VOID
   );

UCHAR
q117RdsMultiplyTuples (
   IN UCHAR tup1,
   IN UCHAR tup2
   );

UCHAR
q117RdsDivideTuples (
   IN UCHAR tup1,
   IN UCHAR tup2
   );

UCHAR
q117RdsExpTuple (
   IN UCHAR tup1,
   IN UCHAR xpnt
   );

VOID
q117RdsMakeCRC (
   IN OUT UCHAR *Array,      // pointer to 32K data area (segment)
   IN UCHAR Count            // number of sectors (1K blocks)(1-32)
   );

BOOLEAN
q117RdsReadCheck (
   IN UCHAR *Array,         // pointer to 32K data area (segment)
   IN UCHAR Count           // number of sectors (1K blocks)(1-32)
   );

BOOLEAN
q117RdsCorrect(
   IN OUT UCHAR *Array,    // pointer to 32K data area (segment)
   IN UCHAR Count,         // number of good sectors in segment (4-32)
   IN UCHAR CRCErrors,     // number of crc errors
   IN UCHAR e1,
   IN UCHAR e2,
   IN UCHAR e3             // sectors where errors occurred
   );

VOID
q117RdsGetSyndromes (
   IN OUT UCHAR *Array,       // pointer to 32K data area (segment)
   IN UCHAR Count,            // number of good sectors in segment (4-32)
   IN UCHAR *ps1,
   IN UCHAR *ps2,
   IN UCHAR *ps3
   );

BOOLEAN
q117RdsCorrectFailure (
   IN OUT UCHAR *Array,     // pointer to 32K data area (segment)
   IN UCHAR Count,          // number of good sectors in segment (4-32)
   IN UCHAR s1,
   IN UCHAR s2,
   IN UCHAR s3
   );

BOOLEAN
q117RdsCorrectOneError (
   IN OUT UCHAR *Array,      // pointer to 32K data area (segment)
   IN UCHAR Count,           // number of good sectors in segment (4-32)
   IN UCHAR ErrorLocation,
   IN UCHAR s1,
   IN UCHAR s2,
   IN UCHAR s3
   );

BOOLEAN
q117RdsCorrectTwoErrors (
   IN OUT UCHAR *Array,       // pointer to 32K data area (segment)
   IN UCHAR Count,            // number of good sectors in segment (4-32)
   IN UCHAR ErrorLocation1,
   IN UCHAR ErrorLocation2,
   IN UCHAR s1,
   IN UCHAR s2,
   IN UCHAR s3
   );

BOOLEAN
q117RdsCorrectThreeErrors (
   IN OUT UCHAR *Array,       // pointer to 32K data area (segment)
   IN UCHAR Count,            // number of good sectors in segment (4-32)
   IN UCHAR ErrorLocation1,
   IN UCHAR ErrorLocation2,
   IN UCHAR ErrorLocation3,
   IN UCHAR s1,
   IN UCHAR s2,
   UCHAR s3
   );

BOOLEAN
q117RdsCorrectOneErrorAndOneFailure (
   IN OUT UCHAR *Array,        // pointer to 32K data area (segment)
   IN UCHAR Count,             // number of good sectors in segment (4-32)
   IN UCHAR ErrorLocation1,
   IN UCHAR s1,
   IN UCHAR s2,
   IN UCHAR s3
   );

void
q117SpacePadString(
   IN OUT CHAR *InputString,
   IN LONG StrSize
   );

NTSTATUS
q117VerifyFormat(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117EraseQ(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117EraseS(
   IN OUT PQ117_CONTEXT Context
   );

VOID
q117ClearVolume (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117SkipBlock (
   IN OUT ULONG *HowMany,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ReconstructSegment(
   IN PIO_REQUEST IoReq,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117DoCorrect(
   IN PVOID DataBuffer,
   IN ULONG BadSectorMap,
   IN ULONG SectorsInError
   );

UCHAR
q117CountBits(
    IN PQ117_CONTEXT Context,
    IN SEGMENT Segment,
    ULONG Map
    );

ULONG q117ReadBadSectorList (
    IN PQ117_CONTEXT Context,
    IN SEGMENT Segment
    );

USHORT
q117GoodDataBytes(
   IN SEGMENT Segment,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117AllocatePermanentMemory(
   PQ117_CONTEXT Context,
   PDEVICE_OBJECT FdcDeviceObject
   );

NTSTATUS
q117GetTemporaryMemory(
   PQ117_CONTEXT Context
   );

VOID
q117FreeTemporaryMemory(
   PQ117_CONTEXT Context
   );

NTSTATUS
q117IoCtlReadAbs (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlWriteAbs (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlDetect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117UpdateBadMap(
    IN OUT PQ117_CONTEXT Context,
    IN SEGMENT Segment,
    IN ULONG BadSectors
    );

int
q117BadMapToBadList(
    IN SEGMENT Segment,
    IN ULONG BadSectors,
    IN BAD_LIST_PTR BadListPtr
    );

ULONG
q117BadListEntryToSector(
    IN UCHAR *ListEntry,
    OUT BOOLEAN *hiBitSet
    );

NTSTATUS
q117AllocateBuffers (
    PQ117_CONTEXT Context
    );

NTSTATUS
q117Read(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
q117Write(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117DeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Create (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Close (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
q117CreateKey(
    IN HANDLE Root,
    IN PSTR key,
    OUT PHANDLE NewKey
    );

NTSTATUS
q117CreateRegistryInfo(
    IN ULONG TapeNumber,
    IN PUNICODE_STRING RegistryPath,
    IN PQ117_CONTEXT Context
    );

cms_IoCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117DoRewind(
    PQ117_CONTEXT       Context
    );

NTSTATUS q117MakeMarkArrayBigger(
    PQ117_CONTEXT       Context,
    int MinimumToAdd
    );

int
q117SelectBSMLocation(
    IN OUT PQ117_CONTEXT Context
    );

NTSTATUS kdi_WriteRegString(
    HANDLE          unit_key,
    PSTR            name,
    PSTR            value
    );

NTSTATUS kdi_FdcDeviceIo(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEQICH,q117Initialize)
#pragma alloc_text(PAGEQICH,q117CreateRegistryInfo)
#pragma alloc_text(PAGEQICH,q117CreateKey)
#pragma alloc_text(PAGEQICH,q117AllocatePermanentMemory)
#endif

#ifndef NOCODELOCK

#ifdef ALLOC_PRAGMA
//#pragma alloc_text(PAGEQICH, q117Create)
//#pragma alloc_text(PAGEQICH, q117Close)
#pragma alloc_text(PAGEQICH, cms_IoCtl)
#pragma alloc_text(PAGEQICH, q117Read)
#pragma alloc_text(PAGEQICH, q117Write)
#pragma alloc_text(PAGEQICH, q117DeviceControl)
#pragma alloc_text(PAGEQICH, q117DoRewind)
#pragma alloc_text(PAGEQICH, q117AbortIo)
#pragma alloc_text(PAGEQICH, q117AbortIoDone)
#pragma alloc_text(PAGEQICH, q117AllocateBuffers )
#pragma alloc_text(PAGEQICH, q117AppVolTD)
#pragma alloc_text(PAGEQICH, q117BadListEntryToSector)
#pragma alloc_text(PAGEQICH, q117BadMapToBadList)
#pragma alloc_text(PAGEQICH, q117BuildHeader)
#pragma alloc_text(PAGEQICH, q117CheckNewTape )
#pragma alloc_text(PAGEQICH, q117ClearQueue)
#pragma alloc_text(PAGEQICH, q117ClearVolume )
#pragma alloc_text(PAGEQICH, q117ConvertStatus)
#pragma alloc_text(PAGEQICH, q117CountBits)
#pragma alloc_text(PAGEQICH, q117Dequeue)
#pragma alloc_text(PAGEQICH, q117DoCmd)
#pragma alloc_text(PAGEQICH, q117DoCorrect)
#pragma alloc_text(PAGEQICH, q117DoIO)
#pragma alloc_text(PAGEQICH, q117DoUpdateBad)
#pragma alloc_text(PAGEQICH, q117DoUpdateMarks)
#pragma alloc_text(PAGEQICH, q117EndBack)
#pragma alloc_text(PAGEQICH, q117EndReadOperation )
#pragma alloc_text(PAGEQICH, q117EndRest)
#pragma alloc_text(PAGEQICH, q117EndWriteOperation )
#pragma alloc_text(PAGEQICH, q117EraseQ)
#pragma alloc_text(PAGEQICH, q117EraseS)
#pragma alloc_text(PAGEQICH, q117FakeDataSize)
#pragma alloc_text(PAGEQICH, q117FillTapeBlocks)
#pragma alloc_text(PAGEQICH, q117FindMark)
#pragma alloc_text(PAGEQICH, q117Format)
#pragma alloc_text(PAGEQICH, q117FreeTemporaryMemory)
#pragma alloc_text(PAGEQICH, q117GetBadSectors )
#pragma alloc_text(PAGEQICH, q117GetCurReq)
#pragma alloc_text(PAGEQICH, q117GetEndBlock )
#pragma alloc_text(PAGEQICH, q117GetFreeBuffer)
#pragma alloc_text(PAGEQICH, q117GetLastBuffer)
#pragma alloc_text(PAGEQICH, q117GetMarks)
#pragma alloc_text(PAGEQICH, q117GetQueueIndex)
#pragma alloc_text(PAGEQICH, q117GetTapeCapacity)
#pragma alloc_text(PAGEQICH, q117GetTemporaryMemory)
#pragma alloc_text(PAGEQICH, q117GoodDataBytes)
#pragma alloc_text(PAGEQICH, q117InitFiler )
#pragma alloc_text(PAGEQICH, q117IoCtlErase )
#pragma alloc_text(PAGEQICH, q117IoCtlGetDeviceNumber )
#pragma alloc_text(PAGEQICH, q117IoCtlGetDriveParameters )
#pragma alloc_text(PAGEQICH, q117IoCtlGetMediaParameters )
#pragma alloc_text(PAGEQICH, q117IoCtlGetPosition )
#pragma alloc_text(PAGEQICH, q117IoCtlGetStatus )
#pragma alloc_text(PAGEQICH, q117IoCtlPrepare )
#pragma alloc_text(PAGEQICH, q117IoCtlReadAbs )
#pragma alloc_text(PAGEQICH, q117IoCtlSetDriveParameters )
#pragma alloc_text(PAGEQICH, q117IoCtlSetMediaParameters )
#pragma alloc_text(PAGEQICH, q117IoCtlSetPosition )
#pragma alloc_text(PAGEQICH, q117IoCtlWriteAbs )
#pragma alloc_text(PAGEQICH, q117IoCtlWriteMarks )
#pragma alloc_text(PAGEQICH, q117IssIOReq)
#pragma alloc_text(PAGEQICH, q117LoadTape )
#pragma alloc_text(PAGEQICH, q117MapBadBlock )
#pragma alloc_text(PAGEQICH, q117NewTrkBk)
#pragma alloc_text(PAGEQICH, q117NewTrkRC)
#pragma alloc_text(PAGEQICH, q117OpenForRead )
#pragma alloc_text(PAGEQICH, q117OpenForWrite )
#pragma alloc_text(PAGEQICH, q117QueueEmpty)
#pragma alloc_text(PAGEQICH, q117QueueFull)
#pragma alloc_text(PAGEQICH, q117QueueNormal)
#pragma alloc_text(PAGEQICH, q117QueueSingle)
#pragma alloc_text(PAGEQICH, q117RdsCorrect)
#pragma alloc_text(PAGEQICH, q117RdsCorrectFailure )
#pragma alloc_text(PAGEQICH, q117RdsCorrectOneError )
#pragma alloc_text(PAGEQICH, q117RdsCorrectOneErrorAndOneFailure )
#pragma alloc_text(PAGEQICH, q117RdsCorrectThreeErrors )
#pragma alloc_text(PAGEQICH, q117RdsCorrectTwoErrors )
#pragma alloc_text(PAGEQICH, q117RdsDivideTuples )
#pragma alloc_text(PAGEQICH, q117RdsExpTuple )
#pragma alloc_text(PAGEQICH, q117RdsGetSyndromes )
#pragma alloc_text(PAGEQICH, q117RdsInitReed )
#pragma alloc_text(PAGEQICH, q117RdsMakeCRC )
#pragma alloc_text(PAGEQICH, q117RdsMultiplyTuples )
#pragma alloc_text(PAGEQICH, q117RdsReadCheck )
#pragma alloc_text(PAGEQICH, q117ReadBadSectorList )
#pragma alloc_text(PAGEQICH, q117ReadHeaderSegment )
#pragma alloc_text(PAGEQICH, q117ReadTape )
#pragma alloc_text(PAGEQICH, q117ReadVolumeEntry)
#pragma alloc_text(PAGEQICH, q117ReconstructSegment)
#pragma alloc_text(PAGEQICH, q117ReqIO)
#pragma alloc_text(PAGEQICH, q117SeekToOffset)
#pragma alloc_text(PAGEQICH, q117SelectTD)
#pragma alloc_text(PAGEQICH, q117SelectVol)
#pragma alloc_text(PAGEQICH, q117SelVol )
#pragma alloc_text(PAGEQICH, q117SetQueueIndex)
#pragma alloc_text(PAGEQICH, q117SetTpSt)
#pragma alloc_text(PAGEQICH, q117SkipBlock )
#pragma alloc_text(PAGEQICH, q117SpacePadString)
#pragma alloc_text(PAGEQICH, q117Start )
#pragma alloc_text(PAGEQICH, q117StartAppend)
#pragma alloc_text(PAGEQICH, q117StartBack)
#pragma alloc_text(PAGEQICH, q117StartComm)
#pragma alloc_text(PAGEQICH, q117Stop )
#pragma alloc_text(PAGEQICH, q117Update)
#pragma alloc_text(PAGEQICH, q117UpdateBadMap)
#pragma alloc_text(PAGEQICH, q117UpdateHeader)
#pragma alloc_text(PAGEQICH, q117VerifyFormat)
#pragma alloc_text(PAGEQICH, q117WaitIO)
#pragma alloc_text(PAGEQICH, q117WriteTape)
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\acpiutil.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       acpiutil.c
//
//--------------------------------------------------------------------------

#include "ideport.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(NONPAGE, DeviceQueryACPISettings)
#pragma alloc_text(NONPAGE, DeviceQueryACPISettingsCompletionRoutine)
#pragma alloc_text(NONPAGE, DeviceQueryFirmwareBootSettings)
#pragma alloc_text(NONPAGE, DeviceQueryChannelTimingSettings)

#pragma alloc_text(NONPAGE, ChannelSetACPITimingSettings)
#pragma alloc_text(NONPAGE, ChannelSyncSetACPITimingSettingsCompletionRoutine)
#pragma alloc_text(NONPAGE, ChannelSetACPITimingSettings)
#pragma alloc_text(NONPAGE, ChannelSetACPITimingSettingsCompletionRoutine)
#endif // ALLOC_PRAGMA


NTSTATUS
DeviceQueryACPISettings (
    IN PDEVICE_EXTENSION_HEADER DoExtension,
    IN ULONG ControlMethodName,
    OUT PACPI_EVAL_OUTPUT_BUFFER *QueryResult
    )
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK ioStatusBlock;
    ACPI_EVAL_INPUT_BUFFER cmInputData;
    PACPI_EVAL_OUTPUT_BUFFER cmOutputData;
    ULONG cmOutputDataSize;
    NTSTATUS status;
    KEVENT event;
    ULONG retry;
    ULONG systemBufferLength;
    PDEVICE_OBJECT targetDeviceObject;


    DebugPrint((DBG_ACPI,
                "ATAPI: ChannelQueryACPISettings for %c%c%c%c\n",
                ((PUCHAR)&ControlMethodName)[0],
                ((PUCHAR)&ControlMethodName)[1],
                ((PUCHAR)&ControlMethodName)[2],
                ((PUCHAR)&ControlMethodName)[3]
                ));

    RtlZeroMemory (
        &cmInputData,
        sizeof(cmInputData)
        );

    cmInputData.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    cmInputData.MethodNameAsUlong = ControlMethodName;

    //
    // get the top of our device stack
    //
    targetDeviceObject = IoGetAttachedDeviceReference(
                             DoExtension->DeviceObject
                             );

    cmOutputDataSize = sizeof(ACPI_EVAL_OUTPUT_BUFFER);
    irp = NULL;

    for (retry=0; retry<2; retry++) {

        DebugPrint((DBG_ACPI, "ATAPI: _GTM try %x\n", retry));

        cmOutputData = ExAllocatePool (
                           NonPagedPool,
                           cmOutputDataSize
                           );
        if (cmOutputData == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE);

        irp = IoAllocateIrp(targetDeviceObject->StackSize, FALSE);
        if (irp == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        if (sizeof(cmInputData) > cmOutputDataSize) {
            systemBufferLength = sizeof(cmInputData);
        } else {
            systemBufferLength = cmOutputDataSize;
        }

        irp->AssociatedIrp.SystemBuffer = ExAllocatePool(
                                              NonPagedPoolCacheAligned,
                                              systemBufferLength
                                              );
        if (irp->AssociatedIrp.SystemBuffer == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ASSERT ((IOCTL_ACPI_ASYNC_EVAL_METHOD & 0x3) == METHOD_BUFFERED);
        irp->Flags = IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        irpSp = IoGetNextIrpStackLocation( irp );

        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        irpSp->Parameters.DeviceIoControl.OutputBufferLength = cmOutputDataSize;
        irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(cmInputData);
        irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_ACPI_ASYNC_EVAL_METHOD;

        RtlCopyMemory(
            irp->AssociatedIrp.SystemBuffer,
            &cmInputData,
            sizeof(cmInputData)
            );

        irp->UserBuffer = cmOutputData;

        IoSetCompletionRoutine(
            irp,
            DeviceQueryACPISettingsCompletionRoutine,
            &event,
            TRUE,
            TRUE,
            TRUE
            );

        status = IoCallDriver(targetDeviceObject, irp);

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            status = irp->IoStatus.Status;
        }

        if (NT_SUCCESS(status)) {

            //
            // should get what we are expecting
            //
            ASSERT (
                cmOutputData->Signature ==
                ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE
            );
            if (cmOutputData->Signature !=
                ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE) {

                status = STATUS_UNSUCCESSFUL;
            }
        }

        ExFreePool(irp->AssociatedIrp.SystemBuffer);
        IoFreeIrp(irp);
        irp = NULL;

        if (!NT_SUCCESS(status)) {

            //
            // grab the data length in case we need it
            //
            cmOutputDataSize = cmOutputData->Length;

            ExFreePool(cmOutputData);
            cmOutputData = NULL;

            if (status == STATUS_BUFFER_OVERFLOW) {

                //
                // output buffer too small, try again
                //

            } else {

                //
                // got some error, no need to retry
                //
                break;
            }
        }
    }

    //
    // Clean up
    //
    ObDereferenceObject (targetDeviceObject);

    if (irp) {

        if (irp->AssociatedIrp.SystemBuffer) {

            ExFreePool(irp->AssociatedIrp.SystemBuffer);
        }
        IoFreeIrp(irp);
    }

    //
    // returning
    //
    *QueryResult = cmOutputData;
    return status;
} // ChannelQueryACPISettings


NTSTATUS
DeviceQueryACPISettingsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PKEVENT event = Context;

    if (!NT_ERROR(Irp->IoStatus.Status)) {

        //
        // Copy the information from the system
        // buffer to the caller's buffer.
        //
        RtlCopyMemory(
            Irp->UserBuffer,
            Irp->AssociatedIrp.SystemBuffer,
            Irp->IoStatus.Information
            );
    }


    KeSetEvent(
        event,
        EVENT_INCREMENT,
        FALSE
        );



    return STATUS_MORE_PROCESSING_REQUIRED;
} // DeviceQueryACPISettingsCompletionRoutine


NTSTATUS
DeviceQueryFirmwareBootSettings (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PDEVICE_SETTINGS *IdeBiosSettings
    )
{
    NTSTATUS status;
    PACPI_EVAL_OUTPUT_BUFFER queryResult;
    PDEVICE_SETTINGS ideBiosSettings;
    ULONG i;

    *IdeBiosSettings = NULL;

    status = DeviceQueryACPISettings (
                 (PDEVICE_EXTENSION_HEADER) PdoExtension,
                 ACPI_METHOD_GET_TASK_FILE,
                 &queryResult
                 );

    if (NT_SUCCESS(status)) {

        if (queryResult->Count != 1) {

            ASSERT (queryResult->Count == 1);
            status = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(status)) {

        PACPI_METHOD_ARGUMENT argument;

        argument = queryResult->Argument;

        //
        // looking for buffer type
        //
        if (argument->Type == ACPI_METHOD_ARGUMENT_BUFFER) {

            ULONG numEntries;

            ASSERT (!(argument->DataLength % sizeof(ACPI_GTF_IDE_REGISTERS)));

            numEntries = argument->DataLength / sizeof(ACPI_GTF_IDE_REGISTERS);

            ideBiosSettings = ExAllocatePool (
                                  NonPagedPool,
                                  sizeof(DEVICE_SETTINGS) +
                                    numEntries * sizeof(IDEREGS)
                                  );
            if (!ideBiosSettings) {

                DebugPrint((DBG_ALWAYS, "ATAPI: ChannelQueryFirmwareBootSettings failed to allocate memory\n"));
                status = STATUS_INSUFFICIENT_RESOURCES;

            } else {


                for (i=0; i<numEntries; i++) {

                    RtlMoveMemory (
                        ideBiosSettings->FirmwareSettings + i,
                        argument->Data + i * sizeof(ACPI_GTF_IDE_REGISTERS),
                        sizeof(ACPI_GTF_IDE_REGISTERS)
                        );

                    ideBiosSettings->FirmwareSettings[i].bReserved = 0;
                }

                ideBiosSettings->NumEntries = numEntries;

                *IdeBiosSettings = ideBiosSettings;

#if DBG
                {
                    ULONG i;
                    DebugPrint((DBG_ACPI, "ATAPI: _GTF Data:\n"));
                    for (i=0; i<ideBiosSettings->NumEntries; i++) {
                        DebugPrint((DBG_ACPI, "\t"));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bFeaturesReg));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bSectorCountReg));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bSectorNumberReg));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bCylLowReg));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bCylHighReg));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bDriveHeadReg));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bCommandReg));
                        DebugPrint((DBG_ACPI, "\n"));
                    }
                }
#endif
            }
        }
    }

    //
    // clean up
    //
    if (queryResult) {

        ExFreePool (queryResult);
    }
    return status;
} // ChannelQueryFirmwareBootSettings


NTSTATUS
DeviceQueryChannelTimingSettings (
    IN PFDO_EXTENSION FdoExtension,
    IN OUT PACPI_IDE_TIMING TimimgSettings
    )
{
    NTSTATUS status;
    PACPI_EVAL_OUTPUT_BUFFER queryResult;
    PACPI_IDE_TIMING timimgSettings;
    ULONG i;

    status = DeviceQueryACPISettings (
                 (PDEVICE_EXTENSION_HEADER) FdoExtension,
                 ACPI_METHOD_GET_TIMING,
                 &queryResult
                 );

    if (NT_SUCCESS(status)) {

        if (queryResult->Count != 1) {

            ASSERT (queryResult->Count == 1);
            status = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(status)) {

        PACPI_METHOD_ARGUMENT argument;

        //
        // PIO Speed
        //
        argument = queryResult->Argument;

        ASSERT (argument->Type == ACPI_METHOD_ARGUMENT_BUFFER);
        if ((argument->Type == ACPI_METHOD_ARGUMENT_BUFFER) &&
            (argument->DataLength >= sizeof (ACPI_IDE_TIMING))) {

            RtlCopyMemory (
                TimimgSettings,
                argument->Data,
                sizeof(ACPI_IDE_TIMING)
                );

            DebugPrint((DBG_ACPI, "ATAPI: _GTM Data:\n"));
            for (i=0; i<MAX_IDE_DEVICE; i++) {
                DebugPrint((DBG_ACPI, "\tPIO Speed %d: 0x%0x\n", i, TimimgSettings->Speed[i].Pio));
                DebugPrint((DBG_ACPI, "\tDMA Speed %d: 0x%0x\n", i, TimimgSettings->Speed[i].Dma));
            }
            DebugPrint((DBG_ACPI, "\tFlags:     0x%0x\n", TimimgSettings->Flags.AsULong));

			//
			// The following asserts are bogus. The ACPI spec doesn't say anything about the timing
			// information for the slave device in this case
			//
            //if (!TimimgSettings->Flags.b.IndependentTiming) {
             //   ASSERT (TimimgSettings->Speed[MAX_IDE_DEVICE - 1].Pio == ACPI_XFER_MODE_NOT_SUPPORT);
              //  ASSERT (TimimgSettings->Speed[MAX_IDE_DEVICE - 1].Dma == ACPI_XFER_MODE_NOT_SUPPORT);
            //}

        } else {

            status = STATUS_UNSUCCESSFUL;
        }

    }

    if (!NT_SUCCESS(status)) {

        for (i=0; i<MAX_IDE_DEVICE; i++) {

            TimimgSettings->Speed[i].Pio = ACPI_XFER_MODE_NOT_SUPPORT;
            TimimgSettings->Speed[i].Dma = ACPI_XFER_MODE_NOT_SUPPORT;
        }
    }

    //
    // clean up
    //
    if (queryResult) {

        ExFreePool (queryResult);
    }
    return status;
} // DeviceQueryChannelTimingSettings


NTSTATUS
ChannelSyncSetACPITimingSettings (
    IN PFDO_EXTENSION FdoExtension,
    IN PACPI_IDE_TIMING TimimgSettings,
    IN PIDENTIFY_DATA AtaIdentifyData[MAX_IDE_DEVICE]
    )
{
    SYNC_SET_ACPI_TIMING_CONTEXT context;
    NTSTATUS status;

    KeInitializeEvent(&context.Event,
                      NotificationEvent,
                      FALSE);

    status = ChannelSetACPITimingSettings (
                 FdoExtension,
                 TimimgSettings,
                 AtaIdentifyData,
                 ChannelSyncSetACPITimingSettingsCompletionRoutine,
                 &context
                 );

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&context.Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
    }

    return status = context.IrpStatus;
}

NTSTATUS
ChannelSyncSetACPITimingSettingsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PVOID Context
    )
{
    PSYNC_SET_ACPI_TIMING_CONTEXT context = Context;

    context->IrpStatus = Status;

    KeSetEvent(
        &context->Event,
        EVENT_INCREMENT,
        FALSE
        );

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
ChannelSetACPITimingSettings (
    IN PFDO_EXTENSION FdoExtension,
    IN PACPI_IDE_TIMING TimimgSettings,
    IN PIDENTIFY_DATA AtaIdentifyData[MAX_IDE_DEVICE],
    IN PSET_ACPI_TIMING_COMPLETION_ROUTINE CallerCompletionRoutine,
    IN PVOID CallerContext
    )
{
    ULONG i;
    PIRP irp;
    NTSTATUS status;
    PDEVICE_OBJECT targetDeviceObject;

    PACPI_EVAL_INPUT_BUFFER_COMPLEX cmInputData;
    ULONG cmInputDataSize;
    PACPI_METHOD_ARGUMENT argument;
    PASYNC_SET_ACPI_TIMING_CONTEXT context;

    PIO_STACK_LOCATION irpSp;

    DebugPrint((DBG_ACPI,
                "ATAPI: ChannelSetACPITimingSettings _STM data\n"
                ));
    for (i=0; i<MAX_IDE_DEVICE; i++) {
        DebugPrint((DBG_ACPI, "\tPIO Speed %d: 0x%0x\n", i, TimimgSettings->Speed[i].Pio));
        DebugPrint((DBG_ACPI, "\tDMA Speed %d: 0x%0x\n", i, TimimgSettings->Speed[i].Dma));
    }
    DebugPrint((DBG_ACPI, "\tFlags:     0x%0x\n", TimimgSettings->Flags.AsULong));


    cmInputData = NULL;
    irp = NULL;
    targetDeviceObject = NULL;

    //
    // get the memory we need
    //
    cmInputDataSize = sizeof (ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
                      3 * sizeof (ACPI_METHOD_ARGUMENT) +
                      sizeof (ACPI_IDE_TIMING) +
                      2 * sizeof (IDENTIFY_DATA);

    cmInputData = ExAllocatePool (
                      NonPagedPool,
                      cmInputDataSize +
                      sizeof (ASYNC_SET_ACPI_TIMING_CONTEXT)
                      );

    if (cmInputData == NULL) {
        status=STATUS_INSUFFICIENT_RESOURCES;
        goto getout;
    }

    RtlZeroMemory (
        cmInputData,
        cmInputDataSize +
        sizeof (ASYNC_SET_ACPI_TIMING_CONTEXT)
        );

    context = (PASYNC_SET_ACPI_TIMING_CONTEXT) (((PUCHAR) cmInputData) + cmInputDataSize);
    context->FdoExtension = FdoExtension;
    context->CallerCompletionRoutine = CallerCompletionRoutine;
    context->CallerContext = CallerContext;


    cmInputData->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
    cmInputData->MethodNameAsUlong = ACPI_METHOD_SET_TIMING;
    cmInputData->Size = cmInputDataSize;
    cmInputData->ArgumentCount = 3;

    //
    // first argument
    //
    argument = cmInputData->Argument;

    argument->Type = ACPI_METHOD_ARGUMENT_BUFFER;
    argument->DataLength = sizeof(ACPI_IDE_TIMING);
    RtlCopyMemory (
        argument->Data,
        TimimgSettings,
        sizeof(ACPI_IDE_TIMING)
        );
    argument = ACPI_METHOD_NEXT_ARGUMENT(argument);

    //
    // second argument
    //
    argument->Type = ACPI_METHOD_ARGUMENT_BUFFER;

    if (AtaIdentifyData[0]) {

        argument->DataLength = sizeof(IDENTIFY_DATA);
        RtlCopyMemory (
            argument->Data,
            AtaIdentifyData[0],
            sizeof(IDENTIFY_DATA)
            );

        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);

    } else {

        argument->DataLength = sizeof(IDENTIFY_DATA);
        RtlZeroMemory (
            argument->Data,
            sizeof(IDENTIFY_DATA)
            );

        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
    }

    //
    // third argument
    //
    argument->Type = ACPI_METHOD_ARGUMENT_BUFFER;
    if (AtaIdentifyData[1]) {

        argument->DataLength = sizeof(IDENTIFY_DATA);
        RtlCopyMemory (
            argument->Data,
            AtaIdentifyData[1],
            sizeof(IDENTIFY_DATA)
            );
    } else {

        argument->DataLength = sizeof(IDENTIFY_DATA);
        RtlZeroMemory (
            argument->Data,
            sizeof(IDENTIFY_DATA)
            );
    }

    //
    // get the top of our device stack
    //
    targetDeviceObject = IoGetAttachedDeviceReference(
                             FdoExtension->DeviceObject
                             );

    irp = IoAllocateIrp(targetDeviceObject->StackSize, FALSE);
    if (irp == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto getout;
    }

    irp->AssociatedIrp.SystemBuffer = cmInputData;

    ASSERT ((IOCTL_ACPI_ASYNC_EVAL_METHOD & 0x3) == METHOD_BUFFERED);
    irp->Flags = IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = cmInputDataSize;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_ACPI_ASYNC_EVAL_METHOD;

    irp->UserBuffer = NULL;

    IoSetCompletionRoutine(
        irp,
        ChannelSetACPITimingSettingsCompletionRoutine,
        context,
        TRUE,
        TRUE,
        TRUE
        );

    IoCallDriver(targetDeviceObject, irp);

    status = STATUS_PENDING;

getout:
    //
    // Clean up
    //
    if (targetDeviceObject) {

        ObDereferenceObject (targetDeviceObject);
    }

    if (!NT_SUCCESS(status) && (status != STATUS_PENDING)) {

        if (irp) {

            IoFreeIrp(irp);
        }

        if (cmInputData) {
            ExFreePool (cmInputData);
        }
    }

    //
    // returning
    //
    return status;

} // ChannelSetACPITimingSettings

NTSTATUS
ChannelSetACPITimingSettingsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PASYNC_SET_ACPI_TIMING_CONTEXT context = Context;

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {

        DebugPrint ((DBG_ALWAYS,
                     "*********************************************\n"
                     "*********************************************\n"
                     "**                                          *\n"
                     "** ACPI Set Timing Failed with status %x    *\n"
                     "** Ignore it for now                        *\n"
                     "**                                          *\n"
                     "*********************************************\n"
                     "*********************************************\n",
                     Irp->IoStatus.Status
                     ));

        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    (*context->CallerCompletionRoutine) (
        DeviceObject,
        Irp->IoStatus.Status,
        context->CallerContext
        );

    ExFreePool (Irp->AssociatedIrp.SystemBuffer);
    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\atapi.c ===
/*++

Copyright (C) 1993-99  Microsoft Corporation

Module Name:

    atapi.c

Abstract:

    This is the miniport driver for IDE controllers.

Author:

    Mike Glass (MGlass)
    Chuck Park (ChuckP)
    Joe Dai (joedai)

Environment:

    kernel mode only

Notes:

Revision History:

    george C.(georgioc)     Merged wtih Compaq code to make miniport driver function
                            with the 120MB floppy drive
                            Added support for MEDIA STATUS NOTIFICATION
                            Added support for SCSIOP_START_STOP_UNIT (eject media)

    joedai                  PCI Bus Master IDE Support
                            ATA Passthrough (temporary solution)
                            LBA with ATA drive > 8G
                            PCMCIA IDE support
                            Native mode support

--*/

#include "ideport.h"

#if DBG
ULONG __DebugForceTimeout = 0;
static ULONG __DebugResetCounter = 0;
#endif // DBG

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(NONPAGE, InitHwExtWithIdentify)
#endif // ALLOC_PRAGMA

BOOLEAN
IssueIdentify(
             PIDE_REGISTERS_1    CmdBaseAddr,
             PIDE_REGISTERS_2    CtrlBaseAddr,
             IN ULONG            DeviceNumber,
             IN UCHAR            Command,
             IN BOOLEAN          InterruptOff,
             OUT PIDENTIFY_DATA  IdentifyData
             )

/*++

Routine Description:

    Issue IDENTIFY command to a device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    DeviceNumber - Indicates which device.
    Command - Either the standard (EC) or the ATAPI packet (A1) IDENTIFY.
    InterruptOff - should leave interrupt disabled

Return Value:

    TRUE if all goes well.

--*/

{
    ULONG                waitCount = 20000;
    ULONG                i,j;
    UCHAR                statusByte;
    UCHAR                signatureLow,
    signatureHigh;
    IDENTIFY_DATA        fullIdentifyData;

    RtlZeroMemory (IdentifyData, sizeof (IdentifyData));

    //
    // Select device 0 or 1.
    //
    SelectIdeDevice(CmdBaseAddr, DeviceNumber, 0);

    //
    // Check that the status register makes sense.
    //

    GetBaseStatus(CmdBaseAddr, statusByte);

    if (Command == IDE_COMMAND_IDENTIFY) {

        //
        // Mask status byte ERROR bits.
        //

        CLRMASK (statusByte, IDE_STATUS_ERROR | IDE_STATUS_INDEX);

        DebugPrint((1,
                    "IssueIdentify: Checking for IDE. Status (%x)\n",
                    statusByte));

        //
        // Check if register value is reasonable.
        //

        if (statusByte != IDE_STATUS_IDLE) {

            //
            // Reset the controller.
            //
            IdeHardReset (
                         CmdBaseAddr,
                         CtrlBaseAddr,
                         InterruptOff,
                         TRUE
                         );

            SelectIdeDevice(CmdBaseAddr, DeviceNumber, 0);

            //
            // Another check for signature, to deal with one model Atapi that doesn't assert signature after
            // a soft reset.
            //

            signatureLow = IdePortInPortByte(CmdBaseAddr->CylinderLow);
            signatureHigh = IdePortInPortByte(CmdBaseAddr->CylinderHigh);

            if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                //
                // Device is Atapi.
                //

                return FALSE;
            }

            if (Is98LegacyIde(CmdBaseAddr)) {

                AtapiSoftReset(CmdBaseAddr, CtrlBaseAddr, DeviceNumber, TRUE);

                WaitOnBusy(CmdBaseAddr, statusByte);

                if (!(statusByte & IDE_STATUS_ERROR)) {

                    //
                    // Device is WD-Mode cdrom.
                    //

                    return FALSE;
                }
            }

            GetBaseStatus(CmdBaseAddr, statusByte);
            CLRMASK (statusByte, IDE_STATUS_INDEX);

            if (statusByte != IDE_STATUS_IDLE) {

                //
                // Give up on this.
                //

                return FALSE;
            }

        }

    } else {

        DebugPrint((1,
                    "IssueIdentify: Checking for ATAPI. Status (%x)\n",
                    statusByte));

    }

    //
    // Load CylinderHigh and CylinderLow with number bytes to transfer.
    //

    IdePortOutPortByte(CmdBaseAddr->CylinderHigh, (0x200 >> 8));
    IdePortOutPortByte(CmdBaseAddr->CylinderLow,  (0x200 & 0xFF));

    for (j = 0; j < 2; j++) {

        //
        // Send IDENTIFY command.
        //

        WaitOnBusy(CmdBaseAddr,statusByte);

        IdePortOutPortByte(CmdBaseAddr->Command, Command);

        WaitOnBusy(CmdBaseAddr,statusByte);

        if (statusByte & IDE_STATUS_ERROR) {

            continue;
        }

        //
        // Wait for DRQ.
        //

        for (i = 0; i < 4; i++) {

            WaitForDrq(CmdBaseAddr, statusByte);

            if (statusByte & IDE_STATUS_DRQ) {

                //
                // Read status to acknowledge any interrupts generated.
                //

                GetBaseStatus(CmdBaseAddr, statusByte);

                //
                // One last check for Atapi.
                //


                signatureLow = IdePortInPortByte(CmdBaseAddr->CylinderLow);
                signatureHigh = IdePortInPortByte(CmdBaseAddr->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    //
                    // Device is Atapi.
                    //

                    return FALSE;
                }

                break;
            }

            if (Command == IDE_COMMAND_IDENTIFY) {

                //
                // Check the signature. If DRQ didn't come up it's likely Atapi.
                //

                signatureLow = IdePortInPortByte(CmdBaseAddr->CylinderLow);
                signatureHigh = IdePortInPortByte(CmdBaseAddr->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    //
                    // Device is Atapi.
                    //

                    return FALSE;
                }

                if (Is98LegacyIde(CmdBaseAddr)) {

                    AtapiSoftReset(CmdBaseAddr, CtrlBaseAddr, DeviceNumber, TRUE);

                    WaitOnBusy(CmdBaseAddr, statusByte);

                    if (!(statusByte & IDE_STATUS_ERROR)) {

                        //
                        // Device is WD-Mode cdrom.
                        //

                        return FALSE;
                    }
                }
            }

            WaitOnBusy(CmdBaseAddr,statusByte);
        }

        if (i == 4 && j == 0) {

            //
            // Device didn't respond correctly. It will be given one more chances.
            //

            DebugPrint((1,
                        "IssueIdentify: DRQ never asserted (%x). Error reg (%x)\n",
                        statusByte,
                        IdePortInPortByte(CmdBaseAddr->Error)));

            AtapiSoftReset(CmdBaseAddr, CtrlBaseAddr, DeviceNumber, InterruptOff);

            GetStatus(CmdBaseAddr,statusByte);

            DebugPrint((1,
                        "IssueIdentify: Status after soft reset (%x)\n",
                        statusByte));

        } else {

            break;

        }
    }

    //
    // Check for error on really bad master devices that assert random
    // patterns of bits in the status register at the slave address.
    //
    if (statusByte & IDE_STATUS_ERROR) {
        return FALSE;
    }


    DebugPrint((1,
                "IssueIdentify: Status before read words %x\n",
                statusByte));

    //
    // pull out 256 words. After waiting for one model that asserts busy
    // after receiving the Packet Identify command.
    //

    WaitOnBusy(CmdBaseAddr,statusByte);

    if (!(statusByte & IDE_STATUS_DRQ)) {
        return FALSE;
    }

    if (Is98LegacyIde(CmdBaseAddr)) {
        //
        // Delay(10ms) for ATAPI CD-ROM device.
        //

        if (Command == IDE_COMMAND_ATAPI_IDENTIFY) {
            for (i = 0; i < 100; i++) {
                KeStallExecutionProcessor(100);
            }
        }
    }

    ReadBuffer(CmdBaseAddr,
               (PUSHORT)&fullIdentifyData,
               sizeof (fullIdentifyData) / 2);

    RtlMoveMemory(IdentifyData,&fullIdentifyData,sizeof(*IdentifyData));

    WaitOnBusy(CmdBaseAddr,statusByte);

    for (i = 0; i < 0x10000; i++) {

        GetStatus(CmdBaseAddr,statusByte);

        if (statusByte & IDE_STATUS_DRQ) {

            //
            // pull out any remaining bytes and throw away.
            //

            READ_PORT_USHORT(CmdBaseAddr->Data);

        } else {

            break;

        }
    }

    DebugPrint((3,
                "IssueIdentify: Status after read words (%x)\n",
                statusByte));

    return TRUE;

} // end IssueIdentify()

VOID
InitDeviceGeometry(
                  PHW_DEVICE_EXTENSION HwDeviceExtension,
                  ULONG                Device,
                  ULONG                NumberOfCylinders,
                  ULONG                NumberOfHeads,
                  ULONG                SectorsPerTrack
                  )
{

    ASSERT (HwDeviceExtension);
    ASSERT (Device < HwDeviceExtension->MaxIdeDevice);
    ASSERT (NumberOfCylinders);
    ASSERT (NumberOfHeads);
    ASSERT (SectorsPerTrack);

    HwDeviceExtension->NumberOfCylinders[Device] = NumberOfCylinders;
    HwDeviceExtension->NumberOfHeads[Device]     = NumberOfHeads;
    HwDeviceExtension->SectorsPerTrack[Device]   = SectorsPerTrack;

    return;
}

VOID
InitHwExtWithIdentify(
                     IN PVOID           HwDeviceExtension,
                     IN ULONG           DeviceNumber,
                     IN UCHAR           Command,
                     IN PIDENTIFY_DATA  IdentifyData,
                     IN BOOLEAN         RemovableMedia
                     )

/*++

Routine Description:

    Issue IDENTIFY command to a device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    DeviceNumber - Indicates which device.
    Command - Either the standard (EC) or the ATAPI packet (A1) IDENTIFY.
    InterruptOff - should leave interrupt disabled

Return Value:

    TRUE if all goes well.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG                i,j;

    //
    // Check out a few capabilities / limitations of the device.
    //

    if (IdentifyData->MediaStatusNotification == IDENTIFY_MEDIA_STATUS_NOTIFICATION_SUPPORTED) {

        //
        // Determine if this drive supports the MSN functions.
        //

        DebugPrint((2,"InitHwExtWithIdentify: Marking drive %d as removable. SFE = %d\n",
                    DeviceNumber,
                    IdentifyData->MediaStatusNotification));

        deviceExtension->DeviceFlags[DeviceNumber] |= DFLAGS_MSN_SUPPORT;
    }


    if (RemovableMedia) {

        //
        // This device has removable media
        //

        deviceExtension->DeviceFlags[DeviceNumber] |= DFLAGS_REMOVABLE_DRIVE;
        CLRMASK (deviceExtension->DeviceFlags[DeviceNumber], DFLAGS_IDENTIFY_VALID);

        DebugPrint((2,
                    "InitHwExtWithIdentify: Device media is removable\n"));

    } else {

        DebugPrint((2,
                    "InitHwExtWithIdentify: Device media is NOT removable\n"));
    }

    if (IdentifyData->GeneralConfiguration & 0x20 &&
        Command != IDE_COMMAND_IDENTIFY) {

        //
        // This device interrupts with the assertion of DRQ after receiving
        // Atapi Packet Command
        //

        deviceExtension->DeviceFlags[DeviceNumber] |= DFLAGS_INT_DRQ;

        DebugPrint((2,
                    "InitHwExtWithIdentify: Device interrupts on assertion of DRQ.\n"));

    } else {

        DebugPrint((2,
                    "InitHwExtWithIdentify: Device does not interrupt on assertion of DRQ.\n"));
    }

    if (((IdentifyData->GeneralConfiguration & 0xF00) == 0x100) &&
        Command != IDE_COMMAND_IDENTIFY) {

        //
        // This is a tape.
        //

        deviceExtension->DeviceFlags[DeviceNumber] |= DFLAGS_TAPE_DEVICE;

        DebugPrint((2,
                    "InitHwExtWithIdentify: Device is a tape drive.\n"));

    } else {

        DebugPrint((2,
                    "InitHwExtWithIdentify: Device is not a tape drive.\n"));
    }

    return;

} // InitHwExtWithIdentify


BOOLEAN
SetDriveParameters(
                  IN PVOID HwDeviceExtension,
                  IN ULONG DeviceNumber,
                  IN BOOLEAN Sync
                  )

/*++

Routine Description:

    Set drive parameters using the IDENTIFY data.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    DeviceNumber - Indicates which device.

Return Value:

    TRUE if all goes well.


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1 = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2 = &deviceExtension->BaseIoAddress2;
    ULONG i;
    UCHAR statusByte;

    DebugPrint ((DBG_BUSSCAN, "SetDriveParameters: %s %d\n", __FILE__, __LINE__));

    DebugPrint((1,
                "SetDriveParameters: Number of heads %x\n",
                deviceExtension->NumberOfHeads[DeviceNumber]));

    DebugPrint((1,
                "SetDriveParameters: Sectors per track %x\n",
                deviceExtension->SectorsPerTrack[DeviceNumber]));
    if (deviceExtension->DeviceFlags[DeviceNumber] & DFLAGS_IDENTIFY_VALID) {

        ASSERT(!(deviceExtension->DeviceFlags[DeviceNumber] & DFLAGS_REMOVABLE_DRIVE));

        SETMASK(deviceExtension->DeviceFlags[DeviceNumber], DFLAGS_IDENTIFY_INVALID);
        CLRMASK(deviceExtension->DeviceFlags[DeviceNumber], DFLAGS_IDENTIFY_VALID);
    }

    //
    // Set up registers for SET PARAMETER command.
    //
    SelectIdeDevice(baseIoAddress1, DeviceNumber, (deviceExtension->NumberOfHeads[DeviceNumber] - 1));

    IdePortOutPortByte(baseIoAddress1->BlockCount,
                       (UCHAR)deviceExtension->SectorsPerTrack[DeviceNumber]);

    DebugPrint ((DBG_BUSSCAN, "SetDriveParameters: %s %d\n", __FILE__, __LINE__));

    //
    // Send SET PARAMETER command.
    //
    IdePortOutPortByte(baseIoAddress1->Command,
                       IDE_COMMAND_SET_DRIVE_PARAMETERS);

    DebugPrint ((DBG_BUSSCAN, "SetDriveParameters: %s %d\n", __FILE__, __LINE__));

    if (Sync) {

        DebugPrint ((DBG_BUSSCAN, "SetDriveParameters: %s %d\n", __FILE__, __LINE__));

        //
        // Wait for ERROR or command complete.
        //
        WaitOnBusy(baseIoAddress1,statusByte);

        DebugPrint ((DBG_BUSSCAN, "SetDriveParameters: %s %d\n", __FILE__, __LINE__));

        if (statusByte & IDE_STATUS_BUSY) {

            return FALSE;

        } else {

            if (statusByte & IDE_STATUS_ERROR) {

                UCHAR errorByte;

                errorByte = IdePortInPortByte(baseIoAddress1->Error);
                DebugPrint((1,
                            "SetDriveParameters: Error bit set. Status %x, error %x\n",
                            errorByte,
                            statusByte));

                return FALSE;

            } else {

                return TRUE;
            }
        }

    } else {

        return TRUE;
    }

} // end SetDriveParameters()


BOOLEAN
AtapiResetController(
                    IN PVOID  HwDeviceExtension,
                    IN ULONG  PathId,
                    IN PULONG CallAgain
                    )

/*++

Routine Description:

    Reset IDE controller and/or Atapi device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Nothing.


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1 baseIoAddress1;
    PIDE_REGISTERS_2 baseIoAddress2;
    BOOLEAN result = FALSE;
    ULONG i;
    UCHAR statusByte;
    ULONG numStates;
    BOOLEAN  enumProbing = FALSE;
    ULONG lineNumber, deviceNumber;
    BOOLEAN setResetFinalState; 

    baseIoAddress1 = &deviceExtension->BaseIoAddress1;
    baseIoAddress2 = &deviceExtension->BaseIoAddress2;

    if (*CallAgain == 0) {

#if DBG
        __DebugResetCounter = 0;
#endif

        // build state table

        numStates = 0;
        setResetFinalState = FALSE;

        for (lineNumber = 0; lineNumber < (deviceExtension->MaxIdeDevice/MAX_IDE_DEVICE); lineNumber++) {

            if (Is98LegacyIde(baseIoAddress1)) {
                if (!(deviceExtension->DeviceFlags[lineNumber * MAX_IDE_DEVICE] & DFLAGS_DEVICE_PRESENT)) {
                    continue;
                }
            }

            deviceExtension->ResetState.DeviceNumber[numStates] = lineNumber * MAX_IDE_DEVICE;
            deviceExtension->ResetState.State[numStates++] = IdeResetBegin;

            deviceExtension->ResetState.DeviceNumber[numStates] = lineNumber * MAX_IDE_DEVICE;
            deviceExtension->ResetState.State[numStates++] = ideResetBusResetInProgress;

            for (i = 0; i < MAX_IDE_DEVICE; i++) {

                deviceNumber = (lineNumber * MAX_IDE_DEVICE) + i;

                if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {

                    if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_ATAPI_DEVICE) {

                        deviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
                        deviceExtension->ResetState.State[numStates++] = ideResetAtapiReset;

                        deviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
                        deviceExtension->ResetState.State[numStates++] = ideResetAtapiResetInProgress;

                        deviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
                        deviceExtension->ResetState.State[numStates++] = ideResetAtapiIdentifyData;
                    } else {

                        deviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
                        deviceExtension->ResetState.State[numStates++] = ideResetAtaIDP;

                        deviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
                        deviceExtension->ResetState.State[numStates++] = ideResetAtaIDPInProgress;

                        deviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
                        deviceExtension->ResetState.State[numStates++] = ideResetAtaMSN;
                    }
                }

                setResetFinalState = TRUE;
            }
        }

        if (setResetFinalState) {

            deviceExtension->ResetState.DeviceNumber[numStates] = 0;
            deviceExtension->ResetState.State[numStates++] = ideResetFinal;
        }
        ASSERT (numStates <= RESET_STATE_TABLE_LEN);
    }

    SelectIdeLine (baseIoAddress1,((deviceExtension->ResetState.DeviceNumber[*CallAgain] >> 1) == 0)?0:1);

    DebugPrint ((DBG_RESET,
                 "AtapiResetController CallAgain = 0x%x, device = 0x%x, busyCount = 0x%x\n",
                 *CallAgain,
                 deviceExtension->ResetState.DeviceNumber[*CallAgain],
                 deviceExtension->ResetState.WaitBusyCount
                ));

    switch (deviceExtension->ResetState.State[*CallAgain]) {
    
    case IdeResetBegin:
        DebugPrint((DBG_RESET,
                    "AtapiResetController: Reset 0x%x IDE...\n",
                    deviceExtension->BaseIoAddress1.RegistersBaseAddress));

        if (Is98LegacyIde(baseIoAddress1) && !(deviceExtension->ResetState.DeviceNumber[*CallAgain] & 0x2)) {
            UCHAR driveHeadReg;

            SelectIdeDevice(baseIoAddress1, deviceExtension->ResetState.DeviceNumber[*CallAgain], 0);
            driveHeadReg = IdePortInPortByte(baseIoAddress1->DriveSelect);

            if (driveHeadReg != ((deviceExtension->ResetState.DeviceNumber[*CallAgain] & 0x1) << 4 | 0xA0)) {
                //
                // Select the secondary line, when there is no primary line.
                //
                SelectIdeLine (baseIoAddress1, 1);
                GetStatus(baseIoAddress1,statusByte);
            }
        }

        //
        // Check if request is in progress.
        //

        if (deviceExtension->CurrentSrb) {

            enumProbing = TestForEnumProbing (deviceExtension->CurrentSrb);

            if ((deviceExtension->CurrentSrb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) ||
                (deviceExtension->CurrentSrb->Function == SRB_FUNCTION_ATA_PASS_THROUGH)) {

                PATA_PASS_THROUGH    ataPassThroughData;

                ataPassThroughData = deviceExtension->CurrentSrb->DataBuffer;

                AtapiTaskRegisterSnapshot (baseIoAddress1, &ataPassThroughData->IdeReg);
            }

            //
            // Complete outstanding request with SRB_STATUS_BUS_RESET.
            //

            IdePortCompleteRequest(deviceExtension,
                                   deviceExtension->CurrentSrb,
                                   (ULONG)SRB_STATUS_BUS_RESET);

            //
            // Clear request tracking fields.
            //

            deviceExtension->CurrentSrb = NULL;
            deviceExtension->BytesLeft = 0;
            deviceExtension->DataBuffer = NULL;

            //
            // Indicate ready for next request.
            //

            IdePortNotification(IdeNextRequest,
                                deviceExtension,
                                NULL);

        }

        //
        // Clear DMA
        //
        if (deviceExtension->DMAInProgress) {
            deviceExtension->DMAInProgress = FALSE;
            deviceExtension->BusMasterInterface.BmDisarm (deviceExtension->BusMasterInterface.Context);
        }

        //
        // Clear expecting interrupt flag.
        //

        deviceExtension->ExpectingInterrupt = FALSE;
        deviceExtension->RDP = FALSE;

        if (!enumProbing) {

            //
            // ATA soft reset.  reset only ATA devices
            //
            IdeHardReset (
                         baseIoAddress1,
                         baseIoAddress2,
                         TRUE,
                         FALSE
                         );
            (*CallAgain)++;
            deviceExtension->ResetState.WaitBusyCount = 0;

            //
            // go to the next stage if a short wait satisfies the 
            // requirement
            //
            GetStatus(baseIoAddress1,statusByte);

            WaitOnBusyUntil(baseIoAddress1, statusByte, 200);

            if (statusByte & IDE_STATUS_BUSY) {

                return TRUE;

            } else {

                return AtapiResetController(
                                           HwDeviceExtension,
                                           PathId,
                                           CallAgain
                                           );
            }

        } else {

            //
            // timeout is caused by a command sent to a non-existing device
            // no need to reset
            //
            *CallAgain = 0;
        }

        return TRUE;
        break;

        //
        // all these states waits for BUSY to go clear
        // then go to the next state
        //

    case ideResetBusResetInProgress:

        if (Is98LegacyIde(baseIoAddress1) && !(deviceExtension->ResetState.DeviceNumber[*CallAgain] & 0x2)) {
            UCHAR driveHeadReg;

            SelectIdeDevice(baseIoAddress1, deviceExtension->ResetState.DeviceNumber[*CallAgain], 0);
            driveHeadReg = IdePortInPortByte(baseIoAddress1->DriveSelect);

            if (driveHeadReg != ((deviceExtension->ResetState.DeviceNumber[*CallAgain] & 0x1) << 4 | 0xA0)) {
                //
                // Select the secondary line, when there is no primary line.
                //
                SelectIdeLine (baseIoAddress1, 1);
            }
        }

        //
        // select the slave when there is no master
        //
        if (!(deviceExtension->DeviceFlags[deviceExtension->ResetState.DeviceNumber[*CallAgain]] & 
              DFLAGS_DEVICE_PRESENT)) {
            SelectIdeDevice(baseIoAddress1, (deviceExtension->ResetState.DeviceNumber[*CallAgain] | 0x1), 0);
        }
    case ideResetAtapiResetInProgress:
    case ideResetAtaIDPInProgress:
        GetStatus(baseIoAddress1,statusByte);
        if (statusByte & IDE_STATUS_BUSY) {

            deviceExtension->ResetState.WaitBusyCount++;

            if ((deviceExtension->ResetState.WaitBusyCount > 30) ||
                (statusByte == 0xff)) {

                UCHAR deviceSelect = IdePortInPortByte(baseIoAddress1->DriveSelect);

                //
                // reset fails
                //
                DebugPrint ((DBG_ALWAYS, "ATAPI ResetController: ATA soft reset fails\n"));

//                if ((statusByte == 0xff) && (deviceSelect == 0xff)) {
//
//                    ULONG i;
//
//                    DebugPrint ((
//                        DBG_ALWAYS, 
//                        "ATAPI: ide Channel 0x%x is gone!!\n", 
//                        baseIoAddress1->RegistersBaseAddress
//                        ));
//
//                    for (i=0; i<deviceExtension->MaxIdeDevice; i++) {
//
//                        deviceExtension->DeviceFlags[i] &= ~DFLAGS_DEVICE_PRESENT;
//                    }
//                }

                if (IdePortChannelEmpty (baseIoAddress1, 
                                         baseIoAddress2, deviceExtension->MaxIdeDevice)) {

                    IdePortNotification(IdeAllDeviceMissing,
                                        deviceExtension,
                                        NULL);
                    *CallAgain = 0;
                    IdePortOutPortByte (baseIoAddress2->DeviceControl, IDE_DC_REENABLE_CONTROLLER);
                    return TRUE;
                }

                //
                // no choice, but continue with the reset
                //
//                *CallAgain = 0;
//                IdePortOutPortByte (baseIoAddress2, IDE_DC_REENABLE_CONTROLLER);
//                return FALSE;

            } else {

                DebugPrint ((DBG_ALWAYS, "ATAPI: ResetController not ready (status = 0x%x) ...wait for 1 sec\n", statusByte));
                return TRUE;
            }
        }

        (*CallAgain)++;
        return AtapiResetController(
                                   HwDeviceExtension,
                                   PathId,
                                   CallAgain
                                   );
        break;

    case ideResetAtapiReset:
        SelectIdeDevice(baseIoAddress1, deviceExtension->ResetState.DeviceNumber[*CallAgain], 0);
        IdePortOutPortByte(baseIoAddress1->Command, IDE_COMMAND_ATAPI_RESET);
        deviceExtension->ResetState.WaitBusyCount = 0;
        (*CallAgain)++;

        //
        // go to the next stage if a short wait satisfies the 
        // requirement
        //
        GetStatus(baseIoAddress1,statusByte);

        WaitOnBusyUntil(baseIoAddress1, statusByte, 200);

        if (statusByte & IDE_STATUS_BUSY) {

            return TRUE;

        } else {

            return AtapiResetController(
                                       HwDeviceExtension,
                                       PathId,
                                       CallAgain
                                       );
        }

        return TRUE;
        break;

    case ideResetAtaIDP:
        if (!Is98LegacyIde(baseIoAddress1)) {
            SetDriveParameters(HwDeviceExtension,
                               deviceExtension->ResetState.DeviceNumber[*CallAgain],
                               FALSE);
        }
        deviceExtension->ResetState.WaitBusyCount = 0;
        (*CallAgain)++;

        //
        // go to the next stage if a short wait satisfies the 
        // requirement
        //
        GetStatus(baseIoAddress1,statusByte);

        WaitOnBusyUntil(baseIoAddress1, statusByte, 200);

        if (statusByte & IDE_STATUS_BUSY) {

            return TRUE;

        } else {

            return AtapiResetController(
                                       HwDeviceExtension,
                                       PathId,
                                       CallAgain
                                       );
        }

        return TRUE;
        break;

    case ideResetAtapiIdentifyData:

        //
        // the device shouldn't be busy at this point
        //
        SelectIdeDevice(&deviceExtension->BaseIoAddress1,
                        deviceExtension->ResetState.DeviceNumber[*CallAgain],
                        0
                       );

        WaitOnBusyUntil(&deviceExtension->BaseIoAddress1,
                        statusByte,
                        100
                       );

        //
        // issue identify command only if the device is not
        // already busy
        //
        if (!(statusByte & IDE_STATUS_BUSY)) {

            GetAtapiIdentifyQuick( &deviceExtension->BaseIoAddress1,
                                   &deviceExtension->BaseIoAddress2,
                                   deviceExtension->ResetState.DeviceNumber[*CallAgain],
                                   &deviceExtension->IdentifyData[deviceExtension->ResetState.DeviceNumber[*CallAgain]]
                                   );

            /*
            IssueIdentify(
                         &deviceExtension->BaseIoAddress1,
                         &deviceExtension->BaseIoAddress2,
                         deviceExtension->ResetState.DeviceNumber[*CallAgain],
                         IDE_COMMAND_ATAPI_IDENTIFY,
                         FALSE,
                         &deviceExtension->IdentifyData[deviceExtension->ResetState.DeviceNumber[*CallAgain]]
                         );
                         */

        }

//        InitHwExtWithIdentify(
//            HwDeviceExtension,
//            deviceExtension->ResetState.DeviceNumber[*CallAgain],
//            IDE_COMMAND_ATAPI_IDENTIFY,
//            &deviceExtension->IdentifyData[deviceExtension->ResetState.DeviceNumber[*CallAgain]]
//            );
        (*CallAgain)++;
        return AtapiResetController(
                                   HwDeviceExtension,
                                   PathId,
                                   CallAgain
                                   );
        break;

    case ideResetAtaMSN:
        IdeMediaStatus(
                      TRUE, 
                      HwDeviceExtension, 
                      deviceExtension->ResetState.DeviceNumber[*CallAgain]
                      );
        (*CallAgain)++;
        return AtapiResetController(
                                   HwDeviceExtension,
                                   PathId,
                                   CallAgain
                                   );
        break;

    case ideResetFinal:

        //
        // HACK: if any of the devices are busy at this point, then they should
        // be marked dead. This will anyway happen because of the timeout count.
        // However, the waitOnBusy macros in all the routines would consume upto
        // 30s leaving the sytem practically hung until the reset completes. Instead,
        // we just clear the device present flag before the routine is called and
        // restore it after that.
        //
        for (i = 0; i < (deviceExtension->MaxIdeDevice/MAX_IDE_DEVICE); i++) {

            if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT) {
                SelectIdeDevice(baseIoAddress1, i, 0);
                WaitOnBusyUntil(baseIoAddress1, statusByte, 100);

                if (statusByte & IDE_STATUS_BUSY) {
                    CLRMASK(deviceExtension->DeviceFlags[i], DFLAGS_DEVICE_PRESENT);
                    SETMASK(deviceExtension->DeviceFlags[i], DFLAGS_DEVICE_ERASED);
                }
            }
        }

        AtapiHwInitialize(HwDeviceExtension, NULL);

        //
        // Restore the device present flag
        //
        for (i = 0; i < (deviceExtension->MaxIdeDevice/MAX_IDE_DEVICE); i++) {

            if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_ERASED) {
                SETMASK(deviceExtension->DeviceFlags[i], DFLAGS_DEVICE_PRESENT);
            }
        }

        if (IdePortChannelEmpty (baseIoAddress1, 
                                 baseIoAddress2, deviceExtension->MaxIdeDevice)) {

            IdePortNotification(IdeAllDeviceMissing,
                                deviceExtension,
                                NULL);
        }
        *CallAgain = 0;
        for (i = 0; i < (deviceExtension->MaxIdeDevice/MAX_IDE_DEVICE); i++) {
            SelectIdeLine(baseIoAddress1, i);
            IdePortOutPortByte (baseIoAddress2->DeviceControl, IDE_DC_REENABLE_CONTROLLER);
        }
        return TRUE;
        break;

    default:
        ASSERT(FALSE);
        *CallAgain = 0;
        for (i = 0; i < (deviceExtension->MaxIdeDevice/MAX_IDE_DEVICE); i++) {
            SelectIdeLine(baseIoAddress1, i);
            IdePortOutPortByte (baseIoAddress2->DeviceControl, IDE_DC_REENABLE_CONTROLLER);
        }
        return FALSE;
        break;
    }
} // end AtapiResetController()



ULONG
MapError(
        IN PVOID HwDeviceExtension,
        IN PSCSI_REQUEST_BLOCK Srb
        )

/*++

Routine Description:

    This routine maps ATAPI and IDE errors to specific SRB statuses.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    ULONG i;
    UCHAR errorByte;
    UCHAR srbStatus;
    UCHAR scsiStatus;
    SENSE_DATA  tempSenseBuffer;
    PSENSE_DATA  senseBuffer = (PSENSE_DATA)&tempSenseBuffer;

    //
    // Read the error register.
    //

    //errorByte = IdePortInPortByte(baseIoAddress1->Error);
    GetErrorByte(baseIoAddress1, errorByte);

    DebugPrint((DBG_IDE_DEVICE_ERROR,
                "MapError: cdb %x and Error register is %x\n",
                Srb->Cdb[0],
                errorByte));

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

        switch (errorByte >> 4) {
        case SCSI_SENSE_NO_SENSE:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: No sense information\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_RECOVERED_ERROR:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Recovered error\n"));
            scsiStatus = 0;
            srbStatus = SRB_STATUS_SUCCESS;
            break;

        case SCSI_SENSE_NOT_READY:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Device not ready\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_MEDIUM_ERROR:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Media error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_HARDWARE_ERROR:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Hardware error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Illegal request\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_UNIT_ATTENTION:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Unit attention\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_DATA_PROTECT:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Data protect\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_BLANK_CHECK:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Blank check\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_ABORTED_COMMAND:
            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "Atapi: Command Aborted\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        default:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Invalid sense information\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;
        }

    } else {

        scsiStatus = 0;
        //
        // Save errorByte,to be used by SCSIOP_REQUEST_SENSE.
        //

        deviceExtension->ReturningMediaStatus = errorByte;

        RtlZeroMemory(senseBuffer, sizeof(SENSE_DATA));

        if (errorByte & IDE_ERROR_MEDIA_CHANGE_REQ) {
            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: Media change\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (Srb->SenseInfoBuffer) {

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
                senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_OPERATOR_REQUEST;
                senseBuffer->AdditionalSenseCodeQualifier = SCSI_SENSEQ_MEDIUM_REMOVAL;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_COMMAND_ABORTED) {

            DebugPrint((DBG_IDE_DEVICE_ERROR, "IDE: Command abort\n"));

            scsiStatus = SCSISTAT_CHECK_CONDITION;
            if ((errorByte & IDE_ERROR_CRC_ERROR) &&
                (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_UDMA) &&
                SRB_USES_DMA(Srb)) {

                DebugPrint((1, "Srb 0x%x had a CRC error using UDMA\n", Srb));

                srbStatus = SRB_STATUS_PARITY_ERROR;

                if (Srb->SenseInfoBuffer) {

                    senseBuffer->ErrorCode = 0x70;
                    senseBuffer->Valid     = 1;
                    senseBuffer->AdditionalSenseLength = 0xb;
                    senseBuffer->SenseKey =  SCSI_SENSE_HARDWARE_ERROR;
                    senseBuffer->AdditionalSenseCode = 0x8;
                    senseBuffer->AdditionalSenseCodeQualifier = 0x3;

                    srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
                }

            } else {

                srbStatus = SRB_STATUS_ABORTED;

                if (Srb->SenseInfoBuffer) {

                    senseBuffer->ErrorCode = 0x70;
                    senseBuffer->Valid     = 1;
                    senseBuffer->AdditionalSenseLength = 0xb;
                    senseBuffer->SenseKey =  SCSI_SENSE_ABORTED_COMMAND;
                    senseBuffer->AdditionalSenseCode = 0;
                    senseBuffer->AdditionalSenseCodeQualifier = 0;

                    srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
                }
            }

            deviceExtension->ErrorCount++;

        } else if (errorByte & IDE_ERROR_END_OF_MEDIA) {

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: End of media\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (Srb->SenseInfoBuffer) {

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_NOT_READY;
                senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_NO_MEDIA_IN_DEVICE;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }
            if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)) {
                deviceExtension->ErrorCount++;
            }

        } else if (errorByte & IDE_ERROR_ILLEGAL_LENGTH) {

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: Illegal length\n"));
            srbStatus = SRB_STATUS_INVALID_REQUEST;

        } else if (errorByte & IDE_ERROR_BAD_BLOCK) {

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: Bad block\n"));
            srbStatus = SRB_STATUS_ERROR;
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            if (Srb->SenseInfoBuffer) {

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_HARDWARE_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_ID_NOT_FOUND) {

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: Id not found\n"));
            srbStatus = SRB_STATUS_ERROR;
            scsiStatus = SCSISTAT_CHECK_CONDITION;

            if (Srb->SenseInfoBuffer) {

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_ILLEGAL_REQUEST;
                senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_ILLEGAL_BLOCK;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

            deviceExtension->ErrorCount++;

        } else if (errorByte & IDE_ERROR_MEDIA_CHANGE) {

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: Media change\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (Srb->SenseInfoBuffer) {

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
                senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_DATA_ERROR) {

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: Data error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)) {
                deviceExtension->ErrorCount++;
            }

            //
            // Build sense buffer
            //

            if (Srb->SenseInfoBuffer) {

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey = (deviceExtension->
                                         DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE)? SCSI_SENSE_DATA_PROTECT : SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }
        } else { // no sense info

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IdePort: No sense information\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
        }

        if (senseBuffer->Valid == 1) {

            ULONG length = sizeof(SENSE_DATA);

            if (Srb->SenseInfoBufferLength < length ) {

               length = Srb->SenseInfoBufferLength;
            }

            ASSERT(length);
            ASSERT(Srb->SenseInfoBuffer);

            RtlCopyMemory(Srb->SenseInfoBuffer, (PVOID) senseBuffer, length);
        }

        if ((deviceExtension->ErrorCount >= MAX_ERRORS) &&
            (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA))) {

            deviceExtension->MaximumBlockXfer[Srb->TargetId] = 0;

            DebugPrint((DBG_ALWAYS,
                        "MapError: Disabling 32-bit PIO and Multi-sector IOs\n"));

            if (deviceExtension->ErrorCount == MAX_ERRORS) {

                //
                // Log the error.
                //

                IdePortLogError( HwDeviceExtension,
                                 Srb,
                                 Srb->PathId,
                                 Srb->TargetId,
                                 Srb->Lun,
                                 SP_BAD_FW_WARNING,
                                 4);
            }

            //
            // Reprogram to not use Multi-sector.
            //

            for (i = 0; i < deviceExtension->MaxIdeDevice; i++) {
                UCHAR statusByte;

                if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT &&
                    !(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                    //
                    // Select the device.
                    //
                    SelectIdeDevice(baseIoAddress1, i, 0);

                    //
                    // Setup sector count to reflect the # of blocks.
                    //

                    IdePortOutPortByte(baseIoAddress1->BlockCount,
                                       0);

                    //
                    // Issue the command.
                    //

                    IdePortOutPortByte(baseIoAddress1->Command,
                                       IDE_COMMAND_SET_MULTIPLE);

                    //
                    // Wait for busy to drop.
                    //

                    WaitOnBaseBusy(baseIoAddress1,statusByte);

                    //
                    // Check for errors. Reset the value to 0 (disable MultiBlock) if the
                    // command was aborted.
                    //

                    if (statusByte & IDE_STATUS_ERROR) {

                        //
                        // Read the error register.
                        //

                        errorByte = IdePortInPortByte(baseIoAddress1->Error);

                        DebugPrint((DBG_ALWAYS,
                                    "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
                                    statusByte,
                                    errorByte));
                        //
                        // Adjust the devExt. value, if necessary.
                        //

                        deviceExtension->MaximumBlockXfer[i] = 0;

                    }
                    deviceExtension->DeviceParameters[i].IdePioReadCommand      = IDE_COMMAND_READ;
                    deviceExtension->DeviceParameters[i].IdePioWriteCommand     = IDE_COMMAND_WRITE;

#ifdef ENABLE_48BIT_LBA
                    if (deviceExtension->DeviceFlags[i] & DFLAGS_48BIT_LBA) {
                        deviceExtension->DeviceParameters[i].IdePioReadCommandExt = IDE_COMMAND_READ_EXT;
                        deviceExtension->DeviceParameters[i].IdePioWriteCommandExt = IDE_COMMAND_WRITE_EXT;
                    }
#endif
                    deviceExtension->DeviceParameters[i].MaxBytePerPioInterrupt = 512;
                    deviceExtension->MaximumBlockXfer[i] = 0;
                }
            }
        }
    }


    //
    // Set SCSI status to indicate a check condition.
    //

    Srb->ScsiStatus = scsiStatus;

    return srbStatus;

} // end MapError()

NTSTATUS
AtapiSetTransferMode (
                     PHW_DEVICE_EXTENSION DeviceExtension,
                     ULONG                DeviceNumber,
                     UCHAR                ModeValue
                     )
{

    PIDE_REGISTERS_1    baseIoAddress1 = &DeviceExtension->BaseIoAddress1;
    UCHAR               ideStatus; 

    if (DeviceExtension->CurrentSrb) {
        DebugPrint ((DBG_ALWAYS, "DeviceExtension->CurrentSrb = 0x%x\n", DeviceExtension->CurrentSrb));
        ASSERT(DeviceExtension->CurrentSrb == NULL);
    }
    ASSERT (DeviceExtension->ExpectingInterrupt == FALSE);

    if (Is98LegacyIde(baseIoAddress1)) {

        if ( !EnhancedIdeSupport() ) {

            DebugPrint((1,"atapi: AtapiSetTransferMode -  not enhanced-ide.\n"));
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        if (DeviceExtension->DeviceFlags[DeviceNumber] & DFLAGS_WD_MODE) {
            //
            // WD-Mode cd-rom can not set transfer mode.
            //

            DebugPrint((1,"atapi: AtapiSetTransferMode -  not enhanced-ide.\n"));
            return STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    SelectIdeDevice(baseIoAddress1, DeviceNumber, 0);

    WaitOnBusy(baseIoAddress1, ideStatus);

    IdePortOutPortByte(
                      baseIoAddress1->Error,
                      IDE_SET_FEATURE_SET_TRANSFER_MODE
                      );

    IdePortOutPortByte(
                      baseIoAddress1->BlockCount,
                      ModeValue
                      );

    IdePortOutPortByte(
                      baseIoAddress1->Command,
                      IDE_COMMAND_SET_FEATURE
                      );

    WaitOnBusy(baseIoAddress1, ideStatus);

    if (ideStatus & (IDE_STATUS_BUSY | IDE_STATUS_ERROR)) {

        return STATUS_INVALID_DEVICE_REQUEST;

    } else {

        return STATUS_SUCCESS;
    }
}



VOID
AtapiProgramTransferMode (
                         PHW_DEVICE_EXTENSION DeviceExtension
                         )
{
    ULONG                       i;

    for (i=0; i<DeviceExtension->MaxIdeDevice; i++) {

        UCHAR ideCommand;
        ULONG pioModeStatus;
        ULONG dmaModeStatus;
        ULONG xferMode;

        if (!(DeviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT)) {

            continue;
        }

        DebugPrint((DBG_XFERMODE, "ATAPI: ProgramTransferMode device %x- TMSelected = 0x%x\n",
                    i,
                    DeviceExtension->DeviceParameters[i].TransferModeSelected));

        CLRMASK (DeviceExtension->DeviceFlags[i], DFLAGS_USE_DMA | DFLAGS_USE_UDMA);

        if (!DeviceExtension->NoPioSetTransferMode) {

            //
            // many old devices just don't support set transfer mode
            // they act unpredictably after receiving one
            // e.g. "SAMSUNG SCR-730 REV D-05" cdrom will start returning
            // no error on TEST_UNIT_READY even if it doesn't have a media
            // 
            // we are going to apply some magic code here!!
            // we would not set transfer mode if the device doesn't support
            // timing faster than mode2
            //
            GetHighestPIOTransferMode(DeviceExtension->DeviceParameters[i].TransferModeSelected, xferMode);

            if (xferMode > PIO2) {

                DebugPrint((DBG_XFERMODE, "ATAPI: device %x, setting PIOmode 0x%x\n",
                            i,
                            xferMode));

                ideCommand = IDE_SET_ADVANCE_PIO_MODE(xferMode-PIO0);

                pioModeStatus = AtapiSetTransferMode (
                                                     DeviceExtension,
                                                     i, 
                                                     ideCommand
                                                     );
                if (!NT_SUCCESS(pioModeStatus)) {

                    DebugPrint ((DBG_ALWAYS, 
                                 "ATAPI: Unable to set pio xfer mode %d for 0x%x device %d\n", 
                                 xferMode,
                                 DeviceExtension->BaseIoAddress1.RegistersBaseAddress,
                                 i));
                }
            }
        }

        //
        // Program DMA mode
        //
        GetHighestDMATransferMode(DeviceExtension->DeviceParameters[i].TransferModeSelected, xferMode);


        if (xferMode >= UDMA0) {

            ideCommand = IDE_SET_UDMA_MODE(xferMode-UDMA0);

        } else if (xferMode >= MWDMA0) {

            ideCommand = IDE_SET_MWDMA_MODE(xferMode-MWDMA0);

        } else if (xferMode >= SWDMA0) {

            ideCommand = IDE_SET_SWDMA_MODE(xferMode-SWDMA0);

        }

        //
        // Issue the set features command only if we support
        // any of the DMA modes
        //
        if (xferMode >= SWDMA0) {

            DebugPrint((DBG_XFERMODE, "ATAPI: device %x, setting DMAmode 0x%x\n",
                        i,
                        xferMode));

            dmaModeStatus = AtapiSetTransferMode (
                                                 DeviceExtension,
                                                 i, 
                                                 ideCommand
                                                 );
            if (NT_SUCCESS(dmaModeStatus)) {

                DeviceExtension->DeviceFlags[i] |= DFLAGS_USE_DMA;

                if (xferMode >= UDMA0) {
                    DeviceExtension->DeviceFlags[i] |= DFLAGS_USE_UDMA;
                }

            } else {

                DebugPrint ((DBG_ALWAYS, 
                             "ATAPI: Unable to set DMA mode %d for  0x%x device %d\n",
                             xferMode,
                             DeviceExtension->BaseIoAddress1.RegistersBaseAddress,
                             i));
            }
        }
    }
    return;
}



BOOLEAN
AtapiHwInitialize(
                 IN PVOID HwDeviceExtension,
                 IN UCHAR FlushCommand[MAX_IDE_DEVICE * MAX_IDE_LINE]
                 )

/*++

Routine Description:

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress;
    ULONG i;
    UCHAR statusByte, errorByte;

    baseIoAddress = &deviceExtension->BaseIoAddress1;

    for (i = 0; i < deviceExtension->MaxIdeDevice; i++) {
        if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT) {

            //
            // Select device
            //
            SelectIdeDevice(baseIoAddress, i, 0);

            //
            // Make sure device is ready for any command
            //
            if (!(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                WaitForDRDY(baseIoAddress, statusByte);
            }

            if (!(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                //
                // Enable media status notification
                //

                IdeMediaStatus(TRUE,HwDeviceExtension,i);

                //
                // If supported, setup Multi-block transfers.
                //
                if (deviceExtension->MaximumBlockXfer[i]) {

                    //
                    // Select the device.
                    //
                    SelectIdeDevice(baseIoAddress, i, 0);

                    //
                    // Setup sector count to reflect the # of blocks.
                    //

                    IdePortOutPortByte(baseIoAddress->BlockCount,
                                       deviceExtension->MaximumBlockXfer[i]);

                    //
                    // Issue the command.
                    //

                    IdePortOutPortByte(baseIoAddress->Command,
                                       IDE_COMMAND_SET_MULTIPLE);

                    //
                    // Wait for busy to drop.
                    //

                    WaitOnBaseBusy(baseIoAddress,statusByte);

                    //
                    // Check for errors. Reset the value to 0 (disable MultiBlock) if the
                    // command was aborted.
                    //

                    if (statusByte & IDE_STATUS_ERROR) {

                        //
                        // Read the error register.
                        //

                        errorByte = IdePortInPortByte(baseIoAddress->Error);

                        DebugPrint((1,
                                    "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
                                    statusByte,
                                    errorByte));
                        //
                        // Adjust the devExt. value, if necessary.
                        //

                        deviceExtension->MaximumBlockXfer[i] = 0;

                    } else {
                        DebugPrint((2,
                                    "AtapiHwInitialize: Using Multiblock on Device %d. Blocks / int - %d\n",
                                    i,
                                    deviceExtension->MaximumBlockXfer[i]));
                    }
                }
            }

            // IdeMediaStatus(TRUE,HwDeviceExtension,i);

            //
            // We need to get our device ready for action before
            // returning from this function
            //
            // According to the atapi spec 2.5 or 2.6, an atapi device
            // clears its status BSY bit when it is ready for atapi commands.
            // However, some devices (Panasonic SQ-TC500N) are still
            // not ready even when the status BSY is clear.  They don't react
            // to atapi commands.
            //
            // Since there is really no other indication that tells us
            // the drive is really ready for action.  We are going to check BSY
            // is clear and then just wait for an arbitrary amount of time!  At
            // least for the older ATAPI changers.
            //
            if (deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE) {
                PIDE_REGISTERS_1     baseIoAddress1 = &deviceExtension->BaseIoAddress1;
                PIDE_REGISTERS_2     baseIoAddress2 = &deviceExtension->BaseIoAddress2;
                ULONG waitCount;

                // have to get out of the loop sometime!
                // 10000 * 100us = 1000,000us = 1000ms = 1s
                waitCount = 10000;
                GetStatus(baseIoAddress1, statusByte);
                while ((statusByte & IDE_STATUS_BUSY) && waitCount) {
                    //
                    // Wait for Busy to drop.
                    //
                    KeStallExecutionProcessor(100);
                    GetStatus(baseIoAddress1, statusByte);
                    waitCount--;
                }
            }
        }
    }

    AtapiProgramTransferMode (deviceExtension);

    InitDeviceParameters (HwDeviceExtension, FlushCommand);

    return TRUE;

} // end AtapiHwInitialize()


VOID
AtapiHwInitializeMultiLun (
                          IN PVOID HwDeviceExtension,
                          IN ULONG TargetId,
                          IN ULONG numSlot
                          )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;

    deviceExtension->DeviceFlags[TargetId] |= DFLAGS_MULTI_LUN_INITED;

    deviceExtension->LastLun[TargetId] = (numSlot == 0) ? 0 : (numSlot - 1);

    return;
}

#ifdef DRIVER_PARAMETER_REGISTRY_SUPPORT

ULONG
AtapiParseArgumentString(
                        IN PCHAR String,
                        IN PCHAR KeyWord
                        )

/*++

Routine Description:

    This routine will parse the string for a match on the keyword, then
    calculate the value for the keyword and return it to the caller.

Arguments:

    String - The ASCII string to parse.
    KeyWord - The keyword for the value desired.

Return Values:

    Zero if value not found
    Value converted from ASCII to binary.

--*/

{
    PCHAR cptr;
    PCHAR kptr;
    ULONG value;
    ULONG stringLength = 0;
    ULONG keyWordLength = 0;
    ULONG index;

    if (!String) {
        return 0;
    }
    if (!KeyWord) {
        return 0;
    }

    //
    // Calculate the string length and lower case all characters.
    //

    cptr = String;
    while (*cptr) {
        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        stringLength++;
    }

    //
    // Calculate the keyword length and lower case all characters.
    //

    cptr = KeyWord;
    while (*cptr) {

        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        keyWordLength++;
    }

    if (keyWordLength > stringLength) {

        //
        // Can't possibly have a match.
        //

        return 0;
    }

    //
    // Now setup and start the compare.
    //

    cptr = String;

    ContinueSearch:

    //
    // The input string may start with white space.  Skip it.
    //

    while (*cptr == ' ' || *cptr == '\t') {
        cptr++;
    }

    if (*cptr == '\0') {

        //
        // end of string.
        //

        return 0;
    }

    kptr = KeyWord;
    while (*cptr++ == *kptr++) {

        if (*(cptr - 1) == '\0') {

            //
            // end of string
            //

            return 0;
        }
    }

    if (*(kptr - 1) == '\0') {

        //
        // May have a match backup and check for blank or equals.
        //

        cptr--;
        while (*cptr == ' ' || *cptr == '\t') {
            cptr++;
        }

        //
        // Found a match.  Make sure there is an equals.
        //

        if (*cptr != '=') {

            //
            // Not a match so move to the next semicolon.
            //

            while (*cptr) {
                if (*cptr++ == ';') {
                    goto ContinueSearch;
                }
            }
            return 0;
        }

        //
        // Skip the equals sign.
        //

        cptr++;

        //
        // Skip white space.
        //

        while ((*cptr == ' ') || (*cptr == '\t')) {
            cptr++;
        }

        if (*cptr == '\0') {

            //
            // Early end of string, return not found
            //

            return 0;
        }

        if (*cptr == ';') {

            //
            // This isn't it either.
            //

            cptr++;
            goto ContinueSearch;
        }

        value = 0;
        if ((*cptr == '0') && (*(cptr + 1) == 'x')) {

            //
            // Value is in Hex.  Skip the "0x"
            //

            cptr += 2;
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                    break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (16 * value) + (*(cptr + index) - '0');
                } else {
                    if ((*(cptr + index) >= 'a') && (*(cptr + index) <= 'f')) {
                        value = (16 * value) + (*(cptr + index) - 'a' + 10);
                    } else {

                        //
                        // Syntax error, return not found.
                        //
                        return 0;
                    }
                }
            }
        } else {

            //
            // Value is in Decimal.
            //

            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                    break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (10 * value) + (*(cptr + index) - '0');
                } else {

                    //
                    // Syntax error return not found.
                    //
                    return 0;
                }
            }
        }

        return value;
    } else {

        //
        // Not a match check for ';' to continue search.
        //

        while (*cptr) {
            if (*cptr++ == ';') {
                goto ContinueSearch;
            }
        }

        return 0;
    }
}
#endif

VOID
InitDeviceParameters (
                     IN PVOID HwDeviceExtension,
                     IN UCHAR FlushCommand[MAX_IDE_DEVICE * MAX_IDE_LINE]
                     )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG deviceNumber;

    //
    // pick out the ATA or ATAPI r/w command we are going to use
    //
    for (deviceNumber = 0; deviceNumber < deviceExtension->MaxIdeDevice; deviceNumber++) {
        if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {

            DebugPrint ((DBG_BUSSCAN, "ATAPI: Base=0x%x Device %d is going to do ", deviceExtension->BaseIoAddress1.RegistersBaseAddress, deviceNumber));
            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_USE_DMA) {
                DebugPrint ((DBG_BUSSCAN, "DMA\n"));
            } else {
                DebugPrint ((DBG_BUSSCAN, "PIO\n"));
            }


            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_ATAPI_DEVICE) {

                deviceExtension->DeviceParameters[deviceNumber].MaxBytePerPioInterrupt = 512;

            } else {

                if (deviceExtension->MaximumBlockXfer[deviceNumber]) {

                    DebugPrint ((DBG_BUSSCAN, "ATAPI: ATA Device (%d) is going to do PIO Multiple\n", deviceNumber));

                    deviceExtension->DeviceParameters[deviceNumber].IdePioReadCommand = IDE_COMMAND_READ_MULTIPLE;
                    deviceExtension->DeviceParameters[deviceNumber].IdePioWriteCommand = IDE_COMMAND_WRITE_MULTIPLE;

#ifdef ENABLE_48BIT_LBA
                    if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_48BIT_LBA) {
                        deviceExtension->DeviceParameters[deviceNumber].IdePioReadCommandExt = IDE_COMMAND_READ_MULTIPLE_EXT;
                        deviceExtension->DeviceParameters[deviceNumber].IdePioWriteCommandExt = IDE_COMMAND_WRITE_MULTIPLE_EXT;
                    }
#endif

                    deviceExtension->DeviceParameters[deviceNumber].MaxBytePerPioInterrupt =
                    deviceExtension->MaximumBlockXfer[deviceNumber] * 512;
                } else {

                    DebugPrint ((DBG_BUSSCAN, "ATAPI: ATA Device (%d) is going to do PIO Single\n", deviceNumber));

                    deviceExtension->DeviceParameters[deviceNumber].IdePioReadCommand = IDE_COMMAND_READ;
                    deviceExtension->DeviceParameters[deviceNumber].IdePioWriteCommand = IDE_COMMAND_WRITE;

#ifdef ENABLE_48BIT_LBA
                    if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_48BIT_LBA) {
                        deviceExtension->DeviceParameters[deviceNumber].IdePioReadCommandExt = IDE_COMMAND_READ_EXT;
                        deviceExtension->DeviceParameters[deviceNumber].IdePioWriteCommandExt = IDE_COMMAND_WRITE_EXT;
                    }
#endif
                    deviceExtension->DeviceParameters[deviceNumber].MaxBytePerPioInterrupt = 512;
                }

                if (FlushCommand) {

                    deviceExtension->DeviceParameters[deviceNumber].IdeFlushCommand = FlushCommand[deviceNumber];

#ifdef ENABLE_48BIT_LBA
                    //
                    // if the flush command worked then we are going to assume that the flush command
                    // for the 48 bit LBA feature set is supported.
                    //
                    if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_48BIT_LBA) {
                        deviceExtension->DeviceParameters[deviceNumber].IdeFlushCommandExt = IDE_COMMAND_FLUSH_CACHE_EXT;
                        deviceExtension->DeviceParameters[deviceNumber].IdeFlushCommand = IDE_COMMAND_NO_FLUSH;
                    }
#endif
                }
            }
        }
    }
}


ULONG
Atapi2Scsi(
          IN PHW_DEVICE_EXTENSION DeviceExtension,
          IN PSCSI_REQUEST_BLOCK Srb,
          IN char *DataBuffer,
          IN ULONG ByteCount
          )
/*++

Routine Description:

    Convert atapi cdb and mode sense data to scsi format

Arguments:

    Srb         - SCSI request block
    DataBuffer  - mode sense data
    ByteCount   - mode sense data length

Return Value:

    byte adjust

--*/
{
    ULONG bytesAdjust = 0;

    if (DeviceExtension->scsi2atapi) {

        if (Srb->Cdb[0] == ATAPI_MODE_SENSE) {

            ASSERT(FALSE);

        } else if (Srb->Cdb[0] == ATAPI_LS120_FORMAT_UNIT) {

            Srb->Cdb[0] = SCSIOP_FORMAT_UNIT;
        }

        RESTORE_ORIGINAL_CDB(DeviceExtension, Srb);

        DeviceExtension->scsi2atapi = FALSE;
    }
    return bytesAdjust;
}


VOID
AtapiCallBack(
             IN PVOID HwDeviceExtension
             )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK  srb = deviceExtension->CurrentSrb;
    PATAPI_REGISTERS_1   baseIoAddress1;
    UCHAR statusByte;

    //
    // If the last command was DSC restrictive, see if it's set. If so, the device is
    // ready for a new request. Otherwise, reset the timer and come back to here later.
    //

    if (srb && (!(deviceExtension->ExpectingInterrupt))) {
#if DBG
        if (!SRB_IS_RDP(srb)) {
            DebugPrint((1,
                        "AtapiCallBack: Invalid CDB marked as RDP - %x\n",
                        srb->Cdb[0]));
        }
#endif

        baseIoAddress1 = (PATAPI_REGISTERS_1)&deviceExtension->BaseIoAddress1;
        if (deviceExtension->RDP) {
            GetStatus(baseIoAddress1, statusByte);
            if (statusByte & IDE_STATUS_DSC) {

                IdePortNotification(IdeRequestComplete,
                                    deviceExtension,
                                    srb);

                //
                // Clear current SRB.
                //

                deviceExtension->CurrentSrb = NULL;
                deviceExtension->RDP = FALSE;

                //
                // Ask for next request.
                //

                IdePortNotification(IdeNextRequest,
                                    deviceExtension,
                                    NULL);


                return;

            } else {

                DebugPrint((3,
                            "AtapiCallBack: Requesting another timer for Op %x\n",
                            deviceExtension->CurrentSrb->Cdb[0]));

                IdePortNotification(IdeRequestTimerCall,
                                    HwDeviceExtension,
                                    AtapiCallBack,
                                    1000);
                return;
            }
        }
    }

    DebugPrint((2,
                "AtapiCallBack: Calling ISR directly due to BUSY\n"));
    AtapiInterrupt(HwDeviceExtension);

}

//#define IdeCrashDumpLogIsrStatus(hwExtension, isrStatus) hwExtension->CrashDumpIsrStatus[hwExtension->CrashDumpLogIndex]=isrStatus;

BOOLEAN
AtapiInterrupt(
              IN PVOID HwDeviceExtension
              )

/*++

Routine Description:

    This is the interrupt service routine for ATAPI IDE miniport driver.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE if expecting an interrupt.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb              = deviceExtension->CurrentSrb;
    PATAPI_REGISTERS_1 baseIoAddress1;
    PATAPI_REGISTERS_2 baseIoAddress2;
    ULONG byteCount = 0, bytesThisInterrupt = 512;
    ULONG status;
    ULONG i;
    UCHAR statusByte,interruptReason;
    BOOLEAN commandComplete = FALSE;
    BOOLEAN atapiDev = FALSE;
    UCHAR dmaStatus;
    BOOLEAN fakeStatus = FALSE;
    BOOLEAN packetBasedSrb;
    BOOLEAN wdModeCdRom;
    BMSTATUS bmStatus=0;
    BOOLEAN dmaInProgress = FALSE;
    BOOLEAN alwaysClearBusMasterInterrupt;
    UCHAR savedCmd;
    BOOLEAN interruptCleared = FALSE;

    alwaysClearBusMasterInterrupt = deviceExtension->BusMasterInterface.AlwaysClearBusMasterInterrupt;


    //
    // if this flag is set, we must try to clear the busmaster interrupt
    // this is to overcome a bug in the cpq controller
    // this is set for native mode contollers
    //                                     
    if (alwaysClearBusMasterInterrupt) {
        if (deviceExtension->BusMasterInterface.BmStatus) {
            bmStatus = deviceExtension->BusMasterInterface.BmStatus (deviceExtension->BusMasterInterface.Context);
            if (bmStatus & BMSTATUS_INTERRUPT) {
                deviceExtension->BusMasterInterface.BmDisarm (deviceExtension->BusMasterInterface.Context);

                interruptCleared = TRUE;
            }
        }
    }


    if (srb) {

        baseIoAddress1 =    (PATAPI_REGISTERS_1)&deviceExtension->BaseIoAddress1;
        baseIoAddress2 =    (PATAPI_REGISTERS_2)&deviceExtension->BaseIoAddress2;
    } else {
        DebugPrint((1,
                    "AtapiInterrupt: CurrentSrb is NULL.  Bogus Interrupt\n"));
        if (deviceExtension->InterruptMode == LevelSensitive) {
            if (deviceExtension->BaseIoAddress1.RegistersBaseAddress != NULL) {
                baseIoAddress1 = (PATAPI_REGISTERS_1)&deviceExtension->BaseIoAddress1;
                GetBaseStatus(baseIoAddress1, statusByte);
                /*
                GetSelectedIdeDevice(baseIoAddress1, savedCmd);
                SelectIdeDevice(baseIoAddress1, 0, 0);
                GetBaseStatus(baseIoAddress1, statusByte);
                SelectIdeDevice(baseIoAddress1, 1, 0);
                GetBaseStatus(baseIoAddress1, statusByte);
                ReSelectIdeDevice(baseIoAddress1, savedCmd);
                */
            }
        }

        return interruptCleared;
    }

    if (!(deviceExtension->ExpectingInterrupt)) {

        DebugPrint((1,
                    "AtapiInterrupt: Unexpected interrupt.\n"));

        return interruptCleared;
    }

    if (!alwaysClearBusMasterInterrupt) {
        if (deviceExtension->BusMasterInterface.BmStatus) {
            bmStatus = deviceExtension->BusMasterInterface.BmStatus (deviceExtension->BusMasterInterface.Context);
            if (bmStatus & BMSTATUS_INTERRUPT) {
                deviceExtension->BusMasterInterface.BmDisarm (deviceExtension->BusMasterInterface.Context);
            }
        }
    }

    //
    // For SiS IDE Controller, we have to read the bm status register first
    //
    if (deviceExtension->DMAInProgress) {

        // PCI Busmaster IDE Controller spec defines a bit in its status
        // register which indicates pending interrupt.  However,
        // CMD 646 (maybe some other one, too) doesn't always do that if
        // the interrupt is from a atapi device.  (strange, but true!)
        // Since we can look at this interrupt bit only if we are sharing
        // interrupt, we will do just that

        //
        // Doesn't look like it is our interrupt
        // If we are called from crashdmp (polling mode) then prociess the interrupt
        // even if the bit is not set. It is checked in the crashdmp routine.
        //
        if (!(bmStatus & BMSTATUS_INTERRUPT) && 
            !(deviceExtension->DriverMustPoll)) {
            DebugPrint((1, "No BusMaster Interrupt\n"));

            ASSERT(interruptCleared == FALSE);
            return FALSE;
        }

        dmaInProgress = deviceExtension->DMAInProgress;
        deviceExtension->DMAInProgress = FALSE;

        if (deviceExtension->BusMasterInterface.IgnoreActiveBitForAtaDevice) {
            if (!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE)) {
                CLRMASK (bmStatus, BMSTATUS_NOT_REACH_END_OF_TRANSFER);
            }
        }
    }

    //
    // should we check for the interrupt bit for PIO transfers?
    //

    //
    // Select IDE line(Primary or Secondary).
    //
    SelectIdeLine(baseIoAddress1, srb->TargetId >> 1);

    //
    // Clear interrupt by reading status.
    //
    GetBaseStatus(baseIoAddress1, statusByte);

#ifdef ENABLE_ATAPI_VERIFIER
    if (ViIdeGenerateDmaTimeout(deviceExtension, dmaInProgress)) {
        deviceExtension->ExpectingInterrupt = FALSE;
        return TRUE;
    }
#endif

    //
    // Log the bus master status
    //
    if (!deviceExtension->DriverMustPoll) {
        IdeLogBmStatus(srb, bmStatus);
    }

    //IdeCrashDumpLogIsrStatus(deviceExtension, bmStatus);
    //
    // check the type of srb we have
    //
    if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

        packetBasedSrb = TRUE;

    } else {

        packetBasedSrb = FALSE;
    }


    if ((srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH) ||
        (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH)) {

        PATA_PASS_THROUGH    ataPassThroughData;
        PIDEREGS             pIdeReg;

        packetBasedSrb = FALSE;

        ataPassThroughData = srb->DataBuffer;
        pIdeReg            = &ataPassThroughData->IdeReg;

        //
        // if the last command we issued was a SLEEP command,
        // the device interface (task registers) is invalid.
        // In order to complete the interrupt, will fake the 
        // a good status
        //
        if (pIdeReg->bCommandReg == IDE_COMMAND_SLEEP) {

            fakeStatus = TRUE;
        }

    }

    if (fakeStatus) {

        statusByte = IDE_STATUS_IDLE;
    }

    DebugPrint((1,
                "AtapiInterrupt: Entered with status (%x)\n",
                statusByte));


    if (statusByte & IDE_STATUS_BUSY) {

        if (deviceExtension->DriverMustPoll) {

            //
            // Crashdump is polling and we got caught with busy asserted.
            // Just go away, and we will be polled again shortly.
            //

            DebugPrint((1,
                        "AtapiInterrupt: Hit status=0x%x while polling during crashdump.\n", 
                        statusByte
                       ));

            deviceExtension->DMAInProgress = TRUE;
            return TRUE;
        }

        if (dmaInProgress) {

            //
            // this is really bad since we already disabled
            // dma at this point, but the device is still busy
            // can't really recover. just return from now.  
            // the timeout code will kick in and save the world
            //

            DebugPrint((DBG_ALWAYS,
                        "AtapiInterrupt: End of DMA transfer but device is still BUSY.  status = 0x%x\n", 
                        statusByte));

            //
            // we are not expecting interrupt anymore. Clear the flag.
            //
            deviceExtension->ExpectingInterrupt = FALSE;
            return interruptCleared;
        }

        //
        // Ensure BUSY is non-asserted.
        //

        for (i = 0; i < 10; i++) {

            GetBaseStatus(baseIoAddress1, statusByte);
            if (!(statusByte & IDE_STATUS_BUSY)) {
                break;
            }

        }

        if (i == 10) {

            DebugPrint((2,
                        "AtapiInterrupt: BUSY on entry. Status %x, Base IO %x\n",
                        statusByte,
                        baseIoAddress1));

            IdePortNotification(IdeRequestTimerCall,
                                HwDeviceExtension,
                                AtapiCallBack,
                                500);

            return interruptCleared;
        }
    }

    //
    // Check for error conditions.
    //

    if (statusByte & IDE_STATUS_ERROR) {

        if (srb->Cdb[0] != SCSIOP_REQUEST_SENSE) {

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }
    }

    wdModeCdRom = FALSE;

    if (Is98LegacyIde(baseIoAddress1)) {

        if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_WD_MODE) {
            if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

                wdModeCdRom = TRUE;

            } else {

                status = SRB_STATUS_ERROR;
                goto CompleteRequest;
            }
        }
    }

    //
    // check reason for this interrupt.
    //
    if (packetBasedSrb && !wdModeCdRom) {

        interruptReason = (IdePortInPortByte(baseIoAddress1->InterruptReason) & 0x3);
        atapiDev = TRUE;
        bytesThisInterrupt = 512;

        if (dmaInProgress) {

            if (interruptReason != 0x3) {

                //
                // the device causes an interrupt in the middle of a
                // dma transfer!  bad bad bad device!
                // do nothing and just return.  this will get translated
                // to a timeout and we will retry.
                //
                DebugPrint((1, 
                            "Interrupt during DMA transfer, reason %x != 0x3\n", 
                            interruptReason
                           ));

                deviceExtension->ExpectingInterrupt = FALSE;

                // ISSUE: should we return TRUE?
                return interruptCleared;
            }
        }

    } else {

        if (dmaInProgress) {

            interruptReason = 0x3;

        } else if (statusByte & IDE_STATUS_DRQ) {

            if (deviceExtension->MaximumBlockXfer[srb->TargetId]) {
                bytesThisInterrupt = 512 * deviceExtension->MaximumBlockXfer[srb->TargetId];

            }

            if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

                interruptReason =  0x2;

            } else if (srb->SrbFlags & SRB_FLAGS_DATA_OUT) {
                interruptReason = 0x0;

            } else {
                status = SRB_STATUS_ERROR;
                goto CompleteRequest;
            }

        } else if (statusByte & IDE_STATUS_BUSY) {

            ASSERT(interruptCleared == FALSE);
            return FALSE;

        } else {

            if (deviceExtension->BytesLeft && (!Is98LegacyIde(baseIoAddress1))) {

                //
                // We should return interruptCleared. 
                //
                return interruptCleared;

            } else {

                //
                // Command complete - verify, write, or the SMART enable/disable.
                //
                // Also get_media_status

                interruptReason = 0x3;
            }
        }
    }

    if (interruptReason == 0x1 && (statusByte & IDE_STATUS_DRQ)) {

        //
        // Write the packet.
        //

        DebugPrint((2,
                    "AtapiInterrupt: Writing Atapi packet.\n"));

        //
        // Send CDB to device.
        //

        WriteBuffer(baseIoAddress1,
                    (PUSHORT)srb->Cdb,
                    6);

        if (SRB_USES_DMA(srb)) {
            deviceExtension->DMAInProgress = TRUE;
            deviceExtension->BusMasterInterface.BmArm (deviceExtension->BusMasterInterface.Context);
        }

        return interruptCleared;

    } else if (interruptReason == 0x0 && (statusByte & IDE_STATUS_DRQ)) {

        //
        // Write the data.
        //
        if (packetBasedSrb) {

            //
            // Pick up bytes to transfer and convert to words.
            //

            byteCount =
            IdePortInPortByte(baseIoAddress1->ByteCountLow);

            byteCount |=
            IdePortInPortByte(baseIoAddress1->ByteCountHigh) << 8;

            if (byteCount != deviceExtension->BytesLeft) {
                DebugPrint((3,
                            "AtapiInterrupt: %d bytes requested; %d bytes xferred\n",
                            deviceExtension->BytesLeft,
                            byteCount));
            }

            //
            // Verify this makes sense.
            //

            if (byteCount > deviceExtension->BytesLeft) {
                byteCount = deviceExtension->BytesLeft;
            }

        } else {

            //
            // IDE path. Check if words left is at least 256.
            //

            if (deviceExtension->BytesLeft < bytesThisInterrupt) {

                //
                // Transfer only words requested.
                //

                byteCount = deviceExtension->BytesLeft;

            } else {

                //
                // Transfer next block.
                //

                byteCount = bytesThisInterrupt;
            }
        }

        //
        // Ensure that this is a write command.
        //

        if (srb->SrbFlags & SRB_FLAGS_DATA_OUT) {

            DebugPrint((3,
                        "AtapiInterrupt: Write interrupt\n"));

            WaitOnBusy(baseIoAddress1,statusByte);

            WriteBuffer(baseIoAddress1,
                        (PUSHORT)deviceExtension->DataBuffer,
                        byteCount / sizeof(USHORT));

            if (byteCount & 1) {

                //
                // grab the last byte
                //
                IdePortOutPortByte(
                                  (PUCHAR)(baseIoAddress1->Data), 
                                  deviceExtension->DataBuffer[byteCount - 1]
                                  );
            }

        } else {

            DebugPrint((1,
                        "AtapiInterrupt: Int reason %x, but srb is for a write %x.\n",
                        interruptReason,
                        srb));

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }


        //
        // Advance data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer += byteCount;
        deviceExtension->BytesLeft -= byteCount;

        return interruptCleared;

    } else if (interruptReason == 0x2 && (statusByte & IDE_STATUS_DRQ)) {

        if (packetBasedSrb) {

            //
            // Pick up bytes to transfer
            //

            byteCount =
            IdePortInPortByte(baseIoAddress1->ByteCountLow);

            byteCount |=
            IdePortInPortByte(baseIoAddress1->ByteCountHigh) << 8;

            if (byteCount != deviceExtension->BytesLeft) {
                DebugPrint((3,
                            "AtapiInterrupt: %d bytes requested; %d bytes xferred\n",
                            deviceExtension->BytesLeft,
                            byteCount));
            }

            //
            // Verify this makes sense.
            //

            if (byteCount > deviceExtension->BytesLeft) {
                byteCount = deviceExtension->BytesLeft;
            }

        } else {

            //
            // Check if words left is at least 256.
            //

            if (deviceExtension->BytesLeft < bytesThisInterrupt) {

                //
                // Transfer only words requested.
                //

                byteCount = deviceExtension->BytesLeft;

            } else {

                //
                // Transfer next block.
                //

                byteCount = bytesThisInterrupt;
            }
        }

        //
        // Ensure that this is a read command.
        //

        if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

            DebugPrint((3,
                        "AtapiInterrupt: Read interrupt\n"));

            WaitOnBusy(baseIoAddress1,statusByte);

            ReadBuffer(baseIoAddress1,
                       (PUSHORT)deviceExtension->DataBuffer,
                       byteCount / sizeof(USHORT));

            if (byteCount & 1) {

                //
                // grab the last byte
                //
                deviceExtension->DataBuffer[byteCount - 1] = IdePortInPortByte((PUCHAR)(baseIoAddress1->Data));
            }

        } else {

            DebugPrint((1,
                        "AtapiInterrupt: Int reason %x, but srb is for a read %x.\n",
                        interruptReason,
                        srb));

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }

        //
        // Translate ATAPI data back to SCSI data if needed
        //
        if (deviceExtension->scsi2atapi) {

            //
            //convert and adjust the wordCount
            //
            byteCount -= Atapi2Scsi(
                                   deviceExtension, 
                                   srb, 
                                   deviceExtension->DataBuffer,
                                   byteCount 
                                   );
        }

        //
        // Advance data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer += byteCount;
        deviceExtension->BytesLeft -= byteCount;

        //
        // Check for read command complete.
        //

        if (deviceExtension->BytesLeft == 0) {

            if (packetBasedSrb) {

                //
                // Work around to make many atapi devices return correct sector size
                // of 2048. Also certain devices will have sector count == 0x00, check
                // for that also.
                //
                if (!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_MULTI_LUN_INITED)) {

                    if ((srb->Cdb[0] == 0x25) &&
                        ((deviceExtension->IdentifyData[srb->TargetId].GeneralConfiguration >> 8) & 0x1f) == 0x05) {

                        deviceExtension->DataBuffer -= byteCount;
                        if (deviceExtension->DataBuffer[0] == 0x00) {

                            *((ULONG *) &(deviceExtension->DataBuffer[0])) = 0xFFFFFF7F;

                        }

                        *((ULONG *) &(deviceExtension->DataBuffer[2])) = 0x00080000;
                        deviceExtension->DataBuffer += byteCount;
                    }
                }
            } else {

                //
                // Completion for IDE drives.
                //


                if (deviceExtension->BytesLeft) {

                    status = SRB_STATUS_DATA_OVERRUN;

                } else {

                    status = SRB_STATUS_SUCCESS;

                }

                goto CompleteRequest;

            }
        }

        return interruptCleared;

    } else if (interruptReason == 0x3) { // && !(statusByte & IDE_STATUS_DRQ)) {

        if (dmaInProgress) {

            deviceExtension->BytesLeft = 0;

            ASSERT (interruptReason == 3);

            //
            // bmStatus is initalized eariler.
            //
            if (!BMSTATUS_SUCCESS(bmStatus)) {

                if (bmStatus & BMSTATUS_ERROR_TRANSFER) {

                    status = SRB_STATUS_ERROR;
                }

                if (bmStatus & BMSTATUS_NOT_REACH_END_OF_TRANSFER) {

                    status = SRB_STATUS_DATA_OVERRUN;
                }

            } else {

                status = SRB_STATUS_SUCCESS;
            }

        } else {

            //
            // Command complete.
            //

            if (deviceExtension->BytesLeft) {

                status = SRB_STATUS_DATA_OVERRUN;

            } else {

                status = SRB_STATUS_SUCCESS;
            }
        }

        CompleteRequest:

        if (status == SRB_STATUS_ERROR) {

            DebugPrint ((1, 
                         "AtapiInterrupt: last command return status byte = 0x%x and error byte = 0x%x\n", 
                         statusByte, 
                         IdePortInPortByte(baseIoAddress1->Error)));

            if (deviceExtension->scsi2atapi) {

                RESTORE_ORIGINAL_CDB(deviceExtension, srb);

                deviceExtension->scsi2atapi = FALSE;

            }
            //
            // Map error to specific SRB status and handle request sense.
            //
            if ((srb->Function == SRB_FUNCTION_FLUSH) ||
                (srb->Function == SRB_FUNCTION_SHUTDOWN)) {

                //
                // return status success even if a flush fails
                //
                status = SRB_STATUS_SUCCESS;
            } else {

                //
                // log only the error that is caused by normal reuqest that
                // fails
                //
                if ((srb->Function != SRB_FUNCTION_ATA_PASS_THROUGH) &&
                    (srb->Function != SRB_FUNCTION_ATA_POWER_PASS_THROUGH)) {

                    status = MapError(deviceExtension,
                                      srb);
                }
            }


            deviceExtension->RDP = FALSE;

#if DBG
//#define ATAPI_RANDOM_RW_ERROR_FREQUENCY    50
    #if ATAPI_RANDOM_RW_ERROR_FREQUENCY

        } else if (status == SRB_STATUS_SUCCESS) {

            static ULONG _____RWCount = 0;

            if ((srb->Cdb[0] == SCSIOP_READ) || (srb->Cdb[0] == SCSIOP_WRITE)) {

                _____RWCount++;

//                if (baseIoAddress1 == (PATAPI_REGISTERS_1)0x170) {
                {

                    if ((_____RWCount % ATAPI_RANDOM_RW_ERROR_FREQUENCY) == 0) {

                        DebugPrint ((1, "ATAPI: Forcing R/W error\n"));

                        srb->SrbStatus = SRB_STATUS_ERROR;
                        srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
                        if (srb->SenseInfoBuffer) {

                            PSENSE_DATA  senseBuffer = (PSENSE_DATA)srb->SenseInfoBuffer;

                            senseBuffer->ErrorCode = 0x70;
                            senseBuffer->Valid     = 1;
                            senseBuffer->AdditionalSenseLength = 0xb;
                            senseBuffer->SenseKey =  SCSI_SENSE_HARDWARE_ERROR;
                            senseBuffer->AdditionalSenseCode = 0;
                            senseBuffer->AdditionalSenseCodeQualifier = 0;

                            srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
                        }
                        status = srb->SrbStatus;
                    }
                }
            }

    #endif // DBG
#endif // ATAPI_GENERATE_RANDOM_RW_ERROR

        } else {

            //
            // Wait for busy to drop.
            //

            for (i = 0; i < 60; i++) {

                if (fakeStatus) {

                    statusByte = IDE_STATUS_IDLE;
                } else {

                    GetStatus(baseIoAddress1,statusByte);
                }
                if (!(statusByte & IDE_STATUS_BUSY)) {
                    break;
                }
                KeStallExecutionProcessor(500);
            }

            if (i == 60) {

                //
                // reset the controller.
                //

                DebugPrint((0,
                            "AtapiInterrupt: Resetting due to BSY still up - %x. Base Io %x\n",
                            statusByte,
                            baseIoAddress1));

                if (deviceExtension->DriverMustPoll) {

                    //
                    // When we are polling, no dpc gets enqueued. 
                    // Try a quick reset...
                    //
                    //AtapiSyncResetController (HwDeviceExtension,srb->PathId);
                    status = SRB_STATUS_BUS_RESET;

                } else {

                    //
                    // Reset the controller in the completion DPC
                    //
                    //AtapiSyncResetController (HwDeviceExtension,srb->PathId);
                    IdePortNotification(IdeResetRequest,
                                        deviceExtension,
                                        NULL);
                    return interruptCleared;
                }

            }

            //
            // Check to see if DRQ is still up.
            //

            if (statusByte & IDE_STATUS_DRQ) {

                for (i = 0; i < 500; i++) {
                    GetStatus(baseIoAddress1,statusByte);
                    if (!(statusByte & IDE_STATUS_DRQ)) {
                        break;
                    }
                    KeStallExecutionProcessor(100);

                }

                if (i == 500) {

                    //
                    // reset the controller.
                    //
                    DebugPrint((0,
                                "AtapiInterrupt: Resetting due to DRQ still up - %x\n",
                                statusByte));

                    if (deviceExtension->DriverMustPoll) {

                        //
                        // When we are polling, no dpc gets enqueued. 
                        // Try a quick reset...
                        //
                        //AtapiSyncResetController (HwDeviceExtension,srb->PathId);
                        status = SRB_STATUS_BUS_RESET;

                    } else {

                        //
                        // Reset the controller in the completion DPC
                        //
                        //AtapiSyncResetController (HwDeviceExtension,srb->PathId);
                        IdePortNotification(IdeResetRequest,
                                            deviceExtension,
                                            NULL);

                        return interruptCleared;
                    }

                }

            }
        }


        //
        // Clear interrupt expecting and dmaInProgress flag.
        //

        deviceExtension->ExpectingInterrupt = FALSE;

        //
        // Sanity check that there is a current request.
        //

        if (srb != NULL) {

            //
            // Set status in SRB.
            //

            srb->SrbStatus = (UCHAR)status;

            //
            // Check for underflow.
            //

            if (deviceExtension->BytesLeft) {

                //
                // Subtract out residual words and update if filemark hit,
                // setmark hit , end of data, end of media...
                //

                if (!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_TAPE_DEVICE)) {

                    if (status == SRB_STATUS_DATA_OVERRUN) {
                        srb->DataTransferLength -= deviceExtension->BytesLeft;
                    } else {
                        srb->DataTransferLength = 0;
                    }
                } else {
                    srb->DataTransferLength -= deviceExtension->BytesLeft;
                }
            }

            if ((srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH) ||
                (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH)) {

                PATA_PASS_THROUGH ataPassThroughData = srb->DataBuffer;

                AtapiTaskRegisterSnapshot ((PIDE_REGISTERS_1)baseIoAddress1, &ataPassThroughData->IdeReg);
            }

            if (srb->Function != SRB_FUNCTION_IO_CONTROL) {

                //
                // Indicate command complete.
                //

                if (!(deviceExtension->RDP) &&
                    !(deviceExtension->DriverMustPoll)) {
                    IdePortNotification(IdeRequestComplete,
                                        deviceExtension,
                                        srb);

                }
            } else {

                PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                UCHAR             error = 0;

                if (status != SRB_STATUS_SUCCESS) {
                    error = IdePortInPortByte(baseIoAddress1->Error);
                }

                //
                // Build the SMART status block depending upon the completion status.
                //

                cmdOutParameters->cBufferSize = byteCount;
                cmdOutParameters->DriverStatus.bDriverError = (error) ? SMART_IDE_ERROR : 0;
                cmdOutParameters->DriverStatus.bIDEError = error;

                //
                // If the sub-command is return smart status, jam the value from cylinder low and high, into the
                // data buffer.
                //

                if (deviceExtension->SmartCommand == RETURN_SMART_STATUS) {
                    cmdOutParameters->bBuffer[0] = RETURN_SMART_STATUS;
                    cmdOutParameters->bBuffer[1] = IdePortInPortByte(baseIoAddress1->InterruptReason);
                    cmdOutParameters->bBuffer[2] = IdePortInPortByte(baseIoAddress1->Unused1);
                    cmdOutParameters->bBuffer[3] = IdePortInPortByte(baseIoAddress1->ByteCountLow);
                    cmdOutParameters->bBuffer[4] = IdePortInPortByte(baseIoAddress1->ByteCountHigh);
                    cmdOutParameters->bBuffer[5] = IdePortInPortByte(baseIoAddress1->DriveSelect);
                    cmdOutParameters->bBuffer[6] = SMART_CMD;
                    cmdOutParameters->cBufferSize = 8;
                }

                //
                // Indicate command complete.
                //

                IdePortNotification(IdeRequestComplete,
                                    deviceExtension,
                                    srb);

            }

        } else {

            DebugPrint((1,
                        "AtapiInterrupt: No SRB!\n"));
        }

        //
        // Indicate ready for next request.
        //

        if (!(deviceExtension->RDP)) {

            //
            // Clear current SRB.
            //

            deviceExtension->CurrentSrb = NULL;

            if (!deviceExtension->DriverMustPoll) {
                IdePortNotification(IdeNextRequest,
                                    deviceExtension,
                                    NULL);
            }
        } else {

            ASSERT(!deviceExtension->DriverMustPoll);
            IdePortNotification(IdeRequestTimerCall,
                                HwDeviceExtension,
                                AtapiCallBack,
                                2000);
        }

        return interruptCleared;

    } else {

        //
        // Unexpected int.
        //

        DebugPrint((0,
                    "AtapiInterrupt: Unexpected interrupt. InterruptReason %x. Status %x.\n",
                    interruptReason,
                    statusByte));

        ASSERT(interruptCleared == FALSE);
        return FALSE;
    }

    return interruptCleared;

} // end AtapiInterrupt()


ULONG
IdeSendSmartCommand(
                   IN PVOID HwDeviceExtension,
                   IN PSCSI_REQUEST_BLOCK Srb
                   )

/*++

Routine Description:

    This routine handles SMART enable, disable, read attributes and threshold commands.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    PSENDCMDOUTPARAMS    cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    PSENDCMDINPARAMS      pCmdInParameters = (PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    SENDCMDINPARAMS      cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    PIDEREGS             regs = &cmdInParameters.irDriveRegs;
    ULONG                i;
    UCHAR                statusByte,targetId;
    ULONG                byteCount;


    if (cmdInParameters.irDriveRegs.bCommandReg == SMART_CMD) {

        targetId = cmdInParameters.bDriveNumber;

        //TODO optimize this check

        if ((!(deviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT)) ||
            (deviceExtension->DeviceFlags[targetId] & DFLAGS_ATAPI_DEVICE)) {

            return SRB_STATUS_SELECTION_TIMEOUT;
        }

        deviceExtension->SmartCommand = cmdInParameters.irDriveRegs.bFeaturesReg;

        //
        // fudge the target Id field in the srb
        // atapi interrupt will use this field.
        //
        Srb->TargetId = targetId;

        //
        // Determine which of the commands to carry out.
        //

#ifdef ENABLE_SMARTLOG_SUPPORT
        if ((cmdInParameters.irDriveRegs.bFeaturesReg == READ_ATTRIBUTES) ||
            (cmdInParameters.irDriveRegs.bFeaturesReg == READ_THRESHOLDS) ||
            (cmdInParameters.irDriveRegs.bFeaturesReg == SMART_READ_LOG)) {
#else
        if ((cmdInParameters.irDriveRegs.bFeaturesReg == READ_ATTRIBUTES) ||
            (cmdInParameters.irDriveRegs.bFeaturesReg == READ_THRESHOLDS)) {
#endif

            ULONG dataLength = 0;

            SelectIdeLine(baseIoAddress1, targetId >> 1);

            WaitOnBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

#ifdef ENABLE_SMARTLOG_SUPPORT
            if (cmdInParameters.irDriveRegs.bFeaturesReg == SMART_READ_LOG) {

                dataLength = cmdInParameters.irDriveRegs.bSectorCountReg* SMART_LOG_SECTOR_SIZE;

            } else {

                dataLength = READ_ATTRIBUTE_BUFFER_SIZE;

            }
#else
            dataLength = READ_ATTRIBUTE_BUFFER_SIZE;
#endif

            //
            // Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
            //
            for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + dataLength - 1); i++) {
                ((PUCHAR)cmdOutParameters)[i] = 0;
            }

            //
            // Set data buffer pointer and words left.
            //
            deviceExtension->DataBuffer = (PUCHAR)cmdOutParameters->bBuffer;
            deviceExtension->BytesLeft = dataLength;

            //
            // Indicate expecting an interrupt.
            //
            deviceExtension->ExpectingInterrupt = TRUE;

            SelectIdeDevice(baseIoAddress1, targetId, 0);
            IdePortOutPortByte(baseIoAddress1->Error,regs->bFeaturesReg);
            IdePortOutPortByte(baseIoAddress1->BlockCount,regs->bSectorCountReg);
            IdePortOutPortByte(baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            IdePortOutPortByte(baseIoAddress1->CylinderLow,regs->bCylLowReg);
            IdePortOutPortByte(baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            IdePortOutPortByte(baseIoAddress1->Command,regs->bCommandReg);

            //
            // Wait for interrupt.
            //
            return SRB_STATUS_PENDING;

        } else if ((cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_SMART) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == DISABLE_SMART) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == RETURN_SMART_STATUS) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_DISABLE_AUTOSAVE) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == EXECUTE_OFFLINE_DIAGS) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == SAVE_ATTRIBUTE_VALUES) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_DISABLE_AUTO_OFFLINE)) {
#ifdef ENABLE_SMARTLOG_SUPPORT
            //
            // Allow only the non-captive tests, for now.
            //
            if (cmdInParameters.irDriveRegs.bFeaturesReg == EXECUTE_OFFLINE_DIAGS) {

                UCHAR sectorNumber = regs->bSectorNumberReg;

                if ((sectorNumber == SMART_OFFLINE_ROUTINE_OFFLINE) ||
                    (sectorNumber == SMART_SHORT_SELFTEST_OFFLINE) ||
                    (sectorNumber == SMART_EXTENDED_SELFTEST_OFFLINE) ||
                    (sectorNumber == SMART_ABORT_OFFLINE_SELFTEST)) {

                    DebugPrint((1, 
                                "The SMART offline command %x is allowed\n",
                                sectorNumber));

                } else if ((sectorNumber == SMART_SHORT_SELFTEST_CAPTIVE) ||
                           (sectorNumber == SMART_EXTENDED_SELFTEST_CAPTIVE)) {

                    //
                    // Don't allow captive mode requests, if you have a slave(another)
                    // device
                    //
                    if (HasSlaveDevice(deviceExtension, targetId)) {
                        return SRB_STATUS_INVALID_REQUEST;
                    }

                }
            }
#endif

            SelectIdeLine(baseIoAddress1, targetId >> 1);

            WaitOnBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

            //
            // Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
            //
            for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) - 1); i++) {
                ((PUCHAR)cmdOutParameters)[i] = 0;
            }

            //
            // Set data buffer pointer and indicate no data transfer.
            //
            deviceExtension->DataBuffer = (PUCHAR)cmdOutParameters->bBuffer;
            deviceExtension->BytesLeft = 0;

            //
            // Indicate expecting an interrupt.
            //
            deviceExtension->ExpectingInterrupt = TRUE;

            SelectIdeDevice(baseIoAddress1, targetId, 0);
            IdePortOutPortByte(baseIoAddress1->Error,regs->bFeaturesReg);
            IdePortOutPortByte(baseIoAddress1->BlockCount,regs->bSectorCountReg);
            IdePortOutPortByte(baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            IdePortOutPortByte(baseIoAddress1->CylinderLow,regs->bCylLowReg);
            IdePortOutPortByte(baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            IdePortOutPortByte(baseIoAddress1->Command,regs->bCommandReg);

            //
            // Wait for interrupt.
            //
            return SRB_STATUS_PENDING;

        }
#ifdef ENABLE_SMARTLOG_SUPPORT
        else if (cmdInParameters.irDriveRegs.bFeaturesReg == SMART_WRITE_LOG) {

            SelectIdeLine(baseIoAddress1, targetId >> 1);

            WaitOnBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

            //
            // we are assuming that the drive will return an error if we try to
            // write multiple sectors when it is not supported.
            //

            //
            // set the input buffer and the datalength fields.
            //
            deviceExtension->DataBuffer = (PUCHAR)pCmdInParameters->bBuffer;
            deviceExtension->BytesLeft = cmdInParameters.irDriveRegs.bSectorCountReg* SMART_LOG_SECTOR_SIZE;

            //
            // Indicate expecting an interrupt.
            //
            deviceExtension->ExpectingInterrupt = TRUE;

            SelectIdeDevice(baseIoAddress1, targetId, 0);
            IdePortOutPortByte(baseIoAddress1->Error,regs->bFeaturesReg);
            IdePortOutPortByte(baseIoAddress1->BlockCount,regs->bSectorCountReg);
            IdePortOutPortByte(baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            IdePortOutPortByte(baseIoAddress1->CylinderLow,regs->bCylLowReg);
            IdePortOutPortByte(baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            IdePortOutPortByte(baseIoAddress1->Command,regs->bCommandReg);

            ASSERT(!SRB_USES_DMA(Srb));

            if (!SRB_USES_DMA(Srb)) {

                if (deviceExtension->BytesLeft < 
                    deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt) {
                    byteCount = deviceExtension->BytesLeft;
                } else {
                    byteCount = deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt;
                }
                //
                // Wait for BSY and DRQ.
                //

                WaitOnBaseBusy(baseIoAddress1,statusByte);

                if (statusByte & IDE_STATUS_BUSY) {

                    DebugPrint((1,
                                "IdeSendSmartCommand: Returning BUSY status %x\n",
                                statusByte));
                    return SRB_STATUS_BUSY;

                }

                if (statusByte & IDE_STATUS_ERROR) {

                    DebugPrint((1,
                                "IdeSendSmartCommand: Returning ERROR status %x\n",
                                statusByte));

                    deviceExtension->BytesLeft = 0;

                    //
                    // Clear interrupt expecting flag.
                    //
                    deviceExtension->ExpectingInterrupt = FALSE;
                    return MapError(deviceExtension, Srb);
                }

                for (i = 0; i < 1000; i++) {
                    GetBaseStatus(baseIoAddress1, statusByte);
                    if (statusByte & IDE_STATUS_DRQ) {
                        break;
                    }
                    KeStallExecutionProcessor(200);

                }

                if (!(statusByte & IDE_STATUS_DRQ)) {

                    DebugPrint((1,
                                "IdeSmartCommand: DRQ never asserted (%x)\n", 
                                statusByte));

                    deviceExtension->BytesLeft = 0;

                    //
                    // Clear interrupt expecting flag.
                    //

                    deviceExtension->ExpectingInterrupt = FALSE;

                    //
                    // Clear current SRB.
                    //

                    deviceExtension->CurrentSrb = NULL;

                    return SRB_STATUS_SELECTION_TIMEOUT;
                }

                //
                // Write next 256 words.
                //

                WriteBuffer(baseIoAddress1,
                            (PUSHORT)deviceExtension->DataBuffer,
                            byteCount / sizeof(USHORT));

                //
                // Adjust buffer address and words left count.
                //

                deviceExtension->BytesLeft -= byteCount;
                deviceExtension->DataBuffer += byteCount;

            }
            //
            // Wait for interrupt.
            //
            return SRB_STATUS_PENDING;

        }
#endif
    }

    return SRB_STATUS_INVALID_REQUEST;

} // end IdeSendSmartCommand()

#ifdef ENABLE_48BIT_LBA

ULONG
IdeReadWriteExt(
               IN PVOID HwDeviceExtension,
               IN PSCSI_REQUEST_BLOCK Srb
               )

/*++

Routine Description:

    This routine handles IDE read and writes.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    ULONG                i;
    ULONG                byteCount;
    UCHAR                statusByte,statusByte2;
    UCHAR                cylinderHigh,cylinderLow,drvSelect;
    ULONG                sectorCount;
    LARGE_INTEGER        startingSector;

    //
    // the device should support 48 bit LBA
    //
    ASSERT(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA);
    ASSERT(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA);

    //
    // Select device 0 or 1.
    //
    SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);

    GetStatus(baseIoAddress1, statusByte2);

    if (statusByte2 & IDE_STATUS_BUSY) {
        DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                    "IdeReadWrite: Returning BUSY status\n"));
        return SRB_STATUS_BUSY;
    }

    if (!(statusByte2 & IDE_STATUS_DRDY)) {

        DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                    "IdeReadWrite: IDE_STATUS_DRDY not set\n"));
        return SRB_STATUS_BUSY;
    }

    //
    // Set data buffer pointer and words left.
    // BytesLeft should be 64-bit.
    //
    deviceExtension->DataBuffer = (PUCHAR)Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    //
    // Indicate expecting an interrupt.
    //
    deviceExtension->ExpectingInterrupt = TRUE;

    //                                                         
    // Set up sector count register. Round up to next block.
    //
    sectorCount = (Srb->DataTransferLength + 0x1FF) / 0x200;

    ASSERT(sectorCount != 0);


    //
    // Get starting sector number from CDB.
    //
    startingSector.QuadPart = 0;
    startingSector.LowPart = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                              ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                              ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                              ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((1,
                "startingSector = 0x%x, length = 0x%x\n",
                startingSector.LowPart,
                sectorCount
                ));


    //
    // the device shall support LBA. We will not use CHS
    //
    SelectIdeDevice(baseIoAddress1,
                    Srb->TargetId,
                    IDE_LBA_MODE);

    //
    // load the higher order bytes
    //
    IdePortOutPortByte (
                       baseIoAddress1->BlockCount,
                       (UCHAR)((sectorCount & 0x0000ff00) >> 8));

    IdePortOutPortByte (
                       baseIoAddress1->BlockNumber,
                       (UCHAR) (((startingSector.LowPart) & 0xff000000) >> 24));

    IdePortOutPortByte (
                       baseIoAddress1->CylinderLow,
                       (UCHAR) (((startingSector.HighPart) & 0x000000ff) >> 0));

    IdePortOutPortByte (
                       baseIoAddress1->CylinderHigh,
                       (UCHAR) (((startingSector.HighPart) & 0x0000ff00) >> 8));

    //
    // load the lower order bytes
    //
    IdePortOutPortByte (
                       baseIoAddress1->BlockCount,
                       (UCHAR)((sectorCount & 0x000000ff) >> 0));

    IdePortOutPortByte (
                       baseIoAddress1->BlockNumber,
                       (UCHAR) (((startingSector.LowPart) & 0x000000ff) >> 0));

    IdePortOutPortByte (
                       baseIoAddress1->CylinderLow,
                       (UCHAR) (((startingSector.LowPart) & 0x0000ff00) >> 8));

    IdePortOutPortByte (
                       baseIoAddress1->CylinderHigh,
                       (UCHAR) (((startingSector.LowPart) & 0x00ff0000) >> 16));

    //
    // Check if write request.
    //
    if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {

        //
        // Send read command.
        //
        if (SRB_USES_DMA(Srb)) {

            IdePortOutPortByte (
                               baseIoAddress1->Command, 
                               IDE_COMMAND_READ_DMA_EXT);

        } else {

            ASSERT (deviceExtension->DeviceParameters[Srb->TargetId].IdePioReadCommandExt);

            IdePortOutPortByte (
                               baseIoAddress1->Command,
                               deviceExtension->DeviceParameters[Srb->TargetId].IdePioReadCommandExt);
        }

    } else {


        //
        // Send write command.
        //
        if (SRB_USES_DMA(Srb)) {

            IdePortOutPortByte (
                               baseIoAddress1->Command, 
                               IDE_COMMAND_WRITE_DMA_EXT);

        } else {

            ASSERT(deviceExtension->DeviceParameters[Srb->TargetId].IdePioWriteCommandExt);

            IdePortOutPortByte (
                               baseIoAddress1->Command,
                               deviceExtension->DeviceParameters[Srb->TargetId].IdePioWriteCommandExt);
        }

        if (!SRB_USES_DMA(Srb)) {

            if (deviceExtension->BytesLeft < 
                deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt) {
                byteCount = deviceExtension->BytesLeft;
            } else {
                byteCount = deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt;
            }
            //
            // Wait for BSY and DRQ.
            //

            WaitOnBaseBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {

                DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                            "IdeReadWrite 2: Returning BUSY status %x\n",
                            statusByte));
                return SRB_STATUS_BUSY;
            }

            for (i = 0; i < 1000; i++) {
                GetBaseStatus(baseIoAddress1, statusByte);
                if (statusByte & IDE_STATUS_DRQ) {
                    break;
                }
                KeStallExecutionProcessor(200);

            }

            if (!(statusByte & IDE_STATUS_DRQ)) {

                DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                            "IdeReadWrite: DRQ never asserted (%x) original status (%x)\n",
                            statusByte,
                            statusByte2));

                deviceExtension->BytesLeft = 0;

                //
                // Clear interrupt expecting flag.
                //

                deviceExtension->ExpectingInterrupt = FALSE;

                //
                // Clear current SRB.
                //

                deviceExtension->CurrentSrb = NULL;

                return SRB_STATUS_TIMEOUT;
            }

            //
            // Write next 256 words.
            //

            WriteBuffer(baseIoAddress1,
                        (PUSHORT)deviceExtension->DataBuffer,
                        byteCount / sizeof(USHORT));

            //
            // Adjust buffer address and words left count.
            //

            deviceExtension->BytesLeft -= byteCount;
            deviceExtension->DataBuffer += byteCount;

        }
    }

    if (SRB_USES_DMA(Srb)) {
        deviceExtension->DMAInProgress = TRUE;
        deviceExtension->BusMasterInterface.BmArm (deviceExtension->BusMasterInterface.Context);
    }

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeReadWriteExt()
#endif


ULONG
IdeReadWrite(
            IN PVOID HwDeviceExtension,
            IN PSCSI_REQUEST_BLOCK Srb
            )

/*++

Routine Description:

    This routine handles IDE read and writes.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    ULONG                startingSector,i;
    ULONG                byteCount;
    UCHAR                statusByte,statusByte2;
    UCHAR                cylinderHigh,cylinderLow,drvSelect,sectorNumber;


    //
    // Select device 0 or 1.
    //
    SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);

    GetStatus(baseIoAddress1, statusByte2);

    if (statusByte2 & IDE_STATUS_BUSY) {
        DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                    "IdeReadWrite: Returning BUSY status\n"));
        return SRB_STATUS_BUSY;
    }

    if (!(statusByte2 & IDE_STATUS_DRDY)) {

        if ((statusByte2 == 0) && 
            (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_SONY_MEMORYSTICK)) {
            statusByte2=IDE_STATUS_DRDY;
        } else {
            DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                        "IdeReadWrite: IDE_STATUS_DRDY not set\n"));
            return SRB_STATUS_BUSY;
        }
    }


    //
    // returns status busy when atapi verifier is enabled
    //
    //ViIdeFakeHungController(HwDeviceExtension);

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUCHAR)Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;

    //                                                         
    // Set up sector count register. Round up to next block.
    //
    IdePortOutPortByte (
                       baseIoAddress1->BlockCount,
                       (UCHAR)((Srb->DataTransferLength + 0x1FF) / 0x200));

    //
    // Get starting sector number from CDB.
    //

    startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                "IdeReadWrite: Starting sector is %x, Number of bytes %x\n",
                startingSector,
                Srb->DataTransferLength));

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA) {

        SelectIdeDevice(baseIoAddress1,
                        Srb->TargetId,
                        (IDE_LBA_MODE | ((startingSector & 0x0f000000) >> 24)));

        IdePortOutPortByte (
                           baseIoAddress1->BlockNumber,
                           (UCHAR) ((startingSector & 0x000000ff) >> 0));
        IdePortOutPortByte (
                           baseIoAddress1->CylinderLow,
                           (UCHAR) ((startingSector & 0x0000ff00) >> 8));

        IdePortOutPortByte (
                           baseIoAddress1->CylinderHigh,
                           (UCHAR) ((startingSector & 0x00ff0000) >> 16));


    } else {  //CHS

        //
        // Set up sector number register.
        //

        sectorNumber =  (UCHAR)((startingSector % deviceExtension->SectorsPerTrack[Srb->TargetId]) + 1);
        IdePortOutPortByte (
                           baseIoAddress1->BlockNumber,
                           sectorNumber);

        //
        // Set up cylinder low register.
        //

        cylinderLow =  (UCHAR)(startingSector / (deviceExtension->SectorsPerTrack[Srb->TargetId] *
                                                 deviceExtension->NumberOfHeads[Srb->TargetId]));
        IdePortOutPortByte (
                           baseIoAddress1->CylinderLow,
                           cylinderLow);

        //
        // Set up cylinder high register.
        //

        cylinderHigh = (UCHAR)((startingSector / (deviceExtension->SectorsPerTrack[Srb->TargetId] *
                                                  deviceExtension->NumberOfHeads[Srb->TargetId])) >> 8);
        IdePortOutPortByte (
                           baseIoAddress1->CylinderHigh,
                           cylinderHigh);

        //
        // Set up head and drive select register.
        //

        drvSelect = (UCHAR)(((startingSector / deviceExtension->SectorsPerTrack[Srb->TargetId]) %
                             deviceExtension->NumberOfHeads[Srb->TargetId]));
        SelectIdeDevice(baseIoAddress1, Srb->TargetId, drvSelect);

        DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                    "IdeReadWrite: Cylinder %x Head %x Sector %x\n",
                    startingSector /
                    (deviceExtension->SectorsPerTrack[Srb->TargetId] *
                     deviceExtension->NumberOfHeads[Srb->TargetId]),
                    (startingSector /
                     deviceExtension->SectorsPerTrack[Srb->TargetId]) %
                    deviceExtension->NumberOfHeads[Srb->TargetId],
                    startingSector %
                    deviceExtension->SectorsPerTrack[Srb->TargetId] + 1));
    }

    //
    // Check if write request.
    //

    if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {

        //
        // Send read command.
        //
        if (SRB_USES_DMA(Srb)) {

            IdePortOutPortByte (
                               baseIoAddress1->Command, 
                               IDE_COMMAND_READ_DMA);

        } else {

            IdePortOutPortByte (
                               baseIoAddress1->Command,
                               deviceExtension->DeviceParameters[Srb->TargetId].IdePioReadCommand);
        }

    } else {


        //
        // Send write command.
        //
        if (SRB_USES_DMA(Srb)) {

            IdePortOutPortByte (
                               baseIoAddress1->Command, 
                               IDE_COMMAND_WRITE_DMA);

        } else {

            IdePortOutPortByte (
                               baseIoAddress1->Command,
                               deviceExtension->DeviceParameters[Srb->TargetId].IdePioWriteCommand);
        }

        if (!SRB_USES_DMA(Srb)) {

            if (deviceExtension->BytesLeft < 
                deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt) {
                byteCount = deviceExtension->BytesLeft;
            } else {
                byteCount = deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt;
            }
            //
            // Wait for BSY and DRQ.
            //

            WaitOnBaseBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {

                DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                            "IdeReadWrite 2: Returning BUSY status %x\n",
                            statusByte));
                return SRB_STATUS_BUSY;
            }

            for (i = 0; i < 1000; i++) {
                GetBaseStatus(baseIoAddress1, statusByte);
                if (statusByte & IDE_STATUS_DRQ) {
                    break;
                }
                KeStallExecutionProcessor(200);

            }

            if (!(statusByte & IDE_STATUS_DRQ)) {

                DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                            "IdeReadWrite: DRQ never asserted (%x) original status (%x)\n",
                            statusByte,
                            statusByte2));

                deviceExtension->BytesLeft = 0;

                //
                // Clear interrupt expecting flag.
                //

                deviceExtension->ExpectingInterrupt = FALSE;

                //
                // Clear current SRB.
                //

                deviceExtension->CurrentSrb = NULL;

                return SRB_STATUS_TIMEOUT;
            }

            //
            // Write next 256 words.
            //

            WriteBuffer(baseIoAddress1,
                        (PUSHORT)deviceExtension->DataBuffer,
                        byteCount / sizeof(USHORT));

            //
            // Adjust buffer address and words left count.
            //

            deviceExtension->BytesLeft -= byteCount;
            deviceExtension->DataBuffer += byteCount;

        }
    }

    if (SRB_USES_DMA(Srb)) {
        deviceExtension->DMAInProgress = TRUE;
        deviceExtension->BusMasterInterface.BmArm (deviceExtension->BusMasterInterface.Context);
    }

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeReadWrite()

#ifdef ENABLE_48BIT_LBA
ULONG
IdeVerifyExt(
            IN PVOID HwDeviceExtension,
            IN PSCSI_REQUEST_BLOCK Srb
            )

/*++

Routine Description:

    This routine handles IDE Verify.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    LARGE_INTEGER        startingSector;
    ULONG                sectors;
    ULONG                endSector;
    ULONG                sectorCount;

    //
    // the device should support 48 bit LBA
    //
    ASSERT(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA);
    ASSERT(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA);

    //
    // Get starting sector number from CDB.
    //
    startingSector.QuadPart = 0;
    startingSector.LowPart = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                             ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                             ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                             ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    sectorCount = (USHORT)((((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb << 8) |
                            ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb );

    DebugPrint((3,
                "IdeVerify: Starting sector %x. Number of blocks %x\n",
                startingSector.LowPart,
                sectorCount));

    if (sectorCount > 0x10000) {

        DebugPrint((DBG_ALWAYS,
                    "IdeVerify: verify too many sectors 0x%x\n",
                    sectorCount));

        return SRB_STATUS_INVALID_REQUEST;
    }


    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;


    SelectIdeDevice(baseIoAddress1,
                    Srb->TargetId,
                    IDE_LBA_MODE);

    //
    // Load the higer order bytes
    //
    IdePortOutPortByte(baseIoAddress1->BlockNumber,
                       (UCHAR) (((startingSector.LowPart) & 0xff000000) >> 24));

    IdePortOutPortByte(baseIoAddress1->CylinderLow,
                       (UCHAR) (((startingSector.HighPart) & 0x000000ff) >> 0));

    IdePortOutPortByte(baseIoAddress1->CylinderHigh,
                       (UCHAR) (((startingSector.HighPart) & 0x0000ff00) >> 8));

    IdePortOutPortByte(baseIoAddress1->BlockCount,
                       (UCHAR)((sectorCount & 0x0000ff00) >> 8));

    //
    // Load the lower order bytes
    //
    IdePortOutPortByte(baseIoAddress1->BlockNumber,
                       (UCHAR) (((startingSector.LowPart) & 0x000000ff) >> 0));

    IdePortOutPortByte(baseIoAddress1->CylinderLow,
                       (UCHAR) (((startingSector.LowPart) & 0x0000ff00) >> 8));

    IdePortOutPortByte(baseIoAddress1->CylinderHigh,
                       (UCHAR) (((startingSector.LowPart) & 0x00ff0000) >> 16));

    IdePortOutPortByte(baseIoAddress1->BlockCount,
                       (UCHAR)((sectorCount & 0x000000ff) >> 0));

    //
    // Send verify command.
    //

    IdePortOutPortByte(baseIoAddress1->Command,
                       IDE_COMMAND_VERIFY_EXT);

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeVerifyExt()
#endif


ULONG
IdeVerify(
         IN PVOID HwDeviceExtension,
         IN PSCSI_REQUEST_BLOCK Srb
         )

/*++

Routine Description:

    This routine handles IDE Verify.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    ULONG                startingSector;
    ULONG                sectors;
    ULONG                endSector;
    USHORT               sectorCount;

    //
    // Drive has these number sectors.
    //

#if DBG
    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA) { // LBA
        sectors = deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors;
    } else {
        sectors = deviceExtension->SectorsPerTrack[Srb->TargetId] *
                  deviceExtension->NumberOfHeads[Srb->TargetId] *
                  deviceExtension->NumberOfCylinders[Srb->TargetId];
    }
#endif

    DebugPrint((3,
                "IdeVerify: Total sectors %x\n",
                sectors));

    //
    // Get starting sector number from CDB.
    //

    startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((3,
                "IdeVerify: Starting sector %x. Number of blocks %x\n",
                startingSector,
                ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb));

    sectorCount = (USHORT)(((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb << 8 |
                           ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb );
    endSector = startingSector + sectorCount;

    DebugPrint((3,
                "IdeVerify: Ending sector %x\n",
                endSector));

    if (sectorCount > 0x100) {

        DebugPrint((DBG_ALWAYS,
                    "IdeVerify: verify too many sectors 0x%x\n",
                    sectorCount));

        return SRB_STATUS_INVALID_REQUEST;
    }


    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;


    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA) { // LBA

        SelectIdeDevice(baseIoAddress1,
                        Srb->TargetId,
                        (IDE_LBA_MODE |((startingSector & 0x0f000000) >> 24)));

        IdePortOutPortByte(baseIoAddress1->BlockNumber,
                           (UCHAR) ((startingSector & 0x000000ff) >> 0));

        IdePortOutPortByte(baseIoAddress1->CylinderLow,
                           (UCHAR) ((startingSector & 0x0000ff00) >> 8));

        IdePortOutPortByte(baseIoAddress1->CylinderHigh,
                           (UCHAR) ((startingSector & 0x00ff0000) >> 16));

        DebugPrint((2,
                    "IdeVerify: LBA: startingSector %x\n",
                    startingSector));

    } else {  //CHS

        //
        // Set up head and drive select register.
        //

        SelectIdeDevice(baseIoAddress1,
                        Srb->TargetId,
                        (UCHAR)((startingSector /
                                 deviceExtension->SectorsPerTrack[Srb->TargetId]) %
                                deviceExtension->NumberOfHeads[Srb->TargetId]));

        //
        // Set up sector number register.
        //

        IdePortOutPortByte(baseIoAddress1->BlockNumber,
                           (UCHAR)((startingSector %
                                    deviceExtension->SectorsPerTrack[Srb->TargetId]) + 1));

        //
        // Set up cylinder low register.
        //

        IdePortOutPortByte(baseIoAddress1->CylinderLow,
                           (UCHAR)(startingSector /
                                   (deviceExtension->SectorsPerTrack[Srb->TargetId] *
                                    deviceExtension->NumberOfHeads[Srb->TargetId])));

        //
        // Set up cylinder high register.
        //

        IdePortOutPortByte(baseIoAddress1->CylinderHigh,
                           (UCHAR)((startingSector /
                                    (deviceExtension->SectorsPerTrack[Srb->TargetId] *
                                     deviceExtension->NumberOfHeads[Srb->TargetId])) >> 8));

        DebugPrint((2,
                    "IdeVerify: CHS: Cylinder %x Head %x Sector %x\n",
                    startingSector /
                    (deviceExtension->SectorsPerTrack[Srb->TargetId] *
                     deviceExtension->NumberOfHeads[Srb->TargetId]),
                    (startingSector /
                     deviceExtension->SectorsPerTrack[Srb->TargetId]) %
                    deviceExtension->NumberOfHeads[Srb->TargetId],
                    startingSector %
                    deviceExtension->SectorsPerTrack[Srb->TargetId] + 1));
    }

/********
    if (endSector > sectors) {

        //
        // Too big, round down.
        //

        DebugPrint((1,
                    "IdeVerify: Truncating request to %x blocks\n",
                    sectors - startingSector - 1));

        IdePortOutPortByte(baseIoAddress1->BlockCount,
                               (UCHAR)(sectors - startingSector - 1));

    } else {

        IdePortOutPortByte(baseIoAddress1->BlockCount,(UCHAR)sectorCount);
    }
******/

    IdePortOutPortByte(baseIoAddress1->BlockCount,(UCHAR)sectorCount);

    //
    // Send verify command.
    //

    IdePortOutPortByte(baseIoAddress1->Command,
                       IDE_COMMAND_VERIFY);

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeVerify()


VOID
Scsi2Atapi(
          IN PHW_DEVICE_EXTENSION DeviceExtension,
          IN PSCSI_REQUEST_BLOCK Srb
          )

/*++

Routine Description:

    Convert SCSI packet command to Atapi packet command.

Arguments:

    Srb - IO request packet

Return Value:

    None

--*/
{
    SAVE_ORIGINAL_CDB(DeviceExtension, Srb);

    DeviceExtension->scsi2atapi = FALSE;

    if (!(DeviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_TAPE_DEVICE)) {

        //
        // Change the cdb length
        //
        //Srb->CdbLength = 12;

        switch (Srb->Cdb[0]) {
        case SCSIOP_MODE_SENSE: {

            ASSERT(FALSE);

            break;
            }

        case SCSIOP_MODE_SELECT: {

            ASSERT (FALSE);

            break;
            }

        case SCSIOP_START_STOP_UNIT: {

                //
                // Bad Cd-roms
                // STOP command (1B) hangs during shutdown/hibernation on
                // some cd-rom drives. Setting the Immediate bit to 0 seems
                // to work
                //

                PCDB cdb = (PCDB)Srb->Cdb;
                if ((cdb->START_STOP.Immediate == 1) && 
                    (cdb->START_STOP.LoadEject == 0) &&
                    (cdb->START_STOP.Start == 0))

                    cdb->START_STOP.Immediate=0;
                DeviceExtension->scsi2atapi = TRUE;
                break;
            }

        case SCSIOP_FORMAT_UNIT:

            if (DeviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LS120_FORMAT) {

                Srb->Cdb[0] = ATAPI_LS120_FORMAT_UNIT;
                DeviceExtension->scsi2atapi = TRUE;
            }
            break;

        }
    }

    return;
} // Scsi2Atapi



ULONG
AtapiSendCommand(
                IN PVOID HwDeviceExtension,
                IN PSCSI_REQUEST_BLOCK Srb
                )

/*++

Routine Description:

    Send ATAPI packet command to device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PATAPI_REGISTERS_1   baseIoAddress1  = (PATAPI_REGISTERS_1)&deviceExtension->BaseIoAddress1;
    PATAPI_REGISTERS_2   baseIoAddress2 =  (PATAPI_REGISTERS_2)&deviceExtension->BaseIoAddress2;
    ULONG i;
    ULONG flags;
    UCHAR statusByte,byteCountLow,byteCountHigh;


#ifdef ENABLE_48BIT_LBA
    ASSERT(!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA));
#endif

    DebugPrint((DBG_ATAPI_DEVICES,
                "AtapiSendCommand: Command %x to TargetId %d lun %d\n",
                Srb->Cdb[0],
                Srb->TargetId,
                Srb->Lun));

    if (Srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) {
        DebugPrint((DBG_ATAPI_DEVICES,
                    "AtapiSendCommand: xferLength=%x, LBA=%x\n",
                    Srb->DataTransferLength,
                    (((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 |
                     (((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 8) | 
                     (((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 16) |
                     (((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 << 24))
                   ));
    }

    //
    // Make sure command is to ATAPI device.
    //

    flags = deviceExtension->DeviceFlags[Srb->TargetId];

    if (Srb->Lun > deviceExtension->LastLun[Srb->TargetId]) {
        return SRB_STATUS_SELECTION_TIMEOUT;
    }

    if (!(flags & DFLAGS_ATAPI_DEVICE)) {
        return SRB_STATUS_SELECTION_TIMEOUT;
    }

    //
    // Select device 0 or 1.
    //
    SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);


    //
    // Verify that controller is ready for next command.
    //

    GetStatus(baseIoAddress1,statusByte);

    DebugPrint((2,
                "AtapiSendCommand: Entered with status %x\n",
                statusByte));

    if (statusByte & IDE_STATUS_BUSY) {
        DebugPrint((1,
                    "AtapiSendCommand: Device busy (%x)\n",
                    statusByte));
        return SRB_STATUS_BUSY;

    }

    //
    // If a tape drive has doesn't have DSC set and the last command is restrictive, don't send
    // the next command. See discussion of Restrictive Delayed Process commands in QIC-157.
    //

#if 0
    if ((!(statusByte & IDE_STATUS_DSC)) &&
        (flags & DFLAGS_TAPE_DEVICE) && deviceExtension->RDP) {
        KeStallExecutionProcessor(1000);
        DebugPrint((2,"AtapiSendCommand: DSC not set. %x\n",statusByte));
        return SRB_STATUS_BUSY;
    }
#endif

    //
    // Extended RDP to include SEEK commands for CD-ROMS.
    //
    if ((!(statusByte & IDE_STATUS_DSC)) && deviceExtension->RDP &&
        (flags & DFLAGS_RDP_SET)) {

        KeStallExecutionProcessor(1000);

        DebugPrint((DBG_ATAPI_DEVICES,
                    "AtapiSendCommand: DSC not set. %x\n",
                    statusByte
                   ));

        return SRB_STATUS_BUSY;
    }

    if (SRB_IS_RDP(Srb)) {

        deviceExtension->RDP = TRUE;
        SETMASK(deviceExtension->DeviceFlags[Srb->TargetId], DFLAGS_RDP_SET);

        DebugPrint((3,
                    "AtapiSendCommand: %x mapped as DSC restrictive\n",
                    Srb->Cdb[0]));

    } else {

        deviceExtension->RDP = FALSE;
        CLRMASK(deviceExtension->DeviceFlags[Srb->TargetId], DFLAGS_RDP_SET);
    }

    //
    // Convert SCSI to ATAPI commands if needed
    //
    Scsi2Atapi(deviceExtension, Srb);

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    WaitOnBusy(baseIoAddress1,statusByte);

    //
    // Write transfer byte count to registers.
    //

    byteCountLow = (UCHAR)(Srb->DataTransferLength & 0xFF);
    byteCountHigh = (UCHAR)(Srb->DataTransferLength >> 8);

    if (Srb->DataTransferLength >= 0x10000) {
        byteCountLow = byteCountHigh = 0xFF;
    }

    IdePortOutPortByte(baseIoAddress1->ByteCountLow,byteCountLow);
    IdePortOutPortByte(baseIoAddress1->ByteCountHigh, byteCountHigh);

    if (SRB_USES_DMA(Srb)) {
        IdePortOutPortByte(baseIoAddress1->Error, 0x1);
    } else {

        IdePortOutPortByte(baseIoAddress1->Error, 0x0);
    }

    if (flags & DFLAGS_INT_DRQ) {

        //
        // This device interrupts when ready to receive the packet.
        //
        // Write ATAPI packet command.
        //

        deviceExtension->ExpectingInterrupt = TRUE;

        IdePortOutPortByte(baseIoAddress1->Command,
                           IDE_COMMAND_ATAPI_PACKET);

        DebugPrint((3,
                    "AtapiSendCommand: Wait for int. to send packet. Status (%x)\n",
                    statusByte));

        return SRB_STATUS_PENDING;

    } else {

        //
        // Write ATAPI packet command.
        //

        IdePortOutPortByte(baseIoAddress1->Command,
                           IDE_COMMAND_ATAPI_PACKET);

        //
        // Wait for DRQ.
        //

        WaitOnBusy(baseIoAddress1, statusByte);
        WaitForDrq(baseIoAddress1, statusByte);

        if (!(statusByte & IDE_STATUS_DRQ)) {

            DebugPrint((1,
                        "AtapiSendCommand: DRQ never asserted (%x)\n",
                        statusByte));
            return SRB_STATUS_ERROR;
        }
    }

    //
    // Need to read status register.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    //
    // Indicate expecting an interrupt and wait for it.
    //

    deviceExtension->ExpectingInterrupt = TRUE;


    //
    // Send CDB to device.
    //

    WaitOnBusy(baseIoAddress1,statusByte);

    WriteBuffer(baseIoAddress1,
                (PUSHORT)Srb->Cdb,
                6);

    if (SRB_USES_DMA(Srb)) {
        deviceExtension->DMAInProgress = TRUE;
        deviceExtension->BusMasterInterface.BmArm (deviceExtension->BusMasterInterface.Context);
    }

    return SRB_STATUS_PENDING;

} // end AtapiSendCommand()

ULONG
IdeSendFlushCommand(
                   IN PVOID HwDeviceExtension,
                   IN PSCSI_REQUEST_BLOCK Srb
                   )
/*++

Routine Description:

    Program ATA registers for IDE flush command.

Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (pending if all goes well).

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    UCHAR                flushCommand;
    ULONG status;


    //
    // Get the flush command
    //
    flushCommand = deviceExtension->DeviceParameters[Srb->TargetId].IdeFlushCommand;

    //
    // We should check for the case where we have  already queued a 
    // flush cache command. 
    //
    if (flushCommand == IDE_COMMAND_NO_FLUSH) {
        return SRB_STATUS_SUCCESS;
    }

    //
    // if we reached this stage then the device should support flush command
    //
    ASSERT (flushCommand != IDE_COMMAND_NO_FLUSH);

    DebugPrint((1,
                "IdeSendFlushCommand: device %d, srb 0x%x\n",
                Srb->TargetId,
                Srb
               ));

    //
    // Select the right device
    //
    SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);

    //
    // Set data buffer pointer and words left.
    //
    deviceExtension->DataBuffer = (PUCHAR)Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    //
    // Indicate expecting an interrupt.
    //
    deviceExtension->ExpectingInterrupt = TRUE;
    status = SRB_STATUS_PENDING;


    //
    // Program the TaskFile registers
    //
    IdePortOutPortByte(baseIoAddress1->Error,        0);
    IdePortOutPortByte(baseIoAddress1->BlockCount,   0);
    IdePortOutPortByte(baseIoAddress1->BlockNumber,  0);
    IdePortOutPortByte(baseIoAddress1->CylinderLow,  0);
    IdePortOutPortByte(baseIoAddress1->CylinderHigh, 0);
    IdePortOutPortByte(baseIoAddress1->Command,      flushCommand);

    return status;
}

#ifdef ENABLE_48BIT_LBA

ULONG
IdeSendFlushCommandExt(
                      IN PVOID HwDeviceExtension,
                      IN PSCSI_REQUEST_BLOCK Srb
                      )
/*++

Routine Description:

    Program ATA registers for IDE flush ext command.

Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (pending if all goes well).

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    UCHAR                flushCommand;
    ULONG status;
    UCHAR statusByte;


    //
    // the device should support 48 bit LBA
    //
    ASSERT(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA);

    //
    // Get the flush command
    //
    flushCommand = deviceExtension->DeviceParameters[Srb->TargetId].IdeFlushCommandExt;

    //
    // We should check for the case where we have  already queued a 
    // flush cache command. 
    //
    if (flushCommand == IDE_COMMAND_NO_FLUSH) {
        return SRB_STATUS_SUCCESS;
    }

    //
    // if we reached this stage then the device should support flush command
    //
    ASSERT (flushCommand != IDE_COMMAND_NO_FLUSH);

    DebugPrint((1,
                "IdeSendFlushCommand: device %d, srb 0x%x\n",
                Srb->TargetId,
                Srb
               ));

    //
    // Select the right device
    //
    SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);

    //
    // Set data buffer pointer and words left.
    //
    deviceExtension->DataBuffer = (PUCHAR)Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    //
    // Indicate expecting an interrupt.
    //
    deviceExtension->ExpectingInterrupt = TRUE;
    status = SRB_STATUS_PENDING;


    //
    // Program the TaskFile registers (previous content)
    //
    IdePortOutPortByte(baseIoAddress1->Error,        0);
    IdePortOutPortByte(baseIoAddress1->BlockCount,   0);
    IdePortOutPortByte(baseIoAddress1->BlockNumber,  0);
    IdePortOutPortByte(baseIoAddress1->CylinderLow,  0);
    IdePortOutPortByte(baseIoAddress1->CylinderHigh, 0);

    //
    // Program the TaskFile registers (current content)
    //
    IdePortOutPortByte(baseIoAddress1->Error,        0);
    IdePortOutPortByte(baseIoAddress1->BlockCount,   0);
    IdePortOutPortByte(baseIoAddress1->BlockNumber,  0);
    IdePortOutPortByte(baseIoAddress1->CylinderLow,  0);
    IdePortOutPortByte(baseIoAddress1->CylinderHigh, 0);

    IdePortOutPortByte(baseIoAddress1->Command,      flushCommand);

    return status;
}
#endif

ULONG
IdeSendCommand(
              IN PVOID HwDeviceExtension,
              IN PSCSI_REQUEST_BLOCK Srb
              )

/*++

Routine Description:

    Program ATA registers for IDE disk transfer.

Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (pending if all goes well).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    PCDB cdb;

    UCHAR statusByte,errorByte;
    ULONG status;
    ULONG i;
    PMODE_PARAMETER_HEADER   modeData;

    DebugPrint((2,
                "IdeSendCommand: Command %x to device %d\n",
                Srb->Cdb[0],
                Srb->TargetId));



    switch (Srb->Cdb[0]) {
    case SCSIOP_INQUIRY:

        //
        // Filter out all TIDs but 0 and 1 since this is an IDE interface
        // which support up to two devices.
        //

        if ((Srb->Lun != 0) ||
            (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT))) {

            //
            // Indicate no device found at this address.
            //

            status = SRB_STATUS_SELECTION_TIMEOUT;
            break;

        } else {

            INQUIRYDATA     inquiryData;
            PIDENTIFY_DATA  identifyData = &deviceExtension->IdentifyData[Srb->TargetId];

            //
            // Zero INQUIRY data structure.
            //
            RtlZeroMemory(Srb->DataBuffer, Srb->DataTransferLength);

            RtlZeroMemory((PUCHAR) &inquiryData, sizeof(INQUIRYDATA));

            inquiryData.DeviceType = DIRECT_ACCESS_DEVICE;

            //
            // Set the removable bit, if applicable.
            //

            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE) {
                inquiryData.RemovableMedia = 1;
            }

            //
            // Fill in vendor identification fields.
            //

            for (i = 0; i < 20; i += 2) {
                inquiryData.VendorId[i] =
                ((PUCHAR)identifyData->ModelNumber)[i + 1];
                inquiryData.VendorId[i+1] =
                ((PUCHAR)identifyData->ModelNumber)[i];
            }

            //
            // Initialize unused portion of product id.
            //

            for (i = 0; i < 4; i++) {
                inquiryData.ProductId[12+i] = ' ';
            }

            //
            // Move firmware revision from IDENTIFY data to
            // product revision in INQUIRY data.
            //

            for (i = 0; i < 4; i += 2) {
                inquiryData.ProductRevisionLevel[i] =
                ((PUCHAR)identifyData->FirmwareRevision)[i+1];
                inquiryData.ProductRevisionLevel[i+1] =
                ((PUCHAR)identifyData->FirmwareRevision)[i];
            }

            //
            // Copy as much the return data as possible
            //
            RtlMoveMemory (
                          Srb->DataBuffer,
                          &inquiryData,
                          Srb->DataTransferLength > sizeof (INQUIRYDATA) ? 
                          sizeof (INQUIRYDATA) : 
                          Srb->DataTransferLength
                          );

            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SCSIOP_TEST_UNIT_READY:

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {

            //
            // Select device 0 or 1.
            //

            SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);
            IdePortOutPortByte(baseIoAddress1->Command,IDE_COMMAND_GET_MEDIA_STATUS);

            //
            // Wait for busy. If media has not changed, return success
            //

            WaitOnBusy(baseIoAddress1,statusByte);

            if (!(statusByte & IDE_STATUS_ERROR)) {
                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;
            } else {
                errorByte = IdePortInPortByte(baseIoAddress1->Error);
                if (errorByte == IDE_ERROR_DATA_ERROR) {

                    //
                    // Special case: If current media is write-protected,
                    // the 0xDA command will always fail since the write-protect bit
                    // is sticky,so we can ignore this error
                    //

                    GetBaseStatus(baseIoAddress1, statusByte);
                    status = SRB_STATUS_SUCCESS;

                } else {

                    deviceExtension->ReturningMediaStatus = errorByte;

                    //
                    // we need to set the scsi status here. Otherwise we 
                    // won't issue a request sense
                    //
                    Srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
                    Srb->SrbStatus = SRB_STATUS_ERROR;

                    status = SRB_STATUS_ERROR;
                }
            }
        } else {
            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SCSIOP_VERIFY:
#ifdef ENABLE_48BIT_LBA

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA) {

            status = IdeVerifyExt(HwDeviceExtension, Srb);
            break;
        }
#endif
        status = IdeVerify(HwDeviceExtension,Srb);

        break;
#ifdef  DIDE_CPQ_BM
    case SCSIOP_DVD_READ:
    case SCSIOP_REPORT_KEY:
    case SCSIOP_SEND_KEY:
    case SCSIOP_READ_DVD_STRUCTURE:
#endif
    case SCSIOP_READ:
    case SCSIOP_WRITE:

#ifdef ENABLE_48BIT_LBA

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA) {

            status = IdeReadWriteExt(HwDeviceExtension,
                                     Srb);
            break;
        }
#endif
        status = IdeReadWrite(HwDeviceExtension,
                              Srb);
        break;

    case SCSIOP_START_STOP_UNIT:

        //
        //Determine what type of operation we should perform
        //
        cdb = (PCDB)Srb->Cdb;

        if (cdb->START_STOP.LoadEject == 1) {

            SelectIdeLine(baseIoAddress1, Srb->TargetId >> 1);

            //
            // Eject media,
            // first select device 0 or 1.
            //
            WaitOnBusy(baseIoAddress1,statusByte);

            SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);
            IdePortOutPortByte(baseIoAddress1->Command,IDE_COMMAND_MEDIA_EJECT);
        }
        status = SRB_STATUS_SUCCESS;
        break;

    case SCSIOP_MEDIUM_REMOVAL:

        cdb = (PCDB)Srb->Cdb;

        SelectIdeLine(baseIoAddress1, Srb->TargetId >> 1);

        WaitOnBusy(baseIoAddress1,statusByte);

        SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);
        if (cdb->MEDIA_REMOVAL.Prevent == TRUE) {
            IdePortOutPortByte(baseIoAddress1->Command,IDE_COMMAND_DOOR_LOCK);
        } else {
            IdePortOutPortByte(baseIoAddress1->Command,IDE_COMMAND_DOOR_UNLOCK);
        }

        status = SRB_STATUS_SUCCESS;

        WaitOnBusy(baseIoAddress1,statusByte);

        if (statusByte & IDE_STATUS_ERROR) {

            errorByte = IdePortInPortByte(baseIoAddress1->Error);

            status = MapError(HwDeviceExtension, Srb);

        }

        break;

    case SCSIOP_REQUEST_SENSE:
        // this function makes sense buffers to report the results
        // of the original GET_MEDIA_STATUS command

        if ((deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) && 
            (Srb->DataTransferLength >= sizeof(SENSE_DATA))) {
            status = IdeBuildSenseBuffer(HwDeviceExtension, Srb);
        } else {
            status = SRB_STATUS_INVALID_REQUEST;
        }
        break;

    case SCSIOP_SYNCHRONIZE_CACHE:

        DebugPrint((1,
                    "Flush the cache for IDE device %d\n",
                    Srb->TargetId
                   ));

        status = SRB_STATUS_SUCCESS;

        //
        // Send the flush command if one exists
        //
        if (deviceExtension->DeviceParameters[Srb->TargetId].IdeFlushCommand != 
            IDE_COMMAND_NO_FLUSH) {

#ifdef ENABLE_48BIT_LBA
            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA) {

                status = IdeSendFlushCommandExt(HwDeviceExtension,
                                                Srb);
            } else
#endif
                status = IdeSendFlushCommand(deviceExtension, Srb);
        }

        break;

    case SCSIOP_FORMAT_UNIT:
        if ( IsNEC_98 ) {
            // 
            // Support physical format of fixed disk.
            // It is meaningful for SCSI device.
            // So, we do not execute it on IDE device.
            // But we need to return the success in order to fit with SCSI
            // 
            status = SRB_STATUS_SUCCESS;
            break;
        }

    default:

        DebugPrint((1,
                    "IdeSendCommand: Unsupported command %x\n",
                    Srb->Cdb[0]));

        status = SRB_STATUS_INVALID_REQUEST;

    } // end switch

    return status;

} // end IdeSendCommand()

ULONG
IdeSendPassThroughCommand(
                         IN PVOID HwDeviceExtension,
                         IN PSCSI_REQUEST_BLOCK Srb
                         )

/*++

Routine Description:

    Program ATA registers for IDE disk transfer.

Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (pending if all goes well).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    PCDB cdb;
    UCHAR statusByte,errorByte;
    ULONG status;
    PATA_PASS_THROUGH       ataPassThroughData;
    PIDEREGS                pIdeReg;

    ataPassThroughData = Srb->DataBuffer;
    pIdeReg            = &ataPassThroughData->IdeReg;

    //
    // select the right device
    //
    CLRMASK (pIdeReg->bDriveHeadReg, 0xb0);
    pIdeReg->bDriveHeadReg |= (UCHAR) (((Srb->TargetId & 0x1) << 4) | 0xA0);

    SelectIdeDevice(baseIoAddress1, Srb->TargetId, pIdeReg->bDriveHeadReg);

    //
    // check to see if this is a "no-op" SRB 
    //
    if (pIdeReg->bReserved & ATA_PTFLAGS_NO_OP) {

        ULONG repeatCount = (ULONG)ataPassThroughData->IdeReg.bSectorCountReg;
        UCHAR busyWait = pIdeReg->bSectorNumberReg;

        //
        // wait for busy if this is set
        //
        if (busyWait != 0) {

            ULONG busyWaitTime;

            if (busyWait > 30) {

                busyWait = 30;
            }

            busyWaitTime = busyWait * 1000;

            WaitOnBusyUntil(baseIoAddress1, statusByte, busyWaitTime);
        }

        if (repeatCount <= 0) {
            repeatCount = 1;
        }

        while (repeatCount) {
            repeatCount--;

            KeStallExecutionProcessor(100);

            //
            // get a copy of the task file registers
            //
            AtapiTaskRegisterSnapshot (
                                      baseIoAddress1,
                                      pIdeReg
                                      );
        }

        return SRB_STATUS_SUCCESS;
    }

    if (pIdeReg->bReserved & ATA_PTFLAGS_EMPTY_CHANNEL_TEST) {

#ifdef DPC_FOR_EMPTY_CHANNEL
        if (status=IdePortChannelEmptyQuick(baseIoAddress1, baseIoAddress2, 
                                            deviceExtension->MaxIdeDevice, &deviceExtension->CurrentIdeDevice,
                                            &deviceExtension->MoreWait, &deviceExtension->NoRetry)) {
            if (status==STATUS_RETRY) {
                return SRB_STATUS_PENDING;
            }
            return SRB_STATUS_SUCCESS;
        } else {
            return SRB_STATUS_ERROR;
        }
#endif

        if (IdePortChannelEmpty(baseIoAddress1, baseIoAddress2, deviceExtension->MaxIdeDevice)) {

            return SRB_STATUS_SUCCESS;

        } else {

            return SRB_STATUS_ERROR;
        }
    }


    if (pIdeReg->bReserved & ATA_PTFLAGS_INLINE_HARD_RESET) {

        IdeHardReset (
                     baseIoAddress1,
                     baseIoAddress2,
                     FALSE,
                     TRUE
                     );

        //
        // re-select the right device
        //
        SelectIdeDevice(baseIoAddress1, Srb->TargetId, pIdeReg->bDriveHeadReg);
    }

    GetStatus(baseIoAddress1, statusByte);

    if (statusByte & IDE_STATUS_BUSY) {
        DebugPrint((1,
                    "IdeSendPassThroughCommand: Returning BUSY status\n"));
        return SRB_STATUS_BUSY;
    }
    if (pIdeReg->bReserved & ATA_PTFLAGS_STATUS_DRDY_REQUIRED) {

        if (!(statusByte & IDE_STATUS_DRDY)) {

            if ((statusByte == 0)  &&
                (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_SONY_MEMORYSTICK)) {
                statusByte = IDE_STATUS_DRDY;
            } else {
                DebugPrint((1,
                            "IdeSendPassThroughCommand: DRDY not ready\n"));
                return SRB_STATUS_BUSY;
            }
        }
    }
    if (pIdeReg->bCommandReg != IDE_COMMAND_ATAPI_RESET) {

        // if identifydata in device extension is valid, use it

#if 1
        if ((deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_IDENTIFY_VALID) && 
            (pIdeReg->bCommandReg == IDE_COMMAND_IDENTIFY)) {

            ASSERT(!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE));

            DebugPrint((1, "Bypassing identify command\n"));

            RtlMoveMemory(ataPassThroughData->DataBuffer, &(deviceExtension->IdentifyData[Srb->TargetId]), 
                          ataPassThroughData->DataBufferSize);

            return SRB_STATUS_SUCCESS;

        }
#endif
        //
        // Set data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer = ataPassThroughData->DataBuffer;
        deviceExtension->BytesLeft = ataPassThroughData->DataBufferSize;

        //
        // Indicate expecting an interrupt.
        //

        deviceExtension->ExpectingInterrupt = TRUE;
        status = SRB_STATUS_PENDING;

        IdePortOutPortByte(baseIoAddress1->Error,        pIdeReg->bFeaturesReg);
        IdePortOutPortByte(baseIoAddress1->BlockCount,   pIdeReg->bSectorCountReg);
        IdePortOutPortByte(baseIoAddress1->BlockNumber,  pIdeReg->bSectorNumberReg);
        IdePortOutPortByte(baseIoAddress1->CylinderLow,  pIdeReg->bCylLowReg);
        IdePortOutPortByte(baseIoAddress1->CylinderHigh, pIdeReg->bCylHighReg);
        IdePortOutPortByte(baseIoAddress1->Command,      pIdeReg->bCommandReg);

    } else {

        //
        // perform sync. atapi soft reset because this command doesn't generate interrupts
        //
        AtapiSoftReset(baseIoAddress1, baseIoAddress2, Srb->TargetId & 0x1, FALSE);
        status = SRB_STATUS_SUCCESS;
    }

    DebugPrint ((1, "IdeSendPassThroughCommand: 0x%x 0x%x command = 0x%x\n", baseIoAddress1->RegistersBaseAddress, Srb->TargetId, pIdeReg->bCommandReg));

    return status;

} // end IdeSendPassThroughCommand()


VOID
IdeMediaStatus(
              BOOLEAN EnableMSN,
              IN PVOID HwDeviceExtension,
              ULONG DeviceNumber
              )
/*++

Routine Description:

    Enables disables media status notification

Arguments:

HwDeviceExtension - ATAPI driver storage.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress = &deviceExtension->BaseIoAddress1;
    UCHAR statusByte,errorByte;


    if (EnableMSN == TRUE) {

        //
        // If supported enable Media Status Notification support
        //

        if ((deviceExtension->DeviceFlags[DeviceNumber] & DFLAGS_MSN_SUPPORT)) {

            //
            // enable
            //
            SelectIdeDevice(baseIoAddress, DeviceNumber, 0);
            IdePortOutPortByte(baseIoAddress->Error,(UCHAR) (0x95));
            IdePortOutPortByte(baseIoAddress->Command,
                               IDE_COMMAND_SET_FEATURE);

            WaitOnBaseBusy(baseIoAddress,statusByte);

            if (statusByte & IDE_STATUS_ERROR) {
                //
                // Read the error register.
                //
                errorByte = IdePortInPortByte(baseIoAddress->Error);

                DebugPrint((1,
                            "IdeMediaStatus: Error enabling media status. Status %x, error byte %x\n",
                            statusByte,
                            errorByte));
            } else {
                deviceExtension->DeviceFlags[DeviceNumber] |= DFLAGS_MEDIA_STATUS_ENABLED;
                DebugPrint((1,"IdeMediaStatus: Media Status Notification Supported\n"));
                deviceExtension->ReturningMediaStatus = 0;

            }

        }
    } else { // end if EnableMSN == TRUE

        //
        // disable if previously enabled
        //
        if ((deviceExtension->DeviceFlags[DeviceNumber] & DFLAGS_MEDIA_STATUS_ENABLED)) {

            SelectIdeDevice(baseIoAddress, DeviceNumber, 0);
            IdePortOutPortByte(baseIoAddress->Error,(UCHAR) (0x31));
            IdePortOutPortByte(baseIoAddress->Command,
                               IDE_COMMAND_SET_FEATURE);

            WaitOnBaseBusy(baseIoAddress,statusByte);
            CLRMASK (deviceExtension->DeviceFlags[DeviceNumber], DFLAGS_MEDIA_STATUS_ENABLED);
        }


    }

}

ULONG
IdeBuildSenseBuffer(
                   IN PVOID HwDeviceExtension,
                   IN PSCSI_REQUEST_BLOCK Srb
                   )

/*++

Routine Description:

    Builts an artificial sense buffer to report the results of a GET_MEDIA_STATUS
    command. This function is invoked to satisfy the SCSIOP_REQUEST_SENSE.
Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (ALWAYS SUCCESS).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG status;
    PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->DataBuffer;

    if (senseBuffer) {

        if (deviceExtension->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if (deviceExtension->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE_REQ) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_OPERATOR_REQUEST;
            senseBuffer->AdditionalSenseCodeQualifier = SCSI_SENSEQ_MEDIUM_REMOVAL;
        } else if (deviceExtension->ReturningMediaStatus & IDE_ERROR_END_OF_MEDIA) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_NOT_READY;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_NO_MEDIA_IN_DEVICE;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if (deviceExtension->ReturningMediaStatus & IDE_ERROR_DATA_ERROR) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_DATA_PROTECT;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }

        return SRB_STATUS_SUCCESS;
    }
    return SRB_STATUS_ERROR;

}// End of IdeBuildSenseBuffer




BOOLEAN
AtapiStartIo(
            IN PVOID HwDeviceExtension,
            IN PSCSI_REQUEST_BLOCK Srb
            )

/*++

Routine Description:

    This routine is called from the port driver synchronized
    with the kernel to start an IO request.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    TRUE

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG status;

    //
    // Determine which function.
    //

    switch (Srb->Function) {
    
    case SRB_FUNCTION_ATA_POWER_PASS_THROUGH:
    case SRB_FUNCTION_FLUSH:
    case SRB_FUNCTION_SHUTDOWN:
    case SRB_FUNCTION_ATA_PASS_THROUGH:
    case SRB_FUNCTION_EXECUTE_SCSI:

        //
        // Sanity check. Only one request can be outstanding on a
        // controller.
        //

        if (deviceExtension->CurrentSrb) {

            DebugPrint((1,
                        "AtapiStartIo: Already have a request!\n"));
            Srb->SrbStatus = SRB_STATUS_BUSY;
            IdePortNotification(IdeRequestComplete,
                                deviceExtension,
                                Srb);
            return FALSE;
        }

        //
        // Indicate that a request is active on the controller.
        //

        deviceExtension->CurrentSrb = Srb;

        //
        // Send command to device.
        //

        // ATA_PASSTHORUGH
        if ((Srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH) ||
            (Srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH)) {

            status = IdeSendPassThroughCommand(HwDeviceExtension,
                                               Srb);

        } else if ((deviceExtension->DeviceFlags[Srb->TargetId] & 
                    (DFLAGS_ATAPI_DEVICE | DFLAGS_DEVICE_PRESENT)) ==
                   (DFLAGS_ATAPI_DEVICE | DFLAGS_DEVICE_PRESENT)) {

            status = AtapiSendCommand(HwDeviceExtension,
                                      Srb);

        } else if ((Srb->Function == SRB_FUNCTION_FLUSH) ||
                   (Srb->Function == SRB_FUNCTION_SHUTDOWN)) {

#ifdef ENABLE_48BIT_LBA
            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA) {

                status = IdeSendFlushCommandExt(HwDeviceExtension,
                                                Srb);
            } else {
#endif

                status = IdeSendFlushCommand(HwDeviceExtension,
                                             Srb);

#ifdef ENABLE_48BIT_LBA
            }
#endif

        } else if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) {

            status = IdeSendCommand(HwDeviceExtension,
                                    Srb);

        } else {

            status = SRB_STATUS_SELECTION_TIMEOUT;
        }

        break;

    case SRB_FUNCTION_ABORT_COMMAND:

        //
        // Verify that SRB to abort is still outstanding.
        //

        if (!deviceExtension->CurrentSrb) {

            DebugPrint((1, "AtapiStartIo: SRB to abort already completed\n"));

            //
            // Complete abort SRB.
            //

            status = SRB_STATUS_ABORT_FAILED;

            break;
        }

        //
        // Abort function indicates that a request timed out.
        // Call reset routine. Card will only be reset if
        // status indicates something is wrong.
        // Fall through to reset code.
        //

    case SRB_FUNCTION_RESET_BUS:

        //
        // Reset Atapi and SCSI bus.
        //

        DebugPrint((1, "AtapiStartIo: Reset bus request received\n"));

        SelectIdeLine(&deviceExtension->BaseIoAddress1, Srb->TargetId >> 1);

        if (!AtapiSyncResetController(deviceExtension,
                                      Srb->PathId)) {

            DebugPrint((1,"AtapiStartIo: Reset bus failed\n"));

            //
            // Log reset failure.
            //

            IdePortLogError(
                           HwDeviceExtension,
                           NULL,
                           0,
                           0,
                           0,
                           SP_INTERNAL_ADAPTER_ERROR,
                           5 << 8
                           );

            status = SRB_STATUS_ERROR;

        } else {

            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SRB_FUNCTION_IO_CONTROL:

        if (deviceExtension->CurrentSrb) {

            DebugPrint((1,
                        "AtapiStartIo: Already have a request!\n"));
            Srb->SrbStatus = SRB_STATUS_BUSY;
            IdePortNotification(IdeRequestComplete,
                                deviceExtension,
                                Srb);
            return FALSE;
        }

        //
        // Indicate that a request is active on the controller.
        //

        deviceExtension->CurrentSrb = Srb;

        if (strlen("SCSIDISK") != RtlCompareMemory(((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature,"SCSIDISK",strlen("SCSIDISK"))) {

            DebugPrint((1,
                        "AtapiStartIo: IoControl signature incorrect. Send %s, expected %s\n",
                        ((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature,
                        "SCSIDISK"));

            status = SRB_STATUS_INVALID_REQUEST;
            break;
        }

        switch (((PSRB_IO_CONTROL)(Srb->DataBuffer))->ControlCode) {
        
        case IOCTL_SCSI_MINIPORT_SMART_VERSION: {

                PGETVERSIONINPARAMS versionParameters = (PGETVERSIONINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                UCHAR deviceNumber;
                UCHAR channelNo;

                //
                // Version and revision per SMART 1.03
                //

                versionParameters->bVersion = 1;
                versionParameters->bRevision = 1;
                versionParameters->bReserved = 0;

                //
                // Indicate that support for IDE IDENTIFY, ATAPI IDENTIFY and SMART commands.
                //

                versionParameters->fCapabilities = (CAP_ATA_ID_CMD | CAP_ATAPI_ID_CMD | CAP_SMART_CMD);

                //
                // This is done because of how the IOCTL_SCSI_MINIPORT
                // determines 'targetid's'. Disk.sys places the real target id value
                // in the DeviceMap field. Once we do some parameter checking, the value passed
                // back to the application will be determined.
                //

                //
                // HACK: atapi doesn't have the channel number. So it uses the hack below.
                // this should work on non native mode IDE controllers
                //
                channelNo = (deviceExtension->PrimaryAddress)? 0:1;

                //
                // the bIDEDeviceMap is a bit map, with the bits defined as follows
                // bit 0 - IDE drive as master on Primary channel
                // bit 1 - IDE drive as slave on Primary channel
                // bit 2 - IDE drive as master on Secondary channel
                // bit 3 - IDE drive as slave on Secondary Channel
                // bit 4 - ATAPI drive as master on Primary Channle
                // bit 5 - ATAPI drive as slave on Primary Channle
                // bit 6 - ATAPI drive as master on secondary Channle
                // bit 7 - ATAPI drive as slave on secondary Channle
                //
                // since we have an FDO per channel, we can only fill in the fields
                // pertinent to this channel. 
                //

                versionParameters->bIDEDeviceMap = 0;

                //
                // Master device
                //
                deviceNumber = 0;
                if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {
                    if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_ATAPI_DEVICE) {

                        deviceNumber += channelNo*2 + 4;

                    } else {

                        deviceNumber += channelNo*2;

                    }

                    versionParameters->bIDEDeviceMap |= (1 << deviceNumber);
                }

                //
                // slave device
                //
                deviceNumber = 1;
                if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {
                    if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_ATAPI_DEVICE) {

                        deviceNumber += channelNo*2 + 4;

                    } else {

                        deviceNumber += channelNo*2;

                    }

                    versionParameters->bIDEDeviceMap |= (1 << deviceNumber);
                }

                status = SRB_STATUS_SUCCESS;
                break;
            }

        case IOCTL_SCSI_MINIPORT_IDENTIFY: {

                PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                SENDCMDINPARAMS   cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                ULONG             i;
                UCHAR             targetId;


                if (cmdInParameters.irDriveRegs.bCommandReg == ID_CMD) {

                    //
                    // Extract the target.
                    //

                    targetId = cmdInParameters.bDriveNumber;

                    if (!(deviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT) ||
                        (deviceExtension->DeviceFlags[targetId] & DFLAGS_ATAPI_DEVICE)) {

                        status = SRB_STATUS_SELECTION_TIMEOUT;
                        break;
                    }

                    //
                    // Zero the output buffer
                    //

                    for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE - 1); i++) {
                        ((PUCHAR)cmdOutParameters)[i] = 0;
                    }

                    //
                    // Build status block.
                    //

                    cmdOutParameters->cBufferSize = IDENTIFY_BUFFER_SIZE;
                    cmdOutParameters->DriverStatus.bDriverError = 0;
                    cmdOutParameters->DriverStatus.bIDEError = 0;

                    //
                    // Extract the identify data from the device extension.
                    //

                    RtlMoveMemory (cmdOutParameters->bBuffer, &deviceExtension->IdentifyData[targetId], IDENTIFY_DATA_SIZE);

                    status = SRB_STATUS_SUCCESS;


                } else {
                    status = SRB_STATUS_INVALID_REQUEST;
                }
                break;
            }

        case  IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS:
        case  IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS:
        case  IOCTL_SCSI_MINIPORT_ENABLE_SMART:
        case  IOCTL_SCSI_MINIPORT_DISABLE_SMART:
        case  IOCTL_SCSI_MINIPORT_RETURN_STATUS:
        case  IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE:
        case  IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES:
        case  IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS:
        case  IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTO_OFFLINE:
#ifdef ENABLE_SMARTLOG_SUPPORT
        case  IOCTL_SCSI_MINIPORT_READ_SMART_LOG:
        case  IOCTL_SCSI_MINIPORT_WRITE_SMART_LOG:
#endif

            status = IdeSendSmartCommand(HwDeviceExtension,Srb);
            break;

        default :

            status = SRB_STATUS_INVALID_REQUEST;
            break;

        }

        break;

    default:

        //
        // Indicate unsupported command.
        //

        status = SRB_STATUS_INVALID_REQUEST;

        break;

    } // end switch

    //
    // Check if command complete.
    //

    if (status != SRB_STATUS_PENDING) {

        DebugPrint((2,
                    "AtapiStartIo: Srb %x complete with status %x\n",
                    Srb,
                    status));

        //
        // Clear current SRB.
        //

        deviceExtension->CurrentSrb = NULL;

        //
        // Set status in SRB.
        //

        Srb->SrbStatus = (UCHAR)status;

        //
        // Indicate command complete.
        //

        IdePortNotification(IdeRequestComplete,
                            deviceExtension,
                            Srb);

        //
        // Indicate ready for next request.
        //

        IdePortNotification(IdeNextRequest,
                            deviceExtension,
                            NULL);
    }

    return TRUE;

} // end AtapiStartIo()

BOOLEAN
AtapiSyncResetController(
                        IN PVOID  HwDeviceExtension,
                        IN ULONG  PathId
                        )
{
    ULONG   callAgain = 0;
    BOOLEAN result;

    do {

        result = AtapiResetController(
                                     HwDeviceExtension,
                                     PathId,
                                     &callAgain
                                     );

    } while (callAgain);

    return result;
}


NTSTATUS
IdeHardReset (
             PIDE_REGISTERS_1     BaseIoAddress1,
             PIDE_REGISTERS_2     BaseIoAddress2,
             BOOLEAN              InterruptOff,
             BOOLEAN              Sync
             )
{
    UCHAR resetByte;

    DebugPrint((1,
                "IdeHardReset: Resetting controller.\n"));

    //
    // Kingston DP-ATA/20 pcmcia flash card
    //
    // if we don't make sure we select master device,
    // later when we check for busy status, we will
    // get the non-existing slave status
    //
    IdePortOutPortByte (BaseIoAddress1->DriveSelect, 0xA0);

    IdePortOutPortByte (BaseIoAddress2->DeviceControl, IDE_DC_RESET_CONTROLLER | IDE_DC_DISABLE_INTERRUPTS);

    //
    // ATA-2 spec requires a minimum of 5 microsec stall here
    //
    KeStallExecutionProcessor (10);

    if (InterruptOff) {
        resetByte = IDE_DC_DISABLE_INTERRUPTS;

    } else {
        resetByte = IDE_DC_REENABLE_CONTROLLER;
    }

    IdePortOutPortByte (BaseIoAddress2->DeviceControl, resetByte);

    //
    // ATA-2 spec requires a minimum of 400 ns stall here
    //
    KeStallExecutionProcessor (1);

    if (Sync) {

        UCHAR deviceSelect;
        UCHAR status;
        ULONG sec;                                                      
        ULONG i;                                                        
        UCHAR statusByte;

        WaitOnBusyUntil(BaseIoAddress1, statusByte, 500);

        IdePortOutPortByte (BaseIoAddress1->DriveSelect, 0xa0);
        deviceSelect = IdePortInPortByte(BaseIoAddress1->DriveSelect);
        if (deviceSelect != 0xa0) {

            //
            // slave only channel
            //
            KeStallExecutionProcessor(1000);                     
            IdePortOutPortByte (BaseIoAddress1->DriveSelect, 0xb0);
        }

        //
        // ATA-2 spec allows a maximum of 31s for both master and slave device to come back from reset
        //
        for (sec=0; sec<31; sec++) {

            /**/                                                        
            /* one second loop */                                       
            /**/                                                        
            for (i=0; i<2500; i++) {
                GetStatus(BaseIoAddress1, status);                       
                if (status & IDE_STATUS_BUSY) {
                    KeStallExecutionProcessor(400);                     
                    continue;                                           
                } else {
                    break;                                              
                }                                                       
            }                                                           
            if (status == 0xff) {
                break;                                                  
            } else if (status & IDE_STATUS_BUSY) {
                DebugPrint ((0, "ATAPI: IdeHardReset WaitOnBusy failed. status = 0x%x\n", (ULONG) (status))); 
            } else {
                break;                                                  
            }                                                           
        }                                                               

        if (status & IDE_STATUS_BUSY) {

            DebugPrint ((0, "ATAPI: IdeHardReset WaitOnBusy failed. status = 0x%x\n", (ULONG) (status))); 

            return STATUS_UNSUCCESSFUL;

        } else {

            return STATUS_SUCCESS;
        }

    } else {

        return STATUS_SUCCESS;
    }
}


VOID
AtapiTaskRegisterSnapshot (
                          IN PIDE_REGISTERS_1 CmdRegBase,
                          IN OUT PIDEREGS     IdeReg
                          )
{
    ASSERT(IdeReg);

    IdeReg->bFeaturesReg     = IdePortInPortByte(CmdRegBase->Error);
    IdeReg->bSectorCountReg  = IdePortInPortByte(CmdRegBase->BlockCount);
    IdeReg->bSectorNumberReg = IdePortInPortByte(CmdRegBase->BlockNumber);
    IdeReg->bCylLowReg       = IdePortInPortByte(CmdRegBase->CylinderLow);
    IdeReg->bCylHighReg      = IdePortInPortByte(CmdRegBase->CylinderHigh);
    IdeReg->bDriveHeadReg    = IdePortInPortByte(CmdRegBase->DriveSelect);
    IdeReg->bCommandReg      = IdePortInPortByte(CmdRegBase->Command);

    return;
} // AtapiTaskFileSnapshot

BOOLEAN
GetAtapiIdentifyQuick (
    IN PIDE_REGISTERS_1 BaseIoAddress1,
    IN PIDE_REGISTERS_2 BaseIoAddress2,
    IN ULONG DeviceNumber,
    OUT PIDENTIFY_DATA IdentifyData
    )
{
    UCHAR statusByte;
    ULONG i;

    SelectIdeDevice(BaseIoAddress1, DeviceNumber, 0);

    GetStatus(BaseIoAddress1, statusByte);

    if (statusByte & IDE_STATUS_BUSY) {

        return FALSE;
    }

    IdePortOutPortByte(BaseIoAddress1->Command, IDE_COMMAND_ATAPI_IDENTIFY);

    WaitOnBusyUntil(BaseIoAddress1, statusByte, 500);

    if ((statusByte & IDE_STATUS_BUSY) ||
        (statusByte & IDE_STATUS_ERROR)) {

        return FALSE;
    }
    
    if (statusByte & IDE_STATUS_DRQ) {

        ReadBuffer(BaseIoAddress1,
                   (PUSHORT)IdentifyData,
                   sizeof (IDENTIFY_DATA) / 2);

    }

    GetStatus(BaseIoAddress1, statusByte);

    //
    // pull out any remaining bytes and throw away.
    //
    i=0;
    while ((statusByte & IDE_STATUS_DRQ) && (i < 100)) {

        READ_PORT_USHORT(BaseIoAddress1->Data);

        GetStatus(BaseIoAddress1, statusByte);

        KeStallExecutionProcessor(50);

        i++;
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\mode3fdc\desk2fdc\q117enum.c ===
/*****************************************************************************
*
* COPYRIGHT 1993 - COLORADO MEMORY SYSTEMS, INC.
* COPYRIGHT 1997 - COLORADO SOFTWARE ARCHITECTS, INC.
*
* ALL RIGHTS RESERVED.
*
******************************************************************************
*
* FUNCTION: cqd_LocateDevice
*
* PURPOSE:
*
*****************************************************************************/

#ifdef NO_INC_LLP64
typedef unsigned int UINT_PTR;
typedef int  INT_PTR;
typedef UINT_PTR ULONG_PTR;
typedef INT_PTR LONG_PTR;
#endif

#include <ntddk.h>
#include <ntddfdc.h>
#include "q117_dat.h"
/*endinclude*/

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,cqd_LocateDevice)
#pragma alloc_text(PAGE,cqd_InitializeContext)
#pragma alloc_text(PAGE,cqd_LookForDevice)
#pragma alloc_text(PAGE,cqd_SendPhantomSelect)
#pragma alloc_text(PAGE,cqd_CmdSelectDevice)
#pragma alloc_text(PAGE,cqd_CmdDeselectDevice)
#pragma alloc_text(PAGE,cqd_ConnerPreamble)
#pragma alloc_text(PAGE,cqd_DeselectDevice)
#pragma alloc_text(PAGE,cqd_SendByte)
#pragma alloc_text(PAGE,cqd_ReceiveByte)
#pragma alloc_text(PAGE,cqd_GetDeviceError)
#pragma alloc_text(PAGE,cqd_WaitActive)
#pragma alloc_text(PAGE,cqd_GetStatus)
#pragma alloc_text(PAGE,cqd_WaitCommandComplete)
#pragma alloc_text(PAGE,cqd_Report)
#pragma alloc_text(PAGE,cqd_ClearTapeError)
#pragma alloc_text(PAGE,cqd_ResetFDC)
#pragma alloc_text(PAGE,cqd_ConfigureFDC)
#pragma alloc_text(PAGE,cqd_DCROut)
#pragma alloc_text(PAGE,cqd_DSROut)
#pragma alloc_text(PAGE,cqd_TDROut)
#pragma alloc_text(PAGE,cqd_IssueFDCCommand)
#pragma alloc_text(PAGE,kdi_Error)
#pragma alloc_text(PAGE,kdi_GetErrorType)
#pragma alloc_text(PAGE,kdi_ReportAbortStatus)
#pragma alloc_text(PAGE,kdi_GetSystemTime)
#pragma alloc_text(PAGE,kdi_GetInterfaceType)
// #pragma alloc_text(PAGE,kdi_CheckedDump)
#pragma alloc_text(PAGE,kdi_Sleep)
#pragma alloc_text(PAGE,kdi_FdcDeviceIo)
#endif

#define FCT_ID 0x11017

NTSTATUS 
cqd_LocateDevice(
    IN PVOID context,
    IN PUCHAR vendor_detected
    )
/* COMMENTS: *****************************************************************
*
* The drive search must be done in a specific order.  Drives which use only a
* hardware select scheme must be searched first.  If they are not, some of
* them will simulate another manufacturers drive based on the SW select they
* receive.  In many cases this simulation is incomplete and must not be used.
* Whenever possible, an attempt must be made to select a drive in it's native
* mode.
*
* DEFINITIONS: *************************************************************/
{
    NTSTATUS status;          // NTSTATUS or error condition.
    USHORT i;                   // loop variable
	CqdContextPtr cqd_context;
    BOOLEAN found = FALSE;
    USHORT ven;
    UCHAR drv;
    USHORT seq;

    cqd_context = (CqdContextPtr)context;

    for ( i = 0; i < FIND_RETRIES && !found; i++ ) {

        seq = 0;

        do {
            ++seq;
            switch(seq) {
            case 1:  ven = VENDOR_UNKNOWN;          drv = DRIVEU;   break;
            case 2:  ven = VENDOR_MOUNTAIN_SUMMIT;  drv = DRIVEU;   break;
            case 3:  ven = VENDOR_CMS;              drv = DRIVEU;   break;
            case 4:  ven = VENDOR_UNKNOWN;          drv = DRIVED;   break;
            case 5:  ven = VENDOR_MOUNTAIN_SUMMIT;  drv = DRIVED;   break;
            case 6:  ven = VENDOR_CMS;              drv = DRIVED;   break;
#ifdef B_DRIVE
            case 7:  ven = VENDOR_CMS;              drv = DRIVEB;   break;
            case 8:  ven = VENDOR_UNKNOWN;          drv = DRIVEUB;  break;
            case 9:  ven = VENDOR_MOUNTAIN_SUMMIT;  drv = DRIVEUB;  break;
            case 10: ven = VENDOR_CMS;              drv = DRIVEUB;  break;
#endif
            default:
                //ASSERT(seq != seq);
                seq = 0;    // flag complete
                break;
            }

            if (seq) {
                cqd_context->device_descriptor.vendor = ven;
                cqd_ResetFDC( cqd_context );
                status = cqd_LookForDevice( cqd_context,
                                            drv,
                                            vendor_detected,
                                            &found);

            }

        } while(!found && seq);

        // If not found, Wait a second, and retry
        if (!found)
            kdi_Sleep(cqd_context->kdi_context, kdi_wt001s);
    }

   // Sort out the results of the drive address search.  A DriveFlt or a
   // CmdFlt indicate that we could never successfully communicate with
   // the tape drive at either address so we must assume that there is
   // no tape drive present. A NECFlt indicates that we had serious
   // trouble talking to the FDC so we must assume that it is either
   // broken or not there.  The last thing to consider here is a TapeFlt.
   // If the TapeFlt indicates either a hardware or software reset it is
   // save to continue and the error can be ignored (since we must be
   // starting a tape session neither of these errors should bother us).
   // If the TapeFlt indicates any other error, it probably means some
   // badness has happened.

    switch (kdi_GetErrorType(status)) {

    case ERR_DRIVE_FAULT:
    case ERR_CMD_FAULT:
    case ERR_CMD_OVERRUN:
        status = kdi_Error(ERR_NO_DRIVE, FCT_ID, ERR_SEQ_1);
        break;

    case ERR_FDC_FAULT:
    case ERR_INVALID_FDC_STATUS:
        status = kdi_Error(ERR_NO_FDC, FCT_ID, ERR_SEQ_1);
        break;

    case ERR_INVALID_COMMAND:
        break;

    default:
        status = STATUS_SUCCESS;
        break;

    }

#if DBG

    if (status) {

        kdi_CheckedDump( QIC117INFO,
                         "Q117i: DLocateDrv Failed %08x\n",
                         status);
    }

#endif

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x11009

VOID 
cqd_InitializeContext(
    IN PVOID cqd_context,
    IN PVOID kdi_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_InitializeContext
*
* PURPOSE: Initialize the common driver context.
*
*****************************************************************************/
{

    RtlZeroMemory( cqd_context, sizeof(CqdContext) );
    ((CqdContextPtr)cqd_context)->kdi_context = kdi_context;
    ((CqdContextPtr)cqd_context)->pegasus_supported = TRUE;
    ((CqdContextPtr)cqd_context)->configured = FALSE;
    ((CqdContextPtr)cqd_context)->cms_mode = FALSE;
    ((CqdContextPtr)cqd_context)->selected = FALSE;
    ((CqdContextPtr)cqd_context)->cmd_selected = FALSE;
    ((CqdContextPtr)cqd_context)->operation_status.no_tape = TRUE;
    ((CqdContextPtr)cqd_context)->device_cfg.speed_change = TRUE;
    ((CqdContextPtr)cqd_context)->drive_parms.mode = PRIMARY_MODE;
    ((CqdContextPtr)cqd_context)->device_descriptor.vendor = VENDOR_UNKNOWN;
    ((CqdContextPtr)cqd_context)->device_descriptor.fdc_type = FDC_TYPE_UNKNOWN;
    ((CqdContextPtr)cqd_context)->controller_data.isr_reentered = 0;
    ((CqdContextPtr)cqd_context)->controller_data.start_format_mode = FALSE;
    ((CqdContextPtr)cqd_context)->controller_data.end_format_mode = FALSE;
    ((CqdContextPtr)cqd_context)->controller_data.perpendicular_mode = FALSE;
    ((CqdContextPtr)cqd_context)->operation_status.xfer_rate = XFER_500Kbps;
    ((CqdContextPtr)cqd_context)->operation_status.retry_mode = FALSE;
    ((CqdContextPtr)cqd_context)->xfer_rate.tape = TAPE_500Kbps;
    ((CqdContextPtr)cqd_context)->xfer_rate.fdc = FDC_500Kbps;
    ((CqdContextPtr)cqd_context)->xfer_rate.srt = SRT_500Kbps;

#if DBG
    ((CqdContextPtr)cqd_context)->dbg_head =
                                ((CqdContextPtr)cqd_context)->dbg_tail = 0;
#endif

    return;
}

#undef FCT_ID
#define FCT_ID 0x1102c

NTSTATUS 
cqd_LookForDevice(
    IN CqdContextPtr cqd_context,
    IN UCHAR drive_selector,
    IN BOOLEAN *vendor_detected,
    IN BOOLEAN *found
    )
/*****************************************************************************
*
* FUNCTION: cqd_LookForDevice
*
* PURPOSE:
*
*****************************************************************************/
{
    NTSTATUS status;    /* NTSTATUS or error condition.*/

   /* Set the drive select parameters according to the desired target drive */
   /* selector. */

    switch (drive_selector) {

    case DRIVEB:
        cqd_context->device_cfg.select_byte = selb;
        cqd_context->device_cfg.deselect_byte = dselb;
        cqd_context->device_cfg.drive_select = curb;
        break;

    case DRIVED:
        cqd_context->device_cfg.select_byte = seld;
        cqd_context->device_cfg.deselect_byte = dseld;
        cqd_context->device_cfg.drive_select = curd;
        break;

    case DRIVEU:
        cqd_context->device_cfg.select_byte = selu;
        cqd_context->device_cfg.deselect_byte = dselu;
        cqd_context->device_cfg.drive_select = curu;
        break;

    case DRIVEUB:
        cqd_context->device_cfg.select_byte = selub;
        cqd_context->device_cfg.deselect_byte = dselub;
        cqd_context->device_cfg.drive_select = curub;
        break;

    }

   /* Try to communicate with the tape drive by requesting drive status. */
   /* If we can successfully communicate with the drive, wait up to the */
   /* approximate maximum autoload time (150 seconds) for the tape drive */
   /* to become ready. This should cover a new tape being inserted */
   /* immediatley before starting a tape session. */

    *vendor_detected = FALSE;
    *found = FALSE;

    if ((status = cqd_CmdSelectDevice(cqd_context)) == STATUS_SUCCESS) {

        status = cqd_GetDeviceError(cqd_context);
        if (kdi_GetErrorType(status) != ERR_DRIVE_FAULT &&
            kdi_GetErrorType(status) != ERR_CMD_FAULT) {

            *found = TRUE;

            if ((status = cqd_SendByte(cqd_context, FW_CMD_REPORT_VENDOR32)) ==
                 STATUS_SUCCESS) {

                USHORT vendor_id;

                if ((status = cqd_ReceiveByte(
                                cqd_context,
                                READ_WORD,
                                (USHORT *)&vendor_id)) != STATUS_SUCCESS) {
                    cqd_GetDeviceError(cqd_context);
                } else {
                    //
                    // Identify the drive (just new drives that support the
                    // vendor 32 command.  This is needed, as the TEAC drive
                    // can not be de-selected (without it needing to
                    // re-autoload).
                    cqd_context->device_descriptor.vendor =
                                            (USHORT)(vendor_id >> 6);
                    cqd_context->device_descriptor.model =
                                            (UCHAR)(vendor_id & ~VENDOR_MASK);
                    *vendor_detected = TRUE;
                    kdi_CheckedDump(
                        QIC117INFO,
                        "Q117i: Report Vendor 32 succeded (%x) \n", vendor_id);
                    if (cqd_context->device_descriptor.vendor == VENDOR_TEAC &&
                        cqd_context->device_descriptor.model == TEAC_TR1) {
                        // TEAC-800 Does not allow a deselect (except through
                        // a reset)
                        cqd_context->deselect_cmd = 0;
                    }
                }
            }
        }

        cqd_DeselectDevice(cqd_context);
   }

    return status;
}

#undef FCT_ID
#define FCT_ID 0x11040

NTSTATUS 
cqd_SendPhantomSelect(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_SendPhantomSelect
*
* PURPOSE:
*
*****************************************************************************/
{
    NTSTATUS status=STATUS_SUCCESS;    /* NTSTATUS or error condition.*/
    status = cqd_SendByte( cqd_context, FW_CMD_SELECT_DRIVE );
    if ( status == STATUS_SUCCESS ) {

       kdi_Sleep( cqd_context->kdi_context, INTERVAL_CMD );
       status = cqd_SendByte( cqd_context,
                       (UCHAR)(cqd_context->device_cfg.drive_id + CMD_OFFSET));

        // For teac,  use conner's deselect and cms's slelect
        kdi_Sleep( cqd_context->kdi_context, kdi_wt001s );
        cqd_context->deselect_cmd = FW_CMD_DESELECT_DRIVE;
    }
    return status;
}

NTSTATUS 
cqd_CmdSelectDevice(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_CmdSelectDevice
*
* PURPOSE:
*
*****************************************************************************/
{

    NTSTATUS status = STATUS_SUCCESS;    /* NTSTATUS or error condition.*/
    KdiContextPtr kdi_context;
    FDC_ENABLE_PARMS    fdcEnableParms;

    if (cqd_context->selected == FALSE) {

        kdi_context = cqd_context->kdi_context;

        fdcEnableParms.DriveOnValue = cqd_context->device_cfg.select_byte;
        fdcEnableParms.TimeToWait = 0;

        status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                                  IOCTL_DISK_INTERNAL_ENABLE_FDC_DEVICE,
                                  &fdcEnableParms );

        if (status == STATUS_SUCCESS &&
            (cqd_context->device_cfg.select_byte == seld ||
             cqd_context->device_cfg.select_byte == selu ||
             cqd_context->device_cfg.select_byte == selub) &&
             cqd_context->device_cfg.drive_select != curb) {

            switch ( cqd_context->device_descriptor.vendor ) {

                case VENDOR_UNKNOWN:
                case VENDOR_UNASSIGNED:
                case VENDOR_UNSUPPORTED:
                case VENDOR_PERTEC:
                    cqd_context->deselect_cmd = 0;
                    //Do nothing.
                    break;

                case VENDOR_MOUNTAIN_SUMMIT:
                case VENDOR_ARCHIVE_CONNER:
                case VENDOR_CORE:
                status = cqd_ConnerPreamble(cqd_context, TRUE);
                    cqd_context->deselect_cmd = FW_CMD_CONNER_DESELECT;
                    break;

                case VENDOR_TEAC:
                    if (cqd_context->device_descriptor.model == TEAC_TR1) {
                        // For the teac-800 drive,  we will never deselect the
                        // device (reset is the only way to do so,  not good).
                        // If,  however,  the drive was deselected (reset) by a
                        // floppy drive access, we must take care of that
                        // condition here

                        // Assume the drive is active and send it a device
                        // error command
                        status = cqd_GetDeviceError(cqd_context);

                        // if one of these error occurs,  then the drive was
                        // reset.
                        if (kdi_GetErrorType(status) == ERR_DRIVE_FAULT ||
                            kdi_GetErrorType(status) == ERR_CMD_FAULT) {
                            // the drive must have been reset,  now send the
                            // drive select command, and wait for the drive to
                            // autoload.
                            status = cqd_SendPhantomSelect(cqd_context);

                            // Force no deselect,  We will always leave the
                            // drive selected
                            cqd_context->deselect_cmd = 0;

                            // Wait for the tape to autoload
                            if (status == STATUS_SUCCESS) {
                                status = cqd_ClearTapeError(cqd_context);
                                status = STATUS_SUCCESS;
                            }
                        } else {
                            status = STATUS_SUCCESS;
                            //status = cqd_ClearTapeError(cqd_context);
                        }
                    } else {
                        status = cqd_SendPhantomSelect(cqd_context);
                    }
                    break;

                case VENDOR_IOMEGA:
                case VENDOR_CMS:
                default:
                    status = cqd_SendPhantomSelect(cqd_context);
                    break;
            }
        }

        if (status == STATUS_SUCCESS) {

            cqd_context->selected = TRUE;

        }

        kdi_Sleep(cqd_context->kdi_context, INTERVAL_CMD );
   }

   return status;
}

#undef  FCT_ID
#define FCT_ID 0x1100C

VOID 
cqd_CmdDeselectDevice(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN drive_selected
    )
/*****************************************************************************
*
* FUNCTION: cqd_CmdDeselectDevice
*
* PURPOSE: Deselect the device and release any locked resources
*
*****************************************************************************/
{

    /* reset the FDC to ensure reliable drive communications */
    (VOID) cqd_ResetFDC(cqd_context);

    if (drive_selected) {

        (VOID) cqd_DeselectDevice(cqd_context);

    }

    /* Dont issue a pause after this command */
    cqd_context->no_pause = TRUE;
    cqd_context->operation_status.new_tape = FALSE;

    return;
}

#undef  FCT_ID
#define FCT_ID 0x1102D

NTSTATUS 
cqd_ConnerPreamble(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN select
    )
/*****************************************************************************
*
* FUNCTION: cqd_ConnerPreamble
*
* PURPOSE:
*
*****************************************************************************/
{
    NTSTATUS status;    /* NTSTATUS or error condition.*/

    if (select) {

        status = cqd_SendByte(cqd_context, FW_CMD_CONNER_SELECT_1);
        if (status == STATUS_SUCCESS) {

            kdi_Sleep(cqd_context->kdi_context, INTERVAL_CMD );
            status = cqd_SendByte(cqd_context, FW_CMD_CONNER_SELECT_2);
            kdi_Sleep(cqd_context->kdi_context, INTERVAL_CMD );

        }

    } else {

        status = cqd_SendByte(cqd_context, cqd_context->deselect_cmd);
        kdi_Sleep(cqd_context->kdi_context, INTERVAL_CMD );

    }

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x1101D

NTSTATUS 
cqd_DeselectDevice(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_DeselectDevice
*
* PURPOSE: Deselect the tape drive by making the select line inactive (high).
*
*****************************************************************************/
{

    NTSTATUS status=STATUS_SUCCESS;    /* NTSTATUS or error condition.*/
    KdiContextPtr kdi_context;

    if (cqd_context->selected == TRUE) {

        if ((cqd_context->device_cfg.select_byte == seld ||
             cqd_context->device_cfg.select_byte == selu ||
             cqd_context->device_cfg.select_byte == selub) &&
             cqd_context->device_cfg.drive_select != curb) {

            if (cqd_context->deselect_cmd) {
                status = cqd_SendByte(cqd_context, cqd_context->deselect_cmd);
                kdi_Sleep(cqd_context->kdi_context, kdi_wt500ms );
            }
        }

        kdi_context = cqd_context->kdi_context;

        status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                                  IOCTL_DISK_INTERNAL_DISABLE_FDC_DEVICE,
                                  NULL );

        cqd_context->selected = FALSE;
        kdi_Sleep(cqd_context->kdi_context, INTERVAL_CMD );
    }

    return status;
}

#undef FCT_ID
#define FCT_ID 0x11041

NTSTATUS 
cqd_SendByte(
    IN CqdContextPtr cqd_context,
    IN UCHAR command
    )
/*****************************************************************************
*
* FUNCTION: cqd_SendByte
*
* PURPOSE: Transmit a command to the tape drive using step pulses
*          generated by the FDC.
*
*          Using the Present Cylinder Number (pcn) of the FDC
*          calculate a New Cylinder Number (ncn) that will make
*          the FDC generate the number of step pulses corresponding
*          to the command byte.
*
*          Execute a Seek with the FDC.
*
*          Sense Interrupt NTSTATUS of the FDC and make sure that the
*          pcn concurs with the ncn, which indicates that the correct
*          number of step pulses were issued.
*
*****************************************************************************/
{

    NTSTATUS status = STATUS_SUCCESS;    /* NTSTATUS or error condition.*/
    FDC_CMD_SEEK seek;
    FDC_CMD_SENSE_INTERRUPT_STATUS sense_int;
    FDC_RESULT result;
#if DBG
    BOOLEAN save;
#endif

#if DBG
   /* Lockout commands used to receive the status */
    save = cqd_context->dbg_lockout;
    cqd_context->dbg_lockout = TRUE;
#endif

    if (command >= MAX_FDC_SEEK || command <= 0) {

#if DBG
        cqd_context->dbg_lockout = save;
#endif
        return kdi_Error(ERR_INVALID_COMMAND, FCT_ID, ERR_SEQ_1);

    }

    if (cqd_context->controller_data.fdc_pcn < MAX_FDC_SEEK) {

        seek.NCN = (UCHAR)(cqd_context->controller_data.fdc_pcn + command);

    } else {

        seek.NCN = (UCHAR)(cqd_context->controller_data.fdc_pcn - command);

    }

    seek.cmd = COMMND_SEEK;
    seek.drive = (UCHAR)cqd_context->device_cfg.drive_select;

    status = cqd_IssueFDCCommand( cqd_context,
                                  (UCHAR *)&seek,
                                  (UCHAR *)&result,
                                  NULL,
                                  0,
                                  0,
                                  kdi_wt001s);

    if (status != STATUS_SUCCESS) {

        return status;

    }

    /* If the sense interrupt status is O.K., then proceed as if */
    /* nothing happened. If, however, there is an error returned by */
    /* status register 0, then return a FDCFLT. */

    if (!(result.ST0 & ST0_IC)) {

        /* If we timed out, then we did the sense interrupt status */
        /* without clearing the interrupt from the interrupt controller. */
        /* Since the FDC did not indicate an error, we assume that we */
        /* missed the interrupt and send the EOI. Only needed for an */
        /* 82072. */

        if (kdi_GetInterfaceType(cqd_context->kdi_context) != MICRO_CHANNEL) {

            if (result.ST0 !=
                (UCHAR)(cqd_context->device_cfg.drive_select | ST0_SE)) {

#if DBG
                cqd_context->dbg_lockout = save;
#endif
                return kdi_Error(ERR_FDC_FAULT, FCT_ID, ERR_SEQ_1);

            }
        }

        if (seek.NCN != result.PCN) {

#if DBG
            cqd_context->dbg_lockout = save;
#endif
            return kdi_Error(ERR_CMD_FAULT, FCT_ID, ERR_SEQ_1);

        }

        cqd_context->controller_data.fdc_pcn = result.PCN;

    } else {

#if DBG
        cqd_context->dbg_lockout = save;
#endif
        return kdi_Error(ERR_FDC_FAULT, FCT_ID, ERR_SEQ_2);

    }

#if DBG
    cqd_context->dbg_lockout = save;
    DBG_ADD_ENTRY(QIC117SHOWMCMDS, (CqdContextPtr)cqd_context, DBG_SEND_BYTE);
    DBG_ADD_ENTRY(QIC117SHOWMCMDS, (CqdContextPtr)cqd_context, (UCHAR)command);
#endif

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x1103B

NTSTATUS 
cqd_ReceiveByte(
    IN CqdContextPtr cqd_context,
    IN USHORT receive_length,
    OUT PUSHORT receive_data
    )
/*****************************************************************************
*
* FUNCTION: cqd_ReceiveByte
*
* PURPOSE: Read a byte/word of response data from the FDC.  Response data
*          can be drive error/status information or drive configuration
*          information.
*
*          Wait for Track 0 from the tape drive to go active.  This
*          indicates that the drive is ready to start sending data.
*
*          Alternate sending Report Next Bit commands to the tape drive
*          and sampling Track 0 (response data) from the tape drive
*          until the proper number of response data bits have been read.
*
*          Read one final data bit from the tape drive which is the
*          confirmation bit.  This bit must be a 1 to confirm the
*          transmission.
*
*****************************************************************************/
{

    NTSTATUS status;    /* NTSTATUS or error condition.*/
    UCHAR i = 0;
    UCHAR stat3;
    USHORT fdc_data= 0;
#if DBG
    BOOLEAN save;
#endif

#if DBG
   /* Lockout commands used to receive the status */
    save = cqd_context->dbg_lockout;
    cqd_context->dbg_lockout = TRUE;
#endif

    if ((status = cqd_WaitActive(cqd_context)) != STATUS_SUCCESS) {
#if DBG
        cqd_context->dbg_lockout = save;
#endif
        return status;
    }

    do {

        if((status = cqd_SendByte( cqd_context,
                                   FW_CMD_RPT_NEXT_BIT)) != STATUS_SUCCESS) {

#if DBG
            cqd_context->dbg_lockout = save;
#endif
            return status;

        }

        kdi_Sleep( cqd_context->kdi_context,
                   INTERVAL_WAIT_ACTIVE );


        if ((status = cqd_GetStatus(cqd_context, &stat3)) != STATUS_SUCCESS) {
#if DBG
            cqd_context->dbg_lockout = save;
#endif
            return status;
        }

        fdc_data >>= 1;
        if (stat3 & ST3_T0) {

            fdc_data |= 0x8000;

        }

        i++;

    } while (i < receive_length);

    /* If the received data is only one byte wide, then shift data to the low */
    /* byte of fdc_data. */

    if (receive_length == READ_BYTE) {

        fdc_data >>= READ_BYTE;

    }

    /* Return the low byte to the caller. */

    ((UCHAR *)receive_data)[LOW_BYTE] = ((UCHAR *)&fdc_data)[LOW_BYTE];

    /* If the FDC data is a word, then return it to the caller. */

    if (receive_length == READ_WORD) {

        ((UCHAR *)receive_data)[HI_BYTE] = ((UCHAR *)&fdc_data)[HI_BYTE];

    }

    if ((status = cqd_SendByte( cqd_context,
                                FW_CMD_RPT_NEXT_BIT)) != STATUS_SUCCESS) {

#if DBG
        cqd_context->dbg_lockout = save;
#endif
        return status;

    }

    kdi_Sleep(cqd_context->kdi_context, INTERVAL_WAIT_ACTIVE );

    if((status = cqd_GetStatus(cqd_context, &stat3)) != STATUS_SUCCESS) {

#if DBG
        cqd_context->dbg_lockout = save;
#endif
        return status;

    }

    if (!(stat3 & (UCHAR)ST3_T0)) {

#if DBG
        cqd_context->dbg_lockout = save;
#endif
        return kdi_Error(ERR_CMD_OVERRUN, FCT_ID, ERR_SEQ_1);

    }

#if DBG
    cqd_context->dbg_lockout = save;
    DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                   (CqdContextPtr)cqd_context,
                   DBG_RECEIVE_BYTE);
    DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                   (CqdContextPtr)cqd_context,
                   fdc_data);
#endif

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x11022

NTSTATUS 
cqd_GetDeviceError(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_GetDeviceError
*
* PURPOSE: Read the tape drive NTSTATUS byte and, if necessary, the
*          tape drive Error information.
*
*          Read the Drive NTSTATUS byte from the tape drive.
*
*          If the drive status indicates that the tape drive has an
*          error to report, read the error information which includes
*          both the error code and the command that was being executed
*          when the error occurred.
*
*****************************************************************************/
{

    NTSTATUS status;    /* NTSTATUS or error condition.*/
    UCHAR drv_stat;
    USHORT drv_err;
    BOOLEAN repeat_report;
    BOOLEAN repeat_drv_flt = FALSE;
    BOOLEAN esd_retry = FALSE;

    cqd_context->firmware_cmd = FW_NO_COMMAND;
    cqd_context->firmware_error = FW_NO_ERROR;

    do {

        repeat_report = FALSE;

        if ((status = cqd_Report( cqd_context,
                                  FW_CMD_REPORT_STATUS,
                                  (USHORT *)&drv_stat,
                                  READ_BYTE,
                                  &esd_retry)) != STATUS_SUCCESS) {

            if ((kdi_GetErrorType(status) == ERR_DRIVE_FAULT) &&
                    !repeat_drv_flt) {

                repeat_report = TRUE;
                repeat_drv_flt = TRUE;

            }
        }

        if (status == STATUS_SUCCESS) {

            cqd_context->drv_stat = drv_stat;
            kdi_CheckedDump( QIC117DRVSTAT,
                             "QIC117: Drv status = %02x\n",
                             drv_stat);

            if ((drv_stat & STATUS_READY) == 0) {

                status = kdi_Error(ERR_DRV_NOT_READY, FCT_ID, ERR_SEQ_1);

            } else {

                if ((drv_stat & STATUS_CART_PRESENT) != 0) {

                    if ( ((drv_stat & STATUS_NEW_CART) != 0) ||
                         ((cqd_context->device_descriptor.vendor ==
                            VENDOR_IOMEGA) &&
                         cqd_context->operation_status.no_tape) ) {

                      cqd_context->persistent_new_cart = TRUE;

                    }

                    if ((drv_stat & STATUS_BOT) != 0) {

                        cqd_context->rd_wr_op.bot = TRUE;

                    } else {

                        cqd_context->rd_wr_op.bot = FALSE;

                    }

                    if ((drv_stat & STATUS_EOT) != 0) {

                        cqd_context->rd_wr_op.eot = TRUE;

                    } else {

                        cqd_context->rd_wr_op.eot = FALSE;

                    }

                    if ((drv_stat & STATUS_CART_REFERENCED) != 0) {

                        cqd_context->operation_status.cart_referenced = TRUE;

                    } else {

                        cqd_context->operation_status.cart_referenced = FALSE;

                        if (!repeat_drv_flt &&
                            ((drv_stat & STATUS_ERROR) == 0)) {

                            repeat_report = TRUE;
                            repeat_drv_flt = TRUE;

                        }

                    }

                    if ((drv_stat & STATUS_WRITE_PROTECTED) != 0) {

                        cqd_context->tape_cfg.write_protected = TRUE;

                    } else {

                        cqd_context->tape_cfg.write_protected = FALSE;

                    }

                    cqd_context->operation_status.no_tape = FALSE;

                } else {

                    cqd_context->operation_status.no_tape = TRUE;
                    cqd_context->persistent_new_cart = FALSE;
                    cqd_context->operation_status.cart_referenced = FALSE;
                    cqd_context->tape_cfg.write_protected = FALSE;
                    cqd_context->rd_wr_op.bot = FALSE;
                    cqd_context->rd_wr_op.eot = FALSE;

                }


                if ((drv_stat & (STATUS_NEW_CART | STATUS_ERROR)) != 0) {

                    if ((status = cqd_Report(cqd_context,
                                            FW_CMD_REPORT_ERROR,
                                            &drv_err,
                                            READ_WORD,
                                            &esd_retry)) != STATUS_SUCCESS) {

                        if ((kdi_GetErrorType(status) == ERR_DRIVE_FAULT) &&
                            !repeat_drv_flt) {

                            repeat_report = TRUE;
                            repeat_drv_flt = TRUE;

                        }

                    }

                    if (status == STATUS_SUCCESS) {

                        kdi_CheckedDump( QIC117DRVSTAT,
                                        "QIC117: Drv error = %04x\n",
                                        drv_err );

                        if ((drv_stat & STATUS_ERROR) != 0) {

                            cqd_context->firmware_error = (UCHAR)drv_err;
                            cqd_context->firmware_cmd =
                                                (UCHAR)(drv_err >> 8);

                            if (cqd_context->firmware_error ==
                                FW_CMD_WHILE_NEW_CART) {

                                cqd_context->firmware_cmd = FW_NO_COMMAND;
                                cqd_context->firmware_error = FW_NO_ERROR;
                                cqd_context->persistent_new_cart = TRUE;

                            }

                        } else {

                            cqd_context->firmware_cmd = FW_NO_COMMAND;
                            cqd_context->firmware_error = FW_NO_ERROR;

                        }

                        if (cqd_context->firmware_error != FW_NO_ERROR) {

                            switch (cqd_context->firmware_error) {

                            case FW_ILLEGAL_CMD:

                                if (esd_retry) {

                                    esd_retry = FALSE;
                                    repeat_report = TRUE;

                                }

                                break;

                            case FW_NO_DRIVE:

                                cqd_ResetFDC(cqd_context);
                                cqd_context->selected = FALSE;
                                status = cqd_CmdSelectDevice(cqd_context);
                                if (!repeat_drv_flt && (status == STATUS_SUCCESS)) {

                                    repeat_report = TRUE;
                                    repeat_drv_flt = TRUE;

                                } else {

                                    status = kdi_Error( ERR_NO_DRIVE,
                                                        FCT_ID,
                                                        ERR_SEQ_1);

                                }

                                break;

                            case FW_CART_NOT_IN:

                                break;

                            case FW_DRIVE_NOT_READY:

                                status = kdi_Error( ERR_DRV_NOT_READY,
                                                    FCT_ID,
                                                    ERR_SEQ_2);

                                break;

                            default:

                                status = kdi_Error(
                                            (USHORT)(ERR_CQD +
                                                cqd_context->firmware_error),
                                            (ULONG)cqd_context->firmware_cmd,
                                            ERR_SEQ_1);

                            }
                        }
                    }
                }
            }
        }

    } while (repeat_report);

    if (status == STATUS_SUCCESS) {

        cqd_context->operation_status.new_tape =
            cqd_context->persistent_new_cart;

        if (cqd_context->cmd_selected) {

            if (cqd_context->operation_status.no_tape) {

                status = kdi_Error(ERR_NO_TAPE, FCT_ID, ERR_SEQ_1);

            }

            if (cqd_context->operation_status.new_tape) {

                status = kdi_Error(ERR_NEW_TAPE, FCT_ID, ERR_SEQ_1);

            }
        }
    }

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x11049

NTSTATUS 
cqd_WaitActive(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_WaitActive
*
* PURPOSE: Wait up to 5ms for tape drive's TRK0 line to go active.
*          5 ms the specified delay for this parameter.
*
*****************************************************************************/
{

    NTSTATUS status;    /* Status or error condition.*/
    UCHAR stat3;

    kdi_Sleep(cqd_context->kdi_context, INTERVAL_WAIT_ACTIVE );

    if ((status = cqd_GetStatus(cqd_context, &stat3)) != STATUS_SUCCESS) {

        return status;

    }

    if (!(stat3 & ST3_T0)) {

        status = kdi_Error(ERR_DRIVE_FAULT, FCT_ID, ERR_SEQ_1);

    }

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x11028

NTSTATUS 
cqd_GetStatus(
    IN CqdContextPtr cqd_context,
    OUT UCHAR *status_register_3
    )
/*****************************************************************************
*
* FUNCTION: cqd_GetStatus
*
* PURPOSE: Get status byte from the floppy controller chip.
*          Send the Sense Drive NTSTATUS command to the floppy controller.
*          Read the response from the floppy controller which should be
*          status register 3.
*
*****************************************************************************/
{
    NTSTATUS status;    /* NTSTATUS or error condition.*/
    FDC_CMD_SENSE_DRIVE_STATUS send_st;

    send_st.command = COMMND_SENSE_DRIVE_STATUS;
    send_st.drive = (UCHAR)cqd_context->device_cfg.drive_select;

    status = cqd_IssueFDCCommand( cqd_context,
                                  (UCHAR *)&send_st,
                                  (UCHAR *)status_register_3,
                                  NULL,
                                  0,
                                  0,
                                  0);

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x1104A

NTSTATUS 
cqd_WaitCommandComplete(
    IN CqdContextPtr cqd_context,
    IN ULONG wait_time,
    IN BOOLEAN non_interruptible
    )
/*****************************************************************************
*
* FUNCTION: cqd_WaitCommandComplete
*
* PURPOSE: Wait a specified amount of time for the tape drive to become
*          ready after executing a command.
*
*          Read the Drive NTSTATUS byte from the tape drive.
*
*          If the drive is not ready then wait 1/2 second and try again
*          until the specified time has elapsed.
*
*****************************************************************************/
{

    NTSTATUS status;    /* NTSTATUS or error condition.*/
    ULONG wait_start = 0l;
    ULONG wait_current = 0l;

    wait_start = kdi_GetSystemTime();

#if DBG
   /* Lockout commands used to receive the status */
    ++cqd_context->dbg_lockout;
#endif

    do {

        kdi_Sleep(cqd_context->kdi_context, kdi_wt100ms );

        status = cqd_GetDeviceError(cqd_context);

        if (kdi_GetErrorType(status) != ERR_DRV_NOT_READY) {

#if DBG
            --cqd_context->dbg_lockout;
            DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                           (CqdContextPtr)cqd_context,
                           DBG_WAITCC);
            DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                           (CqdContextPtr)cqd_context,
                           cqd_context->drv_stat);
            DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                           (CqdContextPtr)cqd_context,
                           cqd_context->firmware_error);
            DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                           (CqdContextPtr)cqd_context,
                           status);
#endif
            return status;

        }

        if (!non_interruptible &&
            (kdi_ReportAbortStatus(cqd_context->kdi_context) !=
            NO_ABORT_PENDING)) {

#if DBG
            --cqd_context->dbg_lockout;
#endif
            return kdi_Error(ERR_ABORT, FCT_ID, ERR_SEQ_1);

        }

        wait_current = kdi_GetSystemTime();

    } while (wait_time > (wait_current - wait_start));

    if (kdi_ReportAbortStatus(cqd_context->kdi_context) != NO_ABORT_PENDING) {

        status = kdi_Error(ERR_ABORT, FCT_ID, ERR_SEQ_1);

    } else {

       status = kdi_Error(ERR_KDI_TO_EXPIRED, FCT_ID, ERR_SEQ_1);

    }

#if DBG
    --cqd_context->dbg_lockout;

    DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                   (CqdContextPtr)cqd_context,
                   DBG_WAITCC);
    DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                   (CqdContextPtr)cqd_context,
                   cqd_context->drv_stat);
    DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                   (CqdContextPtr)cqd_context,
                   cqd_context->firmware_error);
    DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                   (CqdContextPtr)cqd_context,
                   status);
#endif

   return status;
}

#undef  FCT_ID
#define FCT_ID 0x1103C

NTSTATUS 
cqd_Report(
    IN     CqdContextPtr cqd_context,
    IN     UCHAR command,
    IN     PUSHORT report_data,
    IN     USHORT report_size,
    IN OUT PBOOLEAN esd_retry
    )
/*****************************************************************************
*
* FUNCTION: cqd_Report
*
* PURPOSE: Send a report command to the tape drive and get the response
*          data.  If a communication failure occurs, then we assume that
*          it is a result of an ESD hit and retry the communication.
*
*****************************************************************************/
{
    NTSTATUS status;    /* NTSTATUS or error condition.*/
    USHORT i = 0;

    do {

        if (cqd_context->controller_data.end_format_mode) {

            cqd_context->controller_data.end_format_mode = FALSE;
            status = STATUS_SUCCESS;

        } else {

            status = cqd_SendByte(cqd_context, command);

        }

        if (status == STATUS_SUCCESS) {

            status = cqd_ReceiveByte(cqd_context, report_size, report_data);

            if (kdi_GetErrorType(status) == ERR_CMD_OVERRUN) {

                if (esd_retry != NULL) {

                    *esd_retry = TRUE;
                    cqd_ResetFDC(cqd_context);
                    status = cqd_CmdSelectDevice(cqd_context);

                }
            }
        }

    } while (++i < REPORT_RPT && status != STATUS_SUCCESS);

    return status;

}

#undef  FCT_ID
#define FCT_ID 0x11004

NTSTATUS 
cqd_ClearTapeError(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_ClearTapeError
*
* PURPOSE: To correct errors in the Jumbo B drive and firmware version 63.
*
*            This piece of code added due to the face that the Jumbo B drives
*             with firmware 63 have a bug where you put a tape in very slowly,
*            they sense that they have a tape and engage the motor before the
*            tape is actually in. It may also cause the drive to think that
*            the tape is write protected when it actually is not. Sending it
*            the New tape command causes it to go through the tape loading
*            sequence and fixes these 2 bugs.
*
*****************************************************************************/
{

    NTSTATUS status;    /* NTSTATUS or error condition.*/

   /* Send the NewTape command, and then clear the error byte. */

    if ((status = cqd_SendByte(cqd_context, FW_CMD_NEW_TAPE)) == STATUS_SUCCESS) {

        status = cqd_WaitCommandComplete( cqd_context,
                                          INTERVAL_LOAD_POINT,
                                          TRUE);

        /* This command is specific to CMS drives.  Since we don't
         * know whose drive this is when the function is called,
         * the invalid command error is cleared.
         */

        if ((kdi_GetErrorType(status) == ERR_FW_ILLEGAL_CMD) ||
            (kdi_GetErrorType(status) == ERR_FW_UNDEFINED_COMMAND)) {

            status = STATUS_SUCCESS;
        }
    }

    return status;
}
#undef FCT_ID
#define FCT_ID 0x1103d

VOID 
cqd_ResetFDC(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_ResetFDC
*
* PURPOSE: To reset the floppy controller chip.
*
*****************************************************************************/
{

    NTSTATUS status=STATUS_SUCCESS;    /* NTSTATUS or error condition.*/
    KdiContextPtr kdi_context;

    kdi_context = cqd_context->kdi_context;

    status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                              IOCTL_DISK_INTERNAL_RESET_FDC,
                              NULL );

    if ( NT_SUCCESS(status) ) {
        cqd_ConfigureFDC(cqd_context);
        cqd_context->controller_data.fdc_pcn = 0;
        cqd_context->controller_data.perpendicular_mode = FALSE;
    }

    return;
}

#undef  FCT_ID
#define FCT_ID 0x11006

NTSTATUS 
cqd_ConfigureFDC(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_ConfigureFDC
*
* PURPOSE: To configure the floppy controller chip according
*          to the current FDC parameters.
*
*****************************************************************************/
{

    NTSTATUS status;                    /* NTSTATUS or error condition.*/
    FDC_CMD_SPECIFY specify;
    FDC_CMD_CONFIGURE config;
    UCHAR precomp_mask = 0;        /* Mask write precomp in DSR register */
    FDC_CMD_DRIVE_SPECIFICATION drive_s;

    status = cqd_DCROut(cqd_context, cqd_context->xfer_rate.fdc);

    if ( status == STATUS_SUCCESS ) {
        if ( cqd_context->device_descriptor.fdc_type == FDC_TYPE_82078_64 )  {    
            drive_s.command = COMMND_DRIVE_SPECIFICATION;
            drive_s.drive_spec = (UCHAR)(DRIVE_SPEC |
                                 ((cqd_context->device_cfg.select_byte &
                                 DRIVE_ID_MASK) << DRIVE_SELECT_OFFSET));
            drive_s.done = DONE_MARKER;
            status = cqd_IssueFDCCommand( cqd_context,
                                          (UCHAR *)&drive_s,
                                          NULL,
                                          NULL,
                                          0,
                                          0,
                                          0 );
        }
    }

    if ((status == STATUS_SUCCESS) &&
        (cqd_context->device_descriptor.fdc_type == FDC_TYPE_82077 ||
         cqd_context->device_descriptor.fdc_type == FDC_TYPE_82077AA ||
         cqd_context->device_descriptor.fdc_type == FDC_TYPE_82078_44 ||
         cqd_context->device_descriptor.fdc_type == FDC_TYPE_82078_64 ||
         cqd_context->device_descriptor.fdc_type == FDC_TYPE_NATIONAL)) {

        /*  if this is a 3010 or 3020 CMS drive, turn off write precomp */
        switch (cqd_context->device_descriptor.drive_class) {
        case QIC3010_DRIVE:
        case QIC3010W_DRIVE:
        case QIC3020_DRIVE:
        case QIC3020W_DRIVE:
            precomp_mask = FDC_PRECOMP_OFF;
            break;
        default:
            precomp_mask = FDC_PRECOMP_ON;
        }

        /* Select the fdc data rate corresponding to the current xfer rate
         * and enable or disable write precomp. */
        status = cqd_DSROut( cqd_context,
                            (UCHAR)(cqd_context->xfer_rate.fdc | precomp_mask));

        /* Deselect the tape drive PLL */
        if (status == STATUS_SUCCESS) {
            cqd_TDROut( cqd_context, curu );

            switch (cqd_context->xfer_rate.fdc) {
            case FDC_250Kbps:
            case FDC_500Kbps:
                /* Enable the tape drive PLL */
                status = cqd_TDROut( cqd_context, curb );
                break;
            }

            if (status == STATUS_SUCCESS) {
                config.cmd = COMMND_CONFIGURE;
                config.czero = FDC_CONFIG_NULL_BYTE;
                config.config = (UCHAR)(FDC_FIFO & FIFO_MASK);
                config.pretrack = FDC_CONFIG_PRETRACK;

                /* issue the configure command to the FDC */
                status = cqd_IssueFDCCommand( cqd_context,
                                            (UCHAR *)&config,
                                            NULL,
                                            NULL,
                                            0,
                                            0,
                                            0 );
            }
        }
        if (status != STATUS_SUCCESS) {

            return status;

        }
    }

    /* Specify the rates for the FDC's three internal timers. */
    /* This includes the head unload time (HUT), the head load */
    /* time (HLT), and the step rate time (SRT) */
    specify.command = COMMND_SPECIFY;
    specify.SRT_HUT = cqd_context->xfer_rate.srt;
    specify.HLT_ND = FDC_HLT;
    status = cqd_IssueFDCCommand( cqd_context,
                                  (UCHAR *)&specify,
                                  NULL,
                                  NULL,
                                  0,
                                  0,
                                  0 );

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x11008

NTSTATUS 
cqd_DCROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR speed
    )
/*****************************************************************************
*
* FUNCTION: cqd_DCROut
*
* PURPOSE: Set the data rate bits of the configuration control register.
*
******************************************************************************/
{
    NTSTATUS status;
    KdiContextPtr kdi_context;

    kdi_context = cqd_context->kdi_context;

    speed = (UCHAR)(speed & FDC_DCR_MASK);

    status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                              IOCTL_DISK_INTERNAL_SET_FDC_DATA_RATE,
                              &speed );

    return status;

}

NTSTATUS 
cqd_DSROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR precomp
    )
{

    NTSTATUS status;
    KdiContextPtr kdi_context;

    kdi_context = cqd_context->kdi_context;

    status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                              IOCTL_DISK_INTERNAL_SET_FDC_PRECOMP,
                              &precomp );

    return status;

}

NTSTATUS 
cqd_TDROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR tape_mode
    )
{
    NTSTATUS status;
    KdiContextPtr kdi_context;

    kdi_context = cqd_context->kdi_context;

    status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                              IOCTL_DISK_INTERNAL_SET_FDC_TAPE_MODE,
                              &tape_mode );

    return status;

}

NTSTATUS 
cqd_IssueFDCCommand(
    IN CqdContextPtr cqd_context,
    IN PUCHAR     CommandFifo,
    IN PUCHAR     ResultFifo,
    IN PVOID         IoHandle,
    IN ULONG         IoOffset,
    IN ULONG         TransferBytes,
    IN ULONG         TimeOut
    )
{
    NTSTATUS status;
    ISSUE_FDC_COMMAND_PARMS issueCommandParms;
    KdiContextPtr kdi_context;

    kdi_context = cqd_context->kdi_context;

    //
    //  Set the command parameters
    //
    issueCommandParms.FifoInBuffer = CommandFifo;
    issueCommandParms.FifoOutBuffer = ResultFifo;
    issueCommandParms.IoHandle = IoHandle;
    issueCommandParms.IoOffset = IoOffset;
    issueCommandParms.TransferBytes = TransferBytes;
    //
    // Timeouts are requested in terms of milliseconds but fdc.sys needs them
    // in terms of seconds, so adjust the value.
    //
    issueCommandParms.TimeOut = TimeOut / 1000;

    status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                              IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND,
                              &issueCommandParms );

    return status;

}

#undef  FCT_ID
#define FCT_ID 0x15883

NTSTATUS 
kdi_Error(
    IN USHORT  group_and_type,
    IN ULONG grp_fct_id,
    IN UCHAR   sequence
    )
/*****************************************************************************
*
* FUNCTION: kdi_Error
*
* PURPOSE:
*
*****************************************************************************/
{
    return ERROR_ENCODE( group_and_type, grp_fct_id, sequence );
}

#undef  FCT_ID
#define FCT_ID 0x15886

USHORT 
kdi_GetErrorType(
    IN NTSTATUS status
    )
/*****************************************************************************
*
* FUNCTION: kdi_GetErrorType
*
* PURPOSE: Return the GRP+ERROR to the calling function for easy comparisons 
*          and switch statement access.
*****************************************************************************/
{
    return (USHORT)(status >> 16);
}

#undef  FCT_ID
#define FCT_ID 0x15a0f

BOOLEAN 
kdi_ReportAbortStatus(
    IN PVOID   kdi_context
    )
/*****************************************************************************
*
* FUNCTION: kdi_ReportAbortStatus
*
* PURPOSE:
*
*****************************************************************************/
{

    if (((KdiContextPtr)kdi_context)->abort_requested) {

        return ABORT_LEVEL_1;

    } else {

        return NO_ABORT_PENDING;

    }
}

#undef  FCT_ID
#define FCT_ID 0x15A10

ULONG 
kdi_GetSystemTime(
    )
/*****************************************************************************
*
* FUNCTION: kdi_GetSystemTime
*
* PURPOSE:  Gets the system time in milliseconds
*
*****************************************************************************/
{

    ULONG remainder;
    ULONG time_increment;
    ULARGE_INTEGER nanosec_interval;
    LARGE_INTEGER tick_count;
    LARGE_INTEGER temp;

    time_increment = KeQueryTimeIncrement();
    KeQueryTickCount(&tick_count);
    temp = RtlExtendedIntegerMultiply(
                tick_count,
                time_increment);

    nanosec_interval = *(ULARGE_INTEGER *)&temp;

    return RtlEnlargedUnsignedDivide(
                nanosec_interval,
                NANOSEC_PER_MILLISEC,
                &remainder);
}

#undef  FCT_ID
#define FCT_ID 0x15A17

UCHAR 
kdi_GetInterfaceType(
    IN KdiContextPtr kdi_context
    )
/*****************************************************************************
*
* FUNCTION: kdi_GetInterfaceType
*
* PURPOSE:
*
*****************************************************************************/
{
    return kdi_context->interface_type;
}

#undef  FCT_ID
#define FCT_ID 0x15A20

#if DBG

unsigned long kdi_debug_level = 0;

#endif

#if DBG

VOID 
kdi_CheckedDump(
    IN ULONG    debug_level,
    IN PCHAR    format_str,
    IN ULONG_PTR argument
    )
/*****************************************************************************
*
* FUNCTION: kdi_CheckedDump
*
* PURPOSE:
*
*****************************************************************************/
{
   if ((kdi_debug_level & debug_level) != 0) {

      DbgPrint(format_str, argument);
   }

    return;
}

#endif

/*****************************************************************************
*
* FUNCTION: kdi_Sleep
*
* PURPOSE:
*
*****************************************************************************/
#undef  FCT_ID
#define FCT_ID 0x15A0E

NTSTATUS 
kdi_Sleep(
    IN KdiContextPtr kdi_context,
    IN ULONG wait_time
    )
{
    LARGE_INTEGER timeout;

    timeout.QuadPart = -(10 * 1000 * (LONGLONG)wait_time);

    (VOID) KeDelayExecutionThread( KernelMode,
                                   FALSE,
                                   &timeout );

    return kdi_Error( ERR_KDI_TO_EXPIRED, FCT_ID, ERR_SEQ_2 );
}

NTSTATUS 
kdi_FdcDeviceIo(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    )
/*****************************************************************************
*
* FUNCTION: kdi_FdcDeviceIo
*
* PURPOSE:
*
*****************************************************************************/
{
    NTSTATUS ntStatus;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT doneEvent;
    IO_STATUS_BLOCK ioStatus;

    KeInitializeEvent( &doneEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Create an IRP for enabler
    //
    irp = IoBuildDeviceIoControlRequest( Ioctl,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,
                                         &doneEvent,
                                         &ioStatus );

    if (irp == NULL) {

        //
        // If an Irp can't be allocated, then this call will
        // simply return. This will leave the queue frozen for
        // this device, which means it can no longer be accessed.
        //
        return ERROR_ENCODE(ERR_OUT_OF_BUFFERS, FCT_ID, 1);
    }

    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->Parameters.DeviceIoControl.Type3InputBuffer = Data;

    //
    // Call the driver and request the operation
    //
    ntStatus = IoCallDriver(DeviceObject, irp);

    //
    // Now wait for operation to complete (should already be done,  but
    // maybe not)
    //
    if ( ntStatus == STATUS_PENDING ) {

        KeWaitForSingleObject( &doneEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        ntStatus = ioStatus.Status;
    }

    if ( ntStatus == STATUS_DEVICE_NOT_READY ) {

        ntStatus = ERROR_ENCODE(ERR_KDI_TO_EXPIRED, FCT_ID, 1);
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\acpiutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       acpiutil.h
//
//--------------------------------------------------------------------------

#if !defined (___acpiutil_h___)
#define ___acpiutil_h___

//
// ACPI Control Method Stuff
//
#define ACPI_METHOD_GET_TASK_FILE   ((ULONG) 'FTG_') // _GTF
#define ACPI_METHOD_GET_TIMING      ((ULONG) 'MTG_') // _GTM
#define ACPI_METHOD_SET_TIMING      ((ULONG) 'MTS_') // _STM

#define ACPI_XFER_MODE_NOT_SUPPORT     (0xffffffff)

#pragma pack(1)
typedef struct _ACPI_GTF_IDE_REGISTERS {
    UCHAR    FeaturesReg;
    UCHAR    SectorCountReg;
    UCHAR    SectorNumberReg;
    UCHAR    CylLowReg;
    UCHAR    CylHighReg;
    UCHAR    DriveHeadReg;
    UCHAR    CommandReg;
} ACPI_GTF_IDE_REGISTERS, *PACPI_GTF_IDE_REGISTERS;
#pragma pack()

typedef struct _ACPI_IDE_TIMING {

    struct _TIMING {

        ULONG Pio;
        ULONG Dma;

    } Speed[MAX_IDE_DEVICE];

    union {
        struct {
            ULONG UltraDma0:1;
            ULONG IoChannelReady0:1;
            ULONG UltraDma1:1;
            ULONG IoChannelReady1:1;
            ULONG IndependentTiming:1;
            ULONG Reserved:27;
        } b;
        ULONG AsULong;
    } Flags;
} ACPI_IDE_TIMING, *PACPI_IDE_TIMING;
                          
                          
NTSTATUS
DeviceQueryFirmwareBootSettings (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PDEVICE_SETTINGS *IdeBiosSettings
    );
                         
NTSTATUS
DeviceQueryACPISettings (
    IN PDEVICE_EXTENSION_HEADER DoExtension,
    IN ULONG ControlMethodName,
    OUT PACPI_EVAL_OUTPUT_BUFFER *QueryResult
    );

NTSTATUS
DeviceQueryACPISettingsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
DeviceQueryChannelTimingSettings (
    IN PFDO_EXTENSION FdoExtension,
    IN OUT PACPI_IDE_TIMING TimimgSettings
    );
                          
typedef struct _SYNC_SET_ACPI_TIMING_CONTEXT {

    KEVENT Event;
    NTSTATUS IrpStatus;

} SYNC_SET_ACPI_TIMING_CONTEXT, *PSYNC_SET_ACPI_TIMING_CONTEXT;

NTSTATUS
ChannelSyncSetACPITimingSettings (
    IN PFDO_EXTENSION FdoExtension,
    IN PACPI_IDE_TIMING TimimgSettings,
    IN PIDENTIFY_DATA AtaIdentifyData[MAX_IDE_DEVICE]
    );

NTSTATUS
ChannelSyncSetACPITimingSettingsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PVOID Context
    );

typedef
NTSTATUS
(*PSET_ACPI_TIMING_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PVOID Context
    );

typedef struct _ASYNC_SET_ACPI_TIMING_CONTEXT {

    PFDO_EXTENSION FdoExtension;

    PSET_ACPI_TIMING_COMPLETION_ROUTINE CallerCompletionRoutine;
    PVOID CallerContext;

} ASYNC_SET_ACPI_TIMING_CONTEXT, *PASYNC_SET_ACPI_TIMING_CONTEXT;

NTSTATUS
ChannelSetACPITimingSettings (
    IN PFDO_EXTENSION FdoExtension,
    IN PACPI_IDE_TIMING TimimgSettings,
    IN PIDENTIFY_DATA AtaIdentifyData[MAX_IDE_DEVICE],
    IN PSET_ACPI_TIMING_COMPLETION_ROUTINE CallerCompletionRoutine,
    IN PVOID CallerContext
    );

NTSTATUS
ChannelSetACPITimingSettingsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#endif // ___acpiutil_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\atapi.h ===
#if !defined (___atapi_h___)
#define ___atapi_h___

/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    atapi.h

Abstract:

    This module contains the structures and definitions for the ATAPI
    IDE miniport driver.

Author:

    Mike Glass


Revision History:

--*/

#include "scsi.h"
#include "stdio.h"
#include "string.h"

ULONG
AtapiParseArgumentString(
    IN PCHAR String,
    IN PCHAR KeyWord
    );

//
// IDE register definition
//
typedef struct _IDE_REGISTERS_3 {
    ULONG Data;
    UCHAR Others[4];
} IDE_REGISTERS_3, *PIDE_REGISTERS_3;

typedef struct _ATA_COMMAND_BLOCK_READ_REGISTERS {

    union {

        struct {
            PUSHORT Data16;
        } w;

        struct {
            PUCHAR Data8;
            PUCHAR Error;
            PUCHAR SectorCount;
            PUCHAR SectorNumber;
            PUCHAR CylinderLow;
            PUCHAR CylinderHigh;
            PUCHAR DriveSelect;
            PUCHAR Status;
        } b;

    } size;

} ATA_COMMAND_BLOCK_READ_REGISTERS, *PATA_COMMAND_BLOCK_READ_REGISTERS;

typedef struct _ATA_COMMAND_BLOCK_WRITE_REGISTERS {

    union {

        struct {
            PUSHORT Data16;
        } w;

        struct {
            PUCHAR Data8;
            PUCHAR Feature;
            PUCHAR SectorCount;
            PUCHAR SectorNumber;
            PUCHAR CylinderLow;
            PUCHAR CylinderHigh;
            PUCHAR DriveSelect;
            PUCHAR Command;
        } b;

    } size;

} ATA_COMMAND_BLOCK_WRITE_REGISTERS, *PATA_COMMAND_BLOCK_WRITE_REGISTERS;

typedef struct _ATAPI_COMMAND_BLOCK_READ_REGISTERS {

    union {

        struct {
            PUSHORT Data16;
        } w;

        struct {
            PUCHAR Data8;
            PUCHAR Error;
            PUCHAR InterruptReason;
            PUCHAR Reserved;
            PUCHAR ByteCountLow;
            PUCHAR ByteCountHigh;
            PUCHAR DriveSelect;
            PUCHAR Status;
        } b;

    } size;

} ATAPI_COMMAND_BLOCK_READ_REGISTERS, *PATAPI_COMMAND_BLOCK_READ_REGISTERS;

typedef struct _ATAPI_COMMAND_BLOCK_WRITE_REGISTERS {

    union {

        struct {
            PUSHORT Data16;
        } w;

        struct {
            PUCHAR Data8;
            PUCHAR Feature;
            PUCHAR Resereved0;
            PUCHAR Resereved1;
            PUCHAR ByteCountLow;
            PUCHAR ByteCountHigh;
            PUCHAR DriveSelect;
            PUCHAR Command;
        } b;
    } size;

} ATAPI_COMMAND_BLOCK_WRITE_REGISTERS, *PATAPI_COMMAND_BLOCK_WRITE_REGISTERS;

typedef struct _IDE_COMMAND_BLOCK_WRITE_REGISTERS {

    PUCHAR  RegistersBaseAddress;

    union {

        union {

            ATA_COMMAND_BLOCK_READ_REGISTERS r;
            ATA_COMMAND_BLOCK_WRITE_REGISTERS w;

        } ata;

        union {

            ATAPI_COMMAND_BLOCK_READ_REGISTERS r;
            ATAPI_COMMAND_BLOCK_WRITE_REGISTERS w;

        } atapi;

    } type;

} IDE_COMMAND_BLOCK_WRITE_REGISTERS, *PIDE_COMMAND_BLOCK_WRITE_REGISTERS;

//
// handy ata macros
//

#define ATA_DATA16_REG(baseAddress)             (baseAddress)->type.ata.r.size.w.Data16
#define ATA_ERROR_REG(baseAddress)              (baseAddress)->type.ata.r.size.b.Error
#define ATA_SECTOR_COUNT_REG(baseAddress)       (baseAddress)->type.ata.r.size.b.SectorCount
#define ATA_SECTOR_NUMBER_REG(baseAddress)      (baseAddress)->type.ata.r.size.b.SectorNumber
#define ATA_CYLINDER_LOW_REG(baseAddress)       (baseAddress)->type.ata.r.size.b.CylinderLow
#define ATA_CYLINDER_HIGH_REG(baseAddress)      (baseAddress)->type.ata.r.size.b.CylinderHigh
#define ATA_DRIVE_SELECT_REG(baseAddress)       (baseAddress)->type.ata.r.size.b.DriveSelect
#define ATA_STATUS_REG(baseAddress)             (baseAddress)->type.ata.r.size.b.Status

#define ATA_FEATURE_REG(baseAddress)            (baseAddress)->type.ata.w.size.b.Feature
#define ATA_COMMAND_REG(baseAddress)            (baseAddress)->type.ata.w.size.b.Command

//
// handy atapi macros
//
#define ATAPI_DATA16_REG(baseAddress)           (baseAddress)->type.atapi.r.size.w.Data16
#define ATAPI_ERROR_REG(baseAddress)            (baseAddress)->type.atapi.r.size.b.Error
#define ATAPI_INTERRUPT_REASON_REG(baseAddress) (baseAddress)->type.atapi.r.size.b.InterruptReason
#define ATAPI_BYTECOUNT_LOW_REG(baseAddress)    (baseAddress)->type.atapi.r.size.b.ByteCountLow
#define ATAPI_BYTECOUNT_HIGH_REG(baseAddress)   (baseAddress)->type.atapi.r.size.b.ByteCountHigh
#define ATAPI_DRIVE_SELECT_REG(baseAddress)     (baseAddress)->type.atapi.r.size.b.DriveSelect
#define ATAPI_STATUS_REG(baseAddress)           (baseAddress)->type.atapi.r.size.b.Status

#define ATAPI_FEATURE_REG(baseAddress)          (baseAddress)->type.atapi.w.size.b.Feature
#define ATAPI_COMMAND_REG(baseAddress)          (baseAddress)->type.atapi.w.size.b.Command


//
// Device Extension Device Flags
//

#define DFLAGS_DEVICE_PRESENT        (1 << 0)    // Indicates that some device is present.
#define DFLAGS_ATAPI_DEVICE          (1 << 1)    // Indicates whether Atapi commands can be used.
#define DFLAGS_TAPE_DEVICE           (1 << 2)    // Indicates whether this is a tape device.
#define DFLAGS_INT_DRQ               (1 << 3)    // Indicates whether device interrupts as DRQ is set after
                                                 // receiving Atapi Packet Command

#define DFLAGS_REMOVABLE_DRIVE       (1 << 4)    // Indicates that the drive has the 'removable' bit set in
                                                 // identify data (offset 128)
#define DFLAGS_MEDIA_STATUS_ENABLED  (1 << 5)    // Media status notification enabled

#define DFLAGS_USE_DMA               (1 << 9)    // Indicates whether device can use DMA
#define DFLAGS_LBA                   (1 << 10)   // support LBA addressing
#define DFLAGS_MULTI_LUN_INITED      (1 << 11)   // Indicates that the init path for multi-lun has already been done.

#define DFLAGS_MSN_SUPPORT           (1 << 12)   // Device support media status notification
#define DFLAGS_AUTO_EJECT_ZIP        (1 << 13)   // bootup default enables auto eject
#define DFLAGS_WD_MODE               (1 << 14)   // Indicates that unit is WD-Mode(not SFF-Mode).
#define DFLAGS_LS120_FORMAT          (1 << 15)   // Indicates that unit uses ATAPI_LS120_FORMAT_UNIT to format

#define DFLAGS_USE_UDMA              (1 << 16)    // Indicates whether device can use UDMA
#define DFLAGS_IDENTIFY_VALID        (1 << 17)    // Indicates whether the Identify data is valid or not
#define DFLAGS_IDENTIFY_INVALID      (1 << 18)    // Indicates whether the Identify data is valid or not
#define DFLAGS_RDP_SET               (1 << 19)    // If the srb is for RDP

#define DFLAGS_SONY_MEMORYSTICK      (1 << 20)    // If the device is a Sony Memorystick
#define DFLAGS_48BIT_LBA      		 (1 << 21)    // If the device supports 48-bit LBA
#define DFLAGS_DEVICE_ERASED         (1 << 22)    // Indicates that some device is temporarily blocked for access.

//
// Used to disable 'advanced' features.
//

#define MAX_ERRORS                     4

//
// ATAPI command definitions
//

#define ATAPI_MODE_SENSE   0x5A
#define ATAPI_MODE_SELECT  0x55
#define ATAPI_LS120_FORMAT_UNIT  0x24

//
// ATAPI mode page page code
//
#define ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE_PAGECODE     (0x00)
#define ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES_PAGECODE  (0x1b)


//
// ATAPI Command Descriptor Block
//
typedef struct _MODE_PARAMETER_HEADER_10 {
    UCHAR ModeDataLengthMsb;
    UCHAR ModeDataLengthLsb;
    UCHAR MediumType;
    UCHAR Reserved[5];
}MODE_PARAMETER_HEADER_10, *PMODE_PARAMETER_HEADER_10;


typedef struct _ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES {

    UCHAR PageCode : 6;
    UCHAR Reserved0 : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;

    UCHAR Reserved2:6;
    UCHAR SRFP:1;
    UCHAR SFLP:1;

    UCHAR TotalLun:3;
    UCHAR Reserved3:3;
    UCHAR SML:1;
    UCHAR NCD:1;

    UCHAR Reserved[8];

} ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES, *PATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES;

typedef struct _ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved0 : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;

    UCHAR Reserved2:5;
    UCHAR DVW:1;
    UCHAR SLR:1;
    UCHAR SLM:1;

    UCHAR Reserved3:4;
    UCHAR DDE:1;
    UCHAR Reserved4:3;

} ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE, *PATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE;


//
// IDE command definitions
//

#define IDE_COMMAND_NOP                         0x00
#define IDE_COMMAND_ATAPI_RESET                 0x08
#define IDE_COMMAND_RECALIBRATE                 0x10
#define IDE_COMMAND_READ                        0x20
#define IDE_COMMAND_READ_EXT                    0x24
#define IDE_COMMAND_READ_DMA_EXT                0x25
#define IDE_COMMAND_READ_DMA_QUEUED_EXT         0x26
#define IDE_COMMAND_READ_MULTIPLE_EXT           0x29
#define IDE_COMMAND_WRITE                       0x30
#define IDE_COMMAND_WRITE_EXT                   0x34
#define IDE_COMMAND_WRITE_DMA_EXT               0x35
#define IDE_COMMAND_WRITE_DMA_QUEUED_EXT        0x36
#define IDE_COMMAND_WRITE_MULTIPLE_EXT          0x39
#define IDE_COMMAND_VERIFY                      0x40
#define IDE_COMMAND_VERIFY_EXT                  0x42
#define IDE_COMMAND_SEEK                        0x70
#define IDE_COMMAND_EXECUTE_DEVICE_DIAGNOSTIC   0x90
#define IDE_COMMAND_SET_DRIVE_PARAMETERS        0x91
#define IDE_COMMAND_ATAPI_PACKET                0xA0
#define IDE_COMMAND_ATAPI_IDENTIFY              0xA1
#define IDE_COMMAND_READ_MULTIPLE               0xC4
#define IDE_COMMAND_WRITE_MULTIPLE              0xC5
#define IDE_COMMAND_SET_MULTIPLE                0xC6
#define IDE_COMMAND_READ_DMA                    0xC8
#define IDE_COMMAND_WRITE_DMA                   0xCA
#define IDE_COMMAND_GET_MEDIA_STATUS            0xDA
#define IDE_COMMAND_STANDBY_IMMEDIATE           0xE0
#define IDE_COMMAND_IDLE_IMMEDIATE              0xE1
#define IDE_COMMAND_CHECK_POWER                 0xE5
#define IDE_COMMAND_SLEEP                       0xE6
#define IDE_COMMAND_FLUSH_CACHE                 0xE7
#define IDE_COMMAND_FLUSH_CACHE_EXT             0xEA
#define IDE_COMMAND_IDENTIFY                    0xEC
#define IDE_COMMAND_MEDIA_EJECT                 0xED
#define IDE_COMMAND_SET_FEATURE                 0xEF
#define IDE_COMMAND_DOOR_LOCK                   0xDE
#define IDE_COMMAND_DOOR_UNLOCK                 0xDF
#define IDE_COMMAND_NO_FLUSH                    0xFF // Commmand value to indicate the target device can't handle any flush command

//
// IDE Set Transfer Mode
//
#define IDE_SET_DEFAULT_PIO_MODE(mode)      ((UCHAR) 1)     // disable I/O Ready
#define IDE_SET_ADVANCE_PIO_MODE(mode)      ((UCHAR) ((1 << 3) | (mode)))
#define IDE_SET_SWDMA_MODE(mode)            ((UCHAR) ((1 << 4) | (mode)))
#define IDE_SET_MWDMA_MODE(mode)            ((UCHAR) ((1 << 5) | (mode)))
#define IDE_SET_UDMA_MODE(mode)             ((UCHAR) ((1 << 6) | (mode)))

#define IDE_SET_FEATURE_SET_TRANSFER_MODE   0x3
#define IDE_SET_FEATURE_ENABLE_WRITE_CACHE  0x2
#define IDE_SET_FEATURE_DISABLE_WRITE_CACHE 0x82

//
// Media Status Set Feature
//
#define IDE_SET_FEATURE_ENABLE_MSN          0x95
#define IDE_SET_FEATURE_DISABLE_MSN         0x31
#define IDE_SET_FEATURE_DISABLE_REVERT_TO_POWER_ON 0x66

//
// IDE drive select/head definitions
//

#define IDE_DRIVE_SELECT_1           0xA0
#define IDE_DRIVE_SELECT_2           0x10

//
// IDE error definitions
//

#define IDE_ERROR_BAD_BLOCK          0x80
#define IDE_ERROR_CRC_ERROR          IDE_ERROR_BAD_BLOCK
#define IDE_ERROR_DATA_ERROR         0x40
#define IDE_ERROR_MEDIA_CHANGE       0x20
#define IDE_ERROR_ID_NOT_FOUND       0x10
#define IDE_ERROR_MEDIA_CHANGE_REQ   0x08
#define IDE_ERROR_COMMAND_ABORTED    0x04
#define IDE_ERROR_END_OF_MEDIA       0x02
#define IDE_ERROR_ILLEGAL_LENGTH     0x01

//
// ATAPI register definition
//

typedef struct _ATAPI_REGISTERS_1 {
    PUCHAR RegistersBaseAddress;

    PUSHORT Data;
    PUCHAR Error;
    PUCHAR InterruptReason;
    PUCHAR Unused1;
    PUCHAR ByteCountLow;
    PUCHAR ByteCountHigh;
    PUCHAR DriveSelect;
    PUCHAR Command;
} ATAPI_REGISTERS_1, *PATAPI_REGISTERS_1;

typedef struct _ATAPI_REGISTERS_2 {
    PUCHAR RegistersBaseAddress;

    PUCHAR DeviceControl;
    PUCHAR DriveAddress;
} ATAPI_REGISTERS_2, *PATAPI_REGISTERS_2;


//
// ATAPI interrupt reasons
//

#define ATAPI_IR_COD 0x01
#define ATAPI_IR_IO  0x02

//
// IDENTIFY data
//
/**************** Moved to ide.h *************
#pragma pack (1)
typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumCylinders;                    // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumHeads;                        // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT NumSectorsPerTrack;              // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    UCHAR  SerialNumber[20];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    UCHAR  FirmwareRevision[8];             // 2E  23-26
    UCHAR  ModelNumber[40];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:3;        // 6A  53
    USHORT Reserved3:13;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[11];                   //     69-79
    USHORT MajorRevision;                   //     80
    USHORT MinorRevision;                   //     81
    USHORT Reserved6[6];                    //     82-87
    USHORT UltraDMASupport : 8;             //     88
    USHORT UltraDMAActive  : 8;             //
    USHORT Reserved7[37];                   //     89-125
    USHORT LastLun:3;                       //     126
    USHORT Reserved8:13;
    USHORT MediaStatusNotification:2;       //     127
    USHORT Reserved9:6;
    USHORT DeviceWriteProtect:1;
    USHORT Reserved10:7;
    USHORT Reserved11[128];                  //     128-255
} IDENTIFY_DATA, *PIDENTIFY_DATA;

//
// Identify data without the Reserved4.
//

//typedef struct _IDENTIFY_DATA2 {
//    USHORT GeneralConfiguration;            // 00 00
//    USHORT NumCylinders;                    // 02  1
//    USHORT Reserved1;                       // 04  2
//    USHORT NumHeads;                        // 06  3
//    USHORT UnformattedBytesPerTrack;        // 08  4
//    USHORT UnformattedBytesPerSector;       // 0A  5
//    USHORT NumSectorsPerTrack;              // 0C  6
//    USHORT VendorUnique1[3];                // 0E  7-9
//    UCHAR  SerialNumber[20];                // 14  10-19
//    USHORT BufferType;                      // 28  20
//    USHORT BufferSectorSize;                // 2A  21
//    USHORT NumberOfEccBytes;                // 2C  22
//    UCHAR  FirmwareRevision[8];             // 2E  23-26
//    UCHAR  ModelNumber[40];                 // 36  27-46
//    UCHAR  MaximumBlockTransfer;            // 5E  47
//    UCHAR  VendorUnique2;                   // 5F
//    USHORT DoubleWordIo;                    // 60  48
//    USHORT Capabilities;                    // 62  49
//    USHORT Reserved2;                       // 64  50
//    UCHAR  VendorUnique3;                   // 66  51
//    UCHAR  PioCycleTimingMode;              // 67
//    UCHAR  VendorUnique4;                   // 68  52
//    UCHAR  DmaCycleTimingMode;              // 69
//    USHORT TranslationFieldsValid:3;        // 6A  53
//    USHORT Reserved3:13;
//    USHORT NumberOfCurrentCylinders;        // 6C  54
//    USHORT NumberOfCurrentHeads;            // 6E  55
//    USHORT CurrentSectorsPerTrack;          // 70  56
//    ULONG  CurrentSectorCapacity;           // 72  57-58
//    USHORT CurrentMultiSectorSetting;       //     59
//    ULONG  UserAddressableSectors;          //     60-61
//    USHORT SingleWordDMASupport : 8;        //     62
//    USHORT SingleWordDMAActive : 8;
//    USHORT MultiWordDMASupport : 8;         //     63
//    USHORT MultiWordDMAActive : 8;
//    USHORT AdvancedPIOModes : 8;            //     64
//    USHORT Reserved4 : 8;
//    USHORT MinimumMWXferCycleTime;          //     65
//    USHORT RecommendedMWXferCycleTime;      //     66
//    USHORT MinimumPIOCycleTime;             //     67
//    USHORT MinimumPIOCycleTimeIORDY;        //     68
//    USHORT Reserved5[11];                   //     69-79
//    USHORT MajorRevision;                   //     80
//    USHORT MinorRevision;                   //     81
//    USHORT Reserved6[6];                    //     82-87
//    USHORT UltraDMASupport : 8;             //     88
//    USHORT UltraDMAActive  : 8;             //
//    USHORT Reserved7[37];                   //     89-125
//    USHORT LastLun:3;                       //     126
//    USHORT Reserved8:13;
//    USHORT MediaStatusNotification:2;       //     127
//    USHORT Reserved9:6;
//    USHORT DeviceWriteProtect:1;
//    USHORT Reserved10:7;
//} IDENTIFY_DATA2, *PIDENTIFY_DATA2;
#pragma pack ()

#define IDENTIFY_DATA_SIZE sizeof(IDENTIFY_DATA)
******************************************************/

//
// Identify Data General Configuration Bit Definition
//
#define IDE_IDDATA_DEVICE_TYPE_MASK          ((1 << 15) | (1 << 14))
#define IDE_IDDATA_ATAPI_DEVICE              ((1 << 15 | (0 << 14))

#define IDE_IDDATA_ATAPI_DEVICE_MASK         ((1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8))

#define IDE_IDDATA_REMOVABLE                 (1 << 7)

#define IDE_IDDATA_DRQ_TYPE_MASK             ((1 << 6) | (1 << 5))
#define IDE_IDDATA_INTERRUPT_DRQ             ((1 << 6) | (0 << 5))

//
// Identify Data 48 bit lba support
//
#define IDE_IDDATA_48BIT_LBA_SUPPORT		(1<<10)


//
// IDENTIFY capability bit definitions.
//

#define IDENTIFY_CAPABILITIES_DMA_SUPPORTED             (1 << 8)
#define IDENTIFY_CAPABILITIES_LBA_SUPPORTED             (1 << 9)
#define IDENTIFY_CAPABILITIES_IOREADY_CAN_BE_DISABLED   (1 << 10)
#define IDENTIFY_CAPABILITIES_IOREADY_SUPPORTED         (1 << 11)


//
// Identify MediaStatusNotification
//
#define IDENTIFY_MEDIA_STATUS_NOTIFICATION_SUPPORTED    (0x1)

//
// Select LBA mode when progran IDE device
//
#define IDE_LBA_MODE                                    (1 << 6)

//
// ID DATA
//
/********** Not needed ****************
#define IDD_UDMA_MODE0_ACTIVE           (1 << 0)
#define IDD_UDMA_MODE1_ACTIVE           (1 << 1)
#define IDD_UDMA_MODE2_ACTIVE           (1 << 2)
#define IDD_UDMA_MODE3_ACTIVE           (1 << 3)
#define IDD_UDMA_MODE4_ACTIVE           (1 << 4)
#define IDD_UDMA_MODE5_ACTIVE           (1 << 5)

#define IDD_MWDMA_MODE0_ACTIVE          (1 << 0)
#define IDD_MWDMA_MODE1_ACTIVE          (1 << 1)
#define IDD_MWDMA_MODE2_ACTIVE          (1 << 2)

#define IDD_SWDMA_MODE0_ACTIVE          (1 << 0)
#define IDD_SWDMA_MODE1_ACTIVE          (1 << 1)
#define IDD_SWDMA_MODE2_ACTIVE          (1 << 2)

#define IDD_UDMA_MODE0_SUPPORTED        (1 << 0)
#define IDD_UDMA_MODE1_SUPPORTED        (1 << 1)
#define IDD_UDMA_MODE2_SUPPORTED        (1 << 2)

#define IDD_MWDMA_MODE0_SUPPORTED       (1 << 0)
#define IDD_MWDMA_MODE1_SUPPORTED       (1 << 1)
#define IDD_MWDMA_MODE2_SUPPORTED       (1 << 2)

#define IDD_SWDMA_MODE0_SUPPORTED       (1 << 0)
#define IDD_SWDMA_MODE1_SUPPORTED       (1 << 1)
#define IDD_SWDMA_MODE2_SUPPORTED       (1 << 2)
************/

//
// Beautification macros
//

#define HasSlaveDevice(HwExt, Target) (HwExt->DeviceFlags[(Target+1)%MAX_IDE_DEVICE] & DFLAGS_DEVICE_PRESENT)

#ifdef ENABLE_ATAPI_VERIFIER
#define GetBaseStatus(BaseIoAddress, Status) \
            Status = ViIdeGetBaseStatus((PIDE_REGISTERS_1)BaseIoAddress);
                       
#define GetErrorByte(BaseIoAddress, ErrorByte) \
            ErrorByte = ViIdeGetErrorByte((PIDE_REGISTERS_1)BaseIoAddress);
#else
#define GetBaseStatus(BaseIoAddress, Status) \
        Status = IdePortInPortByte((BaseIoAddress)->Command);

#define GetErrorByte(BaseIoAddress, ErrorByte) \
        ErrorByte = IdePortInPortByte((BaseIoAddress)->Error);
#endif

#define WriteCommand(BaseIoAddress, Command) \
    IdePortOutPortByte((BaseIoAddress)->Command, Command);



#define ReadBuffer(BaseIoAddress, Buffer, Count) \
    IdePortInPortWordBuffer((PUSHORT)(BaseIoAddress)->Data, Buffer, Count);

#define WriteBuffer(BaseIoAddress, Buffer, Count) \
    IdePortOutPortWordBuffer((PUSHORT)(BaseIoAddress)->Data, Buffer, Count);

#define WaitOnBusy(BaseIoAddress, Status) \
{ \
    ULONG sec;                                                      \
    ULONG i;                                                        \
    for (sec=0; sec<10; sec++) {  \
        /**/                                                        \
        /* one second loop */                                       \
        /**/                                                        \
        for (i=0; i<2500; i++) {                                    \
            GetStatus(BaseIoAddress, Status);                       \
            if (Status & IDE_STATUS_BUSY) {                         \
                KeStallExecutionProcessor(400);                     \
                continue;                                           \
            } else {                                                \
                break;                                              \
            }                                                       \
        }                                                           \
        if (Status & IDE_STATUS_BUSY) {                             \
            DebugPrint ((1, "ATAPI: after 1 sec wait, device is still busy with 0x%x status = 0x%x\n", (BaseIoAddress)->RegistersBaseAddress, (ULONG) (Status))); \
        } else {                                                    \
            break;                                                  \
        }                                                           \
    }                                                               \
    if (Status & IDE_STATUS_BUSY) {                                 \
        DebugPrint ((0, "WaitOnBusy failed in %s line %u. 0x%x status = 0x%x\n", __FILE__, __LINE__, (BaseIoAddress)->RegistersBaseAddress, (ULONG) (Status))); \
    }                                                               \
}

#define WaitForDRDY(BaseIoAddress, Status) \
{ \
    ULONG i; \
    WaitOnBusy(BaseIoAddress, Status);\
    for (i=0; i<20000; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (!(Status & IDE_STATUS_IDLE)) { \
            KeStallExecutionProcessor(150); \
            continue; \
        } else { \
            break; \
        } \
    } \
    if (i == 20000) \
        DebugPrint ((0, "WaitForDRDY failed in %s line %u. 0x%x status = 0x%x\n", __FILE__, __LINE__, (BaseIoAddress)->RegistersBaseAddress, (ULONG) (Status))); \
}


#define WaitOnBusyUntil(BaseIoAddress, Status, Millisec) \
{ \
    ULONG i; \
    ULONG maxCount = Millisec * 10;\
    for (i=0; i<maxCount; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            KeStallExecutionProcessor(100); \
            continue; \
        } else { \
            break; \
        } \
    } \
    if (i == maxCount) \
        DebugPrint ((0, "WaitOnBusyUntil failed in %s line %u. status = 0x%x\n", __FILE__, __LINE__, (ULONG) (Status))); \
}


#define WaitOnBaseBusy(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<20000; i++) { \
        GetBaseStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            KeStallExecutionProcessor(150); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WaitForDrq(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<1000; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            KeStallExecutionProcessor(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            KeStallExecutionProcessor(200); \
        } \
    } \
}



#define WaitShortForDrq(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<2; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            KeStallExecutionProcessor(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            KeStallExecutionProcessor(100); \
        } \
    } \
}

#define AtapiSoftReset(BaseIoAddress1, BaseIoAddress2, DeviceNumber, interruptOff) \
{\
    ULONG __i;\
    UCHAR statusByte; \
    SelectIdeDevice(BaseIoAddress1, DeviceNumber, 0); \
    KeStallExecutionProcessor(500);\
    IdePortOutPortByte((BaseIoAddress1)->Command, IDE_COMMAND_ATAPI_RESET); \
    KeStallExecutionProcessor(500);\
    SelectIdeDevice(BaseIoAddress1, DeviceNumber, 0); \
    WaitOnBusy(BaseIoAddress1, statusByte); \
    if ( !Is98LegacyIde(BaseIoAddress1) ) { \
        KeStallExecutionProcessor(500); \
    } else { \
        for (__i = 0; __i < 20; __i++) { \
            KeStallExecutionProcessor(500); \
        } \
    } \
    if (interruptOff) { \
        IdePortOutPortByte(BaseIoAddress2->DeviceControl, IDE_DC_DISABLE_INTERRUPTS); \
    } \
}

#define SAVE_ORIGINAL_CDB(DeviceExtension, Srb) \
	RtlCopyMemory(DeviceExtension->OriginalCdb, Srb->Cdb, sizeof(CDB));

#define RESTORE_ORIGINAL_CDB(DeviceExtension, Srb) \
	RtlCopyMemory(Srb->Cdb, DeviceExtension->OriginalCdb, sizeof(CDB));
	
//
// NEC 98: Buffer size of mode sense data.
//
#define MODE_DATA_SIZE          192

typedef enum {
    IdeResetBegin = 0,
    ideResetBusResetInProgress,

    ideResetAtapiReset,
    ideResetAtapiResetInProgress,
    ideResetAtapiIdentifyData,

    ideResetAtaIDP,
    ideResetAtaIDPInProgress,
    ideResetAtaMSN,

    ideResetFinal
} IDE_RESET_STATE;


//
// Definition in ide.h
//
struct IDENTIFY_DATA;
//
// Device extension
//
typedef struct _HW_DEVICE_EXTENSION {

    //
    // Current request on controller.
    //

    PSCSI_REQUEST_BLOCK CurrentSrb;

    //
    // Base register locations
    //

    IDE_REGISTERS_1            BaseIoAddress1;
    IDE_REGISTERS_2            BaseIoAddress2;

    //
    // Register length.
    //

    ULONG   BaseIoAddress1Length;
    ULONG   BaseIoAddress2Length;

    //
    // Max ide device/target-id
    //

    ULONG   MaxIdeDevice;
    ULONG   MaxIdeTargetId;

    //
    // Variables to check empty channel
    //
#ifdef DPC_FOR_EMPTY_CHANNEL
    ULONG CurrentIdeDevice;
    ULONG MoreWait;
    ULONG NoRetry;
#endif
    //
    // Drive Geometry
    //
    ULONG   NumberOfCylinders[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG   NumberOfHeads[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG   SectorsPerTrack[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Interrupt Mode (Level or Edge)
    //

    ULONG InterruptMode;

    //
    // Data buffer pointer.
    //

    PUCHAR DataBuffer;

    //
    // Data words left.
    //

    ULONG BytesLeft;

    //
    // Count of errors. Used to turn off features.
    //

    ULONG ErrorCount;

    //
    // Count of timeouts. Used to turn off features.
    //

    ULONG TimeoutCount[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicates number of platters on changer-ish devices.
    //

    ULONG LastLun[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Flags word for each possible device.
    //

    ULONG DeviceFlags[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicates the number of blocks transferred per int. according to the
    // identify data.
    //

    UCHAR MaximumBlockXfer[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicates expecting an interrupt
    //

    BOOLEAN ExpectingInterrupt;

    //
    // Indicates DMA is in progress
    //

    BOOLEAN DMAInProgress;

    //
    // Keep track of whether we convert a SCSI command to ATAPI on the fly
    //
    BOOLEAN scsi2atapi;

    //
    // Indicate last tape command was DSC Restrictive.
    //

    BOOLEAN RDP;

    //
    // Driver is being used by the crash dump utility or ntldr.
    //

    BOOLEAN DriverMustPoll;

    //
    // Indicates whether '0x1f0' is the base address. Used
    // in SMART Ioctl calls.
    //

    BOOLEAN PrimaryAddress;
    BOOLEAN SecondaryAddress;

    //
    // No IDE_SET_FEATURE_SET_TRANSFER_MODE
    //
    BOOLEAN NoPioSetTransferMode;

    //
    // Placeholder for the original cdb
    //
	UCHAR OriginalCdb[16];

    //
    // Placeholder for the sub-command value of the last
    // SMART command.
    //

    UCHAR SmartCommand;

    //
    // Placeholder for status register after a GET_MEDIA_STATUS command
    //
    UCHAR ReturningMediaStatus;

    //
    // Identify data for device
    //
    IDENTIFY_DATA IdentifyData[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // PCI IDE Parent bus master interface
    //
    PCIIDE_BUSMASTER_INTERFACE BusMasterInterface;

    //
    // Device Specific Info.
    //
    struct _DEVICE_PARAMETERS {

        ULONG   MaxBytePerPioInterrupt;

        UCHAR   IdePioReadCommand;
        UCHAR   IdePioWriteCommand;
        UCHAR   IdeFlushCommand;

        UCHAR   IdePioReadCommandExt;
        UCHAR   IdePioWriteCommandExt;
        UCHAR   IdeFlushCommandExt;

        //
        // Timing Stuff
        //
        BOOLEAN IoReadyEnabled;
        ULONG   BestPioCycleTime;
        ULONG   BestSwDmaCycleTime;
        ULONG   BestMwDmaCycleTime;
        ULONG   BestUDmaCycleTime;

        ULONG   TransferModeSupported;
        ULONG   BestPioMode;
        ULONG   BestSwDmaMode;
        ULONG   BestMwDmaMode;
        ULONG   BestUDmaMode;

        ULONG   TransferModeCurrent;

        ULONG   TransferModeSelected;

        ULONG   TransferModeMask;

    } DeviceParameters[MAX_IDE_DEVICE * MAX_IDE_LINE];

#define RESET_STATE_TABLE_LEN   (((2 + 3 * MAX_IDE_DEVICE) * MAX_IDE_LINE) + 1)

    struct RESET_STATE {

        ULONG WaitBusyCount;

        IDE_RESET_STATE State[RESET_STATE_TABLE_LEN];
        IDE_RESET_STATE DeviceNumber[RESET_STATE_TABLE_LEN];

    } ResetState;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// max number of CHS addressable sectors
//
//#define MAX_NUM_CHS_ADDRESSABLE_SECTORS     ((ULONG) (16515072 - 1))
#define MAX_NUM_CHS_ADDRESSABLE_SECTORS     ((ULONG) (16514064))
#define MAX_28BIT_LBA     ((ULONG) (1<<28))

//
// IDE Cycle Timing
//
/****************************Moved to idep.h****************
#define PIO_MODE0_CYCLE_TIME        600
#define PIO_MODE1_CYCLE_TIME        383
#define PIO_MODE2_CYCLE_TIME        240
#define PIO_MODE3_CYCLE_TIME        180
#define PIO_MODE4_CYCLE_TIME        120

#define SWDMA_MODE0_CYCLE_TIME      960
#define SWDMA_MODE1_CYCLE_TIME      480
#define SWDMA_MODE2_CYCLE_TIME      240

#define MWDMA_MODE0_CYCLE_TIME      480
#define MWDMA_MODE1_CYCLE_TIME      150
#define MWDMA_MODE2_CYCLE_TIME      120

#define UDMA_MODE0_CYCLE_TIME       120
#define UDMA_MODE1_CYCLE_TIME       80
#define UDMA_MODE2_CYCLE_TIME       60
#define UDMA_MODE3_CYCLE_TIME       45
#define UDMA_MODE4_CYCLE_TIME       30
#define UDMA_MODE5_CYCLE_TIME       15

#define UNINITIALIZED_CYCLE_TIME    0xffffffff
#define UNINITIALIZED_TRANSFER_MODE 0xffffffff
*/
BOOLEAN
AtapiInterrupt(
    IN PVOID HwDeviceExtension
    );

BOOLEAN
AtapiHwInitialize(
    IN PVOID HwDeviceExtension,
    IN UCHAR FlushCommand[MAX_IDE_DEVICE * MAX_IDE_LINE]
    );

BOOLEAN
AtapiStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
AtapiResetController(
    IN PVOID  HwDeviceExtension,
    IN ULONG  PathId,
    IN PULONG CallAgain
    );

VOID
InitDeviceParameters (
    IN PVOID HwDeviceExtension,
    IN UCHAR FlushCommand[MAX_IDE_DEVICE * MAX_IDE_LINE]
    );

VOID
AtapiProgramTransferMode (
    PHW_DEVICE_EXTENSION DeviceExtension
    );

VOID
AtapiHwInitializeMultiLun (
    IN PVOID HwDeviceExtension,
    IN ULONG TargetId,
    IN ULONG numSlot
    );

ULONG
AtapiSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

ULONG
IdeBuildSenseBuffer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
IdeMediaStatus(
    IN BOOLEAN EnableMSN,
    IN PVOID HwDeviceExtension,
    IN ULONG DeviceNumber
    );

VOID
DeviceSpecificInitialize(
    IN PVOID HwDeviceExtension
    );

BOOLEAN
EnableBusMasterController (
    IN PVOID HwDeviceExtension,
    IN PCHAR userArgumentString
    );

BOOLEAN
AtapiDeviceDMACapable (
    IN PVOID HwDeviceExtension,
    IN ULONG deviceNumber
    );

BOOLEAN
GetAtapiIdentifyQuick (
    PIDE_REGISTERS_1    BaseIoAddress1,
    PIDE_REGISTERS_2    BaseIoAddress2,
    IN ULONG            DeviceNumber,
    OUT PIDENTIFY_DATA  IdentifyData
    );

BOOLEAN
IssueIdentify(
    PIDE_REGISTERS_1    CmdBaseAddr,
    PIDE_REGISTERS_2    CtrlBaseAddr,
    IN ULONG            DeviceNumber,
    IN UCHAR            Command,
    IN BOOLEAN          InterruptOff,
    OUT PIDENTIFY_DATA  IdentifyData
    );

VOID
InitDeviceGeometry(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG                Device,
    ULONG                NumberOfCylinders,
    ULONG                NumberOfHeads,
    ULONG                SectorsPerTrack
    );

VOID
InitHwExtWithIdentify(
    IN PVOID           HwDeviceExtension,
    IN ULONG           DeviceNumber,
    IN UCHAR           Command,
    IN PIDENTIFY_DATA  IdentifyData,
    IN BOOLEAN         RemovableMedia
    );

BOOLEAN
SetDriveParameters(
    IN PVOID HwDeviceExtension,
    IN ULONG DeviceNumber,
    IN BOOLEAN Sync
    );

BOOLEAN
FindDevices(
    IN PVOID HwDeviceExtension,
    IN BOOLEAN AtapiOnly
    );

ULONG
IdeSendPassThroughCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
AtapiSyncResetController(
    IN PVOID  HwDeviceExtension,
    IN ULONG  PathId
    );

NTSTATUS
IdeHardReset (
    PIDE_REGISTERS_1     BaseIoAddress1,
    PIDE_REGISTERS_2     BaseIoAddress2,
    BOOLEAN              InterruptOff,
    BOOLEAN              Sync
    );

ULONG
IdeReadWrite(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
AtapiTaskRegisterSnapshot (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN OUT PIDEREGS     IdeReg
);

NTSTATUS
AtapiSetTransferMode (
    PHW_DEVICE_EXTENSION DeviceExtension,
    ULONG                DeviceNumber,
    UCHAR                ModeValue
    );

#define     ATA_VERSION_MASK    (0xfffe)
#define     ATA1_COMPLIANCE     (1 << 1)
#define     ATA2_COMPLIANCE     (1 << 2)
#define     ATA3_COMPLIANCE     (1 << 3)
#define     ATA4_COMPLIANCE     (1 << 4)


#endif // ___atapi_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\atapinit.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    atapinit.c

Abstract:

    This contain routine to enumrate IDE devices on the IDE bus

Author:

    Joe Dai (joedai)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "ideport.h"

extern PULONG InitSafeBootMode;  // imported from NTOS (init.c), must use a pointer to reference the data

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IdePortInitHwDeviceExtension)
#pragma alloc_text(PAGE, AtapiDetectDevice)
#pragma alloc_text(PAGE, IdePreAllocEnumStructs)
#pragma alloc_text(PAGE, IdeFreeEnumStructs)

#pragma alloc_text(NONPAGE, AtapiSyncSelectTransferMode)
                          
#pragma alloc_text(PAGESCAN, AnalyzeDeviceCapabilities)
#pragma alloc_text(PAGESCAN, AtapiDMACapable)
#pragma alloc_text(PAGESCAN, IdePortSelectCHS)
#pragma alloc_text(PAGESCAN, IdePortScanBus)

LONG IdePAGESCANLockCount = 0;
#endif // ALLOC_PRAGMA

#ifdef IDE_MEASURE_BUSSCAN_SPEED
static PWCHAR IdePortBootTimeRegKey[6]= {
    L"IdeBusResetTime",
    L"IdeEmptyChannelCheckTime",
    L"IdeDetectMasterDeviceTime",
    L"IdeDetectSlaveDeviceTime",
    L"IdeCriticalSectionTime",
    L"IdeLastStageScanTime"
};
#endif

static PWCHAR IdePortRegistryDeviceTimeout[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    MASTER_DEVICE_TIMEOUT,
    SLAVE_DEVICE_TIMEOUT
};

static PWCHAR IdePortRegistryDeviceTypeName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    MASTER_DEVICE_TYPE_REG_KEY,
    SLAVE_DEVICE_TYPE_REG_KEY,
    MASTER_DEVICE_TYPE2_REG_KEY,
    SLAVE_DEVICE_TYPE2_REG_KEY
};

static PWCHAR IdePortRegistryDeviceTimingModeName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    MASTER_DEVICE_TIMING_MODE,
    SLAVE_DEVICE_TIMING_MODE,
    MASTER_DEVICE_TIMING_MODE2,
    SLAVE_DEVICE_TIMING_MODE2
};

static PWCHAR IdePortRegistryDeviceTimingModeAllowedName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    MASTER_DEVICE_TIMING_MODE_ALLOWED,
    SLAVE_DEVICE_TIMING_MODE_ALLOWED,
    MASTER_DEVICE_TIMING_MODE_ALLOWED2,
    SLAVE_DEVICE_TIMING_MODE_ALLOWED2
};

static PWCHAR IdePortRegistryIdentifyDataChecksum[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    MASTER_IDDATA_CHECKSUM,
    SLAVE_IDDATA_CHECKSUM,
    MASTER_IDDATA_CHECKSUM2,
    SLAVE_IDDATA_CHECKSUM2
};

static PWCHAR IdePortUserRegistryDeviceTypeName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    USER_MASTER_DEVICE_TYPE_REG_KEY,
    USER_SLAVE_DEVICE_TYPE_REG_KEY,
    USER_MASTER_DEVICE_TYPE2_REG_KEY,
    USER_SLAVE_DEVICE_TYPE2_REG_KEY
};

static PWCHAR IdePortRegistryUserDeviceTimingModeAllowedName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    USER_MASTER_DEVICE_TIMING_MODE_ALLOWED,
    USER_SLAVE_DEVICE_TIMING_MODE_ALLOWED,
    USER_MASTER_DEVICE_TIMING_MODE_ALLOWED2,
    USER_SLAVE_DEVICE_TIMING_MODE_ALLOWED2
};

VOID
AnalyzeDeviceCapabilities(
    IN OUT PFDO_EXTENSION FdoExtension,
    IN BOOLEAN            MustBePio[MAX_IDE_DEVICE * MAX_IDE_LINE]
    )
/*++

Routine Description:

    software-initialize devices on the ide bus

    figure out
        if the attached devices are dma capable
        if the attached devices are LBA ready

Arguments:

    HwDeviceExtension   - HW Device Extension

Return Value:

    none

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = FdoExtension->HwDeviceExtension;
    ULONG deviceNumber;
    BOOLEAN pioDevicePresent;
    PIDENTIFY_DATA identifyData;
    struct _DEVICE_PARAMETERS * deviceParameters;
    ULONG cycleTime;
    ULONG xferMode;
    ULONG bestXferMode;
    ULONG currentMode;
    ULONG tempMode;

    ULONG numberOfCylinders;
    ULONG numberOfHeads;
    ULONG sectorsPerTrack;

    PULONG TransferModeTimingTable=FdoExtension->TransferModeInterface.TransferModeTimingTable;
    ULONG transferModeTableLength=FdoExtension->TransferModeInterface.TransferModeTableLength;
    ASSERT(TransferModeTimingTable);

    //
    // Code is paged until locked down.
    //
	PAGED_CODE();
#ifdef ALLOC_PRAGMA
	ASSERT(IdePAGESCANLockCount > 0);
#endif

    //
    // Figure out who can do DMA and who cannot
    //
    for (deviceNumber = 0; deviceNumber < deviceExtension->MaxIdeDevice; deviceNumber++) {

        if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {

            //
            // check LBA capabilities
            //
            CLRMASK (deviceExtension->DeviceFlags[deviceNumber], DFLAGS_LBA);

            // Some drives lie about their ability to do LBA
            // we don't want to do LBA unless we have to (>8G drive)
            if (deviceExtension->IdentifyData[deviceNumber].UserAddressableSectors > MAX_NUM_CHS_ADDRESSABLE_SECTORS) {

                // some device has a bogus value in the UserAddressableSectors field
                // make sure these 3 fields are max. out as defined in ATA-3 (X3T10 Rev. 6)
                if ((deviceExtension->IdentifyData[deviceNumber].NumCylinders == 16383) &&
                    (deviceExtension->IdentifyData[deviceNumber].NumHeads<= 16) &&
                    (deviceExtension->IdentifyData[deviceNumber].NumSectorsPerTrack== 63)) {

                    deviceExtension->DeviceFlags[deviceNumber] |= DFLAGS_LBA;
                }

				if (!Is98LegacyIde(&deviceExtension->BaseIoAddress1)) {

					//
					// words 1, 3 and 6
					//
					numberOfCylinders = deviceExtension->IdentifyData[deviceNumber].NumCylinders;
					numberOfHeads     = deviceExtension->IdentifyData[deviceNumber].NumHeads;
					sectorsPerTrack   = deviceExtension->IdentifyData[deviceNumber].NumSectorsPerTrack;

					if (deviceExtension->IdentifyData[deviceNumber].UserAddressableSectors >
						(numberOfCylinders * numberOfHeads * sectorsPerTrack)) {

						//
						// some ide driver has a 2G jumer to get around bios
						// problem.  make sure we are not tricked the same way.
						//
						if ((numberOfCylinders <= 0xfff) &&
							(numberOfHeads == 0x10) &&
							(sectorsPerTrack == 0x3f)) {
	
							deviceExtension->DeviceFlags[deviceNumber] |= DFLAGS_LBA;
						}
					}
				}
            }

#ifdef ENABLE_48BIT_LBA
			{
				USHORT commandSetSupport = deviceExtension->IdentifyData[deviceNumber].CommandSetSupport;
				USHORT commandSetActive = deviceExtension->IdentifyData[deviceNumber].CommandSetActive;

				if ((commandSetSupport & IDE_IDDATA_48BIT_LBA_SUPPORT) &&
					(commandSetActive & IDE_IDDATA_48BIT_LBA_SUPPORT)) {
					ULONG maxLBA;

					//
					// get words 100-103 and make sure that it is the same or 
					// greater than words 57-58.
					//
					ASSERT(deviceExtension->IdentifyData[deviceNumber].Max48BitLBA[0] != 0);
					maxLBA = deviceExtension->IdentifyData[deviceNumber].Max48BitLBA[0];
					ASSERT(deviceExtension->IdentifyData[deviceNumber].Max48BitLBA[1] == 0);

					ASSERT(maxLBA >= deviceExtension->IdentifyData[deviceNumber].UserAddressableSectors);

					DebugPrint((0,
								"Max LBA supported is 0x%x\n",
								maxLBA
								));

					if ((FdoExtension->EnableBigLba == 1) && 
						(maxLBA >= MAX_28BIT_LBA)) {

						deviceExtension->DeviceFlags[deviceNumber] |= DFLAGS_48BIT_LBA;
						deviceExtension->DeviceFlags[deviceNumber] |= DFLAGS_LBA;

					} else {

						DebugPrint((1, "big lba disabled\n"));
					}
				}
			}
#endif
            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_LBA) {
                DebugPrint ((DBG_BUSSCAN, "atapi: target %d supports LBA\n", deviceNumber));
            }

            xferMode  = 0;
            cycleTime = UNINITIALIZED_CYCLE_TIME;
            bestXferMode = 0;

            //
            // check for IoReady Line
            //
            if (deviceExtension->IdentifyData[deviceNumber].Capabilities & IDENTIFY_CAPABILITIES_IOREADY_SUPPORTED) {

                deviceExtension->DeviceParameters[deviceNumber].IoReadyEnabled = TRUE;

            } else {

                deviceExtension->DeviceParameters[deviceNumber].IoReadyEnabled = FALSE;
            }

            //
            // Check for PIO mode
            //
            bestXferMode = (deviceExtension->IdentifyData[deviceNumber].PioCycleTimingMode & 0x00ff)+PIO0;

            if (bestXferMode > PIO2) {
                bestXferMode = PIO0;
            }

            ASSERT(bestXferMode < PIO3);

            cycleTime = TransferModeTimingTable[bestXferMode];
            ASSERT(cycleTime);

            GenTransferModeMask(bestXferMode, xferMode);
            currentMode = 1<<bestXferMode;

            if (deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 1)) {

                if (deviceExtension->DeviceParameters[deviceNumber].IoReadyEnabled) {

                    cycleTime = deviceExtension->IdentifyData[deviceNumber].MinimumPIOCycleTimeIORDY;

                } else {

                    cycleTime = deviceExtension->IdentifyData[deviceNumber].MinimumPIOCycleTime;
                }

                if (deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes & (1 << 0)) {

                    xferMode |= PIO_MODE3;
                    bestXferMode = 3;

                    currentMode = PIO_MODE3;
                }

                if (deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes & (1 << 1)) {

                    xferMode |= PIO_MODE4;
                    bestXferMode = 4;

                    currentMode = PIO_MODE4;
                }

                // check if any of the bits > 1 are set. If so, default to PIO_MODE4
                if (deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes) {
                    GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes,
                                               bestXferMode);
                    bestXferMode += PIO3;

                    if (bestXferMode > PIO4) {
                        DebugPrint((DBG_ALWAYS, 
                                    "ATAPI: AdvancePIOMode > PIO_MODE4. Defaulting to PIO_MODE4. \n"));
                        bestXferMode = PIO4;
                    }

                    currentMode = 1<<bestXferMode;
                    xferMode |= currentMode;
                }

                DebugPrint ((DBG_BUSSCAN,
                             "atapi: target %d IdentifyData AdvancedPIOModes = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes));
            }

            ASSERT (cycleTime != UNINITIALIZED_CYCLE_TIME);
            ASSERT (xferMode);
            ASSERT (currentMode);
            deviceExtension->DeviceParameters[deviceNumber].BestPioCycleTime      = cycleTime;
            deviceExtension->DeviceParameters[deviceNumber].BestPioMode           = bestXferMode;

            //
            // can't really figure out the current PIO mode
            // just use the best mode
            //
            deviceExtension->DeviceParameters[deviceNumber].TransferModeCurrent   = currentMode;

            //
            // figure out all the DMA transfer mode this device supports
            //
            currentMode = 0;

            //
            // check singleword DMA timing
            //
            cycleTime = UNINITIALIZED_CYCLE_TIME;
            bestXferMode = UNINITIALIZED_TRANSFER_MODE;

            if (deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport) {

                DebugPrint ((DBG_BUSSCAN,
                             "atapi: target %d IdentifyData SingleWordDMASupport = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport));
                DebugPrint ((DBG_BUSSCAN,
                             "atapi: target %d IdentifyData SingleWordDMAActive = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].SingleWordDMAActive));

                GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport,
                                           bestXferMode);

                if ((bestXferMode+SWDMA0) > SWDMA2) {
                    bestXferMode = SWDMA2-SWDMA0;
                }

                cycleTime = TransferModeTimingTable[bestXferMode+SWDMA0];
                ASSERT(cycleTime);

                tempMode = 0;
                GenTransferModeMask(bestXferMode, tempMode);

                xferMode |= (tempMode << SWDMA0);

                if (deviceExtension->IdentifyData[deviceNumber].SingleWordDMAActive) {

                    GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].SingleWordDMAActive,
                                               currentMode);

                    if ((currentMode+SWDMA0) > SWDMA2) {
                        currentMode = SWDMA2 - SWDMA0;
                    }
                    currentMode = 1 << (currentMode+SWDMA0);
                }
            }

            deviceExtension->DeviceParameters[deviceNumber].BestSwDmaCycleTime    = cycleTime;
            deviceExtension->DeviceParameters[deviceNumber].BestSwDmaMode         = bestXferMode;

            //
            // check multiword DMA timing
            //
            cycleTime = UNINITIALIZED_CYCLE_TIME;
            bestXferMode = UNINITIALIZED_TRANSFER_MODE;

            if (deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport) {

                DebugPrint ((DBG_BUSSCAN,
                             "atapi: target %d IdentifyData MultiWordDMASupport = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport));
                DebugPrint ((DBG_BUSSCAN,
                             "atapi: target %d IdentifyData MultiWordDMAActive = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].MultiWordDMAActive));

                GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport,
                                           bestXferMode);

                if ((bestXferMode+MWDMA0) > MWDMA2) {
                    bestXferMode = MWDMA2 - MWDMA0;
                }

                cycleTime = TransferModeTimingTable[bestXferMode+MWDMA0];
                ASSERT(cycleTime);

                tempMode = 0;
                GenTransferModeMask(bestXferMode, tempMode);

                xferMode |= (tempMode << MWDMA0);

                if (deviceExtension->IdentifyData[deviceNumber].MultiWordDMAActive) {

                    GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].MultiWordDMAActive,
                                               currentMode);

                    if ((currentMode+MWDMA0) > MWDMA2) {
                        currentMode = MWDMA2 - MWDMA0;
                    }
                    currentMode = 1 << (currentMode+MWDMA0);
                }
            }

            if (deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 1)) {

                DebugPrint ((DBG_BUSSCAN, "atapi: target %d IdentifyData word 64-70 are valid\n", deviceNumber));

                if (deviceExtension->IdentifyData[deviceNumber].MinimumMWXferCycleTime &&
                    deviceExtension->IdentifyData[deviceNumber].RecommendedMWXferCycleTime) {

                    DebugPrint ((DBG_BUSSCAN,
                                 "atapi: target %d IdentifyData MinimumMWXferCycleTime = 0x%x\n",
                                 deviceNumber,
                                 deviceExtension->IdentifyData[deviceNumber].MinimumMWXferCycleTime));
                    DebugPrint ((DBG_BUSSCAN,
                                 "atapi: target %d IdentifyData RecommendedMWXferCycleTime = 0x%x\n",
                                 deviceNumber,
                                 deviceExtension->IdentifyData[deviceNumber].RecommendedMWXferCycleTime));

                    cycleTime = deviceExtension->IdentifyData[deviceNumber].MinimumMWXferCycleTime;
                }
            }

            deviceExtension->DeviceParameters[deviceNumber].BestMwDmaCycleTime = cycleTime;
            deviceExtension->DeviceParameters[deviceNumber].BestMwDmaMode      = bestXferMode;

            //
            // figure out the ultra DMA timing the device supports
            //
            cycleTime = UNINITIALIZED_CYCLE_TIME;
            bestXferMode = UNINITIALIZED_TRANSFER_MODE;
            tempMode = UNINITIALIZED_TRANSFER_MODE; // to set the current mode correctly

            //
            // Consult the channel driver for the UDMA modes that are supported.
            // This will allow new udma modes to be supported. Always trust this funtion.
            // 
            if (FdoExtension->TransferModeInterface.UdmaModesSupported) {

                NTSTATUS status = FdoExtension->TransferModeInterface.UdmaModesSupported (
                             deviceExtension->IdentifyData[deviceNumber],
                             &bestXferMode,
                             &tempMode
                             );

                if (!NT_SUCCESS(status)) {
                    bestXferMode = UNINITIALIZED_TRANSFER_MODE;
                    tempMode = UNINITIALIZED_TRANSFER_MODE;
                }

            }  else {
            
                //
                // No udma support funtions to interpret Identify data in the channel driver. 
                // Interpret in the known way.
                //

                if (deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 2)) {

                    if (deviceExtension->IdentifyData[deviceNumber].UltraDMASupport) {

                        GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].UltraDMASupport,
                                                   bestXferMode);
                    }

                    if (deviceExtension->IdentifyData[deviceNumber].UltraDMAActive) {

                        GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].UltraDMAActive,
                                                   tempMode);
                    }

                }
            }


            //
            // Use the current mode if we actually got one
            //
            if (tempMode != UNINITIALIZED_TRANSFER_MODE) {

                currentMode = tempMode;

                if (transferModeTableLength <= (currentMode + UDMA0)) {
                    currentMode = transferModeTableLength-UDMA0-1;
                } 

                currentMode = 1 << (currentMode+UDMA0);
            }

            //
            // make sure that bestXferMode is initialized. if not it indicates that
            // the device does not support udma.
            //
            if (bestXferMode != UNINITIALIZED_TRANSFER_MODE) {

                if (transferModeTableLength <= (bestXferMode + UDMA0)) {
                    bestXferMode = transferModeTableLength-UDMA0-1;
                }

                cycleTime = TransferModeTimingTable[bestXferMode+UDMA0];
                ASSERT(cycleTime);

                tempMode = 0;
                GenTransferModeMask(bestXferMode, tempMode);

                xferMode |= (tempMode << UDMA0);
            }

            //
            // Doesn't really know the ultra dma cycle time
            //
            deviceExtension->DeviceParameters[deviceNumber].BestUDmaCycleTime = cycleTime;
            deviceExtension->DeviceParameters[deviceNumber].BestUDmaMode      = bestXferMode;

            deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported = xferMode;
            deviceExtension->DeviceParameters[deviceNumber].TransferModeCurrent  |= currentMode;

            //
            // Check to see if the device is in the Hall of Shame!
            //
            if (MustBePio[deviceNumber] || 
                !AtapiDMACapable (FdoExtension, deviceNumber) ||
                (*InitSafeBootMode == SAFEBOOT_MINIMAL)) {

                DebugPrint((DBG_XFERMODE,
                            "ATAPI: Reseting DMA Information\n"
                            ));
                //
                // Remove all DMA info
                //
                deviceExtension->DeviceParameters[deviceNumber].BestSwDmaCycleTime = 0;
                deviceExtension->DeviceParameters[deviceNumber].BestMwDmaCycleTime = 0;
                deviceExtension->DeviceParameters[deviceNumber].BestUDmaCycleTime  = 0;
                deviceExtension->DeviceParameters[deviceNumber].BestSwDmaMode      = 0;
                deviceExtension->DeviceParameters[deviceNumber].BestMwDmaMode      = 0;
                deviceExtension->DeviceParameters[deviceNumber].BestUDmaMode       = 0;
                deviceExtension->DeviceParameters[deviceNumber].TransferModeCurrent   &= PIO_SUPPORT;
                deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported &= PIO_SUPPORT;
            }

            // if DMADetectionLevel = 0, clear current DMA mode
            // if DMADetectionLevel = 1, set current mode
            // if DMADetectionLevel = 2, clear all current mode
            // pciidex takes care of this for non-acpi machines. 
            // In acpi systems, it is better to trust the GTM settings.

            //
            // If a device supports any of the advanced PIO mode, we are assuming that
            // the device is a "newer" drive and IDE_COMMAND_READ_MULTIPLE should work.
            // Otherwise, we will turn off IDE_COMMAND_READ_MULTIPLE
            //
            if (deviceExtension->DeviceParameters[deviceNumber].BestPioMode > 2) {

                if (!Is98LegacyIde(&deviceExtension->BaseIoAddress1)) {

                    deviceExtension->MaximumBlockXfer[deviceNumber] =
                        (UCHAR)(deviceExtension->IdentifyData[deviceNumber].MaximumBlockTransfer & 0xFF);

                } else {

                    //
                    // MaximumBlockXfer is less or equal 16
                    //
                    deviceExtension->MaximumBlockXfer[deviceNumber] =
                        ((UCHAR)(deviceExtension->IdentifyData[deviceNumber].MaximumBlockTransfer & 0xFF) > 16)?
                            16 : (UCHAR)(deviceExtension->IdentifyData[deviceNumber].MaximumBlockTransfer & 0xFF);
                }
            } else {

                deviceExtension->MaximumBlockXfer[deviceNumber] = 0;
            }

            DebugPrint ((DBG_XFERMODE,
                         "atapi: target %d transfer timing:\n"
                         "atapi: PIO mode supported   = %4x and best cycle time = %5d ns\n"
                         "atapi: SWDMA mode supported = %4x and best cycle time = %5d ns\n"
                         "atapi: MWDMA mode supported = %4x and best cycle time = %5d ns\n"
                         "atapi: UDMA mode supported  = %x and best cycle time = %5d ns\n"
                         "atapi: Current mode bitmap  = %4x\n",
                         deviceNumber,
                         deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported & PIO_SUPPORT,
                         deviceExtension->DeviceParameters[deviceNumber].BestPioCycleTime,
                         deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported & SWDMA_SUPPORT,
                         deviceExtension->DeviceParameters[deviceNumber].BestSwDmaCycleTime,
                         deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported & MWDMA_SUPPORT,
                         deviceExtension->DeviceParameters[deviceNumber].BestMwDmaCycleTime,
                         deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported & UDMA_SUPPORT,
                         deviceExtension->DeviceParameters[deviceNumber].BestUDmaCycleTime,
                         deviceExtension->DeviceParameters[deviceNumber].TransferModeCurrent
                         ));
        }
    }

} // AnalyzeDeviceCapabilities


VOID
AtapiSyncSelectTransferMode (
    IN PFDO_EXTENSION FdoExtension,
    IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
    IN ULONG TimingModeAllowed[MAX_IDE_TARGETID * MAX_IDE_LINE]
    )
/*++

Routine Description:

    query the best transfer mode for our devices

Arguments:

    FdoExtension
    DeviceExtension   - HW Device Extension
    TimingModeAllowed - Allowed transfer modes

Return Value:

    none

--*/
{
    PCIIDE_TRANSFER_MODE_SELECT  transferModeSelect;
    ULONG                        i;
    NTSTATUS                     status;


    if (!IsNEC_98) {
                                                 
        RtlZeroMemory (&transferModeSelect, sizeof(transferModeSelect));
    
        for (i=0; i<DeviceExtension->MaxIdeDevice; i++) {

            transferModeSelect.DevicePresent[i] = DeviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT ? TRUE : FALSE;
    
            //
            // ISSUE: 07/31/2000: How about atapi hard disk
			// We don't know of any. This would suffice for the time being.
            //
            transferModeSelect.FixedDisk[i]     = !(DeviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE);
    
            transferModeSelect.BestPioCycleTime[i] = DeviceExtension->DeviceParameters[i].BestPioCycleTime;
            transferModeSelect.BestSwDmaCycleTime[i] = DeviceExtension->DeviceParameters[i].BestSwDmaCycleTime;
            transferModeSelect.BestMwDmaCycleTime[i] = DeviceExtension->DeviceParameters[i].BestMwDmaCycleTime;
            transferModeSelect.BestUDmaCycleTime[i] = DeviceExtension->DeviceParameters[i].BestUDmaCycleTime;
    
            transferModeSelect.IoReadySupported[i] = DeviceExtension->DeviceParameters[i].IoReadyEnabled;
    
            transferModeSelect.DeviceTransferModeSupported[i] = DeviceExtension->DeviceParameters[i].TransferModeSupported;
            transferModeSelect.DeviceTransferModeCurrent[i]   = DeviceExtension->DeviceParameters[i].TransferModeCurrent;
    
            //
            // if we don't have a busmaster capable parent or
            // the device is a tape, stay with pio mode
            //
            // (tape may transfer fewer bytes than requested.
            //  we can't figure exactly byte transfered with DMA)
            //
          //  if ((!FdoExtension->BoundWithBmParent) ||
           //     (DeviceExtension->DeviceFlags[i] & DFLAGS_TAPE_DEVICE)) {
            if (!FdoExtension->BoundWithBmParent) {
    
                transferModeSelect.DeviceTransferModeSupported[i] &= PIO_SUPPORT;
                transferModeSelect.DeviceTransferModeCurrent[i]   &= PIO_SUPPORT;
            }

            //
            // Some miniports need this
            //
            transferModeSelect.IdentifyData[i]=DeviceExtension->IdentifyData[i];
    
            transferModeSelect.UserChoiceTransferMode[i] = FdoExtension->UserChoiceTransferMode[i];
            //
            // honor user's choice and/or last knowen good mode
            //
            transferModeSelect.DeviceTransferModeSupported[i] &= TimingModeAllowed[i];
            transferModeSelect.DeviceTransferModeCurrent[i] &= TimingModeAllowed[i];
    
            // should look at dmadetectionlevel and set DeviceTransferModeDesired
            // we look at dmaDetectionlecel in TransferModeSelect function below.
            // the parameters set here should be honoured anyways, I feel.

        }

        transferModeSelect.TransferModeTimingTable= FdoExtension->
                                                        TransferModeInterface.TransferModeTimingTable;
        transferModeSelect.TransferModeTableLength= FdoExtension->
                                                        TransferModeInterface.TransferModeTableLength;

        ASSERT(FdoExtension->TransferModeInterface.TransferModeSelect);
        status = FdoExtension->TransferModeInterface.TransferModeSelect (
                     FdoExtension->TransferModeInterface.Context,
                     &transferModeSelect
                     );
    } else {                     
        //
        // Always fail for nec98 machines
        //
        status = STATUS_UNSUCCESSFUL; 
    }

    if (!NT_SUCCESS(status)) {
    
        //
        // Unable to get the mode select, default to current PIO mode
        //
        for (i=0; i<DeviceExtension->MaxIdeDevice; i++) {
            DeviceExtension->DeviceParameters[i].TransferModeSelected =
                DeviceExtension->DeviceParameters[i].TransferModeCurrent & PIO_SUPPORT;
                
            DebugPrint ((DBG_XFERMODE,
                         "Atapi: DEFAULT device %d transfer mode current 0x%x  and selected bitmap 0x%x\n",
                         i,
                         DeviceExtension->DeviceParameters[i].TransferModeCurrent,
                         DeviceExtension->DeviceParameters[i].TransferModeSelected));
        }
        
    } else {
    
        for (i=0; i<DeviceExtension->MaxIdeDevice; i++) {
    
            DeviceExtension->DeviceParameters[i].TransferModeSelected =
                transferModeSelect.DeviceTransferModeSelected[i];
    
            DebugPrint ((DBG_XFERMODE,
                         "Atapi: device %d transfer mode current 0x%x  and selected bitmap 0x%x\n",
                         i,
                         DeviceExtension->DeviceParameters[i].TransferModeCurrent,
                         DeviceExtension->DeviceParameters[i].TransferModeSelected));
        }                         
    }

    return;

} // AtapiSelectTransferMode


UCHAR SpecialWDDevicesFWVersion[][9] = {
    {"14.04E28"},
    {"25.26H35"},
    {"26.27J38"},
    {"27.25C38"},
    {"27.25C39"}
};
#define NUMBER_OF_SPECIAL_WD_DEVICES (sizeof(SpecialWDDevicesFWVersion) / (sizeof (UCHAR) * 9))

BOOLEAN
AtapiDMACapable (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN ULONG deviceNumber
    )
/*++

Routine Description:

    check the given device whether it is on our bad device list (non dma device)

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    deviceNumber        - device number

Return Value:

    TRUE if dma capable
    FALSE if not dma capable

--*/
{
    PHW_DEVICE_EXTENSION    deviceExtension = FdoExtension->HwDeviceExtension;
    UCHAR modelNumber[41];
    UCHAR firmwareVersion[9];
    ULONG i;
    BOOLEAN turnOffDMA = FALSE;

    //
    // Code is paged until locked down.
    //
	PAGED_CODE();

#ifdef ALLOC_PRAGMA
	ASSERT(IdePAGESCANLockCount > 0);
#endif

    if (!(deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT)) {
        return FALSE;
    }

    //
    // byte swap model number
    //
    for (i=0; i<40; i+=2) {
        modelNumber[i + 0] = deviceExtension->IdentifyData[deviceNumber].ModelNumber[i + 1];
        modelNumber[i + 1] = deviceExtension->IdentifyData[deviceNumber].ModelNumber[i + 0];
    }
    modelNumber[i] = 0;

    //
    // if we have a Western Digial device
    //     if the best dma mode is multi word dma mode 1
    //         if the identify data word offset 129 is not 0x5555
    //            turn off dma unless
    //            if the device firmware version is on the list and
    //            it is the only drive on the bus
    //
    if (3 == RtlCompareMemory(modelNumber, "WDC", 3)) {
        if ((deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported &
            (MWDMA_MODE2 | MWDMA_MODE1)) == MWDMA_MODE1) {

            for (i=0; i<8; i+=2) {
                firmwareVersion[i + 0] = deviceExtension->IdentifyData[deviceNumber].FirmwareRevision[i + 1];
                firmwareVersion[i + 1] = deviceExtension->IdentifyData[deviceNumber].FirmwareRevision[i + 0];
            }
            firmwareVersion[i] = 0;

            //
            // Check the special flag.  If not found, can't use dma
            //
            if (*(((PUSHORT)&deviceExtension->IdentifyData[deviceNumber]) + 129) != 0x5555) {

                DebugPrint ((0, "ATAPI: found mode 1 WD drive. no dma unless it is the only device\n"));

                turnOffDMA = TRUE;

                for (i=0; i<NUMBER_OF_SPECIAL_WD_DEVICES; i++) {

                    if (8 == RtlCompareMemory (firmwareVersion, SpecialWDDevicesFWVersion[i], 8)) {

                        ULONG otherDeviceNumber;

                        //
                        // 0 becomes 1
                        // 1 becomes 0
                        // 2 becomes 3
                        // 3 becomes 2
                        //
                        otherDeviceNumber = ((deviceNumber & 0x2) | ((deviceNumber & 0x1) ^ 1));

                        //
                        // if the device is alone on the bus, we can use dma
                        //
                        if (!(deviceExtension->DeviceFlags[otherDeviceNumber] & DFLAGS_DEVICE_PRESENT)) {
                            turnOffDMA = FALSE;
                            break;
                        }
                    }
                }
            }
        }
    }

    if (turnOffDMA) {
        return FALSE;
    } else {
        return TRUE;
    }
}


IDE_DEVICETYPE
AtapiDetectDevice (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN OUT PPDO_EXTENSION PdoExtension,
    IN OUT PIDENTIFY_DATA IdentifyData,
    IN     BOOLEAN          MustSucceed
    )
/**++

Routine Description:

    Detect the device at this location.
    
    1. Send "ec".
    2. if success read the Identify data and return the device type
    3. else send "a1"
    4. if success read the Identify data and return the device type
    5. else return no device
    
Arguments:
    
    FdoExtension: 
    PdoExtension:
    IdentifyData: Identify data is copied into this buffer if a device is detected.
    MustSucceed:  TRUE if pre-alloced memory is to be used.
    
Return Value:    

    device type: ATA, ATAPI or NO Device
    
--**/
{
    PATA_PASS_THROUGH       ataPassThroughData;
    UCHAR                   ataPassThroughDataBuffer[sizeof(*ataPassThroughData) + sizeof (*IdentifyData)];
    BOOLEAN                 foundIt;
    NTSTATUS                status;

    PIDE_REGISTERS_1        cmdRegBase;
    UCHAR                   statusByte1;
    LONG                    i;
    ULONG                   j;
    IDEREGS                 identifyCommand[3];

    IDE_DEVICETYPE          deviceType;
    BOOLEAN                 resetController = FALSE;

    LARGE_INTEGER           tickCount;
    ULONG                   timeDiff;
    ULONG                   timeoutValue = 0;
    ULONG                   retryCount = 0;
	BOOLEAN					defaultTimeout = FALSE;

    HANDLE                  deviceHandle;

    PAGED_CODE();

    ASSERT(FdoExtension);
    ASSERT(PdoExtension);
    ASSERT(PdoExtension->PathId == 0);
    ASSERT(PdoExtension->TargetId < FdoExtension->HwDeviceExtension->MaxIdeTargetId);

#ifdef ENABLE_ATAPI_VERIFIER
    if (ViIdeFakeMissingDevice(FdoExtension, PdoExtension->TargetId)) {

        IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                             PdoExtension->DeadmeatRecord.LineNumber
                             );

        return DeviceNotExist;
    }
#endif //ENABLE_ATAPI_VERIFIER

    ataPassThroughData = (PATA_PASS_THROUGH)ataPassThroughDataBuffer;

    foundIt = FALSE;
    cmdRegBase = &FdoExtension->HwDeviceExtension->BaseIoAddress1;

    if (FdoExtension->UserChoiceDeviceType[PdoExtension->TargetId] == DeviceNotExist) {

        deviceType = DeviceNotExist;

    } else {

        //
        // Look into the registry for last boot configration
        //
        deviceType = DeviceUnknown;
        IdePortGetDeviceParameter(
            FdoExtension,
            IdePortRegistryDeviceTypeName[PdoExtension->TargetId],
            (PULONG)&deviceType
            );

        DebugPrint((DBG_BUSSCAN, 
                    "AtapiDetectDevice - last boot config deviceType = 0x%x\n", 
                    deviceType));

        //
        // Obtain the timeout value.
        // ISSUE: should not be in the class section.
        //

/*****
   status = IoOpenDeviceRegistryKey(
                                    FdoExtension->AttacheePdo,
                                    PLUGPLAY_REGKEY_DEVICE, 
                                    KEY_QUERY_VALUE, 
                                    &deviceHandle);

   DebugPrint((0, "DetectDevice status = %x\n", status));
   ZwClose(deviceHandle);
****/

        IdePortGetDeviceParameter(
            FdoExtension,
            IdePortRegistryDeviceTimeout[PdoExtension->TargetId],
            (PULONG)&timeoutValue
            );

        //
        // if there is no registry entry use the default
        //
        if (timeoutValue == 0) {
            timeoutValue = (PdoExtension->TargetId & 0x1)==0 ? 10 : 3;
			defaultTimeout = TRUE;
        }

        //
        // Use 3s timeout for slave devices in safe boot mode. Why??
        //
        if (*InitSafeBootMode == SAFEBOOT_MINIMAL) {
            timeoutValue = (PdoExtension->TargetId & 0x1)==0 ? 10 : 3;
        }

        //
        // invalidate the last boot configuration
        // we will update it with a new setting if we
        // detect a device
        //
        IdePortSaveDeviceParameter(
            FdoExtension,
            IdePortRegistryDeviceTypeName[PdoExtension->TargetId],
            DeviceUnknown
            );

        if ((PdoExtension->TargetId == 1) && 
            (FdoExtension->MayHaveSlaveDevice == 0)) {
            deviceType = DeviceNotExist;
        } 
    }

    if (Is98LegacyIde(cmdRegBase)) {
        UCHAR               signatureLow;
        UCHAR               signatureHigh;
        UCHAR               statusByte1;

        if ((PdoExtension->TargetId & 0x1) == 1) {

            //
            // Slave device phese.
            //

            if (!EnhancedIdeSupport()) {
                //
                // Enhanced ide machine can not have the slave device.
                //

                IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                                     PdoExtension->DeadmeatRecord.LineNumber
                                     );
                return DeviceNotExist;
            }

            if (FdoExtension->HwDeviceExtension->DeviceFlags[PdoExtension->TargetId - 1] & DFLAGS_WD_MODE) {
                //
                // WD-Mode cd-rom can not has slave device.
                //
                IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                                     PdoExtension->DeadmeatRecord.LineNumber
                                     );
                return DeviceNotExist;
            }
        }

#if 0 //NEC_98
        if (deviceType == DeviceIsAtapi) {
            //
            // reset device type to determine WD-Mode or ATAPI.
            //
            deviceType = DeviceUnknown;
        }

        if (deviceType == DeviceUnknown) {

            RtlZeroMemory (ataPassThroughData, sizeof (*ataPassThroughData));
            ataPassThroughData->IdeReg.bCommandReg = IDE_COMMAND_ATAPI_RESET;
            ataPassThroughData->IdeReg.bReserved = ATA_PTFLAGS_ENUM_PROBING;

            status = IssueSyncAtaPassThroughSafe (
                         FdoExtension,
                         PdoExtension,
                         ataPassThroughData,
                         FALSE,
                         FALSE,
                         15,
                         mustSucceed
                         );
            statusByte1 = ataPassThroughData->IdeReg.bCommandReg;
            signatureLow = ataPassThroughData->IdeReg.bCylLowReg;
            signatureHigh = ataPassThroughData->IdeReg.bCylHighReg;

            if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                deviceType = DeviceIsAtapi;

            } else {

                DebugPrint((DBG_BUSSCAN, "AtapiDetectDevice - ata %x status after soft reset %x\n",PdoExtension->TargetId, statusByte1));
                if (statusByte1 & IDE_STATUS_ERROR) {

                    deviceType = DeviceIsAta;

                } else {

                    //
                    // Device is WD-Mode cd-rom.
                    //
                    deviceType = DeviceIsAtapi;
                    SETMASK (FdoExtension->HwDeviceExtension->DeviceFlags[PdoExtension->TargetId], DFLAGS_WD_MODE);
                }
            }
        }
#endif //NEC_98
    }

#if ENABLE_ATAPI_VERIFIER
    if (!Is98LegacyIde(cmdRegBase)) {
        //
        // simulate device change
        //
        if (deviceType == DeviceIsAta) {
            deviceType = DeviceIsAtapi;
        } else if (deviceType == DeviceIsAtapi) {
            deviceType = DeviceIsAta;
        }
    }
#endif 

    //
    // command to issue
    //
    RtlZeroMemory (&identifyCommand, sizeof (identifyCommand));
    if (deviceType == DeviceNotExist) {

        IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                             PdoExtension->DeadmeatRecord.LineNumber
                             );
        return DeviceNotExist;

    } else if (deviceType == DeviceIsAta) {

        identifyCommand[0].bCommandReg = IDE_COMMAND_IDENTIFY;
        identifyCommand[0].bReserved   = ATA_PTFLAGS_STATUS_DRDY_REQUIRED | ATA_PTFLAGS_ENUM_PROBING;

        identifyCommand[1].bCommandReg = IDE_COMMAND_ATAPI_IDENTIFY;
        identifyCommand[1].bReserved   = ATA_PTFLAGS_ENUM_PROBING;

    } else {

        identifyCommand[0].bCommandReg = IDE_COMMAND_ATAPI_IDENTIFY;
        identifyCommand[0].bReserved   = ATA_PTFLAGS_ENUM_PROBING;

        identifyCommand[1].bCommandReg = IDE_COMMAND_IDENTIFY;
        identifyCommand[1].bReserved   = ATA_PTFLAGS_STATUS_DRDY_REQUIRED | ATA_PTFLAGS_ENUM_PROBING;
    }
    
    //
    // IDE HACK
    //
    // If we are talking to a non-existing device, the
    // status register value may be unstable.
    // Reading it a few time seems to stablize it.
    //
    RtlZeroMemory (ataPassThroughData, sizeof (*ataPassThroughData));
    ataPassThroughData->IdeReg.bReserved = ATA_PTFLAGS_NO_OP | ATA_PTFLAGS_ENUM_PROBING;
    //
    // Repeat 10 times
    //
    ataPassThroughData->IdeReg.bSectorCountReg = 10;

    LogBusScanStartTimer(&tickCount);

    status = IssueSyncAtaPassThroughSafe (
                 FdoExtension,
                 PdoExtension,
                 ataPassThroughData,
                 FALSE,
                 FALSE,
                 3,
                 MustSucceed
                 );

    timeDiff = LogBusScanStopTimer(&tickCount);
    DebugPrint((DBG_SPECIAL,
                "DetectDevice: Hack for device %d at %x took %u ms\n",
                PdoExtension->TargetId,
                FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                timeDiff
                ));
                
    statusByte1 = ataPassThroughData->IdeReg.bCommandReg;

    if (Is98LegacyIde(cmdRegBase)) {
        UCHAR   driveHeadReg;

        driveHeadReg = ataPassThroughData->IdeReg.bDriveHeadReg;

        if (driveHeadReg != ((PdoExtension->TargetId & 0x1) << 4 | 0xA0)) {
            //
            // Bad controller.
            //

            IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                                 PdoExtension->DeadmeatRecord.LineNumber
                                 );
            IdeLogDeadMeatTaskFile( PdoExtension->DeadmeatRecord.IdeReg, 
                                    ataPassThroughData->IdeReg
                                    );

            return DeviceNotExist;
        }

        //
        // There are some H/W as follow...
        //

        if ((statusByte1 & 0xe8) == 0xa8) {

            IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                                 PdoExtension->DeadmeatRecord.LineNumber
                                 );
            IdeLogDeadMeatTaskFile( PdoExtension->DeadmeatRecord.IdeReg, 
                                    ataPassThroughData->IdeReg
                                    );
            return DeviceNotExist;
        }
    }

    if (statusByte1 == 0xff) {

        //
        // nothing here
        //

        IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                             PdoExtension->DeadmeatRecord.LineNumber
                             );
        IdeLogDeadMeatTaskFile( PdoExtension->DeadmeatRecord.IdeReg, 
                                ataPassThroughData->IdeReg
                                );
        return DeviceNotExist;
    }

    //
    // If the statusByte1 is 80 then try a reset
    //
    if (statusByte1 & IDE_STATUS_BUSY)  {

        //
        // look like it is hung, try reset to bring it back
        //
        RtlZeroMemory (ataPassThroughData, sizeof (*ataPassThroughData));
        ataPassThroughData->IdeReg.bReserved = ATA_PTFLAGS_BUS_RESET;

        LogBusScanStartTimer(&tickCount);
        status = IssueSyncAtaPassThroughSafe(
                     FdoExtension,
                     PdoExtension,
                     ataPassThroughData,
                     FALSE,
                     FALSE,
                     30,
                     MustSucceed
                     );
        timeDiff = LogBusScanStopTimer(&tickCount);
        LogBusScanTimeDiff(FdoExtension, IdePortBootTimeRegKey[0], timeDiff);
        DebugPrint((DBG_SPECIAL, 
                    "DtectDevice: Reset device %d ata %x took %u ms\n",
                    PdoExtension->TargetId,
                    FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                    timeDiff
                    ));
    }

    LogBusScanStartTimer(&tickCount);

    retryCount = 0;

    for (i=0; i<2; i++) {

        BOOLEAN ataIdentify;

        ataIdentify = identifyCommand[i].bCommandReg == IDE_COMMAND_IDENTIFY ? TRUE : FALSE;

        if (ataIdentify) {


            //
            // IDE HACK
            //
            // If we are talking to a non-existing device, the
            // status register value may be unstable.
            // Reading it a few time seems to stablize it.
            //
            RtlZeroMemory (ataPassThroughData, sizeof (*ataPassThroughData));
            ataPassThroughData->IdeReg.bReserved = ATA_PTFLAGS_NO_OP | ATA_PTFLAGS_ENUM_PROBING;
            //
            // Repeat 10 times
            //
            ataPassThroughData->IdeReg.bSectorCountReg = 10;

            status = IssueSyncAtaPassThroughSafe(
                         FdoExtension,
                         PdoExtension,
                         ataPassThroughData,
                         FALSE,
                         FALSE,
                         3,
                         MustSucceed
                         );

            statusByte1 = ataPassThroughData->IdeReg.bCommandReg;


            //
            // a real ATA device should never return this
            //
            if ((statusByte1 == 0x00) ||
                (statusByte1 == 0x01)) {

                //
                // nothing here
                //
                continue;
            }

            deviceType = DeviceIsAta;

            if (Is98LegacyIde(cmdRegBase)) {
               UCHAR               systemPortAData;

               //
               // dip-switch 2 read.
               //
               systemPortAData = IdePortInPortByte( (PUCHAR)SYSTEM_PORT_A );
               DebugPrint((DBG_BUSSCAN, "atapi:AtapiFindNewDevices - ide dip switch %x\n",systemPortAData));
               if (!(systemPortAData & 0x20)) {

                   //
                   // Internal-hd(ide) has been disabled with system-menu.
                   //
                   deviceType = DeviceNotExist;
                   break;
               }
            }

        } else {

            RtlZeroMemory (ataPassThroughData, sizeof (*ataPassThroughData));
            ataPassThroughData->IdeReg.bReserved = ATA_PTFLAGS_NO_OP | ATA_PTFLAGS_ENUM_PROBING;

            status = IssueSyncAtaPassThroughSafe (
                         FdoExtension,
                         PdoExtension,
                         ataPassThroughData,
                         FALSE,
                         FALSE,
                         3,
                         MustSucceed
                         );
            statusByte1 = ataPassThroughData->IdeReg.bCommandReg;

            deviceType = DeviceIsAtapi;
        }

        if ((statusByte1 == 0xff) ||
            (statusByte1 == 0xfe)) {

            //
            // nothing here
            //

            IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                                 PdoExtension->DeadmeatRecord.LineNumber
                                 );
            IdeLogDeadMeatTaskFile( PdoExtension->DeadmeatRecord.IdeReg, 
                                    ataPassThroughData->IdeReg
                                    );
            deviceType = DeviceNotExist;
            break;
        }

        //
        // build the ata pass through the id data command
        //
        RtlZeroMemory (ataPassThroughData, sizeof (*ataPassThroughData));
        ataPassThroughData->DataBufferSize = sizeof (*IdentifyData);
        RtlMoveMemory (&ataPassThroughData->IdeReg, identifyCommand + i, sizeof(ataPassThroughData->IdeReg));

        ASSERT(timeoutValue);
        //
        // Issue an id data command to the device
        //
        // some device (Kingston PCMCIA Datapak (non-flash)) takes a long time to response.  we
        // can possibly timeout even an device exists.
        //
        // we have to make a compromise here.  We want to detect slow devices without causing
        // many systems to boot slow.
        //
        // here is the logic:
        //
        // Since we are here (IsChannelEmpty() == FALSE), we are guessing we have at least
        // one device attached and it is a master device.  It should be ok to allow longer
        // timeout when sending ID data to the master.  We should never timeout unless
        // the channel has only a slave device.
        //
        // Yes, we will not detect slow slave device for now.  If anyone complain, we will
        // fix it.
        //
        // You can never win as long as we have broken ATA devices!
        //
        status = IssueSyncAtaPassThroughSafe (
                     FdoExtension,
                     PdoExtension,
                     ataPassThroughData,
                     TRUE,
                     FALSE,
                     timeoutValue,
                     MustSucceed
                     );
        //(PdoExtension->TargetId & 0x1)==0 ? 10 : 1,

        if (NT_SUCCESS(status)) {

            if (!(ataPassThroughData->IdeReg.bCommandReg & IDE_STATUS_ERROR)) {

                DebugPrint ((DBG_BUSSCAN, "IdePort: Found a child on 0x%x target 0x%x\n", cmdRegBase->RegistersBaseAddress, PdoExtension->TargetId));

                foundIt = TRUE;

                if (ataIdentify) {

                    IdePortFudgeAtaIdentifyData(
                        (PIDENTIFY_DATA) ataPassThroughData->DataBuffer
                        );
                }

                break;

            } else {

                DebugPrint ((DBG_BUSSCAN, "AtapiDetectDevice:Command %x,  0x%x target 0x%x failed 0x%x with status 0x%x\n",
                             i,
                             cmdRegBase->RegistersBaseAddress,
                             PdoExtension->TargetId,
                             identifyCommand[i].bCommandReg,
                             ataPassThroughData->IdeReg.bCommandReg
                             ));
            }

        } else {
            DebugPrint ((DBG_BUSSCAN, "AtapiDetectDevice:The irp with command %x,  0x%x target 0x%x failed 0x%x with status 0x%x\n",
                             i,
                             cmdRegBase->RegistersBaseAddress,
                             PdoExtension->TargetId,
                             identifyCommand[i].bCommandReg,
                             status 
                             ));

            deviceType = DeviceNotExist;

            IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                                 PdoExtension->DeadmeatRecord.LineNumber
                                 );
            IdeLogDeadMeatTaskFile( PdoExtension->DeadmeatRecord.IdeReg, 
                                    ataPassThroughData->IdeReg
                                    );

            if ((FdoExtension->HwDeviceExtension->DeviceFlags[PdoExtension->TargetId] & DFLAGS_DEVICE_PRESENT) &&
                !(FdoExtension->HwDeviceExtension->DeviceFlags[PdoExtension->TargetId] & DFLAGS_ATAPI_DEVICE) &&
                (retryCount < 2)) {

                //
                // BAD BAD BAD device
                //
                //     SAMSUNG WU32543A (2.54GB)
                //
                // when it does a few UDMA transfers, it kind of forgets
                // how to do ATA identify data so it looks like the device
                // is gone.
                //
                // we better try harder to make sure if it is really gone
                // we will do that by issuing a hard reset and try identify
                // data again.
                //

                if (identifyCommand[i].bCommandReg == IDE_COMMAND_IDENTIFY) {

                    //
                    // ask for an "inline" hard reset before issuing identify command
                    //
                    identifyCommand[i].bReserved |= ATA_PTFLAGS_INLINE_HARD_RESET;

                    //
                    // redo the last command
                    //
                    i -= 1;

                    resetController = TRUE;
                    retryCount++;
                }

            } else {

                if (status == STATUS_IO_TIMEOUT) {

                    //
                    // looks like there is no device there
					// update the registry with a low timeout value if
					// this is the slave device.
                    //
					if ((PdoExtension->TargetId & 0x1) &&
						defaultTimeout) {

						//
						// Use the timeout value of 1s for the next boot.
						//
						DebugPrint((1,
									"Updating the registry with 1s value for device %d\n",
									PdoExtension->TargetId
									));

						IdePortSaveDeviceParameter(
							FdoExtension,
							IdePortRegistryDeviceTimeout[PdoExtension->TargetId],
							1	
							);

					}
                    break;
                }
            }
        }

        //
        // try the next command
        //
    }

    timeDiff = LogBusScanStopTimer(&tickCount);
    DebugPrint((DBG_SPECIAL,
                "DetectDevice: Identify Data for device %d at %x took %u ms\n",
                PdoExtension->TargetId,
                FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                timeDiff
                ));
    //
    // save for the next boot
    //
    IdePortSaveDeviceParameter(
        FdoExtension,
        IdePortRegistryDeviceTypeName[PdoExtension->TargetId],
        deviceType == DeviceNotExist? DeviceUnknown : deviceType
        );

    if (foundIt) {

        RtlMoveMemory (IdentifyData, ataPassThroughData->DataBuffer, sizeof (*IdentifyData));

#if DBG
        {
            ULONG i;
            UCHAR string[41];

            for (i=0; i<8; i+=2) {
               string[i]     = IdentifyData->FirmwareRevision[i + 1];
               string[i + 1] = IdentifyData->FirmwareRevision[i];
            }
            string[i] = 0;
            DebugPrint((DBG_BUSSCAN, "AtapiDetectDevice: firmware version: %s\n", string));

            for (i=0; i<40; i+=2) {
               string[i]     = IdentifyData->ModelNumber[i + 1];
               string[i + 1] = IdentifyData->ModelNumber[i];
            }
            string[i] = 0;
            DebugPrint((DBG_BUSSCAN, "AtapiDetectDevice: model number: %s\n", string));

            for (i=0; i<20; i+=2) {
               string[i]     = IdentifyData->SerialNumber[i + 1];
               string[i + 1] = IdentifyData->SerialNumber[i];
            }
            string[i] = 0;
            DebugPrint((DBG_BUSSCAN, "AtapiDetectDevice: serial number: %s\n", string));
        }
#endif // DBG
    } else {

        deviceType = DeviceNotExist;
    }

    if (deviceType == DeviceNotExist) {

        IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                             PdoExtension->DeadmeatRecord.LineNumber
                             );

        IdeLogDeadMeatTaskFile( PdoExtension->DeadmeatRecord.IdeReg, 
                                ataPassThroughData->IdeReg
                                );

    }

    return deviceType;
}


NTSTATUS
IdePortSelectCHS (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN ULONG              Device,
    IN PIDENTIFY_DATA     IdentifyData
    )
{
    IN PHW_DEVICE_EXTENSION HwDeviceExtension;
    BOOLEAN                 skipSetParameters = FALSE;

    //
    // Code is paged until locked down.
    //
	PAGED_CODE();

#ifdef ALLOC_PRAGMA
	ASSERT(IdePAGESCANLockCount > 0);
#endif

    ASSERT(FdoExtension);
    ASSERT(IdentifyData);

    HwDeviceExtension = FdoExtension->HwDeviceExtension;
    ASSERT (HwDeviceExtension);
    ASSERT(Device < HwDeviceExtension->MaxIdeDevice);

    // LBA???
    // We set the LBA flag in AnalyzeDeviceCapabilities.
    //

    if (!((HwDeviceExtension->DeviceFlags[Device] & DFLAGS_DEVICE_PRESENT) &&
         (!(HwDeviceExtension->DeviceFlags[Device] & DFLAGS_ATAPI_DEVICE)))) {

        return STATUS_SUCCESS;
    }

    if (!Is98LegacyIde(&HwDeviceExtension->BaseIoAddress1) &&
        (((IdentifyData->NumberOfCurrentCylinders *
           IdentifyData->NumberOfCurrentHeads *
           IdentifyData->CurrentSectorsPerTrack) <
          (IdentifyData->NumCylinders *
           IdentifyData->NumHeads *
           IdentifyData->NumSectorsPerTrack)) ||  // discover a larger drive
          (IdentifyData->MajorRevision == 0) ||
          ((IdentifyData->NumberOfCurrentCylinders == 0) ||
           (IdentifyData->NumberOfCurrentHeads == 0) ||
           (IdentifyData->CurrentSectorsPerTrack == 0))) ) {

        HwDeviceExtension->NumberOfCylinders[Device] = IdentifyData->NumCylinders;
        HwDeviceExtension->NumberOfHeads[Device]     = IdentifyData->NumHeads;
        HwDeviceExtension->SectorsPerTrack[Device]   = IdentifyData->NumSectorsPerTrack;

    } else {

        HwDeviceExtension->NumberOfCylinders[Device] = IdentifyData->NumberOfCurrentCylinders;
        HwDeviceExtension->NumberOfHeads[Device]     = IdentifyData->NumberOfCurrentHeads;
        HwDeviceExtension->SectorsPerTrack[Device]   = IdentifyData->CurrentSectorsPerTrack;
    }

    if ((IdentifyData->NumCylinders != IdentifyData->NumberOfCurrentCylinders) ||
        (IdentifyData->NumHeads     != IdentifyData->NumberOfCurrentHeads)     ||
        (IdentifyData->NumSectorsPerTrack != IdentifyData->CurrentSectorsPerTrack)) {

        DebugPrint ((
            DBG_ALWAYS,
            "0x%x device %d current CHS (%x,%x,%x) differs from default CHS (%x,%x,%x)\n",
            HwDeviceExtension->BaseIoAddress1.RegistersBaseAddress,
            Device,
            IdentifyData->NumberOfCurrentCylinders,
            IdentifyData->NumberOfCurrentHeads,
            IdentifyData->CurrentSectorsPerTrack,
            IdentifyData->NumCylinders,
            IdentifyData->NumHeads,
            IdentifyData->NumSectorsPerTrack
            ));
    }

    //
    // This hideous hack is to deal with ESDI devices that return
    // garbage geometry in the IDENTIFY data.
    // This is ONLY for the crashdump environment as
    // these are ESDI devices.
    //

    if (HwDeviceExtension->SectorsPerTrack[Device] ==
            0x35 &&
        HwDeviceExtension->NumberOfHeads[Device] ==
            0x07) {

        DebugPrint((DBG_ALWAYS,
                   "FindDevices: Found nasty Compaq ESDI!\n"));

        //
        // Change these values to something reasonable.
        //

        HwDeviceExtension->SectorsPerTrack[Device] =
            0x34;
        HwDeviceExtension->NumberOfHeads[Device] =
            0x0E;
    }

    if (HwDeviceExtension->SectorsPerTrack[Device] ==
            0x35 &&
        HwDeviceExtension->NumberOfHeads[Device] ==
            0x0F) {

        DebugPrint((DBG_ALWAYS,
                   "FindDevices: Found nasty Compaq ESDI!\n"));

        //
        // Change these values to something reasonable.
        //

        HwDeviceExtension->SectorsPerTrack[Device] =
            0x34;
        HwDeviceExtension->NumberOfHeads[Device] =
            0x0F;
    }


    if (HwDeviceExtension->SectorsPerTrack[Device] ==
            0x36 &&
        HwDeviceExtension->NumberOfHeads[Device] ==
            0x07) {

        DebugPrint((DBG_ALWAYS,
                   "FindDevices: Found nasty UltraStor ESDI!\n"));

        //
        // Change these values to something reasonable.
        //

        HwDeviceExtension->SectorsPerTrack[Device] =
            0x3F;
        HwDeviceExtension->NumberOfHeads[Device] =
            0x10;
        skipSetParameters = TRUE;
    }

    if (Is98LegacyIde(&HwDeviceExtension->BaseIoAddress1)) {

        skipSetParameters = TRUE;
    }

    if (!skipSetParameters) {

        PIDE_REGISTERS_1 baseIoAddress1 = &HwDeviceExtension->BaseIoAddress1;
        PIDE_REGISTERS_2 baseIoAddress2 = &HwDeviceExtension->BaseIoAddress2;
        UCHAR            statusByte;

        DebugPrintTickCount (FindDeviceTimer, 0);

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

        //
        // Select the device.
        //
        SelectIdeDevice(baseIoAddress1, Device, 0);

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

        WaitOnBusy(baseIoAddress1,statusByte);

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

        if (statusByte & IDE_STATUS_BUSY) {
            ULONG  waitCount = 20000;

            DebugPrintTickCount (FindDeviceTimer, 0);

            //
            // Reset the device.
            //

            DebugPrint((2,
                        "FindDevices: Resetting controller before SetDriveParameters.\n"));

            DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

            IdeHardReset (
                baseIoAddress1,
                baseIoAddress2,
                FALSE,
                TRUE
                );

            DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

            DebugPrintTickCount (FindDeviceTimer, 0);
        }

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

        WaitOnBusy(baseIoAddress1,statusByte);

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

        DebugPrintTickCount (FindDeviceTimer, 0);

        DebugPrint((2,
                    "FindDevices: Status before SetDriveParameters: (%x) (%x)\n",
                    statusByte,
                    IdePortInPortByte (baseIoAddress1->DriveSelect)));

        //
        // Use the IDENTIFY data to set drive parameters.
        //

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

        if (!SetDriveParameters(HwDeviceExtension,Device,TRUE)) {

            DebugPrint((0,
                       "IdePortFixUpCHS: Set drive parameters for device %d failed\n",
                       Device));

            //
            // Don't use this device as writes could cause corruption.
            //

            HwDeviceExtension->DeviceFlags[Device] = 0;
        }

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IdePortScanBus (
    IN OUT PFDO_EXTENSION FdoExtension
    )
/**++

Routine Description:

    Scans the IDE bus (channel) for devices. It also configures the detected devices.
    The "safe" routines used in the procedure are not thread-safe, they use pre-allocated
    memory. The important steps in the enumeration of a channel are:
      
    1. Detect the devices on the channel
    2. Stop all the device queues
    3. Determine and set the transfer modes and the other flags
    4. Start all the device queues
    5. IssueInquiry 
    
Arguments:

    FdoExtension: Functional device extension

Return Value:

    STATUS_SUCCESS : if the operation succeeded
    Failure status : if the operation fails
    
--**/
{
    NTSTATUS                status;
    IDE_PATH_ID             pathId;
    ULONG                   target;
    ULONG                   lun;

    PPDO_EXTENSION          pdoExtension;
    PHW_DEVICE_EXTENSION    hwDeviceExtension;
    PIDEDRIVER_EXTENSION    ideDriverExtension;

    INQUIRYDATA             InquiryData;
    IDENTIFY_DATA           identifyData[MAX_IDE_TARGETID * MAX_IDE_LINE];
    ULONG                   idDatacheckSum[MAX_IDE_TARGETID * MAX_IDE_LINE];
    SPECIAL_ACTION_FLAG     specialAction[MAX_IDE_TARGETID*MAX_IDE_LINE];
    IDE_DEVICETYPE          deviceType[MAX_IDE_TARGETID * MAX_IDE_LINE];
    BOOLEAN                 mustBePio[MAX_IDE_TARGETID * MAX_IDE_LINE];
    BOOLEAN                 pioByDefault[MAX_IDE_TARGETID * MAX_IDE_LINE];
    UCHAR                   flushCommand[MAX_IDE_TARGETID * MAX_IDE_LINE];
    BOOLEAN                 removableMedia[MAX_IDE_TARGETID * MAX_IDE_LINE];
    BOOLEAN                 isLs120[MAX_IDE_TARGETID * MAX_IDE_LINE];
    BOOLEAN                 noPowerDown[MAX_IDE_TARGETID * MAX_IDE_LINE];
    BOOLEAN                 isSameDevice[MAX_IDE_TARGETID * MAX_IDE_LINE];
    ULONG                   lastKnownGoodTimingMode[MAX_IDE_TARGETID * MAX_IDE_LINE];
    ULONG                   savedTransferMode[MAX_IDE_TARGETID * MAX_IDE_LINE];
	PULONG 					enableBigLba;

    ULONG                   numSlot=0;
    ULONG                   numPdoChildren;
    UCHAR                   targetModelNum[MAX_MODELNUM_SIZE+sizeof('\0')]; //extra bytes for '\0'
    HANDLE                  pageScanCodePageHandle;
    BOOLEAN                 newPdo;
    BOOLEAN                 check4EmptyChannel;
    BOOLEAN                 emptyChannel;
    BOOLEAN                 mustSucceed=TRUE;
    KIRQL                   currentIrql;
    BOOLEAN                 inSetup;
    PULONG                  waitOnPowerUp;

    LARGE_INTEGER           tickCount;
    ULONG                   timeDiff;
    LARGE_INTEGER           totalDeviceDetectionTime;
    totalDeviceDetectionTime.QuadPart = 0;

//
// This macro is used in IdePortScanBus
//
#define RefLuExt(pdoExtension, fdoExtension, pathId, removedOk, newPdo) {\
        pdoExtension = RefLogicalUnitExtensionWithTag( \
                           fdoExtension, \
                           (UCHAR) pathId.b.Path, \
                           (UCHAR) pathId.b.TargetId, \
                           (UCHAR) pathId.b.Lun, \
                           removedOk, \
                           IdePortScanBus \
                           ); \
        if (pdoExtension == NULL) { \
            pdoExtension = AllocatePdoWithTag( \
                               fdoExtension, \
                               pathId, \
                               IdePortScanBus \
                               ); \
            newPdo = TRUE; \
        } \
}

//
// This macro is used in IdePortScanBus
//
#define UnRefLuExt(pdoExtension, fdoExtension, sync, callIoDeleteDevice, newPdo) { \
        if (newPdo) { \
            FreePdoWithTag( \
                pdoExtension, \
                sync, \
                callIoDeleteDevice, \
                IdePortScanBus \
                ); \
        } else { \
            UnrefLogicalUnitExtensionWithTag ( \
                fdoExtension, \
                pdoExtension, \
                IdePortScanBus \
                ); \
        } \
}
    //
    // Before getting in to this critical region, we must lock down
    // all the code and data because we may have stopped the paging
    // device!
    //
    // lock down all code that belongs to PAGESCAN
    //
#ifdef ALLOC_PRAGMA
    pageScanCodePageHandle = MmLockPagableCodeSection(
                                 IdePortScanBus
                                 );
	InterlockedIncrement(&IdePAGESCANLockCount);
#endif
                                 

    ASSERT(FdoExtension);
    ASSERT(FdoExtension->PreAllocEnumStruct);

    hwDeviceExtension = FdoExtension->HwDeviceExtension;

    if (FdoExtension->InterruptObject == NULL) {
        
        //
        // we are started with no irq.  it means
        // we have no children.  it is ok to poke
        // at the ports directly
        //
        if (IdePortChannelEmpty (&hwDeviceExtension->BaseIoAddress1, 
                                 &hwDeviceExtension->BaseIoAddress2, 
                                 hwDeviceExtension->MaxIdeDevice) == FALSE) {

            //
            // this channel is started with out an irq
            // it was because the channel looked empty
            // but, now it doesn't look empty.  we need
            // to restart with an irq resource
            //
            if (FdoExtension->RequestProperResourceInterface) {
                FdoExtension->RequestProperResourceInterface (FdoExtension->AttacheePdo);
            }
            else {
                DebugPrint((DBG_ALWAYS, 
                            "No interface to request resources. Probably a pcmcia parent\n"));
            }
        }
        goto done;
    }

    DebugPrint ((
        DBG_BUSSCAN,
        "IdePort: scan bus 0x%x\n",
        FdoExtension->IdeResource.TranslatedCommandBaseAddress
        ));

    inSetup = IdePortInSetup(FdoExtension);

    DebugPrint((DBG_BUSSCAN,
                "ATAPI: insetup = 0x%x\n",
                inSetup?  1: 0
                ));

    waitOnPowerUp = NULL;

    IdePortGetParameterFromServiceSubKey (
                            FdoExtension->DriverObject,
                            L"WaitOnBusyOnPowerUp",
                            REG_DWORD,
                            TRUE,
                            (PVOID) &waitOnPowerUp,
                            0
                            );

    FdoExtension->WaitOnPowerUp = PtrToUlong(waitOnPowerUp);

    check4EmptyChannel = FALSE;
    FdoExtension->DeviceChanged = FALSE;
    pathId.l = 0;
    for (target = 0; target < hwDeviceExtension->MaxIdeTargetId; target++) {

        pathId.b.TargetId = target;
        pathId.b.Lun = 0;
        newPdo = FALSE;
        mustBePio[target] = FALSE;

        RefLuExt(pdoExtension, FdoExtension, pathId, TRUE, newPdo);

        if (!newPdo && (pdoExtension->PdoState & PDOS_DEADMEAT)) {

            //
            // device marked dead already
            //
            UnrefLogicalUnitExtensionWithTag (
                FdoExtension,
                pdoExtension,
                IdePortScanBus
                );
            ASSERT (FALSE);
            pdoExtension = NULL;
        }

        if (!pdoExtension) {

            DebugPrint ((DBG_ALWAYS,
                         "ATAPI: IdePortScanBus() is unable to get pdo (%d,%d,%d)\n",
                         pathId.b.Path,
                         pathId.b.TargetId,
                         pathId.b.Lun));

            deviceType[target] = DeviceNotExist;
            continue;
        }
        
        if (!check4EmptyChannel) {

            ULONG i;
            NTSTATUS status;
            UCHAR statusByte1;
            ATA_PASS_THROUGH ataPassThroughData;

            check4EmptyChannel = TRUE;

            //
            // make sure the channel is not empty
            //
            RtlZeroMemory (&ataPassThroughData, sizeof (ataPassThroughData));
            ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_EMPTY_CHANNEL_TEST;

            LogBusScanStartTimer(&tickCount);

            status = IssueSyncAtaPassThroughSafe(
                         FdoExtension,
                         pdoExtension,
                         &ataPassThroughData,
                         FALSE,
                         FALSE,
                         30,
                         TRUE
                         );
            if (NT_SUCCESS(status)) {
                emptyChannel = TRUE;
            } else {
                emptyChannel = FALSE;
            }

            timeDiff = LogBusScanStopTimer(&tickCount);
            LogBusScanTimeDiff(FdoExtension, IdePortBootTimeRegKey[1], timeDiff);
            DebugPrint((DBG_SPECIAL,
                        "BusScan: Empty Channel check for fdoe %x took %u ms\n",
                        FdoExtension,
                        timeDiff
                        ));
        }

        LogBusScanStartTimer(&tickCount);

        if (!emptyChannel) {

            deviceType[target] = AtapiDetectDevice (FdoExtension, pdoExtension, 
                                                    identifyData + target, TRUE);
            
            if (deviceType[target] != DeviceNotExist) {

                SETMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_DEVICE_PRESENT);

                //
                // Check for special action requests for the device
                //
                GetTargetModelId((identifyData+target), targetModelNum);

                specialAction[target] = IdeFindSpecialDevice(targetModelNum, NULL);

                if (specialAction[target] == setFlagSonyMemoryStick ) {

                    ULONG i;

                    // SonyMemoryStick device.
                    SETMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_SONY_MEMORYSTICK);

                    //
                    // Truncate the hardware id, so that the size of
                    // the memory stick is not included in it.
                    //
                    for (i=strlen("MEMORYSTICK");i<sizeof((identifyData+target)->ModelNumber);i++) {
                        (identifyData+target)->ModelNumber[i+1]='\0';
                    }
                }
            }
            else {
                DebugPrint((DBG_BUSSCAN, "Didn't detect the device %d\n", target));
            }
            
        } else {

            DebugPrint((DBG_SPECIAL,
                        "BusScan: IdeDevicePresent %x detected no device %d\n",
                        FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                        target
                        ));

            //
            // invalidate the last boot configuration
            //
            IdePortSaveDeviceParameter(
                FdoExtension,
                IdePortRegistryDeviceTypeName[pdoExtension->TargetId],
                DeviceUnknown
                );

            deviceType[target] = DeviceNotExist;
        }

        ASSERT (deviceType[target] <= DeviceNotExist);


        timeDiff = LogBusScanStopTimer(&tickCount);
        LogBusScanTimeDiff(FdoExtension, IdePortBootTimeRegKey[2+target], timeDiff);
        DebugPrint((DBG_SPECIAL,
                    "BusScan: Detect device %d for %x took %u ms\n",
                    target,
                    FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                    timeDiff
                    ));
        totalDeviceDetectionTime.QuadPart += timeDiff;

        ASSERT (deviceType[target] <= DeviceNotExist);
        ASSERT (deviceType[target] != DeviceUnknown);
        ASSERT (pdoExtension->TargetId == target);

        if (deviceType[target] != DeviceNotExist) {

            if (target & 1) {

                if (deviceType[(LONG) target - 1] != DeviceNotExist) {

                    if (IdePortSlaveIsGhost (
                            FdoExtension,
                            identifyData + target - 1,
                            identifyData + target - 0)) {

                        //
                        // remove the slave device
                        //
                        deviceType[target] = DeviceNotExist;
                    }
                }
            }
        }

        ASSERT (deviceType[target] <= DeviceNotExist);
        if (deviceType[target] == DeviceNotExist) {

            CLRMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_IDENTIFY_VALID);
            if (FdoExtension->HwDeviceExtension->DeviceFlags[target] & DFLAGS_DEVICE_PRESENT) {

                IDE_PATH_ID pathId;
                PPDO_EXTENSION pdoExtension;

                //
                // device went away
                //
                FdoExtension->DeviceChanged = TRUE;

                //
                // mark all PDOs for the missing device DEADMEAT
                //
                pathId.l = 0;
                pathId.b.TargetId = target;

                while (pdoExtension = NextLogUnitExtensionWithTag(
                                          FdoExtension,
                                          &pathId,
                                          TRUE,
                                          (PVOID) (~(ULONG_PTR)IdePortScanBus)
                                          )) {

                    if (pdoExtension->TargetId == target) {

                        DebugPrint((DBG_BUSSCAN, "Enum Failed for target=%d, PDOe=0x%x\n",
                                                target, pdoExtension));

                        KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

                        SETMASK (pdoExtension->PdoState, PDOS_DEADMEAT);

                        IdeLogDeadMeatReason( pdoExtension->DeadmeatRecord.Reason,
                                              enumFailed;
                                             );

                        KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

                        UnrefPdoWithTag (pdoExtension, (PVOID) (~(ULONG_PTR)IdePortScanBus));

                    } else {

                        UnrefPdoWithTag (pdoExtension, (PVOID) (~(ULONG_PTR)IdePortScanBus));
                        break;
                    }
                }
            }

        } else {

            idDatacheckSum[target] = IdePortSimpleCheckSum (
                                         0,
                                         identifyData[target].ModelNumber,
                                         sizeof(identifyData[target].ModelNumber)
                                         );
            idDatacheckSum[target] += IdePortSimpleCheckSum (
                                         idDatacheckSum[target],
                                         identifyData[target].SerialNumber,
                                         sizeof(identifyData[target].SerialNumber)
                                         );
            idDatacheckSum[target] += IdePortSimpleCheckSum (
                                         idDatacheckSum[target],
                                         identifyData[target].FirmwareRevision,
                                         sizeof(identifyData[target].FirmwareRevision)
                                         );
            if (newPdo) {

                //
                // new device
                //
                FdoExtension->DeviceChanged = TRUE;
                DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: Found a new device. pdoe = x%x\n", pdoExtension));

            } else {

#ifdef ENABLE_ATAPI_VERIFIER
                idDatacheckSum[target] += ViIdeFakeDeviceChange(FdoExtension, target);
#endif //ENABLE_ATAPI_VERIFIER

                if (idDatacheckSum[target] != pdoExtension->IdentifyDataCheckSum) {

                    FdoExtension->DeviceChanged = TRUE;
                    DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: bad bad bad user.  a device is replaced by a different device. pdoe = x%x\n", pdoExtension));

                    //
                    // mark the old device deadmeat
                    //
                    KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

                    SETMASK (pdoExtension->PdoState, PDOS_DEADMEAT | PDOS_NEED_RESCAN);

                    IdeLogDeadMeatReason( pdoExtension->DeadmeatRecord.Reason,
                                          replacedByUser;
                                         );

                    KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

                    //
                    // pretend we have seen the new device.
                    // we will re-enum when the old one is removed.
                    //
                    deviceType[target] = DeviceNotExist;
                }
            }
        }

        ASSERT (deviceType[target] <= DeviceNotExist);
        if (deviceType[target] != DeviceNotExist) {

            ULONG savedIdDataCheckSum;

            mustBePio[target] = IdePortMustBePio (
                                    FdoExtension,
                                    identifyData + target
                                    );
            pioByDefault[target] = IdePortPioByDefaultDevice (
                                    FdoExtension,
                                    identifyData + target
                                    );

            ASSERT (deviceType[target] <= DeviceNotExist);

            LogBusScanStartTimer(&tickCount);

            flushCommand[target] = IDE_COMMAND_NO_FLUSH;

            //
            // we need this only for ata devices
            //
            if (deviceType[target] != DeviceIsAtapi) {

                flushCommand[target] = IdePortGetFlushCommand (
                                           FdoExtension,
                                           pdoExtension,
                                           identifyData + target
                                           );
            }

            timeDiff = LogBusScanStopTimer(&tickCount);
            DebugPrint((DBG_SPECIAL,
                        "BusScan: Flush command for device %d at %x took %u ms\n",
                        target,
                        FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                        timeDiff
                        ));

            ASSERT (deviceType[target] <= DeviceNotExist);

            removableMedia[target] = IdePortDeviceHasNonRemovableMedia (
                                         FdoExtension,
                                         identifyData + target
                                         );

            ASSERT (deviceType[target] <= DeviceNotExist);

            isLs120[target] = IdePortDeviceIsLs120 (
                                  FdoExtension,
                                  identifyData + target
                                  );
            ASSERT (deviceType[target] <= DeviceNotExist);

            noPowerDown[target] = IdePortNoPowerDown (
                                      FdoExtension,
                                      identifyData + target
                                      );
            ASSERT (deviceType[target] <= DeviceNotExist);


            //
            // init. the default value to an abnormal #.
            //
            FdoExtension->UserChoiceTransferMode[target] = 0x12345678;

            IdePortGetDeviceParameter(
                FdoExtension,
                IdePortRegistryUserDeviceTimingModeAllowedName[target],
                FdoExtension->UserChoiceTransferMode + target
                );

            if (FdoExtension->UserChoiceTransferMode[target] == 0x12345678) {

                //
                // This value is used to decide whether a user choice was indicated
                // or not. This helps us to set the transfer mode to a default value
                // if the user doesn't choose a particular transfer mode. Otherwise we
                // honour the user choice.
                //
                FdoExtension->UserChoiceTransferMode[target] = UNINITIALIZED_TRANSFER_MODE;

                //
                // we know the register doesn't have what we are looking for
                // set the default atapi-override setting to a value 
                // that will force pio only on atapi device
                //
                FdoExtension->UserChoiceTransferModeForAtapiDevice[target] = PIO_SUPPORT;
            } else {

                //
                // user acutally picked the transfer mode settings.
                // set the default atapi-override setting to a value (-1)
                // that will not affect the user choice.
                FdoExtension->UserChoiceTransferModeForAtapiDevice[target] = MAXULONG;
            }

            // 
            // get the previous mode
            //
            IdePortGetDeviceParameter(
                FdoExtension,
                IdePortRegistryDeviceTimingModeName[target],
                savedTransferMode+target
                );

            savedIdDataCheckSum = 0;
            IdePortGetDeviceParameter(
                FdoExtension,
                IdePortRegistryIdentifyDataChecksum[target],
                &savedIdDataCheckSum
                );

            ASSERT (deviceType[target] <= DeviceNotExist);

            //
            // figure out what transfer mode we can use
            //
            if (savedIdDataCheckSum == idDatacheckSum[target]) {

                //
                // same device. if we program the same transfer mode then
                // we can skip the DMA test
                //
                isSameDevice[target] = TRUE;

                //
                // it is the same device, use
                // the lastKnownGoodTimingMode
                // in the registry
                //
                lastKnownGoodTimingMode[target] = MAXULONG;
                IdePortGetDeviceParameter(
                    FdoExtension,
                    IdePortRegistryDeviceTimingModeAllowedName[target],
                    lastKnownGoodTimingMode + target
                    );

            } else {

                isSameDevice[target] = FALSE;
                lastKnownGoodTimingMode[target] = MAXULONG;

            }


            ASSERT (deviceType[target] <= DeviceNotExist);

            FdoExtension->TimingModeAllowed[target] =
                lastKnownGoodTimingMode[target] &
                FdoExtension->UserChoiceTransferMode[target];
                              
            //
            // TransferModeMask is initially 0.
            //
            FdoExtension->TimingModeAllowed[target] &= ~(hwDeviceExtension->
                                                         DeviceParameters[target].TransferModeMask);

            if (pdoExtension->CrcErrorCount >= PDO_UDMA_CRC_ERROR_LIMIT)  {

                //
                //Reset the error count
                //
                pdoExtension->CrcErrorCount =0;
            }

            DebugPrint ((DBG_XFERMODE, "TMAllowed=%x, TMMask=%x, UserChoice=%x\n",
                         FdoExtension->TimingModeAllowed[target],
                         hwDeviceExtension->DeviceParameters[target].TransferModeMask,
                         FdoExtension->UserChoiceTransferMode[target]));

            ASSERT (deviceType[target] <= DeviceNotExist);
        }

        UnRefLuExt(pdoExtension, FdoExtension, TRUE, TRUE, newPdo);

        pdoExtension = NULL;
    }


#ifdef IDE_MEASURE_BUSSCAN_SPEED
    if (FdoExtension->BusScanTime == 0) {

        FdoExtension->BusScanTime = totalDeviceDetectionTime.LowPart;
    }
#endif // IDE_MEASURE_BUSSCAN_SPEED

#ifdef ENABLE_48BIT_LBA

    //
    // Enable big lba support by default
    //
	FdoExtension->EnableBigLba = 1;
#endif

//    if (!deviceChanged && !DBG) {
//
//        //
//        // didn't find anything different than before
//        //
//        return STATUS_SUCCESS;
//    }

    DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: detect a change of device...re-initializing\n"));


    // ISSUE: check if device got removed!!!

    //
    // Begin of a critial region
    // must stop all children, do the stuff, and restart all children
    //

    //
    // cycle through all children and stop their device queue
    //

    LogBusScanStartTimer(&tickCount);

    pathId.l = 0;
    numPdoChildren = 0;
    status = STATUS_SUCCESS;
    while (pdoExtension = NextLogUnitExtensionWithTag(
                              FdoExtension,
                              &pathId,
                              TRUE,
                              IdePortScanBus
                              )) {

        DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: stopping pdo 0x%x\n", pdoExtension));

        status = DeviceStopDeviceQueueSafe (pdoExtension, PDOS_QUEUE_FROZEN_BY_PARENT, TRUE);

        DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: stopped pdo 0x%x\n", pdoExtension));

        UnrefLogicalUnitExtensionWithTag (
            FdoExtension,
            pdoExtension,
            IdePortScanBus
            );
        numPdoChildren++;

        if (!NT_SUCCESS(status)) {
            break;
        }
    }

    if (NT_SUCCESS(status)) {

        BOOLEAN foundAtLeastOneIdeDevice = FALSE;
        BOOLEAN useDma;
        IDE_PATH_ID pathId;

        DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: all children are stoped\n"));

        pathId.l = 0;
        for (target = 0; target < hwDeviceExtension->MaxIdeTargetId; target++) {

            ASSERT (deviceType[target] <= DeviceNotExist);
            if (deviceType[target] != DeviceNotExist) {

                pathId.b.TargetId = target;

                newPdo = FALSE;

                RefLuExt(pdoExtension, FdoExtension, pathId, TRUE, newPdo);

                if (!pdoExtension) {
                    continue;
                }
                ASSERT (pdoExtension);

                foundAtLeastOneIdeDevice = TRUE;

                SETMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_DEVICE_PRESENT);

                if (deviceType[target] == DeviceIsAtapi) {

                    SETMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_ATAPI_DEVICE);

                    useDma=FALSE;

                    //
                    // skip the dvd test, if ModeSense command is not to be
                    // sent to the device or if we are in setup
                    //
                    if (inSetup) {

                        mustBePio[target] = TRUE;

                    } else if ((specialAction[target] != skipModeSense) &&
                               (!pioByDefault[target])) {

                        useDma = IdePortDmaCdromDrive(FdoExtension,
                                                pdoExtension,
                                                TRUE
                                                );
                    }

					//
					// Don't force PIO if we have seen this before. If it was doing PIO
					// TimingModeAllowed would reflect that. 
					// Set UserChoiceForAtapi to 0xffffffff
					// This won't anyway affect the user choice
					//
                    if ( useDma) {

                        DebugPrint((DBG_BUSSCAN, 
                                    "IdePortScanBus: USE DMA FOR target %d\n",
                                    target
                                    ));

                        FdoExtension->UserChoiceTransferModeForAtapiDevice[target] = MAXULONG;

                    }


                    FdoExtension->TimingModeAllowed[target] &= 
                        FdoExtension->UserChoiceTransferModeForAtapiDevice[target];


                }

                //
                // allow LS-120 Format Command
                //
                if (isLs120[target]) {

                    SETMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_LS120_FORMAT);
                }

                RtlMoveMemory (
                    hwDeviceExtension->IdentifyData + target,
                    identifyData + target,
                    sizeof (IDENTIFY_DATA)
                    );

                //
                // Always re-use identify data
                // This will get cleared if it is a removable media
                // The queue is stopped. Now I can safely set this flag.
                //
                SETMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_IDENTIFY_VALID);

                DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: Calling InitHwExtWithIdentify\n"));

                //
                // IdentifyValid flag should be cleared, if it is a removable media
                //
                InitHwExtWithIdentify(
                    hwDeviceExtension,
                    target,
                    (UCHAR) (deviceType[target] == DeviceIsAtapi ? IDE_COMMAND_ATAPI_IDENTIFY : IDE_COMMAND_IDENTIFY),
                    hwDeviceExtension->IdentifyData + target,
                    removableMedia[target]
                    );

                DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: Calling IdePortSelectCHS\n"));

                IdePortSelectCHS (
                    FdoExtension,
                    target,
                    identifyData + target
                    );

                DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: back from IdePortSelectCHS\n"));

                UnRefLuExt(pdoExtension, FdoExtension, TRUE, TRUE, newPdo);

            } else {

                hwDeviceExtension->DeviceFlags[target] = 0;
            }
        }

        if (foundAtLeastOneIdeDevice) {

            DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: Calling AnalyzeDeviceCapabilities\n"));

            //
            // could move this out of the critial region
            //
            AnalyzeDeviceCapabilities (
                FdoExtension,
                mustBePio
                );

            DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: Calling AtapiSelectTransferMode\n"));

			//
            // could move this out of the critial region
            //
            AtapiSyncSelectTransferMode (
                FdoExtension,
                hwDeviceExtension,
                FdoExtension->TimingModeAllowed
                );

            DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: Calling AtapiHwInitialize\n"));

            AtapiHwInitialize (
                FdoExtension->HwDeviceExtension,
                flushCommand
                );
        }

    } else {

        //
        // unable to stop all children, so force an buscheck to try again
        //
//        IoInvalidateDeviceRelations (
//            FdoExtension->AttacheePdo,
//            BusRelations
//            );
    }


    //
    // cycle through all children and restart their device queue
    //
    pathId.l = 0;
    numPdoChildren = 0;
    while (pdoExtension = NextLogUnitExtensionWithTag(
                              FdoExtension,
                              &pathId,
                              TRUE,
                              IdePortScanBus
                              )) {

        DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: re-start pdo 0x%x\n", pdoExtension));

        DeviceStartDeviceQueue (pdoExtension, PDOS_QUEUE_FROZEN_BY_PARENT);

        UnrefLogicalUnitExtensionWithTag (
            FdoExtension,
            pdoExtension,
            IdePortScanBus
            );
        numPdoChildren++;
    }

    timeDiff = LogBusScanStopTimer(&tickCount);
    LogBusScanTimeDiff(FdoExtension, IdePortBootTimeRegKey[4], timeDiff);
    DebugPrint((DBG_SPECIAL,
                "BusScan : Critical section %x took %u ms\n",
                FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                timeDiff
                ));

    if (NT_SUCCESS(status)) {

        //
        // second stage scanning
        //
        pathId.l = 0;

        LogBusScanStartTimer(&tickCount);

        for (target = 0; target < hwDeviceExtension->MaxIdeTargetId; target++) {

            if (deviceType[target] == DeviceNotExist) {

                continue;
            }

            pathId.b.TargetId = target;

            for (lun = 0; lun < FdoExtension->MaxLuCount; lun++) {

                LARGE_INTEGER  tempTickCount;
                pathId.b.Lun = lun;
                newPdo = FALSE;

                RefLuExt(pdoExtension, FdoExtension, pathId, TRUE, newPdo);

                if (!pdoExtension) {
                    continue;
                }

                ASSERT (pdoExtension);

                if (lun == 0) {

#if defined (ALWAYS_VERIFY_DMA)
#undef ALWAYS_VERIFY_DMA
#define ALWAYS_VERIFY_DMA TRUE
#else
#define ALWAYS_VERIFY_DMA FALSE
#endif

                    ASSERT (ALL_MODE_SUPPORT != MAXULONG);
                    if ((FdoExtension->HwDeviceExtension->
                            DeviceParameters[target].TransferModeSelected & DMA_SUPPORT) ||
                        ALWAYS_VERIFY_DMA) {

                        ULONG mode = FdoExtension->HwDeviceExtension->
                            DeviceParameters[target].TransferModeSelected;
                        //
                        // if lastKnownGoodTimingMode is MAX_ULONG, it means
                        // we have never seen this device before and the user
                        // hasn't said anything about what dma mode to use.
                        //
                        // we have chosen to use dma because all the software
                        // detectable parameters (identify dma, pci config data)
                        // looks good for DMA.
                        //
                        // the only thing that can stop us from using DMA now
                        // is bad device.  before we go on, do a little test
                        // to verify dma is ok

                        //
                        // could re-use the inquiry data obtained here.
                        //
                        //
                        // skip the test if we have already seen the device
                        //

                        LogBusScanStartTimer(&tempTickCount);
                        if (isSameDevice[target] &&
                            mode == savedTransferMode[target]) { 

                            DebugPrint((DBG_BUSSCAN, 
                                        "Skip dma test for %d\n", target));

                        } else {

                            IdePortVerifyDma (
                                pdoExtension,
                                deviceType[target]
                                );
                        }
                        timeDiff = LogBusScanStopTimer(&tempTickCount);
                        DebugPrint((DBG_SPECIAL,
                                    "ScanBus: VerifyDma for %x device %d took %u ms\n",
                                    FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                                    target,
                                    timeDiff
                                    ));


                    }

                    //
                    // Initialize numSlot to 0
                    //
                    numSlot=0;

                    //
                    // If this is in the bad cd-rom drive list, then don't
                    // send these Mode Sense command. The drive might lock up.
                    //
                    LogBusScanStartTimer(&tempTickCount);
                    if (specialAction[target] != skipModeSense) {
                        //
                        // Non-CD device
                        //
                        numSlot = IdePortQueryNonCdNumLun (
                                          FdoExtension,
                                          pdoExtension,
                                          FALSE
                                          );
                    } else {
                        DebugPrint((DBG_BUSSCAN, "Skip modesense\n"));
                    }

                    timeDiff = LogBusScanStopTimer(&tempTickCount);
                    DebugPrint((DBG_SPECIAL,
                                "ScanBus: Initialize Luns for %x device %d took %u ms\n",
                                FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                                target,
                                timeDiff
                                ));

                    AtapiHwInitializeMultiLun (
                        FdoExtension->HwDeviceExtension,
                        pdoExtension->TargetId,
                        numSlot
                        );
                }

                if (pdoExtension) {

                    LogBusScanStartTimer(&tempTickCount);
                    status = IssueInquirySafe(FdoExtension, pdoExtension, &InquiryData, TRUE);
                    timeDiff = LogBusScanStopTimer(&tempTickCount);
                    DebugPrint((DBG_SPECIAL,
                                "ScanBus: Inquiry %x for  Lun  %d device %d took %u ms\n",
                                FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                                lun,
                                target,
                                timeDiff
                                ));

                    if (NT_SUCCESS(status) || (status == STATUS_DATA_OVERRUN)) {

                        DeviceInitDeviceType (
                            pdoExtension,
                            &InquiryData
                            );

                        //
                        // Init Ids String for PnP Query ID
                        //
                        DeviceInitIdStrings (
                            pdoExtension,
                            deviceType[target],
                            &InquiryData,
                            identifyData + target
                            );

                        //
                        // Clear rescan flag. Since this LogicalUnit will not be freed,
                        // the IOCTL_SCSI_MINIPORT requests can safely attach.
                        //
                        CLRMASK (pdoExtension->LuFlags, PD_RESCAN_ACTIVE);

                        DebugPrint((DBG_BUSSCAN,"IdePortScanBus: Found device at "));
                        DebugPrint((DBG_BUSSCAN,"   Bus         %d", pdoExtension->PathId));
                        DebugPrint((DBG_BUSSCAN,"   Target Id   %d", pdoExtension->TargetId));
                        DebugPrint((DBG_BUSSCAN,"   LUN         %d\n", pdoExtension->Lun));

                        if (noPowerDown[target] ||
                            (pdoExtension->ScsiDeviceType == READ_ONLY_DIRECT_ACCESS_DEVICE)) {

                            KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

                            SETMASK (pdoExtension->PdoState, PDOS_NO_POWER_DOWN);

                            KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);
                        }

                        pdoExtension->IdentifyDataCheckSum = idDatacheckSum[target];

                        //
                        // done using the current logical unit extension
                        //
                        UnrefLogicalUnitExtensionWithTag (
                            FdoExtension,
                            pdoExtension,
                            IdePortScanBus
                            );

                        pdoExtension = NULL;
                    }

                } else {

                    ASSERT (pdoExtension);

                    DebugPrint ((DBG_ALWAYS, "IdePort: unable to create new pdo\n"));
                }

                if (pdoExtension) {

                    if (!newPdo) {

                        DebugPrint((DBG_BUSSCAN, "IdePortScanBus: pdoe 0x%x is missing.  (physically removed)\n", pdoExtension));
                    }

                    //
                    // get the pdo states
                    //
                    KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

                    SETMASK (pdoExtension->PdoState, PDOS_DEADMEAT);

                    KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);


                    UnRefLuExt(pdoExtension, FdoExtension, TRUE, TRUE, newPdo);

                    pdoExtension = NULL;
                }
            }
        }

        //
        // Get all PDOs ready
        //
        pathId.l = 0;
        while (pdoExtension = NextLogUnitExtensionWithTag(
                                  FdoExtension,
                                  &pathId,
                                  FALSE,
                                  IdePortScanBus
                                  )) {

            //
            // PO Idle Timer
            //
            DeviceRegisterIdleDetection (
                pdoExtension,
                DEVICE_DEFAULT_IDLE_TIMEOUT,
                DEVICE_DEFAULT_IDLE_TIMEOUT
                );

            CLRMASK (pdoExtension->DeviceObject->Flags, DO_DEVICE_INITIALIZING);

            UnrefLogicalUnitExtensionWithTag (
                FdoExtension,
                pdoExtension,
                IdePortScanBus
                );
        }

        //
        // Update the device map.
        //
        ideDriverExtension = IoGetDriverObjectExtension(
                                 FdoExtension->DriverObject,
                                 DRIVER_OBJECT_EXTENSION_ID
                                 );
        IdeBuildDeviceMap(FdoExtension, &ideDriverExtension->RegistryPath);
    }

    timeDiff = LogBusScanStopTimer(&tickCount);
    LogBusScanTimeDiff(FdoExtension, IdePortBootTimeRegKey[5], timeDiff);
    DebugPrint((DBG_SPECIAL,
                "BusScan: Last Stage scanning for %x took %u ms\n",
                FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                timeDiff
                ));
    //
    // save current transfer mode setting in the registry
    //
    for (target = 0; target < hwDeviceExtension->MaxIdeTargetId; target++) {

        ULONG mode;

        pdoExtension = RefLogicalUnitExtensionWithTag(
                           FdoExtension,
                           0,
                           (UCHAR) target,
                           0,
                           TRUE,
                           IdePortScanBus
                           );

        if (pdoExtension) {

            mode = FdoExtension->HwDeviceExtension->DeviceParameters[target].TransferModeSelected;

            if (pdoExtension->DmaTransferTimeoutCount >= PDO_DMA_TIMEOUT_LIMIT) {
            
                mode &= PIO_SUPPORT;
                lastKnownGoodTimingMode[target] &= PIO_SUPPORT;
            }

            UnrefLogicalUnitExtensionWithTag (
                FdoExtension,
                pdoExtension,
                IdePortScanBus
                );

            IdePortSaveDeviceParameter(
                FdoExtension,
                IdePortRegistryDeviceTimingModeName[target],
                mode
                );

            IdePortSaveDeviceParameter(
                FdoExtension,
                IdePortRegistryDeviceTimingModeAllowedName[target],
                lastKnownGoodTimingMode[target]
                );

            IdePortSaveDeviceParameter(
                FdoExtension,
                IdePortRegistryIdentifyDataChecksum[target],
                idDatacheckSum[target]
                );

        } else {

            IdePortSaveDeviceParameter(
                FdoExtension,
                IdePortRegistryDeviceTimingModeName[target],
                0
                );
        }
    }

done:
    //
    // unlock BUSSCAN code pages
    //
#ifdef ALLOC_PRAGMA
    InterlockedDecrement(&IdePAGESCANLockCount);
    MmUnlockPagableImageSection(
        pageScanCodePageHandle
        );
#endif
    
    return STATUS_SUCCESS;
}


BOOLEAN
IdePreAllocEnumStructs (
    IN PFDO_EXTENSION FdoExtension
)
/**++

Routine Description:

    Pre-Allocates Memory for structures used during enumertion. This is not protected by a lock.
    Thus if multiple threads cannot use the structures at the same time. Any routine using these
    structures should be aware of this fact.

Arguments:

    FdoExtension : Functional Device Extension    
    
Return Value:

    TRUE: if allocations succeeded.
    FALSE: if any of the allocations failed    

--**/
{
    PENUMERATION_STRUCT enumStruct;
    PIRP irp1;
    ULONG deviceRelationsSize;
    PULONG DataBuffer;
    ULONG currsize=0;
    PIDE_WORK_ITEM_CONTEXT          workItemContext;

	PAGED_CODE();

    //
    // Lock
    //
    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 1, 0) == 0);

    if (FdoExtension->PreAllocEnumStruct) {

        //
        // Unlock
        //
        ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 0, 1) == 1);
        return TRUE;
    }

    enumStruct = ExAllocatePool(NonPagedPool, sizeof(ENUMERATION_STRUCT));
    if (enumStruct == NULL) {

        //
        // Unlock
        //
        ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 0, 1) == 1);
        ASSERT(FdoExtension->EnumStructLock == 0);
        return FALSE;
    }
    currsize += sizeof(ENUMERATION_STRUCT);
    
    RtlZeroMemory(enumStruct, sizeof(ENUMERATION_STRUCT));

    //
    // Allocate ATaPassThru context
    //
    enumStruct->Context = ExAllocatePool(NonPagedPool, sizeof (ATA_PASSTHROUGH_CONTEXT));
    if (enumStruct->Context == NULL) {
        goto getout;
    }

    currsize += sizeof(ATA_PASSTHROUGH_CONTEXT);

	//
	// Allocate the WorkItemContext for the enumeration
	//
	ASSERT(enumStruct->EnumWorkItemContext == NULL);

	enumStruct->EnumWorkItemContext = ExAllocatePool (NonPagedPool, 
											 sizeof(IDE_WORK_ITEM_CONTEXT)
											 );
	if (enumStruct->EnumWorkItemContext == NULL) {
		goto getout;
	}

    currsize += sizeof(IDE_WORK_ITEM_CONTEXT);

	//
	// Allocate the WorkItem
	//
	workItemContext = (PIDE_WORK_ITEM_CONTEXT) (enumStruct->EnumWorkItemContext);
	workItemContext->WorkItem = IoAllocateWorkItem(FdoExtension->DeviceObject);

	if (workItemContext->WorkItem == NULL) {
		goto getout;
	}

    //
    // StopQueu Context, used to stop the device queue
    //
    enumStruct->StopQContext = ExAllocatePool(NonPagedPool, sizeof (PDO_STOP_QUEUE_CONTEXT));
    if (enumStruct->StopQContext == NULL) {
        goto getout;
    }

    currsize += sizeof(PDO_STOP_QUEUE_CONTEXT);

    //
    // Sense Info buffer
    //
    enumStruct->SenseInfoBuffer = ExAllocatePool( NonPagedPoolCacheAligned, SENSE_BUFFER_SIZE);
    if (enumStruct->SenseInfoBuffer == NULL) {
        goto getout;
    }

    currsize += SENSE_BUFFER_SIZE;

    //
    // Srb to send pass thru requests
    //
    enumStruct->Srb = ExAllocatePool (NonPagedPool, sizeof (SCSI_REQUEST_BLOCK));
    if (enumStruct->Srb == NULL) {
        goto getout;
    }

    currsize += sizeof(SCSI_REQUEST_BLOCK);

    //
    // irp for pass thru requests
    //
    irp1 = IoAllocateIrp (
              (CCHAR) (PREALLOC_STACK_LOCATIONS),
              FALSE
              );

    if (irp1 == NULL) {
        goto getout;
    }

    enumStruct->Irp1 = irp1;

    //
    // Data buffer to hold inquiry data or Identify data
    //
    enumStruct->DataBufferSize = sizeof(ATA_PASS_THROUGH)+INQUIRYDATABUFFERSIZE+
                                        sizeof(IDENTIFY_DATA);

    currsize += enumStruct->DataBufferSize;

    DataBuffer = ExAllocatePool(NonPagedPoolCacheAligned, 
                                enumStruct->DataBufferSize);

    if (DataBuffer == NULL) {
        enumStruct->DataBufferSize=0;
        goto getout;
    }

    enumStruct->DataBuffer = DataBuffer;

    enumStruct->MdlAddress = IoAllocateMdl( DataBuffer,
                                     enumStruct->DataBufferSize,
                                     FALSE,
                                     FALSE,
                                     (PIRP) NULL );
    if (enumStruct->MdlAddress == NULL) {
        goto getout;
    }

    MmBuildMdlForNonPagedPool(enumStruct->MdlAddress);

    FdoExtension->PreAllocEnumStruct=enumStruct;

    DebugPrint((DBG_BUSSCAN, "BusScan: TOTAL PRE_ALLOCED MEM=%x\n", currsize));

    //
    // Unlock
    //
    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 0, 1) == 1);

    return TRUE;

getout:

    //
    // Some allocations failed. Free the already allocated ones.
    //
    IdeFreeEnumStructs(enumStruct);

    FdoExtension->PreAllocEnumStruct=NULL;

    //
    // Unlock
    //
    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 0, 1) == 1);
    ASSERT(FALSE);
    return FALSE;
}

VOID
IdeFreeEnumStructs(
    PENUMERATION_STRUCT enumStruct
    )
/**++

Routine Description:

    Frees the pre-allocated memory.
    
Arguments
    
    Pointer to the Enumeration Structure that is to be freed
    
Return Value:

    None        
--**/
{
	PAGED_CODE();

    if (enumStruct != NULL) { 
        if (enumStruct->Context) {
            ExFreePool (enumStruct->Context);
        }

        if (enumStruct->SenseInfoBuffer) {
            ExFreePool (enumStruct->SenseInfoBuffer);
        }

        if (enumStruct->Srb) {
            ExFreePool(enumStruct->Srb);
        }

        if (enumStruct->StopQContext) {
            ExFreePool(enumStruct->StopQContext);
        }

        if (enumStruct->DataBuffer) {
            ExFreePool(enumStruct->DataBuffer);
        }

        if (enumStruct->Irp1) {
            IoFreeIrp(enumStruct->Irp1);
        }

        if (enumStruct->MdlAddress) {
            ExFreePool(enumStruct->MdlAddress);
        }

		if (enumStruct->EnumWorkItemContext) {
			PIDE_WORK_ITEM_CONTEXT	workItemContext = (PIDE_WORK_ITEM_CONTEXT)enumStruct->
																					EnumWorkItemContext;
			if (workItemContext->WorkItem) {
				IoFreeWorkItem(workItemContext->WorkItem);
			}

			ExFreePool (enumStruct->EnumWorkItemContext);
		}

        ExFreePool(enumStruct);
        enumStruct = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\chanfdo.c ===
/*++

Copyright (C) 1993-99  Microsoft Corporation

Module Name:

    chanfdo.c

Abstract:

--*/

#include "ideport.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ChannelAddDevice)
#pragma alloc_text(PAGE, ChannelAddChannel)
#pragma alloc_text(PAGE, ChannelStartDevice)
#pragma alloc_text(PAGE, ChannelStartChannel)
#pragma alloc_text(PAGE, ChannelCreateSymblicLinks)
#pragma alloc_text(PAGE, ChannelDeleteSymblicLinks)
#pragma alloc_text(PAGE, ChannelRemoveDevice)
#pragma alloc_text(PAGE, ChannelSurpriseRemoveDevice)
#pragma alloc_text(PAGE, ChannelStopDevice)
#pragma alloc_text(PAGE, ChannelRemoveChannel)
#pragma alloc_text(PAGE, ChannelQueryDeviceRelations)
#pragma alloc_text(PAGE, ChannelQueryBusRelation)
#pragma alloc_text(PAGE, ChannelQueryId)
#pragma alloc_text(PAGE, ChannelUsageNotification)
#pragma alloc_text(PAGE, DigestResourceList)
#pragma alloc_text(PAGE, ChannelQueryBusMasterInterface)
#pragma alloc_text(PAGE, ChannelQueryTransferModeInterface)
#pragma alloc_text(PAGE, ChannelUnbindBusMasterParent)
#pragma alloc_text(PAGE, ChannelQuerySyncAccessInterface)
#pragma alloc_text(PAGE, ChannelEnableInterrupt)
#pragma alloc_text(PAGE, ChannelDisableInterrupt)
#pragma alloc_text(PAGE, ChannelFilterResourceRequirements)
#pragma alloc_text(PAGE, ChannelQueryPnPDeviceState)
#pragma alloc_text(PAGE, ChannelQueryPcmciaParent)

#ifdef IDE_FILTER_PROMISE_TECH_RESOURCES
#pragma alloc_text(PAGE, ChannelFilterPromiseTechResourceRequirements)
#endif // IDE_FILTER_PROMISE_TECH_RESOURCES

#pragma alloc_text(NONPAGE, ChannelDeviceIoControl)
#pragma alloc_text(NONPAGE, ChannelRemoveDeviceCompletionRoutine)
#pragma alloc_text(NONPAGE, ChannelQueryIdCompletionRoutine)
#pragma alloc_text(NONPAGE, ChannelUsageNotificationCompletionRoutine)
#pragma alloc_text(NONPAGE, ChannelAcpiTransferModeSelect)
#pragma alloc_text(NONPAGE, ChannelRestoreTiming)
#pragma alloc_text(NONPAGE, ChannelStartDeviceCompletionRoutine)

#endif // ALLOC_PRAGMA


static ULONG AtapiNextIdePortNumber = 0;

NTSTATUS
ChannelAddDevice(
    IN  PDRIVER_OBJECT DriverObject,
    IN  PDEVICE_OBJECT PhysicalDeviceObject
    )
{
    PFDO_EXTENSION fdoExtension;

    return ChannelAddChannel(DriverObject,
                             PhysicalDeviceObject,
                             &fdoExtension);
}


NTSTATUS
ChannelAddChannel(
    IN  PDRIVER_OBJECT DriverObject,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PFDO_EXTENSION *FdoExtension
    )
{
    PDEVICE_OBJECT functionalDeviceObject;
    PFDO_EXTENSION fdoExtension;
    PPDO_EXTENSION pdoExtension;
    PDEVICE_OBJECT childDeviceObject;
    ULONG          deviceExtensionSize;
    NTSTATUS status;

    UNICODE_STRING  deviceName;
    WCHAR           deviceNameBuffer[64];

    PAGED_CODE();

    swprintf(deviceNameBuffer, DEVICE_OJBECT_BASE_NAME L"\\IdePort%d", AtapiNextIdePortNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    //
    // We've been given the PhysicalDeviceObject for a IDE controller.  Create the
    // FunctionalDeviceObject.  Our FDO will be nameless.
    //

    deviceExtensionSize = sizeof(FDO_EXTENSION) + sizeof(HW_DEVICE_EXTENSION);

    status = IoCreateDevice(
                 DriverObject,               // our driver object
                 deviceExtensionSize,        // size of our extension
                 &deviceName,                // our name
                 FILE_DEVICE_CONTROLLER,     // device type
                 FILE_DEVICE_SECURE_OPEN,    // device characteristics
                 FALSE,                      // not exclusive
                 &functionalDeviceObject     // store new device object here
                 );

    if( !NT_SUCCESS( status )){

        return status;
    }

    fdoExtension = (PFDO_EXTENSION)functionalDeviceObject->DeviceExtension;
    RtlZeroMemory (fdoExtension, deviceExtensionSize);


    fdoExtension->HwDeviceExtension = (PVOID)(fdoExtension + 1);

    //
    // We have our FunctionalDeviceObject, initialize it.
    //

    fdoExtension->AttacheePdo              = PhysicalDeviceObject;
    fdoExtension->DriverObject             = DriverObject;
    fdoExtension->DeviceObject             = functionalDeviceObject;

    // Dispatch Table
    fdoExtension->DefaultDispatch          = IdePortPassDownToNextDriver;
    fdoExtension->PnPDispatchTable         = FdoPnpDispatchTable;
    fdoExtension->PowerDispatchTable       = FdoPowerDispatchTable;
    fdoExtension->WmiDispatchTable         = FdoWmiDispatchTable;

    //
    // Now attach to the PDO we were given.
    //
    fdoExtension->AttacheeDeviceObject = IoAttachDeviceToDeviceStack (
                                              functionalDeviceObject,
                                              PhysicalDeviceObject
                                              );
    if (fdoExtension->AttacheeDeviceObject == NULL) {

        //
        // Couldn't attach.  Delete the FDO.
        //

        IoDeleteDevice (functionalDeviceObject);
		status = STATUS_UNSUCCESSFUL;

    } else {

        //
        // fix up alignment requirement
        //
        functionalDeviceObject->AlignmentRequirement = fdoExtension->AttacheeDeviceObject->AlignmentRequirement;
        if (functionalDeviceObject->AlignmentRequirement < 1) {
            functionalDeviceObject->AlignmentRequirement = 1;
        }

        fdoExtension->IdePortNumber = AtapiNextIdePortNumber;
        AtapiNextIdePortNumber++;

        *FdoExtension = fdoExtension;

        CLRMASK (functionalDeviceObject->Flags, DO_DEVICE_INITIALIZING);
    }

    DebugPrint((DBG_PNP, "DeviceObject %x returnd status %x from Addevice\n", 
                PhysicalDeviceObject, status));

    return status;
}

NTSTATUS
ChannelStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION              thisIrpSp;
    NTSTATUS                        status;
    PFDO_EXTENSION                  fdoExtension;
    PCM_RESOURCE_LIST               resourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    ULONG                           resourceListSize;
    ULONG                           i;
    PCM_RESOURCE_LIST               resourceListForKeep = NULL;
    PIRP                            newIrp;
    KEVENT                          event;
    IO_STATUS_BLOCK                 ioStatusBlock;

    ULONG                           parentResourceListSize;
    PCM_RESOURCE_LIST               parentResourceList = NULL;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;

    ASSERT (!(fdoExtension->FdoState & FDOS_STARTED));

    resourceList     = thisIrpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

    //
    // TEMP CODE for the time without a real PCI driver.
    //
    resourceListSize = 0;

    if (resourceList) {

        fullResourceList = resourceList->List;

        for (i=0; i<resourceList->Count; i++) {

            ULONG partialResourceListSize;

            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = partialResourceList->PartialDescriptors;

            partialResourceListSize = 0;
            for (i=0; i<partialResourceList->Count; i++) {

                partialResourceListSize += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

                if (partialDescriptors[i].Type == CmResourceTypeDeviceSpecific) {

                    partialResourceListSize += partialDescriptors[i].u.DeviceSpecificData.DataSize;
                }
            }

            resourceListSize += partialResourceListSize +
                                FIELD_OFFSET (CM_FULL_RESOURCE_DESCRIPTOR, PartialResourceList.PartialDescriptors);

            fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (((UCHAR *) fullResourceList) + resourceListSize);
        }
        resourceListSize += FIELD_OFFSET (CM_RESOURCE_LIST, List);
    }

    parentResourceListSize = sizeof (CM_RESOURCE_LIST) - sizeof (CM_FULL_RESOURCE_DESCRIPTOR) +
                             FULL_RESOURCE_LIST_SIZE(3);   // primary IO (2) + IRQ
    parentResourceList = ExAllocatePool (PagedPool, parentResourceListSize);

    if (!parentResourceList) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    RtlZeroMemory (parentResourceList, parentResourceListSize);

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    newIrp = IoBuildDeviceIoControlRequest (
                 IOCTL_IDE_GET_RESOURCES_ALLOCATED,
                 fdoExtension->AttacheeDeviceObject,
                 parentResourceList,
                 parentResourceListSize,
                 parentResourceList,
                 parentResourceListSize,
                 TRUE,
                 &event,
                 &ioStatusBlock);

    if (newIrp == NULL) {

        DebugPrint ((0, "Unable to allocate irp to bind with busmaster parent\n"));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;

    } else {

        status = IoCallDriver(fdoExtension->AttacheeDeviceObject, newIrp);

        if (status == STATUS_PENDING) {

            status = KeWaitForSingleObject(&event,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL);

            status = ioStatusBlock.Status;
        }
    }

    if (!NT_SUCCESS(status)) {

        parentResourceListSize = 0;

    } else {

        parentResourceListSize = (ULONG)ioStatusBlock.Information;
    }

    if (resourceListSize + parentResourceListSize) {

        resourceListForKeep = ExAllocatePool (NonPagedPool, resourceListSize + parentResourceListSize);

    } else {

        resourceListForKeep = NULL;
    }

    if (resourceListForKeep) {

        PUCHAR d;

        resourceListForKeep->Count = 0;
        d = (PUCHAR) resourceListForKeep->List;

        if (resourceListSize) {

            RtlCopyMemory (
                d,
                resourceList->List,
                resourceListSize - FIELD_OFFSET (CM_RESOURCE_LIST, List)
                );

            resourceListForKeep->Count = resourceList->Count;
            d += resourceListSize - FIELD_OFFSET (CM_RESOURCE_LIST, List);
        }

        if (parentResourceListSize) {

            RtlCopyMemory (
                d,
                parentResourceList->List,
                parentResourceListSize - FIELD_OFFSET (CM_RESOURCE_LIST, List)
                );

            resourceListForKeep->Count += parentResourceList->Count;
        }
    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE);

    IoCopyCurrentIrpStackLocationToNext (Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS ;

    IoSetCompletionRoutine(
        Irp,
        ChannelStartDeviceCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Pass the irp along
    //
    status = IoCallDriver(fdoExtension->AttacheeDeviceObject, Irp);

    //
    // Wait for it to come back...
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab back the 'real' status
        //
        status = Irp->IoStatus.Status;
    }

    if (!NT_SUCCESS(status)) {

        ExFreePool (resourceListForKeep);
        goto GetOut;
    }


    status = ChannelStartChannel (fdoExtension,
                                  resourceListForKeep);

    if (!NT_SUCCESS(status)) {

        ExFreePool (resourceListForKeep);
        goto GetOut;
    }

GetOut:
    if (parentResourceList) {

        ExFreePool (parentResourceList);
        parentResourceList = NULL;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

}

NTSTATUS
ChannelStartDeviceCompletionRoutine(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PIRP            Irp,
    IN OUT PVOID           Context
    )
{
    PKEVENT event = (PKEVENT) Context;

    //
    // Signal the event
    //
    KeSetEvent( event, IO_NO_INCREMENT, FALSE );

    //
    // Always return MORE_PROCESSING_REQUIRED
    // will complete it later
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ChannelStartChannel (
    PFDO_EXTENSION    FdoExtension,
    PCM_RESOURCE_LIST ResourceListToKeep
    )
{
    NTSTATUS                        status;
    PLOGICAL_UNIT_EXTENSION         logUnitExtension;
    IDE_PATH_ID                     pathId;
    POWER_STATE                     newState;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR irqPartialDescriptors;
    ULONG                           i;

#if DBG
    {
        PCM_RESOURCE_LIST               resourceList;
        PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
        PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
        ULONG                           resourceListSize;
        ULONG                           i;
        ULONG                           j;

        resourceList     = ResourceListToKeep;
        fullResourceList = resourceList->List;
        resourceListSize = 0;

        DebugPrint ((1, "IdePort: Starting device: FDOe\n", FdoExtension));

        for (i=0; i<resourceList->Count; i++) {
            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

            for (j=0; j<partialResourceList->Count; j++) {
                if (partialDescriptors[j].Type == CmResourceTypePort) {
                    DebugPrint ((1, "IdePort: IO Port = 0x%x. Lenght = 0x%x\n", partialDescriptors[j].u.Port.Start.LowPart, partialDescriptors[j].u.Port.Length));
                } else if (partialDescriptors[j].Type == CmResourceTypeInterrupt) {
                    DebugPrint ((1, "IdePort: Int Level = 0x%x. Int Vector = 0x%x\n", partialDescriptors[j].u.Interrupt.Level, partialDescriptors[j].u.Interrupt.Vector));
                } else {
                    DebugPrint ((1, "IdePort: Unknown resource\n"));
                }
            }
            fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + j);
        }

    }

#endif // DBG

    //
    // Analyze the resources we are getting
    //
    status = DigestResourceList (
                &FdoExtension->IdeResource,
                ResourceListToKeep,
                &irqPartialDescriptors
                );
    if (!NT_SUCCESS(status)) {

        goto GetOut;

    } else {

        PCONFIGURATION_INFORMATION configurationInformation;
        configurationInformation = IoGetConfigurationInformation();

        if (FdoExtension->IdeResource.AtdiskPrimaryClaimed) {
            FdoExtension->HwDeviceExtension->PrimaryAddress = TRUE;
            FdoExtension->HwDeviceExtension->SecondaryAddress = FALSE;
            configurationInformation->AtDiskPrimaryAddressClaimed = TRUE;
        }

        if (FdoExtension->IdeResource.AtdiskSecondaryClaimed) {
            FdoExtension->HwDeviceExtension->PrimaryAddress = FALSE;
            FdoExtension->HwDeviceExtension->SecondaryAddress = TRUE;
            configurationInformation->AtDiskSecondaryAddressClaimed = TRUE;
        }
    }

    //
    // Build io address structure.
    //
    AtapiBuildIoAddress(
            FdoExtension->IdeResource.TranslatedCommandBaseAddress,
            FdoExtension->IdeResource.TranslatedControlBaseAddress,
            &FdoExtension->HwDeviceExtension->BaseIoAddress1,
            &FdoExtension->HwDeviceExtension->BaseIoAddress2,
            &FdoExtension->HwDeviceExtension->BaseIoAddress1Length,
            &FdoExtension->HwDeviceExtension->BaseIoAddress2Length,
            &FdoExtension->HwDeviceExtension->MaxIdeDevice,
            &FdoExtension->HwDeviceExtension->MaxIdeTargetId);

    //
    // check for panasonic controller
    //
    FdoExtension->panasonicController = 
        IdePortIsThisAPanasonicPCMCIACard(FdoExtension);

    newState.DeviceState = PowerSystemWorking;
    status = IdePortIssueSetPowerState (
                 (PDEVICE_EXTENSION_HEADER) FdoExtension,
                 SystemPowerState,
                 newState,
                 TRUE                   // sync call
                 );
    if (status == STATUS_INVALID_DEVICE_REQUEST) {

        //
        // The DeviceObject Below us does not support power irp,
        // we will assume we are powered up
        //
        FdoExtension->SystemPowerState = PowerSystemWorking;

    } else if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    newState.DeviceState = PowerDeviceD0;
    status = IdePortIssueSetPowerState (
                 (PDEVICE_EXTENSION_HEADER) FdoExtension,
                 DevicePowerState,
                 newState,
                 TRUE                   // sync call
                 );
    if (status == STATUS_INVALID_DEVICE_REQUEST) {

        //
        // The DeviceObject Below us does not support power irp,
        // we will assume we are powered up
        //
        FdoExtension->DevicePowerState = PowerDeviceD0;

    } else if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    //
    // Initialize "miniport" data structure
    //
    FdoExtension->HwDeviceExtension->InterruptMode  = FdoExtension->IdeResource.InterruptMode;

#ifdef ENABLE_NATIVE_MODE
    //
    // Get parent's interrupt interface
    //
    ChannelQueryInterruptInterface (
        FdoExtension
        );

#endif
    //
    // Connect our interrupt
    //
    if (irqPartialDescriptors) {

        status = IoConnectInterrupt(&FdoExtension->InterruptObject,
                                    (PKSERVICE_ROUTINE) IdePortInterrupt,
                                    FdoExtension->DeviceObject,
                                    (PKSPIN_LOCK) NULL,
                                    irqPartialDescriptors->u.Interrupt.Vector,
                                    (KIRQL) irqPartialDescriptors->u.Interrupt.Level,
                                    (KIRQL) irqPartialDescriptors->u.Interrupt.Level,
                                    irqPartialDescriptors->Flags & CM_RESOURCE_INTERRUPT_LATCHED ? Latched : LevelSensitive,
                                    (BOOLEAN) (irqPartialDescriptors->ShareDisposition == CmResourceShareShared),
                                    irqPartialDescriptors->u.Interrupt.Affinity,
                                    FALSE);
    
        if (!NT_SUCCESS(status)) {
    
            DebugPrint((0, "IdePort: Can't connect interrupt %d\n", irqPartialDescriptors->u.Interrupt.Vector));
            FdoExtension->InterruptObject = NULL;
            goto GetOut;
        }
    

#ifdef ENABLE_NATIVE_MODE

		//
		// Disconnect the parent ISR stub
		//
        if ( FdoExtension->InterruptInterface.PciIdeInterruptControl) { 

            DebugPrint((1, "IdePort: %d fdoe 0x%x Invoking disconnect\n", 
						irqPartialDescriptors->u.Interrupt.Vector, 
						FdoExtension
						));

			status = FdoExtension->InterruptInterface.PciIdeInterruptControl (
															FdoExtension->InterruptInterface.Context,
															1
															);
			ASSERT(NT_SUCCESS(status));
		}

#endif

        //
        // Enable Interrupt
        //
        ChannelEnableInterrupt (FdoExtension);
    }

    if (FdoExtension->FdoState & FDOS_STOPPED) {

        //
        // we are restarting, no need to do the rest of start code
        //
        status = STATUS_SUCCESS;
        goto GetOut;
    }
    
    //
    // Get parent's busmaster interface
    //
    ChannelQueryBusMasterInterface (
        FdoExtension
        );

    //
    // Maintain a default timing table
    //
    if (FdoExtension->DefaultTransferModeTimingTable == NULL) {

        ULONG length=0;
        PULONG transferModeTimingTable = ExAllocatePool(NonPagedPool, MAX_XFER_MODE*sizeof(ULONG));

        if (transferModeTimingTable != NULL) {
            SetDefaultTiming(transferModeTimingTable, length);
            FdoExtension->DefaultTransferModeTimingTable = transferModeTimingTable;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;
        }
    }
    ASSERT(FdoExtension->DefaultTransferModeTimingTable);

    //
    // Get parent's access token to serialize access with siblings (broken pci-ide)
    //
    ChannelQuerySyncAccessInterface (
        FdoExtension
        );

    //
    // get an interface that tells parent to invalidate out resource requirement
    //
    ChannelQueryRequestProperResourceInterface (
        FdoExtension
        );

    //
    // Create legacy object names
    //
    status = ChannelCreateSymblicLinks (
                 FdoExtension
                 );

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    //
    // FDO Init Data
    //
    IdePortInitFdo (FdoExtension);

	//
	// Allocate reserve error log packets to log insufficient resource events
	//
	for (i=0;i<MAX_IDE_DEVICE;i++) {

		if (FdoExtension->ReserveAllocFailureLogEntry[i] == NULL) {
			FdoExtension->ReserveAllocFailureLogEntry[i] = IoAllocateErrorLogEntry(
															FdoExtension->DeviceObject,
															ALLOC_FAILURE_LOGSIZE
															);
		}
	}

	//
	// Pre-allocate memory for enumeration
	//
    if (!IdePreAllocEnumStructs(FdoExtension)) {
        status=STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

	
	//
	// Reserve pages to perform I/O under low memory conditions
	//
	if (FdoExtension->ReservedPages == NULL) {

		FdoExtension->ReservedPages = MmAllocateMappingAddress( IDE_NUM_RESERVED_PAGES * PAGE_SIZE,
																'PedI'
																);

		ASSERT(FdoExtension->ReservedPages);
			
	}

GetOut:
    if (NT_SUCCESS(status)) {

        //
        // End of Init.
        //
        CLRMASK (FdoExtension->FdoState, FDOS_STOPPED);
        SETMASK (FdoExtension->FdoState, FDOS_STARTED);

        if (FdoExtension->ResourceList) {
            ExFreePool(FdoExtension->ResourceList);
            FdoExtension->ResourceList = NULL;
        }
        FdoExtension->ResourceList = ResourceListToKeep;

    } else {

        ChannelRemoveChannel (FdoExtension);
    }

    return status;
}

NTSTATUS
ChannelCreateSymblicLinks (
    PFDO_EXTENSION FdoExtension
    )
{
    NTSTATUS            status;
    ULONG               i;
    PULONG              scsiportNumber;

    UNICODE_STRING      deviceName;
    WCHAR               deviceNameBuffer[64];

    UNICODE_STRING      symbolicDeviceName;
    WCHAR               symbolicDeviceNameBuffer[64];

    swprintf(deviceNameBuffer, DEVICE_OJBECT_BASE_NAME L"\\IdePort%d", FdoExtension->IdePortNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    scsiportNumber = &IoGetConfigurationInformation()->ScsiPortCount;

    for (i=0; i <= (*scsiportNumber); i++) {

        swprintf(symbolicDeviceNameBuffer, L"\\Device\\ScsiPort%d", i);
        RtlInitUnicodeString(&symbolicDeviceName, symbolicDeviceNameBuffer);

        status = IoCreateSymbolicLink(
                     &symbolicDeviceName,
                     &deviceName
                     );

        if (NT_SUCCESS (status)) {

            swprintf(symbolicDeviceNameBuffer, L"\\DosDevices\\Scsi%d:", i);
            RtlInitUnicodeString(&symbolicDeviceName, symbolicDeviceNameBuffer);

            IoAssignArcName (
                &symbolicDeviceName,
                &deviceName
                );

            break;
        }
    }


    if (NT_SUCCESS(status)) {

        FdoExtension->SymbolicLinkCreated = TRUE;
        FdoExtension->ScsiPortNumber = i;
        (*scsiportNumber)++;
    }

    return status;
}

NTSTATUS
ChannelDeleteSymblicLinks (
    PFDO_EXTENSION FdoExtension
    )
{
    NTSTATUS            status;
    ULONG               i;

    UNICODE_STRING      deviceName;
    WCHAR               deviceNameBuffer[64];

    if (!FdoExtension->SymbolicLinkCreated) {

        return STATUS_SUCCESS;
    }

    swprintf(deviceNameBuffer, L"\\Device\\ScsiPort%d", FdoExtension->ScsiPortNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    IoDeleteSymbolicLink(
        &deviceName
        ); 

    swprintf(deviceNameBuffer, L"\\DosDevices\\Scsi%d:", FdoExtension->ScsiPortNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    IoDeassignArcName(&deviceName);

    FdoExtension->SymbolicLinkCreated = FALSE;

    IoGetConfigurationInformation()->ScsiPortCount--;

    return STATUS_SUCCESS;
}


NTSTATUS
ChannelSurpriseRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    PPDO_EXTENSION pdoExtension;
    IDE_PATH_ID pathId;
    NTSTATUS status;

    //
    // all my childred should be surprise removed or removed
    //
    pathId.l = 0;
    while (pdoExtension = NextLogUnitExtensionWithTag (
                              fdoExtension, 
                              &pathId, 
                              TRUE,
                              ChannelSurpriseRemoveDevice
                              )) {

        //ASSERT (pdoExtension->PdoState & (PDOS_SURPRISE_REMOVED | PDOS_REMOVED));

        CLRMASK (pdoExtension->PdoState, PDOS_REPORTED_TO_PNP); 

        UnrefPdoWithTag(
            pdoExtension, 
            ChannelSurpriseRemoveDevice
            );
    }

    status = ChannelRemoveChannel (fdoExtension);
    ASSERT (NT_SUCCESS(status));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation (Irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
}


NTSTATUS
ChannelRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION  fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    PPDO_EXTENSION  pdoExtension;
    NTSTATUS        status;
    KEVENT          event;

    IDE_PATH_ID     pathId;

    DebugPrint ((
        DBG_PNP,
        "fdoe 0x%x 0x%x got a STOP device\n",
        fdoExtension,
        fdoExtension->IdeResource.TranslatedCommandBaseAddress
        ));

    //
    // Kill all the children if any
    //
    pathId.l = 0;
    while (pdoExtension = NextLogUnitExtensionWithTag (
                              fdoExtension, 
                              &pathId, 
                              TRUE,
                              ChannelRemoveDevice
                              )) {

		if (pdoExtension->PdoState & PDOS_SURPRISE_REMOVED) {

			CLRMASK (pdoExtension->PdoState, PDOS_REPORTED_TO_PNP);
			continue;
		}

        FreePdoWithTag(
            pdoExtension, 
            TRUE,
            TRUE,
            ChannelRemoveDevice
            );
    }

    status = ChannelRemoveChannel (fdoExtension);
    ASSERT (NT_SUCCESS(status));

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext (Irp);

    IoSetCompletionRoutine(
        Irp,
        ChannelRemoveDeviceCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    status = IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);

    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    IoDetachDevice (fdoExtension->AttacheeDeviceObject);

    IoDeleteDevice (DeviceObject);

    //return STATUS_SUCCESS;
    return status;
}


NTSTATUS
ChannelRemoveDeviceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    PKEVENT event = Context;

    KeSetEvent(event, 0, FALSE);

    return STATUS_SUCCESS;
}

NTSTATUS
ChannelStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION fdoExtension;

    fdoExtension = DeviceObject->DeviceExtension;

    DebugPrint ((
        DBG_PNP,
        "fdoe 0x%x 0x%x got a STOP device\n",
        fdoExtension,
        fdoExtension->IdeResource.TranslatedCommandBaseAddress
        ));

    //
    // disable interrupt
    //
    ChannelDisableInterrupt (fdoExtension);

    if (fdoExtension->InterruptObject) {

#ifdef ENABLE_NATIVE_MODE

		//
		// Reconnect the parent ISR stub
		//
        if (fdoExtension->InterruptInterface.PciIdeInterruptControl) { 

			NTSTATUS status;

			DebugPrint((1, "fdoe 0x%x invoking reconnect\n", fdoExtension));

			status = fdoExtension->InterruptInterface.PciIdeInterruptControl (
															fdoExtension->InterruptInterface.Context,
															0
															);
			ASSERT(NT_SUCCESS(status));
		}

#endif
		
        IoDisconnectInterrupt (
            fdoExtension->InterruptObject
            );

        fdoExtension->InterruptObject = 0;

    }

    if (fdoExtension->FdoState & FDOS_STARTED) {

        //
        // indicate we have been stopped only if we have started
        //
        CLRMASK (fdoExtension->FdoState, FDOS_STARTED);
        SETMASK (fdoExtension->FdoState, FDOS_STOPPED);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation (Irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
}

NTSTATUS
ChannelRemoveChannel (
    PFDO_EXTENSION    FdoExtension
    )
{
    PCONFIGURATION_INFORMATION configurationInformation;
    ULONG i;

    configurationInformation = IoGetConfigurationInformation();
    
    DebugPrint((1, "ChannelRemoveChannel for FDOe %x\n", FdoExtension));

    if (FdoExtension->IdeResource.AtdiskPrimaryClaimed) {
        configurationInformation->AtDiskPrimaryAddressClaimed = FALSE;
    }

    if (FdoExtension->IdeResource.AtdiskSecondaryClaimed) {
        configurationInformation->AtDiskSecondaryAddressClaimed = FALSE;
    }
    FdoExtension->IdeResource.AtdiskPrimaryClaimed   = FALSE;
    FdoExtension->IdeResource.AtdiskSecondaryClaimed = FALSE;
    FdoExtension->HwDeviceExtension->PrimaryAddress  = FALSE;

    if ((FdoExtension->IdeResource.CommandBaseAddressSpace == MEMORY_SPACE) &&
        (FdoExtension->IdeResource.TranslatedCommandBaseAddress)) {

        MmUnmapIoSpace (
            FdoExtension->IdeResource.TranslatedCommandBaseAddress,
            FdoExtension->HwDeviceExtension->BaseIoAddress1Length
            );
    }
    FdoExtension->IdeResource.TranslatedCommandBaseAddress = 0;

    if ((FdoExtension->IdeResource.ControlBaseAddressSpace == MEMORY_SPACE) &&
        (FdoExtension->IdeResource.TranslatedControlBaseAddress)) {

        MmUnmapIoSpace (
            FdoExtension->IdeResource.TranslatedControlBaseAddress,
            1
            );
    }
    FdoExtension->IdeResource.TranslatedControlBaseAddress = 0;

    if (FdoExtension->InterruptObject) {

#ifdef ENABLE_NATIVE_MODE

		//
		// Reconnect the parent ISR stub
		//
        if (FdoExtension->InterruptInterface.PciIdeInterruptControl) { 

			NTSTATUS status;

			DebugPrint((1, "fdoe 0x%x invoking reconnect\n", FdoExtension));

			status = FdoExtension->InterruptInterface.PciIdeInterruptControl (
															FdoExtension->InterruptInterface.Context,
															0
															);
			ASSERT(NT_SUCCESS(status));
		}

#endif

        IoDisconnectInterrupt (
            FdoExtension->InterruptObject
            );

        FdoExtension->InterruptObject = 0;
    }

    // unbind from the bm stuff if NECESSARY
    // release parent's access token to serialize access with siblings (broken pci-ide)

    if (FdoExtension->ResourceList) {

        ExFreePool (FdoExtension->ResourceList);
        FdoExtension->ResourceList = NULL;

    }
    else {
        DebugPrint((1, "ATAPI: Resource list for FDOe %x already freed\n",
                            FdoExtension));
    }

    //
    // Lock
    //
    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 1, 0) == 0);

	//
	// Free pre-allocated memory
	//
    IdeFreeEnumStructs(FdoExtension->PreAllocEnumStruct);

    FdoExtension->PreAllocEnumStruct = NULL;

    //
    // Unlock
    //
    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 0, 1) == 1);

	//
	// Free the reserve error log entries
	//
    for (i=0; i< MAX_IDE_DEVICE; i++) {
        PVOID entry;
        PVOID currentValue;

        entry = FdoExtension->ReserveAllocFailureLogEntry[i];

        if (entry == NULL) {
            continue;
        }
        //
        // We have to ensure that we are the only instance to use this
        // event.  To do so, we attempt to NULL the event in the driver
        // extension.  If somebody else beats us to it, they own the
        // event and we have to give up.
        //

        currentValue = InterlockedCompareExchangePointer(
                            &(FdoExtension->ReserveAllocFailureLogEntry[i]),
                            NULL,
                            entry
                            );

        if (entry != currentValue) {
            continue;
        }

        // Note that you cannot ExFreePool the entry
        // because Io returns an offset into the pool allocation, not the start.
        // Use the API provided by Iomanager
        IoFreeErrorLogEntry(entry);
    }

    //
    // Free the default timing table
    //
    if (FdoExtension->DefaultTransferModeTimingTable) {

        ExFreePool(FdoExtension->DefaultTransferModeTimingTable);

        FdoExtension->DefaultTransferModeTimingTable = NULL;
        FdoExtension->TransferModeInterface.TransferModeTimingTable = NULL;
        FdoExtension->TransferModeInterface.TransferModeTableLength =0;
    }

	//
	// Unmap the reserved mapping
	//
	if (FdoExtension->ReservedPages != NULL) {

		MmFreeMappingAddress(FdoExtension->ReservedPages,
							 'PedI'
							 );
		FdoExtension->ReservedPages = NULL;
	}

    ChannelDeleteSymblicLinks (
        FdoExtension
        );

    return STATUS_SUCCESS;
}

NTSTATUS
ChannelQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  thisIrpSp;
    PIDE_WORK_ITEM_CONTEXT workItemContext;
	PENUMERATION_STRUCT	enumStruct = fdoExtension->PreAllocEnumStruct;

    if (!(fdoExtension->FdoState & FDOS_STARTED)) {

        Irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_DEVICE_NOT_READY;
    }

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

    switch (thisIrpSp->Parameters.QueryDeviceRelations.Type) {
    case BusRelations:

        DebugPrint ((DBG_BUSSCAN, "IdeQueryDeviceRelations: bus relations\n"));

		ASSERT(enumStruct);
        workItemContext = (PIDE_WORK_ITEM_CONTEXT) enumStruct->EnumWorkItemContext;
        ASSERT(workItemContext);
        ASSERT(workItemContext->WorkItem);

        workItemContext->Irp = Irp;

#ifdef SYNC_DEVICE_RELATIONS

        return ChannelQueryBusRelation (
                  DeviceObject,
                  workItemContext);

#else 
        Irp->IoStatus.Status = STATUS_PENDING;
        IoMarkIrpPending(Irp);

        IoQueueWorkItem(
             workItemContext->WorkItem,
             ChannelQueryBusRelation,
             DelayedWorkQueue,
             workItemContext
             );

        return STATUS_PENDING;
#endif //!SYNC_DEVICE_RELATIONS
        break;

        default:
        DebugPrint ((1, "IdeQueryDeviceRelations: Unsupported device relation\n"));

        //
        // Don't set the status if it is not success and is being passed 
        // down
        //

        //Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        break;
    }

    IoSkipCurrentIrpStackLocation (Irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
}

NTSTATUS
ChannelQueryBusRelation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIDE_WORK_ITEM_CONTEXT WorkItemContext
    )
{

    PIRP irp;
    PFDO_EXTENSION      fdoExtension;
    PIO_STACK_LOCATION  thisIrpSp;
    PDEVICE_RELATIONS   deviceRelations;
    LARGE_INTEGER       tickCount;
    ULONG               timeDiff;

    irp = WorkItemContext->Irp;

    //
    // do not release resource for this worker item as they are pre-alloced
    //
   // IoFreeWorkItem(WorkItemContext->WorkItem);
    //ExFreePool (WorkItemContext);

    thisIrpSp = IoGetCurrentIrpStackLocation(irp);
    fdoExtension = thisIrpSp->DeviceObject->DeviceExtension;

    LogBusScanStartTimer(&tickCount);

    //
    // grab the acpi/bios timing settings if any
    // GTM should be called for every enumeration
    //
    DeviceQueryChannelTimingSettings (
        fdoExtension,
        &fdoExtension->AcpiTimingSettings
        );

    //
    // Get parent's xfer mode interface
    //
    ChannelQueryTransferModeInterface (
        fdoExtension
        );

    //
    // scan the bus
    //
    IdePortScanBus (fdoExtension);

    timeDiff = LogBusScanStopTimer(&tickCount);
    LogBusScanTimeDiff(fdoExtension, L"IdeTotalBusScanTime", timeDiff);

#ifdef IDE_MEASURE_BUSSCAN_SPEED
        if (timeDiff > 7000) {

            DebugPrint ((DBG_WARNING, "WARNING: **************************************\n"));
            DebugPrint ((DBG_WARNING, "WARNING: IdePortScanBus 0x%x took %u millisec\n", fdoExtension->IdeResource.TranslatedCommandBaseAddress, timeDiff));
            DebugPrint ((DBG_WARNING, "WARNING: **************************************\n"));

        } else {

            DebugPrint ((DBG_BUSSCAN, "IdePortScanBus 0x%x took %u millisec\n", fdoExtension->IdeResource.TranslatedCommandBaseAddress, timeDiff));
        }
#endif

    deviceRelations = ChannelBuildDeviceRelationList (
                          fdoExtension
                          );

    irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
    irp->IoStatus.Status = STATUS_SUCCESS;

    IoSkipCurrentIrpStackLocation (irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, irp);
}


PDEVICE_RELATIONS
ChannelBuildDeviceRelationList (
    PFDO_EXTENSION FdoExtension
    )
{
    IDE_PATH_ID         pathId;
    ULONG               numPdoChildren;
    NTSTATUS            status;
    PPDO_EXTENSION      pdoExtension;
    ULONG               deviceRelationsSize;
    PDEVICE_RELATIONS   deviceRelations;

    status = STATUS_SUCCESS;

    pathId.l = 0;
    numPdoChildren = 0;
    while (pdoExtension = NextLogUnitExtensionWithTag(
                              FdoExtension,
                              &pathId,
                              TRUE,
                              ChannelBuildDeviceRelationList
                              )) {

        UnrefLogicalUnitExtensionWithTag (
            FdoExtension, 
            pdoExtension,
            ChannelBuildDeviceRelationList
            );
        numPdoChildren++;
    }

    if (numPdoChildren) {
        deviceRelationsSize = FIELD_OFFSET (DEVICE_RELATIONS, Objects) +
                              numPdoChildren * sizeof(PDEVICE_OBJECT);
    } else {
        // Current build expect a DEVICE_RELATIONS with a Count of 0
        // if we don't have any PDO to return

        deviceRelationsSize = FIELD_OFFSET( DEVICE_RELATIONS, Objects ) +
                              1 * sizeof( PDEVICE_OBJECT );
    }

    deviceRelations = ExAllocatePool (NonPagedPool, deviceRelationsSize);

    if(!deviceRelations) {
        DebugPrint ((DBG_ALWAYS, "ChannelBuildDeviceRelationList: Unable to allocate DeviceRelations structures\n"));
        status = STATUS_NO_MEMORY;

    }

    if (NT_SUCCESS(status)) {

        (deviceRelations)->Count = 0;

        pathId.l = 0;
        while ((deviceRelations->Count < numPdoChildren) &&
               (pdoExtension = NextLogUnitExtensionWithTag(
                                   FdoExtension, 
                                   &pathId, 
                                   TRUE,
                                   ChannelBuildDeviceRelationList
                                   ))) {

            KIRQL currentIrql;
            BOOLEAN deadMeat;

            KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);
            deadMeat = pdoExtension->PdoState & PDOS_DEADMEAT ? TRUE : FALSE;
            KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

            if (!deadMeat) {

                KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);
                SETMASK (pdoExtension->PdoState, PDOS_REPORTED_TO_PNP);
                KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

                deviceRelations->Objects[deviceRelations->Count] = pdoExtension->DeviceObject;
                ObReferenceObjectByPointer(deviceRelations->Objects[deviceRelations->Count],
                                           0,
                                           0,
                                           KernelMode);
                deviceRelations->Count++;

            } else {

                KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);
                CLRMASK (pdoExtension->PdoState, PDOS_REPORTED_TO_PNP);
                KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

                DebugPrint ((DBG_BUSSCAN, "0x%x target 0x%x pdoExtension 0x%x is marked DEADMEAT\n",
                             pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             pdoExtension->TargetId,
                             pdoExtension));
            }

            UnrefLogicalUnitExtensionWithTag (
                FdoExtension, 
                pdoExtension,
                ChannelBuildDeviceRelationList
                );
        }

        DebugPrint ((DBG_BUSSCAN, "ChannelBuildDeviceRelationList: returning %d children\n", deviceRelations->Count));
    }


    return deviceRelations;
}

NTSTATUS
ChannelQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PFDO_EXTENSION      fdoExtension;
    NTSTATUS            status;
    PWCHAR              returnString;
    ANSI_STRING         ansiString;
    UNICODE_STRING      unicodeString;

	PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;


    if (!(fdoExtension->FdoState & FDOS_STARTED)) {

        Irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_DEVICE_NOT_READY;
    }

    unicodeString.Buffer = NULL;
    switch (thisIrpSp->Parameters.QueryId.IdType) {

        case BusQueryCompatibleIDs:
        case BusQueryHardwareIDs:

            unicodeString.Length        = 0;
            unicodeString.MaximumLength = 50 * sizeof(WCHAR);
            unicodeString.Buffer = ExAllocatePool(PagedPool, unicodeString.MaximumLength);

            //
            // Caller wants the unique id of the device
            //
            RtlInitAnsiString (
                &ansiString,
                "*PNP0600"
                );
            break;

        default:
            break;
    }

    if (unicodeString.Buffer) {

        RtlAnsiStringToUnicodeString(
            &unicodeString,
            &ansiString,
            FALSE
            );

        //
        // double null terminate it
        //
        unicodeString.Buffer[unicodeString.Length/sizeof(WCHAR) + 0] = L'\0';
        unicodeString.Buffer[unicodeString.Length/sizeof(WCHAR) + 1] = L'\0';

        IoMarkIrpPending(Irp);

        //
        // we need to check if the lower driver handles this irp
        // registry a completion routine.  we can check
        // when the irp comes back
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine(
            Irp,
            ChannelQueryIdCompletionRoutine,
            unicodeString.Buffer,
            TRUE,
            TRUE,
            TRUE
            );

    } else {

        //
        // we don't care much about this irp
        //
        IoSkipCurrentIrpStackLocation (Irp);
    }

    status = IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);

    if (unicodeString.Buffer) {

        return STATUS_PENDING;

    } else {

        return status;
    }
}

NTSTATUS
ChannelQueryIdCompletionRoutine (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
{
    if (Irp->IoStatus.Status == STATUS_NOT_SUPPORTED) {

        //
        // the lower level driver didn't handle the irp
        // return the device text string we created early
        //
        Irp->IoStatus.Information = (ULONG_PTR) Context;
        Irp->IoStatus.Status = STATUS_SUCCESS;
    } else {

        //
        // the lower driver handled the irp,
        // we don't need to return our device text string
        //
        ExFreePool (Context);
    }

    return Irp->IoStatus.Status;
}

NTSTATUS
ChannelUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;
    PULONG deviceUsageCount;

    ASSERT (DeviceObject);
    ASSERT (Irp);

    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT (fdoExtension);

    if (!(fdoExtension->FdoState & FDOS_STARTED)) {

        Irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_DEVICE_NOT_READY;
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging) {

        //
        // Adjust the paging path count for this device.
        //
        deviceUsageCount = &fdoExtension->PagingPathCount;

    } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation) {

        //
        // Adjust the paging path count for this device.
        //
        deviceUsageCount = &fdoExtension->HiberPathCount;

    } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile) {

        //
        // Adjust the paging path count for this device.
        //
        deviceUsageCount = &fdoExtension->CrashDumpPathCount;

    } else {

        deviceUsageCount = NULL;
        DebugPrint ((DBG_ALWAYS,
                     "ATAPI: Unknown IRP_MN_DEVICE_USAGE_NOTIFICATION type: 0x%x\n",
                     irpSp->Parameters.UsageNotification.Type));
    }

    IoCopyCurrentIrpStackLocationToNext (Irp);

    IoSetCompletionRoutine (
        Irp,
        ChannelUsageNotificationCompletionRoutine,
        deviceUsageCount,
        TRUE,
        TRUE,
        TRUE);

    ASSERT(fdoExtension->AttacheeDeviceObject);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);

} // ChannelPagingNotification

NTSTATUS
ChannelUsageNotificationCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PFDO_EXTENSION fdoExtension;
    PULONG deviceUsageCount = Context;

    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT (fdoExtension);

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        if (deviceUsageCount) {

            IoAdjustPagingPathCount (
                deviceUsageCount,
                IoGetCurrentIrpStackLocation(Irp)->Parameters.UsageNotification.InPath
                );
        }
    }

    return Irp->IoStatus.Status;
}



NTSTATUS
ChannelDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFDO_EXTENSION fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    PSTORAGE_PROPERTY_QUERY storageQuery;
    STORAGE_ADAPTER_DESCRIPTOR adapterDescriptor;
    ULONG outBufferSize;
    NTSTATUS status;

    // pass it down if not supported and it is for the FDO stack

    switch (thisIrpSp->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_STORAGE_QUERY_PROPERTY:

            storageQuery = Irp->AssociatedIrp.SystemBuffer;

            if (thisIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(STORAGE_PROPERTY_QUERY)) {

                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

            } else {

                if (storageQuery->PropertyId == StorageAdapterProperty) { // device property

                    switch (storageQuery->QueryType) {
                        case PropertyStandardQuery:
                            DebugPrint ((1, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY PropertyStandardQuery\n"));

                            RtlZeroMemory (&adapterDescriptor, sizeof(adapterDescriptor));

                            //
                            // BuildAtaDeviceDescriptor
                            //
                            adapterDescriptor.Version                = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
                            adapterDescriptor.Size                   = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
                            adapterDescriptor.MaximumTransferLength  = MAX_TRANSFER_SIZE_PER_SRB;
                            adapterDescriptor.MaximumPhysicalPages   = SP_UNINITIALIZED_VALUE;   
                            adapterDescriptor.AlignmentMask          = DeviceObject->AlignmentRequirement;
                            adapterDescriptor.AdapterUsesPio         = TRUE;         // We always support PIO
                            adapterDescriptor.AdapterScansDown       = FALSE;
                            adapterDescriptor.CommandQueueing        = FALSE;
                            adapterDescriptor.AcceleratedTransfer    = FALSE;
                            adapterDescriptor.BusType                = BusTypeAta;   // Bus type should be ATA
                            adapterDescriptor.BusMajorVersion        = 1;            // Major version
                            adapterDescriptor.BusMinorVersion        = 0;            // 

                            if (thisIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                                sizeof(STORAGE_ADAPTER_DESCRIPTOR)) {

                                outBufferSize = thisIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                            } else {

                                outBufferSize = sizeof(STORAGE_ADAPTER_DESCRIPTOR);
                            }

                            RtlCopyMemory (Irp->AssociatedIrp.SystemBuffer,
                                           &adapterDescriptor,
                                           outBufferSize);
                            Irp->IoStatus.Information = outBufferSize;
                            Irp->IoStatus.Status = STATUS_SUCCESS;
                            break;

                        case PropertyExistsQuery:
                            DebugPrint ((1, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY PropertyExistsQuery\n"));
                            Irp->IoStatus.Status = STATUS_SUCCESS;
                            break;

                        case PropertyMaskQuery:
                            DebugPrint ((1, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY PropertyMaskQuery\n"));
                            Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                            break;

                        default:
                            DebugPrint ((1, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY unknown type\n"));
                            Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                            break;
                    }
                }
            }
            break;

        default:

            //
            // we don't know what this deviceIoControl Irp is
            //
            if (thisIrpSp->DeviceObject == DeviceObject) {

                //
                // this irp could come from the PDO stack
                //
                // forward this unknown request if and only
                // if this irp is for the FDO stack
                //
                IoSkipCurrentIrpStackLocation (Irp);
                return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
                break;
            }
            Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
            break;

    }

    status = Irp->IoStatus.Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

VOID
ChannelQueryBusMasterInterface (
    PFDO_EXTENSION    FdoExtension
    )
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS          status;


    FdoExtension->BoundWithBmParent = FALSE;

    RtlZeroMemory (&irpSp, sizeof(irpSp));

    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCIIDE_BUSMASTER_INTERFACE;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (FdoExtension->HwDeviceExtension->BusMasterInterface);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->HwDeviceExtension->BusMasterInterface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    status = IdePortSyncSendIrp (FdoExtension->AttacheeDeviceObject, &irpSp, NULL);
    if (NT_SUCCESS(status)) {
        FdoExtension->BoundWithBmParent = TRUE;
    }
    return;
}

#ifdef ENABLE_NATIVE_MODE
VOID
ChannelQueryInterruptInterface (
    PFDO_EXTENSION    FdoExtension
    )
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS          status;


    RtlZeroMemory (&irpSp, sizeof(irpSp));

    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCIIDE_INTERRUPT_INTERFACE;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (FdoExtension->InterruptInterface);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->InterruptInterface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

	DebugPrint((1, "Querying interrupt interface for Fdoe 0x%x\n", FdoExtension));

    status = IdePortSyncSendIrp (FdoExtension->AttacheeDeviceObject, &irpSp, NULL);

    return;
}
#endif

VOID
ChannelQueryTransferModeInterface (
    PFDO_EXTENSION    FdoExtension
    )
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS          status;
    ULONG i;

    PAGED_CODE();

    RtlZeroMemory (&irpSp, sizeof(irpSp));

    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCIIDE_XFER_MODE_INTERFACE;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (FdoExtension->TransferModeInterface);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->TransferModeInterface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    status = IdePortSyncSendIrp (FdoExtension->AttacheeDeviceObject, &irpSp, NULL);
    
    if (NT_SUCCESS(status)) {
    
        if (FdoExtension->TransferModeInterface.SupportLevel 
                != PciIdeFullXferModeSupport) {

            //
            // We got the sfer mode interface from our parent,
            // but it has only the basic functionality.  It
            // just relies on the BIOS to program its timing
            // registers during POST.  It doesn't really know 
            // how to program its timing registers.
            //      
            for (i=0; i<MAX_IDE_DEVICE; i++) {
    
                if (FdoExtension->AcpiTimingSettings.Speed[i].Pio != ACPI_XFER_MODE_NOT_SUPPORT) {
                
                    //
                    // looks like ACPI is present and it knows how to program
                    // ide timing registers.  Let's forget our parent xfer mode
                    // interface and go with the ACPI xfer mode interface
                    //
                    status = STATUS_UNSUCCESSFUL;                
                }
            }
        }

        ASSERT (FdoExtension->TransferModeInterface.TransferModeTimingTable);
    }
    
#ifdef ALWAYS_USE_APCI_IF_AVAILABLE
    for (i=0; i<MAX_IDE_DEVICE; i++) {

        if (FdoExtension->AcpiTimingSettings.Speed[i].Pio != ACPI_XFER_MODE_NOT_SUPPORT) {
        
            status = STATUS_UNSUCCESSFUL;                
        }
    }
#endif // ALWAYS_USE_APCI_IF_AVAILABLE

    if (!NT_SUCCESS(status)) {

        PULONG transferModeTimingTable = FdoExtension->TransferModeInterface.TransferModeTimingTable;
        //
        // if we can't get the TransferModeInterface,
        // we will default to the ACPI TransferModeInterface
        //
        if ((FdoExtension->AcpiTimingSettings.Speed[0].Pio != ACPI_XFER_MODE_NOT_SUPPORT) ||
            (FdoExtension->AcpiTimingSettings.Speed[1].Pio != ACPI_XFER_MODE_NOT_SUPPORT)) {

            FdoExtension->TransferModeInterface.SupportLevel = PciIdeFullXferModeSupport;

        } else {

            FdoExtension->TransferModeInterface.SupportLevel = PciIdeBasicXferModeSupport;
        }
        FdoExtension->TransferModeInterface.Context = FdoExtension;
        FdoExtension->TransferModeInterface.TransferModeSelect = ChannelAcpiTransferModeSelect;

        //
        // Fill up the timingTable with the default cycle times.
        //
        if (transferModeTimingTable == NULL) {
            FdoExtension->TransferModeInterface.TransferModeTimingTable = FdoExtension->
                                                                            DefaultTransferModeTimingTable;
            FdoExtension->TransferModeInterface.TransferModeTableLength = MAX_XFER_MODE;
        }
    }

    if (FdoExtension->TransferModeInterface.SupportLevel == 
        PciIdeBasicXferModeSupport) {

        //
        // we don't really have code to set the correct
        // xfer mode timing on the controller.  
        // our TransferModeInterface is really picking
        // whatever mode set by the bios.  and since there
        // is no way to figure what the current PIO mode
        // the drive is in, we are setting a flag in
        // the HwDeviceExtension so that we won't try
        // to change the pio transfer mode
        // 
        FdoExtension->HwDeviceExtension->NoPioSetTransferMode = TRUE;
    }

    ASSERT (FdoExtension->TransferModeInterface.TransferModeSelect);
    ASSERT (FdoExtension->TransferModeInterface.TransferModeTimingTable);

    return;
}

VOID
ChannelUnbindBusMasterParent (
    PFDO_EXTENSION    FdoExtension
    )
{
    // ISSUE: 08/30/2000 implement me!!!
    return;
}


VOID
ChannelQuerySyncAccessInterface (
    PFDO_EXTENSION    FdoExtension
    )
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS          status;

    RtlZeroMemory (&irpSp, sizeof(irpSp));
    RtlZeroMemory (
        &FdoExtension->SyncAccessInterface,
        sizeof (FdoExtension->SyncAccessInterface)
        );

    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCIIDE_SYNC_ACCESS_INTERFACE;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (FdoExtension->SyncAccessInterface);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->SyncAccessInterface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    status = IdePortSyncSendIrp (FdoExtension->AttacheeDeviceObject, &irpSp, NULL);

    //
    // parent doesn't support access token,
    //
    if (!NT_SUCCESS(status)) {

        FdoExtension->SyncAccessInterface.AllocateAccessToken = 0;
        FdoExtension->SyncAccessInterface.Token               = 0;
    }

    return;
}

VOID
ChannelQueryRequestProperResourceInterface (
    PFDO_EXTENSION    FdoExtension
    )
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS          status;

    RtlZeroMemory (&irpSp, sizeof(irpSp));
    RtlZeroMemory (
        &FdoExtension->RequestProperResourceInterface,
        sizeof (FdoExtension->RequestProperResourceInterface)
        );

    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCIIDE_REQUEST_PROPER_RESOURCES;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (FdoExtension->RequestProperResourceInterface);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->RequestProperResourceInterface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    status = IdePortSyncSendIrp (FdoExtension->AttacheeDeviceObject, &irpSp, NULL);
    return;
}

__inline
VOID
ChannelEnableInterrupt (
    IN PFDO_EXTENSION FdoExtension
)
{
    ULONG i;

    for (i=0; i<(FdoExtension->HwDeviceExtension->MaxIdeDevice/MAX_IDE_DEVICE);i++) {

        SelectIdeLine(&FdoExtension->HwDeviceExtension->BaseIoAddress1,i);

        IdePortOutPortByte (
            FdoExtension->HwDeviceExtension->BaseIoAddress2.DeviceControl,
            IDE_DC_REENABLE_CONTROLLER
            );
    }
}

__inline
VOID
ChannelDisableInterrupt (
    IN PFDO_EXTENSION FdoExtension
)
{
    ULONG i;

    for (i=0; i<(FdoExtension->HwDeviceExtension->MaxIdeDevice/MAX_IDE_DEVICE);i++) {

        SelectIdeLine(&FdoExtension->HwDeviceExtension->BaseIoAddress1,i);

        IdePortOutPortByte (
            FdoExtension->HwDeviceExtension->BaseIoAddress2.DeviceControl,
            IDE_DC_DISABLE_INTERRUPTS
            );
    }
}



NTSTATUS
ChannelAcpiTransferModeSelect (
    IN PVOID Context,
    PPCIIDE_TRANSFER_MODE_SELECT XferMode
    )
{
    PFDO_EXTENSION fdoExtension = Context;
    ULONG i;
    BOOLEAN useUdmaMode[MAX_IDE_DEVICE];
    BOOLEAN dmaMode;
    PIDENTIFY_DATA ataIdentifyData[MAX_IDE_DEVICE];
    NTSTATUS status;
    ULONG numDevices;
    ULONG timingMode[MAX_IDE_DEVICE];
    ULONG cycleTime[MAX_IDE_DEVICE];
    ULONG dmaTiming;
    PACPI_IDE_TIMING acpiTimingSettings;
    ACPI_IDE_TIMING newAcpiTimingSettings;
    PULONG transferModeTimingTable=XferMode->TransferModeTimingTable;

    ASSERT(transferModeTimingTable);


    ASSERT (IsNEC_98 == FALSE);

    if (fdoExtension->DeviceChanged) {
        DebugPrint((DBG_XFERMODE, "Updating boot acpi timing settings\n"));
        RtlCopyMemory (&fdoExtension->BootAcpiTimingSettings, 
                       &fdoExtension->AcpiTimingSettings,
                       sizeof(newAcpiTimingSettings)
                       );
    }
    acpiTimingSettings = &fdoExtension->BootAcpiTimingSettings;

    RtlZeroMemory (&newAcpiTimingSettings, sizeof(newAcpiTimingSettings));
    newAcpiTimingSettings.Flags.b.IndependentTiming = 
        acpiTimingSettings->Flags.b.IndependentTiming;

    //
    // how many devices do we have?
    //
    for (i=numDevices=0; i<MAX_IDE_DEVICE; i++) {
        
        if (XferMode->DevicePresent[i]) {
            numDevices++;
        }
    }
    ASSERT (numDevices);

    //
    // pick the device pio timing
    //
    for (i=0; i<MAX_IDE_DEVICE; i++) {
        
        ULONG mode;

        if (!XferMode->DevicePresent[i]) {
            continue;
        }

        GetHighestPIOTransferMode(XferMode->DeviceTransferModeSupported[i], mode);

        timingMode[i] = 1<<mode;
        cycleTime[i] = XferMode->BestPioCycleTime[i];
    }

    if ((numDevices > 1) && !acpiTimingSettings->Flags.b.IndependentTiming) {

        //
        // pick the slower of the two timings
        // (the smaller timing mode value, the slower it is)
        //

        if (timingMode[0] < timingMode[1]) {

            cycleTime[1] = cycleTime[0];
            timingMode[1] = timingMode[0];

        } else {

            cycleTime[0] = cycleTime[1];
            timingMode[0] = timingMode[1];
        }
    }

    //
    // store the pio mode selected
    //
    for (i=0; i<MAX_IDE_DEVICE; i++) {

        if (XferMode->DevicePresent[i]) {
            XferMode->DeviceTransferModeSelected[i] = timingMode[i];
            newAcpiTimingSettings.Speed[i].Pio = cycleTime[i];

            if (i == 0) {
                newAcpiTimingSettings.Flags.b.IoChannelReady0 = XferMode->IoReadySupported[i];
            } else {
                newAcpiTimingSettings.Flags.b.IoChannelReady1 = XferMode->IoReadySupported[i];
            }

        } else {
            XferMode->DeviceTransferModeSelected[i] = 0;
        }
    }

    //
    // pick the device dma timing
    //
    for (i=0; i<MAX_IDE_DEVICE; i++) {

        ULONG mode;
        BOOLEAN useDma = TRUE;

        timingMode[i] = 0;
        cycleTime[i]= ACPI_XFER_MODE_NOT_SUPPORT;

        if (!XferMode->DevicePresent[i]) {
            continue;
        }

        //
        // check the acpi flag for ultra dma
        //
        if (i == 0) {

            useUdmaMode[i] = acpiTimingSettings->Flags.b.UltraDma0 ? TRUE: FALSE;

        } else {

            ASSERT (i==1);
            useUdmaMode[i] = acpiTimingSettings->Flags.b.UltraDma1 ? TRUE: FALSE;
        }

        //
        // get the dma timing specified in _GTM
        //
        dmaTiming = acpiTimingSettings->Speed[i].Dma;

        //
        // if dma is not supported, don't do anything, We have already set the PIO mode.
        //
        if (dmaTiming == ACPI_XFER_MODE_NOT_SUPPORT) {
            useUdmaMode[i]=0;
            useDma = FALSE;
            mode = PIO0;
        }


        // 
        // Find the highest UDMA mode
        //
        if (useUdmaMode[i]) {

            GetHighestDMATransferMode(XferMode->DeviceTransferModeSupported[i], mode);

            while (mode>= UDMA0) {
                if ((dmaTiming <= transferModeTimingTable[mode]) && 
                    (XferMode->DeviceTransferModeSupported[i] & (1<<mode))) {

                    timingMode[i] = 1<<mode;
                    cycleTime[i] = transferModeTimingTable[mode];
                    ASSERT(cycleTime[i]);

                    // we got a udma mode. so don't try to find a dma mode.
                    useDma = FALSE; 
                    break;
                } 
                mode--;
            }

        } 

        //
        // highest DMA mode
        // useDma is false only when either dma is not supported or an udma mode is
        // already selected.
        //
        if (useDma) {

            ULONG tempMode;

            // we shouldn't be using UDMA now.
            // this will set the flags for STM correctly.
            useUdmaMode[i]=FALSE;

            // mask out UDMA  and MWDMA0
            tempMode = XferMode->
                            DeviceTransferModeSupported[i] & (SWDMA_SUPPORT | MWDMA_SUPPORT);
            tempMode &= (~MWDMA_MODE0);

            GetHighestDMATransferMode(tempMode, mode);

            if (mode >= MWDMA1) {
                timingMode[i] = 1<<mode;
                cycleTime[i] = XferMode->BestMwDmaCycleTime[i];
                ASSERT(cycleTime[i]);
            } else if (mode == SWDMA2) {
                timingMode[i] = 1<<mode;
                cycleTime[i] = XferMode->BestSwDmaCycleTime[i];
                ASSERT(cycleTime[i]);
            } 
            // else don't do anything. PIO is already set

        }

    }

    if ((numDevices > 1) && !acpiTimingSettings->Flags.b.IndependentTiming) {

        //
        // pick the slower of the two timings
        // (the smaller timing mode value, the slower it is)
        //

        if (timingMode[0] < timingMode[1]) {

            cycleTime[1] = cycleTime[0];
            timingMode[1] = timingMode[0];

        } else {

            cycleTime[0] = cycleTime[1];
            timingMode[0] = timingMode[1];
        }

        //
        // both dma mode have to be the same
        // 
        if (useUdmaMode[0] != useUdmaMode[1]) {
            useUdmaMode[0] = 0;
            useUdmaMode[1] = 0;
        }
    }

    //
    // store the dma mode selected
    //
    for (i=0; i<MAX_IDE_DEVICE; i++) {

        if (XferMode->DevicePresent[i]) {

            XferMode->DeviceTransferModeSelected[i] |= timingMode[i];
            newAcpiTimingSettings.Speed[i].Dma = cycleTime[i];

            if (i==0) {
                newAcpiTimingSettings.Flags.b.UltraDma0 = useUdmaMode[i];
            } else {
                newAcpiTimingSettings.Flags.b.UltraDma1 = useUdmaMode[i];
            }
        }
    }

    if (fdoExtension->DmaDetectionLevel == DdlPioOnly) {

        //
        // remove all DMA modes
        //            
        for (i=0; i<MAX_IDE_DEVICE; i++) {

            XferMode->DeviceTransferModeSelected[i] &= PIO_SUPPORT;
        }
    }

    if ((acpiTimingSettings->Speed[0].Pio != ACPI_XFER_MODE_NOT_SUPPORT) ||
        (acpiTimingSettings->Speed[1].Pio != ACPI_XFER_MODE_NOT_SUPPORT)) {

        //
        // looks like we are on an ACPI machine and 
        // it supports IDE timing control method (_STM)
        //

        for (i=0; i<MAX_IDE_DEVICE; i++) {
    
            if (XferMode->DevicePresent[i]) {
    
                ataIdentifyData[i] = fdoExtension->HwDeviceExtension->IdentifyData + i;
            } else {
    
                ataIdentifyData[i] = NULL;
            }
        }        
    
        //
        // save the new timing settings
        //
        RtlCopyMemory (
            &fdoExtension->AcpiTimingSettings,
            &newAcpiTimingSettings, 
            sizeof(newAcpiTimingSettings));

        //
        // call ACPI to program the timing registers
        //
        status = ChannelSyncSetACPITimingSettings (
                     fdoExtension,
                     &newAcpiTimingSettings,
                     ataIdentifyData
                     );
    } else {

        //
        // legacy controller
        //
        for (i=0; i<MAX_IDE_DEVICE; i++) {
            XferMode->DeviceTransferModeSelected[i] &= PIO_SUPPORT;
        }

        status = STATUS_SUCCESS;
    }

    return status;
}


NTSTATUS
ChannelRestoreTiming (
    IN PFDO_EXTENSION FdoExtension,
    IN PSET_ACPI_TIMING_COMPLETION_ROUTINE CallerCompletionRoutine,
    IN PVOID CallerContext
    )
{
    ULONG i;
    PIDENTIFY_DATA ataIdentifyData[MAX_IDE_DEVICE];
    NTSTATUS status;

    PACPI_IDE_TIMING acpiTimingSettings;

    acpiTimingSettings = &FdoExtension->AcpiTimingSettings;

    if (FdoExtension->NumberOfLogicalUnits &&
        ((acpiTimingSettings->Speed[0].Pio != ACPI_XFER_MODE_NOT_SUPPORT) ||
         (acpiTimingSettings->Speed[1].Pio != ACPI_XFER_MODE_NOT_SUPPORT))) {

        //
        // looks like we are on an ACPI machine and 
        // it supports IDE timing control method (_STM)
        //

        for (i=0; i<MAX_IDE_DEVICE; i++) {
    
            if (FdoExtension->HwDeviceExtension->DeviceFlags[i] & 
                DFLAGS_DEVICE_PRESENT) {
    
                ataIdentifyData[i] = FdoExtension->HwDeviceExtension->IdentifyData + i;
            } else {
    
                ataIdentifyData[i] = NULL;
            }
        }        
    
        //
        // call ACPI to program the timing registers
        //
        status = ChannelSetACPITimingSettings (
                     FdoExtension,
                     acpiTimingSettings,
                     ataIdentifyData,
                     CallerCompletionRoutine,
                     CallerContext
                     );

    } else {

        //
        // non-acpi controller
        //
                                               
        if (FdoExtension->NumberOfLogicalUnits) {
            AtapiSyncSelectTransferMode (
                FdoExtension,
                FdoExtension->HwDeviceExtension,
                FdoExtension->TimingModeAllowed
                );
        }
        
        (*CallerCompletionRoutine) (
            FdoExtension->DeviceObject,
            STATUS_SUCCESS,
            CallerContext
        );
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
ChannelRestoreTimingCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PVOID Context
    )
{
    PIO_STACK_LOCATION thisIrpSp;
    PFDO_POWER_CONTEXT context = Context;
    PIRP originalPowerIrp;

    context->TimingRestored = TRUE;

    originalPowerIrp = context->OriginalPowerIrp;
    originalPowerIrp->IoStatus.Status = Status;

    thisIrpSp = IoGetCurrentIrpStackLocation(originalPowerIrp);

    //
    // finish off the original power irp
    // 
    FdoPowerCompletionRoutine (
        thisIrpSp->DeviceObject,
        originalPowerIrp,
        Context
        );

    //
    // continue with the irp completion
    //
    IoCompleteRequest (originalPowerIrp, IO_NO_INCREMENT);

    return Status;
}

 
NTSTATUS
ChannelFilterResourceRequirements (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS          status;
    PFDO_EXTENSION    fdoExtension;
    ULONG             i, j, k;
    IO_STACK_LOCATION irpSp;
    PCIIDE_XFER_MODE_INTERFACE xferModeInterface;

    PIO_RESOURCE_REQUIREMENTS_LIST  requirementsListIn;
    PIO_RESOURCE_LIST               resourceListIn;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptorIn;

    PIO_RESOURCE_DESCRIPTOR         cmdRegResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR         ctrlRegResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR         intRegResourceDescriptor;
    
    PIO_RESOURCE_REQUIREMENTS_LIST  requirementsListOut;
    ULONG                           requirementsListSizeOut;
    PIO_RESOURCE_LIST               resourceListOut;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptorOut;

    PAGED_CODE();
    
    //
    // the value will stay NULL if no filtering required
    //
    requirementsListOut = NULL;

#ifdef IDE_FILTER_PROMISE_TECH_RESOURCES                                        
    if (NT_SUCCESS(ChannelFilterPromiseTechResourceRequirements (DeviceObject, Irp))) {
        goto getout;
    }
#endif // IDE_FILTER_PROMISE_TECH_RESOURCES
    
    //
    // do a simple test to check if we have a pciidex parent
    //
    RtlZeroMemory (&irpSp, sizeof(irpSp));

    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCIIDE_XFER_MODE_INTERFACE;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (xferModeInterface);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) &xferModeInterface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    status = IdePortSyncSendIrp (fdoExtension->AttacheeDeviceObject, &irpSp, NULL);

    if (NT_SUCCESS(status)) {

        //
        // we have a pciidex as a parent.  it would
        // take care of the resource requirement
        // no need to filter
        //
        goto getout;
    }

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        ASSERT (Irp->IoStatus.Information);
        requirementsListIn = (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;

    } else {

        PIO_STACK_LOCATION thisIrpSp;

        thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
        requirementsListIn = thisIrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;
    }

    if (requirementsListIn == NULL) {
        goto getout;
    }

    if (requirementsListIn->AlternativeLists == 0) {
        goto getout;
    }
                
    requirementsListSizeOut = requirementsListIn->ListSize + 
                              requirementsListIn->AlternativeLists *
                              sizeof(IO_RESOURCE_DESCRIPTOR);

    requirementsListOut = ExAllocatePool (PagedPool, requirementsListSizeOut);
    if (requirementsListOut == NULL) {
        goto getout;
    }

    *requirementsListOut = *requirementsListIn;
    requirementsListOut->ListSize = requirementsListSizeOut;

    //
    // some init.
    //
    resourceListIn = requirementsListIn->List;
    resourceListOut = requirementsListOut->List;
    for (j=0; j<requirementsListIn->AlternativeLists; j++) {

        resourceDescriptorIn = resourceListIn->Descriptors;
        
        //
        // analyze what resources we are getting
        //
        cmdRegResourceDescriptor  = NULL;
        ctrlRegResourceDescriptor = NULL;
        intRegResourceDescriptor  = NULL;
        for (i=0; i<resourceListIn->Count; i++) {
    
            switch (resourceDescriptorIn[i].Type) {
                case CmResourceTypePort: {
    
                    if ((resourceDescriptorIn[i].u.Port.Length == 8) &&
                        (cmdRegResourceDescriptor == NULL)) {
    
                        cmdRegResourceDescriptor = resourceDescriptorIn + i;
    
                    } else if (((resourceDescriptorIn[i].u.Port.Length == 1) ||
                                (resourceDescriptorIn[i].u.Port.Length == 2) ||
                                (resourceDescriptorIn[i].u.Port.Length == 4)) &&
                               (ctrlRegResourceDescriptor == NULL)) {
    
                        ctrlRegResourceDescriptor = resourceDescriptorIn + i;
    
                    } else if ((resourceDescriptorIn[i].u.Port.Length >= 0x10) &&
                               (cmdRegResourceDescriptor == NULL) &&
                               (ctrlRegResourceDescriptor == NULL)) {
        
                        //
                        // probably pcmcia device.  it likes to combine
                        // both io ranges into 1.
                        //
                        cmdRegResourceDescriptor = resourceDescriptorIn + i;
                        ctrlRegResourceDescriptor = resourceDescriptorIn + i;
                    }
                }
                break;
    
                case CmResourceTypeInterrupt: {
    
                    if (intRegResourceDescriptor == NULL) {
    
                        intRegResourceDescriptor = resourceDescriptorIn + i;
                    }
                }
                break;
    
                default:
                break;
            }
        }
    
        //
        // making a new copy
        //                                                                 
        *resourceListOut = *resourceListIn;
        
        //
        // figure out what is missing
        //
        if (cmdRegResourceDescriptor &&
            ((cmdRegResourceDescriptor->u.Port.MaximumAddress.QuadPart -
              cmdRegResourceDescriptor->u.Port.MinimumAddress.QuadPart + 1) == 8) &&
            (ctrlRegResourceDescriptor == NULL)) {
    
            //
            // missing controller register resource descriptor.
            //
    
            resourceDescriptorOut = resourceListOut->Descriptors;
            for (i=0; i<resourceListOut->Count; i++) {
    
                *resourceDescriptorOut = resourceDescriptorIn[i];
                resourceDescriptorOut++;
    
                if ((resourceDescriptorIn + i) == cmdRegResourceDescriptor) {
    
                    //
                    // add the control register resource
                    //
                    *resourceDescriptorOut = resourceDescriptorIn[i];
                    resourceDescriptorOut->u.Port.Length = 1;
                    resourceDescriptorOut->u.Port.Alignment = 1;
                    resourceDescriptorOut->u.Port.MinimumAddress.QuadPart = 
                        resourceDescriptorOut->u.Port.MaximumAddress.QuadPart = 
                            cmdRegResourceDescriptor->u.Port.MinimumAddress.QuadPart + 0x206;
    
                    resourceDescriptorOut++;
                }
            }
    
            //
            // account for the new control register resource
            //
            resourceListOut->Count++;
            
        } else {
        
            resourceDescriptorOut = resourceListOut->Descriptors;
            k = resourceListOut->Count;
            for (i = 0; i < k; i++) {

                if (IsNEC_98) {
                    //
                    // NEC98 DevNode includes the ide rom memory resource.
                    // But it should be gotten by NTDETECT.COM&HAL.DLL, so ignore it here.
                    //
                    if ((resourceDescriptorIn[i].Type == CmResourceTypeMemory) &&
                        (resourceDescriptorIn[i].u.Memory.MinimumAddress.QuadPart == 0xd8000) &&
                        (resourceDescriptorIn[i].u.Memory.Length == 0x4000)) {

                        resourceListOut->Count--;
                        continue;
                    }
                }
    
                *resourceDescriptorOut = resourceDescriptorIn[i];
                resourceDescriptorOut++;
            }
        }
        
        resourceListIn = (PIO_RESOURCE_LIST) (resourceDescriptorIn + resourceListIn->Count);
        resourceListOut = (PIO_RESOURCE_LIST) resourceDescriptorOut;
    }        


getout:
    if (requirementsListOut) {

        if (NT_SUCCESS(Irp->IoStatus.Status)) {

            ExFreePool ((PVOID) Irp->IoStatus.Information);

        } else {

            Irp->IoStatus.Status = STATUS_SUCCESS;
        }
        Irp->IoStatus.Information = (ULONG_PTR) requirementsListOut;
    }

    return IdePortPassDownToNextDriver (DeviceObject, Irp);
}

static PCWSTR PcmciaIdeChannelDeviceId = L"PCMCIA\\*PNP0600";
            
BOOLEAN
ChannelQueryPcmciaParent (
    PFDO_EXTENSION FdoExtension
    )
{
    BOOLEAN           foundIt = FALSE;                              
    NTSTATUS          status;
    IO_STATUS_BLOCK   ioStatus;
    IO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    // do a simple test to check if we have a pciidex parent
    //
    RtlZeroMemory (&irpSp, sizeof(irpSp));

    irpSp.Parameters.QueryId.IdType = BusQueryHardwareIDs;
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_ID;

    ioStatus.Status = STATUS_NOT_SUPPORTED;
    status = IdePortSyncSendIrp (FdoExtension->AttacheeDeviceObject, &irpSp, &ioStatus);

    if (NT_SUCCESS(status)) {

        PWSTR wstr;
        UNICODE_STRING hwId;
        UNICODE_STRING targetId;
    
        RtlInitUnicodeString(
            &targetId,
            PcmciaIdeChannelDeviceId);
            
        wstr = (PWSTR) ioStatus.Information;
        while (*wstr) {
        
        	RtlInitUnicodeString(&hwId, wstr);
                     
            if (!RtlCompareUnicodeString(
                    &hwId,
                    &targetId,
                    FALSE)) {
                    
                ExFreePool ((PVOID) ioStatus.Information);
                DebugPrint ((DBG_PNP, "ATAPI: pcmcia parent\n"));
                return TRUE;                
            }                
            
            wstr += hwId.Length / sizeof(WCHAR);
            wstr++; // NULL character
        }
        ExFreePool ((PVOID) ioStatus.Information);
    }
    
    return FALSE;
}                                            

#ifdef IDE_FILTER_PROMISE_TECH_RESOURCES

static PCWSTR PromiseTechDeviceId[] = {
    L"ISAPNP\\BJB1000"
};
#define NUM_PROMISE_TECH_ID     (sizeof(PromiseTechDeviceId)/sizeof(PCWSTR))
            
NTSTATUS
ChannelFilterPromiseTechResourceRequirements (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    BOOLEAN           foundIt = FALSE;                              
    BOOLEAN           firstIrq = FALSE;                              
    ULONG             numExtraIoResDescriptor = 0;
    NTSTATUS          status;
    IO_STATUS_BLOCK   ioStatus;
    PFDO_EXTENSION    fdoExtension;
    ULONG             i, j, k;
    IO_STACK_LOCATION irpSp;
    PCIIDE_XFER_MODE_INTERFACE xferModeInterface;

    PIO_RESOURCE_REQUIREMENTS_LIST  requirementsListIn;
    PIO_RESOURCE_LIST               resourceListIn;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptorIn;
    PIO_RESOURCE_DESCRIPTOR         brokenResourceDescriptor;

    PIO_RESOURCE_DESCRIPTOR         cmdRegResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR         ctrlRegResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR         intRegResourceDescriptor;
    
    PIO_RESOURCE_REQUIREMENTS_LIST  requirementsListOut;
    ULONG                           requirementsListSizeOut;
    PIO_RESOURCE_LIST               resourceListOut;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptorOut;

    PAGED_CODE();

    //
    // the value will stay NULL if no filtering required
    //
    requirementsListOut = NULL;

    //
    // do a simple test to check if we have a pciidex parent
    //
    RtlZeroMemory (&irpSp, sizeof(irpSp));

    irpSp.Parameters.QueryId.IdType = BusQueryDeviceID;
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_ID;

    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    ioStatus.Status = STATUS_NOT_SUPPORTED;
    status = IdePortSyncSendIrp (fdoExtension->AttacheeDeviceObject, &irpSp, &ioStatus);

    if (NT_SUCCESS(status)) {

        UNICODE_STRING deviceId;
        UNICODE_STRING promiseTechDeviceId;
        
    	RtlInitUnicodeString(
    		&deviceId,
    		(PCWSTR) ioStatus.Information);
            
        for (i=0; i<NUM_PROMISE_TECH_ID && !foundIt; i++) {
        
    	    RtlInitUnicodeString(
    	    	&promiseTechDeviceId,
    	    	PromiseTechDeviceId[i]);
                
            if (deviceId.Length >= promiseTechDeviceId.Length) {
                deviceId.Length = promiseTechDeviceId.Length;
                if (!RtlCompareUnicodeString(
                        &promiseTechDeviceId,
                        &deviceId,
                        FALSE)) {
                        
                    foundIt = TRUE;                    
                }                    
            }                
        }
        
        ExFreePool ((PVOID) ioStatus.Information);
    }
    
    if (!foundIt) {
        goto getout;
    }

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        ASSERT (Irp->IoStatus.Information);
        requirementsListIn = (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;

    } else {

        PIO_STACK_LOCATION thisIrpSp;

        thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
        requirementsListIn = thisIrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;
    }

    if (requirementsListIn == NULL) {
        goto getout;
    }

    if (requirementsListIn->AlternativeLists == 0) {
        goto getout;
    }
                
    //
    // look for the bad resource descriptior
    //
    resourceListIn = requirementsListIn->List;
    brokenResourceDescriptor  = NULL;
    for (j=0; j<requirementsListIn->AlternativeLists; j++) {

        resourceDescriptorIn = resourceListIn->Descriptors;
        
        //
        // analyze what resources we are getting
        //
        for (i=0; i<resourceListIn->Count; i++) {
    
            switch (resourceDescriptorIn[i].Type) {
                case CmResourceTypePort: {
    
                    ULONG alignmentMask;
                    
                    alignmentMask = resourceDescriptorIn[i].u.Port.Alignment - 1;
                         
                    if (resourceDescriptorIn[i].u.Port.MinimumAddress.LowPart & alignmentMask) {
                    
                        //                                    
                        // broken resource requirement;
                        //
                        brokenResourceDescriptor = resourceDescriptorIn + i;
                    }                        
                }
                break;
    
                default:
                break;
            }
        }
    }
    
    if (brokenResourceDescriptor) {
    
        ULONG alignmentMask;
        PHYSICAL_ADDRESS minAddress;
        PHYSICAL_ADDRESS addressRange;
        
        alignmentMask = brokenResourceDescriptor->u.Port.Alignment - 1;
        alignmentMask = ~alignmentMask;
        
        minAddress = brokenResourceDescriptor->u.Port.MinimumAddress;
        minAddress.LowPart &= alignmentMask;
        
        addressRange.QuadPart = (brokenResourceDescriptor->u.Port.MaximumAddress.QuadPart - minAddress.QuadPart);
        numExtraIoResDescriptor = (ULONG) (addressRange.QuadPart / brokenResourceDescriptor->u.Port.Alignment);
    }
                                 
    requirementsListSizeOut = requirementsListIn->ListSize + 
                              numExtraIoResDescriptor *
                              sizeof(IO_RESOURCE_DESCRIPTOR);

    requirementsListOut = ExAllocatePool (PagedPool, requirementsListSizeOut);
    if (requirementsListOut == NULL) {
        goto getout;
    }

    *requirementsListOut = *requirementsListIn;
    requirementsListOut->ListSize = requirementsListSizeOut;

    //
    // some init.
    //
    resourceListIn = requirementsListIn->List;
    resourceListOut = requirementsListOut->List;
    for (j=0; j<requirementsListIn->AlternativeLists; j++) {

        resourceDescriptorIn = resourceListIn->Descriptors;
        
        //
        // making a new copy
        //                                                                 
        *resourceListOut = *resourceListIn;
        resourceListOut->Count = 0;
        
        //
        // analyze what resources we are getting
        //
        resourceDescriptorOut = resourceListOut->Descriptors;
        firstIrq = TRUE;
        for (i=0; i<resourceListIn->Count; i++) {
    
            switch (resourceDescriptorIn[i].Type) {
                case CmResourceTypePort: {
                
                    if ((resourceDescriptorIn + i == brokenResourceDescriptor) &&
                        (numExtraIoResDescriptor)) {
                        
                        for (k=0; k<numExtraIoResDescriptor; k++) {
                        
                            *resourceDescriptorOut = resourceDescriptorIn[i];
                            
                            if (k != 0) {
                            
                                resourceDescriptorOut->Option = IO_RESOURCE_ALTERNATIVE;
                            
                            }
                                                     
                            resourceDescriptorOut->u.Port.Alignment = 1;
                            resourceDescriptorOut->u.Port.MinimumAddress.QuadPart = 
                                brokenResourceDescriptor->u.Port.MinimumAddress.QuadPart + 
                                k * brokenResourceDescriptor->u.Port.Alignment;
                            resourceDescriptorOut->u.Port.MaximumAddress.QuadPart = 
                                resourceDescriptorOut->u.Port.MinimumAddress.QuadPart + 
                                resourceDescriptorOut->u.Port.Length - 1;
                                
                            resourceDescriptorOut++;                                
                            resourceListOut->Count++;
                        }
                        
                    } else {
                    
                        *resourceDescriptorOut = resourceDescriptorIn[i];
                        resourceDescriptorOut++;                                
                        resourceListOut->Count++;
                    }                        
                }
                break;
    
                case CmResourceTypeInterrupt: {
        
                    //
                    // keep all irqs except 9 which doesn't really work
                    //        
                    if (!((resourceDescriptorIn[i].u.Interrupt.MinimumVector == 0x9) &&
                         (resourceDescriptorIn[i].u.Interrupt.MaximumVector == 0x9))) {
                        
                        *resourceDescriptorOut = resourceDescriptorIn[i];
                        
                        if (firstIrq) {
                            resourceDescriptorOut->Option = 0;
                            firstIrq = FALSE;
                        } else {
                            resourceDescriptorOut->Option = IO_RESOURCE_ALTERNATIVE;
                        }
                        
                        resourceDescriptorOut++;                                
                        resourceListOut->Count++;
                    }
                }
                break;
                        
                default:
                *resourceDescriptorOut = resourceDescriptorIn[i];
                resourceDescriptorOut++;                                
                resourceListOut->Count++;
                break;
            }
        }
        resourceListIn = (PIO_RESOURCE_LIST) (resourceDescriptorIn + resourceListIn->Count);
        resourceListOut = (PIO_RESOURCE_LIST) resourceDescriptorOut;
    }        


getout:
    if (requirementsListOut) {

        if (NT_SUCCESS(Irp->IoStatus.Status)) {

            ExFreePool ((PVOID) Irp->IoStatus.Information);

        } else {

            Irp->IoStatus.Status = STATUS_SUCCESS;
        }
        Irp->IoStatus.Information = (ULONG_PTR) requirementsListOut;
        
        return STATUS_SUCCESS;
        
    } else {
    
        return STATUS_INVALID_PARAMETER;
    }
}
#endif // IDE_FILTER_PROMISE_TECH_RESOURCES

NTSTATUS
ChannelQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION fdoExtension;
    PPNP_DEVICE_STATE deviceState;

    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
 
    DebugPrint((DBG_PNP, "QUERY_DEVICE_STATE for FDOE 0x%x\n", fdoExtension));

    if(fdoExtension->PagingPathCount != 0) {
        deviceState = (PPNP_DEVICE_STATE) &(Irp->IoStatus.Information);
        SETMASK((*deviceState), PNP_DEVICE_NOT_DISABLEABLE);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoSkipCurrentIrpStackLocation (Irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\atapinit.h ===
#if !defined (___atapinit_h___)
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    atapinit.h

Abstract:

--*/
#define ___atapinit_h___

BOOLEAN
IdePortInitHwDeviceExtension (
    IN OUT PFDO_EXTENSION FdoExtension
    );
      
VOID
AnalyzeDeviceCapabilities(
    IN OUT PFDO_EXTENSION FdoExtension,
    IN BOOLEAN            MustBePio[MAX_IDE_DEVICE * MAX_IDE_LINE]
    );
      
VOID
AtapiSyncSelectTransferMode (
    IN PFDO_EXTENSION FdoExtension,
    IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
    IN ULONG TimingModeAllowed[MAX_IDE_TARGETID * MAX_IDE_LINE]
    );
      
BOOLEAN
AtapiFindDevices(
    IN PFDO_EXTENSION FdoExtension,
    IN OUT PVOID HwDeviceExtension
    );
    
BOOLEAN
AtapiDMACapable (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN ULONG deviceNumber
    );

IDE_DEVICETYPE
AtapiDetectDevice (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN OUT PPDO_EXTENSION PdoExtension,
    IN OUT PIDENTIFY_DATA IdentifyData,
    IN     BOOLEAN          MustSucceed
    );
    
NTSTATUS
IdePortSelectCHS (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN ULONG              Device,
    IN PIDENTIFY_DATA     IdentifyData
    );

NTSTATUS
IdePortScanBus (
    IN OUT PFDO_EXTENSION FdoExtension
    );
    
#endif // ___atapinit_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\crashdmp.h ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    crashdmp.h

Abstract:

--*/

#if !defined (___crashdmp_h___)
#define ___crashdmp_h___

typedef
VOID
(*PSTALL_ROUTINE) (
    IN ULONG Delay
    );
     
typedef struct _CRASHDUMP_INIT_DATA {

    ULONG               CheckSum;

    UCHAR               PathId;
    UCHAR               TargetId;
    UCHAR               Lun;

    PHW_DEVICE_EXTENSION LiveHwDeviceExtension;

} CRASHDUMP_INIT_DATA, *PCRASHDUMP_INIT_DATA;
      
typedef struct _CRASHDUMP_DATA {

    PCRASHDUMP_INIT_DATA    CrashInitData;

    ULONG                   BytesPerSector;

    LARGE_INTEGER           PartitionOffset;

    PSTALL_ROUTINE          StallRoutine;

    SCSI_REQUEST_BLOCK      Srb;

    HW_DEVICE_EXTENSION     HwDeviceExtension;

    ULONG                   MaxBlockSize;

} CRASHDUMP_DATA, *PCRASHDUMP_DATA;

ULONG
AtapiCrashDumpDriverEntry (
    PVOID Context
    );

//
// crash dump privates
//
BOOLEAN
AtapiCrashDumpOpen (
    IN LARGE_INTEGER PartitionOffset
    );

NTSTATUS
AtapiCrashDumpIdeWrite (
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    );

VOID
AtapiCrashDumpFinish (
    VOID
    );
                         
NTSTATUS
AtapiCrashDumpIdeWritePio (
    IN PSCSI_REQUEST_BLOCK Srb
    );

#endif // ___crashdmp_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\crashdmp.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       crashdmp.c
//
//--------------------------------------------------------------------------

//#include "stddef.h"
//#include "stdarg.h"
//#include "stdio.h"
//#include <excpt.h>
//#include <ntdef.h>
//#include <ntstatus.h>
//#include <bugcodes.h>
//#include <exlevels.h>
//#include <ntiologc.h>
//#include <ntos.h>
//#include <pci.h>
//#include "io.h"
//#include "scsi.h"
//#include <ntddscsi.h>
//#include <ntdddisk.h>
//#include <string.h>
//#include "stdio.h"
//
//#ifdef ACPI_CONTROL_METHOD_SUPPORT
////
//// for ACPI
////
//#include "acpiioct.h"
//#endif // ACPI_CONTROL_METHOD_SUPPORT
//
//#include "ide.h"
//
////
//// predefine structure pointer type to prevent
//// constant re-ordering of include files
////
//typedef struct _FDO_EXTENSION * PFDO_EXTENSION;
//typedef struct _PDO_EXTENSION * PPDO_EXTENSION;
//typedef struct _DEVICE_SETTINGS * PDEVICE_SETTINGS;
//
//#include "acpiutil.h"
//#include "port.h"
//#include "chanfdo.h"
//#include "detect.h"
//#include "atapi.h"
//#include "devpdo.h"
//#include "regutils.h"
//#include "atapinit.h"
//#include "luext.h"
//#include "fdopower.h"
//#include "pdopower.h"
//#include "hack.h"
//#include "crashdmp.h"
//#include "idedata.h"
//
//#include "ntddstor.h"

#include <ntosp.h>

#include "io.h"
#include "ideport.h"

NTSTATUS
AtapiCrashDumpIdeWriteDMA (
    IN LONG Action,
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl,
    IN PVOID LocalData
    );

VOID
AtapiCrashDumpBmCallback (
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
//
// All the crash dump code can be marked "INIT".
// during crash dump or hibernate dump, a new copy
// of this driver gets loaded and its INIT code
// doesn't get thrown away when DriverEnry returns
//
#pragma alloc_text(INIT, AtapiCrashDumpDriverEntry)
#pragma alloc_text(INIT, AtapiCrashDumpOpen)
#pragma alloc_text(INIT, AtapiCrashDumpIdeWrite)
#pragma alloc_text(INIT, AtapiCrashDumpFinish)
#pragma alloc_text(INIT, AtapiCrashDumpBmCallback)
#pragma alloc_text(INIT, AtapiCrashDumpIdeWriteDMA)
#endif // ALLOC_PRAGMA


ULONG
AtapiCrashDumpDriverEntry (
    PVOID Context
    )
/*++

Routine Description:

    dump driver entry point

Arguments:

    Context - PCRASHDUMP_INIT_DATA

Return Value:

    NT Status

--*/
{
    PDUMP_INITIALIZATION_CONTEXT context = Context;

    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Entering AtapiCrashDumpDriverEntry...\n"));

    //
    // Put away what we need later
    //
    DumpData.CrashInitData = (PCRASHDUMP_INIT_DATA) context->PortConfiguration;
    DumpData.StallRoutine  = context->StallRoutine;

    //
    // return our dump interface
    //
    context->OpenRoutine    = AtapiCrashDumpOpen;
    context->WriteRoutine   = AtapiCrashDumpIdeWrite;
    context->FinishRoutine  = AtapiCrashDumpFinish;
    context->WritePendingRoutine = AtapiCrashDumpIdeWriteDMA;


    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Leaving AtapiCrashDumpDriverEntry...\n"));

    return STATUS_SUCCESS;
}

BOOLEAN
AtapiCrashDumpOpen (
    IN LARGE_INTEGER PartitionOffset
    )
{
    ULONG i;
    PHW_DEVICE_EXTENSION        hwExtension; 
    PPCIIDE_BUSMASTER_INTERFACE bmInterface;

    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Entering AtapiCrashDumpOpen...PartitionOffset = 0x%x%08x...\n", PartitionOffset.HighPart, PartitionOffset.LowPart));

    // if we are crashdumping, reset the cotroller - Not necessary

    //
    // ISSUE 08/26/2000: Check for disk signature - Why?
    //
    DumpData.PartitionOffset = PartitionOffset;

    RtlMoveMemory (
        &DumpData.HwDeviceExtension,
        DumpData.CrashInitData->LiveHwDeviceExtension,
        sizeof (HW_DEVICE_EXTENSION)
        );

  //  for (i=0; i<DumpData.HwDeviceExtension.MaxIdeDevice; i++) {

//
// AKadatch: we may use DMA and will use DMA if its available
// Do it in AtapiCrashDumpIdeWrite instead
//        CLRMASK (DumpData.HwDeviceExtension.DeviceFlags[i], DFLAGS_USE_DMA);


        DumpData.HwDeviceExtension.CurrentSrb             = NULL;
        DumpData.HwDeviceExtension.DataBuffer             = NULL;
        DumpData.HwDeviceExtension.BytesLeft              = 0;
        DumpData.HwDeviceExtension.ExpectingInterrupt     = FALSE;
        DumpData.HwDeviceExtension.DMAInProgress          = FALSE;
        DumpData.HwDeviceExtension.DriverMustPoll         = TRUE;
   // }

    DumpData.BytesPerSector = 512;
    DumpData.MaxBlockSize = DumpData.BytesPerSector * 256;

    hwExtension = &DumpData.HwDeviceExtension;
    bmInterface = &(hwExtension->BusMasterInterface);

    if (bmInterface->BmCrashDumpInitialize) {
        bmInterface->BmCrashDumpInitialize(bmInterface->Context);
    } else {

        // Don't use DMA
        for (i=0; i<DumpData.HwDeviceExtension.MaxIdeDevice; i++) {
            CLRMASK (DumpData.HwDeviceExtension.DeviceFlags[i], DFLAGS_USE_DMA);
            CLRMASK (DumpData.HwDeviceExtension.DeviceFlags[i], DFLAGS_USE_UDMA);
        }

    }

    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Leaving AtapiCrashDumpOpen...\n"));
    return TRUE;
}

NTSTATUS
AtapiCrashDumpIdeWrite (
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    )
{
    SCSI_REQUEST_BLOCK  SrbData;    // Store Srb on stack, don't modify memory!
    ULONG               retryCount;
    ULONG               srbStatus;
    NTSTATUS            status;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    ULONG               blockOffset;
    ULONG               blockCount;
    ULONG               blockSize;
    ULONG               bytesWritten;
    UCHAR               ideStatus;
    ULONG               i;
    ULONG               writeMulitpleBlockSize;

    for (i=0; i<DumpData.HwDeviceExtension.MaxIdeDevice; i++) {
        CLRMASK (DumpData.HwDeviceExtension.DeviceFlags[i], DFLAGS_USE_DMA);
    }

    DebugPrint((DBG_CRASHDUMP,
               "AtapiCrashDumpWrite: Write memory at 0x%x for 0x%x bytes\n",
                Mdl->MappedSystemVa,
                Mdl->ByteCount));

    if (Mdl->ByteCount % DumpData.BytesPerSector) {

        //
        // must be complete sectors
        //
        DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpWrite ERROR: not writing full sectors\n"));

        return STATUS_INVALID_PARAMETER;
    }

    if ((Mdl->ByteCount / DumpData.BytesPerSector) > 256) {

        //
        // need code to split request up
        //
        DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpWrite ERROR: can't handle large write\n"));

        return STATUS_INVALID_PARAMETER;
    }

    //
    // get the WRITE MULTIPLE blocksize per interrupt for later use
    //
    if (DumpData.HwDeviceExtension.MaximumBlockXfer[DumpData.CrashInitData->TargetId]) {

        writeMulitpleBlockSize =
            DumpData.HwDeviceExtension.
                MaximumBlockXfer[DumpData.CrashInitData->TargetId] *
            DumpData.BytesPerSector;

    } else {

        writeMulitpleBlockSize = 1 * DumpData.BytesPerSector;
    }

    srb = &SrbData;
    cdb = (PCDB)srb->Cdb;

    //
    // Zero SRB.
    //
    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Initialize SRB.
    //

    srb->Length   = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId   = DumpData.CrashInitData->PathId;
    srb->TargetId = DumpData.CrashInitData->TargetId;
    srb->Lun      = DumpData.CrashInitData->Lun;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SrbFlags = SRB_FLAGS_DATA_OUT |
                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT |
                    SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 10;
    srb->CdbLength = 10;

    //
    // Initialize CDB for write command.
    //
    cdb->CDB10.OperationCode = SCSIOP_WRITE;

    MARK_SRB_FOR_PIO(srb);

    bytesWritten = 0;
    do {

        if ((Mdl->ByteCount - bytesWritten) > DumpData.MaxBlockSize) {

            blockSize = DumpData.MaxBlockSize;
            DebugPrint ((DBG_CRASHDUMP, "ATAPI: AtapiCrashDumpWrite: can't do a single write...\n"));

        } else {

            blockSize = Mdl->ByteCount - bytesWritten;
        }

        blockCount =  blockSize / DumpData.BytesPerSector;

        status = STATUS_UNSUCCESSFUL;
        for (retryCount=0; (retryCount<2) && !NT_SUCCESS(status); retryCount++) {

            srb->DataTransferLength = blockSize;
            srb->DataBuffer = ((PUCHAR) Mdl->MappedSystemVa) + bytesWritten;

            //
            // Convert disk byte offset to block offset.
            //

            blockOffset = (ULONG)((DumpData.PartitionOffset.QuadPart +
                                  (*DiskByteOffset).QuadPart +
                                  (ULONGLONG) bytesWritten) / DumpData.BytesPerSector);

            //
            // Fill in CDB block address.
            //

            cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&blockOffset)->Byte3;
            cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&blockOffset)->Byte2;
            cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&blockOffset)->Byte1;
            cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&blockOffset)->Byte0;

            cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&blockCount)->Byte1;
            cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&blockCount)->Byte0;


            status = AtapiCrashDumpIdeWritePio(srb);

            if (NT_SUCCESS(status)) {

                bytesWritten += blockSize;
            }

        }

        if (!NT_SUCCESS(status)) {

            IdeHardReset (
                &DumpData.HwDeviceExtension.BaseIoAddress1,
                &DumpData.HwDeviceExtension.BaseIoAddress2,
                TRUE,
                TRUE
                );

            //
            // model:    WDC AC31000H
            // version:  19.19E22
            // serial #: DWW-2T27518018 6
            //
            // found out this device can't handle WRITE with more sectors than 16,
            // the blocks per interrupt setting in ID data word 59.
            //
            // Therefore, it we see an error, we will change to blocksize to it.
            // If it still fails, we will keep shrinking the blocksize by half
            // until it gets to zero.  Then, we will return an error
            //

            //
            // last write fail, try a smaller block size
            //
            if (blockSize > writeMulitpleBlockSize) {

                blockSize = writeMulitpleBlockSize;
            } else {

                blockSize /= 2;
            }

            if (blockSize) {

                DebugPrint ((DBG_ALWAYS, "ATAPI: AtapiCrashDumpWrite max write block size is down to 0x%x\n", blockSize));
                DumpData.MaxBlockSize = blockSize;

            } else {

                break;
            }
        }

    } while (bytesWritten < Mdl->ByteCount);

    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Leaving AtapiCrashDumpWrite...\n"));
    return status;
}

VOID
AtapiCrashDumpFinish (
    VOID
    )
{
    SCSI_REQUEST_BLOCK  SrbData;    // Store Srb on stack, don't modify memory!
    PSCSI_REQUEST_BLOCK srb = &SrbData;
    PCDB                cdb;
    ULONG               srbStatus;
    ATA_PASS_THROUGH    ataPassThroughData;
    UCHAR               flushCommand;
	UCHAR ideStatus = 0;

    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Entering AtapiCrashDumpFinish...\n"));

    flushCommand =
        DumpData.HwDeviceExtension.DeviceParameters[DumpData.CrashInitData->TargetId].IdeFlushCommand;

    if (flushCommand != IDE_COMMAND_NO_FLUSH) {

        WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);

        //
        // Zero SRB and ATA_PASS_THROUGH
        //
        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));
        RtlZeroMemory(&ataPassThroughData, sizeof(ATA_PASS_THROUGH));

        //
        // Initialize SRB.
        //
        srb->Length   = sizeof(SCSI_REQUEST_BLOCK);
        srb->PathId   = DumpData.CrashInitData->PathId;
        srb->TargetId = DumpData.CrashInitData->TargetId;
        srb->Lun      = DumpData.CrashInitData->Lun;
        srb->Function = SRB_FUNCTION_ATA_PASS_THROUGH;
        srb->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                        SRB_FLAGS_DISABLE_DISCONNECT;
        srb->SrbStatus = srb->ScsiStatus = 0;
        srb->NextSrb = 0;
        srb->TimeOutValue = 10;
        srb->CdbLength = 10;
        srb->DataTransferLength = sizeof (ataPassThroughData);

        srb->DataBuffer = &ataPassThroughData;

        ataPassThroughData.IdeReg.bCommandReg = flushCommand;

        ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;

        srbStatus = IdeSendPassThroughCommand(
                        &DumpData.HwDeviceExtension,
                        srb
                        );

        if (srbStatus == SRB_STATUS_PENDING) {

            UCHAR ideStatus;

            WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);

            DebugPrint ((DBG_ALWAYS, "flush = 0x%x, status = 0x%x...\n", flushCommand, ideStatus));

        } else if (srbStatus != SRB_STATUS_SUCCESS) {

            DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpFinish: flush failed...\n"));
        }
    }

    //
    // issue an standby to park the drive head
    //
    srb = &DumpData.Srb;

    //
    // Zero SRB and ATA_PASS_THROUGH
    //
    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));
    RtlZeroMemory(&ataPassThroughData, sizeof(ATA_PASS_THROUGH));

    //
    // Initialize SRB.
    //
    srb->Length   = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId   = DumpData.CrashInitData->PathId;
    srb->TargetId = DumpData.CrashInitData->TargetId;
    srb->Lun      = DumpData.CrashInitData->Lun;
    srb->Function = SRB_FUNCTION_ATA_PASS_THROUGH;
    srb->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 10;
    srb->CdbLength = 10;
    srb->DataTransferLength = sizeof (ataPassThroughData);

    srb->DataBuffer = &ataPassThroughData;

    ataPassThroughData.IdeReg.bCommandReg = IDE_COMMAND_STANDBY_IMMEDIATE;
    ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;

    srbStatus = IdeSendPassThroughCommand(
                    &DumpData.HwDeviceExtension,
                    srb
                    );

    if (srbStatus == SRB_STATUS_PENDING) {


        WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);

        WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);

        WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);

    } else if (srbStatus != SRB_STATUS_SUCCESS) {

        DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpFinish: flush failed...\n"));
    }


	//
	//the disk will be powered off.
	//

    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Leaving AtapiCrashDumpFinish...\n"));
    return;
}





/* ---------------------------- DMA --------------------------- */
/*                              ---                             */

VOID
AtapiCrashDumpBmCallback (
  IN PVOID Context
)
{
  // Just to make BmSetup happy -- it must be supplied
}


// Local variables that needs to be preserved across the calls
#define ENUM_DUMP_LOCALS(X) \
    X(LARGE_INTEGER,       DiskByteOffset) \
    X(PSCSI_REQUEST_BLOCK, srb) \
    X(PCDB,                cdb) \
    X(PMDL,                Mdl) \
    X(ULONG,               blockSize) \
    X(ULONG,               bytesWritten)

// States
#define STATE_READY       0
#define STATE_WAIT_DMA    1
#define STATE_WAIT_IDE    2
#define STATE_BAD_DMA     3
#define STATE_IO_FAIL     4

#define DMA_MAGIC   'XDma'

typedef struct
{
  UCHAR RegionDescriptorTablePage[PAGE_SIZE];

  LONG State;
  LONG Magic;

  SCSI_REQUEST_BLOCK Srb;

  PMDL Mdl;

  LARGE_INTEGER DiskByteOffset;

  ULONG BytesWritten;

  ULONG RetryCount;

  // Keep contents of BusMasterInterface.Context in safe place because
  // originally it's stored in memory that's saved by hibernation.
  // Unfortunately, BmSetup saves its arguments in PdoContext thus
  // constantly modifying memory. Special troubleshooting code in
  // po\hiber.c detects and reports such memory changes, and despite in this
  // case it's absolutely harmless it's better be avoided.

  PVOID BmContext;
  UCHAR BmContextBuffer[1024];
}
DUMP_LOCALS;

BOOLEAN
AtapiCrashDumpInterrupt(
    PVOID DeviceExtension
    )
/*++

  Routine Description:
  
    This is the ISR for crashdump. Should be called in a polling mode and works
    only for DMA requests. Doesn't need any of the flags, since we get called 
    in a synchronized manner.
    
  Arguments:
  
    DeviceExtension : The hardware device extension.
    
  Return Value:
  
    TRUE : if it is our interrupt.
    FALSE : if it is not our interrupt or if there are no pending requests.        
    
--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = DeviceExtension;
    PPCIIDE_BUSMASTER_INTERFACE bmInterface = &deviceExtension->BusMasterInterface;
    PIDE_REGISTERS_1 baseIoAddress1 = &DumpData.HwDeviceExtension.BaseIoAddress1;
    PIDE_REGISTERS_2 baseIoAddress2 = &DumpData.HwDeviceExtension.BaseIoAddress2;
    PSCSI_REQUEST_BLOCK srb;
    BMSTATUS bmStatus;
    UCHAR statusByte;
    ULONG i;
    ULONG status;

    //
    // This interface should exist
    //
    ASSERT(bmInterface->BmStatus);

    //
    // poll the bus master status register
    //
    bmStatus = bmInterface->BmStatus(bmInterface->Context);

    //
    // return false if it is not our interrupt
    //
    if (!(bmStatus & BMSTATUS_INTERRUPT)) {

        DebugPrint((DBG_CRASHDUMP,
                    "Not our interrupt\n"
                    ));

        return FALSE;
    }

    //
    // Some VIA motherboards do not work without it
    //
    KeStallExecutionProcessor (5);

    //
    // disarm DMA and clear bus master interrupt
    //
    bmInterface->BmDisarm(bmInterface->Context);

    //
    // Get the current request
    //
    srb = deviceExtension->CurrentSrb;

    //
    // we will return false if there are no pending requests
    //
    if (srb == NULL) {

        DebugPrint((DBG_CRASHDUMP,
                    "No pending request\n"
                    ));

        return FALSE;
    }
    
    //
    // ignore the dma active bit
    //
    if (bmInterface->IgnoreActiveBitForAtaDevice) {
        CLRMASK (bmStatus, BMSTATUS_NOT_REACH_END_OF_TRANSFER);
    }

    //
    // Select IDE line(Primary or Secondary).
    //
    SelectIdeLine(baseIoAddress1, srb->TargetId >> 1);

    //
    // Clear interrupt by reading status.
    //
    GetBaseStatus(baseIoAddress1, statusByte);

    //
    // should be an ATA device
    //
    ASSERT(!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE));

    //
    // Check for error conditions.
    //
    if (statusByte & IDE_STATUS_ERROR) {

        //
        // Fail this request.
        //
        status = SRB_STATUS_ERROR;
        goto CompleteRequest;
    }

    WaitOnBusyUntil(baseIoAddress1, statusByte, 500);

    ASSERT(!(statusByte & IDE_STATUS_BUSY));

    //
    // interrupt indicates that the dma engine has finished the transfer
    //
    deviceExtension->BytesLeft = 0;

    //
    // bmStatus is initalized eariler.
    //
    if (!BMSTATUS_SUCCESS(bmStatus)) {

        if (bmStatus & BMSTATUS_ERROR_TRANSFER) {

            status = SRB_STATUS_ERROR;
        }

        if (bmStatus & BMSTATUS_NOT_REACH_END_OF_TRANSFER){

            status = SRB_STATUS_DATA_OVERRUN;
        }
    } else {

        status = SRB_STATUS_SUCCESS;
    }



CompleteRequest:

    //
    // should we translate the srb error
    // and a complicated retry mechanism.
    //

    //
    // check if drq is still up
    //
    i=0;
    while (statusByte & IDE_STATUS_DRQ) {

        GetStatus(baseIoAddress1,statusByte);

        i++;

        if (i > 5) {

            status = SRB_STATUS_BUSY;
        }

        KeStallExecutionProcessor(100);
    }

    //
    // check if the device is busy
    //
    if (statusByte & IDE_STATUS_BUSY) {

        status = SRB_STATUS_BUSY;

    }

    //
    // Set the srb status
    //
    srb->SrbStatus = (UCHAR)status;

    //
    // request is done.
    //
    deviceExtension->CurrentSrb = NULL;

    return TRUE;

}

NTSTATUS
AtapiCrashDumpIdeWriteDMA (
    IN LONG Action,
    IN PLARGE_INTEGER ArgDiskByteOffset,
    IN PMDL ArgMdl,
    IN PVOID LocalData
    )
/*++

  Routine Description:
    Asynchronous DMA write routine.

  Arguments:

    Action        - one of following:
        IO_DUMP_WRITE_INIT    - Initialize LocalData (must be first call)
        IO_DUMP_WRITE_FULFILL - Perform IO and wait until completion
        IO_DUMP_WRITE_START   - Start IO and return ASAP
        IO_DUMP_WRITE_RESUME  - Resume previousely started IO
        IO_DUMP_WRITE_FINISH  - Complete previous IO request (wait if necessary)

        Attention! It is caller's responsibility to make sure that
          a) WriteDMA is always called with absolutely the same value of LocalData
          b) Contents of *ArgMdl will be preserved between Start/Resume/Finish
          c) Memory given by ArgMdl is not modified until the end of operation

    ArgDiskByteOffset - Offset on hard disk in bytes

    ArgMdl            - MDL giving output memory layout
        Attn: for DMA the best IO size is 4 KB; for PIO the more the better
            
    LocalData         - Memory region where WriteDMA will keep all the data
                        that need to be preserved between Start/Resume/Finish.
         Attn: this region shall be of at least IO_DUMP_WRITE_DATA_SIZE bytes,
               and it must be page-aligned

  Return Value:

    STATUS_SUCCESS      - operation completed successfully
    STATUS_PENDING      - operation started but not completed yet
    STATUS_UNSUCCESSFUL - operation failed; use of WriteRoutine (PIO-based IO) adviced
                          (however if user will keep on using WriteDMA it will redirect
                          all requests to PIO itself)
    STATUS_INVALID_PARAMETER - previously started operation wasn't finished, or
                          incorrect parameter indeed
--*/
{

    DUMP_LOCALS                 *Locals = LocalData;
    PHW_DEVICE_EXTENSION        hwExtension = &DumpData.HwDeviceExtension;
    PPCIIDE_BUSMASTER_INTERFACE bmInterface = &hwExtension->BusMasterInterface;
    LONG                        targetId = DumpData.CrashInitData->TargetId;
    PSCSI_REQUEST_BLOCK         srb;
    NTSTATUS                    status;
    ULONG                       srbStatus;
    BMSTATUS                    bmStatus;
    ULONG                       i;
    PCDB                        cdb;
    UCHAR                       statusByte;
    PMDL                        mdl;
    BOOLEAN                     interruptCleared;
    BOOLEAN                     usePio;

    if (IO_DUMP_WRITE_DATA_SIZE < sizeof (*Locals)) {
        DebugPrint ((DBG_CRASHDUMP, "AtapiCrashDumpIdeWriteDMA: IO_DUMP_WRITE_DATA_SIZE = %d, sizeof (*Locals) == %d\n",
                     IO_DUMP_WRITE_DATA_SIZE, sizeof (*Locals)));
        return STATUS_INVALID_PARAMETER;
    }

    switch (Action) {
        case IO_DUMP_WRITE_INIT:

            //
            // initalize the state to bad_dma
            //
            Locals->State = STATE_BAD_DMA;
            Locals->Magic = 0;

            //
            // Check alignment
            //
            if (((ULONG_PTR) Locals) & (PAGE_SIZE-1)) {
                DebugPrint ((DBG_CRASHDUMP, "AtapiCrashDumpIdeWriteDMA: misaligned Locals = %p\n", Locals));
                return STATUS_UNSUCCESSFUL;
            }


            //
            // Make sure we may use UDMA; do not try to use pure DMA --
            // it won't work on some machines (e.g. Compaq Armada 7800)
            //
            if (!(hwExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT) ||
                !(hwExtension->DeviceParameters[targetId].TransferModeSupported & UDMA_SUPPORT) ||
                !(hwExtension->DeviceParameters[targetId].TransferModeSelected & UDMA_SUPPORT) ||
                !(hwExtension->DeviceFlags[targetId] & DFLAGS_USE_UDMA) ||
                bmInterface->MaxTransferByteSize <= 0
               ) {
                DebugPrint ((DBG_CRASHDUMP, "AtapiCrashDumpIdeWriteDMA: UDMA is not available\n"));
                return STATUS_UNSUCCESSFUL;
            }



            //
            // Copy contents of BusMasterInterface.Context to safe place and
            // substitute the pointer. Bm* functions change its contents
            //
            ASSERT(bmInterface->ContextSize > 0);
            ASSERT(bmInterface->ContextSize < sizeof(Locals->BmContextBuffer));

            //
            // make sure we can copy the context to the local buffer
            //
            if ((bmInterface->ContextSize <=0) ||
                (bmInterface->ContextSize > sizeof(Locals->BmContextBuffer))) {

                return STATUS_UNSUCCESSFUL;

            }

            //
            // Save BM context in modifyable memory: 
            // Bm* functions change its contents
            //
            Locals->BmContext = bmInterface->Context;
            RtlCopyMemory (&Locals->BmContextBuffer, Locals->BmContext, bmInterface->ContextSize);


            //
            // Check version of PCIIDEX.SYS
            //
            ASSERT(bmInterface->BmSetupOnePage);


            //
            // OK, now we are ready to use DMA
            //
            Locals->Magic = DMA_MAGIC;
            Locals->State = STATE_READY;

            return STATUS_SUCCESS;

        case IO_DUMP_WRITE_START:
        case IO_DUMP_WRITE_FULFILL:

            //
            // Make sure it was properly initialized
            //
            if (Locals->Magic != DMA_MAGIC) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Do not call DMA if it failed once -- use PIO
            //
            if (Locals->State == STATE_BAD_DMA) {
                return AtapiCrashDumpIdeWrite (ArgDiskByteOffset, ArgMdl);
            }

            //
            // Caller did not complete prev IO
            //
            if (Locals->State != STATE_READY) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Copy arguments into local variables
            //
            Locals->DiskByteOffset = *ArgDiskByteOffset;
            Locals->Mdl = ArgMdl;
            Locals->RetryCount = 0;

            srb = &Locals->Srb;
            mdl = Locals->Mdl;


            //
            // must be complete sectors
            //
            if (mdl->ByteCount % DumpData.BytesPerSector) {

                DebugPrint ((DBG_CRASHDUMP, 
                             "AtapiCrashDumpWriteDMA ERROR: not writing full sectors\n"
                             ));

                return STATUS_INVALID_PARAMETER;
            }

            //
            // need code to split request up
            //
            if ((mdl->ByteCount / DumpData.BytesPerSector) > 256) {

                DebugPrint ((DBG_CRASHDUMP, 
                             "AtapiCrashDumpWriteDMA ERROR: can't handle large write\n"
                             ));

                return STATUS_INVALID_PARAMETER;
            }

            //
            // use modifiable memory
            //
            bmInterface->Context = &Locals->BmContextBuffer;

            //
            // Zero SRB.
            //
            RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

            //
            // Initialize SRB.
            //
            srb->Length   = sizeof(SCSI_REQUEST_BLOCK);
            srb->PathId   = DumpData.CrashInitData->PathId;
            srb->TargetId = (UCHAR) targetId;
            srb->Lun      = DumpData.CrashInitData->Lun;
            srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
            srb->SrbFlags = SRB_FLAGS_DATA_OUT |
                            SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                            SRB_FLAGS_DISABLE_DISCONNECT |
                            SRB_FLAGS_DISABLE_AUTOSENSE;
            srb->SrbStatus = srb->ScsiStatus = 0;
            srb->NextSrb = 0;
            srb->TimeOutValue = 10;
            srb->CdbLength = 10;

            cdb = (PCDB)srb->Cdb;

            //
            // Initialize CDB for write command.
            //
            cdb->CDB10.OperationCode = SCSIOP_WRITE;

            //
            // Mark it for DMA
            //
            MARK_SRB_FOR_DMA (srb);

            hwExtension->CurrentSrb = srb;

            break;


        case IO_DUMP_WRITE_RESUME:
        case IO_DUMP_WRITE_FINISH:

            //
            // Make sure it was properly initialized
            //
            if (Locals->Magic != DMA_MAGIC) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // restore the local variables from scratch memory
            //
            srb = &Locals->Srb;
            mdl = Locals->Mdl;

            //
            // Resume/finish operation
            //

            if (Locals->State == STATE_READY) {

                //
                // we are done. return success
                //
                return(STATUS_SUCCESS);

            }

            if (Locals->State == STATE_WAIT_DMA) {

                //
                // Restore CurrentSrb 
                // (it should be reset back to NULL on return)
                //
                hwExtension->CurrentSrb = srb;
                bmInterface->Context = &Locals->BmContextBuffer;

                goto WaitDma;
            }

            //
            // if any of the DMA operations failed, we would have used
            // PIO. PIO would have completed the transfer, so just return
            // status success.
            //
            if (Locals->State == STATE_BAD_DMA) {

                return STATUS_SUCCESS;
            }

            //
            // wrong state
            //
            DebugPrint((DBG_ALWAYS,
                        "Wrong local state 0x%x\n",
                        Locals->State
                        ));

            ASSERT(FALSE);

            return(STATUS_INVALID_PARAMETER);

        default:

            DebugPrint ((DBG_CRASHDUMP, "AtapiCrashDumpIdeWriteDMA: Wrong Action = %d\n", Action));
            return STATUS_INVALID_PARAMETER;
    }


    DebugPrint((DBG_CRASHDUMP,
                "AtapiCrashDumpWriteDMA: Write memory at 0x%x for 0x%x bytes\n",
                mdl->MappedSystemVa,
                mdl->ByteCount));

    Locals->BytesWritten = 0;
    usePio = FALSE;

    do {

        ULONG blockSize;
        ULONG blockCount;
        ULONG blockOffset;
        ULONG bytesWritten = Locals->BytesWritten;

        //
        // determine the block size
        //

        //
        // cannot be greater than the max block size
        //
        if ((mdl->ByteCount - bytesWritten) > DumpData.MaxBlockSize) {

            blockSize = DumpData.MaxBlockSize;
            DebugPrint ((DBG_CRASHDUMP, "AtapiCrashDumpWriteDMA: can't do a single write...\n"));

        } else {

            blockSize = mdl->ByteCount - bytesWritten;
        }

        //
        // Write page by page in order to avoid extra memory allocations in HAL
        //
        {
            ULONG Size = PAGE_SIZE - (((ULONG) ((ULONG_PTR) mdl->MappedSystemVa + bytesWritten)) & (PAGE_SIZE - 1));
            if (blockSize > Size) {
                blockSize = Size;
            }
        }

        //
        // Don't do more than DMA can
        //
        if (blockSize > bmInterface->MaxTransferByteSize) {

            blockSize = bmInterface->MaxTransferByteSize;

        }

        blockCount =  blockSize / DumpData.BytesPerSector;

        //
        // initialize status
        //
        status = STATUS_UNSUCCESSFUL;

        //
        // fill in the fields in the srb
        //
        srb->SrbStatus = srb->ScsiStatus = 0;
        srb->DataTransferLength = blockSize;
        srb->DataBuffer = ((PUCHAR) mdl->MappedSystemVa) + bytesWritten;

        //
        // Convert disk byte offset to block offset.
        //
        blockOffset = (ULONG)((DumpData.PartitionOffset.QuadPart +
                                       (Locals->DiskByteOffset).QuadPart + 
                                       (ULONGLONG) bytesWritten) / DumpData.BytesPerSector);

        cdb = (PCDB)srb->Cdb;

        //
        // Fill in CDB block address.
        //
        cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&blockOffset)->Byte3;
        cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&blockOffset)->Byte2;
        cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&blockOffset)->Byte1;
        cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&blockOffset)->Byte0;

        cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&blockCount)->Byte1;
        cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&blockCount)->Byte0;


        //
        // make sure device is not busy
        //
        WaitOnBusy(&hwExtension->BaseIoAddress1, statusByte);

        //
        // HACK: do PIO. 
        // Complete this request with PIO. Further requests will not
        // use DMA.
        //
        if (usePio) {

            status = AtapiCrashDumpIdeWritePio(srb);

            goto CompleteIde;
        }

        //
        // Make sure DMA is not busy
        //
        bmStatus = bmInterface->BmStatus (bmInterface->Context);

        if (bmStatus & BMSTATUS_INTERRUPT) {

            //
            // Well, in absense of interrupts it means that DMA is ready
            // However extra disarming won't hurt
            //
            bmInterface->BmDisarm (bmInterface->Context);

        } else if (bmStatus != BMSTATUS_NO_ERROR) {

            ASSERT(bmStatus == BMSTATUS_NO_ERROR);

            status = STATUS_UNSUCCESSFUL;

            goto Return;
        }

        //
        // Flush cached data buffers
        //
        KeFlushIoBuffers(mdl, FALSE, TRUE);

        //
        // Start new DMA operation
        //
        if (bmInterface->BmSetupOnePage == NULL) {
            status = bmInterface->BmSetup (
                                          bmInterface->Context,
                                          srb->DataBuffer,
                                          srb->DataTransferLength,
                                          mdl,
                                          FALSE,
                                          AtapiCrashDumpBmCallback,
                                          NULL
                                          );
        } else {
            status = bmInterface->BmSetupOnePage (
                                                 bmInterface->Context,	
                                                 srb->DataBuffer,
                                                 srb->DataTransferLength,
                                                 mdl,
                                                 FALSE,
                                                 Locals
                                                 );
        }

        if (!NT_SUCCESS(status)) {

            ASSERT(NT_SUCCESS(status));

            goto Return;
        }

		//
		// make sure the device is not busy
		//
		WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, statusByte);

        //
        // srb should be marked for DMA
        //
        ASSERT(SRB_USES_DMA(srb));

        //
        // Start new IO
        //
        srbStatus = IdeReadWrite (hwExtension, srb);

        if (srbStatus != SRB_STATUS_PENDING) {

            DebugPrint ((DBG_CRASHDUMP, 
                         "AtapiCrashDumpWriteDMA: Wrong srbStatus = 0x%x\n", 
                         srbStatus
                         ));

            //
            // reset and retry
            //
            srb->SrbStatus = (UCHAR)srbStatus;

            goto CompleteIde;
        }

        WaitDma:

            //
            // wait for the dma to finish and the controller to
            // interrupt. we will keep polling the bus master status
            // register
            //
            bmStatus = bmInterface->BmStatus(bmInterface->Context);

            //
            // if we have an interrupt or there is an error 
            // we are done
            //
            if (!((bmStatus & BMSTATUS_INTERRUPT) ||
                  (bmStatus & BMSTATUS_ERROR_TRANSFER))) {

                //
                // if we don't have to fulfill the request, just
                // return pending. we will be called again.
                //
                if ((Action == IO_DUMP_WRITE_START) ||
                    (Action == IO_DUMP_WRITE_RESUME)) {

                    Locals->State = STATE_WAIT_DMA;

                    status = STATUS_PENDING;

                    goto Return;
                }

                //
                // we have to finish the request. wait until the interrupt
                // is set
                //
                i=0;

                while (i++ < 10000) {

                    bmStatus = bmInterface->BmStatus(bmInterface->Context);

                    if ((bmStatus & BMSTATUS_INTERRUPT) ||
                        (bmStatus & BMSTATUS_ERROR_TRANSFER)) {

                        break;
                    }

                    KeStallExecutionProcessor (100);
                }

                //
                // check if we received an interrupt.
                //
                if (i >= 10000) {

                    //
                    // reset and retry
                    //
                    ASSERT(FALSE);

                    //
                    // disarm the dma controller
                    //
                    bmInterface->BmDisarm (bmInterface->Context);

                    srb->SrbStatus = SRB_STATUS_ERROR;

                    goto CompleteIde;

                }
            }

            if (bmStatus & BMSTATUS_ERROR_TRANSFER){ 

                //
                // Transfer Error. fail the transfer.
                //
                status = STATUS_UNSUCCESSFUL;

                goto Return;

            } 

            //
            // wait for our ISR to finish its job
            //
            interruptCleared = AtapiCrashDumpInterrupt(hwExtension);
            
            //
            // it should be our interrupt
            //
            ASSERT(interruptCleared);

            if (!interruptCleared) {

                status = STATUS_DEVICE_BUSY;

                goto Return;
                
            }

            //
            // clear any spurious interrupts
            //
            i=0;
            while (AtapiCrashDumpInterrupt(hwExtension)) {

                i++;
                if (i>=100) {

                    DebugPrint((0,
                                "AtapiCrashDump: InterruptStorm\n"
                                ));

                    status = STATUS_DEVICE_BUSY;

                    goto Return;
                }

                KeStallExecutionProcessor (100);
            }


        CompleteIde:

            //
            // Flush the adapter buffers
            //
            if (usePio) {

                //
                // don't do anything
                //

            } else if (bmInterface->BmSetupOnePage == NULL) {

				bmInterface->BmFlush (bmInterface->Context);

			} else {
				status = bmInterface->BmFlushAdapterBuffers (
													 bmInterface->Context,	
													 srb->DataBuffer,
													 srb->DataTransferLength,
													 mdl,
													 FALSE
													 );
			}

            //
            // update the bytesWritten
            //
            if (srb->SrbStatus == SRB_STATUS_SUCCESS) {

                //
                // status success
                //
                status = STATUS_SUCCESS;

                //
                // update byteswritten
                //
                Locals->BytesWritten += srb->DataTransferLength;

                //
                // reset retry count
                //
                Locals->RetryCount = 0;

            } else {

                ASSERT(FALSE);

                //
                // reset the bus and retry the request
                //
                IdeHardReset (
                    &DumpData.HwDeviceExtension.BaseIoAddress1,
                    &DumpData.HwDeviceExtension.BaseIoAddress2,
                    TRUE,
                    TRUE
                    );

                //
                // we should probably look at the error code and
                // decide on the retry appropriately. However, to
                // minimize complexity, we would just blindly retry
                // 4 times and then use PIO
                //
                Locals->RetryCount++;

                //
                // retry with PIO (dma timeout)
                // Give dma a fair shot. Once we switch to PIO
                // we would not use DMA for the rest of hibernation.
                //
                if (Locals->RetryCount == 5) {
                    usePio = TRUE;
                }

                //
                // PIO failed. Return error.
                //
                if (Locals->RetryCount > 5) {

                    status = STATUS_IO_DEVICE_ERROR;
                    goto Return;
                }

            }

    } while (Locals->BytesWritten < mdl->ByteCount);

    Locals->State = STATE_READY;
    status = STATUS_SUCCESS;

    Return:

        //
        // if we used PIO this time, disable dma
        // for the rest of hibernation
        //
        if (usePio) {
            Locals->State = STATE_BAD_DMA;
        }

        if (!NT_SUCCESS(status)) {

            ASSERT(FALSE);
            Locals->State = STATE_IO_FAIL;

        }

        hwExtension->CurrentSrb = NULL;
        bmInterface->Context = Locals->BmContext;

        return status;

}

NTSTATUS
AtapiCrashDumpIdeWritePio (
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    NTSTATUS            status;
    ULONG               srbStatus;
    UCHAR               ideStatus;
    ULONG               i;

    MARK_SRB_FOR_PIO(Srb);

    //
    // make sure it is not busy
    //
    WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);

    //
    // Send the srb to the device
    //
    srbStatus = IdeReadWrite(
                    &DumpData.HwDeviceExtension,
                    Srb
                    );

    if (srbStatus == SRB_STATUS_PENDING) {

        while (DumpData.HwDeviceExtension.BytesLeft) {

            //
            // ATA-2 spec requires a minimum of 400 ns stall here
            //
            KeStallExecutionProcessor (1);

            //
            // a quick wait
            //
            for (i=0; i<100; i++) {

                GetStatus(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);
                if (!(ideStatus & IDE_STATUS_BUSY)) {
                    break;
                }
            }

            if (ideStatus & IDE_STATUS_BUSY) {

                //
                // go to a slower wait
                //
                WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);
            }

            if (ideStatus & (IDE_STATUS_BUSY | IDE_STATUS_ERROR)) {

                status = STATUS_UNSUCCESSFUL;
                DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpIdeWrite: unexpected status 0x%x\n", ideStatus));
                break;

            } else {

                ULONG byteCount;

                //
                // a quick wait On DRQ
                //
                for (i=0; i<100; i++) {

                    GetStatus(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);
                    if (ideStatus & IDE_STATUS_DRQ) {
                        break;
                    }
                }

                if (!(ideStatus & IDE_STATUS_DRQ)) {

                    WaitForDrq(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);
                }

                if (!(ideStatus & IDE_STATUS_DRQ)) {

                    status = STATUS_UNSUCCESSFUL;
                    DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpIdeWrite: drq fails to assert, 0x%x\n", ideStatus));
                    break;
                }

                if (DumpData.HwDeviceExtension.BytesLeft <
                    DumpData.HwDeviceExtension.DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt) {
                    byteCount = DumpData.HwDeviceExtension.BytesLeft;
                } else {
                    byteCount = DumpData.HwDeviceExtension.DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt;
                }

                WriteBuffer(&DumpData.HwDeviceExtension.BaseIoAddress1,
                            (PUSHORT)DumpData.HwDeviceExtension.DataBuffer,
                            byteCount / sizeof(USHORT));

                DumpData.HwDeviceExtension.BytesLeft -= byteCount;
                DumpData.HwDeviceExtension.DataBuffer += byteCount;
            }
        }

        if (!DumpData.HwDeviceExtension.BytesLeft) {

            //
            // ATA-2 spec requires a minimum of 400 ns stall here
            //
            KeStallExecutionProcessor (1);

            //
            // a quick wait
            //
            for (i=0; i<100; i++) {

                GetStatus(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);
                if (!(ideStatus & IDE_STATUS_BUSY)) {
                    break;
                }
            }

            if (ideStatus & IDE_STATUS_BUSY) {

                //
                // go to a slower wait
                //
                WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);
            }
        }

        if (DumpData.HwDeviceExtension.BytesLeft) {

            status = STATUS_UNSUCCESSFUL;
            DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpIdeWrite: write failed. idestatus = 0x%x\n", ideStatus));

        } else {

            Srb->SrbStatus = SRB_STATUS_SUCCESS;
            status = STATUS_SUCCESS;
        }

    } else {

        DebugPrint ((DBG_ALWAYS,
                     "atapi crash dump: IdeReadWrite failed with stautus = 0x%x\n",
                     srbStatus
                     ));

        status = STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS(status)) {

        Srb->SrbStatus = SRB_STATUS_ERROR;

    } else {

        ASSERT(Srb->SrbStatus == SRB_STATUS_SUCCESS);
    }

    DumpData.HwDeviceExtension.BytesLeft = 0;
    DumpData.HwDeviceExtension.DataBuffer = 0;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\detect.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    detect.c

Abstract:

    This contain legacy detection routines

Author:

    Joe Dai (joedai)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "ideport.h"

#if !defined(NO_LEGACY_DRIVERS)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IdePortDetectLegacyController)
#pragma alloc_text(INIT, IdePortCreateDetectionList)
#pragma alloc_text(INIT, IdePortTranslateAddress)
#pragma alloc_text(INIT, IdePortFreeTranslatedAddress)
#pragma alloc_text(INIT, IdePortDetectAlias)
#endif // ALLOC_PRAGMA

NTSTATUS
IdePortDetectLegacyController (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    Detect legacy IDE controllers and report them to PnP

Arguments:

    DriverObject - this driver's driver object

    RegistryPath - this driver's registry path

Return Value:

    NT Status

--*/
{
    ULONG                           cmResourceListSize;
    PCM_RESOURCE_LIST               cmResourceList = NULL;
    PCM_FULL_RESOURCE_DESCRIPTOR    cmFullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartialDescriptors;

    BOOLEAN                         conflictDetected;
    BOOLEAN                         resourceIsCmdPort;

    PDEVICE_OBJECT                  detectedPhysicalDeviceObject;
    PFDO_EXTENSION                  fdoExtension = NULL;

    UNICODE_STRING                  deviceClassName;

    NTSTATUS                        status;
    PDETECTION_PORT                 detectionPort;
    ULONG                           numPort;
    ULONG                           i;
    ULONG                           j;

    ULONG                           cmdAddressSpace;
    ULONG                           ctrlAddressSpace;
    PUCHAR                          cmdRegBase;
    PUCHAR                          ctrlRegBase;
    IDE_REGISTERS_1                 baseIoAddress1;
    IDE_REGISTERS_2                 baseIoAddress2;
    PHYSICAL_ADDRESS                cmdRegMemoryBase;
    PHYSICAL_ADDRESS                ctrlRegMemoryBase;
    UCHAR                           statusByte;
    ULONG                           baseIoAddress1Length;
    ULONG                           baseIoAddress2Length;
    ULONG                           maxIdeDevice;

    UCHAR                           altMasterStatus;
    UCHAR                           altSlaveStatus;


#if !defined (ALWAYS_DO_LEGACY_DETECTION)
    if (!IdePortOkToDetectLegacy(DriverObject)) {

        //
        // legacy detection is not enabled
        //
        return STATUS_SUCCESS;
    }
#endif

    //
    // make up a list of popular legacy I/O ports
    //
    status = IdePortCreateDetectionList (
                 DriverObject,
                 &detectionPort,
                 &numPort
                 );
    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    //
    // Resource Requirement List
    //
    cmResourceListSize = sizeof (CM_RESOURCE_LIST) +
                         sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (((!IsNEC_98) ? 3 : 12) - 1);
    cmResourceList = ExAllocatePool (PagedPool, cmResourceListSize);
    if (cmResourceList == NULL){

        status = STATUS_NO_MEMORY;
        goto GetOut;

    }

    RtlZeroMemory(cmResourceList, cmResourceListSize);
    RtlInitUnicodeString(&deviceClassName, L"ScsiAdapter");

    for (i=0; i<numPort; i++) {

        //
        // Build io address structure.
        //

        AtapiBuildIoAddress ( (PUCHAR)detectionPort[i].CommandRegisterBase,
                              (PUCHAR)detectionPort[i].ControlRegisterBase,
                              &baseIoAddress1,
                              &baseIoAddress2,
                              &baseIoAddress1Length,
                              &baseIoAddress2Length,
                              &maxIdeDevice,
                              NULL);

        //
        // Build resource requirement list
        //
        cmResourceList->Count = 1;

        cmFullResourceDescriptor = cmResourceList->List;
        cmFullResourceDescriptor->InterfaceType = Isa;
        cmFullResourceDescriptor->BusNumber = 0;

        cmPartialResourceList = &cmFullResourceDescriptor->PartialResourceList;
        cmPartialResourceList->Version = 1;
        cmPartialResourceList->Revision = 1;
        cmPartialResourceList->Count = 3;

        cmPartialDescriptors = cmPartialResourceList->PartialDescriptors;

        cmPartialDescriptors[0].Type             = CmResourceTypePort;
        cmPartialDescriptors[0].ShareDisposition = CmResourceShareDeviceExclusive;
        cmPartialDescriptors[0].Flags            = CM_RESOURCE_PORT_IO |
                           (!Is98LegacyIde(&baseIoAddress1)? CM_RESOURCE_PORT_10_BIT_DECODE :
                                                             CM_RESOURCE_PORT_16_BIT_DECODE);
        cmPartialDescriptors[0].u.Port.Length    = baseIoAddress1Length;
        cmPartialDescriptors[0].u.Port.Start.QuadPart = detectionPort[i].CommandRegisterBase;

        cmPartialDescriptors[1].Type             = CmResourceTypePort;
        cmPartialDescriptors[1].ShareDisposition = CmResourceShareDeviceExclusive;
        cmPartialDescriptors[1].Flags            = CM_RESOURCE_PORT_IO |
                           (!Is98LegacyIde(&baseIoAddress1)? CM_RESOURCE_PORT_10_BIT_DECODE :
                                                             CM_RESOURCE_PORT_16_BIT_DECODE);
        cmPartialDescriptors[1].u.Port.Length    = 1;
        cmPartialDescriptors[1].u.Port.Start.QuadPart = detectionPort[i].ControlRegisterBase;

        cmPartialDescriptors[2].Type             = CmResourceTypeInterrupt;
        cmPartialDescriptors[2].ShareDisposition = CmResourceShareDeviceExclusive;
        cmPartialDescriptors[2].Flags            = CM_RESOURCE_INTERRUPT_LATCHED;
        cmPartialDescriptors[2].u.Interrupt.Level = detectionPort[i].IrqLevel;
        cmPartialDescriptors[2].u.Interrupt.Vector = detectionPort[i].IrqLevel;
        cmPartialDescriptors[2].u.Interrupt.Affinity = -1;

        if (Is98LegacyIde(&baseIoAddress1)) {

            ULONG resourceCount;
            ULONG commandRegisters;

            commandRegisters = detectionPort[i].CommandRegisterBase + 2;
            resourceCount = 3;

            while (commandRegisters < (IDE_NEC98_COMMAND_PORT_ADDRESS + 0x10)) {
                cmPartialDescriptors[resourceCount].Type             = CmResourceTypePort;
                cmPartialDescriptors[resourceCount].ShareDisposition = CmResourceShareDeviceExclusive;
                cmPartialDescriptors[resourceCount].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                cmPartialDescriptors[resourceCount].u.Port.Length    = 1;
                cmPartialDescriptors[resourceCount].u.Port.Start.QuadPart = commandRegisters;

                resourceCount++;
                commandRegisters += 2;
            }

            cmPartialDescriptors[resourceCount].Type             = CmResourceTypePort;
            cmPartialDescriptors[resourceCount].ShareDisposition = CmResourceShareDeviceExclusive;
            cmPartialDescriptors[resourceCount].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
            cmPartialDescriptors[resourceCount].u.Port.Length    = 2;
            cmPartialDescriptors[resourceCount].u.Port.Start.QuadPart = (ULONG_PTR)SELECT_IDE_PORT;

            resourceCount++;

            cmPartialDescriptors[resourceCount].Type             = CmResourceTypePort;
            cmPartialDescriptors[resourceCount].ShareDisposition = CmResourceShareDeviceExclusive;
            cmPartialDescriptors[resourceCount].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
            cmPartialDescriptors[resourceCount].u.Port.Length    = 1;
            cmPartialDescriptors[resourceCount].u.Port.Start.QuadPart = (ULONG_PTR)SELECT_IDE_PORT + 3;

            resourceCount++;

            cmPartialResourceList->Count = resourceCount;
        }

        //
        // check to see if the resource is available
        // if not, assume no legacy IDE controller
        // is at the this location
        //
        for (j=0; j<2; j++) {

            status = IoReportResourceForDetection (
                         DriverObject,
                         cmResourceList,
                         cmResourceListSize,
                         NULL,
                         NULL,
                         0,
                         &conflictDetected
                         );

            if (NT_SUCCESS(status) && !conflictDetected) {

                //
                // got our resources
                //
                break;

            } else {

                if (NT_SUCCESS(status)) {

                    IoReportResourceForDetection (
                                 DriverObject,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 0,
                                 &conflictDetected
                                 );

                    status = STATUS_UNSUCCESSFUL;
                }

                //
                // try 16 bit decode
                //
                cmPartialDescriptors[0].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                cmPartialDescriptors[1].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;

                if (Is98LegacyIde(&baseIoAddress1)) {
                    ULONG k;

                    for (k=3; k<12; k++) {
                        cmPartialDescriptors[k].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                    }
                }
            }
        }

        if (!NT_SUCCESS(status)) {

            continue;
        }


        //
        // translate the i/o port via Hal
        //

        status = STATUS_SUCCESS;

        if (Is98LegacyIde(&baseIoAddress1)) {
            for (j=3; j<12; j++) {
                cmdRegBase = NULL;
                cmdAddressSpace = IO_SPACE;

                status = IdePortTranslateAddress (
                             cmFullResourceDescriptor->InterfaceType,
                             cmFullResourceDescriptor->BusNumber,
                             cmPartialDescriptors[j].u.Port.Start,
                             cmPartialDescriptors[j].u.Port.Length,
                             &cmdAddressSpace,
                             &cmdRegBase,
                             &cmdRegMemoryBase
                             );
                if (!NT_SUCCESS(status)) {
                    break;
                }
            }
        }

        if (NT_SUCCESS(status)) {

            cmdRegBase = NULL;
            ctrlRegBase = NULL;
            cmdAddressSpace = IO_SPACE;

            status = IdePortTranslateAddress (
                         cmFullResourceDescriptor->InterfaceType,
                         cmFullResourceDescriptor->BusNumber,
                         cmPartialDescriptors[0].u.Port.Start,
                         cmPartialDescriptors[0].u.Port.Length,
                         &cmdAddressSpace,
                         &cmdRegBase,
                         &cmdRegMemoryBase
                         );
        }

        if (NT_SUCCESS(status)) {

            ctrlRegBase = NULL;
            ctrlAddressSpace = IO_SPACE;
            status = IdePortTranslateAddress (
                         cmFullResourceDescriptor->InterfaceType,
                         cmFullResourceDescriptor->BusNumber,
                         cmPartialDescriptors[1].u.Port.Start,
                         cmPartialDescriptors[1].u.Port.Length,
                         &ctrlAddressSpace,
                         &ctrlRegBase,
                         &ctrlRegMemoryBase
                         );
        }

        if (NT_SUCCESS(status)) {

            //
            // 2nd build io address structure.
            //

            AtapiBuildIoAddress ( cmdRegBase,
                                  ctrlRegBase,
                                  &baseIoAddress1,
                                  &baseIoAddress2,
                                  &baseIoAddress1Length,
                                  &baseIoAddress2Length,
                                  &maxIdeDevice,
                                  NULL);

            //
            // The IBM Aptiva ide channel with the external cdrom doesn't power up with any device selected
            // we must select a device; otherwise, we get a 0xff from all IO ports
            //
            SelectIdeDevice(&baseIoAddress1, 0, 0);
            altMasterStatus = IdePortInPortByte(baseIoAddress2.DeviceControl);

            SelectIdeDevice(&baseIoAddress1, 1, 0);
            altSlaveStatus = IdePortInPortByte(baseIoAddress2.DeviceControl);

            if ((!Is98LegacyIde(&baseIoAddress1)) && (altMasterStatus == 0xff) && (altSlaveStatus == 0xff)) {

                //
                // the alternate status byte is 0xff,
                // guessing we have a SCSI adapter (DPT) that emulate IDE controller
                // say the channel is empty, let the real SCSI driver picks up
                // the controller
                //
                status = STATUS_UNSUCCESSFUL;

                //
                // Note: The IDE port on SB16/AWE32 does not have the alternate status
                // register.  Because of this alternate status test, we will fail to
                // detect this IDE port.  However, this IDE port should be enumerated
                // by ISA-PnP bus driver.
                //

            } else if (IdePortChannelEmpty (&baseIoAddress1, &baseIoAddress2, maxIdeDevice)) {

                //
                // channel looks empty
                //
                status = STATUS_UNSUCCESSFUL;

            } else {

                BOOLEAN             deviceFound;
                IDENTIFY_DATA       IdentifyData;
                ULONG               i;

                for (i=0; i<maxIdeDevice; i++) {

                    if (Is98LegacyIde(&baseIoAddress1)) {
                        UCHAR driveHeadReg;

                        //
                        // Check master device only.
                        //

                        if ( i & 0x1 ) {

                            continue;
                        }

                        //
                        // Check device is present.
                        //

                        SelectIdeDevice(&baseIoAddress1, i, 0);
                        driveHeadReg = IdePortInPortByte(baseIoAddress1.DriveSelect);

                        if (driveHeadReg != ((i & 0x1) << 4 | 0xA0)) {
                            //
                            // Bad controller.
                            //
                            continue;
                        }
                    }

                    //
                    // Is there a ATA device?
                    //
                    deviceFound = IssueIdentify(
                                      &baseIoAddress1,
                                      &baseIoAddress2,
                                      i,
                                      IDE_COMMAND_IDENTIFY,
                                      TRUE,
                                      &IdentifyData
                                      );
                    if (deviceFound) {
                        break;
                    }

                    //
                    // Is there a ATAPI device?
                    //
                    deviceFound = IssueIdentify(
                                      &baseIoAddress1,
                                      &baseIoAddress2,
                                      i,
                                      IDE_COMMAND_ATAPI_IDENTIFY,
                                      TRUE,
                                      &IdentifyData
                                      );
                    if (deviceFound) {
                        break;
                    }
                }

                if (!deviceFound) {

                    status = STATUS_UNSUCCESSFUL;
                }
            }
        }

        if (!NT_SUCCESS (status)) {

            //
            // if we didn't found anything,
            // unmap the reosurce
            //

            if (cmdRegBase) {

                IdePortFreeTranslatedAddress (
                    cmdRegBase,
                    cmPartialDescriptors[0].u.Port.Length,
                    cmdAddressSpace
                    );

                if (Is98LegacyIde(&baseIoAddress1)) {
                    for (j=3; j<12; j++) {
                        IdePortFreeTranslatedAddress (
                            cmdRegBase,
                            cmPartialDescriptors[j].u.Port.Length,
                            cmdAddressSpace
                            );
                    }
                }
            }

            if (ctrlRegBase) {

                IdePortFreeTranslatedAddress (
                    ctrlRegBase,
                    cmPartialDescriptors[1].u.Port.Length,
                    ctrlAddressSpace
                    );
            }

        } else {

            //
            // check for alias ports
            //
            if (cmPartialDescriptors[0].Flags & CM_RESOURCE_PORT_10_BIT_DECODE) {

                if (!IdePortDetectAlias (&baseIoAddress1)) {

                    cmPartialDescriptors[0].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                    cmPartialDescriptors[1].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;

                    if (Is98LegacyIde(&baseIoAddress1)) {
                        for (j=3; j<12; j++) {
                            cmPartialDescriptors[j].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                        }
                    }
                }
            }
        }

        //
        // release the resources we have grab, IoReportDetectedDevice()
        // will grab them for us again when we call and it will grab them
        // on behalf of the detected PDO.
        //
        IoReportResourceForDetection (
                     DriverObject,
                     NULL,
                     0,
                     NULL,
                     NULL,
                     0,
                     &conflictDetected
                     );

        if (NT_SUCCESS(status)) {

            detectedPhysicalDeviceObject = NULL;

            status = IoReportDetectedDevice(DriverObject,
                                            InterfaceTypeUndefined,
                                            -1,
                                            -1,
                                            cmResourceList,
                                            NULL,
                                            FALSE,
                                            &detectedPhysicalDeviceObject);

            if (NT_SUCCESS (status)) {

                //
                // create a FDO and attach it to the detected PDO
                //
                status = ChannelAddChannel (
                             DriverObject,
                             detectedPhysicalDeviceObject,
                             &fdoExtension
                             );

                if (NT_SUCCESS (status)) {

                    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
                    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
                    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
                    ULONG i, j;

                    //
                    // translate resources
                    //
                    fullResourceList = cmResourceList->List;
                    for (i=0; i<cmResourceList->Count; i++) {

                        partialResourceList = &(fullResourceList->PartialResourceList);
                        partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

                        for (j=0; j<partialResourceList->Count; j++) {

                            resourceIsCmdPort = FALSE;

                            if (!Is98LegacyIde(&baseIoAddress1)) {

                                if ((partialDescriptors[j].Type == CmResourceTypePort) &&
                                    (partialDescriptors[j].u.Port.Length == baseIoAddress1Length)) {

                                    resourceIsCmdPort = TRUE;
                                }
                            } else {

                                if ((partialDescriptors[j].Type == CmResourceTypePort) &&
                                    (partialDescriptors[j].u.Port.Start.QuadPart == IDE_NEC98_COMMAND_PORT_ADDRESS)) {

                                    resourceIsCmdPort = TRUE;

                                } else if ((partialDescriptors[j].Type == CmResourceTypePort) &&
                                           (partialDescriptors[j].u.Port.Start.QuadPart != IDE_NEC98_COMMAND_PORT_ADDRESS) &&
                                           (partialDescriptors[j].u.Port.Start.QuadPart != (IDE_NEC98_COMMAND_PORT_ADDRESS + 0x10C))) {

                                    //
                                    // This is not the base port address for Legacy ide on NEC98;
                                    //

                                    continue;
                                }
                            }

                            if (resourceIsCmdPort) {

                                if (cmdAddressSpace == MEMORY_SPACE) {

                                    partialDescriptors[j].Type = CmResourceTypeMemory;
                                    partialDescriptors[j].u.Memory.Start = cmdRegMemoryBase;
                                    partialDescriptors[j].u.Memory.Length = partialDescriptors[j].u.Port.Length;

                                } else {

                                    partialDescriptors[j].u.Port.Start.QuadPart = (ULONG_PTR) cmdRegBase;
                                }

                            } else if ((partialDescriptors[j].Type == CmResourceTypePort) &&
                                  (partialDescriptors[j].u.Port.Length == 1)) {

                                if (ctrlAddressSpace == MEMORY_SPACE) {

                                    partialDescriptors[j].Type = CmResourceTypeMemory;
                                    partialDescriptors[j].u.Memory.Start = ctrlRegMemoryBase;
                                    partialDescriptors[j].u.Memory.Length = partialDescriptors[j].u.Port.Length;

                                } else {

                                    partialDescriptors[j].u.Port.Start.QuadPart = (ULONG_PTR) ctrlRegBase;
                                }

                            } else if (partialDescriptors[j].Type == CmResourceTypeInterrupt) {

                                partialDescriptors[j].u.Interrupt.Vector = HalGetInterruptVector(fullResourceList->InterfaceType,
                                                                               fullResourceList->BusNumber,
                                                                               partialDescriptors[j].u.Interrupt.Level,
                                                                               partialDescriptors[j].u.Interrupt.Vector,
                                                                               (PKIRQL) &partialDescriptors[j].u.Interrupt.Level,
                                                                               &partialDescriptors[j].u.Interrupt.Affinity);
                            }
                        }
                        fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + j);
                    }

                    //
                    // start the FDO
                    //
                    status = ChannelStartChannel (fdoExtension,
                                                  cmResourceList);      // callee is keeping this if no error
                }

                if (!NT_SUCCESS (status)) {

                    //
                    // go through the remove sequence
                    //
                    if (fdoExtension) {

                        ChannelRemoveChannel (fdoExtension);

                        IoDetachDevice (fdoExtension->AttacheeDeviceObject);

                        IoDeleteDevice (fdoExtension->DeviceObject);
                    }

                    DebugPrint ((0, "IdePort: Unable to start detected device\n"));
                    ASSERT (FALSE);

                } else {

                   IoInvalidateDeviceRelations (
                       fdoExtension->AttacheePdo,
                       BusRelations
                       );
                }
            }
        }
    }

GetOut:
    if (cmResourceList) {
        ExFreePool (cmResourceList);
    }

    if (detectionPort) {
        ExFreePool (detectionPort);
    }

    return status;

} //IdePortDetectLegacyController



NTSTATUS
IdePortCreateDetectionList (
    IN  PDRIVER_OBJECT  DriverObject,
    OUT PDETECTION_PORT *DetectionPort,
    OUT PULONG          NumPort
)
/*++

Routine Description:

    create a list of popular legacy ports

Arguments:

    DriverObject - this driver's driver object

    DetectionPort - pointer to port list

    NumPort - number of ports in the list

Return Value:

    NT Status

--*/
{
    NTSTATUS                status;
    CCHAR                   deviceBuffer[50];
    ANSI_STRING             ansiString;
    UNICODE_STRING          subKeyPath;
    HANDLE                  subServiceKey;

    PDETECTION_PORT         detectionPort;
    ULONG                   numDevices;
    ULONG                   i;
    ULONG                   j;

    CUSTOM_DEVICE_PARAMETER customDeviceParameter;

    PCONFIGURATION_INFORMATION configurationInformation = IoGetConfigurationInformation();

    numDevices = 0;
    status = STATUS_SUCCESS;

#ifdef DRIVER_PARAMETER_REGISTRY_SUPPORT

    //
    // look for non-standard legacy port setting in the registry
    //      9
    do {
        sprintf (deviceBuffer, "Parameters\\Device%d", numDevices);
        RtlInitAnsiString(&ansiString, deviceBuffer);
        status = RtlAnsiStringToUnicodeString(&subKeyPath, &ansiString, TRUE);

        if (NT_SUCCESS(status)) {

            subServiceKey = IdePortOpenServiceSubKey (
                                DriverObject,
                                &subKeyPath
                                );

            RtlFreeUnicodeString (&subKeyPath);

            if (subServiceKey) {

                numDevices++;
                IdePortCloseServiceSubKey (
                    subServiceKey
                    );

            } else {

                status = STATUS_UNSUCCESSFUL;
            }
        }
    } while (NT_SUCCESS(status));

#endif // DRIVER_PARAMETER_REGISTRY_SUPPORT

    //
    // always have at least 4 to return
    //
    detectionPort = ExAllocatePool (
                        PagedPool,
                        (numDevices + 4) * sizeof (DETECTION_PORT)
                        );

    if (detectionPort) {

        for (i = j = 0; i < numDevices; i++) {

#ifdef DRIVER_PARAMETER_REGISTRY_SUPPORT

            //
            // look for non-standard legacy port setting in the registry
            //

            sprintf (deviceBuffer, "Parameters\\Device%d", i);
            RtlInitAnsiString(&ansiString, deviceBuffer);
            status = RtlAnsiStringToUnicodeString(&subKeyPath, &ansiString, TRUE);

            if (NT_SUCCESS(status)) {

                subServiceKey = IdePortOpenServiceSubKey (
                                    DriverObject,
                                    &subKeyPath
                                    );

                RtlFreeUnicodeString (&subKeyPath);

                if (subServiceKey) {

                    RtlZeroMemory (
                        &customDeviceParameter,
                        sizeof (CUSTOM_DEVICE_PARAMETER)
                        );

                    IdeParseDeviceParameters (
                        subServiceKey,
                        &customDeviceParameter
                        );

                    if (customDeviceParameter.CommandRegisterBase) {

                        detectionPort[j].CommandRegisterBase =
                            customDeviceParameter.CommandRegisterBase;

                        detectionPort[j].ControlRegisterBase =
                            customDeviceParameter.CommandRegisterBase + 0x206;

                        detectionPort[j].IrqLevel =
                            customDeviceParameter.IrqLevel;

                        j++;
                    }

                    IdePortCloseServiceSubKey (
                        subServiceKey
                        );
                }
            }
#endif // DRIVER_PARAMETER_REGISTRY_SUPPORT
        }

        //
        // populate the list with popular i/o ports
        //

        if ( !IsNEC_98 ) {
            if (configurationInformation->AtDiskPrimaryAddressClaimed == FALSE) {

                detectionPort[j].CommandRegisterBase = 0x1f0;
                detectionPort[j].ControlRegisterBase = 0x1f0 + 0x206;
                detectionPort[j].IrqLevel            = 14;
                j++;
            }

            if (configurationInformation->AtDiskSecondaryAddressClaimed == FALSE) {

                detectionPort[j].CommandRegisterBase = 0x170;
                detectionPort[j].ControlRegisterBase = 0x170 + 0x206;
                detectionPort[j].IrqLevel            = 15;
                j++;
            }

            detectionPort[j].CommandRegisterBase = 0x1e8;
            detectionPort[j].ControlRegisterBase = 0x1e8 + 0x206;
            detectionPort[j].IrqLevel            = 11;
// DEC Hi-Note hack
//        detectionPort[j].ControlRegisterBase = 0x1e8 + 0x1f - 0x2;
//        detectionPort[j].IrqLevel            = 7;
// DEC Hi-Note hack
            j++;

            detectionPort[j].CommandRegisterBase = 0x168;
            detectionPort[j].ControlRegisterBase = 0x168 + 0x206;
            detectionPort[j].IrqLevel            = 10;
            j++;

        } else { // IsNEC_98

            if ((configurationInformation->AtDiskPrimaryAddressClaimed   == FALSE) &&
                (configurationInformation->AtDiskSecondaryAddressClaimed == FALSE)) {

                detectionPort[j].CommandRegisterBase = 0x640;
                detectionPort[j].ControlRegisterBase = 0x640 + 0x10c; //0x74c
                detectionPort[j].IrqLevel            = 9;
                j++;
            }

        }

        *NumPort = j;
        *DetectionPort = detectionPort;
        return STATUS_SUCCESS;
    } else {

        *NumPort = 0;
        *DetectionPort = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }
} // IdePortCreateDetectionList


NTSTATUS
IdePortTranslateAddress (
    IN INTERFACE_TYPE      InterfaceType,
    IN ULONG               BusNumber,
    IN PHYSICAL_ADDRESS    StartAddress,
    IN LONG                Length,
    IN OUT PULONG          AddressSpace,
    OUT PVOID              *TranslatedAddress,
    OUT PPHYSICAL_ADDRESS  TranslatedMemoryAddress
    )
/*++

Routine Description:

    translate i/o address

Arguments:

    InterfaceType - bus interface

    BusNumber - bus number

    StartAddress - address to translate

    Length - number of byte to translate

    AddressSpace - address space for the given address

Return Value:

    AddressSpace - address space for the translated address

    TranslatedAddress - translated address

    TranslatedMemoryAddress - tranlated memory address if translated to memory space

    NT Status

--*/
{
    PHYSICAL_ADDRESS       translatedAddress;

    ASSERT (Length);
    ASSERT (AddressSpace);
    ASSERT (TranslatedAddress);

    *TranslatedAddress = NULL;
    TranslatedMemoryAddress->QuadPart = (ULONGLONG) NULL;

    if (HalTranslateBusAddress(InterfaceType,
                               BusNumber,
                               StartAddress,
                               AddressSpace,
                               &translatedAddress)) {


        if (*AddressSpace == IO_SPACE) {

            *TranslatedAddress = (PVOID) translatedAddress.u.LowPart;

        } else if (*AddressSpace == MEMORY_SPACE) {

            //
            // translated address is in memory space,
            // need to map it to I/O space.
            //
            *TranslatedMemoryAddress = translatedAddress;

            *TranslatedAddress = MmMapIoSpace(
                                    translatedAddress,
                                    Length,
                                    FALSE);
        }
    }

    if (*TranslatedAddress) {

        return STATUS_SUCCESS;

    } else {

        return STATUS_INVALID_PARAMETER;
    }
} // IdePortTranslateAddress


VOID
IdePortFreeTranslatedAddress (
    IN PVOID               TranslatedAddress,
    IN LONG                Length,
    IN ULONG               AddressSpace
    )
/*++

Routine Description:

    free resources created for a translated address

Arguments:

    TranslatedAddress - translated address

    Length - number of byte to translated

    AddressSpace - address space for the translated address

Return Value:

    None

--*/
{
    if (TranslatedAddress) {

        if (AddressSpace == MEMORY_SPACE) {

            MmUnmapIoSpace (
                TranslatedAddress,
                Length
                );
        }
    }
    return;
} // IdePortFreeTranslatedAddress


BOOLEAN
IdePortDetectAlias (
    PIDE_REGISTERS_1 CmdRegBase
    )
{
    PIDE_REGISTERS_1 cmdRegBaseAlias;
    PUCHAR cylinderHighAlias;
    PUCHAR cylinderLowAlias;

    //
    // alias port
    //
    cylinderHighAlias = (PUCHAR) ((ULONG_PTR) CmdRegBase->CylinderHigh | (1 << 15));
    cylinderLowAlias = (PUCHAR) ((ULONG_PTR) CmdRegBase->CylinderLow | (1 << 15));

    IdePortOutPortByte (CmdRegBase->CylinderHigh, SAMPLE_CYLINDER_HIGH_VALUE);
    IdePortOutPortByte (CmdRegBase->CylinderLow,  SAMPLE_CYLINDER_LOW_VALUE);

    //
    // Check if indentifier can be read back via the alias port
    //
    if ((IdePortInPortByte (cylinderHighAlias) != SAMPLE_CYLINDER_HIGH_VALUE) ||
        (IdePortInPortByte (cylinderLowAlias)  != SAMPLE_CYLINDER_LOW_VALUE)) {

        return FALSE;

    } else {

        return TRUE;
    }
}

#endif // NO_LEGACY_DRIVERS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\chanfdo.h ===
/*++

Copyright (C) 1993-99  Microsoft Corporation

Module Name:

    chanfdo.h

Abstract:

--*/

#if !defined (___chanfdo_h___)
#define ___chanfdo_h___

//
// work item
//
typedef struct _IDE_WORK_ITEM_CONTEXT {

    PIO_WORKITEM    WorkItem;
    PIRP            Irp;

} IDE_WORK_ITEM_CONTEXT, *PIDE_WORK_ITEM_CONTEXT;

             
NTSTATUS
ChannelAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
ChannelAddChannel(
    IN  PDRIVER_OBJECT DriverObject,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PFDO_EXTENSION *FdoExtension
    );

NTSTATUS
ChannelStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelStartChannel (
    PFDO_EXTENSION    FdoExtension,
    PCM_RESOURCE_LIST ResourceListToKeep
    );

NTSTATUS
ChannelStartDeviceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP       Irp,
    IN OUT PVOID      Context
    );

NTSTATUS
ChannelCreateSymblicLinks (
    PFDO_EXTENSION FdoExtension
    );

NTSTATUS
ChannelDeleteSymblicLinks (
    PFDO_EXTENSION FdoExtension
    );

NTSTATUS
ChannelSurpriseRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelRemoveDeviceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
ChannelStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelRemoveChannel (
    PFDO_EXTENSION    FdoExtension
    );

NTSTATUS
ChannelStartDeviceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
ChannelQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelQueryBusRelation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIDE_WORK_ITEM_CONTEXT workItemContext
    );

PDEVICE_RELATIONS
ChannelBuildDeviceRelationList (
    PFDO_EXTENSION FdoExtension
    );

NTSTATUS
ChannelQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelQueryIdCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

NTSTATUS
ChannelUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelUsageNotificationCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
ChannelDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ChannelQueryBusMasterInterface (
    PFDO_EXTENSION    FdoExtension
    );

VOID
ChannelQueryTransferModeInterface (
    PFDO_EXTENSION    FdoExtension
    );

VOID
ChannelUnbindBusMasterParent (
    PFDO_EXTENSION    FdoExtension
    );

VOID
ChannelQuerySyncAccessInterface (
    PFDO_EXTENSION    FdoExtension
    );

VOID
ChannelQueryRequestProperResourceInterface (
    PFDO_EXTENSION    FdoExtension
    );

    
__inline
VOID
ChannelEnableInterrupt (
    IN PFDO_EXTENSION FdoExtension
    );

__inline
VOID
ChannelDisableInterrupt (
    IN PFDO_EXTENSION FdoExtension
	);

NTSTATUS
ChannelGetIdentifyData (
    PFDO_EXTENSION FdoExtension,
    ULONG DeviceNumber,
    PIDENTIFY_DATA IdentifyData
    );

NTSTATUS
ChannelAcpiTransferModeSelect (
    IN PVOID Context,
    PPCIIDE_TRANSFER_MODE_SELECT XferMode
    );

NTSTATUS
ChannelRestoreTiming (
    IN PFDO_EXTENSION FdoExtension,
    IN PSET_ACPI_TIMING_COMPLETION_ROUTINE CallerCompletionRoutine,
    IN PVOID CallerContext
    );

NTSTATUS
ChannelRestoreTimingCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PVOID Context
    );

NTSTATUS
ChannelFilterResourceRequirements (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
BOOLEAN
ChannelQueryPcmciaParent (
    PFDO_EXTENSION FdoExtension
    );
      
#ifdef IDE_FILTER_PROMISE_TECH_RESOURCES
NTSTATUS
ChannelFilterPromiseTechResourceRequirements (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
#endif // IDE_FILTER_PROMISE_TECH_RESOURCES

NTSTATUS
ChannelQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
                         
#ifdef ENABLE_NATIVE_MODE
VOID
ChannelQueryInterruptInterface (
    PFDO_EXTENSION    FdoExtension
    );
#endif
#endif // ___chanfdo_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\detect.h ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    detect.h

Abstract:

--*/

#if !defined (___detect_h___)
#define ___detect_h___

typedef struct _DETECTION_PORT {

    ULONG   CommandRegisterBase;
    ULONG   ControlRegisterBase;
    ULONG   IrqLevel;

} DETECTION_PORT, *PDETECTION_PORT;


NTSTATUS
IdePortDetectLegacyController (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
);

NTSTATUS
IdePortCreateDetectionList (
    IN  PDRIVER_OBJECT  DriverObject,
    OUT PDETECTION_PORT *DetectionPort,
    OUT PULONG          NumPort
);

NTSTATUS
IdePortTranslateAddress (
    IN INTERFACE_TYPE      InterfaceType,
    IN ULONG               BusNumber,
    IN PHYSICAL_ADDRESS    StartAddress,
    IN LONG                Length,
    IN OUT PULONG          AddressSpace,
    OUT PVOID              *TranslatedAddress,
    OUT PPHYSICAL_ADDRESS  TranslatedMemoryAddress
    );

VOID
IdePortFreeTranslatedAddress (
    IN PVOID               TranslatedAddress,
    IN LONG                Length,
    IN ULONG               AddressSpace
    );

BOOLEAN
IdePortDetectAlias (
    PIDE_REGISTERS_1 CmdRegBase
    );

#endif // ___detect_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\devpdo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       devpdo.h
//
//--------------------------------------------------------------------------

#if !defined (___devpdo_h___)
#define ___devpdo_h___

#define PNP_ADDRESS(target, lun)    ((target & 0xf) | (lun << 4))

typedef struct _PDO_STOP_QUEUE_CONTEXT {

    PPDO_EXTENSION    PdoExtension;
    KEVENT            Event;
    ULONG             QueueStopFlag;
    NTSTATUS          Status;
    ATA_PASS_THROUGH  AtaPassThroughData;

} PDO_STOP_QUEUE_CONTEXT, *PPDO_STOP_QUEUE_CONTEXT;

           
//
// PDO State
//                         
#define PDOS_DEVICE_CLIAMED        (1 << 0)
#define PDOS_LEGACY_ATTACHER       (1 << 1)
#define PDOS_STARTED               (1 << 2)
#define PDOS_STOPPED               (1 << 3)

#define PDOS_SURPRISE_REMOVED      (1 << 4)
#define PDOS_REMOVED               (1 << 5)
#define PDOS_DEADMEAT              (1 << 6)
#define PDOS_NO_POWER_DOWN         (1 << 7)

#define PDOS_QUEUE_FROZEN_BY_POWER_DOWN       (1 << 8)
#define PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM  (1 << 9)
#define PDOS_QUEUE_FROZEN_BY_STOP_DEVICE      (1 << 10)
#define PDOS_QUEUE_FROZEN_BY_PARENT           (1 << 11)
#define PDOS_QUEUE_FROZEN_BY_START            (1 << 12)

#define PDOS_DISABLED_BY_USER                 (1 << 13)

#define PDOS_NEED_RESCAN                      (1 << 14)

#define PDOS_REPORTED_TO_PNP                  (1 << 15)

#define PDOS_INITIALIZED                     (1 << 31)

#define PDOS_MUST_QUEUE            (PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM |\
                                    PDOS_QUEUE_FROZEN_BY_STOP_DEVICE |\
                                    PDOS_QUEUE_FROZEN_BY_PARENT |\
                                    PDOS_QUEUE_FROZEN_BY_START)

#define PDOS_QUEUE_BLOCKED        (PDOS_MUST_QUEUE | PDOS_QUEUE_FROZEN_BY_POWER_DOWN)


#define PDO_CONSECUTIVE_PAGING_TIMEOUT_LIMIT 20
#define PDO_CONSECUTIVE_TIMEOUT_LIMIT       6
#define PDO_CONSECUTIVE_TIMEOUT_WARNING_LIMIT       (PDO_CONSECUTIVE_TIMEOUT_LIMIT/2)
#define PDO_DMA_TIMEOUT_LIMIT               6
#define PDO_FLUSH_TIMEOUT_LIMIT             3
#define PDO_UDMA_CRC_ERROR_LIMIT            6
#define PDO_PAGING_DEVICE_RETRY_COUNT       6

typedef enum {
    enumFailed = 1,
    reportedMissing,
    tooManyTimeout,
    byKilledPdo,
    replacedByUser
} DEADMEAT_REASON;

//
// Ide Power Context (pre-alloced)
//
typedef struct _IDE_POWER_CONTEXT {

    PPDO_EXTENSION    PdoExtension;
    PIRP              PowerIrp;
    ATA_PASS_THROUGH  AtaPassThroughData;

} IDE_POWER_CONTEXT, *PIDE_POWER_CONTEXT;

//
// Device Extension
//
typedef struct _PDO_EXTENSION {

    EXTENSION_COMMON_HEADER;

    PFDO_EXTENSION ParentDeviceExtension;

    PULONG         IdleCounter;

    KEVENT RemoveEvent;

    ULONG          ConsecutiveTimeoutCount;

    ULONG          DmaTransferTimeoutCount;

    ULONG          FlushCacheTimeoutCount;

    ULONG          CrcErrorCount;

    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR RetryCount;
    ULONG LuFlags;
    ULONG CurrentKey;
    struct _PDO_EXTENSION *NextLogicalUnit;
    PSCSI_REQUEST_BLOCK AbortSrb;
    struct _PDO_EXTENSION *CompletedAbort;
    LONG RequestTimeoutCounter;
    PIRP PendingRequest;
    PIRP BusyRequest;
    //UCHAR MaxQueueDepth;
    //UCHAR QueueCount;
    SRB_DATA SrbData;

    UCHAR ScsiDeviceType;

    UCHAR FullVendorProductId[40 + 1];
    UCHAR FullProductRevisionId[8 + 1];
    UCHAR FullSerialNumber[20 * 2 + 1];

    //
    // (ata device only) indicate whether the write cache is enabled
    //
    BOOLEAN WriteCacheEnable;

    //
    // SpinLock to protect Pdo Extension
    //
    KSPIN_LOCK PdoSpinLock;

    //
    // If the logical is attached, this field contains
    // the device object of the attacher.  Otherwise,
    // it is same as PhysicalDeviceObject
    //
    PVOID AttacherDeviceObject;

    //
    // Number of references made to this logical unit extension
    //
    // Protected by Pdo SpinLock
    //
    // should be LONG: ASSERT when we try to decrement 0.
    ULONG ReferenceCount;

    //
    // keeping track of Pdo State
    //
    ULONG PdoState;

    PIRP PendingPowerDownSystemIrp;

    //
    // indicate we need to call DeviceQueryInitData()
    // protected by interlock
    //
    ULONG InitDeviceWithAcpiGtf;

    //
    // iddata checksum
    //
    ULONG IdentifyDataCheckSum;

    //
    // firmware settings from acpi
    //
    // must get it before we power down
    PDEVICE_SETTINGS AcpiDeviceSettings;

    IDE_POWER_CONTEXT   PdoPowerContext;

#if DBG
    ULONG   PowerContextLock;
#endif

#ifdef LOG_DEADMEAT_EVENT

    struct {

        DEADMEAT_REASON Reason;

        PUCHAR FileName;
        ULONG LineNumber;
        IDEREGS IdeReg;

    } DeadmeatRecord;

#endif // LOG_DEADMEAT_EVENT

#if DBG
    //
    // Number of Items queued up in Device Queue
    //
    ULONG NumberOfIrpQueued;

    #define TAG_TABLE_SIZE  0x1000
    KSPIN_LOCK RefCountSpinLock;
    ULONG NumTagUsed;
    PVOID TagTable[TAG_TABLE_SIZE];

#endif

} PDO_EXTENSION, *PPDO_EXTENSION;

typedef PDO_EXTENSION  LOGICAL_UNIT_EXTENSION;
typedef PPDO_EXTENSION PLOGICAL_UNIT_EXTENSION;

typedef VOID (*DEVICE_INIT_COMPLETION) (
    PVOID Context,
    NTSTATUS Status
    );

typedef enum _DEVICE_INIT_STATE {
    deviceInitState_acpi = 0,
    deviceInitState_done,
    deviceInitState_max
} DEVICE_INIT_STATE;

typedef struct _DEVICE_INIT_DEVICE_STATE_CONTEXT {

    PPDO_EXTENSION PdoExtension;

    DEVICE_INIT_STATE DeviceInitState[deviceInitState_max];
    ULONG CurrentState;

    ULONG NumInitState;

    ULONG NumAcpiRequestSent;

    ULONG NumRequestFailed;

    DEVICE_INIT_COMPLETION DeviceInitCompletionRoutine;
    PVOID DeviceInitCompletionContext;

    ATA_PASS_THROUGH AtaPassThroughData;

} DEVICE_INIT_DEVICE_STATE_CONTEXT, *PDEVICE_INIT_DEVICE_STATE_CONTEXT;


#define DEVICE_DEFAULT_IDLE_TIMEOUT        0xffffffff
#define DEVICE_VERY_LONG_IDLE_TIMEOUT      0xfffffffe

typedef struct _IDE_READ_CAPACITY_CONTEXT {

    PPDO_EXTENSION PdoExtension;
    PIRP OriginalIrp;
    PVOID OldDataBuffer;

    ATA_PASS_THROUGH AtaPassThroughData;
    UCHAR DataBuffer[sizeof(IDENTIFY_DATA)];

    BOOLEAN GeometryIoctl;

} IDE_READ_CAPACITY_CONTEXT, *PIDE_READ_CAPACITY_CONTEXT;

typedef struct _IDE_MODE_COMMAND_CONTEXT {

    PSCSI_REQUEST_BLOCK Srb;
    PVOID OriginalDataBuffer;
} IDE_MODE_COMMAND_CONTEXT, *PIDE_MODE_COMMAND_CONTEXT;


PDEVICE_OBJECT
DeviceCreatePhysicalDeviceObject (
    IN PDRIVER_OBJECT  DriverObject,
    IN PFDO_EXTENSION  FdoExtension,
    IN PUNICODE_STRING DeviceObjectName
    );

NTSTATUS
DeviceStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceStartDeviceQueue (
    IN PPDO_EXTENSION PdoExtension,
    IN ULONG          StopFlagToClear
    );

NTSTATUS
DeviceStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceStopDeviceQueueSafe (
    IN PPDO_EXTENSION PdoExtension,
    IN ULONG          QueueStopFlag,
    IN BOOLEAN          lowMem
    );

VOID
IdeStopQueueCompletionRoutine (
    IN PDEVICE_OBJECT           DeviceObject,
    IN PPDO_STOP_QUEUE_CONTEXT  Context,
    IN NTSTATUS                 Status
    );

NTSTATUS
DeviceRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceQueryStopRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

PWSTR
DeviceBuildBusId (
    IN PPDO_EXTENSION pdoExtension
    );

PWSTR
DeviceBuildInstanceId (
    IN PPDO_EXTENSION pdoExtension
    );

PWSTR
DeviceBuildCompatibleId(
    IN PPDO_EXTENSION pdoExtension
    );

PWSTR
DeviceBuildHardwareId(
    IN PPDO_EXTENSION pdoExtension
    );

VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Count,
    IN UCHAR Change
    );

NTSTATUS
DeviceDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
NTSTATUS
DeviceBuildStorageDeviceDescriptor(
    PPDO_EXTENSION pdoExtension,
    IN OUT PSTORAGE_DEVICE_DESCRIPTOR StorageDeviceDescriptor,
    IN OUT PULONG BufferSize
    );

NTSTATUS
DeviceQueryCapabilities (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
NTSTATUS
IdePortInsertByKeyDeviceQueue (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp,
    IN ULONG SortKey,
    OUT PBOOLEAN Inserted
    );
                        
VOID
DeviceInitCompletionRoutine (
    PVOID Context,
    NTSTATUS Status
    );

NTSTATUS
DeviceQueryText (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
                        
NTSTATUS
IdePortSendPassThrough (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp
    );

VOID
DeviceRegisterIdleDetection (
    IN PPDO_EXTENSION PdoExtension,
    IN ULONG ConservationIdleTime,
    IN ULONG PerformanceIdleTime
);
                        
VOID
DeviceUnregisterIdleDetection (
    IN PPDO_EXTENSION PdoExtension
);

VOID
DeviceInitIdStrings (
    IN PPDO_EXTENSION PdoExtension,
    IN IDE_DEVICETYPE DeviceType,
    IN PINQUIRYDATA   InquiryData,
    IN PIDENTIFY_DATA IdentifyData
);
                        
VOID
DeviceInitDeviceType (
    IN PPDO_EXTENSION PdoExtension,
    IN PINQUIRYDATA   InquiryData
);
                        
NTSTATUS
DeviceQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceInitDeviceState (
    IN PPDO_EXTENSION PdoExtension,
    DEVICE_INIT_COMPLETION DeviceInitCompletionRoutine,
    PVOID DeviceInitCompletionContext
    );
                        
NTSTATUS
DeviceQueryInitData (
    IN PPDO_EXTENSION PdoExtension
    );

VOID
DeviceInitDeviceStateCompletionRoutine (
    PDEVICE_OBJECT DeviceObject,
    PVOID Context,
    NTSTATUS Status
    );

VOID
DeviceInitCHS (
    IN PPDO_EXTENSION PdoExtension,
    PDEVICE_INIT_DEVICE_STATE_CONTEXT DeviceStateContext,
    PATA_PASS_THROUGH AtaPassThroughData
    );
                        
NTSTATUS
DeviceIdeReadCapacity (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
);

VOID
DeviceIdeReadCapacityCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    PVOID Context,
    NTSTATUS Status
    );

NTSTATUS
DeviceIdeModeSense (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceIdeModeSelect (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
);
                        
NTSTATUS
DeviceQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
                        
NTSTATUS
DeviceIdeTestUnitReady (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
);
                        
NTSTATUS
DeviceAtapiModeSelect (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp
    );

NTSTATUS
DeviceAtapiModeSense (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp
    );

NTSTATUS
DeviceAtapiModeCommandCompletion (
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#endif // ___devpdo_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\fdopower.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       fdopower.h
//
//--------------------------------------------------------------------------

#if !defined (___fdopower_h___)
#define ___fdopower_h___

typedef struct  _FDO_POWER_CONTEXT *PFDO_POWER_CONTEXT;
           
//POWER_STATE                   
NTSTATUS
IdePortIssueSetPowerState (
    IN PDEVICE_EXTENSION_HEADER DoExtension,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE      State,
    IN BOOLEAN          Sync
    );

NTSTATUS
IdePortPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
IdePortSetFdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
FdoContingentPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
FdoPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );
    
VOID
FdoChildReportPowerDown (
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension
    );

NTSTATUS
FdoChildRequestPowerUp (
    IN PFDO_EXTENSION            FdoExtension,
    IN PPDO_EXTENSION            PdoExtension,
    IN PVOID                     Context
    );
    
NTSTATUS
FdoChildRequestPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );
                          
                          
NTSTATUS
ChannelQueryPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
                                    
NTSTATUS
FdoSystemPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );

#endif // ___fdopower_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\devpdo.c ===
/*++

Copyright (C) 1993-99  Microsoft Corporation

Module Name:

    devpdo.c

Abstract:

--*/

#include "ideport.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, IdePortSendPassThrough)
#pragma alloc_text(PAGE, DeviceInitIdStrings)
#pragma alloc_text(PAGE, DeviceInitDeviceType)
#pragma alloc_text(PAGE, DeviceQueryDeviceRelations)
#pragma alloc_text(PAGE, DeviceUsageNotification)
#pragma alloc_text(PAGE, DeviceBuildStorageDeviceDescriptor)
#pragma alloc_text(PAGE, DeviceQueryPnPDeviceState)
#pragma alloc_text(PAGE, DeviceQueryCapabilities)
#pragma alloc_text(PAGE, DeviceBuildBusId)
#pragma alloc_text(PAGE, DeviceBuildCompatibleId)
#pragma alloc_text(PAGE, DeviceBuildHardwareId)
#pragma alloc_text(PAGE, DeviceBuildInstanceId)
#pragma alloc_text(PAGE, DeviceQueryId)
#pragma alloc_text(PAGE, DeviceQueryText)
#pragma alloc_text(PAGE, DeviceIdeTestUnitReady)
#pragma alloc_text(PAGE, DeviceQueryInitData)
#pragma alloc_text(PAGE, DeviceQueryStopRemoveDevice)
#pragma alloc_text(PAGE, DeviceStopDevice)
#pragma alloc_text(PAGE, CopyField)

#pragma alloc_text(NONPAGE, DeviceIdeModeSelect)
#pragma alloc_text(NONPAGE, DeviceInitDeviceState)
#pragma alloc_text(NONPAGE, DeviceStartDeviceQueue)

#endif // ALLOC_PRAGMA

PDEVICE_OBJECT
DeviceCreatePhysicalDeviceObject (
    IN PDRIVER_OBJECT  DriverObject,
    IN PFDO_EXTENSION  FdoExtension,
    IN PUNICODE_STRING DeviceObjectName
    )
{
    PDEVICE_OBJECT  physicalDeviceObject;
    PPDO_EXTENSION  pdoExtension;
    NTSTATUS        status;

    physicalDeviceObject = NULL;

    status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(PDO_EXTENSION),      // size of our extension
                DeviceObjectName,           // our name
                FILE_DEVICE_MASS_STORAGE,   // device type
                FILE_DEVICE_SECURE_OPEN,    // device characteristics
                FALSE,                      // not exclusive
                &physicalDeviceObject       // store new device object here
                );

    if (NT_SUCCESS(status)) {

        //
        // spinning up could take a lot of current;
        //
        physicalDeviceObject->Flags |= DO_POWER_INRUSH | DO_DIRECT_IO;

        //
        // fix up alignment requirement
        //
        physicalDeviceObject->AlignmentRequirement = FdoExtension->DeviceObject->AlignmentRequirement;
        if (physicalDeviceObject->AlignmentRequirement < 1) {
            physicalDeviceObject->AlignmentRequirement = 1;
        }

        pdoExtension = physicalDeviceObject->DeviceExtension;
        RtlZeroMemory (pdoExtension, sizeof(PDO_EXTENSION));

        //
        // Keeping track of those device objects
        //
        pdoExtension->DriverObject           = DriverObject;
        pdoExtension->DeviceObject           = physicalDeviceObject;

        //
        // keep track of our parent
        //
        pdoExtension->ParentDeviceExtension  = FdoExtension;

        //
        // Dispatch Table
        //
        pdoExtension->DefaultDispatch        = IdePortNoSupportIrp;
        pdoExtension->PnPDispatchTable       = PdoPnpDispatchTable;
        pdoExtension->PowerDispatchTable     = PdoPowerDispatchTable;
        pdoExtension->WmiDispatchTable       = PdoWmiDispatchTable;

        //
        // We have to be in this D0 state before we can be enumurated
        // 
        pdoExtension->SystemPowerState = PowerSystemWorking;
        pdoExtension->DevicePowerState = PowerDeviceD0;
    }

    return physicalDeviceObject;
}

NTSTATUS
DeviceStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPDO_EXTENSION pdoExtension;
    KEVENT event;

    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       TRUE,
                       DeviceStartDevice
                       );

    if (pdoExtension) {

        KIRQL       currentIrql;

        // ISSUE: if we are not lun0, we really should wait for lun0 to start first


#if defined (IDEPORT_WMI_SUPPORT)
        //
        // register with WMI
        //
        if (!(pdoExtension->PdoState & PDOS_STARTED)) {
            IdePortWmiRegister ((PDEVICE_EXTENSION_HEADER)pdoExtension);
        }
        else {
            DebugPrint((1, "ATAPI: PDOe %x Didn't register for WMI\n", pdoExtension));
        }
#endif // IDEPORT_WMI_SUPPORT

        KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

        SETMASK (pdoExtension->PdoState, PDOS_STARTED);
        CLRMASK (pdoExtension->PdoState, PDOS_STOPPED | PDOS_REMOVED | PDOS_SURPRISE_REMOVED | PDOS_DISABLED_BY_USER);

        KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

        //
        // need to init device with acpi GTF before processing
        // the first request
        //
        ASSERT(pdoExtension->InitDeviceWithAcpiGtf == 0);
        InterlockedIncrement (&pdoExtension->InitDeviceWithAcpiGtf);

        //
        // keep the device queue block until we can go through some
        // init code
        //
        DeviceStopDeviceQueueSafe (pdoExtension, PDOS_QUEUE_FROZEN_BY_START, FALSE);

        //
        // clear the stop_device block
        //
        status = DeviceStartDeviceQueue (pdoExtension, PDOS_QUEUE_FROZEN_BY_STOP_DEVICE);

        //
        // init pdo with acpi bios _GTF data
        //
        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE);

        DeviceQueryInitData(
            pdoExtension
            );

        //
        // can't really tell if it is enabled or not
        // assume it is.
        //
        pdoExtension->WriteCacheEnable = TRUE;

        status = DeviceInitDeviceState(
                     pdoExtension,
                     DeviceInitCompletionRoutine,
                     &event
                     );

        if (!NT_SUCCESS(status)) {

            ASSERT(NT_SUCCESS(status));
            DeviceInitCompletionRoutine (
                &event,
                status
                );

        } else {

            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }

        //
        // open the queue
        //
        DeviceStartDeviceQueue (pdoExtension, PDOS_QUEUE_FROZEN_BY_START);


        UnrefPdoWithTag(
            pdoExtension,
            DeviceStartDevice
            );

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_DEVICE_DOES_NOT_EXIST;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

NTSTATUS
DeviceStartDeviceQueue (
    IN PPDO_EXTENSION PdoExtension,
    IN ULONG          StopFlagToClear
    )
{
    NTSTATUS    status;
    KIRQL       currentIrql;
    BOOLEAN     restartQueue;
    ULONG       oldPdoState;

    restartQueue = FALSE;

    KeAcquireSpinLock(&PdoExtension->PdoSpinLock, &currentIrql);

    oldPdoState = PdoExtension->PdoState;

    CLRMASK (PdoExtension->PdoState, StopFlagToClear);

    if (PdoExtension->PdoState & PDOS_DEADMEAT) {

        restartQueue = FALSE;

    } else if ((oldPdoState & PDOS_MUST_QUEUE) !=
        (PdoExtension->PdoState & PDOS_MUST_QUEUE)) {

        //
        // make sure we have actually cleared some
        // PDOS_MUST_QUEUE bits.
        //
        if (!(PdoExtension->PdoState & PDOS_MUST_QUEUE)) {

            restartQueue = TRUE;
        }
    }

    KeReleaseSpinLock(&PdoExtension->PdoSpinLock, currentIrql);

    //
    // Restart queue
    //
    if (restartQueue) {

        KeAcquireSpinLock(&PdoExtension->ParentDeviceExtension->SpinLock, &currentIrql);

        GetNextLuPendingRequest(PdoExtension->ParentDeviceExtension, PdoExtension);

        KeLowerIrql(currentIrql);

        DebugPrint ((DBG_PNP, "IdePort: pdo 0x%x is pnp started with 0x%x items queued\n", PdoExtension->DeviceObject, PdoExtension->NumberOfIrpQueued));
    }

    return STATUS_SUCCESS;
}


NTSTATUS
DeviceStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPDO_EXTENSION pdoExtension;

	PAGED_CODE();

    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       TRUE,
                       DeviceStopDevice
                       );

    if (pdoExtension) {

        DebugPrint ((
            DBG_PNP,
            "pdoe 0x%x 0x%x (%d, %d, %d) got a STOP device\n",
            pdoExtension,
            pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
            pdoExtension->PathId,
            pdoExtension->TargetId,
            pdoExtension->Lun
            ));

        status = DeviceStopDeviceQueueSafe (pdoExtension, PDOS_QUEUE_FROZEN_BY_STOP_DEVICE, FALSE);
        UnrefPdoWithTag (
            pdoExtension,
            DeviceStopDevice
            );

    } else {

        status = STATUS_DEVICE_DOES_NOT_EXIST;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

NTSTATUS
DeviceStopDeviceQueueSafe (
    IN PPDO_EXTENSION PdoExtension,
    IN ULONG          QueueStopFlag,
    IN BOOLEAN        LowMem
    )
{
    NTSTATUS                status;
    PPDO_STOP_QUEUE_CONTEXT context;
    KIRQL                   currentIrql;
    BOOLEAN                 queueAlreadyBlocked = FALSE;
    PENUMERATION_STRUCT     enumStruct;
    ULONG                   retryCount = 1;
    ULONG                   locked;

    ASSERT (PDOS_MUST_QUEUE & QueueStopFlag);

    //
    // make sure the queue is not already blocked for the same reason
    //
    ASSERT (!(PdoExtension->PdoState & QueueStopFlag));

    if (LowMem) {

        //
        //Lock
        //
        ASSERT(InterlockedCompareExchange(&(PdoExtension->ParentDeviceExtension->EnumStructLock),
                                              1, 0) == 0);

        enumStruct=PdoExtension->ParentDeviceExtension->PreAllocEnumStruct;
        if (enumStruct) {
            context=enumStruct->StopQContext;
            retryCount=5;
        } else {
            ASSERT(enumStruct);
            LowMem=FALSE;
            retryCount=1;
        }
    }

    if (!LowMem) {
        context = ExAllocatePool (NonPagedPool, sizeof(*context));
    }

    if (context) {

        //
        // check to see if queue is already blocked
        //
        KeAcquireSpinLock(&PdoExtension->PdoSpinLock, &currentIrql);
        if (PdoExtension->PdoState & (PDOS_MUST_QUEUE | PDOS_DEADMEAT)) {

            SETMASK (PdoExtension->PdoState, QueueStopFlag);
            queueAlreadyBlocked = TRUE;
        }
        KeReleaseSpinLock(&PdoExtension->PdoSpinLock, currentIrql);

        RtlZeroMemory (context, sizeof (*context));
        KeInitializeEvent(&context->Event,
                           NotificationEvent,
                           FALSE);

        context->PdoExtension  = PdoExtension;
        context->QueueStopFlag = QueueStopFlag;
        context->AtaPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_NO_OP;

        if (queueAlreadyBlocked) {

            IdeStopQueueCompletionRoutine (
                PdoExtension->DeviceObject,
                context,
                STATUS_SUCCESS
                );

            status = STATUS_SUCCESS;

        } else {

            //
            // send a no-op request to block the queue
            //


            status = STATUS_INSUFFICIENT_RESOURCES;

            //
            // if lowMem=0, this loop will execute only once
            //
            while (status == STATUS_INSUFFICIENT_RESOURCES && retryCount--) {
                status = IssueAsyncAtaPassThroughSafe (
                             PdoExtension->ParentDeviceExtension,
                             PdoExtension,
                             &context->AtaPassThroughData,
                             FALSE,
                             IdeStopQueueCompletionRoutine,
                             context,
                             TRUE,          // TRUE really means complete this irp before starting a new one
                             DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                             LowMem
                             );
                ASSERT (NT_SUCCESS(status));

                if (status == STATUS_PENDING) {

                    KeWaitForSingleObject(&context->Event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL);
                }

                status = context->Status;
            }
        }

        //
        // Don't free the context if it was Pre-alloced.
        //
        if (!LowMem) {
            ExFreePool (context);
        } else {

            // Unlock
            ASSERT(InterlockedCompareExchange(&(PdoExtension->ParentDeviceExtension->EnumStructLock),
                                        0, 1) == 1);
        }

    } else {

        status = STATUS_NO_MEMORY;
    }

    return status;
}

VOID
IdeStopQueueCompletionRoutine (
    IN PDEVICE_OBJECT           DeviceObject,
    IN PPDO_STOP_QUEUE_CONTEXT  Context,
    IN NTSTATUS                 Status
    )
{
    PPDO_EXTENSION pdoExtension;
    KIRQL          currentIrql;

    pdoExtension = Context->PdoExtension;
    Context->Status = Status;

    if (NT_SUCCESS(Status)) {

        KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

        if (Context->QueueStopFlag == PDOS_QUEUE_FROZEN_BY_STOP_DEVICE) {

            SETMASK (pdoExtension->PdoState, PDOS_STOPPED);
        }

        SETMASK (pdoExtension->PdoState, Context->QueueStopFlag);

        DebugPrint ((DBG_PNP, "IdePort: pdo 0x%x is pnp stopped with 0x%x items queued\n", DeviceObject, pdoExtension->NumberOfIrpQueued));

        KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

    } else {

        DebugPrint ((0, "IdePort: unable to stop pdo 0x%x\n", pdoExtension));
    }

    KeSetEvent (&Context->Event, 0, FALSE);

    return;
}

NTSTATUS
DeviceRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS       status;
    PPDO_EXTENSION pdoExtension;
    KIRQL          currentIrql;
    PDEVICE_OBJECT parentAttacheePdo;
    BOOLEAN        freePdo;
    BOOLEAN        callIoDeleteDevice;
    BOOLEAN        deregWmi = FALSE;

    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       TRUE,
                       DeviceRemoveDevice
                       );

    if (pdoExtension) {

        PIO_STACK_LOCATION thisIrpSp;
        KIRQL       currentIrql;

        thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

        KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

        if (pdoExtension->PdoState & PDOS_NEED_RESCAN) {

            CLRMASK (pdoExtension->PdoState, PDOS_NEED_RESCAN);

            //
            // get ready for IoInvalidateDeviceRelations
            //
            parentAttacheePdo = pdoExtension->ParentDeviceExtension->AttacheePdo;
        } else {

            parentAttacheePdo = NULL;
        }

        if (thisIrpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {

            DebugPrint ((
                DBG_PNP,
                "pdoe 0x%x 0x%x (%d, %d, %d) got a REMOVE device\n",
                pdoExtension,
                pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                pdoExtension->PathId,
                pdoExtension->TargetId,
                pdoExtension->Lun
                ));

            if (pdoExtension->PdoState & (PDOS_DEADMEAT | PDOS_SURPRISE_REMOVED)) {

                SETMASK (pdoExtension->PdoState, PDOS_REMOVED);

                if (pdoExtension->PdoState & PDOS_REPORTED_TO_PNP) {

                    freePdo = FALSE;

                } else {

                    freePdo = TRUE;
                }

            } else {

                SETMASK (pdoExtension->PdoState, PDOS_DISABLED_BY_USER);
                freePdo = FALSE;
            }

            if ((pdoExtension->PdoState & PDOS_STARTED) &&
                 !(pdoExtension->PdoState & PDOS_SURPRISE_REMOVED)) {
                deregWmi = TRUE;
            }
            CLRMASK (pdoExtension->PdoState, PDOS_STARTED);

            //
            // not claimed anymore
            //
            CLRMASK (pdoExtension->PdoState, PDOS_DEVICE_CLIAMED);

            callIoDeleteDevice = TRUE;

        } else {

            DebugPrint ((
                DBG_PNP,
                "pdoe 0x%x 0x%x (%d, %d, %d) got a SURPRISE_REMOVE device\n",
                pdoExtension,
                pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                pdoExtension->PathId,
                pdoExtension->TargetId,
                pdoExtension->Lun
                ));

            SETMASK (pdoExtension->PdoState, PDOS_SURPRISE_REMOVED | PDOS_DEADMEAT);

            if (pdoExtension->PdoState & PDOS_STARTED) {
                deregWmi = TRUE;
            }

            freePdo = TRUE;
            freePdo = FALSE;
            callIoDeleteDevice = FALSE;
        }

        KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

#if defined (IDEPORT_WMI_SUPPORT)
        //
        // deregister with WMI
        //
        if (deregWmi) {

            IdePortWmiDeregister ((PDEVICE_EXTENSION_HEADER)pdoExtension);
        }
#endif // IDEPORT_WMI_SUPPORT

        if (freePdo) {

            status = FreePdoWithTag(
                         pdoExtension,
                         TRUE,
                         callIoDeleteDevice,
                         DeviceRemoveDevice
                         );

        } else {

            //
            // release the pdo
            //
            UnrefPdoWithTag (
                pdoExtension,
                DeviceRemoveDevice
                );
        }

        if (parentAttacheePdo) {

            IoInvalidateDeviceRelations (
                parentAttacheePdo,
                BusRelations
                );
        }
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;

} // DeviceRemoveDevice

NTSTATUS
DeviceUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS       status;

	PAGED_CODE();

    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       FALSE,
                       DeviceUsageNotification
                       );
    status = Irp->IoStatus.Status;

    if (pdoExtension) {

        PIO_STACK_LOCATION irpSp;
        PDEVICE_OBJECT targetDeviceObject;
        IO_STATUS_BLOCK ioStatus;
        PULONG deviceUsageCount;

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging) {

            //
            // Adjust the paging path count for this device.
            //
            deviceUsageCount = &pdoExtension->PagingPathCount;

            //
            // changing device state
            //
            IoInvalidateDeviceState(pdoExtension->DeviceObject);

        } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation) {

            //
            // Adjust the paging path count for this device.
            //
            deviceUsageCount = &pdoExtension->HiberPathCount;

        } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile) {

            //
            // Adjust the paging path count for this device.
            //
            deviceUsageCount = &pdoExtension->CrashDumpPathCount;

        } else {

            deviceUsageCount = NULL;
            DebugPrint ((DBG_ALWAYS,
                         "ATAPI: Unknown IRP_MN_DEVICE_USAGE_NOTIFICATION type: 0x%x\n",
                         irpSp->Parameters.UsageNotification.Type));
        }

        //
        // get the top of parent's device stack
        //
        targetDeviceObject = IoGetAttachedDeviceReference(
                                 pdoExtension->
                                     ParentDeviceExtension->
                                         DeviceObject);


        ioStatus.Status = STATUS_NOT_SUPPORTED;
        status = IdePortSyncSendIrp (targetDeviceObject, irpSp, &ioStatus);

        ObDereferenceObject (targetDeviceObject);

        if (NT_SUCCESS(status)) {

            POWER_STATE powerState;

            if (deviceUsageCount) {

                IoAdjustPagingPathCount (
                    deviceUsageCount,
                    irpSp->Parameters.UsageNotification.InPath
                    );
            }

            if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile) {

                //
                // reset the idle timeout to "forever"
                //
                DeviceRegisterIdleDetection (
                    pdoExtension,
                    DEVICE_VERY_LONG_IDLE_TIMEOUT,
                    DEVICE_VERY_LONG_IDLE_TIMEOUT
                    );

                if (pdoExtension->IdleCounter) {

                    PoSetDeviceBusy (pdoExtension->IdleCounter);
                }

                //
                // spin up the crash dump drive
                //
                powerState.DeviceState = PowerDeviceD0;
                PoRequestPowerIrp (
                    pdoExtension->DeviceObject,
                    IRP_MN_SET_POWER,
                    powerState,
                    NULL,
                    NULL,
                    NULL
                    );
            }
        }

        //
        // release the pdo
        //
        UnrefPdoWithTag (
            pdoExtension,
            DeviceUsageNotification
            );

    } else {

        status = STATUS_NO_SUCH_DEVICE;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

} // DeviceUsageNotification

NTSTATUS
DeviceQueryStopRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS       status;
    PPDO_EXTENSION pdoExtension;
    PIO_STACK_LOCATION  thisIrpSp;

	PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation(Irp);

    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       TRUE,
                       DeviceQueryStopRemoveDevice
                       );

    if (pdoExtension) {

        if ((pdoExtension->PdoState & PDOS_LEGACY_ATTACHER) &&
            (thisIrpSp->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE)) {

            status = STATUS_UNSUCCESSFUL;

        } else if (pdoExtension->PagingPathCount ||
                   pdoExtension->CrashDumpPathCount) {

            //
            // Check the paging path count for this device.
            //

            status = STATUS_UNSUCCESSFUL;

        } else {

            status = STATUS_SUCCESS;
        }

        UnrefPdoWithTag (
            pdoExtension,
            DeviceQueryStopRemoveDevice
            );


    } else {

        status = STATUS_NO_SUCH_DEVICE;
        DebugPrint((1, "Query remove failed\n"));
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

} // DeviceQueryStopRemoveDevice

NTSTATUS
DeviceQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PPDO_EXTENSION      pdoExtension;
    NTSTATUS status;
    PWSTR idString;

	PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

    idString = NULL;
    status = STATUS_DEVICE_DOES_NOT_EXIST;

    pdoExtension = RefPdoWithTag (
                       DeviceObject,
                       TRUE,
                       DeviceQueryId
                       );
    if (pdoExtension) {

        switch (thisIrpSp->Parameters.QueryId.IdType) {

            case BusQueryDeviceID:

                //
                // Caller wants the bus ID of this device.
                //

                idString = DeviceBuildBusId(pdoExtension);
                break;

            case BusQueryInstanceID:

                //
                // Caller wants the unique id of the device
                //

                idString = DeviceBuildInstanceId(pdoExtension);
                break;

            case BusQueryCompatibleIDs:

                //
                // Caller wants the compatible id of the device
                //

                idString = DeviceBuildCompatibleId(pdoExtension);
                break;

            case BusQueryHardwareIDs:

                //
                // Caller wants the hardware id of the device
                //

                idString = DeviceBuildHardwareId(pdoExtension);
                break;

            default:
                DebugPrint ((1, "ideport: QueryID type %d not supported\n", thisIrpSp->Parameters.QueryId.IdType));
                status = STATUS_NOT_SUPPORTED;
                break;
        }

        UnrefPdoWithTag(
            pdoExtension,
            DeviceQueryId
            );
    }

    if( idString != NULL ){
        Irp->IoStatus.Information = (ULONG_PTR) idString;
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

} // DeviceQueryId


PWSTR
DeviceBuildBusId(
    IN PPDO_EXTENSION pdoExtension
    )
{
#define IDE_BUS_ID_PREFIX   "IDE\\"

    PUCHAR      deviceTypeIdString;
    ULONG       deviceTypeIdLen;
    UCHAR       compatibleId[10];


    USHORT      idStringBufLen;

    PUCHAR          idString;
    ANSI_STRING     ansiBusIdString;
    PWCHAR          idWString;
    UNICODE_STRING  unicodeIdString;

	PAGED_CODE();

    //
    // get the device type
    //
    deviceTypeIdString = (PUCHAR)IdePortGetDeviceTypeString (
                                    pdoExtension->ScsiDeviceType
                                    );

    if (deviceTypeIdString == NULL) {

        sprintf (compatibleId,
                 "Type%d",
                 pdoExtension->ScsiDeviceType);

        deviceTypeIdString = compatibleId;
    }
    deviceTypeIdLen = strlen(deviceTypeIdString);

    idStringBufLen = (USHORT)(strlen( IDE_BUS_ID_PREFIX ) +
                     deviceTypeIdLen +
                     sizeof (pdoExtension->FullVendorProductId) +
                     sizeof (pdoExtension->FullProductRevisionId) +
                     sizeof (pdoExtension->FullSerialNumber) +
                     1);

    //
    // get the string buffers
    //
    idWString = ExAllocatePool( PagedPool, idStringBufLen * sizeof(WCHAR));
    idString  = ExAllocatePool( PagedPool, idStringBufLen);

    if (idString && idWString) {

        //
        // build the ansi string
        //
        sprintf(idString, IDE_BUS_ID_PREFIX);

        CopyField(idString + strlen(idString),
                  deviceTypeIdString,
                  deviceTypeIdLen,
                  '_');

        CopyField(idString + strlen(idString),
                  pdoExtension->FullVendorProductId,
                  sizeof (pdoExtension->FullVendorProductId) - sizeof(CHAR),
                  '_');
        CopyField(idString + strlen(idString),
                  pdoExtension->FullProductRevisionId,
                  sizeof (pdoExtension->FullProductRevisionId) - sizeof(CHAR),
                  '_');

        RtlInitAnsiString (
            &ansiBusIdString,
            idString
            );

        //
        // build the unicode string
        //
        unicodeIdString.Length        = 0;
        unicodeIdString.MaximumLength = idStringBufLen * sizeof(WCHAR);
        unicodeIdString.Buffer        = (PWSTR) idWString;

        RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiBusIdString,
            FALSE
            );

        unicodeIdString.Buffer[unicodeIdString.Length/sizeof(WCHAR)] = L'\0';

    } else {

        if (idWString) {
            ExFreePool (idWString);
        }
    }

    if (idString) {
        ExFreePool (idString);
    }
    return idWString;
}

PWSTR
DeviceBuildInstanceId(
    IN PPDO_EXTENSION pdoExtension
    )
{
    PWSTR       idString;
    USHORT      idStringBufLen;
    NTSTATUS    status;
    WCHAR       ideNonUniqueIdFormat[] = L"%x.%x.%x";

    PAGED_CODE();

    idStringBufLen = (sizeof(pdoExtension->FullSerialNumber) + 1) * sizeof(WCHAR);
    idString = ExAllocatePool (PagedPool, idStringBufLen);
    if( idString == NULL ){

        return NULL;
    }

    //
    // Form the string and return it.
    //
    if (pdoExtension->FullSerialNumber[0]) {

        ANSI_STRING     ansiCompatibleIdString;
        UNICODE_STRING  unicodeIdString;

        //
        // unique id
        //
        RtlInitAnsiString (
            &ansiCompatibleIdString,
            pdoExtension->FullSerialNumber
            );

        unicodeIdString.Length        = 0;
        unicodeIdString.MaximumLength = idStringBufLen;
        unicodeIdString.Buffer        = idString;

        RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiCompatibleIdString,
            FALSE
            );

        idString[unicodeIdString.Length / 2] = L'\0';

    } else {

        //
        // non-unique id
        //
        swprintf( idString,
                  ideNonUniqueIdFormat,
                  pdoExtension->PathId,
                  pdoExtension->TargetId,
                  pdoExtension->Lun);
    }

    return idString;
}

PWSTR
DeviceBuildCompatibleId(
    IN PPDO_EXTENSION pdoExtension
    )
{
    NTSTATUS        status;

    PCSTR           compatibleIdString;

    ANSI_STRING     ansiCompatibleIdString;
    UNICODE_STRING  unicodeIdString;

    PWCHAR          compIdStrings;
    ULONG           totalBufferLen;

	PAGED_CODE();

	if (pdoExtension->ParentDeviceExtension->HwDeviceExtension->
			DeviceFlags[pdoExtension->TargetId] & DFLAGS_LS120_FORMAT) {

			//
			// ls-120 drive detected
			// return the special ls-120 compatible ID
			//
			compatibleIdString = SuperFloppyCompatibleIdString;

		} else {

			compatibleIdString = IdePortGetCompatibleIdString (pdoExtension->ScsiDeviceType);

		}


    RtlInitAnsiString (
        &ansiCompatibleIdString,
        compatibleIdString
        );

    totalBufferLen = RtlAnsiStringToUnicodeSize (
                         &ansiCompatibleIdString
                         );

    unicodeIdString.Length = 0;
    unicodeIdString.MaximumLength = (USHORT) totalBufferLen;

    //
    // null terminator
    //
    totalBufferLen += sizeof(WCHAR);

    //
    // multi-string null terminator
    //
    totalBufferLen += sizeof(WCHAR);

    compIdStrings = ExAllocatePool (PagedPool, totalBufferLen);

    if (compIdStrings) {

        unicodeIdString.Buffer = compIdStrings;
    } else {

        unicodeIdString.Buffer = NULL;
    }

    if (unicodeIdString.Buffer) {

            RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiCompatibleIdString,
            FALSE
            );

        unicodeIdString.Buffer[unicodeIdString.Length/2 + 0] = L'\0';
        unicodeIdString.Buffer[unicodeIdString.Length/2 + 1] = L'\0';
    }

    return compIdStrings;
}

PWSTR
DeviceBuildHardwareId(
    IN PPDO_EXTENSION pdoExtension
    )
{
#define NUMBER_HARDWARE_STRINGS 5

    ULONG           i;
    PWSTR           idMultiString;
    PWSTR           idString;
    UCHAR           scratch[64];
    ULONG           idStringLen;
    NTSTATUS        status;
    ANSI_STRING     ansiCompatibleIdString;
    UNICODE_STRING  unicodeIdString;

    PCSTR           deviceTypeCompIdString;
    UCHAR           deviceTypeCompId[20];
    PCSTR           deviceTypeIdString;
    UCHAR           deviceTypeId[20];

    UCHAR           ScsiDeviceType;

	PAGED_CODE();

    ScsiDeviceType = pdoExtension->ScsiDeviceType;

    idStringLen = (64 * NUMBER_HARDWARE_STRINGS + sizeof (UCHAR)) * sizeof (WCHAR);
    idMultiString = ExAllocatePool (PagedPool, idStringLen);
    if (idMultiString == NULL) {

        return NULL;
    }

    deviceTypeIdString = IdePortGetDeviceTypeString(ScsiDeviceType);
    if (deviceTypeIdString == NULL) {

        sprintf (deviceTypeId,
                 "Type%d",
                 ScsiDeviceType);

        deviceTypeIdString = deviceTypeId;
    }

    if (pdoExtension->ParentDeviceExtension->HwDeviceExtension->
        DeviceFlags[pdoExtension->TargetId] & DFLAGS_LS120_FORMAT) {

        //
        // ls-120 drive detected
        // return the special ls-120 compatible ID
        //
        deviceTypeCompIdString = SuperFloppyCompatibleIdString;

    } else {

        deviceTypeCompIdString = IdePortGetCompatibleIdString (ScsiDeviceType);
        if (deviceTypeCompIdString == NULL) {

            sprintf (deviceTypeCompId,
                     "GenType%d",
                     ScsiDeviceType);

            deviceTypeCompIdString = deviceTypeCompId;
        }
    }

    //
    // Zero out the string buffer
    //

    RtlZeroMemory(idMultiString, idStringLen);
    idString = idMultiString;

    for(i = 0; i < NUMBER_HARDWARE_STRINGS; i++) {

        //
        // Build each of the hardware id's
        //

        switch(i) {

            //
            // Bus + Dev Type + Vendor + Product + Revision
            //

            case 0: {

                sprintf(scratch, "IDE\\%s", deviceTypeIdString);

                CopyField(scratch + strlen(scratch),
                          pdoExtension->FullVendorProductId,
                          sizeof (pdoExtension->FullVendorProductId) - sizeof(CHAR),
                          '_');
                CopyField(scratch + strlen(scratch),
                          pdoExtension->FullProductRevisionId,
                          sizeof (pdoExtension->FullProductRevisionId) - sizeof(CHAR),
                          '_');
                break;
            }

            //
            // bus + vendor + product + revision[0]
            case 1: {

                sprintf(scratch, "IDE\\");

                CopyField(scratch + strlen(scratch),
                          pdoExtension->FullVendorProductId,
                          sizeof (pdoExtension->FullVendorProductId) - sizeof(CHAR),
                          '_');
                CopyField(scratch + strlen(scratch),
                          pdoExtension->FullProductRevisionId,
                          sizeof (pdoExtension->FullProductRevisionId) - sizeof(CHAR),
                          '_');
                break;
            }

            //
            // bus + device + vendor + product
            case 2: {

                sprintf(scratch, "IDE\\%s", deviceTypeIdString);

                CopyField(scratch + strlen(scratch),
                          pdoExtension->FullVendorProductId,
                          sizeof (pdoExtension->FullVendorProductId) - sizeof(CHAR),
                          '_');
                break;
            }

            //
            // vendor + product + revision[0] (win9x)
            case 3: {

                CopyField(scratch,
                          pdoExtension->FullVendorProductId,
                          sizeof (pdoExtension->FullVendorProductId) - sizeof(CHAR),
                          '_');
                CopyField(scratch + strlen(scratch),
                          pdoExtension->FullProductRevisionId,
                          sizeof (pdoExtension->FullProductRevisionId) - sizeof(CHAR),
                          '_');

                break;
            }

            case 4: {

                sprintf(scratch, "%s", deviceTypeCompIdString);
                break;
            }

            default: {

                break;
            }
        }

        RtlInitAnsiString (
            &ansiCompatibleIdString,
            scratch
            );

        unicodeIdString.Length        = 0;
        unicodeIdString.MaximumLength = (USHORT) RtlAnsiStringToUnicodeSize(
                                                     &ansiCompatibleIdString
                                                     );
        unicodeIdString.Buffer        = idString;

        RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiCompatibleIdString,
            FALSE
            );

        idString[unicodeIdString.Length / 2] = L'\0';
        idString += unicodeIdString.Length / 2+ 1;
    }
    idString[0] = L'\0';

    return idMultiString;

#undef NUMBER_HARDWARE_STRINGS
}


VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Count,
    IN UCHAR Change
    )

/*++

Routine Description:

    This routine will copy Count string bytes from Source to Destination.  If
    it finds a nul byte in the Source it will translate that and any subsequent
    bytes into Change.  It will also replace non-printable characters with the
    specified character.

Arguments:

    Destination - the location to copy bytes

    Source - the location to copy bytes from

    Count - the number of bytes to be copied

Return Value:

    none

--*/

{
    ULONG i = 0;
    BOOLEAN pastEnd = FALSE;

	PAGED_CODE();

    for(i = 0; i < Count; i++) {

        if(!pastEnd) {

            if(Source[i] == 0) {

                pastEnd = TRUE;

                Destination[i] = Change;

            } else if ((Source[i] <= L' ') ||
                       (Source[i] > ((WCHAR)0x7f)) ||
                       (Source[i] == L',')) {

                Destination[i] = Change;

            } else {

                Destination[i] = Source[i];

            }
        } else {
            Destination[i] = Change;
        }
    }

    Destination[i] = L'\0';
    return;
}



NTSTATUS
DeviceDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
    PPDO_EXTENSION pdoExtension;
    PSTORAGE_PROPERTY_QUERY storageQuery;
    BOOLEAN passItToFdo;
    PDEVICE_OBJECT ParentDeviceObject;
    NTSTATUS status;
    ULONG controlCode;

#ifdef GET_DISK_GEOMETRY_DEFINED
    PIDE_READ_CAPACITY_CONTEXT context;
    PATA_PASS_THROUGH ataPassThroughData;
    PFDO_EXTENSION fdoExtension;
#endif

    controlCode = thisIrpSp->Parameters.DeviceIoControl.IoControlCode;

#ifdef GET_DISK_GEOMETRY_DEFINED
    if ((DEVICE_TYPE_FROM_CTL_CODE(controlCode) != IOCTL_STORAGE_BASE) &&
        (DEVICE_TYPE_FROM_CTL_CODE(controlCode) != IOCTL_SCSI_BASE &&
         controlCode != IOCTL_DISK_GET_DRIVE_GEOMETRY)) {
#else
    if ((DEVICE_TYPE_FROM_CTL_CODE(controlCode) != IOCTL_STORAGE_BASE) &&
        (DEVICE_TYPE_FROM_CTL_CODE(controlCode) != IOCTL_SCSI_BASE)) {
#endif

        status = Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       FALSE,
                       Irp
                       );

    if (pdoExtension) {

        passItToFdo = TRUE;
        ParentDeviceObject = pdoExtension->ParentDeviceExtension->DeviceObject;

#ifdef GET_DISK_GEOMETRY_DEFINED
        fdoExtension=pdoExtension->ParentDeviceExtension;
        //DebugPrint((DBG_ALWAYS, "DeviceIoCtl: ContlCode=%x, type=%x\n", controlCode,
         //                       DEVICE_TYPE_FROM_CTL_CODE(controlCode)));
#endif
        //
        // RefPdo makes sure that the pdo is not removed.
        //
        switch (controlCode) {

            case IOCTL_SCSI_PASS_THROUGH:
            case IOCTL_SCSI_PASS_THROUGH_DIRECT:

                if (thisIrpSp->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(SCSI_PASS_THROUGH)) {

                    passItToFdo = FALSE;
                    Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                } else {

                    PSCSI_PASS_THROUGH      srbControl;

                    srbControl = Irp->AssociatedIrp.SystemBuffer;
                    srbControl->PathId   = pdoExtension->PathId;
                    srbControl->TargetId = pdoExtension->TargetId;
                    srbControl->Lun      = pdoExtension->Lun;
                }
                break;

            case IOCTL_IDE_PASS_THROUGH:

                passItToFdo = FALSE;
                Irp->IoStatus.Status = IdePortSendPassThrough(pdoExtension, Irp);

                break;

#ifdef GET_DISK_GEOMETRY_DEFINED

    case IOCTL_DISK_GET_DRIVE_GEOMETRY:

        passItToFdo = FALSE;
        if ( thisIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof( DISK_GEOMETRY ) ) {

            Irp->IoStatus.Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
        if ((fdoExtension->HwDeviceExtension->DeviceFlags[pdoExtension->TargetId] & DFLAGS_ATAPI_DEVICE)) {

            Irp->IoStatus.Status=STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // do DeviceIdeReadCapacity
        // code duplication.
        //
        context = ExAllocatePool (
                     NonPagedPool,
                     sizeof(IDE_READ_CAPACITY_CONTEXT)
                     );
        if (context == NULL) {

            //UnrefLogicalUnitExtensionWithTag(
             //   fdoExtension,
              //  pdoExtension,
               // Irp
                //);
            DebugPrint((1, "Could not allocate context\n"));
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // Not a read capacity srb
        //
        context->GeometryIoctl=TRUE;

        context->PdoExtension = pdoExtension;
        context->OriginalIrp = Irp;
        IoMarkIrpPending(Irp);

        ataPassThroughData = &context->AtaPassThroughData;

        RtlZeroMemory (
            ataPassThroughData,
            sizeof (*ataPassThroughData)
            );

        ataPassThroughData->DataBufferSize = sizeof(IDENTIFY_DATA);
        ataPassThroughData->IdeReg.bCommandReg = IDE_COMMAND_IDENTIFY;
        ataPassThroughData->IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;

        status = IssueAsyncAtaPassThroughSafe (
                     pdoExtension->ParentDeviceExtension,
                     pdoExtension,
                     ataPassThroughData,
                     TRUE,
                     DeviceIdeReadCapacityCompletionRoutine,
                     context,
                     FALSE,
                     DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                     FALSE
                     );

        if (status != STATUS_PENDING) {

            DeviceIdeReadCapacityCompletionRoutine (
                pdoExtension->DeviceObject,
                context,
                status
                );
        }

        return status;

#endif

            case IOCTL_SCSI_GET_ADDRESS: {

                PSCSI_ADDRESS scsiAddress = Irp->AssociatedIrp.SystemBuffer;

                passItToFdo = FALSE;

                if(thisIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                   sizeof(SCSI_ADDRESS)) {

                    Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
                    break;
                }

                scsiAddress->Length = sizeof(SCSI_ADDRESS);
                scsiAddress->PortNumber = (UCHAR) pdoExtension->ParentDeviceExtension->ScsiPortNumber;
                scsiAddress->PathId = pdoExtension->PathId;
                scsiAddress->TargetId = pdoExtension->TargetId;
                scsiAddress->Lun = pdoExtension->Lun;

                Irp->IoStatus.Information = sizeof(SCSI_ADDRESS);
                Irp->IoStatus.Status = STATUS_SUCCESS;
                break;
            }

            case IOCTL_SCSI_GET_DUMP_POINTERS:

                passItToFdo = FALSE;

                //
                // Get parameters for crash dump driver.
                //
                if (Irp->RequestorMode != KernelMode) {

                    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

                } else if (thisIrpSp->Parameters.DeviceIoControl.OutputBufferLength
                    < sizeof(DUMP_POINTERS)) {
                    Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;

                } else {

                    PCRASHDUMP_INIT_DATA dumpInitData;

                    //
                    // caller needs to free this
                    //
                    // ISSUE: make sure we tell the parent to power up
                    //
                    dumpInitData = ExAllocatePool (NonPagedPool, sizeof (CRASHDUMP_INIT_DATA));
                    if (dumpInitData) {

                        PDUMP_POINTERS dumpPointers;
                        dumpPointers = (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;

                        RtlZeroMemory (dumpInitData, sizeof (CRASHDUMP_INIT_DATA));
                        dumpInitData->PathId    = pdoExtension->PathId;
                        dumpInitData->TargetId  = pdoExtension->TargetId;
                        dumpInitData->Lun       = pdoExtension->Lun;

                        dumpInitData->LiveHwDeviceExtension = pdoExtension->ParentDeviceExtension->HwDeviceExtension;

                        dumpPointers->AdapterObject      = NULL;
                        dumpPointers->MappedRegisterBase = NULL;
                        dumpPointers->DumpData           = dumpInitData;
                        dumpPointers->CommonBufferVa     = NULL;
                        dumpPointers->CommonBufferPa.QuadPart = 0;
                        dumpPointers->CommonBufferSize      = 0;
                        dumpPointers->DeviceObject          = pdoExtension->DeviceObject;
                        dumpPointers->AllocateCommonBuffers = FALSE;

                        Irp->IoStatus.Status = STATUS_SUCCESS;
                        Irp->IoStatus.Information = sizeof(DUMP_POINTERS);

                    } else {

                        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                        IdeLogNoMemoryError(pdoExtension->ParentDeviceExtension,
                                            pdoExtension->TargetId,
                                            NonPagedPool,
                                            sizeof(CRASHDUMP_INIT_DATA),
                                            IDEPORT_TAG_DUMP_POINTER
                                            );
                    }
                }

                break;


            case IOCTL_STORAGE_QUERY_PROPERTY:

                storageQuery = Irp->AssociatedIrp.SystemBuffer;

                if (thisIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(STORAGE_PROPERTY_QUERY)) {

                    Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                    passItToFdo = FALSE;

                } else {

                    if (storageQuery->PropertyId == StorageDeviceProperty) { // device property

                        ULONG bufferSize;
                        passItToFdo = FALSE;

                        switch (storageQuery->QueryType) {
                            case PropertyStandardQuery:
                                DebugPrint ((2, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY PropertyStandardQuery\n"));

                                bufferSize = thisIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                                Irp->IoStatus.Status = DeviceBuildStorageDeviceDescriptor(
                                                           pdoExtension,
                                                           (PSTORAGE_DEVICE_DESCRIPTOR) Irp->AssociatedIrp.SystemBuffer,
                                                           &bufferSize
                                                           );
                                if (NT_SUCCESS(Irp->IoStatus.Status)) {

                                    Irp->IoStatus.Information = bufferSize;
                                }

                                break;

                            case PropertyExistsQuery:
                                DebugPrint ((2, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY PropertyExistsQuery\n"));
                                // ISSUE: Will be implemented when required
                                Irp->IoStatus.Status = STATUS_SUCCESS;
                                break;

                            case PropertyMaskQuery:
                                DebugPrint ((2, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY PropertyMaskQuery\n"));
                                //ISSUE:  Will implement when required
                                Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                                break;

                            default:
                                DebugPrint ((2, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY unknown type\n"));
                                // ISSUE: Will implement when required
                                Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                                break;
                        }
                    }
                }
            break;
        }

        UnrefPdoWithTag(
            pdoExtension,
            Irp
            );

    } else {

        passItToFdo = FALSE;
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
    }

    if (passItToFdo) {
        return IdePortDeviceControl (
                   ParentDeviceObject, Irp
                   );
    } else {
        status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
}

NTSTATUS
DeviceBuildStorageDeviceDescriptor(
    PPDO_EXTENSION pdoExtension,
    IN OUT PSTORAGE_DEVICE_DESCRIPTOR StorageDeviceDescriptor,
    IN OUT PULONG BufferSize
    )
{

    STORAGE_DEVICE_DESCRIPTOR localStorageDeviceDescriptor;
    ULONG productIdLength;
    ULONG revisionIdLength;
    ULONG serialNumberLength;
    PUCHAR bytebuffer;
    ULONG byteLeft;
    ULONG byteToCopy;

    INQUIRYDATA InquiryData;
    NTSTATUS status;

    ASSERT (pdoExtension);
    ASSERT (StorageDeviceDescriptor);

    productIdLength    = strlen(pdoExtension->FullVendorProductId) + sizeof(UCHAR);
    revisionIdLength   = strlen(pdoExtension->FullProductRevisionId) + sizeof(UCHAR);
    serialNumberLength = strlen(pdoExtension->FullSerialNumber) + sizeof(UCHAR);

    RtlZeroMemory (&localStorageDeviceDescriptor, sizeof (STORAGE_DEVICE_DESCRIPTOR));
    localStorageDeviceDescriptor.Version = sizeof (STORAGE_DEVICE_DESCRIPTOR);
    localStorageDeviceDescriptor.Size = sizeof (STORAGE_DEVICE_DESCRIPTOR) +
                                        INQUIRYDATABUFFERSIZE +
                                        productIdLength +
                                        revisionIdLength +
                                        serialNumberLength;

    localStorageDeviceDescriptor.DeviceType = pdoExtension->ScsiDeviceType;

    if (pdoExtension->
            ParentDeviceExtension->
            HwDeviceExtension->
            DeviceFlags[pdoExtension->TargetId] &
            DFLAGS_REMOVABLE_DRIVE) {

        localStorageDeviceDescriptor.RemovableMedia = TRUE;
    }

    if (pdoExtension->
            ParentDeviceExtension->
            HwDeviceExtension->
            DeviceFlags[pdoExtension->TargetId] &
            DFLAGS_ATAPI_DEVICE) {

        localStorageDeviceDescriptor.BusType = BusTypeAtapi;
    } else {

        localStorageDeviceDescriptor.BusType = BusTypeAta;
    }

    bytebuffer = (PUCHAR) StorageDeviceDescriptor;
    byteLeft = *BufferSize;

    //
    // copy the basic STORAGE_DEVICE_DESCRIPTOR
    //
    if (byteLeft) {

        byteToCopy = min(sizeof (STORAGE_DEVICE_DESCRIPTOR), byteLeft);

        RtlCopyMemory (StorageDeviceDescriptor,
                       &localStorageDeviceDescriptor,
                       byteToCopy);

        bytebuffer += byteToCopy;
        byteLeft -= byteToCopy;
    }

    //
    // copy raw device properties (Inquiry Data)
    //
    if (byteLeft) {

        status = IssueInquirySafe(
                     pdoExtension->ParentDeviceExtension,
                     pdoExtension,
                     &InquiryData,
                     FALSE
                     );

        if (NT_SUCCESS(status) || (status == STATUS_DATA_OVERRUN)) {

            byteToCopy = min(INQUIRYDATABUFFERSIZE, byteLeft);

            RtlCopyMemory (bytebuffer,
                           &InquiryData,
                           byteToCopy);

            StorageDeviceDescriptor->RawPropertiesLength = byteToCopy;

            bytebuffer += byteToCopy;
            byteLeft -= byteToCopy;
        }
    }

    //
    // copy product ID
    //
    if (byteLeft) {

        byteToCopy = min(productIdLength, byteLeft);

        RtlCopyMemory (bytebuffer,
                       pdoExtension->FullVendorProductId,
                       byteToCopy);
        bytebuffer[byteToCopy - 1] = '\0';

        StorageDeviceDescriptor->ProductIdOffset = *BufferSize - byteLeft;

        bytebuffer += byteToCopy;
        byteLeft -= byteToCopy;
    }

    //
    // copy revision ID
    //
    if (byteLeft) {

        byteToCopy = min(productIdLength, byteLeft);

        RtlCopyMemory (bytebuffer,
                       pdoExtension->FullProductRevisionId,
                       byteToCopy);
        bytebuffer[byteToCopy - 1] = '\0';

        StorageDeviceDescriptor->ProductRevisionOffset = *BufferSize - byteLeft;

        bytebuffer += byteToCopy;
        byteLeft -= byteToCopy;
    }

    //
    // copy serial #
    //
    if (byteLeft) {

        byteToCopy = min(serialNumberLength, byteLeft);

        RtlCopyMemory (bytebuffer,
                       pdoExtension->FullSerialNumber,
                       byteToCopy);
        bytebuffer[byteToCopy - 1] = '\0';

        StorageDeviceDescriptor->SerialNumberOffset = *BufferSize - byteLeft;

        bytebuffer += byteToCopy;
        byteLeft -= byteToCopy;
    }

    *BufferSize -= byteLeft;

    return STATUS_SUCCESS;

} // DeviceBuildStorageDeviceDescriptor


NTSTATUS
DeviceQueryCapabilities (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION      thisIrpSp;
    PPDO_EXTENSION          pdoExtension;
    PDEVICE_CAPABILITIES    capabilities;
    NTSTATUS                status;

	PAGED_CODE();

    thisIrpSp    = IoGetCurrentIrpStackLocation( Irp );
    capabilities = thisIrpSp->Parameters.DeviceCapabilities.Capabilities;

    pdoExtension = RefPdoWithTag (
                       DeviceObject,
                       TRUE,
                       DeviceQueryCapabilities
                       );

    if (pdoExtension == NULL) {

        status = STATUS_DEVICE_DOES_NOT_EXIST;

    } else {

        DEVICE_CAPABILITIES parentDeviceCapabilities;

        status = IdeGetDeviceCapabilities(
                     pdoExtension->ParentDeviceExtension->AttacheePdo,
                     &parentDeviceCapabilities);

        if (NT_SUCCESS(status)) {

            RtlMoveMemory (
                capabilities,
                &parentDeviceCapabilities,
                sizeof(DEVICE_CAPABILITIES));

            if (pdoExtension->FullSerialNumber[0]) {

                capabilities->UniqueID          = TRUE;
            } else {

                capabilities->UniqueID          = FALSE;
            }

            //
            // never!
            //
            capabilities->Removable         = FALSE;
            capabilities->SurpriseRemovalOK = FALSE;

            capabilities->Address           = PNP_ADDRESS(pdoExtension->TargetId, pdoExtension->Lun);
            capabilities->UINumber          = pdoExtension->TargetId;

            capabilities->D1Latency         = 31 * (1000 * 10);     // 31s
            capabilities->D2Latency         = 31 * (1000 * 10);     // 31s
            capabilities->D3Latency         = 31 * (1000 * 10);     // 31s
        }

        UnrefPdoWithTag (
            pdoExtension,
            DeviceQueryCapabilities
            );

    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
} // DeviceQueryCapabitilies

NTSTATUS
IdePortInsertByKeyDeviceQueue (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp,
    IN ULONG SortKey,
    OUT PBOOLEAN Inserted
    )
{
    KIRQL currentIrql;
    NTSTATUS status;
    POWER_STATE powerState;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    BOOLEAN urgentSrb;

    status = STATUS_SUCCESS;
    *Inserted = FALSE;

    KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);

    if (PdoExtension->LuFlags & PD_QUEUE_FROZEN) {

        DebugPrint((1,"IdePortDispatch:  Request put in frozen queue!\n"));
    }

    *Inserted = KeInsertByKeyDeviceQueue(
                    &PdoExtension->DeviceObject->DeviceQueue,
                    &Irp->Tail.Overlay.DeviceQueueEntry,
                    SortKey);

    if (*Inserted == FALSE) {

        if (PdoExtension->PdoState & PDOS_QUEUE_BLOCKED) {

            ASSERT (PdoExtension->PendingRequest == NULL);
            PdoExtension->PendingRequest = Irp;
            *Inserted = TRUE;

            if (!(PdoExtension->PdoState & PDOS_MUST_QUEUE)) {

                POWER_STATE powerState;

                //
                // device is powered down
                // use a large time in case it spins up slowly
                //
                if (srb->TimeOutValue < DEFAULT_SPINUP_TIME) {

                    srb->TimeOutValue = DEFAULT_SPINUP_TIME;
                }

                //
                // We are not powered up.
                // issue an power up
                //
                powerState.DeviceState = PowerDeviceD0;
                status = PoRequestPowerIrp (
                             PdoExtension->DeviceObject,
                             IRP_MN_SET_POWER,
                             powerState,
                             NULL,
                             NULL,
                             NULL
                             );
                ASSERT (NT_SUCCESS(status));

                DebugPrint ((2, "IdePort GetNextLuRequest: 0x%x 0x%x need to spin up device, requeue irp 0x%x\n",
                             PdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             PdoExtension->TargetId,
                             Irp));
            }

        } else if (srb->Function != SRB_FUNCTION_ATA_POWER_PASS_THROUGH) {

            //
            // If this irp is not for changing power state, we may have
            // to queue it
            //
            if (PdoExtension->DevicePowerState != PowerDeviceD0) {

                if (PdoExtension->DevicePowerState != PowerDeviceD3) {

                    //
                    // we are in D1 or D2.
                    // We can never be sure that we are in D0 when
                    // we tell the device to go from D1/D2 to D0.
                    // Some device lies and won't spin up until it sees
                    // a media access command.  This causes longer time
                    // to execute the command
                    //
                    // to prevent the next command from timing out, we
                    // will increment its timeout
                    //

                    if (srb->TimeOutValue < 30) {

                        srb->TimeOutValue = 30;
                    }
                }

                //
                // We are not powered up.
                // issue an power up
                //
                powerState.DeviceState = PowerDeviceD0;
                status = PoRequestPowerIrp (
                             PdoExtension->DeviceObject,
                             IRP_MN_SET_POWER,
                             powerState,
                             NULL,
                             NULL,
                             NULL
                             );

                ASSERT (NT_SUCCESS(status));
                status = STATUS_SUCCESS;

                ASSERT (PdoExtension->PendingRequest == NULL);
                PdoExtension->PendingRequest = Irp;

                DebugPrint ((1, "IdePort IdePortInsertByKeyDeviceQueue: 0x%x 0x%x need to spin up device, requeue irp 0x%x\n",
                             PdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             PdoExtension->TargetId,
                             Irp));

                *Inserted = TRUE;
            }
        }

    } else {

#if DBG
        InterlockedIncrement (
            &PdoExtension->NumberOfIrpQueued
            );
#endif // DBG

    }

    KeLowerIrql(currentIrql);
    return status;
}

VOID
DeviceInitCompletionRoutine (
    PVOID Context,
    NTSTATUS Status
    )
{
    PKEVENT event = Context;

    if (!NT_SUCCESS(Status)) {

        //ASSERT (!"DeviceInitDeviceState Failed\n");
        DebugPrint((DBG_ALWAYS, "ATAPI: ERROR: DeviceInitDeviceStateFailed with Status %x\n",
                        Status));
    }

    KeSetEvent (event, 0, FALSE);
}

NTSTATUS
DeviceQueryText (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PPDO_EXTENSION      pdoExtension;
    PWCHAR              returnString;
    LONG                i;
    UNICODE_STRING      unicodeString;
    ANSI_STRING         ansiString;
    ULONG               stringLen;
    NTSTATUS            status;

	PAGED_CODE();
    thisIrpSp    = IoGetCurrentIrpStackLocation (Irp);

    returnString = NULL;
    Irp->IoStatus.Information = 0;

    pdoExtension = RefPdoWithTag (
                       DeviceObject,
                       TRUE,
                       DeviceQueryText
                       );

    if (pdoExtension == NULL) {

        status = STATUS_DEVICE_DOES_NOT_EXIST;

    } else {

        status = STATUS_NO_MEMORY;

        if (thisIrpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {

            stringLen = sizeof (pdoExtension->FullVendorProductId) * sizeof (WCHAR);

            returnString = ExAllocatePool (
                               PagedPool,
                               stringLen
                               );
            if (returnString) {

                unicodeString.Length        = 0;
                unicodeString.MaximumLength = (USHORT) stringLen;
                unicodeString.Buffer        = returnString;

                //
                // vendor ID
                //
                RtlInitAnsiString (
                    &ansiString,
                    pdoExtension->FullVendorProductId
                    );

                RtlAnsiStringToUnicodeString(
                    &unicodeString,
                    &ansiString,
                    FALSE
                    );

                ASSERT(unicodeString.Length < unicodeString.MaximumLength);
                //
                // get rid of trailing spaces and nulls
                //
                for (i=(unicodeString.Length/2)-1; i >= 0; i--) {

                    if ((returnString[i] == ' ') || (returnString[i] == 0)) {

                        continue;

                    } else {

                        break;
                    }
                }

                //
                // null terminate it
                //
                returnString[i + 1] = 0;

                status = STATUS_SUCCESS;
            }
        } else if (thisIrpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextLocationInformation) {

            stringLen = 100;

            returnString = ExAllocatePool (
                               PagedPool,
                               stringLen
                               );

            if (returnString) {

                swprintf(returnString, L"%ws",
                         (((pdoExtension->TargetId & 0x1) == 0) ? L"0" :
                                                                  L"1"));

                RtlInitUnicodeString(&unicodeString, returnString);

                //
                // null terminate it
                //
                unicodeString.Buffer[unicodeString.Length/sizeof(WCHAR) + 0] = L'\0';

                status = STATUS_SUCCESS;
            }

        } else {

            status = STATUS_NOT_SUPPORTED;
        }

        UnrefPdoWithTag (
            pdoExtension,
            DeviceQueryText
            );
    }

    Irp->IoStatus.Information = (ULONG_PTR) returnString;
    Irp->IoStatus.Status = status;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // DeviceQueryText

NTSTATUS
IdePortSendPassThrough (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function sends a user specified IDE task registers
    It creates an srb which is processed normally by the port driver.
    This call is synchornous.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    RequestIrp - Supplies a pointe to the Irp which made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/

{
    PIO_STACK_LOCATION      irpStack;
    PATA_PASS_THROUGH       ataPassThroughData;
    ULONG                   dataBufferSize;
    BOOLEAN                 dataIn;
    NTSTATUS                status;
    ULONG                   outputBufferSize;

    PAGED_CODE();

    DebugPrint((3,"IdePortSendPassThrough: Enter routine\n"));

    //
    // validate target device
    //
    if (PdoExtension->Lun != 0) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Get a pointer to the control block.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    ataPassThroughData = Irp->AssociatedIrp.SystemBuffer;

    //
    // Validiate the user buffer.
    //
    if (irpStack->Parameters.DeviceIoControl.InputBufferLength < FIELD_OFFSET(ATA_PASS_THROUGH, DataBuffer)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < FIELD_OFFSET(ATA_PASS_THROUGH, DataBuffer)) {
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(ataPassThroughData != NULL);

    dataBufferSize = ataPassThroughData->DataBufferSize;

    outputBufferSize = FIELD_OFFSET(ATA_PASS_THROUGH, DataBuffer) + dataBufferSize;
    if (outputBufferSize < dataBufferSize) {

        //
        // outputBufferSize overflows a ULONG
        //
        outputBufferSize = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    }

    if ((irpStack->Parameters.DeviceIoControl.OutputBufferLength) >=
        outputBufferSize) {

        dataIn = TRUE;
    } else {

        dataIn = FALSE;
    }

    status = IssueSyncAtaPassThroughSafe (
                 PdoExtension->ParentDeviceExtension,
                 PdoExtension,
                 ataPassThroughData,
                 dataIn,
                 FALSE,
                 DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                 FALSE
                 );

    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Information = outputBufferSize;

    } else {

        //
        // ignore all errors
        // let the caller figure out the error
        // from the task file registers
        //
        status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FIELD_OFFSET(ATA_PASS_THROUGH, DataBuffer);
    }

    Irp->IoStatus.Status = status;
    return status;

} // IdePortSendPassThrough

VOID
DeviceRegisterIdleDetection (
    IN PPDO_EXTENSION PdoExtension,
    IN ULONG ConservationIdleTime,
    IN ULONG PerformanceIdleTime
)
{
    NTSTATUS          status;
    ATA_PASS_THROUGH  ataPassThroughData;

    //
    // Many ATAPI device (Acer and Panasonice Changer) doesn't like ATA
    // power down command.  Since they auto-spin-down anyway, we are not
    // go to power manage it
    //
    if (!(PdoExtension->PdoState & PDOS_NO_POWER_DOWN)) {

        if (!PdoExtension->CrashDumpPathCount) {

            RtlZeroMemory (&ataPassThroughData, sizeof(ataPassThroughData));
            ataPassThroughData.IdeReg.bCommandReg = IDE_COMMAND_IDLE_IMMEDIATE;
            ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;

            status = IssueSyncAtaPassThroughSafe (
                         PdoExtension->ParentDeviceExtension,
                         PdoExtension,
                         &ataPassThroughData,
                         FALSE,
                         FALSE,
                         DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                         FALSE
                         );

            if (NT_SUCCESS(status)) {

                DEVICE_POWER_STATE devicePowerState;

                //
                // ISSUE
                // should check the registry/device property whether
                // idle detection has been disabled for this device
                //
                devicePowerState = PowerDeviceD3;
                PdoExtension->IdleCounter = PoRegisterDeviceForIdleDetection (
                                                PdoExtension->DeviceObject,
                                                ConservationIdleTime,            // seconds
                                                PerformanceIdleTime,             // seconds
                                                devicePowerState
                                                );

                DebugPrint ((1, "IdePort: pdoExtension 0x%x support power managerment command\n", PdoExtension));

            } else {

                KIRQL             currentIrql;

                KeAcquireSpinLock(&PdoExtension->PdoSpinLock, &currentIrql);

                SETMASK (PdoExtension->PdoState, PDOS_NO_POWER_DOWN);

                KeReleaseSpinLock(&PdoExtension->PdoSpinLock, currentIrql);

                DebugPrint ((1, "IdePort: pdoExtension 0x%x DOES NOT support power managerment command\n", PdoExtension));
            }
        }
    }

    return;
}

VOID
DeviceUnregisterIdleDetection (
    IN PPDO_EXTENSION PdoExtension
)
{
    DEVICE_POWER_STATE devicePowerState;
    devicePowerState = PowerDeviceD3;

    if (PdoExtension->IdleCounter) {

        PoRegisterDeviceForIdleDetection (
            PdoExtension->DeviceObject,
            0,
            0,
            devicePowerState
            );

        PdoExtension->IdleCounter = NULL;
    }
    return;
}

VOID
DeviceInitIdStrings (
    IN PPDO_EXTENSION PdoExtension,
    IN IDE_DEVICETYPE DeviceType,
    IN PINQUIRYDATA   InquiryData,
    IN PIDENTIFY_DATA IdentifyData
)
{
    LONG i;
    UCHAR c;

    SPECIAL_ACTION_FLAG specialFlags;

	PAGED_CODE();

    ASSERT (PdoExtension);
    ASSERT (IdentifyData);

    if (DeviceType == DeviceIsAta) {

        CopyField(
            PdoExtension->FullVendorProductId,
            IdentifyData->ModelNumber,
            sizeof(PdoExtension->FullVendorProductId)-1,
            ' '
            );

        CopyField(
            PdoExtension->FullProductRevisionId,
            IdentifyData->FirmwareRevision,
            sizeof(PdoExtension->FullProductRevisionId)-1,
            ' '
            );

        //
        // byte swap
        //
        for (i=0; i<sizeof(PdoExtension->FullVendorProductId)-1; i+=2) {
            c = PdoExtension->FullVendorProductId[i];
            PdoExtension->FullVendorProductId[i] = PdoExtension->FullVendorProductId[i + 1];
            PdoExtension->FullVendorProductId[i + 1] = c;
        }
        for (i=0; i<sizeof(PdoExtension->FullProductRevisionId)-1; i+=2) {
            c = PdoExtension->FullProductRevisionId[i];
            PdoExtension->FullProductRevisionId[i] = PdoExtension->FullProductRevisionId[i + 1];
            PdoExtension->FullProductRevisionId[i + 1] = c;
        }

    } else if (DeviceType == DeviceIsAtapi) {

        PUCHAR fullVendorProductId;

        fullVendorProductId = PdoExtension->FullVendorProductId;

        CopyField(
            fullVendorProductId,
            InquiryData->VendorId,
            8,
            ' '
            );

        for (i=7; i >= 0; i--) {

            if (fullVendorProductId[i] != ' ') {

                fullVendorProductId[i + 1] = ' ';
                fullVendorProductId += i + 2;
                break;
            }
        }

        CopyField(
            fullVendorProductId,
            InquiryData->ProductId,
            16,
            ' '
            );

        fullVendorProductId += 16;

        for (i=0; fullVendorProductId+i < PdoExtension->FullVendorProductId+40; i++) {
            fullVendorProductId[i] = ' ';
        }

        CopyField(
            PdoExtension->FullProductRevisionId,
            InquiryData->ProductRevisionLevel,
            4,
            ' '
            );

        for (i=4; i<8; i++) {
            PdoExtension->FullProductRevisionId[i] = ' ';
        }

    } else {

        ASSERT (FALSE);
    }

    //
    // take out trailing spaces
    //
    for (i=sizeof(PdoExtension->FullVendorProductId)-2; i >= 0; i--) {

        if (PdoExtension->FullVendorProductId[i] != ' ') {

            PdoExtension->FullVendorProductId[i+1] = '\0';
            break;
        }
    }

    for (i=sizeof(PdoExtension->FullProductRevisionId)-2; i >= 0; i--) {

        if (PdoExtension->FullProductRevisionId[i] != ' ') {

            PdoExtension->FullProductRevisionId[i+1] = '\0';
            break;
        }
    }

    //
    // Check the vendor & product id to see if we should disable the serial
    // number for this device.
    //

    specialFlags = IdeFindSpecialDevice(PdoExtension->FullVendorProductId,
                                        PdoExtension->FullProductRevisionId);

    //
    // look for serial number
    //
    // some device returns non-printable characters as part of its
    // serial number.  to get around this, we will turn all raw numbers
    // into a string.
    //
    if ((specialFlags != disableSerialNumber) &&
        (IdentifyData->SerialNumber[0] != ' ') &&
        (IdentifyData->SerialNumber[0] != '\0')) {

        for (i=0; i<sizeof(IdentifyData->SerialNumber); i++) {

            sprintf (PdoExtension->FullSerialNumber+i*2, "%2x", IdentifyData->SerialNumber[i]);
        }

        PdoExtension->FullSerialNumber[sizeof(PdoExtension->FullSerialNumber) - 1] = '\0';

    } else {

        PdoExtension->FullSerialNumber[0] = '\0';
    }

    DebugPrint ((
        DBG_BUSSCAN,
        "PDOE 0x%x: Full IDs \n\t%s\n\t%s\n\t%s\n",
        PdoExtension,
        PdoExtension->FullVendorProductId,
        PdoExtension->FullProductRevisionId,
        PdoExtension->FullSerialNumber
        ));

    return;
}

VOID
DeviceInitDeviceType (
    IN PPDO_EXTENSION PdoExtension,
    IN PINQUIRYDATA   InquiryData
)
{
    PdoExtension->ScsiDeviceType = InquiryData->DeviceType;

    if(InquiryData->RemovableMedia) {

        SETMASK (PdoExtension->DeviceObject->Characteristics, FILE_REMOVABLE_MEDIA);
    }

    return;
}

NTSTATUS
DeviceQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PDEVICE_RELATIONS   deviceRelations;
    NTSTATUS            status;

    IDE_PATH_ID         pathId;
    PPDO_EXTENSION      pdoExtension;
    PPDO_EXTENSION      otherPdoExtension;
    ULONG               numPdos;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

    switch (thisIrpSp->Parameters.QueryDeviceRelations.Type) {

        case TargetDeviceRelation:

            deviceRelations = ExAllocatePool (
                                  NonPagedPool,
                                  sizeof(*deviceRelations) +
                                    sizeof(deviceRelations->Objects[0]) * 1
                                  );

            if (deviceRelations != NULL) {

                deviceRelations->Count = 1;
                deviceRelations->Objects[0] = DeviceObject;

                ObReferenceObjectByPointer(DeviceObject,
                                           0,
                                           0,
                                           KernelMode);

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
            } else {

                Irp->IoStatus.Status = STATUS_NO_MEMORY;
                Irp->IoStatus.Information = 0;
            }
            break;
    }

    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // DeviceQueryDeviceRelations

NTSTATUS
DeviceQueryInitData (
    IN PPDO_EXTENSION PdoExtension
    )
{
    PDEVICE_SETTINGS deviceSettings;
    PDEVICE_SETTINGS tempDeviceSettings;
    NTSTATUS status;
    ATA_PASS_THROUGH ataPassThroughData;
    ULONG i;
    PPDO_EXTENSION   lun0PdoExtension;
    ULONG totalDeviceSettingEntries;
    ULONG firstNewEntryOffset;

	PAGED_CODE();

    DebugPrint ((
        DBG_PNP,
        "DeviceQueryInitData: Init. pdoe 0x%x (%d,%d,%d)\n",
        PdoExtension,
        PdoExtension->PathId,
        PdoExtension->TargetId,
        PdoExtension->Lun
        ));

    deviceSettings = PdoExtension->AcpiDeviceSettings;
    if (deviceSettings == NULL) {

        //
        // ISSUE: we can't be sure acpi is always attached on lun0
        //
        // get the lun0 pdo
        //
        lun0PdoExtension = RefLogicalUnitExtensionWithTag(
                               PdoExtension->ParentDeviceExtension,
                               PdoExtension->PathId,
                               PdoExtension->TargetId,
                               0,
                               TRUE,
                               DeviceQueryInitData
                               );

        if (lun0PdoExtension) {

            ASSERT (lun0PdoExtension->TargetId == PdoExtension->TargetId);

            status = DeviceQueryFirmwareBootSettings (
                         lun0PdoExtension,
                         &deviceSettings
                         );

            //
            // let go Lun0
            //
            UnrefPdoWithTag(
                lun0PdoExtension,
                DeviceQueryInitData
                );
        }

        if (deviceSettings) {

            ULONG i;
            ULONG j;

            for (i=0; i<deviceSettings->NumEntries; i++) {

                //
                // Ignore SET_DRIVE_PARAMETERS, SET_MULTIPLE and set transfermode commands
                // in GTF
                //
                if (((deviceSettings->FirmwareSettings[i].bCommandReg == IDE_COMMAND_SET_FEATURE) &&
                     (deviceSettings->FirmwareSettings[i].bFeaturesReg == IDE_SET_FEATURE_SET_TRANSFER_MODE)) ||
                    (deviceSettings->FirmwareSettings[i].bCommandReg == IDE_COMMAND_SET_DRIVE_PARAMETERS) ||
                    (deviceSettings->FirmwareSettings[i].bCommandReg == IDE_COMMAND_SET_MULTIPLE)) {

                    DebugPrint((DBG_ACPI,
                                "Ignoring Command %xin GTF\n",
                                deviceSettings->FirmwareSettings[i].bCommandReg
                                ));

                    deviceSettings->NumEntries--;

                    //
                    // remove this command by shifting the rest up one entry
                    //
                    for (j=i; j<deviceSettings->NumEntries; j++) {

                        deviceSettings->FirmwareSettings[j] = deviceSettings->FirmwareSettings[j+1];
                    }

                    //
                    // we move something new into the current i entry
                    // better adjust i so that we will check this entry
                    // again
                    //
                    if (i < deviceSettings->NumEntries) {
                        i--;
                    }
                }


            }
        }

        //
        // we need to add a new setting
        //
        if (PdoExtension->ScsiDeviceType == DIRECT_ACCESS_DEVICE) {
            totalDeviceSettingEntries = 2;
        } else {
            totalDeviceSettingEntries = 1;
        }

        if (deviceSettings) {
            totalDeviceSettingEntries += deviceSettings->NumEntries;
            firstNewEntryOffset = deviceSettings->NumEntries;
        } else {
            firstNewEntryOffset = 0;
        }

        tempDeviceSettings = ExAllocatePool (
                                  NonPagedPool,
                                  sizeof(DEVICE_SETTINGS) +
                                    (totalDeviceSettingEntries) * sizeof(IDEREGS)
                                  );

        if (tempDeviceSettings) {

            tempDeviceSettings->NumEntries = totalDeviceSettingEntries;

            //
            // copy the settings from acpi query
            //
            if (deviceSettings) {
                RtlCopyMemory (&tempDeviceSettings->FirmwareSettings,
                    &deviceSettings->FirmwareSettings,
                    sizeof(IDEREGS) * deviceSettings->NumEntries);

                //
                // don't need the old structure anymore
                //
                ExFreePool (deviceSettings);
                deviceSettings = NULL;
            }

            //
            // add the new settings
            //
            RtlZeroMemory (
                &tempDeviceSettings->FirmwareSettings[firstNewEntryOffset],
                sizeof (IDEREGS));
            tempDeviceSettings->FirmwareSettings[firstNewEntryOffset].bFeaturesReg =
                IDE_SET_FEATURE_DISABLE_REVERT_TO_POWER_ON;
            tempDeviceSettings->FirmwareSettings[firstNewEntryOffset].bCommandReg =
                IDE_COMMAND_SET_FEATURE;
            tempDeviceSettings->FirmwareSettings[firstNewEntryOffset].bReserved =
                ATA_PTFLAGS_STATUS_DRDY_REQUIRED | ATA_PTFLAGS_OK_TO_FAIL;

            if (PdoExtension->ScsiDeviceType == DIRECT_ACCESS_DEVICE) {

                RtlZeroMemory (
                    &tempDeviceSettings->FirmwareSettings[firstNewEntryOffset + 1],
                    sizeof (IDEREGS));
                tempDeviceSettings->FirmwareSettings[firstNewEntryOffset + 1].bFeaturesReg =
                    IDE_SET_FEATURE_ENABLE_WRITE_CACHE;
                tempDeviceSettings->FirmwareSettings[firstNewEntryOffset + 1].bCommandReg =
                    IDE_COMMAND_SET_FEATURE;
                tempDeviceSettings->FirmwareSettings[firstNewEntryOffset + 1].bReserved =
                    ATA_PTFLAGS_STATUS_DRDY_REQUIRED | ATA_PTFLAGS_OK_TO_FAIL;
            }

            //
            // throw away the old and keep the new
            //
            deviceSettings = tempDeviceSettings;

        } else {

            //
            // someone took all the memory.
            // we can't build a new device setting structure
            // will have to use the old one
            //
        }

        //
        // keep it around
        //
        PdoExtension->AcpiDeviceSettings = deviceSettings;

    }

    return STATUS_SUCCESS;
}

NTSTATUS
DeviceInitDeviceState (
    IN PPDO_EXTENSION PdoExtension,
    DEVICE_INIT_COMPLETION DeviceInitCompletionRoutine,
    PVOID DeviceInitCompletionContext
    )
{
    PDEVICE_SETTINGS deviceSettings;
    NTSTATUS status;
    PDEVICE_INIT_DEVICE_STATE_CONTEXT deviceStateContext;
    ULONG deviceStateContextSize;
    ULONG numState;
    ULONG numRequestSent;
    DEVICE_INIT_STATE deviceInitState[deviceInitState_done];

    if (!InterlockedExchange (&PdoExtension->InitDeviceWithAcpiGtf, 0)) {

        //
        // make sure we only do this once per start
        //
        return STATUS_SUCCESS;
    }

    if (!(PdoExtension->PdoState & PDOS_STARTED)) {

        DebugPrint ((DBG_PNP, "DeviceInitDeviceState: device not started...skipping acpi init\n"));

        (DeviceInitCompletionRoutine) (
            DeviceInitCompletionContext,
            STATUS_SUCCESS
            );

        return STATUS_SUCCESS;
    }

    deviceStateContextSize = sizeof (DEVICE_INIT_DEVICE_STATE_CONTEXT);

    deviceStateContext = ExAllocatePool (NonPagedPool, deviceStateContextSize);
    if (deviceStateContext == NULL) {

        return STATUS_NO_MEMORY;
    }

    if (!RefPdoWithTag(PdoExtension->DeviceObject, FALSE, DeviceInitDeviceState)) {
        ExFreePool (deviceStateContext);
        return STATUS_NO_SUCH_DEVICE;
    }

    RtlZeroMemory(
        deviceStateContext,
        deviceStateContextSize
        );

    deviceSettings = PdoExtension->AcpiDeviceSettings;

    //
    // compute the total number of inti state we are going to have
    //
    numState = 0;
    if (deviceSettings) {

        deviceStateContext->DeviceInitState[numState] = deviceInitState_acpi;
        numState++;
    }
    deviceStateContext->DeviceInitState[numState] = deviceInitState_done;
    numState++;

    ASSERT(numState <= deviceInitState_max);

    deviceStateContext->PdoExtension = PdoExtension;
    deviceStateContext->NumInitState = numState;
    deviceStateContext->DeviceInitCompletionRoutine = DeviceInitCompletionRoutine;
    deviceStateContext->DeviceInitCompletionContext = DeviceInitCompletionContext;

    DeviceInitDeviceStateCompletionRoutine (
        PdoExtension->DeviceObject,
        deviceStateContext,
        STATUS_SUCCESS
        );

    return STATUS_PENDING;
} // DeviceInitDeviceState

VOID
DeviceInitDeviceStateCompletionRoutine (
    PDEVICE_OBJECT DeviceObject,
    PVOID Context,
    NTSTATUS Status
    )
{
    ULONG numRequestCompleted;
    PDEVICE_INIT_DEVICE_STATE_CONTEXT deviceStateContext = Context;
    PDEVICE_SETTINGS deviceSettings;
    PPDO_EXTENSION PdoExtension;
    NTSTATUS status;

    if (!NT_SUCCESS(Status)) {

        InterlockedIncrement (&deviceStateContext->NumRequestFailed);
        DebugPrint ((DBG_ALWAYS, "DeviceInitDeviceStateCompletionRoutine: Last init. command failed with status %x\n",
                        Status));
    }

    PdoExtension = deviceStateContext->PdoExtension;
    switch (deviceStateContext->DeviceInitState[deviceStateContext->CurrentState]) {

        case deviceInitState_acpi:

        deviceSettings = PdoExtension->AcpiDeviceSettings;
        ASSERT (deviceSettings);

        RtlZeroMemory (
            &deviceStateContext->AtaPassThroughData,
            sizeof(deviceStateContext->AtaPassThroughData)
            );

        deviceStateContext->AtaPassThroughData.IdeReg =
            deviceSettings->FirmwareSettings[deviceStateContext->NumAcpiRequestSent];

        deviceStateContext->AtaPassThroughData.IdeReg.bReserved |=
            ATA_PTFLAGS_STATUS_DRDY_REQUIRED | ATA_PTFLAGS_URGENT;

        deviceStateContext->NumAcpiRequestSent++;
        if (deviceStateContext->NumAcpiRequestSent >= deviceSettings->NumEntries) {
            //
            // sent all acpi init state.  go to the next state
            //
            deviceStateContext->CurrentState++;
        }

        if ((deviceStateContext->AtaPassThroughData.IdeReg.bFeaturesReg ==
             IDE_SET_FEATURE_ENABLE_WRITE_CACHE) &&
            (deviceStateContext->AtaPassThroughData.IdeReg.bCommandReg ==
             IDE_COMMAND_SET_FEATURE)) {

            //
            // only ata harddisk should have this entry
            //
            ASSERT (PdoExtension->ScsiDeviceType == DIRECT_ACCESS_DEVICE);

            if (PdoExtension->WriteCacheEnable == FALSE) {

                deviceStateContext->AtaPassThroughData.IdeReg.bFeaturesReg =
                    IDE_SET_FEATURE_DISABLE_WRITE_CACHE;
            }
        }


        DebugPrint ((
            DBG_PNP,
            "IdePort: restore firmware settings from ACPI BIOS. ide command = 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
            deviceStateContext->AtaPassThroughData.IdeReg.bFeaturesReg,
            deviceStateContext->AtaPassThroughData.IdeReg.bSectorCountReg,
            deviceStateContext->AtaPassThroughData.IdeReg.bSectorNumberReg,
            deviceStateContext->AtaPassThroughData.IdeReg.bCylLowReg,
            deviceStateContext->AtaPassThroughData.IdeReg.bCylHighReg,
            deviceStateContext->AtaPassThroughData.IdeReg.bDriveHeadReg,
            deviceStateContext->AtaPassThroughData.IdeReg.bCommandReg
            ));

        status = IssueAsyncAtaPassThroughSafe (
                    PdoExtension->ParentDeviceExtension,
                    PdoExtension,
                    &deviceStateContext->AtaPassThroughData,
                    TRUE,
                    DeviceInitDeviceStateCompletionRoutine,
                    deviceStateContext,
                    FALSE,
                    DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                    FALSE
                    );
        if (!NT_SUCCESS(status)) {

            //
            // can't send the request
            // notify the completion routine that we fail
            //
            DeviceInitDeviceStateCompletionRoutine (
                PdoExtension->DeviceObject,
                deviceStateContext,
                status
                );
        }
        break;

        case deviceInitState_done:

        //
        // notify the original caller w/ error if any
        //
        (*deviceStateContext->DeviceInitCompletionRoutine) (
            deviceStateContext->DeviceInitCompletionContext,
            deviceStateContext->NumRequestFailed ?
                STATUS_UNSUCCESSFUL :
                STATUS_SUCCESS
            );

        UnrefPdoWithTag(
            deviceStateContext->PdoExtension,
            DeviceInitDeviceState
            );

        ExFreePool (deviceStateContext);
        break;

        default:
        ASSERT(FALSE);
    }

    return;
}

NTSTATUS
DeviceIdeReadCapacity (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
)
{
    NTSTATUS status;
    PIDE_READ_CAPACITY_CONTEXT context;
    PATA_PASS_THROUGH ataPassThroughData;
    ULONG dataSize;
    PUCHAR dataOffset;
    PHW_DEVICE_EXTENSION hwDeviceExtension=PdoExtension->ParentDeviceExtension->HwDeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

    //
    // Check for device present flag
    //
    if (!(hwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_DEVICE_PRESENT)) {

        srb->SrbStatus = SRB_STATUS_NO_DEVICE;

        UnrefLogicalUnitExtensionWithTag(
            PdoExtension->ParentDeviceExtension,
            PdoExtension,
            Irp
            );

        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    context = ExAllocatePool (
                 NonPagedPool,
                 sizeof(IDE_READ_CAPACITY_CONTEXT)
                 );
    if ((context == NULL) || (Irp->MdlAddress == NULL)) {

        if (context) {
            ExFreePool(context);
        }

        UnrefLogicalUnitExtensionWithTag(
            PdoExtension->ParentDeviceExtension,
            PdoExtension,
            Irp
            );

        srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        srb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId,
                            NonPagedPool,
                            sizeof(IDE_READ_CAPACITY_CONTEXT),
                            IDEPORT_TAG_READCAP_CONTEXT
                            );

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // save the old data buffer for restoring later
    //
    context->OldDataBuffer = srb->DataBuffer;
    context->GeometryIoctl=FALSE;

    //
    // map the buffer in
    //
    dataOffset = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, HighPagePriority);
    srb->DataBuffer = dataOffset +
        (ULONG)((PUCHAR)srb->DataBuffer -
        (PCCHAR)MmGetMdlVirtualAddress(Irp->MdlAddress));

    context->PdoExtension = PdoExtension;
    context->OriginalIrp = Irp;

    // MdlSafe failed

    if (dataOffset == NULL) {

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId,
                            NonPagedPool,
                            sizeof(MDL),
                            IDEPORT_TAG_READCAP_MDL
                            );

        DeviceIdeReadCapacityCompletionRoutine (
            PdoExtension->DeviceObject,
            context,
            STATUS_INSUFFICIENT_RESOURCES
            );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IoMarkIrpPending(Irp);

    ataPassThroughData = &context->AtaPassThroughData;

    RtlZeroMemory (
        ataPassThroughData,
        sizeof (*ataPassThroughData)
        );

    ataPassThroughData->DataBufferSize = sizeof(IDENTIFY_DATA);

        ataPassThroughData->IdeReg.bCommandReg = IDE_COMMAND_IDENTIFY;
        ataPassThroughData->IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;

    status = IssueAsyncAtaPassThroughSafe (
                 PdoExtension->ParentDeviceExtension,
                 PdoExtension,
                 ataPassThroughData,
                 TRUE,
                 DeviceIdeReadCapacityCompletionRoutine,
                 context,
                 FALSE,
                 DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                 FALSE
                 );

    if (status != STATUS_PENDING) {

        DeviceIdeReadCapacityCompletionRoutine (
            PdoExtension->DeviceObject,
            context,
            status
            );
    }

    //
    // the irp was marked pending. return status_pending
    //
    return STATUS_PENDING;
}

VOID
DeviceIdeReadCapacityCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    PVOID Context,
    NTSTATUS Status
    )
{
    PIDE_READ_CAPACITY_CONTEXT context = Context;
    PIRP irp = context->OriginalIrp;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
    PSCSI_REQUEST_BLOCK srb;
    KIRQL currentIrql;
    PKSPIN_LOCK spinLock;
    ULONG numberOfCylinders;
    ULONG numberOfHeads;
    ULONG sectorsPerTrack;
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    ULONG i;
    ULONG targetId;
    PIDENTIFY_DATA identifyData;

#ifdef  GET_DISK_GEOMETRY_DEFINED

    DISK_GEOMETRY diskGeometry;

    //
    // ioctl_disk_get_drive_geometry
    // not interested in updating the srb
    //
    if (context->GeometryIoctl) {
        srb=NULL;
        targetId=context->PdoExtension->TargetId;
    }
    else {
#endif

        srb = irpStack->Parameters.Scsi.Srb;
        targetId=srb->TargetId;

#ifdef  GET_DISK_GEOMETRY_DEFINED
    }
#endif

    hwDeviceExtension = context->PdoExtension->ParentDeviceExtension->HwDeviceExtension;
    spinLock = &context->PdoExtension->ParentDeviceExtension->SpinLock;

    if (NT_SUCCESS(Status)) {

        identifyData = (PIDENTIFY_DATA) context->AtaPassThroughData.DataBuffer;

        IdePortFudgeAtaIdentifyData(
            identifyData
            );

        if ( (!Is98LegacyIde(&hwDeviceExtension->BaseIoAddress1)) &&
             ((identifyData->MajorRevision == 0) ||
              ((identifyData->NumberOfCurrentCylinders == 0) ||
               (identifyData->NumberOfCurrentHeads == 0) ||
               (identifyData->CurrentSectorsPerTrack == 0))) ) {

            numberOfCylinders = identifyData->NumCylinders;
            numberOfHeads     = identifyData->NumHeads;
            sectorsPerTrack   = identifyData->NumSectorsPerTrack;

        } else {

            numberOfCylinders = identifyData->NumberOfCurrentCylinders;
            numberOfHeads     = identifyData->NumberOfCurrentHeads;
            sectorsPerTrack   = identifyData->CurrentSectorsPerTrack;

            if (!Is98LegacyIde(&hwDeviceExtension->BaseIoAddress1)) {

                if (identifyData->UserAddressableSectors >
                    (numberOfCylinders * numberOfHeads * sectorsPerTrack)) {

                    //
                    // some ide driver has a 2G jumer to get around bios
                    // problem.  make sure we are not tricked the samw way.
                    //
                    if ((numberOfCylinders <= 0xfff) &&
                        (numberOfHeads == 0x10) &&
                        (sectorsPerTrack == 0x3f)) {

                        numberOfCylinders = identifyData->UserAddressableSectors / (0x10 * 0x3f);
                    }
                }
            }

        }

        //
        // update the HW Device Extension Data
        //
        KeAcquireSpinLock(spinLock, &currentIrql);

        InitDeviceGeometry(
            hwDeviceExtension,
            targetId,
            numberOfCylinders,
            numberOfHeads,
            sectorsPerTrack
            );

        if (hwDeviceExtension->DeviceFlags[targetId] & DFLAGS_IDENTIFY_INVALID) {

                RtlMoveMemory (
                    hwDeviceExtension->IdentifyData + targetId,
                    identifyData,
                    sizeof (IDENTIFY_DATA)
                    );
             
                ASSERT(!(hwDeviceExtension->DeviceFlags[targetId] & DFLAGS_REMOVABLE_DRIVE));

                SETMASK(hwDeviceExtension->DeviceFlags[targetId], DFLAGS_IDENTIFY_VALID);
                CLRMASK(hwDeviceExtension->DeviceFlags[targetId], DFLAGS_IDENTIFY_INVALID);
        }

        if (srb) {
            //
            // Claim 512 byte blocks (big-endian).
            //
            ((PREAD_CAPACITY_DATA)srb->DataBuffer)->BytesPerBlock = 0x20000;

            //
            // Calculate last sector.
            //
            if (context->PdoExtension->ParentDeviceExtension->
                HwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_LBA) {
                // LBA device
                i = identifyData->UserAddressableSectors - 1;

				//
				// LBAs can only be 28 bits wide
				//
				if (i >= MAX_28BIT_LBA) {
					i = MAX_28BIT_LBA - 1;
				}

#ifdef ENABLE_48BIT_LBA
				if (context->PdoExtension->ParentDeviceExtension->
					HwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_48BIT_LBA) {

					i = identifyData->Max48BitLBA[0] - 1;

					//
					// currently we support only upto 32 bits.
					//
					ASSERT(identifyData->Max48BitLBA[1] == 0);
				}
#endif
                DebugPrint((1,
                        "IDE LBA disk %x - total # of sectors = 0x%x\n",
                        srb->TargetId,
                        identifyData->UserAddressableSectors));

            } else {
                // CHS device
                i = (numberOfHeads * numberOfCylinders * sectorsPerTrack) - 1;

                DebugPrint((1,
                        "IDE CHS disk %x - #sectors %x, #heads %x, #cylinders %x\n",
                        srb->TargetId,
                        sectorsPerTrack,
                        numberOfHeads,
                        numberOfCylinders));
                DebugPrint((1,
                        "IDE CHS disk Identify data%x - #sectors %x, #heads %x, #cylinders %x\n",
                        srb->TargetId,
                        identifyData->NumSectorsPerTrack,
                        identifyData->NumHeads,
                        identifyData->NumCylinders));
                DebugPrint((1,
                        "IDE CHS disk Identify currentdata%x - #sectors %x, #heads %x, #cylinders %x\n",
                        srb->TargetId,
                        identifyData->CurrentSectorsPerTrack,
                        identifyData->NumberOfCurrentHeads,
                        identifyData->NumberOfCurrentCylinders));
            }

            ((PREAD_CAPACITY_DATA)srb->DataBuffer)->LogicalBlockAddress =
            (((PUCHAR)&i)[0] << 24) |  (((PUCHAR)&i)[1] << 16) |
            (((PUCHAR)&i)[2] << 8) | ((PUCHAR)&i)[3];

            srb->SrbStatus = SRB_STATUS_SUCCESS;

			irp->IoStatus.Information = sizeof(READ_CAPACITY_DATA);

        }

        KeReleaseSpinLock(spinLock, currentIrql);

    } else {

        if (srb) {
            if (Status==STATUS_INSUFFICIENT_RESOURCES) {
                srb->SrbStatus=SRB_STATUS_INTERNAL_ERROR;
                srb->InternalStatus=STATUS_INSUFFICIENT_RESOURCES;
            }
            else {
                srb->SrbStatus = SRB_STATUS_ERROR;
            }
        }
    }


    if (srb) {
        //
        // restoring DataBuffer
        //
        srb->DataBuffer = context->OldDataBuffer;
    }

#ifdef  GET_DISK_GEOMETRY_DEFINED
    if (context->GeometryIoctl && NT_SUCCESS(Status)) {

        //
        // Update Disk geometry from device extension
        //
        //diskGeometry.Cylinders.QuadPart=hwDeviceExtension->NumberOfCylinders[targetId];
        diskGeometry.Cylinders.QuadPart=numberOfCylinders;

        if (hwDeviceExtension->DeviceFlags[targetId] & DFLAGS_REMOVABLE_DRIVE) {
            diskGeometry.MediaType=RemovableMedia;
        } else {
            diskGeometry.MediaType=FixedMedia;
        }

        diskGeometry.TracksPerCylinder=hwDeviceExtension->NumberOfHeads[targetId];
        diskGeometry.SectorsPerTrack=hwDeviceExtension->SectorsPerTrack[targetId];
        diskGeometry.BytesPerSector=512; //check

        //
        // >8Gb
        //
        if ((hwDeviceExtension->NumberOfCylinders[targetId] == 16383) &&
            (hwDeviceExtension->NumberOfHeads[targetId] <= 16) &&
            (hwDeviceExtension->SectorsPerTrack[targetId] == 63)) {

            diskGeometry.Cylinders.QuadPart= (identifyData->UserAddressableSectors)/
                (hwDeviceExtension->NumberOfHeads[targetId]*
                    hwDeviceExtension->SectorsPerTrack[targetId]);

        }

        DebugPrint((1, "Geometry: device=%d, tpc=%d, spt=%d, bps=%d, cyl=%x, ncyl=%d, uas=%d\n",
                        targetId,
                        diskGeometry.TracksPerCylinder,
                        diskGeometry.SectorsPerTrack,
                        diskGeometry.BytesPerSector,
                        diskGeometry.Cylinders.QuadPart,
                        hwDeviceExtension->NumberOfCylinders[targetId],
                        identifyData->UserAddressableSectors));

        RtlMoveMemory(irp->AssociatedIrp.SystemBuffer,
                      &(diskGeometry),
                      sizeof(DISK_GEOMETRY));

        irp->IoStatus.Information = sizeof(DISK_GEOMETRY);
        Status=STATUS_SUCCESS;
    }
#endif

    UnrefLogicalUnitExtensionWithTag(
        context->PdoExtension->ParentDeviceExtension,
        context->PdoExtension,
        irp
        );

    IDEPORT_PUT_LUNEXT_IN_IRP (irpStack, NULL);

    ExFreePool (context);

    irp->IoStatus.Status = Status;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return;
}


NTSTATUS
DeviceIdeModeSense (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
)
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    ULONG modeDataBufferSize;
    ULONG dataBufferSize;
    ULONG dataBufferByteLeft;
    PMODE_PARAMETER_HEADER modePageHeader;
    PUCHAR pageData;
    PHW_DEVICE_EXTENSION hwDeviceExtension;

    PAGED_CODE();

    hwDeviceExtension = PdoExtension->ParentDeviceExtension->HwDeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    srb      = irpStack->Parameters.Scsi.Srb;
    cdb      = (PCDB) srb->Cdb;

    //
    // Check for device present flag
    //
    if (!(hwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_DEVICE_PRESENT)) {

        srb->SrbStatus = SRB_STATUS_NO_DEVICE;

        UnrefLogicalUnitExtensionWithTag(
            PdoExtension->ParentDeviceExtension,
            PdoExtension,
            Irp
            );

        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    ASSERT(cdb->MODE_SENSE.OperationCode == SCSIOP_MODE_SENSE);

    //
    // make sure this is for the right lun
    //
    if (cdb->MODE_SENSE.LogicalUnitNumber != PdoExtension->Lun) {

        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto getout;
    }

    //
    // only support page control for current values
    //
    if (cdb->MODE_SENSE.Pc != 0) {

        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto getout;
    }

    //
    // save the data buffer size for later use
    //
    modeDataBufferSize = srb->DataTransferLength;

    //
    // make sure the output buffer is at least the size of the header
    //
    if (modeDataBufferSize < sizeof(MODE_PARAMETER_HEADER)) {

        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_BUFFER_TOO_SMALL;
        goto getout;
    }

    //
    // some basic init.
    //
    modePageHeader = srb->DataBuffer;
    pageData = (PUCHAR) (modePageHeader + 1);
    RtlZeroMemory (modePageHeader, modeDataBufferSize);
    ASSERT (modeDataBufferSize);
    ASSERT (modePageHeader);

    modePageHeader->ModeDataLength = sizeof(MODE_PARAMETER_HEADER) -
        FIELD_OFFSET(MODE_PARAMETER_HEADER, MediumType);

    //
    // get write protect bit from smart data
    //
    if (hwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {

        ATA_PASS_THROUGH ataPassThroughData;
        NTSTATUS localStatus;

        RtlZeroMemory (
            &ataPassThroughData,
            sizeof (ataPassThroughData)
            );

        ataPassThroughData.IdeReg.bCommandReg = IDE_COMMAND_GET_MEDIA_STATUS;
        ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;
    
        localStatus = IssueSyncAtaPassThroughSafe (
                         PdoExtension->ParentDeviceExtension,
                         PdoExtension,
                         &ataPassThroughData,
                         FALSE,
                         FALSE,
                         DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                         FALSE);
    
        //if (NT_SUCCESS(localStatus)) {

            if (ataPassThroughData.IdeReg.bCommandReg & IDE_STATUS_ERROR){
                if (ataPassThroughData.IdeReg.bFeaturesReg & IDE_ERROR_DATA_ERROR){

                   modePageHeader->DeviceSpecificParameter |= MODE_DSP_WRITE_PROTECT;
                }
         //   }
        }
    }

    dataBufferByteLeft = modeDataBufferSize - sizeof(MODE_PARAMETER_HEADER);

    if (IsNEC_98) {

        HANDLE pageHandle;
        ULONG numberOfCylinders;
        ULONG numberOfHeads;
        ULONG sectorsPerTrack;
        KIRQL currentIrql;
        PKSPIN_LOCK spinLock;

        //
        // take a snap shot of the CHS values
        //
        spinLock = &PdoExtension->ParentDeviceExtension->SpinLock;

        //
        // lock the code before grabbing a lock
        //
        pageHandle = MmLockPagableCodeSection(DeviceIdeModeSense);
        KeAcquireSpinLock(spinLock, &currentIrql);

        numberOfCylinders = hwDeviceExtension->NumberOfCylinders[srb->TargetId];
        numberOfHeads     = hwDeviceExtension->NumberOfHeads[srb->TargetId];
        sectorsPerTrack   = hwDeviceExtension->SectorsPerTrack[srb->TargetId];

        KeReleaseSpinLock(spinLock, currentIrql);
        MmUnlockPagableImageSection(pageHandle);

        //
        // Set pages which are formated as nec-scsi.
        //
        if ((cdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) ||
            (cdb->MODE_SENSE.PageCode == MODE_PAGE_ERROR_RECOVERY)) {

            //
            // error recovery page
            //

            if (dataBufferByteLeft >= 0x6 + 2) {

                PMODE_DISCONNECT_PAGE  recoveryPage;

                recoveryPage = (PMODE_DISCONNECT_PAGE) pageData;

                recoveryPage->PageCode    = MODE_PAGE_ERROR_RECOVERY;
                recoveryPage->PageLength  = 0x6;

                //
                // update out data buffer pointer
                //
                pageData += recoveryPage->PageLength + 2;
                dataBufferByteLeft -= (recoveryPage->PageLength + 2);
                modePageHeader->ModeDataLength += recoveryPage->PageLength + 2;

            } else {

                status = STATUS_BUFFER_TOO_SMALL;
                goto getout;
            }
        }

        if ((cdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) ||
            (cdb->MODE_SENSE.PageCode == MODE_PAGE_FORMAT_DEVICE)) {

            //
            // format device page
            //

            if (dataBufferByteLeft >= 0x16 + 2) {

                PMODE_FORMAT_PAGE formatPage;

                formatPage = (PMODE_FORMAT_PAGE) pageData;

                formatPage->PageCode    = MODE_PAGE_FORMAT_DEVICE;
                formatPage->PageLength  = 0x16;

                //
                // SectorsPerTrack
                //
                ((PFOUR_BYTE)&formatPage->SectorsPerTrack[0])->Byte1 =
                    ((PFOUR_BYTE)&sectorsPerTrack)->Byte0;

                ((PFOUR_BYTE)&formatPage->SectorsPerTrack[0])->Byte0 =
                    ((PFOUR_BYTE)&sectorsPerTrack)->Byte1;

                //
                // update out data buffer pointer
                //
                pageData += formatPage->PageLength + 2;
                dataBufferByteLeft -= (formatPage->PageLength + 2);
                modePageHeader->ModeDataLength += formatPage->PageLength + 2;

            } else {

                status = STATUS_BUFFER_TOO_SMALL;
                goto getout;
            }
        }

        if ((cdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) ||
            (cdb->MODE_SENSE.PageCode == MODE_PAGE_RIGID_GEOMETRY)) {

            //
            // rigid geometry page
            //

            if (dataBufferByteLeft >= 0x12 + 2) {

                PMODE_RIGID_GEOMETRY_PAGE geometryPage;

                geometryPage = (PMODE_RIGID_GEOMETRY_PAGE) pageData;

                geometryPage->PageCode    = MODE_PAGE_RIGID_GEOMETRY;
                geometryPage->PageLength  = 0x12;

                //
                // NumberOfHeads
                //
                geometryPage->NumberOfHeads = (UCHAR) numberOfHeads;

                //
                // NumberOfCylinders
                //
                ((PFOUR_BYTE)&geometryPage->NumberOfCylinders)->Byte2
                    = ((PFOUR_BYTE)&numberOfCylinders)->Byte0;
                ((PFOUR_BYTE)&geometryPage->NumberOfCylinders)->Byte1
                    = ((PFOUR_BYTE)&numberOfCylinders)->Byte1;
                ((PFOUR_BYTE)&geometryPage->NumberOfCylinders)->Byte0
                    = 0;

                //
                // update out data buffer pointer
                //
                pageData += geometryPage->PageLength + 2;
                dataBufferByteLeft -= (geometryPage->PageLength + 2);
                modePageHeader->ModeDataLength += geometryPage->PageLength + 2;

            } else {

                status = STATUS_BUFFER_TOO_SMALL;
                goto getout;
            }
        }
    }

    if ((cdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) ||
        (cdb->MODE_SENSE.PageCode == MODE_PAGE_CACHING)) {

        if (dataBufferByteLeft >= sizeof(MODE_CACHING_PAGE)) {

            //
            // cache settings page
            //

            PMODE_CACHING_PAGE cachePage;

            cachePage = (PMODE_CACHING_PAGE) pageData;

            cachePage->PageCode = MODE_PAGE_CACHING;
            cachePage->PageSavable = 0;
            cachePage->PageLength = 0xa;
            cachePage->ReadDisableCache = 0;
            cachePage->WriteCacheEnable = PdoExtension->WriteCacheEnable;

            //
            // update out data buffer pointer
            //
            pageData += sizeof (MODE_CACHING_PAGE);
            dataBufferByteLeft -= sizeof (MODE_CACHING_PAGE);
            modePageHeader->ModeDataLength += sizeof (MODE_CACHING_PAGE);

        } else {

            srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
            srb->DataTransferLength -= dataBufferByteLeft;
            Irp->IoStatus.Information = srb->DataTransferLength;
            status = STATUS_BUFFER_TOO_SMALL;
            goto getout;
        }
    }

    //
    // update the number of bytes we are returning
    //
    srb->DataTransferLength -= dataBufferByteLeft;
    Irp->IoStatus.Information = srb->DataTransferLength;
    status = STATUS_SUCCESS;
    srb->SrbStatus = SRB_STATUS_SUCCESS;

getout:

    UnrefPdoWithTag(
        PdoExtension,
        Irp
        );

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
DeviceIdeModeSelect (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
)
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;

    ULONG modeDataBufferSize;
    PMODE_PARAMETER_HEADER modePageHeader;
    PUCHAR modePage;
    ULONG pageOffset;
    PMODE_CACHING_PAGE cachePage;
    PHW_DEVICE_EXTENSION hwDeviceExtension;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    srb      = irpStack->Parameters.Scsi.Srb;
    cdb      = (PCDB) srb->Cdb;

    hwDeviceExtension = PdoExtension->ParentDeviceExtension->HwDeviceExtension;

    //
    // Check for device present flag
    //
    if (!(hwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_DEVICE_PRESENT)) {

        srb->SrbStatus = SRB_STATUS_NO_DEVICE;

        UnrefLogicalUnitExtensionWithTag(
            PdoExtension->ParentDeviceExtension,
            PdoExtension,
            Irp
            );

        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    ASSERT(cdb->MODE_SELECT.OperationCode == SCSIOP_MODE_SELECT);

    //
    // make sure this is for the right lun
    //
    if (cdb->MODE_SELECT.LogicalUnitNumber != PdoExtension->Lun) {

        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto getout;
    }

    //
    // only support scsi-2 mode select format
    //
    if (cdb->MODE_SELECT.PFBit != 1) {

        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto getout;
    }

    modeDataBufferSize = cdb->MODE_SELECT.ParameterListLength;
    modePageHeader = srb->DataBuffer;

    if (modeDataBufferSize < sizeof(MODE_PARAMETER_HEADER)) {
        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto getout;
    }

    pageOffset = sizeof(MODE_PARAMETER_HEADER) + modePageHeader->BlockDescriptorLength;

    while (modeDataBufferSize > pageOffset) {

        modePage = ((PUCHAR) modePageHeader) + pageOffset;
        cachePage = (PMODE_CACHING_PAGE) modePage;

        if ((cachePage->PageCode == MODE_PAGE_CACHING) &&
            ((modePageHeader->ModeDataLength - pageOffset) >= sizeof(MODE_CACHING_PAGE)) &&
            (cachePage->PageLength == 0xa)) {

            if (cachePage->WriteCacheEnable != PdoExtension->WriteCacheEnable) {

                ATA_PASS_THROUGH ataPassThroughData;
                NTSTATUS localStatus;

                RtlZeroMemory (
                    &ataPassThroughData,
                    sizeof (ataPassThroughData)
                    );

                if (cachePage->WriteCacheEnable) {
                    ataPassThroughData.IdeReg.bFeaturesReg = IDE_SET_FEATURE_ENABLE_WRITE_CACHE;
                } else {
                    ataPassThroughData.IdeReg.bFeaturesReg = IDE_SET_FEATURE_DISABLE_WRITE_CACHE;
                }
                ataPassThroughData.IdeReg.bCommandReg = IDE_COMMAND_SET_FEATURE;
                ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;
                
                localStatus = IssueSyncAtaPassThroughSafe (
                                 PdoExtension->ParentDeviceExtension,
                                 PdoExtension,
                                 &ataPassThroughData,
                                 FALSE,
                                 FALSE,
                                 DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                                 FALSE);
                
                if (NT_SUCCESS(localStatus) &&
                    !(ataPassThroughData.IdeReg.bCommandReg & IDE_STATUS_ERROR)) {

                    PdoExtension->WriteCacheEnable = cachePage->WriteCacheEnable;
                } else {
                    status = STATUS_IO_DEVICE_ERROR;
                    srb->SrbStatus = SRB_STATUS_ERROR;
                    goto getout;
                }

            }

            pageOffset += sizeof(MODE_CACHING_PAGE);

        } else {
            status = STATUS_INVALID_PARAMETER;
            srb->SrbStatus = SRB_STATUS_ERROR;
            goto getout;
        }
    }

    status = STATUS_SUCCESS;
    srb->SrbStatus = SRB_STATUS_SUCCESS;

getout:

    UnrefPdoWithTag(
        PdoExtension,
        Irp
        );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}


NTSTATUS
DeviceQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPDO_EXTENSION pdoExtension;

    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       TRUE,
                       DeviceQueryPnPDeviceState
                       );

    if (pdoExtension) {

        PPNP_DEVICE_STATE deviceState;

        DebugPrint((DBG_PNP, "QUERY_DEVICE_STATE for PDOE 0x%x\n", pdoExtension));

        if(pdoExtension->PagingPathCount != 0) {
            deviceState = (PPNP_DEVICE_STATE) &(Irp->IoStatus.Information);
            SETMASK((*deviceState), PNP_DEVICE_NOT_DISABLEABLE);
        }

        status = STATUS_SUCCESS;

        UnrefPdoWithTag(
            pdoExtension,
            DeviceQueryPnPDeviceState
            );

    } else {

        status = STATUS_DEVICE_DOES_NOT_EXIST;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}

NTSTATUS
DeviceAtapiModeCommandCompletion (
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Description

    Completes the original irp after copying the data from the current srb
    
Arguments:

    DeviceObject  Not used
    Irp           The irp - Not used
    Context       Srb
    
Return value:

    STATUS_MORE_PROCESSING_REQUIRED
            
--*/
{
    PIO_STACK_LOCATION irpStack;
    PIDE_MODE_COMMAND_CONTEXT context = Context;
    PSCSI_REQUEST_BLOCK srb = context->Srb;
    PSCSI_REQUEST_BLOCK originalSrb;
    PIRP originalIrp;
    UCHAR bytesAdjust = sizeof(MODE_PARAMETER_HEADER_10) -
                            sizeof(MODE_PARAMETER_HEADER);
    ULONG transferLength;

    //
    // retrieve the original srb and the irp
    //
    originalSrb  = *((PVOID *) (srb+1));
    ASSERT(originalSrb);

    originalIrp = originalSrb->OriginalRequest;
    ASSERT(originalIrp);

    transferLength = srb->DataTransferLength;

    if (srb->Cdb[0] == ATAPI_MODE_SENSE) {

        PMODE_PARAMETER_HEADER_10 header_10 = (PMODE_PARAMETER_HEADER_10)(srb->DataBuffer);
        PMODE_PARAMETER_HEADER header = (PMODE_PARAMETER_HEADER)(originalSrb->DataBuffer);

        header->ModeDataLength = header_10->ModeDataLengthLsb;
        header->MediumType = header_10->MediumType;

        //
        // ATAPI Mode Parameter Header doesn't have these fields.
        //

        header->DeviceSpecificParameter = header_10->Reserved[0];

        //
        // ISSUE: 
        //
        header->BlockDescriptorLength = header_10->Reserved[4];
        
        //
        // copy the rest of the data
        //

        if (transferLength > sizeof(MODE_PARAMETER_HEADER_10)) {
            RtlMoveMemory((PUCHAR)originalSrb->DataBuffer+sizeof(MODE_PARAMETER_HEADER),
                          (PUCHAR)srb->DataBuffer+sizeof(MODE_PARAMETER_HEADER_10),
                          transferLength - sizeof(MODE_PARAMETER_HEADER_10));
        }

        DebugPrint((1,
                    "Mode Sense completed - status 0x%x, length 0x%x\n",
                    srb->SrbStatus,
                    srb->DataTransferLength
                    ));


    } else if (srb->Cdb[0] == ATAPI_MODE_SELECT) {

        DebugPrint((1,
                    "Mode Select completed - status 0x%x, length 0x%x\n",
                    srb->SrbStatus,
                    srb->DataTransferLength
                    ));
    } else {

        ASSERT (FALSE);
    }

    //
    // update the original srb
    //
    originalSrb->DataBuffer = context->OriginalDataBuffer;
    originalSrb->SrbStatus = srb->SrbStatus;
    originalSrb->ScsiStatus = srb->ScsiStatus;

    if (transferLength > bytesAdjust) {
        originalSrb->DataTransferLength = transferLength - bytesAdjust;
    } else {

        //
        // error. transfer length should be zero.
        // if it is less than the header, we will just pass it up.
        //
        originalSrb->DataTransferLength = transferLength;
    }

    //
    // Decrement the logUnitExtension reference count
    //
    irpStack = IoGetCurrentIrpStackLocation(originalIrp);

    UnrefLogicalUnitExtensionWithTag(
        IDEPORT_GET_LUNEXT_IN_IRP(irpStack)->ParentDeviceExtension,
        IDEPORT_GET_LUNEXT_IN_IRP(irpStack),
        originalIrp
        );

    //
    // we will follow the same logic as we did for srb data transfer length.
    //
    if (Irp->IoStatus.Information > bytesAdjust) {
        originalIrp->IoStatus.Information = Irp->IoStatus.Information - bytesAdjust;
    } else {
        originalIrp->IoStatus.Information = Irp->IoStatus.Information;
    }
    originalIrp->IoStatus.Status = Irp->IoStatus.Status;

    DebugPrint((1,
                "Original Mode command completed - status 0x%x, length 0x%x, irpstatus 0x%x\n",
                originalSrb->SrbStatus,
                originalSrb->DataTransferLength,
                originalIrp->IoStatus.Status
                ));

    IoCompleteRequest(originalIrp, IO_NO_INCREMENT);

    //
    // Free the srb, buffer and the irp
    //
    ASSERT(srb->DataBuffer);
    ExFreePool(srb->DataBuffer);

    ExFreePool(srb);

    ExFreePool(context);

    IdeFreeIrpAndMdl(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
DeviceAtapiModeSense (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp
    )
/*++
--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK originalSrb = irpStack->Parameters.Scsi.Srb;
    PSCSI_REQUEST_BLOCK srb = NULL;
    NTSTATUS status;
    PVOID *pointer;
    PCDB cdb;
    UCHAR length; 
    PVOID modeSenseBuffer;
    PUCHAR dataOffset;
    PIDE_MODE_COMMAND_CONTEXT context;
    PMODE_PARAMETER_HEADER_10 header_10; 
    PMODE_PARAMETER_HEADER header;
    UCHAR bytesAdjust = sizeof(MODE_PARAMETER_HEADER_10) -
                            sizeof(MODE_PARAMETER_HEADER);


    IoMarkIrpPending(Irp);

    //
    // allocate the context
    //
    context = ExAllocatePool (
                 NonPagedPool,
                 sizeof(IDE_MODE_COMMAND_CONTEXT)
                 );

    if (context == NULL) {

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId,
                            NonPagedPool,
                            sizeof(IDE_MODE_COMMAND_CONTEXT),
                            IDEPORT_TAG_ATAPI_MODE_SENSE
                            );

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    ASSERT(context);

    context->OriginalDataBuffer = originalSrb->DataBuffer;

    if (Irp->MdlAddress == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    //
    // map the buffer in
    //
    dataOffset = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, HighPagePriority);
    originalSrb->DataBuffer = dataOffset +
                                (ULONG)((PUCHAR)originalSrb->DataBuffer -
                                (PCCHAR)MmGetMdlVirtualAddress(Irp->MdlAddress));
    //
    // allocate a new srb
    //
    srb = ExAllocatePool (NonPagedPool, 
                          sizeof (SCSI_REQUEST_BLOCK)+ sizeof(PVOID));

    if (srb == NULL) {

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId,
                            NonPagedPool,
                            sizeof(SCSI_REQUEST_BLOCK),
                            IDEPORT_TAG_ATAPI_MODE_SENSE
                            );

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    //
    // Save the original SRB after the Srb.
    //
    pointer = (PVOID *) (srb+1);
    *pointer = originalSrb;

    //
    // Fill in SRB fields.
    //
    RtlCopyMemory(srb, originalSrb, sizeof(SCSI_REQUEST_BLOCK));

    length = ((PCDB)originalSrb->Cdb)->MODE_SENSE.AllocationLength;

    //
    // Allocate a new buffer
    //
    modeSenseBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                      originalSrb->DataTransferLength + bytesAdjust
                                      );

    RtlZeroMemory(modeSenseBuffer,originalSrb->DataTransferLength+bytesAdjust);
    header_10 = (PMODE_PARAMETER_HEADER_10)modeSenseBuffer;
    header = (PMODE_PARAMETER_HEADER)(originalSrb->DataBuffer);

    header_10->ModeDataLengthLsb = header->ModeDataLength;
    header_10->MediumType = header->MediumType;

    header_10->Reserved[4] = header->BlockDescriptorLength;

    srb->DataBuffer = modeSenseBuffer;
    srb->DataTransferLength = originalSrb->DataTransferLength + bytesAdjust;

    srb->CdbLength = 12;

    cdb = (PCDB) srb->Cdb;

    RtlZeroMemory(cdb, sizeof(CDB));

    cdb->MODE_SENSE10.OperationCode          = ATAPI_MODE_SENSE;
    cdb->MODE_SENSE10.LogicalUnitNumber      = ((PCDB)originalSrb->Cdb)->MODE_SENSE.LogicalUnitNumber; 
    cdb->MODE_SENSE10.PageCode               = ((PCDB)originalSrb->Cdb)->MODE_SENSE.PageCode; 
    cdb->MODE_SENSE10.AllocationLength[0]    = 0;
    cdb->MODE_SENSE10.AllocationLength[1]    = length+ bytesAdjust;

    context->Srb = srb;

    //
    // send the srb
    //
    status = IdeBuildAndSendIrp (PdoExtension,
                                 srb,
                                 DeviceAtapiModeCommandCompletion,
                                 context
                                 );

    if (NT_SUCCESS(status)) {

        ASSERT(status == STATUS_PENDING);

        return STATUS_PENDING;
    }

GetOut:

    ASSERT(status == STATUS_INSUFFICIENT_RESOURCES);

    if (srb) {
        ExFreePool(srb);
    }

    if (context) {

        originalSrb->DataBuffer = context->OriginalDataBuffer;

        ExFreePool(context);
    }

    UnrefLogicalUnitExtensionWithTag(
        PdoExtension->ParentDeviceExtension,
        PdoExtension,
        Irp
        );

    originalSrb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
    originalSrb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_PENDING;
}

NTSTATUS
DeviceAtapiModeSelect (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp
    )
/*++
--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK originalSrb = irpStack->Parameters.Scsi.Srb;
    PSCSI_REQUEST_BLOCK srb = NULL;
    NTSTATUS status;
    PVOID *pointer;
    PCDB cdb;
    UCHAR length; 
    PVOID modeSelectBuffer;
    PUCHAR dataOffset;
    PIDE_MODE_COMMAND_CONTEXT context;
    PMODE_PARAMETER_HEADER_10 header_10; 
    PMODE_PARAMETER_HEADER header;
    UCHAR bytesAdjust = sizeof(MODE_PARAMETER_HEADER_10) -
                            sizeof(MODE_PARAMETER_HEADER);

    IoMarkIrpPending(Irp);

    //
    // allocate the context
    //
    context = ExAllocatePool (
                 NonPagedPool,
                 sizeof(IDE_MODE_COMMAND_CONTEXT)
                 );

    if (context == NULL) {

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId,
                            NonPagedPool,
                            sizeof(IDE_MODE_COMMAND_CONTEXT),
                            IDEPORT_TAG_ATAPI_MODE_SENSE
                            );

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    ASSERT(context);

    context->OriginalDataBuffer = originalSrb->DataBuffer;

    if (Irp->MdlAddress == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    //
    // map the buffer in
    //
    dataOffset = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, HighPagePriority);
    originalSrb->DataBuffer = dataOffset +
                                (ULONG)((PUCHAR)originalSrb->DataBuffer -
                                (PCCHAR)MmGetMdlVirtualAddress(Irp->MdlAddress));

    //
    // allocate a new srb
    //
    srb = ExAllocatePool (NonPagedPool, 
                          sizeof (SCSI_REQUEST_BLOCK)+ sizeof(PVOID));

    if (srb == NULL) {

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId,
                            NonPagedPool,
                            sizeof(SCSI_REQUEST_BLOCK),
                            IDEPORT_TAG_ATAPI_MODE_SENSE
                            );

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    //
    // Save the original SRB after the Srb.
    //
    pointer = (PVOID *) (srb+1);
    *pointer = originalSrb;

    //
    // Fill in SRB fields.
    //
    RtlCopyMemory(srb, originalSrb, sizeof(SCSI_REQUEST_BLOCK));

    length = ((PCDB)originalSrb->Cdb)->MODE_SELECT.ParameterListLength;

    //
    // Allocate a new buffer
    //
    modeSelectBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                      originalSrb->DataTransferLength + bytesAdjust
                                      );

    RtlZeroMemory(modeSelectBuffer, sizeof(MODE_PARAMETER_HEADER_10));
    header_10 = (PMODE_PARAMETER_HEADER_10)modeSelectBuffer;
    header = (PMODE_PARAMETER_HEADER)(originalSrb->DataBuffer);

    header_10->ModeDataLengthLsb = header->ModeDataLength;
    header_10->MediumType = header->MediumType;

    header_10->Reserved[4] = header->BlockDescriptorLength;

    RtlCopyMemory(((PUCHAR)modeSelectBuffer+sizeof(MODE_PARAMETER_HEADER_10)),
                  ((PUCHAR)originalSrb->DataBuffer + sizeof(MODE_PARAMETER_HEADER)),
                  (originalSrb->DataTransferLength - sizeof(MODE_PARAMETER_HEADER))
                  );

    srb->DataBuffer = modeSelectBuffer;
    srb->DataTransferLength = originalSrb->DataTransferLength + bytesAdjust;

    srb->CdbLength = 12;

    //
    // fill in the cdb
    //
    cdb = (PCDB) srb->Cdb;

    RtlZeroMemory(cdb, sizeof(CDB));

    cdb->MODE_SELECT10.OperationCode     = ATAPI_MODE_SELECT;
    cdb->MODE_SELECT10.LogicalUnitNumber = ((PCDB)originalSrb->Cdb)->MODE_SELECT.LogicalUnitNumber; 
    cdb->MODE_SELECT10.SPBit = ((PCDB)originalSrb->Cdb)->MODE_SELECT.SPBit; 
    cdb->MODE_SELECT10.PFBit                  = 1;
    cdb->MODE_SELECT10.ParameterListLength[0] = 0;
    cdb->MODE_SELECT10.ParameterListLength[1] = length+ bytesAdjust;

    context->Srb = srb;

    //
    // send the srb
    //
    status = IdeBuildAndSendIrp (PdoExtension,
                                 srb,
                                 DeviceAtapiModeCommandCompletion,
                                 context
                                 );

    if (NT_SUCCESS(status)) {

        ASSERT(status == STATUS_PENDING);
        return STATUS_PENDING;
    }

GetOut:

    ASSERT(status == STATUS_INSUFFICIENT_RESOURCES);

    if (srb) {
        ExFreePool(srb);
    }

    if (context) {

        originalSrb->DataBuffer = context->OriginalDataBuffer;

        ExFreePool(context);
    }

    UnrefLogicalUnitExtensionWithTag(
        PdoExtension->ParentDeviceExtension,
        PdoExtension,
        Irp
        );

    originalSrb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
    originalSrb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_PENDING;
                            
}

#if 0
NTSTATUS
DeviceIdeTestUnitReady (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
)
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    PHW_DEVICE_EXTENSION hwDeviceExtension;

    PAGED_CODE();

    hwDeviceExtension = PdoExtension->ParentDeviceExtension->HwDeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    srb      = irpStack->Parameters.Scsi.Srb;

    //
    // get write protect bit from smart data
    //
    if (hwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {

        ATA_PASS_THROUGH ataPassThroughData;
        NTSTATUS localStatus;

        RtlZeroMemory (
            &ataPassThroughData,
            sizeof (ataPassThroughData)
            );

        ataPassThroughData.IdeReg.bCommandReg = IDE_COMMAND_GET_MEDIA_STATUS;
        ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;
    
        localStatus = IssueSyncAtaPassThroughSafe (
                         PdoExtension->ParentDeviceExtension,
                         PdoExtension,
                         &ataPassThroughData,
                         FALSE,
                         FALSE,
                         DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                         FALSE);
    
        if (NT_SUCCESS(localStatus)) {

            if (ataPassThroughData.IdeReg.bCommandReg & IDE_STATUS_ERROR){
                if (ataPassThroughData.IdeReg.bFeaturesReg & IDE_ERROR_DATA_ERROR){
                    //
                    // Special case: If current media is write-protected,
                    // the 0xDA command will always fail since the write-protect bit
                    // is sticky,so we can ignore this error
                    //
                   status = SRB_STATUS_SUCCESS;
                }
            }
        }
    }

    dataBufferByteLeft = modeDataBufferSize - sizeof(MODE_PARAMETER_HEADER);

    if (IsNEC_98) {

        HANDLE pageHandle;
        ULONG numberOfCylinders;
        ULONG numberOfHeads;
        ULONG sectorsPerTrack;
        KIRQL currentIrql;
        PKSPIN_LOCK spinLock;

        //
        // take a snap shot of the CHS values
        //
        spinLock = &PdoExtension->ParentDeviceExtension->SpinLock;

        //
        // lock the code before grabbing a lock
        //
        pageHandle = MmLockPagableCodeSection(DeviceIdeModeSense);
        KeAcquireSpinLock(spinLock, &currentIrql);

        numberOfCylinders = hwDeviceExtension->NumberOfCylinders[srb->TargetId];
        numberOfHeads     = hwDeviceExtension->NumberOfHeads[srb->TargetId];
        sectorsPerTrack   = hwDeviceExtension->SectorsPerTrack[srb->TargetId];

        KeReleaseSpinLock(spinLock, currentIrql);
        MmUnlockPagableImageSection(pageHandle);

        //
        // Set pages which are formated as nec-scsi.
        //
        if ((cdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) ||
            (cdb->MODE_SENSE.PageCode == MODE_PAGE_ERROR_RECOVERY)) {

            //
            // error recovery page
            //

            if (dataBufferByteLeft >= 0x6 + 2) {

                PMODE_DISCONNECT_PAGE  recoveryPage;

                recoveryPage = (PMODE_DISCONNECT_PAGE) pageData;

                recoveryPage->PageCode    = MODE_PAGE_ERROR_RECOVERY;
                recoveryPage->PageLength  = 0x6;

                //
                // update out data buffer pointer
                //
                pageData += recoveryPage->PageLength + 2;
                dataBufferByteLeft -= (recoveryPage->PageLength + 2);
                modePageHeader->ModeDataLength += recoveryPage->PageLength + 2;

            } else {

                status = STATUS_BUFFER_TOO_SMALL;
                goto getout;
            }
        }

        if ((cdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) ||
            (cdb->MODE_SENSE.PageCode == MODE_PAGE_FORMAT_DEVICE)) {

            //
            // format device page
            //

            if (dataBufferByteLeft >= 0x16 + 2) {

                PMODE_FORMAT_PAGE formatPage;

                formatPage = (PMODE_FORMAT_PAGE) pageData;

                formatPage->PageCode    = MODE_PAGE_FORMAT_DEVICE;
                formatPage->PageLength  = 0x16;

                //
                // SectorsPerTrack
                //
                ((PFOUR_BYTE)&formatPage->SectorsPerTrack[0])->Byte1 =
                    ((PFOUR_BYTE)&sectorsPerTrack)->Byte0;

                ((PFOUR_BYTE)&formatPage->SectorsPerTrack[0])->Byte0 =
                    ((PFOUR_BYTE)&sectorsPerTrack)->Byte1;

                //
                // update out data buffer pointer
                //
                pageData += formatPage->PageLength + 2;
                dataBufferByteLeft -= (formatPage->PageLength + 2);
                modePageHeader->ModeDataLength += formatPage->PageLength + 2;

            } else {

                status = STATUS_BUFFER_TOO_SMALL;
                goto getout;
            }
        }

        if ((cdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) ||
            (cdb->MODE_SENSE.PageCode == MODE_PAGE_RIGID_GEOMETRY)) {

            //
            // rigid geometry page
            //

            if (dataBufferByteLeft >= 0x12 + 2) {

                PMODE_RIGID_GEOMETRY_PAGE geometryPage;

                geometryPage = (PMODE_RIGID_GEOMETRY_PAGE) pageData;

                geometryPage->PageCode    = MODE_PAGE_RIGID_GEOMETRY;
                geometryPage->PageLength  = 0x12;

                //
                // NumberOfHeads
                //
                geometryPage->NumberOfHeads = (UCHAR) numberOfHeads;

                //
                // NumberOfCylinders
                //
                ((PFOUR_BYTE)&geometryPage->NumberOfCylinders)->Byte2
                    = ((PFOUR_BYTE)&numberOfCylinders)->Byte0;
                ((PFOUR_BYTE)&geometryPage->NumberOfCylinders)->Byte1
                    = ((PFOUR_BYTE)&numberOfCylinders)->Byte1;
                ((PFOUR_BYTE)&geometryPage->NumberOfCylinders)->Byte0
                    = 0;

                //
                // update out data buffer pointer
                //
                pageData += geometryPage->PageLength + 2;
                dataBufferByteLeft -= (geometryPage->PageLength + 2);
                modePageHeader->ModeDataLength += geometryPage->PageLength + 2;

            } else {

                status = STATUS_BUFFER_TOO_SMALL;
                goto getout;
            }
        }
    }

    if ((cdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) ||
        (cdb->MODE_SENSE.PageCode == MODE_PAGE_CACHING)) {

        if (dataBufferByteLeft >= sizeof(MODE_CACHING_PAGE)) {

            //
            // cache settings page
            //

            PMODE_CACHING_PAGE cachePage;

            cachePage = (PMODE_CACHING_PAGE) pageData;

            cachePage->PageCode = MODE_PAGE_CACHING;
            cachePage->PageSavable = 0;
            cachePage->PageLength = 0xa;
            cachePage->ReadDisableCache = 0;
            cachePage->WriteCacheEnable = PdoExtension->WriteCacheEnable;

            //
            // update out data buffer pointer
            //
            pageData += sizeof (MODE_CACHING_PAGE);
            dataBufferByteLeft -= sizeof (MODE_CACHING_PAGE);
            modePageHeader->ModeDataLength += sizeof (MODE_CACHING_PAGE);

        } else {

            status = STATUS_BUFFER_TOO_SMALL;
            goto getout;
        }
    }

    //
    // update the number of bytes we are returning
    //
    srb->DataTransferLength -= dataBufferByteLeft;
    Irp->IoStatus.Information = srb->DataTransferLength;
    status = STATUS_SUCCESS;
    srb->SrbStatus = SRB_STATUS_SUCCESS;

getout:

    UnrefPdoWithTag(
        PdoExtension,
        Irp
        );

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\fdopower.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    fdopower.c

Abstract:

--*/

#include "ideport.h"

//POWER_STATE                   
NTSTATUS
IdePortIssueSetPowerState (
    IN PDEVICE_EXTENSION_HEADER DoExtension,
    IN POWER_STATE_TYPE   Type,
    IN POWER_STATE        State,
    IN BOOLEAN            Sync
    )
{
    PIRP                      irp = NULL;
    PIO_STACK_LOCATION        irpStack;
    NTSTATUS                  status;
    CCHAR                     stackSize;

    SET_POWER_STATE_CONTEXT   context;

    if (Sync) {

        KeInitializeEvent(
            &context.Event,
            NotificationEvent,
            FALSE
            );
    }

    stackSize = (CCHAR) (DoExtension->DeviceObject->StackSize);

    irp = IoAllocateIrp(
            stackSize,
            FALSE
            );

    if (irp == NULL) {

        status = STATUS_NO_MEMORY;
        goto GetOut;
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_POWER;
    irpStack->MinorFunction = IRP_MN_SET_POWER;

    irpStack->Parameters.Power.SystemContext = 0;
    irpStack->Parameters.Power.Type          = Type;
    irpStack->Parameters.Power.State         = State;

    IoSetCompletionRoutine(irp,
                           IdePortPowerCompletionRoutine,
                           Sync ? &context : NULL,
                           TRUE,
                           TRUE,
                           TRUE);

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    status = PoCallDriver(
                 DoExtension->DeviceObject, 
                 irp
                 );

    //
    // Wait for the completion routine. It will be called anyway
    //
    //if ((status == STATUS_PENDING) && (Sync)) {
    if (Sync) {

        KeWaitForSingleObject(&context.Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = context.Status;
    }

GetOut:

    return status;
}

NTSTATUS
IdePortPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PSET_POWER_STATE_CONTEXT context = Context;

    if (context) {

        context->Status = Irp->IoStatus.Status;

        KeSetEvent(
            &context->Event,
            EVENT_INCREMENT,
            FALSE
            );
    }

    IoFreeIrp (Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
IdePortSetFdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION     fdoExtension;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS           status = STATUS_SUCCESS;
    PFDO_POWER_CONTEXT context;
    BOOLEAN            powerStateChange;
    BOOLEAN            systemPowerContext = FALSE;
    BOOLEAN            devicePowerContext = FALSE;

    DebugPrint ((DBG_POWER, 
                 "FDO devobj 0x%x got power irp 0x%x\n", 
                 DeviceObject,
                 Irp
                 ));

    fdoExtension = DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    //context = ExAllocatePool (NonPagedPool, sizeof(FDO_POWER_CONTEXT));

    //
    // We need two pre-alloced context structures. This is because a system power irp
    // would result in a device power irp to be issued before the former is completed.
    // 
    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 1, 0) == 0);
        context = &(fdoExtension->FdoPowerContext[0]);
        systemPowerContext = TRUE;

    } else {

        ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 1, 0) == 0);
        context = &(fdoExtension->FdoPowerContext[1]);
        devicePowerContext = TRUE;

    }

    if (context == NULL) {

        ASSERT(context);
        status = STATUS_NO_MEMORY;
    } else {

        RtlZeroMemory (context, sizeof(FDO_POWER_CONTEXT));

        powerStateChange = TRUE;

        context->OriginalPowerIrp = Irp;
        context->newPowerType     = irpStack->Parameters.Power.Type;
        context->newPowerState    = irpStack->Parameters.Power.State;
    
        if (irpStack->Parameters.Power.Type == SystemPowerState) {

            if (fdoExtension->SystemPowerState != irpStack->Parameters.Power.State.SystemState) {

#if DBG
                ASSERT (fdoExtension->PendingSystemPowerIrp == NULL);
                fdoExtension->PendingSystemPowerIrp = Irp;
                ASSERT (fdoExtension->PendingSystemPowerIrp);
#endif

                if (fdoExtension->SystemPowerState == PowerSystemWorking) {
    
                    POWER_STATE        powerState;

                    //
                    // Getting out of working state.  
                    //
                    if ((irpStack->Parameters.Power.State.SystemState == PowerSystemShutdown) &&
                        (irpStack->Parameters.Power.ShutdownType == PowerActionShutdownReset)) {

                        //
                        // spin up for BIOS POST
                        //
                        powerState.DeviceState = PowerDeviceD0;

                    } else {
        
                        //
                        // power down for sleep
                        //
                        powerState.DeviceState = PowerDeviceD3;
                    }

                    IoMarkIrpPending(Irp);

                    PoRequestPowerIrp (
                        fdoExtension->DeviceObject,
                        IRP_MN_SET_POWER,
                        powerState,
                        FdoContingentPowerCompletionRoutine,
                        context,
                        NULL
                        );

                    return STATUS_PENDING;
                }       

            } else {

                //
                // We are already in the given state
                //
                powerStateChange = FALSE;
            }

        } else if (irpStack->Parameters.Power.Type == DevicePowerState) {
    
            if (fdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {
    
                DebugPrint ((
                    DBG_POWER, 
                    "IdePort: New Fdo 0x%x device power state 0x%x\n", 
                    fdoExtension->IdeResource.TranslatedCommandBaseAddress, 
                    irpStack->Parameters.Power.State.DeviceState
                    ));
        
                ASSERT (fdoExtension->PendingDevicePowerIrp == NULL);
#if DBG
                fdoExtension->PendingDevicePowerIrp = Irp;
                ASSERT (fdoExtension->PendingDevicePowerIrp);
#endif //DBG

                if (fdoExtension->DevicePowerState == PowerDeviceD0) {
    
                    //
                    // getting out of D0 state, better call PoSetPowerState now
                    //
                    PoSetPowerState (
                        DeviceObject,
                        DevicePowerState,
                        irpStack->Parameters.Power.State
                        );
                }
                                                  
            } else {

                //
                // We are already in the given state
                //
                powerStateChange = FALSE;
            }
        } else {
    
            ASSERT (FALSE);
            status = STATUS_NOT_IMPLEMENTED;
        }
    }


    if (NT_SUCCESS(status)) {
    
		IoMarkIrpPending(Irp);

        IoCopyCurrentIrpStackLocationToNext (Irp);

        if (powerStateChange) {
        
            IoSetCompletionRoutine(Irp,
                                   FdoPowerCompletionRoutine,
                                   context,
                                   TRUE,
                                   TRUE,
                                   TRUE);
        } else {

            if (systemPowerContext) {
                ASSERT(devicePowerContext == FALSE);
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
            }

            if (devicePowerContext) {
                ASSERT(systemPowerContext == FALSE);
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 0, 1) == 1);
            }
            //ExFreePool (context);
            PoStartNextPowerIrp (Irp);

        }
    
        PoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
        return STATUS_PENDING;

    } else {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;

        if (context) {
            if (systemPowerContext) {
                ASSERT(devicePowerContext == FALSE);
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
            }

            if (devicePowerContext) {
                ASSERT(systemPowerContext == FALSE);
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 0, 1) == 1);
            }
            //ExFreePool (context);
        }

        PoStartNextPowerIrp (Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
}

NTSTATUS
FdoContingentPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PFDO_POWER_CONTEXT context = Context;
    PFDO_EXTENSION fdoExtension;
    PIRP irp;

    irp = context->OriginalPowerIrp;
    fdoExtension = DeviceObject->DeviceExtension;

    if (NT_SUCCESS(IoStatus->Status)) {

        IoCopyCurrentIrpStackLocationToNext (irp);
    
        IoSetCompletionRoutine(irp,
                               FdoPowerCompletionRoutine,
                               context,
                               TRUE,
                               TRUE,
                               TRUE);
    
        PoCallDriver (fdoExtension->AttacheeDeviceObject, irp);

    } else {

        irp->IoStatus.Information = 0;
        irp->IoStatus.Status = IoStatus->Status;

        //
        // This should happen only for system power irps
        //
        ASSERT(context->newPowerType == SystemPowerState);
        ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
        //ExFreePool (context);
        PoStartNextPowerIrp (irp);
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return IoStatus->Status;
}


NTSTATUS
FdoPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PFDO_POWER_CONTEXT context = Context;
    BOOLEAN            callPoSetPowerState;
    PFDO_EXTENSION     fdoExtension;
    POWER_STATE        newPowerState;
    POWER_STATE_TYPE   newPowerType;
    BOOLEAN            unlocked = FALSE;
	BOOLEAN			   moreProcessingRequired = FALSE;
	NTSTATUS		   status;

    fdoExtension = DeviceObject->DeviceExtension;

    newPowerType = context->newPowerType;
    newPowerState = context->newPowerState;

    if ((NT_SUCCESS(Irp->IoStatus.Status))) {

        callPoSetPowerState = TRUE;

        if (context->newPowerType == SystemPowerState) { 

            fdoExtension->SystemPowerState = context->newPowerState.SystemState;

            if (fdoExtension->SystemPowerState == PowerSystemWorking) {
                
                POWER_STATE powerState;

                //
                // I don't need the context any more
                //
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
                unlocked = TRUE;
				moreProcessingRequired = TRUE;

				ASSERT(fdoExtension->PendingSystemPowerIrp == Irp);

                //
                // initiate a D0 here to cause a re-enumuration
                //
                powerState.DeviceState = PowerDeviceD0;
                status = PoRequestPowerIrp (
									fdoExtension->DeviceObject,
									IRP_MN_SET_POWER,
									powerState,
									FdoSystemPowerUpCompletionRoutine,
									Irp,
									NULL
									);

				ASSERT(status == STATUS_PENDING);
            }

            DebugPrint ((
                DBG_POWER, "IdePort: New Fdo 0x%x system power state 0x%x\n", 
                fdoExtension->IdeResource.TranslatedCommandBaseAddress, 
                fdoExtension->SystemPowerState));

#if DBG
			if (moreProcessingRequired == FALSE) {
				fdoExtension->PendingSystemPowerIrp = NULL;
			}
#endif

        } else if (context->newPowerType == DevicePowerState) { 

            if (context->newPowerState.DeviceState == PowerDeviceD0) {

                if (fdoExtension->panasonicController) {

                    //
                    // this will loop 20000 * 100 us (2000ms) the most.
                    //                                                      
                    ULONG i = 20000;
                    while (i) {                       
                                  
                        //
                        // the panasonic controller needs a special way to kick start
                        //
                        WRITE_PORT_UCHAR (fdoExtension->HwDeviceExtension->BaseIoAddress1.RegistersBaseAddress + 0x207, 0x81);
                        WRITE_PORT_UCHAR (fdoExtension->HwDeviceExtension->BaseIoAddress1.RegistersBaseAddress, 0xa0);
                        
                        WRITE_PORT_UCHAR (fdoExtension->HwDeviceExtension->BaseIoAddress1.DriveSelect, 0xa0);
                        if (0xa0 == READ_PORT_UCHAR (fdoExtension->HwDeviceExtension->BaseIoAddress1.DriveSelect)) {
                        
                            DebugPrint ((0, "panasonicController wait start count = %u\n", i));
                            //
                            // done
                            //
                            i = 0;
                            
                        } else {
                        
                            KeStallExecutionProcessor(100);
                            i--;
                        }
                    }
                }
            }

            if ((context->newPowerState.DeviceState == PowerDeviceD0) &&
                (!context->TimingRestored)) {

                NTSTATUS status;

                status = ChannelRestoreTiming (
                             fdoExtension,
                             ChannelRestoreTimingCompletionRoutine,
                             context
                             );

                if (!NT_SUCCESS(status)) {

                    ChannelRestoreTimingCompletionRoutine(
                        fdoExtension->DeviceObject,
                        status, 
                        context
                        );
                }

                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            ASSERT (fdoExtension->PendingDevicePowerIrp == Irp);
            fdoExtension->PendingDevicePowerIrp = NULL;

            if (fdoExtension->DevicePowerState == PowerDeviceD0) {

                //
                // PoSetPowerState is called before we get out of D0
                //
                callPoSetPowerState = FALSE;
            }

            fdoExtension->DevicePowerState = context->newPowerState.DeviceState;

            if ((fdoExtension->DevicePowerState == PowerDeviceD0) &&
				(fdoExtension->FdoState & FDOS_STARTED)) {

                IoInvalidateDeviceRelations (
                    fdoExtension->AttacheePdo,
                    BusRelations
                    );
            }
        }

        if (callPoSetPowerState) {

            PoSetPowerState (
                DeviceObject,
                newPowerType,
                newPowerState                
                );
        }

    } else {

        DebugPrint ((DBG_ALWAYS, "ATAPI: devobj 0x%x failed power irp 0x%x\n", fdoExtension->AttacheeDeviceObject, Irp));

        if (context->newPowerType == SystemPowerState) { 

            ASSERT (fdoExtension->PendingSystemPowerIrp == Irp);
            fdoExtension->PendingSystemPowerIrp = NULL;

        } else if (context->newPowerType == DevicePowerState) { 

            ASSERT (fdoExtension->PendingDevicePowerIrp == Irp);
            fdoExtension->PendingDevicePowerIrp = NULL;
        }

    }

    //
    // Done with context
    //
    if (!unlocked) {
        if (context->newPowerType == SystemPowerState) {
            ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
        } else {
            ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 0, 1) == 1);
        }
    }
    //ExFreePool (Context);

	//
	// wait for the device irp to complete
	//
	if (moreProcessingRequired) {
		return STATUS_MORE_PROCESSING_REQUIRED;
	}

    //
    // If pending has be returned for this irp then mark the current stack as
    // pending.
    //
    //if (Irp->PendingReturned) {
     //   IoMarkIrpPending(Irp);
    //}

	PoStartNextPowerIrp (Irp);

    return Irp->IoStatus.Status;
}



VOID
FdoChildReportPowerDown (
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension
    )
{
    KIRQL       currentIrql;
    POWER_STATE powerState;

    KeAcquireSpinLock(&FdoExtension->LogicalUnitListSpinLock, &currentIrql);


    FdoExtension->NumberOfLogicalUnitsPowerUp--;

    if (FdoExtension->NumberOfLogicalUnitsPowerUp == 0) {

        DebugPrint ((DBG_POWER, "FdoChildReportPowerDown: sleep fdo 0x%x\n", FdoExtension));

        //
        // All the children are powered down, we can now power down 
        // the parent (the controller)
        //
        powerState.DeviceState = PowerDeviceD3;
        PoRequestPowerIrp (
            FdoExtension->DeviceObject,
            IRP_MN_SET_POWER,
            powerState,
            NULL,
            NULL,
            NULL
            );

    } else if (FdoExtension->NumberOfLogicalUnitsPowerUp < 0) {

        //
        // should never happen. If it did, pretend it didn't
        //
        ASSERT (FALSE);
        FdoExtension->NumberOfLogicalUnitsPowerUp = 0;
    }

    KeReleaseSpinLock(&FdoExtension->LogicalUnitListSpinLock, currentIrql);

    return;
}

NTSTATUS
FdoChildRequestPowerUp (
    IN PFDO_EXTENSION            FdoExtension,
    IN PPDO_EXTENSION            PdoExtension,
    IN PVOID                     Context
    )
{
    KIRQL       currentIrql;
    NTSTATUS    status;
    POWER_STATE powerState;

    KeAcquireSpinLock(&FdoExtension->LogicalUnitListSpinLock, &currentIrql);

    status = STATUS_SUCCESS;

    if (FdoExtension->NumberOfLogicalUnitsPowerUp == 0) {

        DebugPrint ((DBG_POWER, "FdoChildRequestPowerUp: wake up fdo 0x%x\n", FdoExtension));

        KeReleaseSpinLock(&FdoExtension->LogicalUnitListSpinLock, currentIrql);

        //
        // One of the children is coming out of sleep, 
        // we need to power up the parent (the controller)
        //
        powerState.DeviceState = PowerDeviceD0;
        status = PoRequestPowerIrp (
                     FdoExtension->DeviceObject,
                     IRP_MN_SET_POWER,
                     powerState,
                     FdoChildRequestPowerUpCompletionRoutine,
                     Context,
                     NULL
                     );
        ASSERT (NT_SUCCESS(status));
        status = STATUS_PENDING;

    } else {

        FdoExtension->NumberOfLogicalUnitsPowerUp++;

        if (FdoExtension->NumberOfLogicalUnitsPowerUp > FdoExtension->NumberOfLogicalUnits) {

            //
            // should never happen. If it did, pretend it didn't
            //
            ASSERT (FALSE);
            FdoExtension->NumberOfLogicalUnitsPowerUp = FdoExtension->NumberOfLogicalUnits;
        }

        KeReleaseSpinLock(&FdoExtension->LogicalUnitListSpinLock, currentIrql);

        PdoRequestParentPowerUpCompletionRoutine (
            Context,
            STATUS_SUCCESS
            );
    }

    return status;
}

NTSTATUS
FdoChildRequestPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    PFDO_EXTENSION     fdoExtension;

    fdoExtension = DeviceObject->DeviceExtension;

    if (NT_SUCCESS(IoStatus->Status)) {

        KIRQL currentIrql;
    
        KeAcquireSpinLock(&fdoExtension->LogicalUnitListSpinLock, &currentIrql);

        fdoExtension->NumberOfLogicalUnitsPowerUp++;

        KeReleaseSpinLock(&fdoExtension->LogicalUnitListSpinLock, currentIrql);
    }

    PdoRequestParentPowerUpCompletionRoutine (
        Context,
        IoStatus->Status
        );

    return IoStatus->Status;
}

NTSTATUS
ChannelQueryPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack;
    PFDO_EXTENSION     fdoExtension;

    fdoExtension = DeviceObject->DeviceExtension;

#if defined (DONT_POWER_DOWN_PAGING_DEVICE)

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    if (!fdoExtension->CrashDumpPathCount ||
        ((irpStack->Parameters.Power.Type == SystemPowerState) &&
         (irpStack->Parameters.Power.State.SystemState == PowerSystemWorking)) ||
        ((irpStack->Parameters.Power.Type == DevicePowerState) &&
         (irpStack->Parameters.Power.State.SystemState == PowerDeviceD0))) {

        Irp->IoStatus.Status = STATUS_SUCCESS;

    } else {

        Irp->IoStatus.Status = STATUS_DEVICE_POWER_FAILURE;
    }
#else

    Irp->IoStatus.Status = STATUS_SUCCESS;

#endif // DONT_POWER_DOWN_PAGING_DEVICE

    IoCopyCurrentIrpStackLocationToNext (Irp);
    PoStartNextPowerIrp (Irp);
    return PoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
}


NTSTATUS
FdoSystemPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
	PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
	PIRP irp = Context;

#if DBG
	fdoExtension->PendingSystemPowerIrp = NULL;
#endif


	//
	// start the next system power irp
	//
    PoStartNextPowerIrp (irp);

	if (!NT_SUCCESS(IoStatus->Status)) {
	irp->IoStatus.Status = IoStatus->Status;
	}

	IoCompleteRequest(irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\hack.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    hack.c

Abstract:

--*/

#include "ideport.h"
#include "hack.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IdePortSlaveIsGhost)
#pragma alloc_text(PAGE, IdePortGetFlushCommand)
#pragma alloc_text(PAGE, IdePortMustBePio)
#pragma alloc_text(PAGE, IdePortPioByDefaultDevice)
#pragma alloc_text(PAGE, IdePortDeviceHasNonRemovableMedia)
#pragma alloc_text(PAGE, IdePortDeviceIsLs120)
#pragma alloc_text(PAGE, IdePortNoPowerDown)
#pragma alloc_text(PAGE, IdePortVerifyDma)
#pragma alloc_text(NONPAGE, IdePortFudgeAtaIdentifyData)
#pragma alloc_text(PAGE, IdePortIsThisAPanasonicPCMCIACard)
#pragma alloc_text(PAGE, IdeFindSpecialDevice)
/*
#pragma alloc_text(PAGE, IdePortIsThisASonyMemorystickPCMCIACard)
#pragma alloc_text(PAGE, IdePortSonyMemoryStick)
#pragma alloc_text(PAGE, IdePortReuseIdent)
#pragma alloc_text(PAGE, IdePortBadCdrom)
*/
#endif // ALLOC_PRAGMA

#if defined (FAKE_BMSETUP_FAILURE)
ULONG FailBmSetupCount = 0;
#endif // FAKE_BMSETUP_FAILURE  

#if DBG

ULONG IdeDebugRescanBusFreq = 0;
ULONG IdeDebugRescanBusCounter = 0;

ULONG IdeDebugHungControllerFreq = 0;
ULONG IdeDebugHungControllerCounter = 0;

ULONG IdeDebugTimeoutAllCacheFlush = 0;

ULONG IdeDebugForceSmallCrashDumpBlockSize = 0;

PDEVICE_OBJECT IdeDebugDevObjTimeoutAllDmaSrb = 0;

ULONG IdeDebug = 0;
ULONG IdeDebugPrintControl = DBG_ALWAYS;
UCHAR IdeBuffer[0x1000];


VOID
IdeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all SCSI drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    BOOLEAN print = FALSE;
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel & DBG_BIT_CONTROL) {

        if (DebugPrintLevel == DBG_ALWAYS) {

            print = TRUE;

        } else if ((DebugPrintLevel & ~DBG_BIT_CONTROL) & IdeDebugPrintControl) {

            print = TRUE;
        }

    } else {

        if (DebugPrintLevel <= IdeDebug) {

            print = TRUE;
        }
    }

    if (print) {

        vsprintf(IdeBuffer, DebugMessage, ap);

#ifdef ENABLE_DBG_PRINT
        DbgPrint(IdeBuffer);
#else
        DbgPrintEx(DPFLTR_IDEP_ID, 
                   DPFLTR_INFO_LEVEL,
                   IdeBuffer
                   );
#endif
    }

    va_end(ap);

} // end IdeDebugPrint()
#endif

//
// if we see one of these slave device that looks like
// the master device, we will ignore the slave device
//
BOOLEAN
IdePortSlaveIsGhost (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA MasterIdentifyData,
    IN PIDENTIFY_DATA SlaveIdentifyData
)
{
    ULONG length;
    ULONG i;

    PAGED_CODE();

    length = sizeof (MasterIdentifyData->ModelNumber);
    if (length == RtlCompareMemory (
                      MasterIdentifyData->ModelNumber,
                      SlaveIdentifyData->ModelNumber,
                      length)) {

        if (IdePortSearchDeviceInRegMultiSzList (
                FdoExtension,
                MasterIdentifyData, 
                GHOST_SLAVE_DEVICE)) {

            DebugPrint ((DBG_WARNING, "ATAPI: Found a ghost slave\n"));
            return TRUE;
        }
    }
    return FALSE;
}

UCHAR
IdePortGetFlushCommand (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN OUT PPDO_EXTENSION PdoExtension,
    IN PIDENTIFY_DATA     IdentifyData
)
{
    ULONG i;
    UCHAR flushCommand;
    BOOLEAN done;

    PAGED_CODE();

    ASSERT (FdoExtension);
    ASSERT (PdoExtension);
    ASSERT (IdentifyData);

    done = FALSE;

    //
    // in hall of shame list?
    //
    if (IdePortSearchDeviceInRegMultiSzList (
            FdoExtension,
            IdentifyData, 
            NO_FLUSH_DEVICE)) {

        DebugPrint ((DBG_WARNING, "ATAPI: found a device that couldn't handle any flush command\n"));

        flushCommand = IDE_COMMAND_NO_FLUSH;
        done = TRUE;

    } else  if (IdePortSearchDeviceInRegMultiSzList (
                 FdoExtension,
                 IdentifyData, 
                 CHECK_POWER_FLUSH_DEVICE)) {
    
        DebugPrint ((DBG_WARNING, "ATAPI: found a device that has to use check power mode command to flush\n"));

        flushCommand = IDE_COMMAND_CHECK_POWER;
        done = TRUE;
    } 

    if (!done) { 

        //
        // real ATA-4 drive?
        //

        if ((IdentifyData->MajorRevision != 0x0000) &&
            (IdentifyData->MajorRevision != 0xffff)) {
    
            USHORT version;
    
            version = IdentifyData->MajorRevision & ATA_VERSION_MASK;
            if (version & ~(ATA1_COMPLIANCE | ATA2_COMPLIANCE | ATA3_COMPLIANCE)) {
    
                //
                // ATA-4 Flush Command
                //
                flushCommand = IDE_COMMAND_FLUSH_CACHE;
                done = TRUE;
            }
        } 
    }

    if (!done) { 
            
        ATA_PASS_THROUGH ataPassThroughData;
        NTSTATUS status;
    
        //
        // try the ATA-4 flush command.  maybe it will work.
        //
        RtlZeroMemory (&ataPassThroughData, sizeof (ataPassThroughData));
    
        ataPassThroughData.IdeReg.bCommandReg = IDE_COMMAND_FLUSH_CACHE;
        ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED | ATA_PTFLAGS_ENUM_PROBING;
    
        status = IssueSyncAtaPassThroughSafe (
                     FdoExtension,
                     PdoExtension,
                     &ataPassThroughData,
                     FALSE,
                     FALSE,
                     15,
                     FALSE
                     );
        if (NT_SUCCESS(status)) {
    
            if (!(ataPassThroughData.IdeReg.bCommandReg & IDE_STATUS_ERROR)) {
    
                flushCommand = IDE_COMMAND_FLUSH_CACHE;
                done = TRUE;
            }
        }
    }

    if (!done) {

        // out of idea!
        // choose the default 

        flushCommand = IDE_COMMAND_CHECK_POWER;
    }

    return flushCommand;
}
                
#if 0
BOOLEAN
IdePortReuseIdent(
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    )
{
    PAGED_CODE();
    //
    // Determine if we can re-use the identify data
    //
    if (IdePortSearchDeviceInRegMultiSzList (
            FdoExtension, 
            IdentifyData, 
            NEED_IDENT_DEVICE)) {
        return TRUE;
    }
    return FALSE;
}
#endif
                
BOOLEAN
IdePortMustBePio (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    )
{
    PAGED_CODE();

    //
    // query pio only device from the registry
    //
    if (IdePortSearchDeviceInRegMultiSzList (
            FdoExtension, 
            IdentifyData, 
            PIO_ONLY_DEVICE)) {

        return TRUE;
    }

    return FALSE;
} // IdePortMustBePio
                
                
BOOLEAN
IdePortPioByDefaultDevice (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    )
{
    PAGED_CODE();

    //
    // query pio only device from the registry
    //
    if (IdePortSearchDeviceInRegMultiSzList (
            FdoExtension, 
            IdentifyData, 
            DEFAULT_PIO_DEVICE)) {

        return TRUE;
    }

    return FALSE;
} // IdePortMustBePio

BOOLEAN
IdePortDeviceHasNonRemovableMedia (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA     IdentifyData
)
{
    BOOLEAN removableMediaOverride;
    PAGED_CODE();

    if (IsNEC_98) {
        return ((IdentifyData->GeneralConfiguration & (1 << 7))? TRUE :
                    (!Is98LegacyIde(&FdoExtension->HwDeviceExtension->BaseIoAddress1)? TRUE : FALSE));
    }

    return (IdentifyData->GeneralConfiguration & (1 << 7)) ? TRUE : FALSE; 

    /*
    removableMediaOverride = FALSE;
    if (IdePortSearchDeviceInRegMultiSzList (
            FdoExtension, 
            IdentifyData, 
            NONREMOVABLE_MEDIA_OVERRIDE)) {

        removableMediaOverride = TRUE;
    }

    if (removableMediaOverride) {

        return FALSE;

    } else {

        return (IdentifyData->GeneralConfiguration & (1 << 7)) ? TRUE : FALSE; 
    }
    */
}
                
                
BOOLEAN
IdePortDeviceIsLs120 (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    )
{
    UCHAR modelNumber[41];
    ULONG i;
    UCHAR ls120NameString[] = "LS-120";

    PAGED_CODE();

    //
    // byte swap model number
    //
    for (i=0; i<40; i+=2) {
        modelNumber[i + 0] = IdentifyData->ModelNumber[i + 1];
        modelNumber[i + 1] = IdentifyData->ModelNumber[i + 0];
    }
    modelNumber[i] = 0;

    return strstr(_strupr(modelNumber), ls120NameString) ? TRUE : FALSE;
} // IdePortDeviceIsLs120
                
                
BOOLEAN
IdePortNoPowerDown (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    )
{
    PAGED_CODE();

    //
    // query no power down device from the registry
    //
    if (IdePortSearchDeviceInRegMultiSzList (
            FdoExtension, 
            IdentifyData, 
            NO_POWER_DOWN_DEVICE)) {

        return TRUE;
    }

    return FALSE;
} // IdePortNoPowerDown

BOOLEAN
IdePortVerifyDma (
    IN PPDO_EXTENSION pdoExtension,
    IN IDE_DEVICETYPE ideDeviceType
    )
{
    NTSTATUS status;
    ULONG oldDmaTransferTimeoutCount;
    BOOLEAN dmaOk;


    dmaOk = TRUE;
    
    if (pdoExtension->DmaTransferTimeoutCount >= PDO_DMA_TIMEOUT_LIMIT) {

        dmaOk = FALSE;

    } else if (ideDeviceType == DeviceIsAtapi) {

        INQUIRYDATA DmaInquiryData;
        INQUIRYDATA PioInquiryData;

        status = IssueInquirySafe(
                    pdoExtension->ParentDeviceExtension, 
                    pdoExtension, 
                    &DmaInquiryData,
                    FALSE);

        if (NT_SUCCESS(status)) {

            //
            // force a pio transfer
            //
            oldDmaTransferTimeoutCount = InterlockedExchange(
                                             &pdoExtension->DmaTransferTimeoutCount,
                                             PDO_DMA_TIMEOUT_LIMIT
                                             );
            status = IssueInquirySafe(
                        pdoExtension->ParentDeviceExtension, 
                        pdoExtension, 
                        &PioInquiryData,
                        FALSE);

            if (NT_SUCCESS(status) && 
                (RtlCompareMemory (&DmaInquiryData, &PioInquiryData,
                 sizeof(DmaInquiryData)) != sizeof(DmaInquiryData))) {


                dmaOk = FALSE;

                //
                // dma is not ok, leave the dma error count as PDO_DMA_TIMEOUT_LIMIT
                // so that we are not going to use dma with this device
                //
            } else {

                InterlockedExchange(
                    &pdoExtension->DmaTransferTimeoutCount,
                    oldDmaTransferTimeoutCount
                    ); 
            }
        }

    } else if (ideDeviceType == DeviceIsAta) {

        PUCHAR dmaDataBuffer;
        PUCHAR pioDataBuffer;
        CDB  cdb;

        //
        // the only non-desctrutive way to test dma on a 
        // ata device is to perform a pio read and a dma read and
        // compare the data.
        //
        // this technique does not work if the device has a removable
        // media and it is removed.
        //

        dmaDataBuffer = ExAllocatePool (
                           NonPagedPool,
                           512 * 2
                           );
        if (dmaDataBuffer) {

            pioDataBuffer = dmaDataBuffer + 512;

            //
            // setup dma pass through
            //
            RtlZeroMemory(&cdb, sizeof(CDB));
            cdb.CDB10.OperationCode = SCSIOP_READ;
            cdb.CDB10.TransferBlocksLsb = 1;

            status = IssueSyncAtapiCommandSafe (
                         pdoExtension->ParentDeviceExtension, 
                         pdoExtension,
                         &cdb,
                         dmaDataBuffer,
                         512,
                         TRUE,
                         2,
                         FALSE
                         );

            if (NT_SUCCESS(status)) {

                //
                // setup pio pass through
                //
                RtlZeroMemory(&cdb, sizeof(CDB));
                cdb.CDB10.OperationCode = SCSIOP_READ;
                cdb.CDB10.TransferBlocksLsb = 1;

                //
                // force a pio transfer
                //
                oldDmaTransferTimeoutCount = InterlockedExchange(
                                                 &pdoExtension->DmaTransferTimeoutCount,
                                                 PDO_DMA_TIMEOUT_LIMIT
                                                 );

                status = IssueSyncAtapiCommand (
                             pdoExtension->ParentDeviceExtension, 
                             pdoExtension,
                             &cdb,
                             pioDataBuffer,
                             512,
                             TRUE,
                             2,
                             FALSE
                             );

                if (NT_SUCCESS(status) &&
                    (RtlCompareMemory (
                        dmaDataBuffer,
                        pioDataBuffer,
                        512) != 512)) {

                    dmaOk = FALSE;

                    //
                    // dma is not ok, leave the dma error count as PDO_DMA_TIMEOUT_LIMIT
                    // so that we are not going to use dma with this device
                    //
                } else {

                    InterlockedExchange(
                        &pdoExtension->DmaTransferTimeoutCount,
                        oldDmaTransferTimeoutCount
                        ); 
                }
            }
        }

        if (dmaDataBuffer) {
            ExFreePool (dmaDataBuffer);
        }
    }

#if DBG
#if defined (FAKE_BROKEN_DMA_DEVICE)
    InterlockedExchange(
        &pdoExtension->DmaTransferTimeoutCount,
        PDO_DMA_TIMEOUT_LIMIT
        ); 
    dmaOk = FALSE;
#endif // FAKE_BROKEN_DMA_DEVICE
#endif // DBG

    if (!dmaOk) {

        ERROR_LOG_ENTRY errorLogEntry;

        errorLogEntry.ErrorCode             = SP_BAD_FW_ERROR;
        errorLogEntry.MajorFunctionCode     = IRP_MJ_SCSI;
        errorLogEntry.PathId                = pdoExtension->PathId;
        errorLogEntry.TargetId              = pdoExtension->TargetId;
        errorLogEntry.Lun                   = pdoExtension->Lun;
        errorLogEntry.UniqueId              = ERRLOGID_LYING_DMA_SYSTEM;
        errorLogEntry.ErrorLogRetryCount    = 0;
        errorLogEntry.SequenceNumber        = 0;

        LogErrorEntry(
            pdoExtension->ParentDeviceExtension,
            &errorLogEntry
            );

        DebugPrint ((
            DBG_ALWAYS,
            "ATAPI: system and/or device lies about its dma capability. pdoe = 0x%x\n",
            pdoExtension
            ));
    }

    return dmaOk;
}

VOID
IdePortFudgeAtaIdentifyData(
    IN OUT PIDENTIFY_DATA IdentifyData
    )
{
    if (IdentifyData->GeneralConfiguration == 0xffff) {

        //
        // guessing we have a really old ATA drive
        // fake the GeneralConfiguration value
        //
        CLRMASK (
            IdentifyData->GeneralConfiguration, 
            (IDE_IDDATA_REMOVABLE | (1 << 15))
            );
    }

}

#define PANASONIC_PCMCIA_IDE_DEVICE L"PCMCIA\\KME-KXLC005-A99E"

BOOLEAN
IdePortIsThisAPanasonicPCMCIACard(
    IN PFDO_EXTENSION FdoExtension
    )
{
    IO_STATUS_BLOCK     ioStatus;
    KEVENT              pnpEvent;
    NTSTATUS            status;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack;
    PIRP                pnpIrp;
    BOOLEAN             result = FALSE;

    PAGED_CODE();

    targetObject = FdoExtension->AttacheeDeviceObject;

    //
    // Initialize the event
    //
    KeInitializeEvent( &pnpEvent, SynchronizationEvent, FALSE );

    //
    // Build an Irp
    //
    pnpIrp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        FdoExtension->AttacheeDeviceObject,
        NULL,
        0,
        NULL,
        &pnpEvent,
        &ioStatus
        );
    if (pnpIrp == NULL) {

        return FALSE;
    }

    //
    // Pnp Irps all begin life as STATUS_NOT_SUPPORTED;
    //
    pnpIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    pnpIrp->IoStatus.Information = 0;

    //
    // Set the top of stack
    //
    irpStack = IoGetNextIrpStackLocation( pnpIrp );
    RtlZeroMemory( irpStack, sizeof(IO_STACK_LOCATION ) );
    irpStack->MajorFunction = IRP_MJ_PNP;
    irpStack->MinorFunction = IRP_MN_QUERY_ID;
    irpStack->Parameters.QueryId.IdType = BusQueryDeviceID;

    //
    // Make sure that there are no completion routines set
    //
    IoSetCompletionRoutine(
        pnpIrp,
        NULL,
        NULL,
        FALSE,
        FALSE,
        FALSE
        );

    //
    // Call the driver
    //
    status = IoCallDriver( targetObject, pnpIrp );
    if (status == STATUS_PENDING) {

        //
        // Block until the irp comes back
        //
        KeWaitForSingleObject(
            &pnpEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = ioStatus.Status;

    }

    if (NT_SUCCESS(status)) {

        UNICODE_STRING panasonicDeviceId;
        UNICODE_STRING deviceId;

        RtlInitUnicodeString (&panasonicDeviceId, PANASONIC_PCMCIA_IDE_DEVICE);
        RtlInitUnicodeString (&deviceId, (PWCHAR) ioStatus.Information);

        if (!RtlCompareUnicodeString(
            &deviceId, 
            &panasonicDeviceId,
            TRUE)) {

            result = TRUE;
        }

        ExFreePool ((PVOID) ioStatus.Information);
    }

    return result;
}


//
// Timing Code
//
#if defined (ENABLE_TIME_LOG)

TIME_LOG TimeLog[TimeMax] = {0};
VOID
LogStartTime(
    TIME_ID id,
    PLARGE_INTEGER timer
    ) 
{
    *timer = KeQueryPerformanceCounter(NULL);
}

VOID
LogStopTime(
    TIME_ID id,
    PLARGE_INTEGER timer,
    ULONG waterMark
    ) 
{
    LARGE_INTEGER freq;
    LARGE_INTEGER stopTime;
    LARGE_INTEGER diffTime;
    LARGE_INTEGER diffTimeInMicroSec;

    stopTime = KeQueryPerformanceCounter(&freq);
    diffTime.QuadPart = stopTime.QuadPart - timer->QuadPart;
    diffTimeInMicroSec.QuadPart = (diffTime.QuadPart * 1000000) / freq.QuadPart;

    // need a spinlock

    if (TimeLog[id].min.QuadPart == 0) {

        TimeLog[id].min.QuadPart = 0x7fffffffffffffffL;
    }

    if (diffTime.QuadPart < TimeLog[id].min.QuadPart) {
        TimeLog[id].min = diffTime;
    }

    if (diffTime.QuadPart > TimeLog[id].max.QuadPart) {
        TimeLog[id].max = diffTime;
    }

    TimeLog[id].totalTimeInMicroSec.QuadPart += diffTimeInMicroSec.QuadPart;
    TimeLog[id].numLog.QuadPart++;

    if (waterMark) {
        if (diffTimeInMicroSec.LowPart > waterMark) {
    
            DebugPrint ((DBG_ALWAYS, "IdePort: timerID 0x%d took %d us\n", id, (ULONG) diffTimeInMicroSec.LowPart));
        }
    }
}

#endif // ENABLE_TIME_LOG


#if defined (IDE_BUS_TRACE)

ULONG IdePortBusTraceTableMaxEntries = 0x20000;
BUS_TRACE_LOG IdePortBusTaceLog = {0, 0, 0, FALSE};

VOID InitBusTraceLogTable (
    VOID
    )
{
    ASSERT (IdePortBusTaceLog.LogTable == NULL);

    //           
    // make sure MAX_ULONG + 1 is a multiple of total log entries
    // so that when the index wraps, we don't skin any log entry
    //
    ASSERT(!((((ULONGLONG) 0xffffffff) + 1) % IdePortBusTraceTableMaxEntries));

    IdePortBusTaceLog.LogTable = 
        ExAllocatePool (NonPagedPool, IdePortBusTraceTableMaxEntries * sizeof(BUS_TRACE_RECORD));

    if (IdePortBusTaceLog.LogTable) {
        IdePortBusTaceLog.NumLogTableEntries = IdePortBusTraceTableMaxEntries;
        IdePortBusTaceLog.LastLogTableEntry = -1;
        IdePortBusTaceLog.TableWrapped = FALSE;

        KeInitializeSpinLock(&IdePortBusTaceLog.SpinLock);
    }
}

VOID FreeBusTraceLogTable (
    VOID
    )
{
    if (IdePortBusTaceLog.LogTable) {

        ExFreePool (IdePortBusTaceLog.LogTable);
        RtlZeroMemory(&IdePortBusTaceLog, sizeof(IdePortBusTaceLog));
    }
}


VOID
IdepUpdateTraceLog (
    IO_TYPE IoType,
    PVOID PortAddress,
    ULONG Data
    )
{
    KIRQL currentIrql;
    ULONG lastEntry;

    if (IdePortBusTaceLog.LogTable) {

        lastEntry = InterlockedIncrement(&IdePortBusTaceLog.LastLogTableEntry);
        lastEntry--;
        lastEntry %= IdePortBusTaceLog.NumLogTableEntries;
        IdePortBusTaceLog.LogTable[lastEntry].IoType = IoType;
        IdePortBusTaceLog.LogTable[lastEntry].Address = PortAddress;
        IdePortBusTaceLog.LogTable[lastEntry].Data = Data;
        IdePortBusTaceLog.LogTable[lastEntry].Count = 1;
    }
}

UCHAR
IdepPortInPortByte (
    PUCHAR PortAddress
    )
{
    KIRQL currentIrql;
    UCHAR data;

    data = READ_PORT_UCHAR(PortAddress);
    IdepUpdateTraceLog (InPortByte, PortAddress, (ULONG) data);
    return data;
}

VOID
IdepPortOutPortByte (
    PUCHAR PortAddress,
    UCHAR Data
    )
{
    WRITE_PORT_UCHAR(PortAddress, Data);
    IdepUpdateTraceLog (OutPortByte, PortAddress, (ULONG) Data);
    return;
}

USHORT
IdepPortInPortWord (
    PUSHORT PortAddress
    )
{
    KIRQL currentIrql;
    USHORT data;

    data = READ_PORT_USHORT(PortAddress);
    IdepUpdateTraceLog (InPortWord, PortAddress, (ULONG) data);
    return data;
}

VOID
IdepPortOutPortWord (
    PUSHORT PortAddress,
    USHORT Data
    )
{
    WRITE_PORT_USHORT(PortAddress, Data);
    IdepUpdateTraceLog (OutPortWord, PortAddress, (ULONG) Data);
    return;
}

VOID
IdepPortInPortWordBuffer (
    PUSHORT PortAddress,
    PUSHORT Buffer,
    ULONG Count
    )
{
    ULONG i;
    for (i=0; i<Count; i++) {
        Buffer[i] = IdepPortInPortWord (PortAddress);
    }
    return;
}


VOID
IdepPortOutPortWordBuffer (
    PUSHORT PortAddress,
    PUSHORT Buffer,
    ULONG Count
    )
{
    ULONG i;
    for (i=0; i<Count; i++) {
        IdepPortOutPortWord (PortAddress, Buffer[i]);
    }
    return;
}

#endif // IDE_BUS_TRACE



SPECIAL_ACTION_FLAG
IdeFindSpecialDevice(
    IN PUCHAR VendorProductId,
    IN PUCHAR ProductRevisionId
)
/*++

Routine Description:

    This routine will search the IDE special device table to determine whether 
    any special behavior should be enabled for this device. The match is made upto 
    the strlen of VendorProductId in the table.
    
Arguments:

    VendorProductId - the full vendor & product ID of the device in question.    
    ProductRevisionId - the full product revision ID of the device in question.    

ReturnValue:

    an ulong which describes the limitations of the device 
    in question.
    
--*/

{
    IDE_SPECIAL_DEVICE IdeSpecialDeviceTable[] = {
        {"TOSHIBA CD-ROM XM-1702B", NULL, disableSerialNumber},
        {"TOSHIBA CD-ROM XM-6202B", NULL, disableSerialNumber},
        {"COMPAQ DVD-ROM DRD-U424", NULL, disableSerialNumber},
        {"           "            , NULL, disableSerialNumber},
        {"KENWOOD CD-ROM",          NULL, skipModeSense},
        {"MEMORYSTICK",             NULL, setFlagSonyMemoryStick},
        {NULL,                      NULL, noSpecialAction}
        };
    
    ULONG i;
    ULONG length;

    PAGED_CODE();

    //
    // if both the arguments are null, then just return no special action
    //
    if (VendorProductId == NULL &&
        ProductRevisionId == NULL) {
        return noSpecialAction;
    }

    for(i = 0; IdeSpecialDeviceTable[i].VendorProductId != NULL; i++) {

        //
        // Match only upto the strlen of the productID in the table
        // This will allow special action for all the models from a particular vendor.
        //
        length=strlen(IdeSpecialDeviceTable[i].VendorProductId);

        if (length != RtlCompareMemory(IdeSpecialDeviceTable[i].VendorProductId, 
                                                VendorProductId, length)) {

            continue;
        }

        //
        // Partial matches are not acceptable for revision Ids.
        //
        if((IdeSpecialDeviceTable[i].Revision != NULL) &&
           (strcmp(IdeSpecialDeviceTable[i].Revision,
                    ProductRevisionId) != 0)) {
            continue;
        }

        //
        // We've got a match.  Break out.
        //

        break;
    }

    //
    // Return whatever entry we're pointing at.  If we matched based on the
    // id's then this will be the matching entry.  If we broke out of the 
    // loop then this will be the last entry in the list which is the 
    // benign, "nothing special about this device" entry that we return 
    // for a failed match.
    //

    return (IdeSpecialDeviceTable[i].RequiredAction);
}

#ifdef ENABLE_COMMAND_LOG

VOID
IdeLogOpenCommandLog(
    PSRB_DATA SrbData
)
{
    if (SrbData->IdeCommandLog == NULL) {
        SrbData->IdeCommandLog = ExAllocatePool(
                                            NonPagedPool, 
                                            MAX_COMMAND_LOG_ENTRIES*sizeof(COMMAND_LOG)
                                            );
        if (SrbData->IdeCommandLog != NULL) {
            RtlZeroMemory(SrbData->IdeCommandLog, MAX_COMMAND_LOG_ENTRIES*sizeof(COMMAND_LOG));
        }

        SrbData->IdeCommandLogIndex = 0;
    }
    return;
}

VOID
IdeLogStartCommandLog(
    PSRB_DATA SrbData
)
{
    PCOMMAND_LOG cmdLog = &(SrbData->IdeCommandLog[SrbData->IdeCommandLogIndex]);
    PSCSI_REQUEST_BLOCK srb = SrbData->CurrentSrb;

    ASSERT(srb);

    if (cmdLog == NULL) {
        return;
    }

    UpdateStartTimeStamp(cmdLog);

    if (srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH ||
        srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) {

        PATA_PASS_THROUGH ataPassThroughData = srb->DataBuffer;
        cmdLog->Cdb[0]= srb->Function;
        RtlCopyMemory(&(cmdLog->Cdb[1]), &(ataPassThroughData->IdeReg), sizeof(IDEREGS));

    } else {

        RtlCopyMemory(&(cmdLog->Cdb), &(srb->Cdb), sizeof(CDB));
    }
    return;
}

VOID
IdeLogStopCommandLog(
    PSRB_DATA SrbData
)
{
    PCOMMAND_LOG cmdLog = &(SrbData->IdeCommandLog[SrbData->IdeCommandLogIndex]);
    PSCSI_REQUEST_BLOCK srb = SrbData->CurrentSrb;
	PSENSE_DATA senseBuffer = NULL;
    ULONG senseInfoBufferLength;

    ASSERT(srb);

    if (cmdLog == NULL) {
        return;
    }

    UpdateStopTimeStamp(cmdLog);

    if (srb->Cdb[0] == SCSIOP_REQUEST_SENSE) {
        senseBuffer = srb->DataBuffer;
        senseInfoBufferLength = srb->DataTransferLength;
    } else if (srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        senseBuffer = srb->SenseInfoBuffer;
        senseInfoBufferLength = (ULONG) srb->SenseInfoBufferLength;
	}

	if (senseBuffer && (senseInfoBufferLength > FIELD_OFFSET(SENSE_DATA, AdditionalSenseCodeQualifier))) {
		cmdLog->SenseData[0] = senseBuffer->SenseKey;
		cmdLog->SenseData[1] = senseBuffer->AdditionalSenseCode;
		cmdLog->SenseData[2] = senseBuffer->AdditionalSenseCodeQualifier;
	}else {
		cmdLog->SenseData[0] = 0;
		cmdLog->SenseData[1] = 0;
		cmdLog->SenseData[2] = 0;
	}

    SrbData->IdeCommandLogIndex = ( SrbData->IdeCommandLogIndex + 1) % MAX_COMMAND_LOG_ENTRIES;
    return;
}

VOID
IdeLogSaveTaskFile(
    PSRB_DATA SrbData,
    PIDE_REGISTERS_1 BaseIoAddress
)
{
    PCOMMAND_LOG cmdLog = &(SrbData->IdeCommandLog[SrbData->IdeCommandLogIndex]);

    if (cmdLog == NULL) {
        return;
    }

    AtapiTaskRegisterSnapshot(BaseIoAddress, &(cmdLog->FinalTaskFile));
    return;
}

VOID
IdeLogBmStatus(
    PSCSI_REQUEST_BLOCK Srb,
    BMSTATUS   BmStatus
)
{
    PSRB_DATA srbData = IdeGetSrbData(NULL, Srb);
    PCOMMAND_LOG cmdLog;

    if (srbData == NULL) {
        return;
    }

    cmdLog = &(srbData->IdeCommandLog[srbData->IdeCommandLogIndex]);
    if (cmdLog == NULL) {
        return;
    }

    cmdLog->BmStatus = BmStatus;
    return;
}

VOID
IdeLogFreeCommandLog(
    PSRB_DATA   SrbData
)
{
    PCOMMAND_LOG cmdLog = SrbData->IdeCommandLog;

    if (cmdLog) {
        ExFreePool(cmdLog);
    }
    SrbData->IdeCommandLog = NULL;      
    SrbData->IdeCommandLogIndex = 0;      
}
#endif

#ifdef ENABLE_ATAPI_VERIFIER

PVOID ViIdeExtensionTable[2];

#define VFLAGS_FORCE_TIMEOUT    (1<<0)
#define VFLAGS_DMA_TIMEOUT      (1<<1)
#define VFLAGS_CFLUSH_TIMEOUT   (1<<2)
#define VFLAGS_DEVICE_CHANGE    (1<<3)
#define VFLAGS_MISSING_DEVICE   (1<<4)
#define VFLAGS_ACTUAL_ERROR     (1<<5)
#define VFLAGS_CRC_ERROR        (1<<6)
#define VFLAGS_BUSY_ERROR       (1<<7)
#define VFLAGS_RW_ERROR         (1<<8)

VOID
ViIdeInitVerifierSettings(
    IN PFDO_EXTENSION   FdoExtension
)
{
}

BOOLEAN
ViIdeGenerateDmaTimeout(
    IN PVOID HwDeviceExtension, 
    IN BOOLEAN DmaInProgress
) 
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PFDO_EXTENSION fdoExtension = ((PFDO_EXTENSION)HwDeviceExtension - 1); 
    PSCSI_REQUEST_BLOCK srb = hwDeviceExtension->CurrentSrb;
    ULONG ideInternalVerifierFlags ;

    ASSERT(srb);

    ideInternalVerifierFlags = fdoExtension->IdeInternalVerifierFlags[srb->TargetId];

    if (ideInternalVerifierFlags & VFLAGS_FORCE_TIMEOUT) {
        return TRUE;
    }

    if (DmaInProgress && (ideInternalVerifierFlags & VFLAGS_DMA_TIMEOUT)) { 
        return TRUE;
    }

    if ((srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH) ||
        (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH)) {

        PATA_PASS_THROUGH    ataPassThroughData;
        PIDEREGS             pIdeReg;

        ataPassThroughData = srb->DataBuffer;
        pIdeReg            = &ataPassThroughData->IdeReg;

        if ((ideInternalVerifierFlags & VFLAGS_CFLUSH_TIMEOUT) &&
            (pIdeReg->bCommandReg == hwDeviceExtension->DeviceParameters[srb->TargetId].IdeFlushCommand )) {
            return TRUE;
        }
    }

    return FALSE;
}

ULONG
ViIdeFakeDeviceChange(
    IN PFDO_EXTENSION FdoExtension,
    ULONG   Target
)
{
    ULONG ideInternalVerifierFlags = FdoExtension->IdeDebugVerifierFlags[Target];

    if (ideInternalVerifierFlags & VFLAGS_DEVICE_CHANGE) {
        return 1;
    }

    return 0;
}

BOOLEAN
ViIdeFakeMissingDevice(
    IN PFDO_EXTENSION FdoExtension,
    ULONG Target
)
{
    ULONG ideInternalVerifierFlags = FdoExtension->IdeDebugVerifierFlags[Target];

    if (ideInternalVerifierFlags & VFLAGS_MISSING_DEVICE) {
        return TRUE;
    }

    return FALSE;
}
VOID
ViAtapiInterrupt(
    IN PFDO_EXTENSION FdoExtension
    )
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = FdoExtension->HwDeviceExtension;
    PIDE_REGISTERS_1 baseIoAddress = &(hwDeviceExtension->BaseIoAddress1);
    PSCSI_REQUEST_BLOCK srb = hwDeviceExtension->CurrentSrb;
    ULONG target;

    //DebugPrint((0, "verifier interrupt fdoe = %x, b=%x\n", FdoExtension, baseIoAddress->RegistersBaseAddress));

    if ((ULONG)(baseIoAddress->RegistersBaseAddress) == 0x1f0) {
        ViIdeExtensionTable[0]=FdoExtension;
    } else {
        ViIdeExtensionTable[1]=FdoExtension;
    }

    if (srb == NULL) {
        return ;
    }

    target = srb->TargetId;

    //
    // Generate timeouts
    //
    if (FdoExtension->IdeDebugVerifierFlags[target] & VFLAGS_DMA_TIMEOUT) {
        FdoExtension->IdeInternalVerifierFlags[target] |= VFLAGS_DMA_TIMEOUT;
        return;
    }

    //
    // Generate CRC errors
    //
    if (FdoExtension->IdeDebugVerifierFlags[target] & VFLAGS_CRC_ERROR) {
        if (FdoExtension->IdeVerifierEventCount[target][CrcEvent] >= FdoExtension->IdeVerifierEventFrequency[target][CrcEvent]) {
            FdoExtension->IdeInternalVerifierFlags[target] |= VFLAGS_CRC_ERROR;
            FdoExtension->IdeVerifierEventCount[target][CrcEvent]=0;
            return;
        } else {
            FdoExtension->IdeVerifierEventCount[target][RwEvent]++;
        }
    }

    //
    // Generate Busy errors
    //
    if (FdoExtension->IdeDebugVerifierFlags[target] & VFLAGS_BUSY_ERROR) {
        if (FdoExtension->IdeVerifierEventCount[target][BusyEvent] >= FdoExtension->IdeVerifierEventFrequency[target][BusyEvent]) {
            FdoExtension->IdeInternalVerifierFlags[target] |= VFLAGS_BUSY_ERROR;
            FdoExtension->IdeVerifierEventCount[target][BusyEvent]=0;
            return;
        } else {
            FdoExtension->IdeVerifierEventCount[target][BusyEvent]++;
        }
    }

    //
    // Generate Read write errors
    //
    if (FdoExtension->IdeDebugVerifierFlags[target] & VFLAGS_RW_ERROR) {
        if (FdoExtension->IdeVerifierEventCount[target][RwEvent] >= FdoExtension->IdeVerifierEventFrequency[target][RwEvent]) {
            FdoExtension->IdeInternalVerifierFlags[target] |= VFLAGS_RW_ERROR;
            FdoExtension->IdeVerifierEventCount[target][RwEvent]=0;
            return;
        } else {
            FdoExtension->IdeVerifierEventCount[target][RwEvent]++;
        }
    }
//    ViIdeGenerateReadWriteErrors(FdoExtension);

 //   ViIdeGenerateDmaErrors(FdoExtension);
//    ViIdeFakeHungController(FdoExtension);
    return ;
}

UCHAR
ViIdeGetBaseStatus(
    PIDE_REGISTERS_1 BaseIoAddress
)
{
    UCHAR status = IdePortInPortByte((BaseIoAddress)->Command);
    /*
    UCHAR deviceSelect = IdePortInPortByte(BaseIoAddress->DriveSelect);
    UCHAR channel = ((ULONG)(BaseIoAddress->RegistersBaseAddress) == 0x1f0) ? 0: 1;
    PFDO_EXTENSION fdoExtension = ViIdeExtensionTable[channel];
    ULONG target = (deviceSelect == 0xA0)? 0: 1;
    ULONG ideInternalVerifierFlags; 
    ULONG dFlags;

    if (fdoExtension == NULL) {
        return status;
    }

    ideInternalVerifierFlags = fdoExtension->IdeInternalVerifierFlags[target];
    dFlags = fdoExtension->HwDeviceExtension->DeviceFlags[target];

    if (status & IDE_STATUS_ERROR) {
        SETMASK(fdoExtension->IdeInternalVerifierFlags[target], VFLAGS_ACTUAL_ERROR);
        return status;
    }

    if (ideInternalVerifierFlags & VFLAGS_CRC_ERROR) {
        return IDE_STATUS_ERROR;
    }

    if (ideInternalVerifierFlags & VFLAGS_BUSY_ERROR) {
        return IDE_STATUS_BUSY;
    }

    if (ideInternalVerifierFlags & VFLAGS_RW_ERROR) {
        return IDE_STATUS_ERROR;
    }
    */
    return status;
}

UCHAR
ViIdeGetErrorByte(
    PIDE_REGISTERS_1 BaseIoAddress
)
/**++
Description:
    Depending on the internalVerifier flag (set by the other verifier routines),
    this function will return the appropriate error value. However, if the device
    reports an actual error (as indicated by the internalverifier flag), 
    it is returned unchanged.
    
Arguments:
    BaseIoAddress : Task file registers
    
Return Value:    
    The error byte.
--**/
{
    UCHAR error = IdePortInPortByte(BaseIoAddress->Error);
    /*
    UCHAR deviceSelect = IdePortInPortByte(BaseIoAddress->DriveSelect);
    UCHAR channel = ((ULONG)(BaseIoAddress->RegistersBaseAddress) == 0x1f0) ? 0: 1;
    PFDO_EXTENSION fdoExtension = ViIdeExtensionTable[channel];
    ULONG target = (deviceSelect == 0xA0)? 0: 1;
    ULONG ideInternalVerifierFlags;
    ULONG dFlags;

    if (fdoExtension == NULL ) {
        return error;
    }
    
    ideInternalVerifierFlags = fdoExtension->IdeInternalVerifierFlags[target];
    dFlags = fdoExtension->HwDeviceExtension->DeviceFlags[target];

    //
    // return error if an actual error was reproted
    //
    if (ideInternalVerifierFlags & VFLAGS_ACTUAL_ERROR) {
        CLRMASK(fdoExtension->IdeInternalVerifierFlags[target], VFLAGS_ACTUAL_ERROR);
        return error;
    }

    if (ideInternalVerifierFlags & VFLAGS_CRC_ERROR) {

        if (dFlags & DFLAGS_ATAPI_DEVICE) {
            error = SCSI_SENSE_HARDWARE_ERROR << 4;
        } else {
            error = IDE_ERROR_CRC_ERROR | IDE_ERROR_COMMAND_ABORTED;
        }
        return error;
    }
    */
    return error;
}

#endif

#ifdef IDE_MEASURE_BUSSCAN_SPEED
VOID
LogBusScanStartTimer(
    PLARGE_INTEGER TickCount
)
{
    KeQueryTickCount(TickCount);
    return;
}

ULONG
LogBusScanStopTimer(
    PLARGE_INTEGER TickCount
)
{
    LARGE_INTEGER tickCount2;
    LARGE_INTEGER numMs;
    KeQueryTickCount(&tickCount2);
    numMs.QuadPart = ((tickCount2.QuadPart - TickCount->QuadPart) * KeQueryTimeIncrement()) / (10 * 1000);

    return(numMs.u.LowPart);
}

#endif

VOID
FASTCALL
IdePortLogNoMemoryErrorFn(
    IN PVOID DeviceExtension,
    IN ULONG TargetId,
    IN POOL_TYPE PoolType,
    IN SIZE_T Size,
    IN ULONG FailureLocationId,
    IN ULONG Tag
    )

/*++

Routine Description:

    This routine writes a message to the event log indicating that an
    allocation failure has occurred.

Arguments:

    DeviceExtension - Fdo Extension

    TargetId     - The target Id of the device that the request was to be sent to
    
    PoolType     - identifies the pool the failed allocation attempt was from.

    Size         - indicates the number of bytes that the failed allocation 
                   attempt tried to obtain.

    Tag          - identifies the pool tag associated with the failed 
                   allocation.
    
    LocationId   - identifies the location in the source code where it failed

Return Value:

    VOID

--*/

{
    NTSTATUS status;
    PFDO_EXTENSION deviceExtension = (PFDO_EXTENSION) (DeviceExtension);
    PIO_ERROR_LOG_PACKET errorLogEntry;
    PIO_ERROR_LOG_PACKET currentValue;

	InterlockedIncrement(&deviceExtension->NumMemoryFailure);

    //
    // Try to allocate a new error log event.
    //
    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                        deviceExtension->DeviceObject,
                        ALLOC_FAILURE_LOGSIZE
                        );


    //
    // If we could not allocate a log event, we check the device extension to
    // see if it has a reserve event we can use.  If we cannot get the device
    // extension or if it does not contain a reserve event, we return
    // without logging the allocation failure.
    //

    if (errorLogEntry == NULL) {

        //
        // Get the reserve event in the device extension.  The reserve event
        // may have already been used, so it's possible that it is NULL.  If
        // this is the case, we give up and return.
        //
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
                deviceExtension->ReserveAllocFailureLogEntry[TargetId];


        if (errorLogEntry == NULL) {
            DebugPrint((1, "IdePortLogAllocationFailureFn: no reserve packet\n"));
            return;
        }

        //
        // We have to ensure that we are the only instance to use this
        // event.  To do so, we attempt to NULL the event in the driver
        // extension.  If somebody else beats us to it, they own the
        // event and we have to give up.
        //

        currentValue = InterlockedCompareExchangePointer(
                            &(deviceExtension->ReserveAllocFailureLogEntry[TargetId]),
                            NULL,
                            errorLogEntry
                            );

        if (errorLogEntry != currentValue) {
            DebugPrint((1, "IdePortLogAllocationFailureFn: someone already owns packet\n"));
            return;
        }
    }

    //
    // Log the error
    //
    errorLogEntry->ErrorCode = IO_WARNING_ALLOCATION_FAILED;
    errorLogEntry->SequenceNumber = 0;
    errorLogEntry->MajorFunctionCode = 0;
    errorLogEntry->RetryCount = 0;
    errorLogEntry->UniqueErrorValue = 0x10;
    errorLogEntry->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
    errorLogEntry->DumpDataSize = 4 * sizeof(ULONG);
    errorLogEntry->DumpData[0] = TargetId;
    errorLogEntry->DumpData[1] = FailureLocationId;
    errorLogEntry->DumpData[2] = PtrToUlong((PVOID)Size);
    errorLogEntry->DumpData[3] = Tag;
    IoWriteErrorLogEntry(errorLogEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\hack.h ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    hack.h

Abstract:

--*/

#if !defined (___hack_h___)
#define ___hack_h___

extern ULONG IdeDebug;

extern ULONG IdeDebugRescanBusFreq;
extern ULONG IdeDebugRescanBusCounter;

extern ULONG IdeDebugHungControllerFreq;
extern ULONG IdeDebugHungControllerCounter;

extern ULONG IdeDebugTimeoutAllCacheFlush;

extern ULONG IdeDebugForceSmallCrashDumpBlockSize;

extern PDEVICE_OBJECT IdeDebugDevObjTimeoutAllDmaSrb;

extern ULONG FailBmSetupCount;

extern ULONG IdeDebugFakeCrcError;

VOID
IdeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#ifdef DebugPrint
#undef DebugPrint
#endif

#if DBG
#define DebugPrint(x) IdeDebugPrint x

#define DBG_BIT_CONTROL 0x80000000
#define DBG_ALWAYS      DBG_BIT_CONTROL
#define DBG_BUSSCAN           (DBG_BIT_CONTROL | 0x00000001)
#define DBG_PNP               (DBG_BIT_CONTROL | 0x00000002)
#define DBG_POWER             (DBG_BIT_CONTROL | 0x00000004)
#define DBG_READ_WRITE        (DBG_BIT_CONTROL | 0x00000008)
#define DBG_CRASHDUMP         (DBG_BIT_CONTROL | 0x00000010)
#define DBG_ACPI              (DBG_BIT_CONTROL | 0x00000020)
#define DBG_RESET             (DBG_BIT_CONTROL | 0x00000040)
#define DBG_PDO_LOCKTAG       (DBG_BIT_CONTROL | 0x00000080)
#define DBG_WMI               (DBG_BIT_CONTROL | 0x00000100)
#define DBG_IDEREADCAP        (DBG_BIT_CONTROL | 0x00000200)
#define DBG_WARNING           (DBG_BIT_CONTROL | 0x00000400)
#define DBG_REG_SEARCH        (DBG_BIT_CONTROL | 0x00000800)
#define DBG_IDE_DEVICE_ERROR  (DBG_BIT_CONTROL | 0x00001000)
#define DBG_ATAPI_DEVICES     (DBG_BIT_CONTROL | 0x00002000)
#define DBG_XFERMODE          (DBG_BIT_CONTROL | 0x00004000)

#ifdef IDE_MEASURE_BUSSCAN_SPEED
#define DBG_SPECIAL           DBG_ALWAYS
#else
#define DBG_SPECIAL           (DBG_BIT_CONTROL | 0x00008000)
#endif


#else
#define DebugPrint(x)
#endif
          
BOOLEAN
IdePortSlaveIsGhost (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA MasterIdentifyData,
    IN PIDENTIFY_DATA SlaveIdentifyData
    );
                      
UCHAR
IdePortGetFlushCommand (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN OUT PPDO_EXTENSION PdoExtension,
    IN PIDENTIFY_DATA     IdentifyData
    );
          

BOOLEAN
IdePortMustBePio (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    );
                     
BOOLEAN
IdePortPioByDefaultDevice (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    );

BOOLEAN
IdePortDeviceHasNonRemovableMedia (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA     IdentifyData
    );
                      
BOOLEAN
IdePortDeviceIsLs120 (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    );
                      
BOOLEAN
IdePortNoPowerDown (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    );
                      
BOOLEAN
IdePortVerifyDma (
    IN PPDO_EXTENSION pdoExtension,
    IN IDE_DEVICETYPE ideDeviceType
    );

VOID
IdePortFudgeAtaIdentifyData(
    IN OUT PIDENTIFY_DATA IdentifyData
    );

BOOLEAN
IdePortIsThisAPanasonicPCMCIACard(
    IN PFDO_EXTENSION FdoExtension
    );


VOID
FASTCALL
IdePortLogNoMemoryErrorFn(
    IN PVOID DeviceExtension,
    IN ULONG TargetId,
    IN POOL_TYPE PoolType,
    IN SIZE_T Size,
    IN ULONG LocationIdentifier,
    IN ULONG Tag
    );

typedef enum {
    noSpecialAction=0,
    disableSerialNumber,
    setFlagSonyMemoryStick,
    skipModeSense
}SPECIAL_ACTION_FLAG;

typedef struct _IDE_SPECIAL_DEVICE {
    PUCHAR VendorProductId;
    PUCHAR Revision;
    SPECIAL_ACTION_FLAG RequiredAction;
} IDE_SPECIAL_DEVICE, *PIDE_SPECIAL_DEVICE;

SPECIAL_ACTION_FLAG
IdeFindSpecialDevice(
    IN PUCHAR VendorProductId,
    IN PUCHAR ProductRevisionId
    );

// Model number can be atmost 40 ascii characters
#define MAX_MODELNUM_SIZE   40
#define MEMSTICKID   "MEMORYSTICK"

//procure the model number from the identify data
#define GetTargetModelId(IdentifyData, targetModelNum) {\
    ULONG i; \
    ASSERT(MAX_MODELNUM_SIZE <= sizeof(IdentifyData->ModelNumber)); \
    for (i=0; i<sizeof(IdentifyData->ModelNumber); i+=2) { \
        targetModelNum[i + 0] = IdentifyData->ModelNumber[i + 1]; \
        targetModelNum[i + 1] = IdentifyData->ModelNumber[i + 0]; \
        if (targetModelNum[i + 0] == '\0') { \
            targetModelNum[i + 0] = ' '; \
        }\
        if (targetModelNum[i + 1] == '\0') { \
            targetModelNum[i + 1] = ' '; \
        } \
    } \
    for (i = sizeof(IdentifyData->ModelNumber)-1;i>0; i--) { \
        if (targetModelNum[i] != ' ') { \
            ASSERT(i < MAX_MODELNUM_SIZE); \
            targetModelNum[i+1]='\0'; \
            break; \
        } \
    } \
    if (i == 0) { \
        if (targetModelNum[i] != ' ') { \
            ASSERT(i < MAX_MODELNUM_SIZE); \
            targetModelNum[i+1]='\0'; \
        } else { \
            targetModelNum[i]='\0'; \
        } \
    } \
}

#define ALLOC_FAILURE_LOGSIZE  (sizeof(IO_ERROR_LOG_PACKET) + 4 * sizeof(ULONG))
#define IdeLogNoMemoryError(a, b, c, d, e) IdePortLogNoMemoryErrorFn(a, b, c, d, e, 'PedI')
//
// Log dead meat info.
//
#ifdef LOG_DEADMEAT_EVENT

#define IdeLogDeadMeatEvent(filName, lineNum) { \
    filName = __FILE__;\
    lineNum = __LINE__; \
}
#define IdeLogDeadMeatTaskFile(dst, src) dst = src
#define IdeLogDeadMeatReason(dst, src) dst=src 

#else

#define IdeLogDeadMeatEvent(filName, lineNum) 
#define IdeLogDeadMeatTaskFile(dst, src) 
#define IdeLogDeadMeatReason(dst, src)

#endif //LOG_DEADMEAT_EVENT

//
// Timing Code
//
typedef enum _TIME_ID {

    TimeIsr = 0,
    TimeDpc,
    TimeStartIo,
    TimeMax

} TIME_ID;

#ifdef IDE_MEASURE_BUSSCAN_SPEED
VOID
LogBusScanStartTimer (
    PLARGE_INTEGER  TickCount
);

ULONG
LogBusScanStopTimer (
    PLARGE_INTEGER  TickCount
);

#define LogBusScanTimeDiff(FdoExtension, ParameterName, ParameterValue)  \
                IdePortSaveDeviceParameter(FdoExtension, ParameterName, ParameterValue)

#else
#define LogBusScanStartTimer(TickCount) 
#define LogBusScanStopTimer(TickCount) 0
#define LogBusScanTimeDiff(FdoExtension, ParameterName, ParameterValue)  
#endif

#if defined (ENABLE_TIME_LOG)

typedef struct _TIME_LOG {

    LARGE_INTEGER min;
    LARGE_INTEGER max;
    LARGE_INTEGER totalTimeInMicroSec;
    LARGE_INTEGER numLog;

} TIME_LOG, *PTIME_LOG;

VOID
LogStartTime(
    TIME_ID id,
    PLARGE_INTEGER timer
    );
VOID
LogStopTime(
    TIME_ID id,
    PLARGE_INTEGER timer,
    ULONG waterMarkInMicroSec
    );

#else 

#define LogStartTime(x,y)
#define LogStopTime(x,y,z)

#endif // ENABLE_TIME_LOG

#if defined (IDE_BUS_TRACE)

typedef enum _IO_TYPE {

    InPortByte = 0,
    OutPortByte,
    InPortWord,
    OutPortWord
} IO_TYPE;


typedef struct _BUS_TRACE_RECORD {

    IO_TYPE IoType;
    PVOID   Address;
    ULONG   Data;
    ULONG   Count;

} BUS_TRACE_RECORD, *PBUS_TRACE_RECORD;

typedef struct _BUS_TRACE_LOG {

    PBUS_TRACE_RECORD LogTable;
    ULONG NumLogTableEntries;
    ULONG LastLogTableEntry;
    BOOLEAN TableWrapped;

    KSPIN_LOCK SpinLock;

} BUS_TRACE_LOG, *PBUS_TRACE_LOG;

VOID InitBusTraceLogTable (
    VOID
    );

VOID FreeBusTraceLogTable (
    VOID
    );

VOID
IdepUpdateTraceLog (
    IO_TYPE IoType,
    PVOID PortAddress,
    ULONG Data
    );

UCHAR
IdepPortInPortByte (
    PUCHAR PortAddress
    );

VOID
IdepPortOutPortByte (
    PUCHAR PortAddress,
    UCHAR Data
    );

USHORT
IdepPortInPortWord (
    PUSHORT PortAddress
    );

VOID
IdepPortOutPortWord (
    PUSHORT PortAddress,
    USHORT Data
    );

VOID
IdepPortInPortWordBuffer (
    PUSHORT PortAddress,
    PUSHORT Buffer,
    ULONG Count
    );

VOID
IdepPortOutPortWordBuffer (
    PUSHORT PortAddress,
    PUSHORT Buffer,
    ULONG Count
    );

#endif // IDE_BUS_TRACE

#if defined (IDE_BUS_TRACE)

#define IdePortInPortByte(addr)        IdepPortInPortByte(addr)
#define IdePortOutPortByte(addr, data) IdepPortOutPortByte(addr, data)  

#define IdePortInPortWord(addr)        IdepPortInPortWord(addr)
#define IdePortOutPortWord(addr, data) IdepPortOutPortWord(addr, data)  

#define IdePortInPortWordBuffer(addr, buf, count)  IdepPortInPortWordBuffer(addr, buf, count)
#define IdePortOutPortWordBuffer(addr, buf, count) IdepPortOutPortWordBuffer(addr, buf, count)

#else

#define IdePortInPortByte(addr)        READ_PORT_UCHAR(addr)
#define IdePortOutPortByte(addr, data) WRITE_PORT_UCHAR(addr, data)  

#define IdePortInPortWord(addr)        READ_PORT_USHORT(addr)
#define IdePortOutPortWord(addr, data) WRITE_PORT_USHORT(addr, data)  

#define IdePortInPortWordBuffer(addr, buf, count)  READ_PORT_BUFFER_USHORT(addr, buf, count)
#define IdePortOutPortWordBuffer(addr, buf, count) WRITE_PORT_BUFFER_USHORT(addr, buf, count)

#endif // IDE_BUS_TRACE


typedef struct _COMMAND_LOG {
    UCHAR               Cdb[16];
    IDEREGS             InitialTaskFile;
    IDEREGS             FinalTaskFile;
    LARGE_INTEGER       StartTime;
    LARGE_INTEGER       EndTime;
    BMSTATUS            BmStatus;
    UCHAR               SenseData[3];
}COMMAND_LOG, *PCOMMAND_LOG;

#ifdef ENABLE_COMMAND_LOG

#define MAX_COMMAND_LOG_ENTRIES    40
#define UpdateStartTimeStamp(cmdLog) KeQuerySystemTime(&(cmdLog->StartTime));
#define UpdateStopTimeStamp(cmdLog) KeQuerySystemTime(&(cmdLog->EndTime));

typedef struct _SRB_DATA *PSRB_DATA;

VOID
IdeLogBmStatus (
    PSCSI_REQUEST_BLOCK Srb,
    BMSTATUS   BmStatus
);

VOID
IdeLogOpenCommandLog(
    PSRB_DATA SrbData
);

VOID
IdeLogStartCommandLog(
    PSRB_DATA SrbData
);

VOID
IdeLogStopCommandLog(
    PSRB_DATA SrbData
);

VOID
IdeLogSaveTaskFile(
    PSRB_DATA SrbData,
    PIDE_REGISTERS_1 BaseIoAddress
);

VOID
IdeLogFreeCommandLog(
    PSRB_DATA SrbData
);


#else

#define IdeLogOpenCommandLog(a)
#define IdeLogStartCommandLog(a)
#define IdeLogStopCommandLog(a)
#define IdeLogSaveTaskFile(a,b)
#define IdeLogBmStatus(a,b)
#define IdeLogFreeCommandLog(a)

#endif  // command log

#ifdef ENABLE_ATAPI_VERIFIER

VOID
ViAtapiInterrupt(
    IN PFDO_EXTENSION FdoExtension
);

UCHAR
ViIdeGetBaseStatus(
    PIDE_REGISTERS_1 BaseIoAddress
);

UCHAR
ViIdeGetErrorByte(
    PIDE_REGISTERS_1 BaseIoAddress
);

ULONG
ViIdeFakeDeviceChange(
    IN PFDO_EXTENSION FdoExtension,
    ULONG   Target
);

BOOLEAN
ViIdeFakeMissingDevice(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG Target
);

BOOLEAN
ViIdeGenerateDmaTimeout (
    IN PVOID HwDeviceExtension,
    IN BOOLEAN  DmaInProgress
);

VOID
ViIdeInitVerifierSettings(
    IN PFDO_EXTENSION   FdoExtension
);
/*
BOOLEAN
ViIdeGenerateDmaTimeout(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension, 
    IN BOOLEAN DmaInProgress
); 
*/
#endif //verifier

#endif // ___hack_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\idedata.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    idedata.c

Abstract:

--*/

#include "ideport.h"

//
// Beginning of Init Data 
//
#pragma data_seg ("INIT")

//
// global data for crashdump or hibernate
//
CRASHDUMP_DATA DumpData;


#pragma data_seg ()
//
// End of Pagable Data 
//

//////////////////////////////////////

//
// Beginning of Pagable Data 
//
#pragma data_seg ("PAGE")

const CHAR SuperFloppyCompatibleIdString[12] = "GenSFloppy";

//
// PnP Dispatch Table
//
PDRIVER_DISPATCH FdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];
PDRIVER_DISPATCH PdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];

//
// Wmi Dispatch Table
//
PDRIVER_DISPATCH FdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];
PDRIVER_DISPATCH PdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];

#pragma data_seg ()
//
// End of Pagable Data 
//

//////////////////////////////////////

//
// Beginning of Nonpagable Data
//              
#pragma data_seg ("NONPAGE")

#pragma data_seg ()
//
// End of Nonpagable Data
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\idedata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       idedata.h
//
//--------------------------------------------------------------------------

extern CRASHDUMP_DATA DumpData;

extern const CHAR SuperFloppyCompatibleIdString[12];

extern PDRIVER_DISPATCH FdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];
extern PDRIVER_DISPATCH PdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];

extern PDRIVER_DISPATCH FdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];
extern PDRIVER_DISPATCH PdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\ide.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    ide.c

Abstract:

    This contain DriverEntry and utilities routines

Author:

    Joe Dai (joedai)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "ideport.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, IdePortNoSupportIrp)
#pragma alloc_text(PAGE, IdePortPassDownToNextDriver)
#pragma alloc_text(PAGE, IdePortStatusSuccessAndPassDownToNextDriver)
#pragma alloc_text(PAGE, IdePortDispatchPnp)
#pragma alloc_text(PAGE, IdePortDispatchSystemControl)
#pragma alloc_text(PAGE, IdePortOkToDetectLegacy)
#pragma alloc_text(PAGE, IdePortOpenServiceSubKey)
#pragma alloc_text(PAGE, IdePortCloseServiceSubKey)
#pragma alloc_text(PAGE, IdePortParseDeviceParameters)
#pragma alloc_text(PAGE, IdePortGetDeviceTypeString)
#pragma alloc_text(PAGE, IdePortGetCompatibleIdString)
#pragma alloc_text(PAGE, IdePortGetPeripheralIdString)
#pragma alloc_text(PAGE, IdePortUnload)
#pragma alloc_text(PAGE, IdePortSearchDeviceInRegMultiSzList)
#pragma alloc_text(PAGE, IdePortSyncSendIrp)
#pragma alloc_text(PAGE, IdePortInSetup)

#pragma alloc_text(NONPAGE, IdePortDispatchDeviceControl)
#pragma alloc_text(NONPAGE, IdePortAlwaysStatusSuccessIrp)
#pragma alloc_text(NONPAGE, IdePortDispatchPower)
#pragma alloc_text(NONPAGE, IdePortGenericCompletionRoutine)
#endif // ALLOC_PRAGMA

//
// get the share code
//
#include "..\share\util.c"

#if DBG

//
// for performance tuning
//
void _DebugPrintResetTickCount (LARGE_INTEGER * lastTickCount) {
    KeQueryTickCount(lastTickCount);
}

void _DebugPrintTickCount (LARGE_INTEGER * lastTickCount, ULONG limit, PUCHAR filename, ULONG lineNumber)
{
    LARGE_INTEGER tickCount;

    KeQueryTickCount(&tickCount);
    if ((tickCount.QuadPart - lastTickCount->QuadPart) >= limit) {
        DebugPrint ((1, "File: %s Line %u: CurrentTick = %u (%u ticks since last check)\n", filename, lineNumber, (ULONG) tickCount.QuadPart, (ULONG) (tickCount.QuadPart - lastTickCount->QuadPart)));
    }
    *lastTickCount = tickCount;
}

#endif //DBG

//
// Po Dispatch Table
//
PDRIVER_DISPATCH FdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];
PDRIVER_DISPATCH PdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];

NTSTATUS
IdePortNoSupportIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Generic routine to fail unsupported irp

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP to fail.

Return Value:

    NT status.

--*/
{
    NTSTATUS status = Irp->IoStatus.Status;
    PIO_STACK_LOCATION       thisIrpSp;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

	//
	// You should call PoStartNextPowerIrp before completing a power irp
	//
	if (thisIrpSp->MajorFunction == IRP_MJ_POWER) {

		PoStartNextPowerIrp (Irp);

	}

    DebugPrint ((
        DBG_WARNING,
        "IdePort: devobj 0x%x failing unsupported Irp (0x%x, 0x%x) with status = %x\n",
        DeviceObject,
        thisIrpSp->MajorFunction,
        thisIrpSp->MinorFunction,
		status
        ));

    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // IdePortNoSupportIrp

NTSTATUS
IdePortAlwaysStatusSuccessIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
/*++

Routine Description:

    Generic routine to STATUS_SUCCESS an irp

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/
    )
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
} // IdePortAlwaysStatusSuccessIrp

NTSTATUS
IdePortPassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Generic routine to pass an irp down to the lower driver

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/
{
    PDEVICE_EXTENSION_HEADER doExtension;
    PIO_STACK_LOCATION       thisIrpSp;
    NTSTATUS status;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    ASSERT (doExtension->AttacheeDeviceObject);

	if (thisIrpSp->MajorFunction == IRP_MJ_POWER) {

		//
		// call PoStartNextPowerIrp before completing a power irp
		//
		PoStartNextPowerIrp (Irp);
		IoSkipCurrentIrpStackLocation (Irp);
		status = PoCallDriver (doExtension->AttacheeDeviceObject, Irp);

	} else {

		//
		// Not a power irp
		//
		IoSkipCurrentIrpStackLocation (Irp);
		status = IoCallDriver (doExtension->AttacheeDeviceObject, Irp);
	}

	return status;

} // IdePortPassDownToNextDriver

NTSTATUS
IdePortStatusSuccessAndPassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PAGED_CODE();
    Irp->IoStatus.Status = STATUS_SUCCESS;
    return IdePortPassDownToNextDriver(DeviceObject, Irp);
} // IdePortStatusSuccessAndPassDownToNextDriver

NTSTATUS
IdePortDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_DEVICE_CONTROL

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/
{
    PDEVICE_EXTENSION_HEADER DoExtensionHeader;
    NTSTATUS status;

    DoExtensionHeader = DeviceObject->DeviceExtension;

    if (IS_PDO(DoExtensionHeader)) {

        //
        // PDO
        //
        status = DeviceDeviceIoControl (
            DeviceObject,
            Irp
            );

    } else {

        //
        // FDO
        //
        status = IdePortDeviceControl (
            DeviceObject,
            Irp
            );
    }

    return status;
} // IdePortDispatchDeviceControl

NTSTATUS
IdePortDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_POWER

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION       thisIrpSp;
    NTSTATUS                 status;
    PDEVICE_EXTENSION_HEADER doExtension;
    BOOLEAN                  pendingIrp;

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //
    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    DebugPrint ((DBG_POWER,
                 "IdePort: 0x%x %s %d got %s[%d, %d]\n",
                 doExtension->AttacheeDeviceObject ?
                     ((PFDO_EXTENSION) doExtension)->IdeResource.TranslatedCommandBaseAddress :
                     ((PPDO_EXTENSION) doExtension)->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                 doExtension->AttacheeDeviceObject ? "FDO" : "PDO",
                 doExtension->AttacheeDeviceObject ? 0 :
                    ((PPDO_EXTENSION) doExtension)->TargetId,
                 IdeDebugPowerIrpName[thisIrpSp->MinorFunction],
				 thisIrpSp->Parameters.Power.Type,
				 thisIrpSp->Parameters.Power.State
				 ));

    if (thisIrpSp->MinorFunction < NUM_POWER_MINOR_FUNCTION) {

        status = doExtension->PowerDispatchTable[thisIrpSp->MinorFunction] (DeviceObject, Irp);
    } else {

        DebugPrint ((DBG_WARNING,
					 "ATAPI: Power Dispatch Table too small\n"
					 ));

		status = doExtension->DefaultDispatch(DeviceObject, Irp);
    }

    return status;
} // IdePortDispatchPower


NTSTATUS
IdePortDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_PNP_POWER IRPs

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION thisIrpSp;
    NTSTATUS status;
    PDEVICE_EXTENSION_HEADER doExtension;

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //
    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    DebugPrint ((DBG_PNP,
                 "IdePort: 0x%x %s %d got %s\n",
                 doExtension->AttacheeDeviceObject ?
                     ((PFDO_EXTENSION) doExtension)->IdeResource.TranslatedCommandBaseAddress :
                     ((PPDO_EXTENSION) doExtension)->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                 doExtension->AttacheeDeviceObject ? "FDO" : "PDO",
                 doExtension->AttacheeDeviceObject ? 0 :
                    ((PPDO_EXTENSION) doExtension)->TargetId,
                 IdeDebugPnpIrpName[thisIrpSp->MinorFunction]));

    if (thisIrpSp->MinorFunction < NUM_PNP_MINOR_FUNCTION) {

        status = doExtension->PnPDispatchTable[thisIrpSp->MinorFunction] (DeviceObject, Irp);

    } else {

        if (thisIrpSp->MinorFunction != 0xff) {

            ASSERT (!"ATAPI: PnP Dispatch Table too small\n");
        }

        status = doExtension->DefaultDispatch (DeviceObject, Irp);
    }

    return status;
} // IdePortDispatchPnp

NTSTATUS
IdePortDispatchSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL (WMI) IRPs

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION thisIrpSp;
    NTSTATUS status;
    PDEVICE_EXTENSION_HEADER doExtension;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    DebugPrint ((DBG_WMI,
                 "IdePort: 0x%x %s %d got %s\n",
                 doExtension->AttacheeDeviceObject ?
                     ((PFDO_EXTENSION) doExtension)->IdeResource.TranslatedCommandBaseAddress :
                     ((PPDO_EXTENSION) doExtension)->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                 doExtension->AttacheeDeviceObject ? "FDO" : "PDO",
                 doExtension->AttacheeDeviceObject ? 0 :
                    ((PPDO_EXTENSION) doExtension)->TargetId,
                 IdeDebugWmiIrpName[thisIrpSp->MinorFunction]));

    if (thisIrpSp->MinorFunction < NUM_WMI_MINOR_FUNCTION) {

        status = doExtension->WmiDispatchTable[thisIrpSp->MinorFunction] (DeviceObject, Irp);

    } else {

        DebugPrint((DBG_WARNING,
					"ATAPI: WMI Dispatch Table too small\n"
					));

        status = doExtension->DefaultDispatch (DeviceObject, Irp);
    }

    return status;
} // IdePortDispatchSystemControl

ULONG
DriverEntry(
    IN OUT PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Entry point to this driver

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/
{
    NTSTATUS                status;
    PIDEDRIVER_EXTENSION    ideDriverExtension;
    ULONG                   i;

#if DBG
    //
    // checking IDE_COMMAND_BLOCK_WRITE_REGISTERS structure and its macros
    //

    {
        IDE_COMMAND_BLOCK_WRITE_REGISTERS baseIoAddress1;
        IDE_REGISTERS_2 baseIoAddress2;
        ULONG           baseIoAddress1Length;
        ULONG           baseIoAddress2Length;
        ULONG           maxIdeDevice;
        ULONG           maxIdeTargetId;

        AtapiBuildIoAddress (0,
                             0,
                             (PIDE_REGISTERS_1)&baseIoAddress1,
                             &baseIoAddress2,
                             &baseIoAddress1Length,
                             &baseIoAddress2Length,
                             &maxIdeDevice,
                             &maxIdeTargetId);

        ASSERT (ATA_DATA16_REG       (&baseIoAddress1) == 0);
        ASSERT (ATA_ERROR_REG        (&baseIoAddress1) == (PUCHAR)1);
        ASSERT (ATA_SECTOR_COUNT_REG (&baseIoAddress1) == (PUCHAR)2);
        ASSERT (ATA_SECTOR_NUMBER_REG(&baseIoAddress1) == (PUCHAR)3);
        ASSERT (ATA_CYLINDER_LOW_REG (&baseIoAddress1) == (PUCHAR)4);
        ASSERT (ATA_CYLINDER_HIGH_REG(&baseIoAddress1) == (PUCHAR)5);
        ASSERT (ATA_DRIVE_SELECT_REG (&baseIoAddress1) == (PUCHAR)6);
        ASSERT (ATA_STATUS_REG       (&baseIoAddress1) == (PUCHAR)7);

        ASSERT (ATA_FEATURE_REG      (&baseIoAddress1) == (PUCHAR)1);
        ASSERT (ATA_COMMAND_REG      (&baseIoAddress1) == (PUCHAR)7);

        ASSERT (ATAPI_DATA16_REG            (&baseIoAddress1) == 0);
        ASSERT (ATAPI_ERROR_REG             (&baseIoAddress1) == (PUCHAR)1);
        ASSERT (ATAPI_INTERRUPT_REASON_REG  (&baseIoAddress1) == (PUCHAR)2);
        ASSERT (ATAPI_BYTECOUNT_LOW_REG     (&baseIoAddress1) == (PUCHAR)4);
        ASSERT (ATAPI_BYTECOUNT_HIGH_REG    (&baseIoAddress1) == (PUCHAR)5);
        ASSERT (ATAPI_DRIVE_SELECT_REG      (&baseIoAddress1) == (PUCHAR)6);
        ASSERT (ATAPI_STATUS_REG            (&baseIoAddress1) == (PUCHAR)7);

        ASSERT (ATAPI_FEATURE_REG           (&baseIoAddress1) == (PUCHAR)1);
        ASSERT (ATAPI_COMMAND_REG           (&baseIoAddress1) == (PUCHAR)7);

        ASSERT (baseIoAddress1Length == 8);
        ASSERT (baseIoAddress2Length == 1);
        ASSERT (maxIdeDevice        == 2);

        if (IsNEC_98) {

            AtapiBuildIoAddress ((PUCHAR)0x640,
                                 (PUCHAR) 0x74C,
                                 (PIDE_REGISTERS_1)&baseIoAddress1,
                                 &baseIoAddress2,
                                 &baseIoAddress1Length,
                                 &baseIoAddress2Length,
                                 &maxIdeDevice,
                                 &maxIdeTargetId);

            ASSERT (ATA_DATA16_REG       (&baseIoAddress1) == (PUSHORT)0x640);
            ASSERT (ATA_ERROR_REG        (&baseIoAddress1) == (PUCHAR)0x642);
            ASSERT (ATA_SECTOR_COUNT_REG (&baseIoAddress1) == (PUCHAR)0x644);
            ASSERT (ATA_SECTOR_NUMBER_REG(&baseIoAddress1) == (PUCHAR)0x646);
            ASSERT (ATA_CYLINDER_LOW_REG (&baseIoAddress1) == (PUCHAR)0x648);
            ASSERT (ATA_CYLINDER_HIGH_REG(&baseIoAddress1) == (PUCHAR)0x64a);
            ASSERT (ATA_DRIVE_SELECT_REG (&baseIoAddress1) == (PUCHAR)0x64c);
            ASSERT (ATA_STATUS_REG       (&baseIoAddress1) == (PUCHAR)0x64e);

            ASSERT (ATA_FEATURE_REG      (&baseIoAddress1) == (PUCHAR)0x642);
            ASSERT (ATA_COMMAND_REG      (&baseIoAddress1) == (PUCHAR)0x64e);

            ASSERT (ATAPI_DATA16_REG            (&baseIoAddress1) == (PUSHORT)0x640);
            ASSERT (ATAPI_ERROR_REG             (&baseIoAddress1) == (PUCHAR)0x642);
            ASSERT (ATAPI_INTERRUPT_REASON_REG  (&baseIoAddress1) == (PUCHAR)0x644);
            ASSERT (ATAPI_BYTECOUNT_LOW_REG     (&baseIoAddress1) == (PUCHAR)0x648);
            ASSERT (ATAPI_BYTECOUNT_HIGH_REG    (&baseIoAddress1) == (PUCHAR)0x64a);
            ASSERT (ATAPI_DRIVE_SELECT_REG      (&baseIoAddress1) == (PUCHAR)0x64c);
            ASSERT (ATAPI_STATUS_REG            (&baseIoAddress1) == (PUCHAR)0x64e);

            ASSERT (ATAPI_FEATURE_REG           (&baseIoAddress1) == (PUCHAR)0x642);
            ASSERT (ATAPI_COMMAND_REG           (&baseIoAddress1) == (PUCHAR)0x64e);

            ASSERT (baseIoAddress1Length == 1);
            ASSERT (baseIoAddress2Length == 1);
            ASSERT (maxIdeDevice        == 4);

        }
    }
#endif //DBG

    if (!DriverObject) {

        //
        // We are called by crashdump or po
        //

        return AtapiCrashDumpDriverEntry (RegistryPath);
    }

    //
    // Allocate Driver Object Extension for storing
    // the RegistryPath
    //
    status = IoAllocateDriverObjectExtension(
                 DriverObject,
                 DRIVER_OBJECT_EXTENSION_ID,
                 sizeof (DRIVER_EXTENSION),
                 &ideDriverExtension
                 );

    if (!NT_SUCCESS(status)) {

        DebugPrint ((0, "IdePort: Unable to create driver extension\n"));
        return status;
    }

    ASSERT(ideDriverExtension);

    RtlZeroMemory (
        ideDriverExtension,
        sizeof (DRIVER_EXTENSION)
        );

    //
    // make copy of the RegistryPath
    //
    ideDriverExtension->RegistryPath.Buffer = ExAllocatePool (NonPagedPool, RegistryPath->Length * sizeof(WCHAR));
    if (ideDriverExtension->RegistryPath.Buffer == NULL) {

        DebugPrint ((0, "IdePort: Unable to allocate memory for registry path\n"));

        return (ULONG) STATUS_INSUFFICIENT_RESOURCES;
    }

    ideDriverExtension->RegistryPath.Length = 0;
    ideDriverExtension->RegistryPath.MaximumLength = RegistryPath->Length;
    RtlCopyUnicodeString (&ideDriverExtension->RegistryPath, RegistryPath);

    //
    // The PnP thing to do
    //
    DriverObject->DriverExtension->AddDevice    = ChannelAddDevice;

    //
    // Set up the device driver entry points.
    //
    DriverObject->DriverStartIo = IdePortStartIo;
    DriverObject->DriverUnload  = IdePortUnload;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = IdePortDispatch;
    DriverObject->MajorFunction[IRP_MJ_SCSI]                    = IdePortDispatch;
    DriverObject->MajorFunction[IRP_MJ_CREATE]                  = IdePortAlwaysStatusSuccessIrp;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = IdePortAlwaysStatusSuccessIrp;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          = IdePortDispatchDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_POWER]                   = IdePortDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = IdePortDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]          = IdePortDispatchSystemControl;

    //
    // FDO PnP Dispatch Table
    //
    for (i=0; i<NUM_PNP_MINOR_FUNCTION; i++) {

        FdoPnpDispatchTable[i] = IdePortPassDownToNextDriver;
    }
    FdoPnpDispatchTable[IRP_MN_START_DEVICE               ] = ChannelStartDevice;
    FdoPnpDispatchTable[IRP_MN_QUERY_REMOVE_DEVICE        ] = IdePortStatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_CANCEL_REMOVE_DEVICE       ] = IdePortStatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_REMOVE_DEVICE              ] = ChannelRemoveDevice;
    FdoPnpDispatchTable[IRP_MN_QUERY_STOP_DEVICE          ] = IdePortStatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_CANCEL_STOP_DEVICE         ] = IdePortStatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_STOP_DEVICE                ] = ChannelStopDevice;
    FdoPnpDispatchTable[IRP_MN_QUERY_DEVICE_RELATIONS     ] = ChannelQueryDeviceRelations;
    FdoPnpDispatchTable[IRP_MN_QUERY_ID                   ] = ChannelQueryId;
    FdoPnpDispatchTable[IRP_MN_DEVICE_USAGE_NOTIFICATION  ] = ChannelUsageNotification;
    FdoPnpDispatchTable[IRP_MN_FILTER_RESOURCE_REQUIREMENTS] = ChannelFilterResourceRequirements;
    FdoPnpDispatchTable[IRP_MN_QUERY_PNP_DEVICE_STATE     ] = ChannelQueryPnPDeviceState;
    FdoPnpDispatchTable[IRP_MN_SURPRISE_REMOVAL           ] = ChannelSurpriseRemoveDevice;

    //
    // PDO PnP Dispatch Table
    //
    for (i=0; i<NUM_PNP_MINOR_FUNCTION; i++) {

        PdoPnpDispatchTable[i] = IdePortNoSupportIrp;
    }
    PdoPnpDispatchTable[IRP_MN_START_DEVICE               ] = DeviceStartDevice;
    PdoPnpDispatchTable[IRP_MN_QUERY_DEVICE_RELATIONS     ] = DeviceQueryDeviceRelations;
    PdoPnpDispatchTable[IRP_MN_QUERY_REMOVE_DEVICE        ] = DeviceQueryStopRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_REMOVE_DEVICE              ] = DeviceRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_CANCEL_REMOVE_DEVICE       ] = IdePortAlwaysStatusSuccessIrp;
    PdoPnpDispatchTable[IRP_MN_STOP_DEVICE                ] = DeviceStopDevice;
    PdoPnpDispatchTable[IRP_MN_QUERY_STOP_DEVICE          ] = DeviceQueryStopRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_CANCEL_STOP_DEVICE         ] = IdePortAlwaysStatusSuccessIrp;
    PdoPnpDispatchTable[IRP_MN_QUERY_ID                   ] = DeviceQueryId;
    PdoPnpDispatchTable[IRP_MN_QUERY_CAPABILITIES         ] = DeviceQueryCapabilities;
    PdoPnpDispatchTable[IRP_MN_QUERY_DEVICE_TEXT          ] = DeviceQueryText;
    PdoPnpDispatchTable[IRP_MN_DEVICE_USAGE_NOTIFICATION  ] = DeviceUsageNotification;
    PdoPnpDispatchTable[IRP_MN_QUERY_PNP_DEVICE_STATE     ] = DeviceQueryPnPDeviceState;
    PdoPnpDispatchTable[IRP_MN_SURPRISE_REMOVAL           ] = DeviceRemoveDevice;

    //
    // FDO Power Dispatch Table
    //
    for (i=0; i<NUM_POWER_MINOR_FUNCTION; i++) {

        FdoPowerDispatchTable[i] = IdePortPassDownToNextDriver;
    }
    FdoPowerDispatchTable[IRP_MN_SET_POWER]   = IdePortSetFdoPowerState;
    FdoPowerDispatchTable[IRP_MN_QUERY_POWER] = ChannelQueryPowerState;


    //
    // PDO Power Dispatch Table
    //
    for (i=0; i<NUM_POWER_MINOR_FUNCTION; i++) {

        PdoPowerDispatchTable[i] = IdePortNoSupportIrp;
    }
    PdoPowerDispatchTable[IRP_MN_SET_POWER]   = IdePortSetPdoPowerState;
    PdoPowerDispatchTable[IRP_MN_QUERY_POWER] = DeviceQueryPowerState;

    //
    // FDO WMI Dispatch Table
    //
    for (i=0; i<NUM_WMI_MINOR_FUNCTION; i++) {

        FdoWmiDispatchTable[i] = IdePortPassDownToNextDriver;
    }

    //
    // PDO WMI Dispatch Table
    //
    for (i=0; i<NUM_WMI_MINOR_FUNCTION; i++) {

#if defined (IDEPORT_WMI_SUPPORT)
        PdoWmiDispatchTable[i] = IdePortWmiSystemControl;
#else
        PdoWmiDispatchTable[i] = IdePortNoSupportIrp;
#endif // IDEPORT_WMI_SUPPORT
    }

#if defined (IDEPORT_WMI_SUPPORT)
    //
    // Init WMI related stuff
    //
    IdePortWmiInit ();
#endif // IDEPORT_WMI_SUPPORT

    //
    // Create device object name directory
    //
    IdeCreateIdeDirectory();

    //
    // Detect legacy (non-enumerable) IDE devices
    //
#if !defined(NO_LEGACY_DRIVERS)
    IdePortDetectLegacyController (
        DriverObject,
        RegistryPath
        );
#endif // NO_LEGACY_DRIVERS

    return STATUS_SUCCESS;
} // DriverEntry


#ifdef DRIVER_PARAMETER_REGISTRY_SUPPORT

HANDLE
IdePortOpenServiceSubKey (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  SubKeyPath
)
/*++

Routine Description:

    Open a registry key

Arguments:

    DriverObject - this driver driver object

    SubKeyPath - registry key to open

Return Value:

    handle to the registry key

--*/
{
    PIDEDRIVER_EXTENSION ideDriverExtension;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE serviceKey;
    HANDLE subServiceKey;
    NTSTATUS status;

    ideDriverExtension = IoGetDriverObjectExtension(
                             DriverObject,
                             DRIVER_OBJECT_EXTENSION_ID
                             );

    if (!ideDriverExtension) {

        return NULL;
    }

    InitializeObjectAttributes(&objectAttributes,
                               &ideDriverExtension->RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&serviceKey,
                       KEY_READ,
                       &objectAttributes);

    if (!NT_SUCCESS(status)) {

        return NULL;
    }

    InitializeObjectAttributes(&objectAttributes,
                               SubKeyPath,
                               OBJ_CASE_INSENSITIVE,
                               serviceKey,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&subServiceKey,
                       KEY_READ,
                       &objectAttributes);


    ZwClose(serviceKey);

    if (NT_SUCCESS(status)) {

        return subServiceKey;
    } else {

        return NULL;
    }
} // IdePortOpenServiceSubKey

VOID
IdePortCloseServiceSubKey (
    IN HANDLE  SubServiceKey
)
/*++

Routine Description:

    close a registry key handle

Arguments:

    SubServiceKey - registry key to close

Return Value:

    None

--*/
{
    ZwClose(SubServiceKey);
} // IdePortCloseServiceSubKey

VOID
IdePortParseDeviceParameters(
    IN     HANDLE                   SubServiceKey,
    IN OUT PCUSTOM_DEVICE_PARAMETER CustomDeviceParameter
    )
/*++

Routine Description:

    This routine parses a device key node and updates the CustomDeviceParameter

Arguments:

    SubServiceKey - Supplies an open key to the device node.

    CustomDeviceParameter - Supplies the configuration information to be initialized.

Return Value:

    None

--*/

{
    UCHAR                           keyValueInformationBuffer[SP_REG_BUFFER_SIZE];
    PKEY_VALUE_FULL_INFORMATION     keyValueInformation;
    ULONG                           length;
    ULONG                           index;
    UNICODE_STRING                  unicodeString;
    ANSI_STRING                     ansiString;
    NTSTATUS                        status;

    //
    // Look at each of the values in the device node.
    //
    index = 0;

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) keyValueInformationBuffer;

    while (NT_SUCCESS (ZwEnumerateValueKey(
                           SubServiceKey,
                           index,
                           KeyValueFullInformation,
                           keyValueInformation,
                           SP_REG_BUFFER_SIZE,
                           &length))) {

        //
        // Update the index for the next time around the loop.
        //

        index++;

        //
        // Check that the length is reasonable.
        //

        if (keyValueInformation->Type == REG_DWORD &&
            keyValueInformation->DataLength != sizeof(ULONG)) {

            continue;
        }

        //
        // Check for a maximum lu number.
        //
        if (_wcsnicmp(keyValueInformation->Name, L"ScsiDebug",
            keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->Type != REG_DWORD) {

                DebugPrint((1, "IdeParseDevice:  Bad data type for ScsiDebug.\n"));
                continue;
            }
#if DBG
            ScsiDebug = *((PULONG) (keyValueInformationBuffer + keyValueInformation->DataOffset));
#endif
        }

        //
        // Check for driver parameters tranfers.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"DriverParameters",
            keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->DataLength == 0) {
                continue;
            }

            if (keyValueInformation->Type == REG_SZ) {

                //
                // This is a unicode string. Convert it to a ANSI string.
                // Initialize the strings.
                //

                unicodeString.Buffer = (PWSTR) ((PCCHAR) keyValueInformation +
                    keyValueInformation->DataOffset);
                unicodeString.Length = (USHORT) keyValueInformation->DataLength;
                unicodeString.MaximumLength = (USHORT) keyValueInformation->DataLength;

                status = RtlUnicodeStringToAnsiString(
                    &ansiString,
                    &unicodeString,
                    TRUE
                    );

                if (NT_SUCCESS(status)) {

                    CustomDeviceParameter->CommandRegisterBase =
                        AtapiParseArgumentString(ansiString.Buffer, "BaseAddress");

                    if (CustomDeviceParameter->CommandRegisterBase) {

                        CustomDeviceParameter->IrqLevel =
                            AtapiParseArgumentString(ansiString.Buffer, "Interrupt");
                    }

                    RtlFreeAnsiString (&ansiString);
                }
            }

            DebugPrint((2, "IdeParseDeviceParameters: Found driver parameter.\n"));
        }
    }

    return;

} // IdePortParseDeviceParameters

#endif // DRIVER_PARAMETER_REGISTRY_SUPPORT

#pragma data_seg ("PAGEDATA")
//
// device description table
// index by SCSI device type
//
const static IDE_DEVICE_TYPE IdeDeviceType[] = {
    {"Disk",       "GenDisk",       "DiskPeripheral"            },
    {"Sequential", "GenSequential", "TapePeripheral"            },
    {"Printer",    "GenPrinter",    "PrinterPeripheral"         },
    {"Processor",  "GenProcessor",  "ProcessorPeripheral"       },
    {"Worm",       "GenWorm",       "WormPeripheral"            },
    {"CdRom",      "GenCdRom",      "CdRomPeripheral"           },
    {"Scanner",    "GenScanner",    "ScannerPeripheral"         },
    {"Optical",    "GenOptical",    "OpticalDiskPeripheral"     },
    {"Changer",    "GenChanger",    "MediumChangerPeripheral"   },
    {"Net",        "GenNet",        "CommunicationPeripheral"   }
};
#pragma data_seg ()

PCSTR
IdePortGetDeviceTypeString (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up SCSI device type string

Arguments:

    DeviceType - SCSI device type

Return Value:

    device type string

--*/
{
    if (DeviceType < (sizeof (IdeDeviceType) / sizeof (IDE_DEVICE_TYPE))) {

        return IdeDeviceType[DeviceType].DeviceTypeString;

    } else {

        return NULL;
    }

} // IdePortGetDeviceTypeString

PCSTR
IdePortGetCompatibleIdString (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up compatible ID string

Arguments:

    DeviceType - SCSI device type

Return Value:

    compatible ID string

--*/
{
    if (DeviceType < (sizeof (IdeDeviceType) / sizeof (IDE_DEVICE_TYPE))) {

        return IdeDeviceType[DeviceType].CompatibleIdString;

    } else {

        return NULL;
    }
} // IdePortGetCompatibleIdString

PCSTR
IdePortGetPeripheralIdString (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up peripheral ID string

Arguments:

    DeviceType - SCSI device type

Return Value:

    Peripheral ID string

--*/
{
    if (DeviceType < (sizeof (IdeDeviceType) / sizeof (IDE_DEVICE_TYPE))) {

        return IdeDeviceType[DeviceType].PeripheralIdString;

    } else {

        return NULL;
    }
} // IdePortGetPeripheralIdString


VOID
IdePortUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    get ready to be unloaded

Arguments:

    DriverObject - the driver being unloaded

Return Value:

    none

--*/

{
    PIDEDRIVER_EXTENSION ideDriverExtension;

    DebugPrint ((1, "IdePort: unloading...\n"));

    ASSERT (DriverObject->DeviceObject == NULL);

    ideDriverExtension = IoGetDriverObjectExtension(
                             DriverObject,
                             DRIVER_OBJECT_EXTENSION_ID
                             );
    if (ideDriverExtension->RegistryPath.Buffer != NULL) {

        ExFreePool (ideDriverExtension->RegistryPath.Buffer);
    }

    return;
} // IdePortUnload

BOOLEAN
IdePortOkToDetectLegacy (
    IN PDRIVER_OBJECT DriverObject
)
{
    NTSTATUS          status;
    OBJECT_ATTRIBUTES attributes;
    HANDLE            regHandle;
    UNICODE_STRING    pathRoot;
    ULONG             legacyDetection;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];

    RtlInitUnicodeString (&pathRoot, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Pnp");
    InitializeObjectAttributes(&attributes,
                               &pathRoot,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR)NULL
                               );
    status = ZwOpenKey(&regHandle,
                       KEY_READ,
                       &attributes
                       );
    if (NT_SUCCESS(status)) {

        ULONG parameterValue = 0;

        RtlZeroMemory(&queryTable, sizeof(queryTable));

        queryTable->QueryRoutine  = NULL;
        queryTable->Flags         = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND | RTL_QUERY_REGISTRY_DIRECT;
        queryTable->Name          = L"DisableFirmwareMapper";
        queryTable->EntryContext  = &parameterValue;
        queryTable->DefaultType   = REG_DWORD;
        queryTable->DefaultData   = &parameterValue;
        queryTable->DefaultLength = sizeof (parameterValue);

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) regHandle,
                                        queryTable,
                                        NULL,
                                        NULL);
        ZwClose (regHandle);

        if (parameterValue) {

            //
            // Cool.  no need to detect legacy controller
            //
            return FALSE;
        }
    }

    status = IdePortGetParameterFromServiceSubKey (
                 DriverObject,
                 LEGACY_DETECTION,
                 REG_DWORD,
                 TRUE,
                 (PVOID) &legacyDetection,
                 0
                 );
    if (NT_SUCCESS(status)) {

        if (legacyDetection) {

            legacyDetection = 0;

            //
            // disable legacy detection for next boot
            //
            IdePortGetParameterFromServiceSubKey (
                DriverObject,
                LEGACY_DETECTION,
                REG_DWORD,
                FALSE,
                (PVOID) &legacyDetection,
                sizeof (legacyDetection)
                );

            return TRUE;

        } else {

            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
IdePortSearchDeviceInRegMultiSzList (
    IN PFDO_EXTENSION  FdoExtension,
    IN PIDENTIFY_DATA  IdentifyData,
    IN PWSTR           RegKeyValue
)
{
    PWSTR           string;
    UNICODE_STRING  unicodeString;

    BOOLEAN         foundIt;

    NTSTATUS        status;

    PWSTR           regDeviceList;

    ANSI_STRING     ansiTargetDeviceId;
    UNICODE_STRING  unicodeTargetDeviceId;
    PUCHAR          targetDeviceId;
    ULONG           i;
    ULONG           j;

    PAGED_CODE();

    ASSERT (IdentifyData);
    ASSERT (RegKeyValue);

    foundIt = FALSE;

    status = IdePortGetParameterFromServiceSubKey (
                        FdoExtension->DriverObject,
                        RegKeyValue,
                        REG_MULTI_SZ,
                        TRUE,
                        &regDeviceList,
                        0
                        );

    if (NT_SUCCESS(status) && regDeviceList) {

        targetDeviceId = ExAllocatePool (
                             PagedPool,
                             sizeof(IdentifyData->ModelNumber) +
                             sizeof(IdentifyData->FirmwareRevision) +
                             sizeof('\0')
                             );

        if (targetDeviceId) {

            for (i=0; i<sizeof(IdentifyData->ModelNumber); i+=2) {

                targetDeviceId[i + 0] = IdentifyData->ModelNumber[i + 1];
                targetDeviceId[i + 1] = IdentifyData->ModelNumber[i + 0];

                if (targetDeviceId[i + 0] == '\0') {

                    targetDeviceId[i + 0] = ' ';
                }
                if (targetDeviceId[i + 1] == '\0') {

                    targetDeviceId[i + 1] = ' ';
                }
            }
            for (j=0; j<sizeof(IdentifyData->FirmwareRevision); j+=2) {

                targetDeviceId[i + j + 0] = IdentifyData->FirmwareRevision[j + 1];
                targetDeviceId[i + j + 1] = IdentifyData->FirmwareRevision[j + 0];

                if (targetDeviceId[i + j + 0] == '\0') {

                    targetDeviceId[i + j + 0] = ' ';
                }
                if (targetDeviceId[i + j + 1] == '\0') {

                    targetDeviceId[i + j + 1] = ' ';
                }
            }
            targetDeviceId[i + j] = 0;

            RtlInitAnsiString(
                &ansiTargetDeviceId,
                targetDeviceId
                );

            status = RtlAnsiStringToUnicodeString(
                         &unicodeTargetDeviceId,
                         &ansiTargetDeviceId,
                         TRUE
                         );

            if (NT_SUCCESS(status)) {

                string = regDeviceList;

                DebugPrint ((DBG_REG_SEARCH, "IdePort: searching for %s in list\n", targetDeviceId));

                while (string[0]) {

                    ULONG length;

                    DebugPrint ((DBG_REG_SEARCH, "IdePort: device list: %ws\n", string));

                    RtlInitUnicodeString(
                        &unicodeString,
                        string
                        );

                    //
                    // compare up to the length of the shorter string
                    //
                    if (unicodeTargetDeviceId.Length < unicodeString.Length) {

                        length = unicodeTargetDeviceId.Length;
                    } else {

                        length = unicodeString.Length;
                    }

                    if (length == RtlCompareMemory(unicodeTargetDeviceId.Buffer, unicodeString.Buffer, length)) {

                        DebugPrint ((DBG_REG_SEARCH, "IdePort: Found a target device on the device list. %ws\n", string));
                        foundIt = TRUE;
                        break;

                    } else {

                        string += (unicodeString.Length / sizeof(WCHAR)) + 1;
                    }
                }

                RtlFreeUnicodeString (
                    &unicodeTargetDeviceId
                    );

            } else {

                ASSERT (FALSE);
            }

            ExFreePool(targetDeviceId);
        }

        ExFreePool(regDeviceList);
    }

    return foundIt;
}

NTSTATUS
IdePortSyncSendIrp (
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT OPTIONAL PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION  newIrpSp;
    PIRP                newIrp;
    KEVENT              event;
    NTSTATUS            status;

    ASSERT (TargetDeviceObject);
    ASSERT (IrpSp);

    //
    // Allocate an IRP for below
    //
    newIrp = IoAllocateIrp (TargetDeviceObject->StackSize, FALSE);      // Get stack size from PDO
    if (newIrp == NULL) {

        DebugPrint ((DBG_ALWAYS, "IdePortSyncSendIrp: Unable to get allocate an irp"));
        return STATUS_NO_MEMORY;
    }

    newIrpSp = IoGetNextIrpStackLocation(newIrp);
    RtlMoveMemory (newIrpSp, IrpSp, sizeof (*IrpSp));

    if (IoStatus) {

        newIrp->IoStatus.Status = IoStatus->Status;
    } else {

        newIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    }

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    IoSetCompletionRoutine (
        newIrp,
        IdePortGenericCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE);
    status = IoCallDriver (TargetDeviceObject, newIrp);

    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject(&event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
    }
    status = newIrp->IoStatus.Status;

    if (IoStatus) {

        *IoStatus = newIrp->IoStatus;
    }

    IoFreeIrp (newIrp);
    return status;
}

NTSTATUS
IdePortGenericCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PKEVENT event = Context;

    KeSetEvent(
        event,
        EVENT_INCREMENT,
        FALSE
        );

    return STATUS_MORE_PROCESSING_REQUIRED;
} // IdePortSyncSendIrpCompletionRoutine


ULONG
IdePortSimpleCheckSum (
    IN ULONG                PartialSum,
    IN PVOID                SourceVa,
    IN ULONG                Length
    )
/*++

Routine Description:

    Computes a checksum for the supplied virtual address and length

    This function comes from Dr. Dobbs Journal, May 1992

Arguments:

    PartialSum  - The previous partial checksum

    SourceVa    - Starting address

    Length      - Length, in bytes, of the range

Return Value:

    The checksum value

--*/
{
    PUSHORT     Source;

    Source = (PUSHORT) SourceVa;
    Length = Length / 2;

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xFFFF);
    }

    return PartialSum;
}


BOOLEAN
IdePortInSetup(
    IN PFDO_EXTENSION FdoExtension
    )
/*++
--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING keyName;
    HANDLE hKey;
    ULONG systemSetupInProgress = 0;
    NTSTATUS status;
    BOOLEAN textmodeSetup = TRUE;

    PAGED_CODE();

    RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\setupdd");

    InitializeObjectAttributes(&objectAttributes,
                               &keyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&hKey,
                       KEY_READ,
                       &objectAttributes);

    if (!NT_SUCCESS(status)) {

        textmodeSetup = FALSE;

    } else {

        ZwClose(hKey);
    }

    RtlInitUnicodeString(&keyName,L"\\Registry\\Machine\\System\\setup");

    InitializeObjectAttributes(&objectAttributes,
                               &keyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&hKey,
                       KEY_READ,
                       &objectAttributes);

    if (NT_SUCCESS(status)) {

        //
        // Query the data for the key value.
        //

        RTL_QUERY_REGISTRY_TABLE queryTable[2];

        systemSetupInProgress = 0;

        RtlZeroMemory(&queryTable, sizeof(queryTable));

        queryTable->QueryRoutine  = NULL;
        queryTable->Flags         = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND | RTL_QUERY_REGISTRY_DIRECT;
        queryTable->Name          = L"SystemSetupInProgress";
        queryTable->EntryContext  = &systemSetupInProgress;
        queryTable->DefaultType   = REG_DWORD;
        queryTable->DefaultData   = &systemSetupInProgress;
        queryTable->DefaultLength = sizeof (systemSetupInProgress);

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) hKey,
                                        queryTable,
                                        NULL,
                                        NULL);

        ZwClose (hKey);

    }

    return (textmodeSetup || systemSetupInProgress);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\ideport.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ideport.h
//
//--------------------------------------------------------------------------

#if !defined (___IDEPORT_H___)
#define ___IDEPORT_H___

#include "stddef.h"
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntddk.h"
#include "scsi.h"
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <string.h>
#include "stdio.h"
#include "safeboot.h"

#ifdef ACPI_CONTROL_METHOD_SUPPORT
//
// for ACPI
//
#include "acpiioct.h"
#endif // ACPI_CONTROL_METHOD_SUPPORT

#include "idep.h"

//
// predefine structure pointer type to prevent 
// constant re-ordering of include files
//              
typedef struct _FDO_EXTENSION * PFDO_EXTENSION;
typedef struct _PDO_EXTENSION * PPDO_EXTENSION;
typedef struct _DEVICE_SETTINGS * PDEVICE_SETTINGS;
typedef struct _IDENTIFY_DATA * PIDENTIFY_DATA;
typedef struct _IDE_DEVICE_TYPE IDE_DEVICE_TYPE;

#include "acpiutil.h"
#include "hack.h"
#include "port.h"
#include "init.h"
#include "chanfdo.h"
#include "detect.h"
#include "atapi.h"
#include "devpdo.h"
#include "regutils.h"
#include "atapinit.h"
#include "luext.h"
#include "fdopower.h"
#include "pdopower.h"
#include "crashdmp.h"
#include "idedata.h"
#include "wmi.h"

//
// Location Identifiers used to log allocation failures
//
#define IDEPORT_TAG_DISPATCH_FLUSH          0x10
#define IDEPORT_TAG_DISPATCH_RESET          0x20
#define IDEPORT_TAG_STARTIO_MDL             0x30
#define IDEPORT_TAG_MPIOCTL_IRP             0x40
#define IDEPORT_TAG_PASSTHRU_SENSE          0x50
#define IDEPORT_TAG_PASSTHRU_IRP            0x60
#define IDEPORT_TAG_DUMP_POINTER            0x70
#define IDEPORT_TAG_READCAP_CONTEXT         0x80
#define IDEPORT_TAG_READCAP_MDL             0x90
#define IDEPORT_TAG_SYNCATAPI_IRP           0x100 //+0xff - IDE commands
#define IDEPORT_TAG_SYNCATAPI_SENSE         0x110
#define IDEPORT_TAG_ATAPASS_IRP             0x200
#define IDEPORT_TAG_ATAPASS_MDL             0x300
#define IDEPORT_TAG_ATAPASS_SRB             0x400
#define IDEPORT_TAG_ATAPASS_SENSE           0x500
#define IDEPORT_TAG_ATAPASS_CONTEXT         0x600
#define IDEPORT_TAG_ATAPI_MODE_SENSE        0x700
#define IDEPORT_TAG_SEND_IRP                0x800

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'PedI')
#endif

#define INLINE __inline

#if DBG

void _DebugPrintTickCount (LARGE_INTEGER * lastTickCount, ULONG limit, PUCHAR filename, ULONG lineNumber);
void _DebugPrintResetTickCount(LARGE_INTEGER * lastTickCount);


static LARGE_INTEGER FindDeviceTimer = {0, 0};

#define DebugPrintTickCount(lastTickCount, limit)     _DebugPrintTickCount (&lastTickCount, limit, __FILE__, __LINE__)
#define DebugPrintResetTickCount(lastTickCount)       { lastTickCount.QuadPart = 0; _DebugPrintResetTickCount(&lastTickCount); }

#else

#define DebugPrintTickCount(lastTickCount, limit)
#define DebugPrintResetTickCount(lastTickCount)

#endif

#if 0
extern PVOID GlobalPdoPtr;

#if DBG

#ifdef IoCompleteRequest
#undef IoCompleteRequest
#endif

#define IoCompleteRequest(irp, boost) {\
                ULONG i; \
                PPDO_EXTENSION globalPdoExtension=(PPDO_EXTENSION)GlobalPdoPtr;\
                if (globalPdoExtension) {\
                    for (i=0;i<globalPdoExtension->NumTagUsed;i++) {\
                        if (globalPdoExtension->TagTable[i]==irp) {\
                            DebugPrint((0, "Irp %x failed\n", irp));\
                            ASSERT(FALSE);\
                        }\
                    }\
                }\
                IofCompleteRequest(irp, boost);}
#endif

#endif

extern PDRIVER_DISPATCH FdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];
extern PDRIVER_DISPATCH PdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];

typedef struct _IDEDRIVER_EXTENSION {

    UNICODE_STRING RegistryPath;

} IDEDRIVER_EXTENSION, *PIDEDRIVER_EXTENSION;

typedef struct _CUSTOM_DEVICE_PARAMETER {

    ULONG   CommandRegisterBase;
    ULONG   IrqLevel;

}CUSTOM_DEVICE_PARAMETER, *PCUSTOM_DEVICE_PARAMETER;



#define FULL_RESOURCE_LIST_SIZE(n) (sizeof (CM_FULL_RESOURCE_DESCRIPTOR) + (sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (n - 1)))

#define IDE_PSUEDO_INITIATOR_ID     (0xff)

ULONG
DriverEntry(
    IN OUT PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
IdePortDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortDispatchSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortNoSupportIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortNoSupportPnpIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortAlwaysStatusSuccessIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortPassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortStatusSuccessAndPassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

VOID
IdePortParseDeviceParameters(
    IN     HANDLE                   SubServiceKey,
    IN OUT PCUSTOM_DEVICE_PARAMETER CustomDeviceParameter
    );

PCSTR
IdePortGetDeviceTypeString (
    IN ULONG DeviceType
    );

PCSTR
IdePortGetCompatibleIdString (
    IN ULONG DeviceType
    );

PCSTR
IdePortGetPeripheralIdString (
    IN ULONG DeviceType
    );

BOOLEAN
IdePortChannelEmpty (
    PIDE_REGISTERS_1 CmdRegBase,
    PIDE_REGISTERS_2 CtrlRegBase,
    ULONG            MaxIdeDevice
);

VOID
IdePortUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
IdePortQueryInterface (
    PFDO_EXTENSION      FdoExtension,
    PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
IdePortQueryInterfaceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
IdePortOkToDetectLegacy (
    IN PDRIVER_OBJECT DriverObject
);

BOOLEAN 
IdePortSearchDeviceInRegMultiSzList (
    IN PFDO_EXTENSION  FdoExtension,
    IN PIDENTIFY_DATA  IdentifyData,
    IN PWSTR           RegKeyValue
);

NTSTATUS
IdePortSyncSendIrp (
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT OPTIONAL PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
IdePortGenericCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

ULONG
IdePortSimpleCheckSum (
    IN ULONG                PartialSum,
    IN PVOID                SourceVa,
    IN ULONG                Length
    );

VOID
FASTCALL
IdeFreeIrpAndMdl(
    IN PIRP Irp
    );

NTSTATUS
FASTCALL
IdeBuildAndSendIrp (
    IN PPDO_EXTENSION PdoExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID CompletionContext
    );

BOOLEAN
IdePortInSetup(
    IN PFDO_EXTENSION FdoExtension
    );

typedef struct _IDE_DEVICE_TYPE {

    PCSTR DeviceTypeString;

    PCSTR CompatibleIdString;

    PCSTR PeripheralIdString;

} IDE_DEVICE_TYPE, * PIDE_DEVICE_TYPE;

#define DRIVER_OBJECT_EXTENSION_ID  DriverEntry

typedef struct _COMPLETION_ROUTINE_CONTEXT {

    KEVENT Event;
    IO_STATUS_BLOCK IoStatus;

} COMPLETION_ROUTINE_CONTEXT, *PCOMPLETION_ROUTINE_CONTEXT;



typedef struct _ENUMERATION_STRUCT {
    PIRP Irp1;
    PSCSI_REQUEST_BLOCK Srb;
    PSENSE_DATA SenseInfoBuffer;
    PMDL        MdlAddress;

    //
    // DataBuffer to hold the input/output
    // buffers
    //
    PULONG DataBuffer;
    ULONG DataBufferSize;

    PPDO_STOP_QUEUE_CONTEXT StopQContext;

    //
    // Pre-Alloced Enum work item
    //
    PVOID EnumWorkItemContext;

    PATA_PASSTHROUGH_CONTEXT Context;

}ENUMERATION_STRUCT, *PENUMERATION_STRUCT;

#define PREALLOC_STACK_LOCATIONS    1

BOOLEAN
IdePreAllocEnumStructs (
    IN PFDO_EXTENSION FdoExtension
);

VOID
IdeFreeEnumStructs(
    PENUMERATION_STRUCT enumStruct
);

//
// test code on/off switch
//       
// always comment this define out before check in
//#define PRIVATE_BUILD

#ifdef PRIVATE_BUILD

#define HUNG_CONTROLLER_CHECK       1

#else 

#undef HUNG_CONTROLLER_CHECK

#endif // PRIVATE_BUILD

//#if DBG
//#define PoStartNextPowerIrp(x) {\
//    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation (x);\
//    DebugPrint ((0, "PoStartNextPowerIrp(0x%x) for devobj 0x%x\n", x, irpStack->DeviceObject));\
//    PoStartNextPowerIrp(x);\
//    }
//#endif //DBG

//
// define this if we want NT4 scsiport DriverParameter support in the registry
// default is "not defined"
//#define DRIVER_PARAMETER_REGISTRY_SUPPORT


#endif // ___IDEPORT_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\init.h ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    init.h

Abstract:

--*/

#if !defined (___INIT_H___)
#define ___INIT_H___

NTSTATUS
IdePortInitFdo(
    IN OUT PFDO_EXTENSION  FdoExtension
);


NTSTATUS
IssueSyncAtapiCommandSafe (
    IN PFDO_EXTENSION   FdoExtension,
    IN PPDO_EXTENSION   PdoExtension,
    IN PCDB             Cdb,
    IN PVOID            DataBuffer,
    IN ULONG            DataBufferSize,
    IN BOOLEAN          DataIn,
    IN ULONG            RetryCount,
    IN BOOLEAN          ByPassBlockedQueue
);

NTSTATUS
SyncAtapiSafeCompletion (
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp,
    PVOID          Context
);

BOOLEAN
IdePortDmaCdromDrive(
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension,
    IN BOOLEAN       LowMem
);

NTSTATUS
IssueInquirySafe(
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension,
    OUT PINQUIRYDATA InquiryData,
    IN BOOLEAN          LowMem
);

NTSTATUS
IssueSyncAtapiCommand (
    IN PFDO_EXTENSION   FdoExtension,
    IN PPDO_EXTENSION   PdoExtension,
    IN PCDB             Cdb,
    IN PVOID            DataBuffer,
    IN ULONG            DataBufferSize,
    IN BOOLEAN          DataIn,
    IN ULONG            RetryCount,
    IN BOOLEAN          ByPassBlockedQueue
);
  
ULONG
IdePortQueryNonCdNumLun (
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension,
    IN BOOLEAN ByPassBlockedQueue
);

VOID
IdeBusScan(
    IN PFDO_EXTENSION FdoExtension
);

VOID
IdeBuildDeviceMap(
    IN PFDO_EXTENSION FdoExtension,
    IN PUNICODE_STRING ServiceKey
);

NTSTATUS
IdeCreateNumericKey(
    IN  HANDLE  Root,
    IN  ULONG   Name,
    IN  PWSTR   Prefix,
    OUT PHANDLE NewKey
);
                       
#endif // ___INIT_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\luext.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       luext.c
//
//--------------------------------------------------------------------------

#include "ideport.h"

static ULONG IdeDeviceUniqueId = 0;

PPDO_EXTENSION
RefPdo(
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
{
    PPDO_EXTENSION  pdoExtension;
    PPDO_EXTENSION  pdoExtension2Return;
    KIRQL           currentIrql;

    pdoExtension = PhysicalDeviceObject->DeviceExtension;

    KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

    pdoExtension2Return = RefPdoWithSpinLockHeldWithTag(
                              PhysicalDeviceObject, 
                              RemovedOk,
                              Tag
                              );

    if (pdoExtension2Return) {
        ASSERT(pdoExtension2Return == pdoExtension);
    }

    KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

    return pdoExtension2Return;

} // RefPdo()

PPDO_EXTENSION
RefPdoWithSpinLockHeld(
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
{
    PPDO_EXTENSION  pdoExtension;
    KIRQL           currentIrql;

    pdoExtension = PhysicalDeviceObject->DeviceExtension;

    if (!(pdoExtension->PdoState & (PDOS_REMOVED | PDOS_DEADMEAT | PDOS_SURPRISE_REMOVED)) ||
        RemovedOk) {

        IdeInterlockedIncrement (
            pdoExtension,
            &pdoExtension->ReferenceCount,
            Tag
            );

    } else {

        pdoExtension = NULL;
    }

    return pdoExtension;

} // RefPdoWithSpinLockHeld()


VOID
UnrefPdo(
    PPDO_EXTENSION PdoExtension
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
{
    UnrefLogicalUnitExtensionWithTag(
        PdoExtension->ParentDeviceExtension,
        PdoExtension,
        Tag
        );
}


PPDO_EXTENSION
RefLogicalUnitExtension(
    PFDO_EXTENSION DeviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    BOOLEAN RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )

/*++

Routine Description:

    Walk logical unit extension list looking for
    extension with matching target id.

Arguments:

    deviceExtension
    TargetId

Return Value:

    Requested logical unit extension if found,
    else NULL.

--*/

{
    PPDO_EXTENSION  pdoExtension;
    PPDO_EXTENSION  pdoExtension2Return = NULL;
    KIRQL           currentIrql;

    if (TargetId >= DeviceExtension->HwDeviceExtension->MaxIdeTargetId) {
        return NULL;
    }

    KeAcquireSpinLock(&DeviceExtension->LogicalUnitListSpinLock, &currentIrql);

    pdoExtension = DeviceExtension->LogicalUnitList[(TargetId + Lun) % NUMBER_LOGICAL_UNIT_BINS];
    while (pdoExtension && !(pdoExtension->TargetId == TargetId &&
                             pdoExtension->Lun == Lun &&
                             pdoExtension->PathId == PathId)) {

        pdoExtension = pdoExtension->NextLogicalUnit;
    }

    if (pdoExtension) {

        pdoExtension2Return = RefPdoWithTag(
                                  pdoExtension->DeviceObject, 
                                  RemovedOk,
                                  Tag
                                  );
    }

    KeReleaseSpinLock(&DeviceExtension->LogicalUnitListSpinLock, currentIrql);

    return pdoExtension2Return;

} // end RefLogicalUnitExtension()

VOID
UnrefLogicalUnitExtension(
    PFDO_EXTENSION FdoExtension,
    PPDO_EXTENSION PdoExtension
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
{
    KIRQL   currentIrql;
    LONG    refCount;
    BOOLEAN deletePdo = FALSE;
    ULONG   lockCount;

    ASSERT (PdoExtension);

    if (PdoExtension) {

        KeAcquireSpinLock(&PdoExtension->PdoSpinLock, &currentIrql);

        ASSERT(PdoExtension->ReferenceCount > 0);

        lockCount = IdeInterlockedDecrement (
                        PdoExtension,
                        &PdoExtension->ReferenceCount,
                        Tag
                        );

//        ASSERT(lockCount >= 0);

        if (lockCount <= 0) {

            if ((PdoExtension->PdoState & PDOS_DEADMEAT) &&
                (PdoExtension->PdoState & PDOS_REMOVED)) {

                deletePdo = TRUE;
            }
        }

        KeReleaseSpinLock(&PdoExtension->PdoSpinLock, currentIrql);

        if (deletePdo) {

//            IoDeleteDevice (PdoExtension->DeviceObject);
            KeSetEvent (&PdoExtension->RemoveEvent, 0, FALSE);
        }
    }

} // UnrefLogicalUnitExtension();

PPDO_EXTENSION
AllocatePdo(
    IN PFDO_EXTENSION   FdoExtension,
    IN IDE_PATH_ID      PathId
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
/*++

Routine Description:

    Create logical unit extension.

Arguments:

    DeviceExtension
    PathId

Return Value:

    Logical unit extension


--*/
{
    PDEVICE_OBJECT    physicalDeviceObject;
    KIRQL             currentIrql;
    PPDO_EXTENSION    pdoExtension;
    ULONG size;
    ULONG bin;
    ULONG uniqueId;

    NTSTATUS          status;
    UNICODE_STRING    deviceName;
    WCHAR             deviceNameBuffer[64];

    PAGED_CODE();

    uniqueId = InterlockedIncrement (&IdeDeviceUniqueId) - 1;

    swprintf(deviceNameBuffer, DEVICE_OJBECT_BASE_NAME L"\\IdeDeviceP%dT%dL%d-%x", 
            FdoExtension->IdePortNumber,
            PathId.b.TargetId,
            PathId.b.Lun,
            uniqueId
            );
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    physicalDeviceObject = DeviceCreatePhysicalDeviceObject (
                               FdoExtension->DriverObject,
                               FdoExtension,
                               &deviceName
                               );

    if (physicalDeviceObject == NULL) {

        DebugPrint ((DBG_ALWAYS, "ATAPI: Unable to create device object\n", deviceNameBuffer));
        return NULL;
    }

    pdoExtension = physicalDeviceObject->DeviceExtension;

    pdoExtension->AttacherDeviceObject = physicalDeviceObject;

    pdoExtension->PathId    = (UCHAR) PathId.b.Path;
    pdoExtension->TargetId  = (UCHAR) PathId.b.TargetId;
    pdoExtension->Lun       = (UCHAR) PathId.b.Lun;

    //
    // Set timer counters in LogicalUnits to -1 to indicate no
    // outstanding requests.
    //

    pdoExtension->RequestTimeoutCounter = -1;

    //
    // This logical unit is be initialized
    //
    pdoExtension->LuFlags |= PD_RESCAN_ACTIVE;

    //
    // Allocate spin lock for critical sections.
    //
    KeInitializeSpinLock(&pdoExtension->PdoSpinLock);

    //
    // Initialize the request list.
    //

    InitializeListHead(&pdoExtension->SrbData.RequestList);

    //
    // Initialize a event
    //
    KeInitializeEvent (
        &pdoExtension->RemoveEvent,
        NotificationEvent,
        FALSE
        );

    //
    // Link logical unit extension on list.
    //

    bin = (PathId.b.TargetId + PathId.b.Lun) % NUMBER_LOGICAL_UNIT_BINS;

    //
    // get spinlock for accessing the logical unit extension bin
    //
    KeAcquireSpinLock(&FdoExtension->LogicalUnitListSpinLock, &currentIrql);

    pdoExtension->NextLogicalUnit =
        FdoExtension->LogicalUnitList[bin];

    //
    // Open the Command Log
    //
    IdeLogOpenCommandLog(&pdoExtension->SrbData);

    FdoExtension->LogicalUnitList[bin] = pdoExtension;

    FdoExtension->NumberOfLogicalUnits++;

    FdoExtension->NumberOfLogicalUnitsPowerUp++;

    IdeInterlockedIncrement (
        pdoExtension,
        &pdoExtension->ReferenceCount,
        Tag
        );

    KeReleaseSpinLock(&FdoExtension->LogicalUnitListSpinLock, currentIrql);

    return pdoExtension;

} // end CreateLogicalUnitExtension()


NTSTATUS
FreePdo(
    IN PPDO_EXTENSION   PdoExtension,
    IN BOOLEAN          Sync,
    IN BOOLEAN          CallIoDeleteDevice
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
{
    PFDO_EXTENSION          fdoExtension;
    PPDO_EXTENSION          pdoExtension;
    KIRQL                   currentIrql;
    PLOGICAL_UNIT_EXTENSION lastPdoExtension;
    ULONG                   targetId;
    ULONG                   lun;
    LONG                    refCount;
    NTSTATUS                status;

    targetId     = PdoExtension->TargetId;
    lun          = PdoExtension->Lun;
    fdoExtension = PdoExtension->ParentDeviceExtension;

    lastPdoExtension = NULL;

    //
    // get spinlock for accessing the logical unit extension bin
    //
    KeAcquireSpinLock(&fdoExtension->LogicalUnitListSpinLock, &currentIrql);

    pdoExtension = fdoExtension->LogicalUnitList[(targetId + lun) % NUMBER_LOGICAL_UNIT_BINS];
    while (pdoExtension != NULL) {

        if (pdoExtension == PdoExtension) {

            if (lastPdoExtension == NULL) {
    
                //
                // Remove from head of list.
                //
                fdoExtension->LogicalUnitList[(targetId + lun) % NUMBER_LOGICAL_UNIT_BINS] =
                    pdoExtension->NextLogicalUnit;
    
            } else {
    
                lastPdoExtension->NextLogicalUnit = pdoExtension->NextLogicalUnit;
            }

            ASSERT (!(pdoExtension->PdoState & PDOS_LEGACY_ATTACHER));

            if (pdoExtension->ReferenceCount > 1) {

                DebugPrint ((0, 
                            "IdePort FreePdo: pdoe 0x%x ReferenceCount is 0x%x\n", 
                            pdoExtension, 
                            pdoExtension->ReferenceCount));
            }

            fdoExtension->NumberOfLogicalUnits--;

            //
            // only if pdo is freed while it is powered up
            //
            if (pdoExtension->DevicePowerState <= PowerDeviceD0) {
            
                fdoExtension->NumberOfLogicalUnitsPowerUp--;
            }                

            KeReleaseSpinLock(&fdoExtension->LogicalUnitListSpinLock, currentIrql);

            break;
        }

        lastPdoExtension = pdoExtension;
        pdoExtension     = pdoExtension->NextLogicalUnit;
    }

    if (pdoExtension) {

        ASSERT (pdoExtension == PdoExtension);

        KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

        //
        // better not attached by a legacy device
        //
        ASSERT (!(pdoExtension->PdoState & PDOS_LEGACY_ATTACHER));

        //
        // lower the refer count for the caller
        // and save the new refCount
        //
        ASSERT(pdoExtension->ReferenceCount > 0);
        refCount = IdeInterlockedDecrement (
                       pdoExtension,
                       &pdoExtension->ReferenceCount,
                       Tag
                       );

        //
        // no more new request
        //
        pdoExtension->PdoState |= PDOS_DEADMEAT | PDOS_REMOVED;

        KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

        //
        // remove idle detection timer if any
        //
        DeviceUnregisterIdleDetection (PdoExtension);
        
        //
        // free acpi data
        //
        if (PdoExtension->AcpiDeviceSettings) {
        
            ExFreePool(PdoExtension->AcpiDeviceSettings);
            PdoExtension->AcpiDeviceSettings = NULL;
        }

        //
        // flush every pending request
        //
        IdePortFlushLogicalUnit (
            fdoExtension,
            PdoExtension,
            TRUE
            ); 

        if (refCount) {

            if (Sync) {

                status = KeWaitForSingleObject(&pdoExtension->RemoveEvent,
                                               Executive,
                                               KernelMode,
                                               FALSE,
                                               NULL);
            }
        }

        if (CallIoDeleteDevice) {

			//
			// Free command log if it was allocated
			//
			IdeLogFreeCommandLog(&PdoExtension->SrbData);

            IoDeleteDevice (pdoExtension->DeviceObject);
        }

        return STATUS_SUCCESS;

    } else {

        KeReleaseSpinLock(&fdoExtension->LogicalUnitListSpinLock, currentIrql);
    
        if (CallIoDeleteDevice) {

            DebugPrint ((
                DBG_PNP,
                "ideport: deleting device 0x%x that was PROBABLY surprise removed\n",
                PdoExtension->DeviceObject
                ));
    
            //ASSERT (PdoExtension->PdoState & PDOS_SURPRISE_REMOVED);
            //
            // delete the device if it wasn't removed before.
            // PDOS_REMOVED could be set, if the device was surprise
            // removed. In that case remove the device
            //
            if (!(PdoExtension->PdoState & PDOS_REMOVED) || 
                        PdoExtension->PdoState & PDOS_SURPRISE_REMOVED) {
				//
				// Free command log if it was allocated
				//
				IdeLogFreeCommandLog(&PdoExtension->SrbData);

                IoDeleteDevice (PdoExtension->DeviceObject);
            }
    
        }

        return STATUS_SUCCESS;
    }

} // end FreeLogicalUnitExtension()


PLOGICAL_UNIT_EXTENSION
NextLogUnitExtension(
    IN     PFDO_EXTENSION FdoExtension,
    IN OUT PIDE_PATH_ID   PathId,
    IN     BOOLEAN        RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
{
    PLOGICAL_UNIT_EXTENSION logUnitExtension;


    logUnitExtension = NULL;

    for (; 
         !logUnitExtension && (PathId->b.Path < MAX_IDE_PATH); 
         PathId->b.Path++, PathId->b.TargetId = 0) {

        for (; 
             !logUnitExtension && (PathId->b.TargetId < FdoExtension->HwDeviceExtension->MaxIdeTargetId); 
             PathId->b.TargetId++, PathId->b.Lun = 0) {

            logUnitExtension = RefLogicalUnitExtensionWithTag (
                                   FdoExtension,
                                   (UCHAR) PathId->b.Path,
                                   (UCHAR) PathId->b.TargetId,
                                   (UCHAR) PathId->b.Lun,
                                   RemovedOk,
                                   Tag
                                   );

            if (logUnitExtension) {

                //
                // increment lun for the next time around
                //
                PathId->b.Lun++;
                return logUnitExtension;
            }

            //
            // Assume Lun number never skips.
            // If we can't find the logical unit extension for a lun,
            // will go to the next target ID with lun 0
            //
        }
    }

    return NULL;

} // end NextLogicalUnitExtension()

VOID
KillPdo(
    IN PPDO_EXTENSION PdoExtension
    )
{
    KIRQL currentIrql;

    ASSERT (PdoExtension);

    KeAcquireSpinLock(&PdoExtension->PdoSpinLock, &currentIrql);

    ASSERT (!(PdoExtension->PdoState & PDOS_DEADMEAT));

    SETMASK (PdoExtension->PdoState, PDOS_DEADMEAT);

    IdeLogDeadMeatReason( PdoExtension->DeadmeatRecord.Reason, 
                          byKilledPdo
                          );

    KeReleaseSpinLock(&PdoExtension->PdoSpinLock, currentIrql);
}


#if DBG

PVOID IdePortInterestedLockTag=NULL;

LONG 
IdeInterlockedIncrement (
   IN PPDO_EXTENSION PdoExtension,
   IN PLONG Addend,
   IN PVOID Tag
   )
{
    ULONG i;
    KIRQL currentIrql;

    DebugPrint ((
        DBG_PDO_LOCKTAG,
        ">>>>>>>>>>>>>>>>>>>> Acquire PdoLock with tag = 0x%x\n", 
        Tag
        ));

    if (IdePortInterestedLockTag == Tag) {

        DebugPrint ((DBG_ALWAYS, "Found the interested lock tag 0x%x\n", Tag));
        DbgBreakPoint();
    }

    KeAcquireSpinLock(&PdoExtension->RefCountSpinLock, &currentIrql);

    if (PdoExtension->NumTagUsed >= TAG_TABLE_SIZE) {

        DebugPrint ((DBG_ALWAYS, "Used up all %d tag\n", TAG_TABLE_SIZE));
        DbgBreakPoint();
    }

    for (i=0; i<PdoExtension->NumTagUsed; i++) {

        if (PdoExtension->TagTable[i] == Tag) {

            DebugPrint ((DBG_ALWAYS, "Tag 0x%x already in used\n", Tag));
            DbgBreakPoint();
        }
    }

    PdoExtension->TagTable[PdoExtension->NumTagUsed] = Tag;
    PdoExtension->NumTagUsed++;

    KeReleaseSpinLock(&PdoExtension->RefCountSpinLock, currentIrql);

    return InterlockedIncrement (Addend);
}

LONG 
IdeInterlockedDecrement (
   IN PPDO_EXTENSION PdoExtension,
   IN PLONG Addend,
   IN PVOID Tag
   )
{
    ULONG i;
    KIRQL currentIrql;
    BOOLEAN foundTag;

    DebugPrint ((
        DBG_PDO_LOCKTAG,
        ">>>>>>>>>>>>>>>>>>>> Release PdoLock with tag = 0x%x\n", 
        Tag
        ));

    KeAcquireSpinLock(&PdoExtension->RefCountSpinLock, &currentIrql);

    for (i=0, foundTag=FALSE; i<PdoExtension->NumTagUsed; i++) {

        if (PdoExtension->TagTable[i] == Tag) {

            if (PdoExtension->NumTagUsed > 1) {

                PdoExtension->TagTable[i] = 
                    PdoExtension->TagTable[PdoExtension->NumTagUsed - 1];
            }
            PdoExtension->NumTagUsed--;
            foundTag = TRUE;
            break;
        }
    }

    if (!foundTag) {

        DebugPrint ((DBG_ALWAYS, "Unable to find tag 0x%x\n", Tag));
        DbgBreakPoint();
    }

    KeReleaseSpinLock(&PdoExtension->RefCountSpinLock, currentIrql);

    return InterlockedDecrement (Addend);
}


#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\luext.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       luext.h
//
//--------------------------------------------------------------------------

#if !defined (___luext_h___)
#define ___luext_h___

#if !DBG

#define RefPdoWithTag(a,b,c)                        RefPdo(a,b)
#define RefPdoWithSpinLockHeldWithTag(a,b,c)        RefPdoWithSpinLockHeld(a,b)
#define RefLogicalUnitExtensionWithTag(a,b,c,d,e,f) RefLogicalUnitExtension(a,b,c,d,e)
#define UnrefPdoWithTag(a,b)                        UnrefPdo(a)
#define UnrefLogicalUnitExtensionWithTag(a,b,c)     UnrefLogicalUnitExtension(a,b)
#define AllocatePdoWithTag(a,b,c)                   AllocatePdo(a,b)
#define FreePdoWithTag(a,b,c,d)                     FreePdo(a,b,c)
#define NextLogUnitExtensionWithTag(a,b,c,d)        NextLogUnitExtension(a,b,c)

#else

#define RefPdoWithTag                    RefPdo
#define RefPdoWithSpinLockHeldWithTag    RefPdoWithSpinLockHeld
#define RefLogicalUnitExtensionWithTag   RefLogicalUnitExtension
#define UnrefPdoWithTag                  UnrefPdo
#define UnrefLogicalUnitExtensionWithTag UnrefLogicalUnitExtension
#define AllocatePdoWithTag               AllocatePdo
#define FreePdoWithTag                   FreePdo
#define NextLogUnitExtensionWithTag      NextLogUnitExtension

#endif // DBG

PPDO_EXTENSION
RefPdo(
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );

PPDO_EXTENSION
RefPdoWithSpinLockHeld(
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );

PPDO_EXTENSION
RefLogicalUnitExtension(
    PFDO_EXTENSION DeviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    BOOLEAN RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );

VOID
UnrefPdo(
    PPDO_EXTENSION PdoExtension
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );

VOID
UnrefLogicalUnitExtension(
    PFDO_EXTENSION FdoExtension,
    PPDO_EXTENSION PdoExtension
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );
      
PPDO_EXTENSION
AllocatePdo(
    IN PFDO_EXTENSION   FdoExtension,
    IN IDE_PATH_ID      PathId
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );

NTSTATUS
FreePdo(
    IN PPDO_EXTENSION   PdoExtension,
    IN BOOLEAN          Sync,
    IN BOOLEAN          IoDeleteDevice
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );
    
PPDO_EXTENSION
NextLogUnitExtension(
    IN     PFDO_EXTENSION FdoExtension,
    IN OUT PIDE_PATH_ID   PathId,
    IN     BOOLEAN        RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );

VOID
KillPdo(
    IN PPDO_EXTENSION PdoExtension
    );
                       
#if !DBG

#define IdeInterlockedIncrement(pdoe, Addend, Tag) InterlockedIncrement(Addend)
#define IdeInterlockedDecrement(pdoe, Addend, Tag) InterlockedDecrement(Addend)

#else
LONG 
IdeInterlockedIncrement (
   IN PPDO_EXTENSION PdoExtension,
   IN PLONG Addend,
   IN PVOID Tag
   );

LONG 
IdeInterlockedDecrement (
   IN PPDO_EXTENSION PdoExtension,
   IN PLONG Addend,
   IN PVOID Tag
   );
#endif




#endif // ___luext_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\init.c ===
/*++

Copyright (C) 1990 - 99  Microsoft Corporation

Module Name:

    port.c

Abstract:

    Ide bus enumeration

Authors:

    Mike Glass
    Jeff Havens
    Joe Dai

Environment:

    kernel mode only

Revision History:

--*/

#include "ideport.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(NONPAGE, IssueSyncAtapiCommand)
#pragma alloc_text(NONPAGE, IssueSyncAtapiCommandSafe)
#pragma alloc_text(NONPAGE, IdePortDmaCdromDrive)
//#pragma alloc_text(PAGESCAN, IdePortDmaCdromDrive)

#pragma alloc_text(PAGE, IdePortInitFdo)
#pragma alloc_text(PAGE, IssueInquirySafe)
#pragma alloc_text(PAGE, IdePortQueryNonCdNumLun)
#pragma alloc_text(PAGE, IdeBuildDeviceMap)
#pragma alloc_text(PAGE, IdeCreateNumericKey)

extern LONG IdePAGESCANLockCount;
#endif

static PWCHAR IdePortUserRegistryDeviceTypeName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    USER_MASTER_DEVICE_TYPE_REG_KEY,
    USER_SLAVE_DEVICE_TYPE_REG_KEY,
    USER_MASTER_DEVICE_TYPE2_REG_KEY,
    USER_SLAVE_DEVICE_TYPE2_REG_KEY
};

static PWCHAR IdePortRegistryUserDeviceTimingModeAllowedName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    USER_MASTER_DEVICE_TIMING_MODE_ALLOWED,
    USER_SLAVE_DEVICE_TIMING_MODE_ALLOWED,
    USER_MASTER_DEVICE_TIMING_MODE_ALLOWED2,
    USER_SLAVE_DEVICE_TIMING_MODE_ALLOWED2
};

//
// Idle Timeout
//
//ULONG PdoConservationIdleTime = -1;
//ULONG PdoPerformanceIdleTime = -1;

NTSTATUS
IdePortInitFdo(
    IN OUT PFDO_EXTENSION  FdoExtension
    )
/*++

Routine Description:

    This routine enumerates the IDE bus and initialize the fdo extension

Arguments:

    FdoExtension - FDO extension

    RegistryPath - registry path passed in via DriverEntry

Return Value:

--*/

{
    PFDO_EXTENSION        fdoExtension = FdoExtension;
    NTSTATUS              status;
    PDEVICE_OBJECT        deviceObject;
    ULONG                 uniqueId;
    KIRQL                 irql;
    PIO_SCSI_CAPABILITIES capabilities;
    PIO_ERROR_LOG_PACKET  errorLogEntry;
    ULONG                 i;
    ULONG                 j;
    BOOLEAN               ideDeviceFound;


    status = STATUS_SUCCESS;
    deviceObject = fdoExtension->DeviceObject;

    //
    // Save the dependent driver routines in the device extension.
    //

    fdoExtension->HwDeviceExtension = (PVOID)(fdoExtension + 1);

    //
    // Mark this object as supporting direct I/O so that I/O system
    // will supply mdls in irps.
    //

    deviceObject->Flags |= DO_DIRECT_IO;

    //
    // Initialize the maximum lu count variable.
    //

    fdoExtension->MaxLuCount = SCSI_MAXIMUM_LOGICAL_UNITS;

    //
    // Allocate spin lock for critical sections.
    //

    KeInitializeSpinLock(&fdoExtension->SpinLock);


    //
    // Spinlock that protects LogicalUnitList manipulation
    //
    KeInitializeSpinLock(&fdoExtension->LogicalUnitListSpinLock);

    //
    // Initialize DPC routine.
    //

    IoInitializeDpcRequest(deviceObject, IdePortCompletionDpc);

    //
    // Initialize the port timeout counter.
    //

    fdoExtension->PortTimeoutCounter = PD_TIMER_STOPPED;

    //
    // Initialize timer.
    //

    IoInitializeTimer(deviceObject, IdePortTickHandler, NULL);

    //
    // Initialize miniport timer and timer DPC.
    //

    KeInitializeTimer(&fdoExtension->MiniPortTimer);
    KeInitializeDpc(&fdoExtension->MiniPortTimerDpc,
                    IdeMiniPortTimerDpc,
                    deviceObject );

    //
    // Start timer. Request timeout counters
    // in the logical units have already been
    // initialized.
    //
    IoStartTimer(deviceObject);
    fdoExtension->Flags |= PD_DISCONNECT_RUNNING;

    //
    // Check to see if an error was logged.
    //

    if (fdoExtension->InterruptData.InterruptFlags & PD_LOG_ERROR) {

        CLRMASK (fdoExtension->InterruptData.InterruptFlags, PD_LOG_ERROR | PD_NOTIFICATION_REQUIRED);
        LogErrorEntry(fdoExtension,
                      &fdoExtension->InterruptData.LogEntry);
    }

    //
    // Initialize the capabilities pointer.
    //

    capabilities = &fdoExtension->Capabilities;

    //
    // Initailize the capabilities structure.
    //

    capabilities->Length = sizeof(IO_SCSI_CAPABILITIES);

    if (fdoExtension->BoundWithBmParent) {

        if (fdoExtension->HwDeviceExtension->BusMasterInterface.MaxTransferByteSize <
            MAX_TRANSFER_SIZE_PER_SRB) {

            capabilities->MaximumTransferLength =
                fdoExtension->HwDeviceExtension->BusMasterInterface.MaxTransferByteSize;

        } else {

            capabilities->MaximumTransferLength =
                MAX_TRANSFER_SIZE_PER_SRB;
        }
    } else {

        capabilities->MaximumTransferLength = MAX_TRANSFER_SIZE_PER_SRB;
    }

    capabilities->TaggedQueuing = FALSE;
    capabilities->AdapterScansDown = FALSE;
    capabilities->AlignmentMask = deviceObject->AlignmentRequirement;
    capabilities->MaximumPhysicalPages = BYTES_TO_PAGES(capabilities->MaximumTransferLength);

    if (fdoExtension->IdeResource.TranslatedCommandBaseAddress) {
        DebugPrint((1,
                   "IdePort: Initialize: Translated IO Base address %x\n",
                   fdoExtension->IdeResource.TranslatedCommandBaseAddress));
    }

    for (i=0; i< MAX_IDE_DEVICE * MAX_IDE_LINE; i++) {

        fdoExtension->UserChoiceDeviceType[i] = DeviceUnknown;
        IdePortGetDeviceParameter (
            fdoExtension,
            IdePortUserRegistryDeviceTypeName[i],
            (PULONG)(fdoExtension->UserChoiceDeviceType + i)
            );

    }

    //
    // the acpi _GTM buffer should be initialized with -1s
    //
    for (i=0; i<MAX_IDE_DEVICE; i++) {

        PACPI_IDE_TIMING timingSettings = &(FdoExtension->BootAcpiTimingSettings);
        timingSettings->Speed[i].Pio = ACPI_XFER_MODE_NOT_SUPPORT;
        timingSettings->Speed[i].Dma = ACPI_XFER_MODE_NOT_SUPPORT;
    }

    fdoExtension->DmaDetectionLevel = DdlFirmwareOk;
    IdePortGetDeviceParameter (
        fdoExtension,
        DMA_DETECTION_LEVEL_REG_KEY,
        (PULONG)&fdoExtension->DmaDetectionLevel
        );

    //
    // non-pcmcia controller, MayHaveSlaveDevice is always set
    // if pcmcia controller, it is not set unless 
    // registry flag PCMCIA_IDE_CONTROLLER_HAS_SLAVE
    // is non-zero
    //
    if (!ChannelQueryPcmciaParent (fdoExtension)) {
    
        fdoExtension->MayHaveSlaveDevice = 1;
        
    } else {
    
        fdoExtension->MayHaveSlaveDevice = 0;
        IdePortGetDeviceParameter (
            fdoExtension,
            PCMCIA_IDE_CONTROLLER_HAS_SLAVE,
            (PULONG)&fdoExtension->MayHaveSlaveDevice
            );
    }

#ifdef ENABLE_ATAPI_VERIFIER
    ViIdeInitVerifierSettings(fdoExtension);
#endif
                         
    return status;

} // IdePortInitFdo


NTSTATUS
SyncAtapiSafeCompletion (
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp,
    PVOID          Context
    )
{
    PSYNC_ATA_PASSTHROUGH_CONTEXT context = Context;

    context->Status = Irp->IoStatus.Status;

    KeSetEvent (&context->Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
IssueSyncAtapiCommandSafe (
    IN PFDO_EXTENSION   FdoExtension,
    IN PPDO_EXTENSION   PdoExtension,
    IN PCDB             Cdb,
    IN PVOID            DataBuffer,
    IN ULONG            DataBufferSize,
    IN BOOLEAN          DataIn,
    IN ULONG            RetryCount,
    IN BOOLEAN          ByPassBlockedQueue

)
/*++

Routine Description:

    Build IRP, SRB and CDB for the given CDB

    Send and wait for the IRP to complete

Arguments:

    FdoExtension - FDO extension

    PdoExtension - device extension of the PDO to which the command is sent

    Cdb - Command Descriptor Block

    DataBuffer - data buffer for the command

    DataBufferSize - byte size of DataBuffer

    DataIn - TRUE is the command causes the device to return data

    RetryCount - number of times to retry the command if the command fails

Return Value:

    NTSTATUS

    If any of the pre-alloc related operation fails, it returns STATUS_INSUFFICIENT_RESOURCES
    The caller should take care of the condition

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    KEVENT event;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL currentIrql;
    NTSTATUS status;
    ULONG flushCount;

    PSENSE_DATA senseInfoBuffer;
    UCHAR senseInfoBufferSize;
    PENUMERATION_STRUCT enumStruct;
    SYNC_ATA_PASSTHROUGH_CONTEXT context;
    ULONG locked;

    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 1, 0) == 0);

    enumStruct=FdoExtension->PreAllocEnumStruct;

    if (enumStruct == NULL) {
        ASSERT(FdoExtension->PreAllocEnumStruct);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    senseInfoBufferSize = SENSE_BUFFER_SIZE;
    senseInfoBuffer = enumStruct->SenseInfoBuffer;

    ASSERT (senseInfoBuffer);

    DebugPrint((1, "Using Sync Atapi safe!\n"));

    srb= enumStruct->Srb;

    ASSERT(srb);

    status = STATUS_UNSUCCESSFUL;
    RetryCount = 5;
    flushCount = 100;
    irp = enumStruct->Irp1;


    ASSERT (irp);

    ASSERT (enumStruct->DataBufferSize >= DataBufferSize);

    while (!NT_SUCCESS(status) && RetryCount--) {

        //
        // Initialize the notification event.
        //

        KeInitializeEvent(&context.Event,
                          NotificationEvent,
                          FALSE);

        IoInitializeIrp(irp,
                        IoSizeOfIrp(PREALLOC_STACK_LOCATIONS),
                        PREALLOC_STACK_LOCATIONS);

        irp->MdlAddress = enumStruct->MdlAddress;

        irpStack = IoGetNextIrpStackLocation(irp);
        irpStack->MajorFunction = IRP_MJ_SCSI;

        if (DataBuffer) {
            RtlCopyMemory(enumStruct->DataBuffer, DataBuffer, DataBufferSize);
        }
        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

        irpStack->Parameters.Scsi.Srb = srb;

        srb->PathId      = PdoExtension->PathId;
        srb->TargetId    = PdoExtension->TargetId;
        srb->Lun         = PdoExtension->Lun;

        srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
        srb->Length = sizeof(SCSI_REQUEST_BLOCK);

        //
        // Set flags to disable synchronous negociation.
        //

        srb->SrbFlags = DataIn ? SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER :
                                SRB_FLAGS_DATA_OUT | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;


        if (ByPassBlockedQueue) {
            srb->SrbFlags |= SRB_FLAGS_BYPASS_FROZEN_QUEUE;
        }

        srb->SrbStatus = srb->ScsiStatus = 0;

        srb->NextSrb = 0;

        srb->OriginalRequest = irp;

        //
        // Set timeout to 4 seconds.
        //

        srb->TimeOutValue = 4;

        srb->CdbLength = 6;

        //
        // Enable auto request sense.
        //

        srb->SenseInfoBuffer = senseInfoBuffer;
        srb->SenseInfoBufferLength = senseInfoBufferSize;

        srb->DataBuffer = MmGetMdlVirtualAddress(irp->MdlAddress);
        srb->DataTransferLength = DataBufferSize;

        //
        // Set CDB operation code.
        //
        RtlCopyMemory(srb->Cdb, Cdb, sizeof(CDB));

        IoSetCompletionRoutine(
            irp,
            SyncAtapiSafeCompletion,
            &context,
            TRUE,
            TRUE,
            TRUE
            );

        //
        // Wait for request to complete.
        //
        if (IoCallDriver(PdoExtension->DeviceObject, irp) == STATUS_PENDING) {

            KeWaitForSingleObject(&context.Event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }

        RtlCopyMemory(DataBuffer, srb->DataBuffer, DataBufferSize);

        if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

            DebugPrint((1,"IssueSyncAtapiCommand: atapi command failed SRB status %x\n",
                        srb->SrbStatus));

            if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_REQUEST_FLUSHED) {
            
                //
                // we will give it a few more retries if our request
                // got flushed.
                //                                 
                flushCount--;
                if (flushCount) {
                    RetryCount++;  
                }
            }
            
            if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

                status = STATUS_DATA_OVERRUN;

            } else {

                status = STATUS_UNSUCCESSFUL;
                
            }

            //
            // Unfreeze queue if necessary
            //

            if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

                DebugPrint((3, "IssueSyncAtapiCommand: Unfreeze Queue TID %d\n",
                    srb->TargetId));

                //
                // unfreeze queue
                //
                CLRMASK (PdoExtension->LuFlags, PD_QUEUE_FROZEN);

                //
                // restart queue
                //
                KeAcquireSpinLock(&FdoExtension->SpinLock, &currentIrql);
                GetNextLuRequest(FdoExtension, PdoExtension);
                KeLowerIrql(currentIrql);
            }

            if ((srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
                (senseInfoBuffer->SenseKey == SCSI_SENSE_ILLEGAL_REQUEST)) {

                 //
                 // A sense key of illegal request was recieved.  This indicates
                 // that the mech status command is illegal.
                 //

                 status = STATUS_INVALID_DEVICE_REQUEST;

                 //
                 // The command is illegal, no point to keep trying
                 //
                 RetryCount = 0;
            }

        } else {

            status = STATUS_SUCCESS;
        }
    }

    if (flushCount != 100) {
        DebugPrint ((DBG_ALWAYS, "IssueSyncAtapiCommand: flushCount is %u\n", flushCount));
    }

    //
    // Unlock
    //
    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 0, 1) == 1);

    return status;

} // IssueSyncAtapiCommandSafe

BOOLEAN
IdePortDmaCdromDrive(
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension,
    IN BOOLEAN       LowMem
    )
/*++

Routine Description:

    Build IRP, SRB and CDB for SCSI MODE_SENSE10 command.

Arguments:

    DeviceExtension - address of adapter's device object extension.
    LowMem - Low memory condition, use the safe (but not thread-safe) version
           - This should be one only when called during enumeration.

Return Value:

    NTSTATUS

--*/
{
    CDB  cdb;
    NTSTATUS status;
    BOOLEAN isDVD = FALSE;
    ULONG bufLength;
    ULONG capPageOffset;
    PMODE_PARAMETER_HEADER10 modePageHeader;
    PCDVD_CAPABILITIES_PAGE capPage;

/*
    //
    // Code is paged until locked down.
    //
	PAGED_CODE();

#ifdef ALLOC_PRAGMA
	ASSERT(IdePAGESCANLockCount > 0);
#endif
*/

    RtlZeroMemory(&cdb, sizeof(CDB));

    bufLength = sizeof(CDVD_CAPABILITIES_PAGE) +
                sizeof(MODE_PARAMETER_HEADER10);

    capPageOffset = sizeof(MODE_PARAMETER_HEADER10);

    cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    cdb.MODE_SENSE10.Dbd = 1;
    cdb.MODE_SENSE10.PageCode = MODE_PAGE_CAPABILITIES;
    cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(bufLength >> 8);
    cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(bufLength >> 0);

    modePageHeader = ExAllocatePool(NonPagedPoolCacheAligned,
                                           bufLength);

    if (modePageHeader) {

        RtlZeroMemory(modePageHeader, bufLength);

        if (LowMem) {
            status = IssueSyncAtapiCommandSafe (
                         FdoExtension,
                         PdoExtension,
                         &cdb,
                         modePageHeader,
                         bufLength,
                         TRUE,
                         INQUIRY_RETRY_COUNT,
                         TRUE
                         );
        } else {
            status = IssueSyncAtapiCommand (
                         FdoExtension,
                         PdoExtension,
                         &cdb,
                         modePageHeader,
                         bufLength,
                         TRUE,
                         INQUIRY_RETRY_COUNT,
                         TRUE
                         );
        }

        if (NT_SUCCESS(status) ||
			(status == STATUS_DATA_OVERRUN)) {

            capPage = (PCDVD_CAPABILITIES_PAGE) (((PUCHAR) modePageHeader) + capPageOffset);

            if ((capPage->PageCode == MODE_PAGE_CAPABILITIES) &&
                (capPage->CDRWrite || capPage->CDEWrite ||
                 capPage->DVDROMRead || capPage->DVDRRead ||
                 capPage->DVDRAMRead || capPage->DVDRWrite ||
                 capPage->DVDRAMWrite)) {

                isDVD=TRUE;
            }
        }
        ExFreePool (modePageHeader);
    }

    return isDVD;
} 


NTSTATUS
IssueInquirySafe(
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension,
    OUT PINQUIRYDATA InquiryData,
    IN BOOLEAN       LowMem
    )
/*++

Routine Description:

    Build IRP, SRB and CDB for SCSI INQUIRY command.

Arguments:

    DeviceExtension - address of adapter's device object extension.
    LunInfo - address of buffer for INQUIRY information.
    LowMem - Low memory condition, use the safe (but not thread-safe) version
           - This should be one only when called during enumeration.

Return Value:

    NTSTATUS

--*/
{
    CDB  cdb;
    NTSTATUS status;

    PAGED_CODE();

    RtlZeroMemory(InquiryData, sizeof(*InquiryData));

    RtlZeroMemory(&cdb, sizeof(CDB));

    cdb.CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set CDB LUN.
    //

    cdb.CDB6INQUIRY.LogicalUnitNumber = PdoExtension->Lun;
    cdb.CDB6INQUIRY.Reserved1 = 0;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb.CDB6INQUIRY.AllocationLength = INQUIRYDATABUFFERSIZE;

    //
    // Zero reserve field and
    // Set EVPD Page Code to zero.
    // Set Control field to zero.
    // (See SCSI-II Specification.)
    //

    cdb.CDB6INQUIRY.PageCode = 0;
    cdb.CDB6INQUIRY.IReserved = 0;
    cdb.CDB6INQUIRY.Control = 0;

    if (LowMem ) {

        // Use the memory safe one
        status = IssueSyncAtapiCommandSafe (
                     FdoExtension,
                     PdoExtension,
                     &cdb,
                     InquiryData,
                     INQUIRYDATABUFFERSIZE,
                     TRUE,
                     INQUIRY_RETRY_COUNT,
                     FALSE
                     );
    } else {

        // Use the thread safe one
        status = IssueSyncAtapiCommand (
                     FdoExtension,
                     PdoExtension,
                     &cdb,
                     InquiryData,
                     INQUIRYDATABUFFERSIZE,
                     TRUE,
                     INQUIRY_RETRY_COUNT,
                     FALSE
                     );
    }

    return status;

} // IssueInquiry

NTSTATUS
IssueSyncAtapiCommand (
    IN PFDO_EXTENSION   FdoExtension,
    IN PPDO_EXTENSION   PdoExtension,
    IN PCDB             Cdb,
    IN PVOID            DataBuffer,
    IN ULONG            DataBufferSize,
    IN BOOLEAN          DataIn,
    IN ULONG            RetryCount,
    IN BOOLEAN          ByPassBlockedQueue

)
/*++

Routine Description:

    Build IRP, SRB and CDB for the given CDB

    Send and wait for the IRP to complete

Arguments:

    FdoExtension - FDO extension

    PdoExtension - device extension of the PDO to which the command is sent

    Cdb - Command Descriptor Block

    DataBuffer - data buffer for the command

    DataBufferSize - byte size of DataBuffer

    DataIn - TRUE is the command causes the device to return data

    RetryCount - number of times to retry the command if the command fails

Return Value:

    NTSTATUS

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    SCSI_REQUEST_BLOCK srb;
    KEVENT event;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL currentIrql;
    NTSTATUS status;
    ULONG flushCount;

    PSENSE_DATA senseInfoBuffer;
    UCHAR senseInfoBufferSize;


    //
    // Sense buffer is in non-paged pool.
    //

    senseInfoBufferSize = SENSE_BUFFER_SIZE;
    senseInfoBuffer = ExAllocatePool( NonPagedPoolCacheAligned, senseInfoBufferSize);

    if (senseInfoBuffer == NULL) {
        DebugPrint((1,"IssueSyncAtapiCommand: Can't allocate request sense buffer\n"));
        IdeLogNoMemoryError(FdoExtension,
                            PdoExtension->TargetId,
                            NonPagedPoolCacheAligned,
                            senseInfoBufferSize,
                            IDEPORT_TAG_SYNCATAPI_SENSE
                            );

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = STATUS_UNSUCCESSFUL;
    RetryCount = 5;
    flushCount = 100;
    while (!NT_SUCCESS(status) && RetryCount--) {

        //
        // Initialize the notification event.
        //

        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE);

        //
        // Build IRP for this request.
        //
        irp = IoBuildDeviceIoControlRequest(
                    DataIn ? IOCTL_SCSI_EXECUTE_IN : IOCTL_SCSI_EXECUTE_OUT,
                    FdoExtension->DeviceObject,
                    DataBuffer,
                    DataBufferSize,
                    DataBuffer,
                    DataBufferSize,
                    TRUE,
                    &event,
                    &ioStatusBlock);

        if (!irp) {

            RetryCount = 0;
            IdeLogNoMemoryError(FdoExtension,
                                PdoExtension->TargetId, 
                                NonPagedPool,
                                IoSizeOfIrp(FdoExtension->DeviceObject->StackSize),
                                IDEPORT_TAG_SYNCATAPI_IRP
                                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        irpStack = IoGetNextIrpStackLocation(irp);

        //
        // Fill in SRB fields.
        //

        RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

        irpStack->Parameters.Scsi.Srb = &srb;

        srb.PathId      = PdoExtension->PathId;
        srb.TargetId    = PdoExtension->TargetId;
        srb.Lun         = PdoExtension->Lun;

        srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
        srb.Length = sizeof(SCSI_REQUEST_BLOCK);

        //
        // Set flags to disable synchronous negociation.
        //

        srb.SrbFlags = DataIn ? SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER :
                                SRB_FLAGS_DATA_OUT | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

        if (ByPassBlockedQueue) {
            srb.SrbFlags |= SRB_FLAGS_BYPASS_FROZEN_QUEUE;
        }

        srb.SrbStatus = srb.ScsiStatus = 0;

        srb.NextSrb = 0;

        srb.OriginalRequest = irp;

        //
        // Set timeout to 4 seconds.
        //

        srb.TimeOutValue = 4;

        srb.CdbLength = 6;

        //
        // Enable auto request sense.
        //

        srb.SenseInfoBuffer = senseInfoBuffer;
        srb.SenseInfoBufferLength = senseInfoBufferSize;

        srb.DataBuffer = MmGetMdlVirtualAddress(irp->MdlAddress);
        srb.DataTransferLength = DataBufferSize;

        //
        // Set CDB operation code.
        //
        RtlCopyMemory(srb.Cdb, Cdb, sizeof(CDB));

        //
        // Wait for request to complete.
        //
        if (IoCallDriver(PdoExtension->DeviceObject, irp) == STATUS_PENDING) {

            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }

        if (SRB_STATUS(srb.SrbStatus) != SRB_STATUS_SUCCESS) {

            DebugPrint((1,"IssueSyncAtapiCommand: atapi command failed SRB status %x\n",
                        srb.SrbStatus));

            if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_REQUEST_FLUSHED) {
            
                //
                // we will give it a few more retries if our request
                // got flushed.
                //                                 
                flushCount--;
                if (flushCount) {
                    RetryCount++;  
                }
            }
            
            if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

                status = STATUS_DATA_OVERRUN;

            } else {

                status = STATUS_UNSUCCESSFUL;
                
//                if (SRB_STATUS(srb.SrbStatus) != SRB_STATUS_REQUEST_FLUSHED) {
//                    if (srb.Lun == 0 && Cdb->CDB6INQUIRY.OperationCode == SCSIOP_INQUIRY) {
//                        DebugPrint ((DBG_ALWAYS, "IssueSyncAtapiCommand: inquiry on lun 0 returned unexpected error: srb, status = 0x%x, 0x%x\n", &srb, srb.SrbStatus));
//                        DbgBreakPoint();
//                    }
//                }
            }

            //
            // Unfreeze queue if necessary
            //

            if (srb.SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

                DebugPrint((3, "IssueSyncAtapiCommand: Unfreeze Queue TID %d\n",
                    srb.TargetId));

                //
                // unfreeze queue
                //
                CLRMASK (PdoExtension->LuFlags, PD_QUEUE_FROZEN);

                //
                // restart queue
                //
                KeAcquireSpinLock(&FdoExtension->SpinLock, &currentIrql);
                GetNextLuRequest(FdoExtension, PdoExtension);
                KeLowerIrql(currentIrql);
            }

            if ((srb.SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
                (senseInfoBuffer->SenseKey == SCSI_SENSE_ILLEGAL_REQUEST)) {

                 //
                 // A sense key of illegal request was recieved.  This indicates
                 // that the mech status command is illegal.
                 //

                 status = STATUS_INVALID_DEVICE_REQUEST;

                 //
                 // The command is illegal, no point to keep trying
                 //
                 RetryCount = 0;
            }

        } else {

            status = STATUS_SUCCESS;
        }
    }

    //
    // Free buffers
    //

    ExFreePool(senseInfoBuffer);
    
    if (flushCount != 100) {
        DebugPrint ((DBG_ALWAYS, "IssueSyncAtapiCommand: flushCount is %u\n", flushCount));
    }

    return status;

} // IssueSyncAtapiCommand


ULONG
IdePortQueryNonCdNumLun (
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension,
    IN BOOLEAN ByPassBlockedQueue
)
/*++

Routine Description:

    query number of Luns a device has using the protocol
    defined in the ATAPI Removable Rewritable Spec (SFF-8070i)

Arguments:

    FdoExtension - FDO extension

    PdoExtension - device extension of the PDO to be queried

Return Value:

    Number of logical units

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    SCSI_REQUEST_BLOCK srb;
    CDB cdb;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL currentIrql;
    NTSTATUS status;

    PMODE_PARAMETER_HEADER10 modeParameterHeader;
    PATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES accessCap;
    PATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE opMode;
    ULONG modePageSize;
    ULONG accessCapPageSize;
    ULONG opModePageSize;

	PAGED_CODE();

    if (IsNEC_98) {

        PIDENTIFY_DATA fullIdentifyData;

        fullIdentifyData = &FdoExtension->HwDeviceExtension->IdentifyData[PdoExtension->TargetId];

        if (fullIdentifyData->GeneralConfiguration & 0x80) {
            if (fullIdentifyData->ModelNumber[8]  == 0x44 &&
                fullIdentifyData->ModelNumber[9]  == 0x50 &&
                fullIdentifyData->ModelNumber[10] == 0x31 &&
                fullIdentifyData->ModelNumber[11] == 0x2D ) {

                //
                // Find ATAPI PD drive.
                //

                return 2;
            }
        }
    }

    //
    // compute the size of the mode page needed
    //
    accessCapPageSize =
        sizeof (MODE_PARAMETER_HEADER10) +
        sizeof (ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES);

    opModePageSize =
        sizeof (MODE_PARAMETER_HEADER10) +
        sizeof (ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE);

    if (sizeof(ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES) >=
        sizeof(ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE)) {

        modePageSize = accessCapPageSize;

    } else {

        modePageSize = opModePageSize;
    }

    modeParameterHeader = ExAllocatePool (
                              NonPagedPoolCacheAligned,
                              modePageSize
                              );

    if (modeParameterHeader == NULL) {

        DebugPrint((DBG_ALWAYS,"QueryNonCdNumLun: Can't allocate modeParameterHeader buffer\n"));
        return(0);

    }
    RtlZeroMemory(modeParameterHeader, accessCapPageSize);
    RtlZeroMemory(&cdb, sizeof(CDB));

    //
    // Set CDB operation code.
    //
    cdb.MODE_SENSE10.OperationCode    = SCSIOP_MODE_SENSE10;
    cdb.MODE_SENSE10.PageCode         = ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES_PAGECODE;
    cdb.MODE_SENSE10.Pc               = MODE_SENSE_CURRENT_VALUES;
    cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR) ((accessCapPageSize & 0xff00) >> 8);
    cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR) ((accessCapPageSize & 0x00ff) >> 0);

    //
    // get the removable block access capabilities page
    //
    status = IssueSyncAtapiCommand (
                 FdoExtension,
                 PdoExtension,
                 &cdb,
                 modeParameterHeader,
                 accessCapPageSize,
                 TRUE,
                 3,
                 ByPassBlockedQueue
                 );

    accessCap = (PATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES) (modeParameterHeader + 1);

    if (NT_SUCCESS(status) &&
        (accessCap->PageCode == ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES_PAGECODE)) {

        DebugPrint ((DBG_PNP,
                     "QueryNonCdNumLun: Removable Block Access Capabilities Page:\n"
                     "page save bit:                  0x%x\n"
                     "format progress report support: 0x%x\n"
                     "system floppy device:           0x%x\n"
                     "total LUNs:                     0x%x\n"
                     "in single-Lun mode:             0x%x\n"
                     "non-CD optical deivce:          0x%x\n",
                     accessCap->PSBit,
                     accessCap->SRFP,
                     accessCap->SFLP,
                     accessCap->TotalLun,
                     accessCap->SML,
                     accessCap->NCD
                     ));

        if (accessCap->NCD) {

            //
            // we have a non-CD optical deivce
            //

            RtlZeroMemory(modeParameterHeader, opModePageSize);
            RtlZeroMemory(&cdb, sizeof(CDB));

            //
            // Set CDB operation code.
            //
            cdb.MODE_SENSE10.OperationCode    = SCSIOP_MODE_SENSE10;
            cdb.MODE_SENSE10.PageCode         = ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE_PAGECODE;
            cdb.MODE_SENSE10.Pc               = MODE_SENSE_CURRENT_VALUES;
            cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR) ((opModePageSize & 0xff00) >> 8);
            cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR) ((opModePageSize & 0x00ff) >> 0);

            //
            // get the non-cd drive operation mode page
            //
            status = IssueSyncAtapiCommand (
                         FdoExtension,
                         PdoExtension,
                         &cdb,
                         modeParameterHeader,
                         opModePageSize,
                         TRUE,
                         3,
                         ByPassBlockedQueue
                         );

            opMode = (PATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE) (modeParameterHeader + 1);

            if (NT_SUCCESS(status) &&
                (opMode->PageCode == ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE_PAGECODE)) {

                DebugPrint ((DBG_PNP,
                             "QueryNonCdNumLun: Non-CD device Operation Mode Page:\n"
                             "page save bit:                  0x%x\n"
                             "disable verify for write:       0x%x\n"
                             "Lun for R/W device:             0x%x\n"
                             "multi-Lun mode:                 0x%x\n",
                             opMode->PSBit,
                             opMode->DVW,
                             opMode->SLR,
                             opMode->SLM
                             ));

                RtlZeroMemory(modeParameterHeader, sizeof (MODE_PARAMETER_HEADER10));


                //
                // With mode select, this is reserved and must be 0
                //
                opMode->PSBit = 0;

                //
                // Turn on multi-lun mode
                //
                opMode->SLM = 1;

                //
                // non-CD device shall be Lun 1
                //
                opMode->SLR = 1;

                RtlZeroMemory(&cdb, sizeof(CDB));

                //
                // Set CDB operation code.
                //
                cdb.MODE_SELECT10.OperationCode    = SCSIOP_MODE_SELECT10;
                cdb.MODE_SELECT10.SPBit            = 1; // save page
                cdb.MODE_SELECT10.PFBit            = 1;
                cdb.MODE_SELECT10.ParameterListLength[0] = (UCHAR) ((opModePageSize & 0xff00) >> 8);
                cdb.MODE_SELECT10.ParameterListLength[1] = (UCHAR) ((opModePageSize & 0x00ff) >> 0);

                status = IssueSyncAtapiCommand (
                             FdoExtension,
                             PdoExtension,
                             &cdb,
                             modeParameterHeader,
                             opModePageSize,
                             FALSE,
                             3,
                             ByPassBlockedQueue
                             );

                if (!NT_SUCCESS(status)) {

                    DebugPrint ((DBG_ALWAYS, "IdePortQueryNonCdNumLun: Unable to set non-CD device into dual Lun Mode\n"));
                }
            }
        }
    }

    //
    // Free buffers
    //

    ExFreePool(modeParameterHeader);

    if (!NT_SUCCESS(status)) {

        return 0;

    } else {

        return 2;
    }

} // IdePortQueryNonCdNumLun


VOID
IdeBuildDeviceMap(
    IN PFDO_EXTENSION FdoExtension,
    IN PUNICODE_STRING ServiceKey
    )
/*++

Routine Description:

    The routine takes the inquiry data which has been collected and creates
    a device map for it.

Arguments:

    FdoExtension - FDO extension

    ServiceKey - Suppiles the name of the service key.

Return Value:

    None.

--*/
{

    UNICODE_STRING name;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;
    HANDLE key;
    HANDLE busKey;
    HANDLE targetKey;
    HANDLE lunKey;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    ULONG disposition;
    PWSTR start;
    WCHAR buffer[32];
    UCHAR lastTarget;
    ULONG i;
    ULONG dmaEnableMask;
    PCSTR peripheralType;

    UCHAR             lastBus;
    IDE_PATH_ID       pathId;
    IN PPDO_EXTENSION pdoExtension;

    PAGED_CODE();

    //
    // Create the SCSI key in the device map.
    //

    RtlInitUnicodeString(&name,
                         L"\\Registry\\Machine\\Hardware\\DeviceMap\\Scsi");

    //
    // Initialize the object for the key.
    //

    InitializeObjectAttributes(&objectAttributes,
                               &name,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    //
    // Create the key or open it.
    //

    status = ZwCreateKey(&lunKey,
                         KEY_READ | KEY_WRITE,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING) NULL,
                         REG_OPTION_VOLATILE,
                         &disposition );

    if (!NT_SUCCESS(status)) {
        return;
    }

    status = IdeCreateNumericKey(lunKey,
                                FdoExtension->ScsiPortNumber,
                                L"Scsi Port ",
                                &key);

    ZwClose(lunKey);

    if (!NT_SUCCESS(status)) {
        return;
    }

#ifdef IDE_MEASURE_BUSSCAN_SPEED

    RtlInitUnicodeString(&name, L"FirstBusScanTimeInMs");

    status = ZwSetValueKey(key,
                           &name,
                           0,
                           REG_DWORD,
                           &FdoExtension->BusScanTime,
                           sizeof(ULONG));

#endif // IDE_MEASURE_BUSSCAN_SPEED

    //
    // Add DMA enable mask value.
    //
    dmaEnableMask = 0;
    for (i=0; i<FdoExtension->HwDeviceExtension->MaxIdeDevice; i++) {

        if (FdoExtension->HwDeviceExtension->DeviceFlags[i] & DFLAGS_USE_DMA) {

            dmaEnableMask |= (1 << i);

        }
    }

    RtlInitUnicodeString(&name, L"DMAEnabled");

    status = ZwSetValueKey(key,
                           &name,
                           0,
                           REG_DWORD,
                           &dmaEnableMask,
                           4);

    //
    // Add Interrupt value.
    //

//    if (FdoExtension->InterruptLevel) {
//
//        RtlInitUnicodeString(&name, L"Interrupt");
//
//        status = ZwSetValueKey(key,
//                               &name,
//                               0,
//                               REG_DWORD,
//                               &FdoExtension->InterruptLevel,
//                               4);
//    }
//
//    //
//    // Add base IO address value.
//    //
//
//    if (FdoExtension->IdeResource.TranslatedCommandBaseAddress) {
//
//        RtlInitUnicodeString(&name, L"IOAddress");
//
//        status = ZwSetValueKey(key,
//                               &name,
//                               0,
//                               REG_DWORD,
//                               &FdoExtension->IdeResource.TranslatedCommandBaseAddress,
//                               4);
//    }

    if (ServiceKey != NULL) {

        //
        // Add identifier value. This value is equal to the name of the driver
        // in the from the service key. Note the service key name is not NULL
        // terminated.
        //

        RtlInitUnicodeString(&name, L"Driver");

        //
        // Get the name of the driver from the service key name.
        //

        start = (PWSTR) ((PCHAR) ServiceKey->Buffer + ServiceKey->Length);
        start--;
        while (*start != L'\\' && start > ServiceKey->Buffer) {
            start--;
        }

        if (*start != L'\\') {
            ZwClose(key);
            return;
        }

        start++;
        for (i = 0; i < 31; i++) {

            buffer[i] = *start++;

            if (start >= ServiceKey->Buffer + ServiceKey->Length / sizeof(wchar_t)) {
                break;
            }
        }

        i++;
        buffer[i] = L'\0';

        status = ZwSetValueKey(key,
                               &name,
                               0,
                               REG_SZ,
                               buffer,
                               (i + 1) * sizeof(wchar_t));

        if (!NT_SUCCESS(status)) {
            ZwClose(key);
            return;
        }
    }

    //
    // Cycle through each of the lun.
    //
    lastBus = 0xff;
    pathId.l = 0;
    busKey = 0;
    targetKey = 0;
    lunKey = 0;
    while (pdoExtension = NextLogUnitExtensionWithTag (
                              FdoExtension,
                              &pathId,
                              FALSE,
                              IdeBuildDeviceMap
                              )) {

        //
        // Create a key entry for the bus.
        //
        if (lastBus != pathId.b.Path) {

            if (busKey) {

                ZwClose(busKey);
                busKey = 0;
            }

            if (targetKey) {

                ZwClose(targetKey);
                targetKey = 0;
            }

            status = IdeCreateNumericKey(key, pathId.b.Path, L"Scsi Bus ", &busKey);

            if (!NT_SUCCESS(status)) {
                break;
            }

            lastBus = (UCHAR) pathId.b.Path;

            //
            // Create a key entry for the Scsi bus adapter.
            //

            status = IdeCreateNumericKey(busKey,
                                    IDE_PSUEDO_INITIATOR_ID,
                                    L"Initiator Id ",
                                    &targetKey);

            if (!NT_SUCCESS(status)) {
                break;
            }

            lastTarget = IDE_PSUEDO_INITIATOR_ID;
        }

        //
        // Process the data for the logical units.
        //

        //
        // If this is a new target Id then create a new target entry.
        //

        if (lastTarget != pdoExtension->TargetId) {

            ZwClose(targetKey);
            targetKey = 0;

            status = IdeCreateNumericKey(busKey,
                                        pdoExtension->TargetId,
                                        L"Target Id ",
                                        &targetKey);

            if (!NT_SUCCESS(status)) {
                break;
            }

            lastTarget = pdoExtension->TargetId;
        }

        //
        // Create the Lun entry.
        //

        status = IdeCreateNumericKey(targetKey,
                                    pdoExtension->Lun,
                                    L"Logical Unit Id ",
                                    &lunKey);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Create identifier value.
        //

        RtlInitUnicodeString(&name, L"Identifier");

        //
        // Get the Identifier from the inquiry data.
        //
        RtlInitAnsiString(&ansiString, pdoExtension->FullVendorProductId);

        status = RtlAnsiStringToUnicodeString(&unicodeString,
                                              &ansiString,
                                              TRUE);

        if (!NT_SUCCESS(status)) {
            break;
        }

        status = ZwSetValueKey(lunKey,
                               &name,
                               0,
                               REG_SZ,
                               unicodeString.Buffer,
                               unicodeString.Length + sizeof(wchar_t));

        RtlFreeUnicodeString(&unicodeString);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Determine the perpherial type.
        //
        peripheralType = IdePortGetPeripheralIdString (
                             pdoExtension->ScsiDeviceType
                             );
        if (!peripheralType) {

            peripheralType = "OtherPeripheral";
        }

        RtlInitAnsiString(&ansiString, peripheralType);

        unicodeString.MaximumLength = (USHORT) RtlAnsiStringToUnicodeSize(&ansiString) + sizeof(WCHAR);
        unicodeString.Length = 0;
        unicodeString.Buffer = ExAllocatePool (PagedPool, unicodeString.MaximumLength);

        if (unicodeString.Buffer) {

            status = RtlAnsiStringToUnicodeString(
                        &unicodeString,
                        &ansiString,
                        FALSE
                        );

            if (NT_SUCCESS(status)) {

                //
                // Set type value.
                //

                RtlInitUnicodeString(&name, L"Type");

                unicodeString.Buffer[unicodeString.Length / sizeof (WCHAR)] = L'\0';

                status = ZwSetValueKey(lunKey,
                                       &name,
                                       0,
                                       REG_SZ,
                                       unicodeString.Buffer,
                                       unicodeString.Length + sizeof (WCHAR));

                ExFreePool (unicodeString.Buffer);
            }

        } else {

            status = STATUS_NO_MEMORY;
        }

        ZwClose(lunKey);
        lunKey = 0;

        if (!NT_SUCCESS(status)) {
            break;
        }

        UnrefLogicalUnitExtensionWithTag (
            FdoExtension,
            pdoExtension,
            IdeBuildDeviceMap
            );
        pdoExtension = NULL;
    }

    if (lunKey) {

        ZwClose(lunKey);
    }

    if (busKey) {

        ZwClose(busKey);
    }

    if (targetKey) {

        ZwClose(targetKey);
    }

    if (pdoExtension) {

        UnrefLogicalUnitExtensionWithTag (
            FdoExtension,
            pdoExtension,
            IdeBuildDeviceMap
            );
    }

    ZwClose(key);
} // IdeBuildDeviceMap

NTSTATUS
IdeCreateNumericKey(
    IN  HANDLE  Root,
    IN  ULONG   Name,
    IN  PWSTR   Prefix,
    OUT PHANDLE NewKey
)
/*++

Routine Description:

    This function creates a registry key.  The name of the key is a string
    version of numeric value passed in.

Arguments:

    RootKey - Supplies a handle to the key where the new key should be inserted.

    Name - Supplies the numeric value to name the key.

    Prefix - Supplies a prefix name to add to name.

    NewKey - Returns the handle for the new key.

Return Value:

   Returns the status of the operation.

--*/

{

    UNICODE_STRING string;
    UNICODE_STRING stringNum;
    OBJECT_ATTRIBUTES objectAttributes;
    WCHAR bufferNum[16];
    WCHAR buffer[64];
    ULONG disposition;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Copy the Prefix into a string.
    //

    string.Length = 0;
    string.MaximumLength=64;
    string.Buffer = buffer;

    RtlInitUnicodeString(&stringNum, Prefix);

    RtlCopyUnicodeString(&string, &stringNum);

    //
    // Create a port number key entry.
    //

    stringNum.Length = 0;
    stringNum.MaximumLength = 16;
    stringNum.Buffer = bufferNum;

    status = RtlIntegerToUnicodeString(Name, 10, &stringNum);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Append the prefix and the numeric name.
    //

    RtlAppendUnicodeStringToString(&string, &stringNum);

    InitializeObjectAttributes( &objectAttributes,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                Root,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwCreateKey(NewKey,
                        KEY_READ | KEY_WRITE,
                        &objectAttributes,
                        0,
                        (PUNICODE_STRING) NULL,
                        REG_OPTION_VOLATILE,
                        &disposition );

    return(status);
} // IdeCreateNumericKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\internal.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    internal.c

Abstract:

    This is the NT SCSI port driver.  This file contains the internal
    code.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "ideport.h"


NTSTATUS
IdeSendMiniPortIoctl(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    );

NTSTATUS
IdeSendPassThrough (
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    );

NTSTATUS
IdeGetInquiryData(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
IdeClaimLogicalUnit(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
IdeRemoveDevice(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

VOID
IdeLogResetError(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK  Srb,
    IN ULONG UniqueId
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(NONPAGE, IdePortDeviceControl)
#pragma alloc_text(PAGE, IdeSendMiniPortIoctl)
#pragma alloc_text(PAGE, IdeGetInquiryData)
#pragma alloc_text(PAGE, IdeSendPassThrough)
#pragma alloc_text(PAGE, IdeClaimLogicalUnit)
#pragma alloc_text(PAGE, IdeRemoveDevice)

#endif

#if DBG
#define CheckIrql() {\
    if (saveIrql != KeGetCurrentIrql()){\
        DebugPrint((1, "saveIrql=%x, current=%x\n", saveIrql, KeGetCurrentIrql()));\
        ASSERT(FALSE);}\
}
#else
#define CheckIrql()
#endif

//
// Routines start
//

NTSTATUS
IdePortDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Address of device object.
    Irp - Address of I/O request packet.

Return Value:

    Status.

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION_HEADER doExtension;
    PFDO_EXTENSION deviceExtension;
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    NTSTATUS status;
    RESET_CONTEXT resetContext;
    KIRQL currentIrql;
    KIRQL saveIrql=KeGetCurrentIrql();

#if DBG
    UCHAR savedCdb[16];
    ULONG ki;
#endif


    doExtension = DeviceObject->DeviceExtension;
    if (doExtension->AttacheeDeviceObject == NULL) {

        //
        // This is a PDO
        //
        PPDO_EXTENSION pdoExtension = (PPDO_EXTENSION) doExtension;

        srb->PathId     = (UCHAR) pdoExtension->PathId;
        srb->TargetId   = (UCHAR) pdoExtension->TargetId;
        srb->Lun        = (UCHAR) pdoExtension->Lun;

        ((PCDB) (srb->Cdb))->CDB6GENERIC.LogicalUnitNumber = srb->Lun;

        CheckIrql();
        return IdePortDispatch(
                   pdoExtension->ParentDeviceExtension->DeviceObject,
                   Irp
                   );

    } else {

        //
        // This is a FDO;
        //
        deviceExtension = (PFDO_EXTENSION) doExtension;
    }

    //
    // Init SRB Flags for IDE
    //
    INIT_IDE_SRB_FLAGS (srb);

    //
    // get the target device object extension
    //
    logicalUnit = RefLogicalUnitExtensionWithTag(
                      deviceExtension,
                      srb->PathId,
                      srb->TargetId,
                      srb->Lun,
                      TRUE,
                      Irp
                      );

    if (logicalUnit == NULL) {

        DebugPrint((1, "IdePortDispatch: Bad logical unit address.\n"));

        //
        // Fail the request. Set status in Irp and complete it.
        //

        srb->SrbStatus = SRB_STATUS_NO_DEVICE;
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        CheckIrql();
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        CheckIrql();
        return STATUS_NO_SUCH_DEVICE;
    }
    //
    // special flag for tape device
    //
    TEST_AND_SET_SRB_FOR_RDP(logicalUnit->ScsiDeviceType, srb);

    //
    // hang the logUnitExtension off the Irp
    //
    IDEPORT_PUT_LUNEXT_IN_IRP (irpStack, logicalUnit);

    //
    // check for DMA candidate
    // default (0) is DMA candidate
    //
    if (SRB_IS_DMA_CANDIDATE(srb)) {

        if (srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) {

            ULONG deviceFlags = deviceExtension->HwDeviceExtension->DeviceFlags[srb->TargetId];

            if (deviceFlags & DFLAGS_ATAPI_DEVICE) {

                if (srb->Cdb[0] == SCSIOP_MODE_SENSE) {

                    if (!(deviceFlags & DFLAGS_TAPE_DEVICE)) {

                        CheckIrql();
                        return DeviceAtapiModeSense(logicalUnit, Irp);

                    }

                    //
                    // we should do PIO for mode sense/select
                    //
                    MARK_SRB_AS_PIO_CANDIDATE(srb);


                } else if (srb->Cdb[0] == SCSIOP_MODE_SELECT) {
                    
                    if (!(deviceFlags & DFLAGS_TAPE_DEVICE)) {

                        CheckIrql();
                        return DeviceAtapiModeSelect(logicalUnit, Irp);

                    }

                    MARK_SRB_AS_PIO_CANDIDATE(srb);

                } else if (srb->Cdb[0] == SCSIOP_REQUEST_SENSE) {

                    //
                    // SCSIOP_REQUEST_SENSE
                    // ALi can't handle odd word udma xfer
                    // safest thing to do is do pio
                    //
                    MARK_SRB_AS_PIO_CANDIDATE(srb);

                } else if ((srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) ||
                           (srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH)) {

                    MARK_SRB_AS_PIO_CANDIDATE(srb);

                } else if ((srb->Cdb[0] == ATAPI_MODE_SENSE)  ||
                           (srb->Cdb[0] == ATAPI_MODE_SELECT) ||
                           (srb->Cdb[0] == SCSIOP_INQUIRY)    ||
                           (srb->Cdb[0] == SCSIOP_GET_EVENT_STATUS)) {

                    MARK_SRB_AS_PIO_CANDIDATE(srb);

                }

            } else { // ATA deivce

                if ((srb->Cdb[0] != SCSIOP_READ) && (srb->Cdb[0] != SCSIOP_WRITE)) {

                    //
                    // for ATA device, we can only DMA with SCSIOP_READ and SCSIOP_WRITE
                    //
                    MARK_SRB_AS_PIO_CANDIDATE(srb);

                    if (srb->Cdb[0] == SCSIOP_READ_CAPACITY) {

                        CheckIrql();
                        return DeviceIdeReadCapacity (logicalUnit, Irp);

                    } else if (srb->Cdb[0] == SCSIOP_MODE_SENSE) {

                        CheckIrql();
                        return DeviceIdeModeSense (logicalUnit, Irp);

                    } else if (srb->Cdb[0] == SCSIOP_MODE_SELECT) {

                        CheckIrql();
                        return DeviceIdeModeSelect (logicalUnit, Irp);
                    }
                }
            }


            //
            //Check with the miniport (Special cases)
            //


            ASSERT (doExtension->AttacheeDeviceObject);
            ASSERT (srb->TargetId >=0);

#if DBG
                for (ki=0;ki<srb->CdbLength;ki++) {
                    savedCdb[ki]=srb->Cdb[ki];
                }
#endif

            //Check for NULL.
            if (deviceExtension->TransferModeInterface.UseDma){
                if (!((deviceExtension->TransferModeInterface.UseDma)
                      (deviceExtension->TransferModeInterface.VendorSpecificDeviceExtension,
                                                  (PVOID)(srb->Cdb), srb->TargetId))) {
                     MARK_SRB_AS_PIO_CANDIDATE(srb);
                }
            }

#if DBG
            for (ki=0;ki<srb->CdbLength;ki++) {
                if (savedCdb[ki] != srb->Cdb[ki]) {
                    DebugPrint((DBG_ALWAYS,
                               "Miniport modified the Cdb\n"));
                    ASSERT(FALSE);
                }
            }
#endif

            if ((logicalUnit->DmaTransferTimeoutCount >= PDO_DMA_TIMEOUT_LIMIT) ||
                (logicalUnit->CrcErrorCount >= PDO_UDMA_CRC_ERROR_LIMIT)) {

                //
                // broken hardware
                //
                MARK_SRB_AS_PIO_CANDIDATE(srb);
            }

        } else {

            MARK_SRB_AS_PIO_CANDIDATE(srb);
        }
    }

    switch (srb->Function) {

        case SRB_FUNCTION_SHUTDOWN:

            DebugPrint((1, "IdePortDispatch: SRB_FUNCTION_SHUTDOWN...\n"));

        // ISSUE: 08/30/2000: disable/restore MSN settings

		case SRB_FUNCTION_FLUSH:
			{
            ULONG dFlags = deviceExtension->HwDeviceExtension->DeviceFlags[srb->TargetId];

			//
			// for IDE devices, complete the request with status success if
			// the device doesn't support the flush cache command
			//
			if (!(dFlags & DFLAGS_ATAPI_DEVICE) &&
				((logicalUnit->FlushCacheTimeoutCount >= PDO_FLUSH_TIMEOUT_LIMIT) ||
				(logicalUnit->
					ParentDeviceExtension->
					HwDeviceExtension->
					DeviceParameters[logicalUnit->TargetId].IdeFlushCommand
				 == IDE_COMMAND_NO_FLUSH))) {

				srb->SrbStatus = SRB_STATUS_SUCCESS;
				status = STATUS_SUCCESS;
                CheckIrql();
                break;
			}

			DebugPrint((1, 
						"IdePortDispatch: SRB_FUNCTION_%x to target %x\n", 
						srb->Function,
						srb->TargetId
						));

			//
			// Fall thru to  execute_scsi
			//

			}

        case SRB_FUNCTION_ATA_POWER_PASS_THROUGH:
        case SRB_FUNCTION_ATA_PASS_THROUGH:
        case SRB_FUNCTION_IO_CONTROL:
        case SRB_FUNCTION_EXECUTE_SCSI:

            if (logicalUnit->PdoState & PDOS_DEADMEAT) {

                //
                // Fail the request. Set status in Irp and complete it.
                //
                srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                status = STATUS_NO_SUCH_DEVICE;
                CheckIrql();
                break;
            }

            if (srb->SrbFlags & SRB_FLAGS_NO_KEEP_AWAKE) {

                if (logicalUnit->DevicePowerState != PowerDeviceD0) {

                    DebugPrint ((DBG_POWER, "0x%x powered down.  failing SRB_FLAGS_NO_KEEP_AWAKE srb 0x%x\n", logicalUnit, srb));

                    srb->SrbStatus = SRB_STATUS_NOT_POWERED;
                    status = STATUS_NO_SUCH_DEVICE;
                    CheckIrql();
                    break;
                }
            }

            //
            // Mark Irp status pending.
            //
            IoMarkIrpPending(Irp);

            if (srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) {

                //
                // Call start io directly.  This will by-pass the
                // frozen queue.
                //

                DebugPrint((DBG_READ_WRITE,
                    "IdePortDispatch: Bypass frozen queue, IRP %lx\n",
                    Irp));

                IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);

                CheckIrql();
                return STATUS_PENDING;

            } else {

                BOOLEAN inserted;

                //
                // Queue the packet normally.
                //
                status = IdePortInsertByKeyDeviceQueue (
                             logicalUnit,
                             Irp,
                             srb->QueueSortKey,
                             &inserted
                             );

                if (NT_SUCCESS(status) && inserted) {

                    //
                    // irp is queued
                    //
                } else {

                    //
                    // irp is ready to go
                    //

                    //
                    // Clear the active flag.  If there is another request, the flag will be
                    // set again when the request is passed to the miniport.
                    //
                    CLRMASK (logicalUnit->LuFlags, PD_LOGICAL_UNIT_IS_ACTIVE);

                    //
                    // Clear the retry count.
                    //

                    logicalUnit->RetryCount = 0;

                    //
                    // Queue is empty; start request.
                    //
                    IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);
                }

                CheckIrql();
                return STATUS_PENDING;
            }

        case SRB_FUNCTION_RELEASE_QUEUE:

            DebugPrint((2,"IdePortDispatch: SCSI unfreeze queue TID %d\n",
                srb->TargetId));

            //
            // Acquire the spinlock to protect the flags structure and the saved
            // interrupt context.
            //

            KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);
            KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

            //
            // Make sure the queue is frozen.
            //

            if (!(logicalUnit->LuFlags & PD_QUEUE_FROZEN)) {

                DebugPrint((DBG_WARNING,
                            "IdePortDispatch:  Request to unfreeze an unfrozen queue!\n"
                            ));

                KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);
                srb->SrbStatus = SRB_STATUS_SUCCESS;
                status = STATUS_SUCCESS;
                CheckIrql();
                break;

            }

            CLRMASK (logicalUnit->LuFlags, PD_QUEUE_FROZEN);

            //
            // If there is not an untagged request running then start the
            // next request for this logical unit.  Otherwise free the
            // spin lock.
            //

            if (logicalUnit->SrbData.CurrentSrb == NULL) {

                //
                // GetNextLuRequest frees the spinlock.
                //

                GetNextLuRequest(deviceExtension, logicalUnit);
                KeLowerIrql(currentIrql);

            } else {

                DebugPrint((DBG_WARNING,
                            "IdePortDispatch: Request to unfreeze queue with active request\n"
                            ));
                KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);

            }


            srb->SrbStatus = SRB_STATUS_SUCCESS;
            status = STATUS_SUCCESS;

            CheckIrql();
            break;

        case SRB_FUNCTION_RESET_BUS: {

            PATA_PASS_THROUGH  ataPassThroughData;

            ataPassThroughData = ExAllocatePool(NonPagedPool, sizeof(ATA_PASS_THROUGH));

            if (ataPassThroughData == NULL) {
                srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
                srb->InternalStatus=STATUS_INSUFFICIENT_RESOURCES;
                status=STATUS_INSUFFICIENT_RESOURCES;
                IdeLogNoMemoryError(deviceExtension,
                                    logicalUnit->TargetId,
                                    NonPagedPool,
                                    sizeof(ATA_PASS_THROUGH),
                                    IDEPORT_TAG_DISPATCH_RESET
                                    );
                CheckIrql();
                break;
            }

            RtlZeroMemory (ataPassThroughData, sizeof (*ataPassThroughData));
            ataPassThroughData->IdeReg.bReserved   = ATA_PTFLAGS_BUS_RESET;

            status = IssueSyncAtaPassThroughSafe (
                         logicalUnit->ParentDeviceExtension,
                         logicalUnit,
                         ataPassThroughData,
                         FALSE,
                         FALSE,
                         30,
                         FALSE
                         );

            if (NT_SUCCESS(status)) {

                IdeLogResetError(deviceExtension,
                                srb,
                                ('R'<<24) | 256);

                srb->SrbStatus = SRB_STATUS_SUCCESS;

            } else {

                //
                // fail to send ata pass through
                //
                srb->SrbStatus = SRB_STATUS_ERROR;
                if (status==STATUS_INSUFFICIENT_RESOURCES) {
                    srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
                    srb->InternalStatus=STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            CheckIrql();
            break;

        }

            //
            // Acquire the spinlock to protect the flags structure and the saved
            // interrupt context.
            //
            /*++
            KeAcquireSpinLock(&deviceExtension->SpinLock, &currentIrql);

            resetContext.DeviceExtension = deviceExtension;
            resetContext.PathId = srb->PathId;
            resetContext.NewResetSequence = TRUE;
            resetContext.ResetSrb = NULL;

            if (!KeSynchronizeExecution(deviceExtension->InterruptObject,
                                        IdeResetBusSynchronized,
                                        &resetContext)) {

                DebugPrint((1,"IdePortDispatch: Reset failed\n"));
                srb->SrbStatus = SRB_STATUS_PHASE_SEQUENCE_FAILURE;
                status = STATUS_IO_DEVICE_ERROR;

            } else {

                IdeLogResetError(deviceExtension,
                                srb,
                                ('R'<<24) | 256);

                srb->SrbStatus = SRB_STATUS_SUCCESS;
                status = STATUS_SUCCESS;
            }

            KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);
            CheckIrql();
            break;
            --*/


        case SRB_FUNCTION_ABORT_COMMAND:

            DebugPrint((1, "IdePortDispatch: SCSI Abort or Reset command\n"));

            //
            // Mark Irp status pending.
            //

            IoMarkIrpPending(Irp);

            //
            // Don't queue these requests in the logical unit
            // queue, rather queue them to the adapter queue.
            //

            KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);

            IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);

            KeLowerIrql(currentIrql);

            CheckIrql();
            return STATUS_PENDING;

            break;

        case SRB_FUNCTION_FLUSH_QUEUE:

            DebugPrint((1, "IdePortDispatch: SCSI flush queue command\n"));

            status = IdePortFlushLogicalUnit (
                         deviceExtension,
                         logicalUnit,
                         FALSE
                         );
            CheckIrql();
            break;

        case SRB_FUNCTION_ATTACH_DEVICE:
        case SRB_FUNCTION_CLAIM_DEVICE:
        case SRB_FUNCTION_RELEASE_DEVICE:

            status = IdeClaimLogicalUnit(deviceExtension, Irp);
            CheckIrql();
            break;

        case SRB_FUNCTION_REMOVE_DEVICE:

            //
            // decrement the refcount before remove the device
            //
            UnrefLogicalUnitExtensionWithTag(
                deviceExtension,
                logicalUnit,
                Irp
                );

            status = IdeRemoveDevice(deviceExtension, Irp);
            Irp->IoStatus.Status = status;
            CheckIrql();
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            CheckIrql();
            return status;

        default:

            //
            // Found unsupported SRB function.
            //

            DebugPrint((1,"IdePortDispatch: Unsupported function, SRB %lx\n",
                srb));

            srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            status = STATUS_INVALID_DEVICE_REQUEST;
            CheckIrql();
            break;
    }


    //
    // Set status in Irp.
    //

    Irp->IoStatus.Status = status;

    //
    // Decrement the logUnitExtension reference count
    //
    CheckIrql();
    UnrefLogicalUnitExtensionWithTag(
        deviceExtension,
        logicalUnit,
        Irp
        );

    IDEPORT_PUT_LUNEXT_IN_IRP (irpStack, NULL);

    //
    // Complete request at raised IRQ.
    //
    CheckIrql();
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    CheckIrql();

    return status;

} // end IdePortDispatch()



VOID
IdePortStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Supplies pointer to Adapter device object.
    Irp - Supplies a pointer to an IRP.

Return Value:

    Nothing.

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    PFDO_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSRB_DATA srbData;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    LONG interlockResult;
    NTSTATUS status;

    ULONG deviceFlags = deviceExtension->HwDeviceExtension->DeviceFlags[srb->TargetId];
    PCDB cdb;

    LARGE_INTEGER timer;

    LogStartTime(TimeStartIo, &timer);

    DebugPrint((3,"IdePortStartIo: Enter routine\n"));

    //
    // Set the default flags in the SRB.
    //

    srb->SrbFlags |= deviceExtension->SrbFlags;

    //
    // Get logical unit extension.
    //

    logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);

    if (!(srb->SrbFlags & SRB_FLAGS_NO_KEEP_AWAKE) &&
        (srb->Function != SRB_FUNCTION_ATA_POWER_PASS_THROUGH) &&
        (logicalUnit->IdleCounter)) {

        //
        // Tell Po that we are busy
        //
        PoSetDeviceBusy (logicalUnit->IdleCounter);
    }

    DebugPrint((2,"IdePortStartIo:  Irp 0x%8x Srb 0x%8x DataBuf 0x%8x Len 0x%8x\n", Irp, srb, srb->DataBuffer, srb->DataTransferLength));

    //
    // No special resources are required.  Set the SRB data to the
    // structure in the logical unit extension, set the queue tag value
    // to the untagged value, and clear the SRB extension.
    //

    srbData = &logicalUnit->SrbData;

    //
    // Update the sequence number for this request if there is not already one
    // assigned.
    //

    if (!srbData->SequenceNumber) {

        //
        // Assign a sequence number to the request and store it in the logical
        // unit.
        //

        srbData->SequenceNumber = deviceExtension->SequenceNumber++;

    }

    //
    // If this is not an ABORT request the set the current srb.
    // NOTE: Lock should be held here!
    //

    if (srb->Function != SRB_FUNCTION_ABORT_COMMAND) {

        ASSERT(srbData->CurrentSrb == NULL);
        srbData->CurrentSrb = srb;
        ASSERT(srbData->CurrentSrb);

        if ((deviceExtension->HwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_USE_DMA) &&
            SRB_IS_DMA_CANDIDATE(srb)) {

            MARK_SRB_FOR_DMA(srb);

        } else {

            MARK_SRB_FOR_PIO(srb);
        }

     } else {

        //
        // Only abort requests can be started when there is a current request
        // active.
        //

        ASSERT(logicalUnit->AbortSrb == NULL);
        logicalUnit->AbortSrb = srb;
    }
    
    //
    // Log the command
    //
    IdeLogStartCommandLog(srbData);

    //
    // Flush the data buffer if necessary.
    //

    if (srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) {

        //
        // Save the MDL virtual address.
        //

        srbData->SrbDataOffset = MmGetMdlVirtualAddress(Irp->MdlAddress);

        do {

            //
            // Determine if the adapter needs mapped memory.
            //
            if (!SRB_USES_DMA(srb)) { // PIO

                if (Irp->MdlAddress) {

                    //
                    // Get the mapped system address and
                    // calculate offset into MDL.
                    //
                    srbData->SrbDataOffset = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, HighPagePriority);

					if ((srbData->SrbDataOffset == NULL) &&
						(deviceExtension->ReservedPages != NULL)) {

                        KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

						//
						// this would set the appropriate flags in the device extension
						// and srbData only when the call succeeds.
						//
						srbData->SrbDataOffset = IdeMapLockedPagesWithReservedMapping(deviceExtension,
																					  srbData,
																					  Irp->MdlAddress
																					  );

						//
						// if there is another active request using the reserved pages
						// mark this one pending. When the active request completes this
						// one will be picked up
						//
						if (srbData->SrbDataOffset == (PVOID)-1) {

							DebugPrint ((1,
										 "Irp 0x%x marked pending\n",
										 Irp
										 ));

							//
							// remove the current Srb
							//
							srbData->CurrentSrb = NULL;

							ASSERT(DeviceObject->CurrentIrp == Irp);
							SETMASK(deviceExtension->Flags, PD_PENDING_DEVICE_REQUEST);

							KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
							return;
						}

						KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                        
					}

                    if (srbData->SrbDataOffset == NULL) {

						deviceExtension->LastMemoryFailure += IDEPORT_TAG_STARTIO_MDL;

                        srbData->CurrentSrb = NULL;

                        //
                        // This is the correct status for insufficient resources
                        //
                        srb->SrbStatus=SRB_STATUS_INTERNAL_ERROR;
                        srb->InternalStatus=STATUS_INSUFFICIENT_RESOURCES;
                        Irp->IoStatus.Status=STATUS_INSUFFICIENT_RESOURCES;

                        IdeLogNoMemoryError(deviceExtension,
                                            logicalUnit->TargetId,
                                            NonPagedPool,
                                            sizeof(MDL),
                                            IDEPORT_TAG_STARTIO_MDL
                                            );
                        //
                        // Clear the device busy flag
                        //
                        IoStartNextPacket(DeviceObject, FALSE);

                        //
                        // Acquire spin lock to protect the flags
                        //
                        KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

                        //
                        // Get the next request, if this request does not
                        // bypass frozen queue. We don't want to start the
                        // next request, if the queue is frozen.
                        //
                        if (!(srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {

                            //
                            // This flag needs to be set for getnextlu to work
                            //
                            logicalUnit->LuFlags |= PD_LOGICAL_UNIT_IS_ACTIVE;

                            //
                            // Retrieve the next request and give it to the fdo
                            // This releases the spinlock
                            //
                            GetNextLuRequest(deviceExtension, logicalUnit);
                        }
                        else {

                            KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                        }

                        //
                        // Decrement the logUnitExtension reference count
                        //
                        UnrefLogicalUnitExtensionWithTag(
                            deviceExtension,
                            logicalUnit,
                            Irp
                            );

                        //
                        // Complete the request
                        //
                        IoCompleteRequest(Irp, IO_NO_INCREMENT);

                        return;
                    }

                    srb->DataBuffer = srbData->SrbDataOffset +
                        (ULONG)((PUCHAR)srb->DataBuffer -
                        (PCCHAR)MmGetMdlVirtualAddress(Irp->MdlAddress));
                }

                IdePortAllocateAccessToken (DeviceObject);

                status = STATUS_SUCCESS;

            } else { // DMA

                //
                // If the buffer is not mapped then the I/O buffer must be flushed.
                //

                KeFlushIoBuffers(Irp->MdlAddress,
                                 (BOOLEAN) (srb->SrbFlags & SRB_FLAGS_DATA_IN ? TRUE : FALSE),
                                 TRUE);

#if defined (FAKE_BMSETUP_FAILURE)

                if (!(FailBmSetupCount++ % FAKE_BMSETUP_FAILURE)) {

                    status = STATUS_UNSUCCESSFUL;

                } else {

#endif // FAKE_BMSETUP_FAILURE
                    status = deviceExtension->HwDeviceExtension->BusMasterInterface.BmSetup (
                                    deviceExtension->HwDeviceExtension->BusMasterInterface.Context,
                                    srb->DataBuffer,
                                    srb->DataTransferLength,
                                    Irp->MdlAddress,
                                    (BOOLEAN) (srb->SrbFlags & SRB_FLAGS_DATA_IN),
                                    IdePortAllocateAccessToken,
                                    DeviceObject
                                    );

#if defined (FAKE_BMSETUP_FAILURE)
                }
#endif // FAKE_BMSETUP_FAILURE

                if (!NT_SUCCESS(status)) {

                    DebugPrint((1,
                                "IdePortStartIo: IoAllocateAdapterChannel failed(%x). try pio for srb %x\n",
                                status, srb));

                    //
                    // out of resource for DMA, try PIO
                    //
                    MARK_SRB_FOR_PIO(srb);
                }
            }

        } while (!NT_SUCCESS(status));

    } else {

        IdePortAllocateAccessToken (DeviceObject);
    }

    LogStopTime(TimeStartIo, &timer, 0);
    return;

} // end IdePortStartIO()




BOOLEAN
IdePortInterrupt(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:


Arguments:

    Interrupt

    Device Object

Return Value:

    Returns TRUE if interrupt expected.

--*/

{
    PFDO_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    BOOLEAN returnValue;
    LARGE_INTEGER timer;

    UNREFERENCED_PARAMETER(Interrupt);

#ifdef ENABLE_ATAPI_VERIFIER
    ViAtapiInterrupt(deviceExtension);
#endif

    LogStartTime(TimeIsr, &timer);
    returnValue = AtapiInterrupt(deviceExtension->HwDeviceExtension);
    LogStopTime(TimeIsr, &timer, 100);

    //
    // Check to see if a DPC needs to be queued.
    //
    if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

        IoRequestDpc(deviceExtension->DeviceObject, NULL, NULL);

    }
    return(returnValue);

} // end IdePortInterrupt()

VOID
IdePortCompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    Dpc
    DeviceObject
    Irp - not used
//    Context - not used

Return Value:

    None.

--*/

{
    PFDO_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    INTERRUPT_CONTEXT interruptContext;
    INTERRUPT_DATA savedInterruptData;
    BOOLEAN callStartIo;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSRB_DATA srbData;
    LONG interlockResult;
    LARGE_INTEGER timeValue;
    PMDL mdl;

    LARGE_INTEGER timer;
    LogStartTime(TimeDpc, &timer);


    UNREFERENCED_PARAMETER(Dpc);


    //
    // Acquire the spinlock to protect flush adapter buffers information.
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

    //
    // Get the interrupt state.  This copies the interrupt state to the
    // saved state where it can be processed.  It also clears the interrupt
    // flags.
    //


    interruptContext.DeviceExtension = deviceExtension;
    interruptContext.SavedInterruptData = &savedInterruptData;

    if (!KeSynchronizeExecution(deviceExtension->InterruptObject,
                                IdeGetInterruptState,
                                &interruptContext)) {

        //
        // There is no work to do so just return.
        //
        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        LogStopTime(TimeDpc, &timer, 0);
        return;
    }


    //
    // We only support one request at a time, so we can just check
    // the first completed request to determine whether we use DMA
    // and whether we need to flush DMA
    //
    if (savedInterruptData.CompletedRequests != NULL) {

        PSCSI_REQUEST_BLOCK srb;

        srbData = savedInterruptData.CompletedRequests;
        ASSERT(srbData->CurrentSrb);


        srb     = srbData->CurrentSrb;

        if (srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) {

            if (SRB_USES_DMA(srb)) {

                deviceExtension->HwDeviceExtension->BusMasterInterface.BmFlush (
                    deviceExtension->HwDeviceExtension->BusMasterInterface.Context
                    );
            }
        }
    }

    //
    // check for empty channels
    //
    if (savedInterruptData.InterruptFlags & PD_ALL_DEVICE_MISSING) {

        PPDO_EXTENSION pdoExtension;
        IDE_PATH_ID pathId;
        ULONG errorCount;
		BOOLEAN rescanActive = FALSE;


        pathId.l = 0;
        while (pdoExtension = NextLogUnitExtensionWithTag (
                                  deviceExtension,
                                  &pathId,
                                  TRUE,
                                  IdePortCompletionDpc
                                  )) {

            KeAcquireSpinLockAtDpcLevel(&pdoExtension->PdoSpinLock);

            SETMASK (pdoExtension->PdoState, PDOS_DEADMEAT);

            IdeLogDeadMeatReason( pdoExtension->DeadmeatRecord.Reason, 
                                  reportedMissing
                                  );
			if (pdoExtension->LuFlags & PD_RESCAN_ACTIVE) {
				rescanActive = TRUE; 
			}

            KeReleaseSpinLockFromDpcLevel(&pdoExtension->PdoSpinLock);

            UnrefPdoWithTag(
                pdoExtension,
                IdePortCompletionDpc
                );
        }

		//
		// Don't ask for a rescan if you are in the middle of one.
		//
		if (!rescanActive) {

			IoInvalidateDeviceRelations (
				deviceExtension->AttacheePdo,
				BusRelations
				);
		} else {

			DebugPrint((1, 
						"The device marked deadmeat during enumeration\n"
						));

		}

    }

    //
    // Check for timer requests.
    //

    if (savedInterruptData.InterruptFlags & PD_TIMER_CALL_REQUEST) {

        //
        // The miniport wants a timer request. Save the timer parameters.
        //

        deviceExtension->HwTimerRequest = savedInterruptData.HwTimerRequest;

        //
        // If the requested timer value is zero, then cancel the timer.
        //

        if (savedInterruptData.MiniportTimerValue == 0) {

            KeCancelTimer(&deviceExtension->MiniPortTimer);

        } else {

            //
            // Convert the timer value from mircoseconds to a negative 100
            // nanoseconds.
            //

            timeValue.QuadPart = Int32x32To64(
                  savedInterruptData.MiniportTimerValue,
                  -10);

            //
            // Set the timer.
            //

            KeSetTimer(&deviceExtension->MiniPortTimer,
                       timeValue,
                       &deviceExtension->MiniPortTimerDpc);
        }
    }

    if (savedInterruptData.InterruptFlags & PD_RESET_REQUEST) {

        RESET_CONTEXT resetContext;

        //
        // clear the reset request
        //
        CLRMASK (savedInterruptData.InterruptFlags, PD_RESET_REQUEST);

        //
        // Request timed out.
        //
        resetContext.DeviceExtension = deviceExtension;
        resetContext.PathId = 0;
        resetContext.NewResetSequence = TRUE;
        resetContext.ResetSrb = NULL;

        if (!KeSynchronizeExecution(deviceExtension->InterruptObject,
                                    IdeResetBusSynchronized,
                                    &resetContext)) {

            DebugPrint((DBG_WARNING,"IdePortCompletionDpc: Reset failed\n"));
        }
    }

    //
    // Verify that the ready for next request is ok.
    //

    if (savedInterruptData.InterruptFlags & PD_READY_FOR_NEXT_REQUEST) {

        //
        // If the device busy bit is not set, then this is a duplicate request.
        // If a no disconnect request is executing, then don't call start I/O.
        // This can occur when the miniport does a NextRequest followed by
        // a NextLuRequest.
        //

        if ((deviceExtension->Flags & (PD_DEVICE_IS_BUSY | PD_DISCONNECT_RUNNING))
            == (PD_DEVICE_IS_BUSY | PD_DISCONNECT_RUNNING)) {

            //
            // Clear the device busy flag.  This flag is set by
            // IdeStartIoSynchonized.
            //

            CLRMASK (deviceExtension->Flags, PD_DEVICE_IS_BUSY);

            if (!(savedInterruptData.InterruptFlags & PD_RESET_HOLD)) {

                //
                // The miniport is ready for the next request and there is
                // not a pending reset hold, so clear the port timer.
                //

                deviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;
            }

        } else {

            //
            // If a no disconnect request is executing, then clear the
            // busy flag.  When the disconnect request completes an
            // IoStartNextPacket will be done.
            //

            CLRMASK (deviceExtension->Flags, PD_DEVICE_IS_BUSY);

            //
            // Clear the ready for next request flag.
            //

            CLRMASK (savedInterruptData.InterruptFlags, PD_READY_FOR_NEXT_REQUEST);
        }
    }

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    //
    // Free Access Token
    //
    if ((savedInterruptData.CompletedRequests != NULL) &&
        (deviceExtension->SyncAccessInterface.FreeAccessToken)) {

        (*deviceExtension->SyncAccessInterface.FreeAccessToken) (
            deviceExtension->SyncAccessInterface.Token
            );
    }

    //
    // Check for a ready for next packet.
    //

    if (savedInterruptData.InterruptFlags & PD_READY_FOR_NEXT_REQUEST) {

        //
        // Start the next request.
        //

        IoStartNextPacket(deviceExtension->DeviceObject, FALSE);
    }

    //
    // Check for an error log requests.
    //

    if (savedInterruptData.InterruptFlags & PD_LOG_ERROR) {

        //
        // Process the request.
        //

        LogErrorEntry(deviceExtension,
                      &savedInterruptData.LogEntry);
    }

    //
    // Process any completed requests.
    //

    callStartIo = FALSE;

    while (savedInterruptData.CompletedRequests != NULL) {

        //
        // Remove the request from the linked-list.
        //

        srbData = savedInterruptData.CompletedRequests;

        savedInterruptData.CompletedRequests = srbData->CompletedRequests;
        srbData->CompletedRequests = NULL;

        //
        // We only supports one request at a time
        //
        ASSERT (savedInterruptData.CompletedRequests == NULL);

        //
        // Stop the command log. The request sense will be logged as the next request.
        //
        IdeLogStopCommandLog(srbData);

        IdeProcessCompletedRequest(deviceExtension,
                                   srbData,
                                   &callStartIo);
    }

    //
    // Process any completed abort requests.
    //

    while (savedInterruptData.CompletedAbort != NULL) {

        logicalUnit = savedInterruptData.CompletedAbort;

        //
        // Remove request from the completed abort list.
        //

        savedInterruptData.CompletedAbort = logicalUnit->CompletedAbort;

        //
        // Acquire the spinlock to protect the flags structure,
        // and the free of the srb extension.
        //

        KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

        //
        // Note the timer which was started for the abort request is not
        // stopped by the get interrupt routine.  Rather the timer is stopped.
        // when the aborted request completes.
        //

        Irp = logicalUnit->AbortSrb->OriginalRequest;


        //
        // Set IRP status. Class drivers will reset IRP status based
        // on request sense if error.
        //

        if (SRB_STATUS(logicalUnit->AbortSrb->SrbStatus) == SRB_STATUS_SUCCESS) {
            Irp->IoStatus.Status = STATUS_SUCCESS;
        } else {
            Irp->IoStatus.Status = IdeTranslateSrbStatus(logicalUnit->AbortSrb);
        }

        Irp->IoStatus.Information = 0;

        //
        // Clear the abort request pointer.
        //

        logicalUnit->AbortSrb = NULL;

        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        UnrefLogicalUnitExtensionWithTag(
            deviceExtension,
            IDEPORT_GET_LUNEXT_IN_IRP(IoGetCurrentIrpStackLocation(Irp)),
            Irp
            );

        IoCompleteRequest(Irp, IO_DISK_INCREMENT);
    }

    //
    // Call the start I/O routine if necessary.
    //

    if (callStartIo) {

        ASSERT(DeviceObject->CurrentIrp != NULL);
        IdePortStartIo(DeviceObject, DeviceObject->CurrentIrp);
    }

    //
    // Check for reset
    //
    if (savedInterruptData.InterruptFlags & PD_RESET_REPORTED) {

        //
        // we had a bus reset.  everyone on the bus should be in PowerDeviceD0
        //
        IDE_PATH_ID             pathId;
        PPDO_EXTENSION          pdoExtension;
        POWER_STATE             powerState;

        pathId.l = 0;
        powerState.DeviceState = PowerDeviceD0;

        while (pdoExtension = NextLogUnitExtensionWithTag (
                                  deviceExtension,
                                  &pathId,
                                  FALSE,
                                  IdePortCompletionDpc
                                  )) {

            //
            // If rescan is active, the pdo might go away
            //
            if (pdoExtension != savedInterruptData.PdoExtensionResetBus &&
                !(pdoExtension->LuFlags & PD_RESCAN_ACTIVE)) {

                PoRequestPowerIrp (
                    pdoExtension->DeviceObject,
                    IRP_MN_SET_POWER,
                    powerState,
                    NULL,
                    NULL,
                    NULL
                    );
            }

            UnrefLogicalUnitExtensionWithTag (
                deviceExtension,
                pdoExtension,
                IdePortCompletionDpc
                );
        }
    }

    LogStopTime(TimeDpc, &timer, 0);
    return;

} // end IdePortCompletionDpc()

#ifdef IDEDEBUG_TEST_START_STOP_DEVICE

typedef enum {

    IdeDebugStartStop_Idle=0,
    IdeDebugStartStop_StopPending,
    IdeDebugStartStop_Stopped,
    IdeDebugStartStop_StartPending,
    IdeDebugStartStop_Started,
    IdeDebugStartStop_LastState
} IDEDEBUG_STARTSTOP_STATE;


PDEVICE_OBJECT IdeDebugStartStopDeviceObject=NULL;
IDEDEBUG_STARTSTOP_STATE IdeDebugStartStopState = IdeDebugStartStop_Idle;
IDEDEBUG_STARTSTOP_STATE IdeDebugStartStopTimer = 0;

PDEVICE_OBJECT
IoGetAttachedDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IdeDebugSynchronousCallCompletionRoutine(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PIRP            Irp,
    IN OUT PVOID           Context
    )
{
    PKEVENT event = Context;

    *(Irp->UserIosb) = Irp->IoStatus;

    KeSetEvent( event, IO_NO_INCREMENT, FALSE );

    IoFreeIrp (Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
IdeDebugSynchronousCall(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STACK_LOCATION TopStackLocation
    )

/*++

Routine Description:

    This function sends a synchronous irp to the top level device
    object which roots on DeviceObject.

Parameters:

    DeviceObject - Supplies the device object of the device being removed.

    TopStackLocation - Supplies a pointer to the parameter block for the irp.

Return Value:

    NTSTATUS code.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK statusBlock;
    KEVENT event;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the deviceObject.
    //

    deviceObject = IoGetAttachedDevice(DeviceObject);

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp(deviceObject->StackSize, FALSE);
    if (irp == NULL){

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize it to failure.
    //

    irp->IoStatus.Status = statusBlock.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = statusBlock.Information = 0;

    irp->UserIosb = &statusBlock;

    //
    // Set the pointer to the status block and initialized event.
    //

    KeInitializeEvent( &event,
                       SynchronizationEvent,
                       FALSE );

    //
    // Set the address of the current thread
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation(irp);


    //
    // Copy in the caller-supplied stack location contents
    //

    *irpSp = *TopStackLocation;

    IoSetCompletionRoutine(
        irp,
        IdeDebugSynchronousCallCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Call the driver
    //

    status = IoCallDriver(DeviceObject, irp);

    //
    // If a driver returns STATUS_PENDING, we will wait for it to complete
    //

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = statusBlock.Status;
    }

    return status;
}

NTSTATUS
IdeDebugStartStopWorkRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM WorkItem
    )
{
    NTSTATUS status;
    IO_STACK_LOCATION irpSp;
    PVOID dummy;

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));
    irpSp.MajorFunction = IRP_MJ_PNP;

    //
    // release resource for this worker item
    //
    IoFreeWorkItem(WorkItem);

    if (IdeDebugStartStopDeviceObject) {

        if (IdeDebugStartStopState == IdeDebugStartStop_StopPending) {

            irpSp.MinorFunction = IRP_MN_STOP_DEVICE;

            status = IdeDebugSynchronousCall(DeviceObject, &irpSp);
            if (!NT_SUCCESS(status)) {
                DbgBreakPoint();
            }

            IdeDebugStartStopTimer = 0;
            IdeDebugStartStopState = IdeDebugStartStop_Stopped;

        } else if (IdeDebugStartStopState == IdeDebugStartStop_StartPending) {

            // this will only work with legacy ide channels enmerated by pciidex.sys

            irpSp.MinorFunction = IRP_MN_START_DEVICE;

            status =IdeDebugSynchronousCall(DeviceObject, &irpSp);
            if (!NT_SUCCESS(status)) {
                DbgBreakPoint();
            }

            IdeDebugStartStopTimer = 0;
            IdeDebugStartStopState = IdeDebugStartStop_Started;

        } else {

            DbgBreakPoint();
        }
    }

    return STATUS_SUCCESS;
}

#endif //IDEDEBUG_TEST_START_STOP_DEVICE


#ifdef DPC_FOR_EMPTY_CHANNEL
BOOLEAN
IdeCheckEmptyChannel(
    IN PVOID ServiceContext
    )
{
    ULONG status;
    PSCSI_REQUEST_BLOCK Srb;
    PDEVICE_OBJECT deviceObject = ServiceContext;
    PFDO_EXTENSION deviceExtension =  deviceObject->DeviceExtension;
    PHW_DEVICE_EXTENSION hwDeviceExtension = deviceExtension->HwDeviceExtension;

    if ((status=IdePortChannelEmptyQuick(&hwDeviceExtension->BaseIoAddress1, &hwDeviceExtension->BaseIoAddress2,
                   hwDeviceExtension->MaxIdeDevice, &hwDeviceExtension->CurrentIdeDevice,
                        &hwDeviceExtension->MoreWait, &hwDeviceExtension->NoRetry))!= STATUS_RETRY) {

        //
        // Clear current SRB.
        //
        Srb=hwDeviceExtension->CurrentSrb;

        hwDeviceExtension->CurrentSrb = NULL;

        //
        // Set status in SRB.
        //
        if (status == 1) {
            Srb->SrbStatus = (UCHAR) SRB_STATUS_SUCCESS;
        } else {
            Srb->SrbStatus = (UCHAR) SRB_STATUS_ERROR;
        }


        //
        // Clear all the variables
        //
        hwDeviceExtension->MoreWait=0;
        hwDeviceExtension->CurrentIdeDevice=0;
        hwDeviceExtension->NoRetry=0;

        //
        // Indicate command complete.
        //

        IdePortNotification(IdeRequestComplete,
                            hwDeviceExtension,
                            Srb);

        //
        // Indicate ready for next request.
        //

        IdePortNotification(IdeNextRequest,
                            hwDeviceExtension,
                            NULL);

        IoRequestDpc(deviceObject, NULL, NULL);
        return TRUE;
    }
    return FALSE;

}
#endif

VOID
IdePortTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/

{
    PFDO_EXTENSION deviceExtension =
        (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PIRP irp;
    ULONG target;
    IDE_PATH_ID pathId;


    UNREFERENCED_PARAMETER(Context);

#if DBG
    if (IdeDebugRescanBusFreq) {

        IdeDebugRescanBusCounter++;

        if (IdeDebugRescanBusCounter == IdeDebugRescanBusFreq) {

            IoInvalidateDeviceRelations (
                deviceExtension->AttacheePdo,
                BusRelations
                );

            IdeDebugRescanBusCounter = 0;
        }
    }
#endif //DBG

#ifdef IDEDEBUG_TEST_START_STOP_DEVICE

    if (deviceExtension->LogicalUnitList[0] &&
        (IdeDebugStartStopDeviceObject == deviceExtension->LogicalUnitList[0]->DeviceObject)) {

        PIO_WORKITEM workItem;

        if (IdeDebugStartStopState == IdeDebugStartStop_Idle) {

            IdeDebugStartStopState = IdeDebugStartStop_StopPending;

            workItem = IoAllocateWorkItem(IdeDebugStartStopDeviceObject);

            IoQueueWorkItem(
                workItem,
                IdeDebugStartStopWorkRoutine,
                DelayedWorkQueue,
                workItem
                );

        } else if (IdeDebugStartStopState == IdeDebugStartStop_Stopped) {

            if (IdeDebugStartStopTimer > 5) {

                IdeDebugStartStopState = IdeDebugStartStop_StartPending;

                workItem = IoAllocateWorkItem(IdeDebugStartStopDeviceObject);

                IoQueueWorkItem(
                    workItem,
                    IdeDebugStartStopWorkRoutine,
                    HyperCriticalWorkQueue,
                    workItem
                    );
            } else {

                IdeDebugStartStopTimer++;
            }

        } else if (IdeDebugStartStopState == IdeDebugStartStop_Started) {

            if (IdeDebugStartStopTimer > 10) {

                IdeDebugStartStopState = IdeDebugStartStop_Idle;

            } else {

                IdeDebugStartStopTimer++;
            }
        }
    }

#endif // IDEDEBUG_TEST_START_STOP_DEVICE

    //
    // Acquire the spinlock to protect the flags structure.
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

#ifdef DPC_FOR_EMPTY_CHANNEL

    //
    //Holding the lock is OK.
    //The empty channel check is quick
    //
    if (deviceExtension->HwDeviceExtension->MoreWait) {
        if (!KeSynchronizeExecution (
            deviceExtension->InterruptObject,
            IdeCheckEmptyChannel,
            DeviceObject
            )) {
            DebugPrint((0,"ATAPI: ChannelEmpty check- device busy after 1sec\n"));
        }

        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        return;
    }
#endif
    //
    // Check for port timeouts.
    //

    if (deviceExtension->ResetCallAgain) {

        RESET_CONTEXT resetContext;

        //
        // Request timed out.
        //
        resetContext.DeviceExtension = deviceExtension;
        resetContext.PathId = 0;
        resetContext.NewResetSequence = FALSE;
        resetContext.ResetSrb = NULL;

        if (!KeSynchronizeExecution(deviceExtension->InterruptObject,
                                    IdeResetBusSynchronized,
                                    &resetContext)) {

            DebugPrint((0,"IdePortTickHanlder: Reset failed\n"));
        }

        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        return;

    } 

    if (deviceExtension->PortTimeoutCounter > 0) {

        if (--deviceExtension->PortTimeoutCounter == 0) {

            //
            // Process the port timeout.
            //
            if (deviceExtension->InterruptObject) {

                if (KeSynchronizeExecution(deviceExtension->InterruptObject,
                                           IdeTimeoutSynchronized,
                                           deviceExtension->DeviceObject)){

                    //
                    // Log error if IdeTimeoutSynchonized indicates this was an error
                    // timeout.
                    //

                    if (deviceExtension->DeviceObject->CurrentIrp) {
                        IdeLogTimeoutError(deviceExtension,
                                           deviceExtension->DeviceObject->CurrentIrp,
                                           256);
                    }
                }

            } else {

                PIRP irp = deviceExtension->DeviceObject->CurrentIrp;

                DebugPrint((0,
                            "The device was suprise removed with an active request\n"
                            ));

                //
                // the device was probably surprise removed. Complete
                // the request with status_no_such_device
                //
                if (irp) {

                    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
                    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

                    srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                    irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

                    UnrefLogicalUnitExtensionWithTag (
                        deviceExtension,
                        IDEPORT_GET_LUNEXT_IN_IRP(irpStack),
                        irp
                        );

                    IoCompleteRequest(irp, IO_NO_INCREMENT);
                   
                }
            }

        }

        //
        // check for busy Luns and restart its request
        //
        pathId.l = 0;
        while (logicalUnit = NextLogUnitExtensionWithTag(
                                 deviceExtension,
                                 &pathId,
                                 TRUE,
                                 IdePortTickHandler
                                 )) {

                AtapiRestartBusyRequest(deviceExtension, logicalUnit);

                UnrefLogicalUnitExtensionWithTag (
                    deviceExtension,
                    logicalUnit,
                    IdePortTickHandler
                    );
            }


        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        //
        // Since a port timeout has been done.  Skip the rest of the
        // processing.
        //

        return;
    }

    //
    // Scan each of the logical units.  If it has an active request then
    // decrement the timeout value and process a timeout if it is zero.
    //

    pathId.l = 0;
    while (logicalUnit = NextLogUnitExtensionWithTag(
                             deviceExtension,
                             &pathId,
                             TRUE,
                             IdePortTickHandler
                             )) {

        //
        // Check for busy requests.
        //

        if (AtapiRestartBusyRequest (deviceExtension, logicalUnit)) {

            //
            // this lun was marked busy
            // skip all other checks
            //

        } else if (logicalUnit->RequestTimeoutCounter == 0) {

            RESET_CONTEXT resetContext;

            //
            // Request timed out.
            //
            logicalUnit->RequestTimeoutCounter = PD_TIMER_STOPPED;

            DebugPrint((1,"IdePortTickHandler: Request timed out\n"));

            resetContext.DeviceExtension = deviceExtension;
            resetContext.PathId = logicalUnit->PathId;
            resetContext.NewResetSequence = TRUE;
            resetContext.ResetSrb = NULL;

            if (deviceExtension->InterruptObject) {

                if (!KeSynchronizeExecution(deviceExtension->InterruptObject,
                                            IdeResetBusSynchronized,
                                            &resetContext)) {

                    DebugPrint((1,"IdePortTickHanlder: Reset failed\n"));
                } else {

                    //
                    // Log the reset.
                    //
                    IdeLogResetError( deviceExtension,
                                     logicalUnit->SrbData.CurrentSrb,
                                     ('P'<<24) | 257);
                }
            }

        } else if (logicalUnit->RequestTimeoutCounter > 0) {

            //
            // Decrement timeout count.
            //

            logicalUnit->RequestTimeoutCounter--;

        }

        UnrefLogicalUnitExtensionWithTag (
            deviceExtension,
            logicalUnit,
            IdePortTickHandler
            );
    }

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    return;

} // end IdePortTickHandler()


BOOLEAN
AtapiRestartBusyRequest (
    PFDO_EXTENSION DeviceExtension,
    PPDO_EXTENSION LogicalUnit
    )
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack; 
    PSCSI_REQUEST_BLOCK srb;


    //
    // Check for busy requests.
    //

    if (LogicalUnit->LuFlags & PD_LOGICAL_UNIT_IS_BUSY) {

        //
        // If a request sense is needed or the queue is
        // frozen, defer processing this busy request until
        // that special processing has completed. This prevents
        // a random busy request from being started when a REQUEST
        // SENSE needs to be sent.
        //

        if (!(LogicalUnit->LuFlags &
            (PD_NEED_REQUEST_SENSE | PD_QUEUE_FROZEN))) {

            DebugPrint((1,"IdePortTickHandler: Retrying busy status request\n"));

            //
            // Clear the busy flag and retry the request. Release the
            // spinlock while the call to IoStartPacket is made.
            //

            CLRMASK (LogicalUnit->LuFlags, PD_LOGICAL_UNIT_IS_BUSY | PD_QUEUE_IS_FULL);
            irp = LogicalUnit->BusyRequest;

            //
            // Clear the busy request.
            //

            LogicalUnit->BusyRequest = NULL;

            //
            // check if the device is gone
            //
            if (LogicalUnit->PdoState & (PDOS_SURPRISE_REMOVED | PDOS_REMOVED)) {

                irpStack = IoGetCurrentIrpStackLocation(irp);

                srb = irpStack->Parameters.Scsi.Srb;

                srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

                //
                // Decrement the logUnitExtension reference count
                //
                UnrefLogicalUnitExtensionWithTag(
                    DeviceExtension,
                    LogicalUnit,
                    irp
                    );

                IoCompleteRequest(irp, IO_NO_INCREMENT);

                return TRUE;

            } 

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            IoStartPacket(DeviceExtension->DeviceObject, irp, (PULONG)NULL, NULL);

            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
        }

        return TRUE;

    }  else {

        return FALSE;
    }
}




NTSTATUS
IdePortDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the device control dispatcher.

Arguments:

    DeviceObject
    Irp

Return Value:


    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFDO_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    UCHAR scsiBus;
    NTSTATUS status;
    ULONG j;


    //
    // Initialize the information field.
    //

    Irp->IoStatus.Information = 0;

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Get adapter capabilities.
    //

    case IOCTL_SCSI_GET_CAPABILITIES:

        //
        // If the output buffer is equal to the size of the a PVOID then just
        // return a pointer to the buffer.
        //

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength
            == sizeof(PVOID)) {

            *((PVOID *)Irp->AssociatedIrp.SystemBuffer)
                = &deviceExtension->Capabilities;

            Irp->IoStatus.Information = sizeof(PVOID);
            status = STATUS_SUCCESS;
            break;

        }

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength
            < sizeof(IO_SCSI_CAPABILITIES)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // this is dynamic
        //
        deviceExtension->Capabilities.AdapterUsesPio = FALSE;
        for (j=0; j<deviceExtension->HwDeviceExtension->MaxIdeDevice; j++) {

            deviceExtension->Capabilities.AdapterUsesPio |=
                !(deviceExtension->HwDeviceExtension->DeviceFlags[j] & DFLAGS_USE_DMA);
        }

        RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer,
                      &deviceExtension->Capabilities,
                      sizeof(IO_SCSI_CAPABILITIES));

        Irp->IoStatus.Information = sizeof(IO_SCSI_CAPABILITIES);
        status = STATUS_SUCCESS;
        break;

    case IOCTL_SCSI_PASS_THROUGH:
    case IOCTL_SCSI_PASS_THROUGH_DIRECT:

        status = IdeSendPassThrough(deviceExtension, Irp);
        break;

#ifdef GET_DISK_GEOMETRY_DEFINED
    case IOCTL_DISK_GET_DRIVE_GEOMETRY:

        DebugPrint((DBG_ALWAYS, "ERROR: Fdo received IOCTL=%x\n",
                    irpStack->Parameters.DeviceIoControl.IoControlCode));

        //
        // Don't know what to do.
        //pass it to the lower device object
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        return IoCallDriver (deviceExtension->AttacheeDeviceObject, Irp);

        break;
#endif

    case IOCTL_SCSI_MINIPORT:

        status = IdeSendMiniPortIoctl( deviceExtension, Irp);
        break;

    case IOCTL_SCSI_GET_INQUIRY_DATA:

        //
        // Return the inquiry data.
        //

        status = IdeGetInquiryData(deviceExtension, Irp);
        break;

    case IOCTL_SCSI_RESCAN_BUS:

        //
        // should return only after we get the device relation irp
        // this will be fixed if needed.
        //
        IoInvalidateDeviceRelations (
            deviceExtension->AttacheePdo,
            BusRelations
            );

        status = STATUS_SUCCESS;
        break;

    default:
        return ChannelDeviceIoControl (DeviceObject, Irp);
        break;

    } // end switch

    //
    // Set status in Irp.
    //

    Irp->IoStatus.Status = status;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

} // end IdePortDeviceControl()


BOOLEAN
IdeStartIoSynchronized (
    PVOID ServiceContext
    )

/*++

Routine Description:

    This routine calls the dependent driver start io routine.
    It also starts the request timer for the logical unit if necesary and
    inserts the SRB data structure in to the requset list.

Arguments:

    ServiceContext - Supplies the pointer to the device object.

Return Value:

    Returns the value returned by the dependent start I/O routine.

Notes:

    The port driver spinlock must be held when this routine is called.

--*/

{
    PDEVICE_OBJECT deviceObject = ServiceContext;
    PFDO_EXTENSION deviceExtension =  deviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK srb;
    PSRB_DATA srbData;
    BOOLEAN timerStarted;
    BOOLEAN returnValue;
    BOOLEAN resetRequest;

    DebugPrint((3, "IdePortStartIoSynchronized: Enter routine\n"));

    irpStack = IoGetCurrentIrpStackLocation(deviceObject->CurrentIrp);
    srb = irpStack->Parameters.Scsi.Srb;


    //
    // Get the logical unit extension.
    //

    logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);

    //
    // Check for a reset hold.  If one is in progress then flag it and return.
    // The timer will reset the current request.  This check should be made
    // before anything else is done.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_RESET_HOLD) {

        DebugPrint ((1, "IdeStartIoSynchronized: PD_RESET_HOLD set...request is held for later..\n"));

        deviceExtension->InterruptData.InterruptFlags |= PD_HELD_REQUEST;
        return(TRUE);
    }

    if ((((srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH) ||
          (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH)) &&
         (((PATA_PASS_THROUGH) (srb->DataBuffer))->IdeReg.bReserved & ATA_PTFLAGS_BUS_RESET))) {

        resetRequest = TRUE;

    } else {

        resetRequest = FALSE;
    }

    //
    // Start the port timer.  This ensures that the miniport asks for
    // the next request in a resonable amount of time.  Set the device
    // busy flag to indicate it is ok to start the next request.
    //

    deviceExtension->PortTimeoutCounter = srb->TimeOutValue;
    deviceExtension->Flags |= PD_DEVICE_IS_BUSY;

    //
    // Start the logical unit timer if it is not currently running.
    //

    if (logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

        //
        // Set request timeout value from Srb SCSI extension in Irp.
        //

        logicalUnit->RequestTimeoutCounter = srb->TimeOutValue;
        timerStarted = TRUE;

    } else {
        timerStarted = FALSE;
    }

    //
    // Indicate that there maybe more requests queued, if this is not a bypass
    // request.
    //

    if (!(srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {

        if (srb->SrbFlags & SRB_FLAGS_DISABLE_DISCONNECT) {

            //
            // This request does not allow disconnects. Remember that so
            // no more requests are started until this one completes.
            //

            CLRMASK (deviceExtension->Flags, PD_DISCONNECT_RUNNING);
        }

        logicalUnit->LuFlags |= PD_LOGICAL_UNIT_IS_ACTIVE;

    } else {

        //
        // If this is an abort request make sure that it still looks valid.
        //

        if (srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

            srbData = IdeGetSrbData(deviceExtension, srb);

            //
            // Make sure the srb request is still active.
            //

            if (srbData == NULL || srbData->CurrentSrb == NULL
                || !(srbData->CurrentSrb->SrbFlags & SRB_FLAGS_IS_ACTIVE)) {

                //
                // Mark the Srb as active.
                //

                srb->SrbFlags |= SRB_FLAGS_IS_ACTIVE;

                if (timerStarted) {
                    logicalUnit->RequestTimeoutCounter = PD_TIMER_STOPPED;
                }

                //
                // The request is gone.
                //

                DebugPrint((1, "IdePortStartIO: Request completed be for it was aborted.\n"));
                srb->SrbStatus = SRB_STATUS_ABORT_FAILED;
                IdePortNotification(IdeRequestComplete,
                                    deviceExtension + 1,
                                    srb);

                IdePortNotification(IdeNextRequest,
                                    deviceExtension + 1);

                //
                // Queue a DPC to process the work that was just indicated.
                //

                IoRequestDpc(deviceExtension->DeviceObject, NULL, NULL);

                return(TRUE);
            }

        } 

        //
        // Any untagged request that bypasses the queue
        // clears the need request sense flag.
        //

        CLRMASK (logicalUnit->LuFlags, PD_NEED_REQUEST_SENSE);

        if (srb->SrbFlags & SRB_FLAGS_DISABLE_DISCONNECT) {

            //
            // This request does not allow disconnects. Remember that so
            // no more requests are started until this one completes.
            //

            CLRMASK (deviceExtension->Flags, PD_DISCONNECT_RUNNING);
        }

        //
        // Set the timeout value in the logical unit.
        //

        logicalUnit->RequestTimeoutCounter = srb->TimeOutValue;
    }

    //
    // Mark the Srb as active.
    //

    srb->SrbFlags |= SRB_FLAGS_IS_ACTIVE;


#if 0
    //joedai
    {
        ULONG c;
        PUCHAR s;
        PUCHAR d;

        s = (PUCHAR) deviceObject->CurrentIrp;
        d = (PUCHAR) &deviceExtension->debugData[deviceExtension->nextEntry].irp;
        deviceExtension->debugDataPtr[deviceExtension->nextEntry].irp = (PIRP) d;
        for (c=0; c<sizeof(IRP); c++) {
            d[c] = s[c];
        }

        if (deviceObject->CurrentIrp->MdlAddress) {
            s = (PUCHAR) deviceObject->CurrentIrp->MdlAddress;
            d = (PUCHAR) &deviceExtension->debugData[deviceExtension->nextEntry].mdl;
            deviceExtension->debugDataPtr[deviceExtension->nextEntry].mdl = (PMDL) d;
            for (c=0; c<sizeof(MDL); c++) {
                d[c] = s[c];
            }
        } else {
            d = (PUCHAR) &deviceExtension->debugData[deviceExtension->nextEntry].mdl;
            deviceExtension->debugDataPtr[deviceExtension->nextEntry].mdl = (PMDL) d;
            for (c=0; c<sizeof(MDL); c++) {
                d[c] = 0;
            }
        }
        s = (PUCHAR) srb;
        d = (PUCHAR) &deviceExtension->debugData[deviceExtension->nextEntry].srb;
        deviceExtension->debugDataPtr[deviceExtension->nextEntry].srb = (PSCSI_REQUEST_BLOCK) d;
        for (c=0; c<sizeof(SCSI_REQUEST_BLOCK); c++) {
            d[c] = s[c];
        }
        ASSERT((((ULONG)srb->DataBuffer) & 0x80000000));

        deviceExtension->nextEntry = (deviceExtension->nextEntry + 1) % NUM_DEBUG_ENTRY;
    }
#endif

    //
    // maybe the device is gone
    //
    if (logicalUnit->PdoState & PDOS_DEADMEAT) {

        srb->SrbStatus = SRB_STATUS_NO_DEVICE;
        IdePortNotification(IdeRequestComplete,
                            deviceExtension + 1,
                            srb);

        IdePortNotification(IdeNextRequest,
                            deviceExtension + 1);

        IoRequestDpc(deviceExtension->DeviceObject, NULL, NULL);

        return TRUE;
    }

    if (resetRequest) {

        RESET_CONTEXT resetContext;

        resetContext.DeviceExtension = deviceExtension;
        resetContext.PathId = 0;
        resetContext.NewResetSequence = TRUE;
        resetContext.ResetSrb = srb;

        srb->SrbStatus = SRB_STATUS_PENDING;

        returnValue = IdeResetBusSynchronized (&resetContext);

    } else {

       returnValue = AtapiStartIo (deviceExtension->HwDeviceExtension,
                                   srb);
    }

    //
    // Check for miniport work requests.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

        IoRequestDpc(deviceExtension->DeviceObject, NULL, NULL);
    }

    return returnValue;

} // end IdeStartIoSynchronized()

BOOLEAN
IdeTimeoutSynchronized (
    PVOID ServiceContext
    )

/*++

Routine Description:

    This routine handles a port timeout.  There are two reason these can occur
    either because of a reset hold or a time out waiting for a read for next
    request notification.  If a reset hold completes, then any held request
    must be started.  If a timeout occurs, then the bus must be reset.

Arguments:

    ServiceContext - Supplies the pointer to the device object.

Return Value:

    TRUE - If a timeout error should be logged.

Notes:

    The port driver spinlock must be held when this routine is called.

--*/

{
    PDEVICE_OBJECT deviceObject = ServiceContext;
    PFDO_EXTENSION deviceExtension =  deviceObject->DeviceExtension;
    ULONG i;
    BOOLEAN enumProbing = FALSE;
    BOOLEAN noErrorLog = FALSE;

    DebugPrint((3, "IdeTimeoutSynchronized: Enter routine\n"));

    //
    // Make sure the timer is stopped.
    //

    deviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;

    //
    // Check for a reset hold.  If one is in progress then clear it and check
    // for a pending held request
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_RESET_HOLD) {

        CLRMASK (deviceExtension->InterruptData.InterruptFlags, PD_RESET_HOLD);

        if (deviceExtension->InterruptData.InterruptFlags & PD_HELD_REQUEST) {

            //
            // Clear the held request flag and restart the request.
            //

            CLRMASK (deviceExtension->InterruptData.InterruptFlags, PD_HELD_REQUEST);
            IdeStartIoSynchronized(ServiceContext);

        }

        return(FALSE);

    } else {

        //
        // Miniport is hung and not accepting new requests. So reset the
        // bus to clear things up.
        //

        if (deviceExtension->HwDeviceExtension->CurrentSrb) {

            deviceExtension->HwDeviceExtension->TimeoutCount[
                        deviceExtension->HwDeviceExtension->CurrentSrb->TargetId
                        ]++;

            //
            // Many harddrives fail to respond to the first DMA operation
            // We then reset the device and subsequently everything works fine
            // The hack is to mask this error from being logged in the system logs
            //

            if (deviceExtension->HwDeviceExtension->TimeoutCount[
                        deviceExtension->HwDeviceExtension->CurrentSrb->TargetId
                        ] == 1) {
                noErrorLog=TRUE;
            }

            enumProbing = TestForEnumProbing (deviceExtension->HwDeviceExtension->CurrentSrb);
        }

        if (!enumProbing) {

            DebugPrint((0,
                        "IdeTimeoutSynchronized: DevObj 0x%x Next request timed out. Resetting bus..currentSrb=0x%x\n",
                        deviceObject,
                        deviceExtension->HwDeviceExtension->CurrentSrb));
        }

        ASSERT (deviceExtension->ResetSrb == 0);
        deviceExtension->ResetSrb = NULL;
        deviceExtension->ResetCallAgain = 0;
        AtapiResetController (deviceExtension->HwDeviceExtension,
                              0,
                              &deviceExtension->ResetCallAgain);

        //
        // Set the reset hold flag and start the counter.
        // if we are doing enumertion, don't set the flag
        //  we shouldn't set the flag if ResetCallAgain is not set
        //
        if (!enumProbing &&
			(deviceExtension->ResetCallAgain))  {

            ASSERT(deviceExtension->ResetCallAgain);

            deviceExtension->InterruptData.InterruptFlags |= PD_RESET_HOLD;
            deviceExtension->PortTimeoutCounter = PD_TIMER_RESET_HOLD_TIME;

        } else {

            ASSERT(deviceExtension->ResetCallAgain == 0);

        }

        //
        // Check for miniport work requests.
        //

        if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

            IoRequestDpc(deviceExtension->DeviceObject, NULL, NULL);
        }
    }

    if (enumProbing || noErrorLog) {

        return(FALSE);
    } else {

        return(TRUE);
    }

} // end IdeTimeoutSynchronized()

NTSTATUS
FASTCALL
IdeBuildAndSendIrp (
    IN PPDO_EXTENSION PdoExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID CompletionContext
    )
{

    LARGE_INTEGER largeInt;
    NTSTATUS status = STATUS_PENDING;
    PIRP irp;
    PIO_STACK_LOCATION  irpStack;

    //
    // why?
    //
    largeInt.QuadPart = (LONGLONG) 1;

    //
    // Build IRP for this request.
    //
    irp = IoBuildAsynchronousFsdRequest(IRP_MJ_READ,
                                       PdoExtension->DeviceObject,
                                       Srb->DataBuffer,
                                       Srb->DataTransferLength,
                                       &largeInt,
                                       NULL);

    if (irp == NULL) {

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId, 
                            NonPagedPool,
                            IoSizeOfIrp(PdoExtension->DeviceObject->StackSize),
                            IDEPORT_TAG_SEND_IRP
                            );

        status = STATUS_INSUFFICIENT_RESOURCES;

        goto GetOut;
    }

    IoSetCompletionRoutine(irp,
                           (PIO_COMPLETION_ROUTINE)CompletionRoutine,
                           CompletionContext,
                           TRUE,
                           TRUE,
                           TRUE);

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //
    irpStack->Parameters.Scsi.Srb = Srb;

    //
    // put the irp in the original request field
    //
    Srb->OriginalRequest = irp;

    (VOID)IoCallDriver(PdoExtension->DeviceObject, irp);

    status = STATUS_PENDING;
    
GetOut:
    
    return status;

}

VOID
FASTCALL
IdeFreeIrpAndMdl(
    IN PIRP Irp
    )
{
    ASSERT(Irp);

    if (Irp->MdlAddress != NULL) {
        MmUnlockPages(Irp->MdlAddress);
        IoFreeMdl(Irp->MdlAddress);

        Irp->MdlAddress = NULL;
    }

    IoFreeIrp(Irp);

    return;
}


VOID
IssueRequestSense(
    IN PPDO_EXTENSION PdoExtension,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    )

/*++

Routine Description:

    This routine creates a REQUEST SENSE request and uses IoCallDriver to
    renter the driver.  The completion routine cleans up the data structures
    and processes the logical unit queue according to the flags.

    A pointer to failing SRB is stored at the end of the request sense
    Srb, so that the completion routine can find it.

Arguments:

    DeviceExension - Supplies a pointer to the pdo device extension

    FailingSrb - Supplies a pointer to the request that the request sense
        is being done for.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpStack;
    PIRP irp;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    PVOID              *pointer;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    KIRQL currentIrql;
    NTSTATUS status;

#if DBG
    PIO_STACK_LOCATION  failingIrpStack;
    PIRP                failingIrp;
    PLOGICAL_UNIT_EXTENSION failingLogicalUnit;
#endif

    DebugPrint((3,"IssueRequestSense: Enter routine\n"));

    //
    // Build the asynchronous request
    // to be sent to the port driver.
    //
    // Allocate Srb from non-paged pool
    // plus room for a pointer to the failing IRP.
    // Note this routine is in an error-handling
    // path and is a shortterm allocation.
    //

    srb = ExAllocatePool(NonPagedPool,
                         sizeof(SCSI_REQUEST_BLOCK) + sizeof(PVOID));

    if (srb == NULL) {
        DebugPrint((1, "IssueRequest sense - pool allocation failed\n"));
        goto Getout;
    }

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Save the Failing SRB after the request sense Srb.
    //

    pointer = (PVOID *) (srb+1);
    *pointer = FailingSrb;

    //
    // Build the REQUEST SENSE CDB.
    //

    srb->CdbLength = 6;
    cdb = (PCDB)srb->Cdb;

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.LogicalUnitNumber = 0;
    cdb->CDB6INQUIRY.Reserved1 = 0;
    cdb->CDB6INQUIRY.PageCode = 0;
    cdb->CDB6INQUIRY.IReserved = 0;
    cdb->CDB6INQUIRY.AllocationLength =
        (UCHAR)FailingSrb->SenseInfoBufferLength;
    cdb->CDB6INQUIRY.Control = 0;



    //
    // Set up SCSI bus address.
    //

    srb->TargetId = FailingSrb->TargetId;
    srb->Lun = FailingSrb->Lun;
    srb->PathId = FailingSrb->PathId;

    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->Length = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set timeout value to 16 seconds.
    //

    srb->TimeOutValue = 0x10;

    //
    // Disable auto request sense.
    //

    srb->SenseInfoBufferLength = 0;

    //
    // Sense buffer is in stack.
    //

    srb->SenseInfoBuffer = NULL;

    //
    // Set read and bypass frozen queue bits in flags.
    //

    //
    // Set SRB flags to indicate the logical unit queue should be by
    // passed and that no queue processing should be done when the request
    // completes.  Also disable disconnect and synchronous data
    // transfer if necessary.
    //

    srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                    SRB_FLAGS_DISABLE_DISCONNECT;

    if (FailingSrb->SrbFlags & SRB_FLAGS_DISABLE_SYNCH_TRANSFER) {
        srb->SrbFlags |= SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
    }

    srb->DataBuffer = FailingSrb->SenseInfoBuffer;

    //
    // Set the transfer length.
    //

    srb->DataTransferLength = FailingSrb->SenseInfoBufferLength;

    //
    // Zero out status.
    //

    srb->ScsiStatus = srb->SrbStatus = 0;

    srb->NextSrb = 0;

#if DBG
    //
    // This was added to catch a bug where the original request
    // was pointing to a pnp irp
    //
    ASSERT(FailingSrb->OriginalRequest);
    failingIrp  = FailingSrb->OriginalRequest;
    failingIrpStack    = IoGetCurrentIrpStackLocation(failingIrp);
    failingLogicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (failingIrpStack);
    ASSERT(failingLogicalUnit);
#endif

    status = IdeBuildAndSendIrp(PdoExtension, 
                                srb, 
                                IdePortInternalCompletion, 
                                srb
                                );

    if (NT_SUCCESS(status)) {
        return;
    }

    ASSERT(status == STATUS_INSUFFICIENT_RESOURCES);

Getout:
        if (srb) {
            ExFreePool(srb);
        }

        irp  = FailingSrb->OriginalRequest;
        irpStack    = IoGetCurrentIrpStackLocation(irp);
        logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);

        //
        // Clear the request sense flag. Since IdeStartIoSync will never get called, this
        // flag won't be cleared.
        //
        KeAcquireSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, &currentIrql);
        CLRMASK (logicalUnit->LuFlags, PD_NEED_REQUEST_SENSE);
        KeReleaseSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, currentIrql);

        //
        // unfreeze the queue if necessary
        //
        ASSERT(FailingSrb->SrbStatus & SRB_STATUS_QUEUE_FROZEN);
        if ((FailingSrb->SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE) &&
            (FailingSrb->SrbStatus & SRB_STATUS_QUEUE_FROZEN)) {


            CLRMASK (logicalUnit->LuFlags, PD_QUEUE_FROZEN);

            KeAcquireSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, &currentIrql);
            GetNextLuRequest(logicalUnit->ParentDeviceExtension, logicalUnit);
            KeLowerIrql(currentIrql);

            CLRMASK (FailingSrb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
        }

        //
        // Decrement the logUnitExtension reference count
        //
        UnrefLogicalUnitExtensionWithTag(
            IDEPORT_GET_LUNEXT_IN_IRP(irpStack)->ParentDeviceExtension,
            IDEPORT_GET_LUNEXT_IN_IRP(irpStack),
            irp
            );

        //
        // Complete the original request
        //
        IoCompleteRequest(irp, IO_DISK_INCREMENT);

        return;

} // end IssueRequestSense()


NTSTATUS
IdePortInternalCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:

Arguments:

    Device object
    IRP
    Context - pointer to SRB

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb = Context;
    PSCSI_REQUEST_BLOCK failingSrb;
    PIRP failingIrp;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSENSE_DATA     senseBuffer;
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    KIRQL currentIrql;

    UNREFERENCED_PARAMETER(DeviceObject);

    DebugPrint((3,"IdePortInternalCompletion: Enter routine\n"));

    //
    // If RESET_BUS or ABORT_COMMAND request
    // then free pool and return.
    //

    if ((srb->Function == SRB_FUNCTION_ABORT_COMMAND) ||
        (srb->Function == SRB_FUNCTION_RESET_BUS)) {

        //
        // Deallocate internal SRB and IRP.
        //

        ExFreePool(srb);

        IoFreeIrp(Irp);

        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Request sense completed. If successful or data over/underrun
    // get the failing SRB and indicate that the sense information
    // is valid. The class driver will check for underrun and determine
    // if there is enough sense information to be useful.
    //

    //
    // Get a pointer to failing Irp and Srb.
    //

    failingSrb  = *((PVOID *) (srb+1));
    failingIrp  = failingSrb->OriginalRequest;
    irpStack    = IoGetCurrentIrpStackLocation(failingIrp);
    logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);


    if ((SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) ||
        (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN)) {

        //
        // Report sense buffer is valid.
        //

        failingSrb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;

        //
        // Copy bytes transferred to failing SRB
        // request sense length field to communicate
        // to the class drivers the number of valid
        // sense bytes.
        //

        failingSrb->SenseInfoBufferLength = (UCHAR) srb->DataTransferLength;

#if 0
        //
        // enable for debugging only
        // if sense buffer is smaller than 13 bytes, then the debugprint
        // below could bugchecl the system
        //

        //
        // Print the sense buffer for debugging purposes.
        //
        senseBuffer = failingSrb->SenseInfoBuffer;
        DebugPrint((DBG_ATAPI_DEVICES, "CDB=%x, SenseKey=%x, ASC=%x, ASQ=%x\n", 
                    failingSrb->Cdb[0],
                    senseBuffer->SenseKey, senseBuffer->AdditionalSenseCode,
                    senseBuffer->AdditionalSenseCodeQualifier));
#endif

    }

    // 
    // Clear the request sense flag. If we fail due to fault injection
    // IdeStartIo won't get called and this flag never gets cleared.
    //
    KeAcquireSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, &currentIrql);
    CLRMASK (logicalUnit->LuFlags, PD_NEED_REQUEST_SENSE);
    KeReleaseSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, currentIrql);

    //
    // unfreeze the queue if necessary
    //
    ASSERT(failingSrb->SrbStatus & SRB_STATUS_QUEUE_FROZEN);
    if ((failingSrb->SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE) &&
        (failingSrb->SrbStatus & SRB_STATUS_QUEUE_FROZEN)) {


        CLRMASK (logicalUnit->LuFlags, PD_QUEUE_FROZEN);

        KeAcquireSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, &currentIrql);
        GetNextLuRequest(logicalUnit->ParentDeviceExtension, logicalUnit);
        KeLowerIrql(currentIrql);

        CLRMASK (failingSrb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
    }

    //
    // Decrement the logUnitExtension reference count
    //
    UnrefLogicalUnitExtensionWithTag(
        IDEPORT_GET_LUNEXT_IN_IRP(irpStack)->ParentDeviceExtension,
        IDEPORT_GET_LUNEXT_IN_IRP(irpStack),
        failingIrp
        );

    //
    // Complete the failing request.
    //


    IoCompleteRequest(failingIrp, IO_DISK_INCREMENT);

    //
    // Deallocate internal SRB, MDL and IRP.
    //

    ExFreePool(srb);

    IdeFreeIrpAndMdl(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;

} // IdePortInternalCompletion()


BOOLEAN
IdeGetInterruptState(
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine saves the InterruptFlags, MapTransferParameters and
    CompletedRequests fields and clears the InterruptFlags.

    This routine also removes the request from the logical unit queue if it is
    tag.  Finally the request time is updated.

Arguments:

    ServiceContext - Supplies a pointer to the interrupt context which contains
        pointers to the interrupt data and where to save it.

Return Value:

    Returns TURE if there is new work and FALSE otherwise.

Notes:

    Called via KeSynchronizeExecution with the port device extension spinlock
    held.

--*/
{
    PINTERRUPT_CONTEXT      interruptContext = ServiceContext;
    ULONG                   limit = 0;
    PFDO_EXTENSION       deviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK     srb;
    PSRB_DATA               srbData;
    PSRB_DATA               nextSrbData;
    BOOLEAN                 isTimed;

    deviceExtension = interruptContext->DeviceExtension;

    //
    // Check for pending work.
    //

    if (!(deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED)) {
        return(FALSE);
    }

    //
    // Move the interrupt state to save area.
    //

    *interruptContext->SavedInterruptData = deviceExtension->InterruptData;

    //
    // Clear the interrupt state.
    //

    deviceExtension->InterruptData.InterruptFlags &= PD_INTERRUPT_FLAG_MASK;
    deviceExtension->InterruptData.CompletedRequests = NULL;
    deviceExtension->InterruptData.ReadyLogicalUnit = NULL;
    deviceExtension->InterruptData.CompletedAbort = NULL;
    deviceExtension->InterruptData.PdoExtensionResetBus = NULL;

    srbData = interruptContext->SavedInterruptData->CompletedRequests;

    while (srbData != NULL) {

        PIRP                irp;
        PIO_STACK_LOCATION  irpStack;

        ASSERT(limit++ < 100);

        //
        // Get a pointer to the SRB and the logical unit extension.
        //

        ASSERT(srbData->CurrentSrb != NULL);
        srb = srbData->CurrentSrb;

        irp = srb->OriginalRequest;
        irpStack = IoGetCurrentIrpStackLocation(irp);
        logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);

        //
        // If the request did not succeed, then check for the special cases.
        //

        if (srb->SrbStatus != SRB_STATUS_SUCCESS) {

            //
            // If this request failed and a REQUEST SENSE command needs to
            // be done, then set a flag to indicate this and prevent other
            // commands from being started.
            //

            if (NEED_REQUEST_SENSE(srb)) {

                if (logicalUnit->LuFlags & PD_NEED_REQUEST_SENSE) {

                    //
                    // This implies that requests have completed with a
                    // status of check condition before a REQUEST SENSE
                    // command could be preformed.  This should never occur.
                    // Convert the request to another code so that only one
                    // auto request sense is issued.
                    //

                    srb->ScsiStatus = 0;
                    srb->SrbStatus = SRB_STATUS_REQUEST_SENSE_FAILED;

                } else {

                    //
                    // Indicate that an auto request sense needs to be done.
                    //

                    logicalUnit->LuFlags |= PD_NEED_REQUEST_SENSE;
                }

            }

        }

        logicalUnit->RequestTimeoutCounter = PD_TIMER_STOPPED;
        srbData = srbData->CompletedRequests;
    }

    return(TRUE);
}

VOID
IdePortAllocateAccessToken (
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFDO_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;

    if (!fdoExtension->SyncAccessInterface.AllocateAccessToken) {

        CallIdeStartIoSynchronized (
            NULL,
            NULL,
            NULL,
            DeviceObject
            );

    } else {

        (*fdoExtension->SyncAccessInterface.AllocateAccessToken) (
            fdoExtension->SyncAccessInterface.Token,
            CallIdeStartIoSynchronized,
            DeviceObject
            );
    }
}


IO_ALLOCATION_ACTION
CallIdeStartIoSynchronized (
    IN PVOID Reserved1,
    IN PVOID Reserved2,
    IN PVOID Reserved3,
    IN PVOID DeviceObject
    )
{
    PFDO_EXTENSION   deviceExtension = ((PDEVICE_OBJECT) DeviceObject)->DeviceExtension;
    KIRQL               currentIrql;

    KeAcquireSpinLock(&deviceExtension->SpinLock, &currentIrql);

    KeSynchronizeExecution (
        deviceExtension->InterruptObject,
        IdeStartIoSynchronized,
        DeviceObject
        );

    KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);

    return KeepObject;
}


VOID
LogErrorEntry(
    IN PFDO_EXTENSION DeviceExtension,
    IN PERROR_LOG_ENTRY LogEntry
    )
/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.

    LogEntry - Supplies a pointer to the scsi port log entry.

Return Value:

    None.

--*/
{
    PIO_ERROR_LOG_PACKET errorLogEntry;

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        DeviceExtension->DeviceObject,
        sizeof(IO_ERROR_LOG_PACKET) + 4 * sizeof(ULONG)
        );

    if (errorLogEntry != NULL) {

        //
        // Translate the miniport error code into the NT I\O driver.
        //

        switch (LogEntry->ErrorCode) {
        case SP_BUS_PARITY_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_PARITY;
            break;

        case SP_UNEXPECTED_DISCONNECT:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_INVALID_RESELECTION:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_BUS_TIME_OUT:
            errorLogEntry->ErrorCode = IO_ERR_TIMEOUT;
            break;

        case SP_PROTOCOL_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_INTERNAL_ADAPTER_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_IRQ_NOT_RESPONDING:
            errorLogEntry->ErrorCode = IO_ERR_INCORRECT_IRQL;
            break;

        case SP_BAD_FW_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_BAD_FIRMWARE;
            break;

        case SP_BAD_FW_WARNING:
            errorLogEntry->ErrorCode = IO_WRN_BAD_FIRMWARE;
            break;

        default:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        }

        errorLogEntry->SequenceNumber = LogEntry->SequenceNumber;
        errorLogEntry->MajorFunctionCode = IRP_MJ_SCSI;
        errorLogEntry->RetryCount = (UCHAR) LogEntry->ErrorLogRetryCount;
        errorLogEntry->UniqueErrorValue = LogEntry->UniqueId;
        errorLogEntry->FinalStatus = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize = 4 * sizeof(ULONG);
        errorLogEntry->DumpData[0] = LogEntry->PathId;
        errorLogEntry->DumpData[1] = LogEntry->TargetId;
        errorLogEntry->DumpData[2] = LogEntry->Lun;
        errorLogEntry->DumpData[3] = LogEntry->ErrorCode;
        IoWriteErrorLogEntry(errorLogEntry);
    }

#if DBG
        {
        PCHAR errorCodeString;

        switch (LogEntry->ErrorCode) {
        case SP_BUS_PARITY_ERROR:
            errorCodeString = "SCSI bus partity error";
            break;

        case SP_UNEXPECTED_DISCONNECT:
            errorCodeString = "Unexpected disconnect";
            break;

        case SP_INVALID_RESELECTION:
            errorCodeString = "Invalid reselection";
            break;

        case SP_BUS_TIME_OUT:
            errorCodeString = "SCSI bus time out";
            break;

        case SP_PROTOCOL_ERROR:
            errorCodeString = "SCSI protocol error";
            break;

        case SP_INTERNAL_ADAPTER_ERROR:
            errorCodeString = "Internal adapter error";
            break;

        default:
            errorCodeString = "Unknown error code";
            break;

        }

        DebugPrint((DBG_ALWAYS,"LogErrorEntry: Logging SCSI error packet. ErrorCode = %s.\n",
            errorCodeString
            ));
        DebugPrint((DBG_ALWAYS,
            "PathId = %2x, TargetId = %2x, Lun = %2x, UniqueId = %x.\n",
            LogEntry->PathId,
            LogEntry->TargetId,
            LogEntry->Lun,
            LogEntry->UniqueId
            ));
        }
#endif

}

VOID
GetNextLuPendingRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    if (LogicalUnit->PendingRequest) {

        GetNextLuRequest(
            DeviceExtension,
            LogicalUnit
            );

    } else {

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    }

    return;
}

#if DBG
#define LOG_LENGTH      5
ULONG IdeDebugGetNextLuRequestLastCallerIndex = LOG_LENGTH - 1;
UCHAR IdeDebugGetNextLuRequestLastCallerFileName[LOG_LENGTH][256] = {0};
ULONG IdeDebugGetNextLuRequestLastCallerLineNumber[LOG_LENGTH] = {0};

VOID
GetNextLuRequest2(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PUCHAR FileName,
    IN ULONG  LineNumber
    )
#else

VOID
GetNextLuRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
#endif
/*++

Routine Description:

    This routine get the next request for the specified logical unit.  It does
    the necessary initialization to the logical unit structure and submitts the
    request to the device queue.  The DeviceExtension SpinLock must be held
    when this function called.  It is released by this function.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.

    LogicalUnit - Supplies a pointer to the logical unit extension to get the
        next request from.

Return Value:

     None.

--*/

{
    PKDEVICE_QUEUE_ENTRY packet;
    PIO_STACK_LOCATION   irpStack;
    PSCSI_REQUEST_BLOCK  srb;
    POWER_STATE          powerState;
    PIRP                 nextIrp;
    BOOLEAN              powerUpDevice = FALSE;

#if DBG

    IdeDebugGetNextLuRequestLastCallerIndex++;
    if (IdeDebugGetNextLuRequestLastCallerIndex >= LOG_LENGTH) {
        IdeDebugGetNextLuRequestLastCallerIndex = 0;
    }
    strcpy (IdeDebugGetNextLuRequestLastCallerFileName[IdeDebugGetNextLuRequestLastCallerIndex], FileName);
    IdeDebugGetNextLuRequestLastCallerLineNumber[IdeDebugGetNextLuRequestLastCallerIndex] = LineNumber;

#endif // DBG


    //
    // If the active flag is not set, then the queue is not busy or there is
    // a request being processed and the next request should not be started..
    //

    if ((!(LogicalUnit->LuFlags & PD_LOGICAL_UNIT_IS_ACTIVE) &&
          (LogicalUnit->PendingRequest == NULL))
        || (LogicalUnit->SrbData.CurrentSrb)) {

        DebugPrint ((2, "IdePort GetNextLuRequest: 0x%x 0x%x NOT PD_LOGICAL_UNIT_IS_ACTIVE\n",
                     DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                     LogicalUnit->TargetId
                     ));
        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        return;
    }

    //
    // Check for pending requests, queue full or busy requests.  Pending
    // requests occur when untagged request is started and there are active
    // queued requests. Busy requests occur when the target returns a BUSY
    // or QUEUE FULL status. Busy requests are started by the timer code.
    // Also if the need request sense flag is set, it indicates that
    // an error status was detected on the logical unit.  No new requests
    // should be started until this flag is cleared.  This flag is cleared
    // by an untagged command that by-passes the LU queue i.e.
    //
    // The busy flag and the need request sense flag have the effect of
    // forcing the queue of outstanding requests to drain after an error or
    // until a busy request gets started.
    //

    if (LogicalUnit->LuFlags & (PD_LOGICAL_UNIT_IS_BUSY
        | PD_QUEUE_IS_FULL | PD_NEED_REQUEST_SENSE | PD_QUEUE_FROZEN) ||
        (LogicalUnit->PdoState & (PDOS_REMOVED | PDOS_SURPRISE_REMOVED))) {

        //
        // If the request queue is now empty, then the pending request can
        // be started.
        //

        DebugPrint((2, "IdePort: GetNextLuRequest: 0x%x 0x%x Ignoring a get next lu call.\n",
                    DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                    LogicalUnit->TargetId
                    ));

        //
        // Note the active flag is not cleared. So the next request
        // will be processed when the other requests have completed.
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
        return;
    }

    //
    // Clear the active flag.  If there is another request, the flag will be
    // set again when the request is passed to the miniport.
    //
    CLRMASK (LogicalUnit->LuFlags, PD_LOGICAL_UNIT_IS_ACTIVE);

    LogicalUnit->RetryCount = 0;
    nextIrp = NULL;

    if (LogicalUnit->PendingRequest) {

        nextIrp = LogicalUnit->PendingRequest;

        LogicalUnit->PendingRequest = NULL;

    } else {

        //
        // Remove the packet from the logical unit device queue.
        //
        packet = KeRemoveByKeyDeviceQueue(&LogicalUnit->DeviceObject->DeviceQueue,
                                          LogicalUnit->CurrentKey);

        if (packet != NULL) {

            nextIrp = CONTAINING_RECORD(packet, IRP, Tail.Overlay.DeviceQueueEntry);

#if DBG
            InterlockedDecrement (
                &LogicalUnit->NumberOfIrpQueued
                );
#endif // DBG

        }
    }

    if (!nextIrp) {

        DebugPrint ((2, "IdePort GetNextLuRequest: 0x%x 0x%x no irp to processing\n",
                     DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                     LogicalUnit->TargetId
                     ));
    }

    if (nextIrp) {

        BOOLEAN pendingRequest;

        irpStack = IoGetCurrentIrpStackLocation(nextIrp);
        srb = (PSCSI_REQUEST_BLOCK)irpStack->Parameters.Others.Argument1;

        if (LogicalUnit->PdoState & PDOS_QUEUE_BLOCKED) {

            DebugPrint ((2, "IdePort GetNextLuRequest: 0x%x 0x%x Lu must queue\n",
                         DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                         LogicalUnit->TargetId
                         ));

            pendingRequest = TRUE;

            if (!(LogicalUnit->PdoState & PDOS_MUST_QUEUE)) {

                //
                // device is powered down
                // use a large time in case it spins up slowly
                //
                if (srb->TimeOutValue < DEFAULT_SPINUP_TIME) {

                    srb->TimeOutValue = DEFAULT_SPINUP_TIME;
                }

                //
                // We are not powered up.
                // issue an power up
                //
                powerUpDevice = TRUE;

                DebugPrint ((2, "IdePort GetNextLuRequest: 0x%x 0x%x need to spin up device, requeue irp 0x%x\n",
                             DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             LogicalUnit->TargetId,
                             nextIrp));
            }

        } else {

            pendingRequest = FALSE;
        }

        if (pendingRequest) {

            ASSERT (LogicalUnit->PendingRequest == NULL);
            LogicalUnit->PendingRequest = nextIrp;

            nextIrp = NULL;
        }
    }

    if (nextIrp) {

        //
        // Set the new current key.
        //
        LogicalUnit->CurrentKey = srb->QueueSortKey;

        //
        // Hack to work-around the starvation led to by numerous requests touching the same sector.
        //

        LogicalUnit->CurrentKey++;

        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        DebugPrint ((2, "GetNextLuRequest: IoStartPacket 0x%x\n", nextIrp));

        IoStartPacket(DeviceExtension->DeviceObject, nextIrp, (PULONG)NULL, NULL);

    } else {

        NTSTATUS status;

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        if (powerUpDevice) {

            powerState.DeviceState = PowerDeviceD0;
            status = PoRequestPowerIrp (
                         LogicalUnit->DeviceObject,
                         IRP_MN_SET_POWER,
                         powerState,
                         NULL,
                         NULL,
                         NULL
                         );
            ASSERT (NT_SUCCESS(status));
        }
    }

} // end GetNextLuRequest()

VOID
IdeLogTimeoutError(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp,
    IN ULONG UniqueId
    )
/*++

Routine Description:

    This function logs an error when a request times out.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.

    Irp - Supplies a pointer to the request which timedout.

    UniqueId - Supplies the UniqueId for this error.

Return Value:

    None.

Notes:

    The port device extension spinlock should be held when this routine is
    called.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    PIO_STACK_LOCATION   irpStack;
    PSRB_DATA            srbData;
    PSCSI_REQUEST_BLOCK  srb;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    srb = (PSCSI_REQUEST_BLOCK)irpStack->Parameters.Others.Argument1;
    srbData = IdeGetSrbData(DeviceExtension, srb);

    if (!srbData) {
        return;
    }

    errorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                                                   sizeof(IO_ERROR_LOG_PACKET) + 4 * sizeof(ULONG));

    if (errorLogEntry != NULL) {
        errorLogEntry->ErrorCode = IO_ERR_TIMEOUT;
        errorLogEntry->SequenceNumber = srbData->SequenceNumber;
        errorLogEntry->MajorFunctionCode = irpStack->MajorFunction;
        errorLogEntry->RetryCount = (UCHAR) srbData->ErrorLogRetryCount;
        errorLogEntry->UniqueErrorValue = UniqueId;
        errorLogEntry->FinalStatus = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize = 4 * sizeof(ULONG);
        errorLogEntry->DumpData[0] = srb->PathId;
        errorLogEntry->DumpData[1] = srb->TargetId;
        errorLogEntry->DumpData[2] = srb->Lun;
        errorLogEntry->DumpData[3] = SP_REQUEST_TIMEOUT;

        IoWriteErrorLogEntry(errorLogEntry);
    }
}

VOID
IdeLogResetError(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK  Srb,
    IN ULONG UniqueId
    )
/*++

Routine Description:

    This function logs an error when the bus is reset.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.

    Srb - Supplies a pointer to the request which timed-out.

    UniqueId - Supplies the UniqueId for this error.

Return Value:

    None.

Notes:

    The port device extension spinlock should be held when this routine is
    called.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    PIO_STACK_LOCATION   irpStack;
    PIRP                 irp;
    PSRB_DATA            srbData;
    ULONG                sequenceNumber = 0;
    UCHAR                function       = 0,
                         pathId         = 0,
                         targetId       = 0,
                         lun            = 0,
                         retryCount     = 0;

    if (Srb) {

        irp = Srb->OriginalRequest;

        if (irp) {
            irpStack = IoGetCurrentIrpStackLocation(irp);
            function = irpStack->MajorFunction;
        }

        srbData = IdeGetSrbData(DeviceExtension, Srb);

        if (!srbData) {
            return;
        }

        pathId         = Srb->PathId;
        targetId       = Srb->TargetId;
        lun            = Srb->Lun;
        retryCount     = (UCHAR) srbData->ErrorLogRetryCount;
        sequenceNumber = srbData->SequenceNumber;


    }

    errorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry( DeviceExtension->DeviceObject,
                                                                    sizeof(IO_ERROR_LOG_PACKET)
                                                                        + 4 * sizeof(ULONG) );

    if (errorLogEntry != NULL) {
        errorLogEntry->ErrorCode         = IO_ERR_TIMEOUT;
        errorLogEntry->SequenceNumber    = sequenceNumber;
        errorLogEntry->MajorFunctionCode = function;
        errorLogEntry->RetryCount        = retryCount;
        errorLogEntry->UniqueErrorValue  = UniqueId;
        errorLogEntry->FinalStatus       = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize      = 4 * sizeof(ULONG);
        errorLogEntry->DumpData[0]       = pathId;
        errorLogEntry->DumpData[1]       = targetId;
        errorLogEntry->DumpData[2]       = lun;
        errorLogEntry->DumpData[3]       = SP_REQUEST_TIMEOUT;

        IoWriteErrorLogEntry(errorLogEntry);
    }
}

NTSTATUS
IdeTranslateSrbStatus(
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    This routine translates an srb status into an ntstatus.

Arguments:

    Srb - Supplies a pointer to the failing Srb.

Return Value:

    An nt status approprate for the error.

--*/

{
    switch (SRB_STATUS(Srb->SrbStatus)) {
    case SRB_STATUS_INVALID_LUN:
    case SRB_STATUS_INVALID_TARGET_ID:
    case SRB_STATUS_NO_DEVICE:
    case SRB_STATUS_NO_HBA:
        return(STATUS_DEVICE_DOES_NOT_EXIST);
    case SRB_STATUS_COMMAND_TIMEOUT:
    case SRB_STATUS_BUS_RESET:
    case SRB_STATUS_TIMEOUT:
        return(STATUS_IO_TIMEOUT);
    case SRB_STATUS_SELECTION_TIMEOUT:
        return(STATUS_DEVICE_NOT_CONNECTED);
    case SRB_STATUS_BAD_FUNCTION:
    case SRB_STATUS_BAD_SRB_BLOCK_LENGTH:
        return(STATUS_INVALID_DEVICE_REQUEST);
    case SRB_STATUS_DATA_OVERRUN:
        return(STATUS_BUFFER_OVERFLOW);
    default:
        return(STATUS_IO_DEVICE_ERROR);
    }

    return(STATUS_IO_DEVICE_ERROR);
}


BOOLEAN
IdeResetBusSynchronized (
    PVOID ServiceContext
    )
/*++

Routine Description:

    This function resets the bus and sets up the port timer so the reset hold
    flag is clean when necessary.

Arguments:

    ServiceContext - Supplies a pointer to the reset context which includes a
        pointer to the device extension and the pathid to be reset.

Return Value:

    TRUE - if the reset succeeds.

--*/

{
    PRESET_CONTEXT resetContext = ServiceContext;
    PFDO_EXTENSION deviceExtension;
    PSCSI_REQUEST_BLOCK  resetSrbToComplete;
    BOOLEAN goodReset;

    resetSrbToComplete  = NULL;
    deviceExtension     = resetContext->DeviceExtension;

    //
    // Should never get a reset srb while one is in progress
    //
    if (resetContext->ResetSrb && deviceExtension->ResetSrb) {

        ASSERT (resetContext->ResetSrb == deviceExtension->ResetSrb);
    }

    if (resetContext->NewResetSequence) {
        //
        // a new reset sequence to kill the reset in progress if any
        //

        if (deviceExtension->ResetCallAgain) {

            DebugPrint ((0, "ATAPI: WARNING: Resetting a reset\n"));

            deviceExtension->ResetCallAgain = 0;

            if (deviceExtension->ResetSrb) {

                resetSrbToComplete = deviceExtension->ResetSrb;
                resetSrbToComplete->SrbStatus = SRB_STATUS_ERROR;

                deviceExtension->ResetSrb = NULL;
            }

        }
        deviceExtension->ResetSrb = resetContext->ResetSrb;
    }

    goodReset = AtapiResetController (
                    deviceExtension->HwDeviceExtension,
                    resetContext->PathId,
                    &deviceExtension->ResetCallAgain);

    //
    // Set the reset hold flag and start the counter if the reset is not done
    //
    if ((goodReset) && (deviceExtension->ResetCallAgain)) {

        deviceExtension->InterruptData.InterruptFlags |= PD_RESET_HOLD;
        deviceExtension->PortTimeoutCounter = PD_TIMER_RESET_HOLD_TIME;

    } else {

        CLRMASK (deviceExtension->InterruptData.InterruptFlags, PD_RESET_HOLD);
        deviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;

        if (deviceExtension->ResetSrb) {

            resetSrbToComplete = deviceExtension->ResetSrb;
            deviceExtension->ResetSrb = NULL;
        }

        if (resetSrbToComplete) {

            if (goodReset) {

                resetSrbToComplete->SrbStatus = SRB_STATUS_SUCCESS;

            } else {

                resetSrbToComplete->SrbStatus = SRB_STATUS_ERROR;
            }
        }

        if (goodReset) {

            IdePortNotification(IdeResetDetected,
                                deviceExtension->HwDeviceExtension,
                                resetSrbToComplete);
        }

        if (deviceExtension->InterruptData.InterruptFlags & PD_HELD_REQUEST) {

            //
            // Clear the held request flag and restart the request.
            //

            CLRMASK (deviceExtension->InterruptData.InterruptFlags, PD_HELD_REQUEST);
            IdeStartIoSynchronized(deviceExtension->DeviceObject);
        }
    }

    if (resetSrbToComplete) {

        IdePortNotification(IdeRequestComplete,
                            deviceExtension->HwDeviceExtension,
                            resetSrbToComplete);

        IdePortNotification(IdeNextRequest,
                            deviceExtension->HwDeviceExtension,
                            NULL);
    }

    //
    // Check for miniport work requests.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

        //
        // Queue a DPC.
        //
        IoRequestDpc(deviceExtension->DeviceObject, NULL, NULL);
    }

    return(TRUE);
}


VOID
IdeProcessCompletedRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    OUT PBOOLEAN CallStartIo
    )
/*++
Routine Description:

    This routine processes a request which has completed.  It completes any
    pending transfers, releases the adapter objects and map registers when
    necessary.  It deallocates any resources allocated for the request.
    It processes the return status, by requeueing busy request, requesting
    sense information or logging an error.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension for the
        adapter data.

    SrbData - Supplies a pointer to the SRB data block to be completed.

    CallStartIo - This value is set if the start I/O routine needs to be
        called.

Return Value:

    None.

--*/

{

    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK     srb;
    PIO_ERROR_LOG_PACKET    errorLogEntry;
    ULONG                   sequenceNumber;
    LONG                    interlockResult;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    PHW_DEVICE_EXTENSION     hwDeviceExtension = DeviceExtension->HwDeviceExtension;

    ASSERT(SrbData->CurrentSrb);
    srb = SrbData->CurrentSrb;
    irp = srb->OriginalRequest;

    DebugPrint((2,"CompletedRequest: Irp 0x%8x Srb 0x%8x DataBuf 0x%8x Len 0x%8x\n", irp, srb, srb->DataBuffer, srb->DataTransferLength));

#ifdef IDE_MULTIPLE_IRP_COMPLETE_REQUESTS_CHECK
    if (irp->CurrentLocation > (CCHAR) (irp->StackCount + 1)) {
        KeBugCheckEx( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) irp, (ULONG_PTR) srb, 0, 0 );
    }
#endif // IDE_MULTIPLE_IRP_COMPLETE_REQUESTS_CHECK


    irpStack = IoGetCurrentIrpStackLocation(irp);


    //
    // Get logical unit extension for this request.
    //

    logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);

    //
    // If miniport needs mapped system addresses, the the
    // data buffer address in the SRB must be restored to
    // original unmapped virtual address. Ensure that this request requires
    // a data transfer.
    //

    if (srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) {
        if (!SRB_USES_DMA(srb)) {
            if (irp->MdlAddress) {

                //
                // If an IRP is for a transfer larger than a miniport driver
                // can handle, the request is broken up into multiple smaller
                // requests. Each request uses the same MDL and the data
                // buffer address field in the SRB may not be at the
                // beginning of the memory described by the MDL.
                //

                srb->DataBuffer = (PCCHAR)MmGetMdlVirtualAddress(irp->MdlAddress) +
                    ((PCCHAR)srb->DataBuffer - SrbData->SrbDataOffset);

                //
                // Since this driver driver did programmaged I/O then the buffer
                // needs to flushed if this an data-in transfer.
                //

                if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

                    KeFlushIoBuffers(irp->MdlAddress,
                                     TRUE,
                                     FALSE);
                }

				if (SrbData->Flags & SRB_DATA_RESERVED_PAGES) {

					KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
					IdeUnmapReservedMapping(DeviceExtension, SrbData, irp->MdlAddress);
					KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);


				}
            }
        }
    }

    //
    // Clear the current request.
    //

    SrbData->CurrentSrb = NULL;

    //
    // If the no diconnect flag was set for this SRB, then check to see
    // if IoStartNextPacket must be called.
    //

    if (srb->SrbFlags & SRB_FLAGS_DISABLE_DISCONNECT) {

        //
        // Acquire the spinlock to protect the flags strcuture.
        //

        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

        //
        // Set the disconnect running flag and check the busy flag.
        //

        DeviceExtension->Flags |= PD_DISCONNECT_RUNNING;

        //
        // The interrupt flags are checked unsynchonized.  This works because
        // the RESET_HOLD flag is cleared with the spinlock held and the
        // counter is only set with the spinlock held.  So the only case where
        // there is a problem is is a reset occurs before this code get run,
        // but this code runs before the timer is set for a reset hold;
        // the timer will soon set for the new value.
        //

        if (!(DeviceExtension->InterruptData.InterruptFlags & PD_RESET_HOLD)) {

            //
            // The miniport is ready for the next request and there is not a
            // pending reset hold, so clear the port timer.
            //

            DeviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;
        }

        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        if (!(DeviceExtension->Flags & PD_DEVICE_IS_BUSY) &&
            !*CallStartIo &&
            !(DeviceExtension->Flags & PD_PENDING_DEVICE_REQUEST)) {

            //
            // The busy flag is clear so the miniport has requested the
            // next request. Call IoStartNextPacket.
            //

            IoStartNextPacket(DeviceExtension->DeviceObject, FALSE);
        }
    }

    //
    // Check if scatter/gather list came from pool.
    //

    if (srb->SrbFlags & SRB_FLAGS_SGLIST_FROM_POOL) {

        CLRMASK (srb->SrbFlags, SRB_FLAGS_SGLIST_FROM_POOL);
    }

    //
    // Acquire the spinlock to protect the flags structure,
    // and the free of the srb extension.
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    //
    // Move bytes transfered to IRP.
    //
    irp->IoStatus.Information = srb->DataTransferLength;

    //
    // Save the sequence number in case an error needs to be logged later.
    //
    sequenceNumber = SrbData->SequenceNumber;
    SrbData->SequenceNumber = 0;
    SrbData->ErrorLogRetryCount = 0;

#if DBG
    SrbData = NULL;
#endif

    if (DeviceExtension->Flags & PD_PENDING_DEVICE_REQUEST) {

        //
        // The start I/O routine needs to be called because it could not
        // allocate an srb extension.  Clear the pending flag and note
        // that it needs to be called later.
        //

        CLRMASK (DeviceExtension->Flags, PD_PENDING_DEVICE_REQUEST);
        *CallStartIo = TRUE;
    }

    //
    // If success then start next packet.
    // Not starting packet effectively
    // freezes the queue.
    //


    if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) {

        ULONG srbFlags;
#if DBG
        PVOID tag = irp;
#endif

        irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // save the srbFlags for later user
        //
        srbFlags = srb->SrbFlags;


        if (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) {

            //
            // must complete power irp before starting a new request
            //
            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            //
            // Decrement the logUnitExtension reference count
            //
            UnrefLogicalUnitExtensionWithTag(
                DeviceExtension,
                logicalUnit,
                tag
                );

            IoCompleteRequest(irp, IO_DISK_INCREMENT);
            irp = NULL;


            //
            // we had a device state transition...restart the lu queue
            //
            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
            GetNextLuRequest(DeviceExtension, logicalUnit);

        } else {

            //
            // If the queue is being bypassed then keep the queue frozen.
            // If there are outstanding requests as indicated by the timer
            // being active then don't start the then next request.
            //
            if (!(srbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) &&
                logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

                //
                // This is a normal request start the next packet.
                //

                GetNextLuRequest(DeviceExtension, logicalUnit);

            } else {

                //
                // Release the spinlock.
                //

                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
            }
        }

        DebugPrint((2,
                    "IdeProcessCompletedRequests: Iocompletion IRP %lx\n",
                    irp));

        //
        // Note that the retry count and sequence number are not cleared
        // for completed packets which were generated by the port driver.
        //
        if (irp) {

            //
            // Decrement the logUnitExtension reference count
            //
            UnrefLogicalUnitExtensionWithTag(
                DeviceExtension,
                logicalUnit,
                tag
                );


            IoCompleteRequest(irp, IO_DISK_INCREMENT);
        }

        return;

    }

    //
    // Set IRP status. Class drivers will reset IRP status based
    // on request sense if error.
    //

    irp->IoStatus.Status = IdeTranslateSrbStatus(srb);

    DebugPrint((2, "IdeProcessCompletedRequests: Queue frozen TID %d\n",
        srb->TargetId));

    if ((srb->SrbStatus == SRB_STATUS_TIMEOUT) ||
        (srb->SrbStatus == SRB_STATUS_BUS_RESET)) {

        if (SRB_USES_DMA(srb)) {

            ULONG errorCount;

            //
            // retry with PIO
            //
            DebugPrint ((DBG_ALWAYS, "ATAPI: retrying dma srb 0x%x with pio\n", srb));

            MARK_SRB_AS_PIO_CANDIDATE(srb);

            srb->SrbStatus = SRB_STATUS_PENDING;
            srb->ScsiStatus = 0;

            if (srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) {

                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                //
                // iostart the fdo
                //
                IoStartPacket(DeviceExtension->DeviceObject, irp, (PULONG)NULL, NULL);

            } else {

                KeInsertByKeyDeviceQueue(&logicalUnit->DeviceObject->DeviceQueue,
                                         &irp->Tail.Overlay.DeviceQueueEntry,
                                         srb->QueueSortKey);

                GetNextLuRequest(DeviceExtension, logicalUnit);
            }

            //
            // spinlock is released.
            //

            //
            // we got an error using DMA
            //
            errorCount = InterlockedIncrement(&logicalUnit->DmaTransferTimeoutCount);

            if (errorCount == PDO_DMA_TIMEOUT_LIMIT) {

                ERROR_LOG_ENTRY errorLogEntry;
                ULONG i;

                //
                // Timeout errors need not be device specific. So no need to
                // update the hall of shame
                //
                errorLogEntry.ErrorCode             = SP_PROTOCOL_ERROR;
                errorLogEntry.MajorFunctionCode     = IRP_MJ_SCSI;
                errorLogEntry.PathId                = srb->PathId;
                errorLogEntry.TargetId              = srb->TargetId;
                errorLogEntry.Lun                   = srb->Lun;
                errorLogEntry.UniqueId              = ERRLOGID_TOO_MANY_DMA_TIMEOUT;
                errorLogEntry.ErrorLogRetryCount    = errorCount;
                errorLogEntry.SequenceNumber        = 0;

                LogErrorEntry(
                    DeviceExtension,
                    &errorLogEntry
                    );

                //
                // disable DMA
                //
                hwDeviceExtension->DeviceParameters[srb->TargetId].TransferModeMask |= DMA_SUPPORT;

                DebugPrint ((DBG_ALWAYS,
                             "ATAPI ERROR: 0x%x target %d has too many DMA timeout, falling back to PIO\n",
                             DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             srb->TargetId
                             ));

                //
                // rescan the bus to update transfer mode
                //
#if defined (BUS_CHECK_ON_DMA_ERROR)
                IoInvalidateDeviceRelations (
                    DeviceExtension->AttacheePdo,
                    BusRelations
                    );
#endif // BUS_CHECK_ON_DMA_ERROR
            }

            return;

        } else {

            if ((!TestForEnumProbing(srb)) &&
                (srb->Function != SRB_FUNCTION_ATA_POWER_PASS_THROUGH) &&
                (srb->Function != SRB_FUNCTION_ATA_PASS_THROUGH)) {

                ULONG errorCount;
                ULONG errorCountLimit;

				//
				// Check if were trying the flush the device cache
				//
				if ((srb->Function == SRB_FUNCTION_FLUSH) ||
					(srb->Function == SRB_FUNCTION_SHUTDOWN) ||
					(srb->Cdb[0] == SCSIOP_SYNCHRONIZE_CACHE)) {

					errorCount = InterlockedIncrement(&logicalUnit->FlushCacheTimeoutCount);

					DebugPrint((1,
								"FlushCacheTimeout incremented to 0x%x\n",
								errorCount
								));

					//
					// Disable flush on IDE devices
					//
					if (errorCount >= PDO_FLUSH_TIMEOUT_LIMIT ) {
						hwDeviceExtension->
							DeviceParameters[srb->TargetId].IdeFlushCommand = IDE_COMMAND_NO_FLUSH;
#ifdef ENABLE_48BIT_LBA
						hwDeviceExtension->
							DeviceParameters[srb->TargetId].IdeFlushCommandExt = IDE_COMMAND_NO_FLUSH;
#endif
					}

					ASSERT (errorCount <= PDO_FLUSH_TIMEOUT_LIMIT);

					//
					// looks like the device doesn't support flush cache
					//
					srb->SrbStatus = SRB_STATUS_SUCCESS;
					irp->IoStatus.Status = STATUS_SUCCESS;

				} else {

					errorCount = InterlockedIncrement(&logicalUnit->ConsecutiveTimeoutCount);

					DebugPrint ((DBG_ALWAYS, "0x%x target %d has 0x%x timeout errors so far\n",
								logicalUnit->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
								logicalUnit->TargetId,
								errorCount));

					if (errorCount == PDO_CONSECUTIVE_TIMEOUT_WARNING_LIMIT) {

						//
						// the device not looking good
						// make sure it is still there
						//
						IoInvalidateDeviceRelations (
							DeviceExtension->AttacheePdo,
							BusRelations
							);
					}

					if (logicalUnit->PagingPathCount) {

						errorCountLimit = PDO_CONSECUTIVE_PAGING_TIMEOUT_LIMIT;

					} else {

						errorCountLimit = PDO_CONSECUTIVE_TIMEOUT_LIMIT;
					}

					if (errorCount >= errorCountLimit) {

						DebugPrint ((DBG_ALWAYS, "0x%x target %d has too many timeout.  it is a goner...\n",
									 logicalUnit->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
									 logicalUnit->TargetId));


						//
						// looks like the device is dead.
						//
						KeAcquireSpinLockAtDpcLevel(&logicalUnit->PdoSpinLock);

						SETMASK (logicalUnit->PdoState, PDOS_DEADMEAT);

						IdeLogDeadMeatReason( logicalUnit->DeadmeatRecord.Reason, 
											  tooManyTimeout
											  );

						KeReleaseSpinLockFromDpcLevel(&logicalUnit->PdoSpinLock);

						IoInvalidateDeviceRelations (
							DeviceExtension->AttacheePdo,
							BusRelations
							);
					}
				}

            }

        }

    } else {

        //
        // reset error count
        //
        InterlockedExchange(&logicalUnit->ConsecutiveTimeoutCount, 0);
    }


    if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_PARITY_ERROR) {

        ULONG errorCount;
        errorCount = InterlockedIncrement(&logicalUnit->CrcErrorCount);
        if (errorCount == PDO_UDMA_CRC_ERROR_LIMIT) {

            ERROR_LOG_ENTRY errorLogEntry;
            ULONG xferMode;

            errorLogEntry.ErrorCode             = SP_BUS_PARITY_ERROR;
            errorLogEntry.MajorFunctionCode     = IRP_MJ_SCSI;
            errorLogEntry.PathId                = srb->PathId;
            errorLogEntry.TargetId              = srb->TargetId;
            errorLogEntry.Lun                   = srb->Lun;
            errorLogEntry.UniqueId              = ERRLOGID_TOO_MANY_CRC_ERROR;
            errorLogEntry.ErrorLogRetryCount    = errorCount;
            errorLogEntry.SequenceNumber        = 0;

            LogErrorEntry(
                DeviceExtension,
                &errorLogEntry
                );

            //
            //Procure the selected transfer mode again.
            //
            GetHighestDMATransferMode(hwDeviceExtension->DeviceParameters[srb->TargetId].TransferModeSelected,
                                      xferMode);

            //
            //Gradual degradation.
            //
            if (xferMode > UDMA0) {

                hwDeviceExtension->DeviceParameters[srb->TargetId].TransferModeMask |= (1 << xferMode);

            } else if (xferMode == UDMA0) {

                // Don't use MWDMA and SWDMA
                hwDeviceExtension->DeviceParameters[srb->TargetId].TransferModeMask |= DMA_SUPPORT;

            }

            DebugPrint ((DBG_ALWAYS,
                         "ATAPI ERROR: 0x%x target %d has too many crc error, degrading to a lower DMA mode\n",
                         DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                         srb->TargetId
                         ));

            //
            // rescan the bus to update transfer mode
            //
            IoInvalidateDeviceRelations (
                DeviceExtension->AttacheePdo,
                BusRelations
                );
        }
    }


    if ((srb->ScsiStatus == SCSISTAT_BUSY ||
         srb->SrbStatus == SRB_STATUS_BUSY ||
         srb->ScsiStatus == SCSISTAT_QUEUE_FULL) &&
         !(srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {

        //
        // Perform busy processing if a busy type status was returned and this
        // is not a by-pass request.
        //

        DebugPrint((1,
                   "SCSIPORT: Busy SRB status %x, SCSI status %x)\n",
                   srb->SrbStatus,
                   srb->ScsiStatus));

        //
        // If there is already a pending busy request or the queue is frozen
        // then just requeue this request.
        //

        if (logicalUnit->LuFlags & (PD_LOGICAL_UNIT_IS_BUSY | PD_QUEUE_FROZEN)) {

            DebugPrint((1,
                       "IdeProcessCompletedRequest: Requeuing busy request\n"));

            srb->SrbStatus = SRB_STATUS_PENDING;
            srb->ScsiStatus = 0;

            if (!KeInsertByKeyDeviceQueue(&logicalUnit->DeviceObject->DeviceQueue,
                                          &irp->Tail.Overlay.DeviceQueueEntry,
                                          srb->QueueSortKey)) {

                //
                // This should never occur since there is a busy request.
                //

                srb->SrbStatus = SRB_STATUS_ERROR;
                srb->ScsiStatus = SCSISTAT_BUSY;

                ASSERT(FALSE);
                goto BusyError;

            }

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        } else if (logicalUnit->RetryCount++ < BUSY_RETRY_COUNT) {

            //
            // If busy status is returned, then indicate that the logical
            // unit is busy.  The timeout code will restart the request
            // when it fires. Reset the status to pending.
            //

            srb->SrbStatus = SRB_STATUS_PENDING;
            srb->ScsiStatus = 0;

            logicalUnit->LuFlags |= PD_LOGICAL_UNIT_IS_BUSY;
            logicalUnit->BusyRequest = irp;

            if (logicalUnit->RetryCount == (BUSY_RETRY_COUNT/2) ) {

                RESET_CONTEXT resetContext;

                DebugPrint ((0,
                             "ATAPI: PDO 0x%x 0x%x seems to be DEAD.  try a reset to bring it back.\n",
                             logicalUnit, logicalUnit->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress
                            ));

                resetContext.DeviceExtension = DeviceExtension;
                resetContext.PathId = srb->PathId;
                resetContext.NewResetSequence = TRUE;
                resetContext.ResetSrb = NULL;

                KeSynchronizeExecution(DeviceExtension->InterruptObject,
                                       IdeResetBusSynchronized,
                                       &resetContext);

#if DBG
                IdeDebugHungControllerCounter = 0;
#endif // DBG
            }

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        } else {

BusyError:
            //
            // Indicate the queue is frozen.
            //

			if (!(srb->SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE)) {
				srb->SrbStatus |= SRB_STATUS_QUEUE_FROZEN;
				logicalUnit->LuFlags |= PD_QUEUE_FROZEN;
			}

//#if DBG
//            if (logicalUnit->PdoState & PDOS_DEADMEAT) {
//                DbgBreakPoint();
//            }
//#endif

            //
            // Release the spinlock.  Start the next request.
            //
            if (!(srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) &&
                logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

                //
                // This is a normal request start the next packet.
                //
                GetNextLuRequest(DeviceExtension, logicalUnit);

            } else {

                //
                // Release the spinlock.
                //
                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
            }

            if (!TestForEnumProbing(srb)) {

                //
                // Log an a timeout erorr if we are not probing during bus-renum.
                //

                errorLogEntry = (PIO_ERROR_LOG_PACKET)
                    IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                            sizeof(IO_ERROR_LOG_PACKET) + 4 * sizeof(ULONG));

                if (errorLogEntry != NULL) {
                    errorLogEntry->ErrorCode = IO_ERR_NOT_READY;
                    errorLogEntry->SequenceNumber = sequenceNumber;
                    errorLogEntry->MajorFunctionCode =
                       IoGetCurrentIrpStackLocation(irp)->MajorFunction;
                    errorLogEntry->RetryCount = logicalUnit->RetryCount;
                    errorLogEntry->UniqueErrorValue = 259;
                    errorLogEntry->FinalStatus = STATUS_DEVICE_NOT_READY;
                    errorLogEntry->DumpDataSize = 5 * sizeof(ULONG);
                    errorLogEntry->DumpData[0] = srb->PathId;
                    errorLogEntry->DumpData[1] = srb->TargetId;
                    errorLogEntry->DumpData[2] = srb->Lun;
                    errorLogEntry->DumpData[3] = srb->ScsiStatus;
                    errorLogEntry->DumpData[4] = SP_REQUEST_TIMEOUT;


                    IoWriteErrorLogEntry(errorLogEntry);
                }
            }

            irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;

            //
            // Decrement the logUnitExtension reference count
            //
            UnrefLogicalUnitExtensionWithTag(
                DeviceExtension,
                logicalUnit,
                irp
                );

            IoCompleteRequest(irp, IO_DISK_INCREMENT);
        }

        return;
    }

    //
    // If the request sense data is valid, or none is needed and this request
    // is not going to freeze the queue, then start the next request for this
    // logical unit if it is idle.
    //

    if (!NEED_REQUEST_SENSE(srb) && srb->SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE) {

        if (logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

            GetNextLuRequest(DeviceExtension, logicalUnit);

            //
            // The spinlock is released by GetNextLuRequest.
            //

        } else {

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        }

    } else {

        //
        // NOTE:  This will also freeze the queue.  For a case where there
        // is no request sense.
        //

//        if (srb->SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE) {
//            DebugPrint ((DBG_ALWAYS, "BAD BAD BAD: Freezing queue even with a no_queue_freeze request srb = 0x%x\n", srb));
//        }

        if (!(srb->SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE)) {
            srb->SrbStatus |= SRB_STATUS_QUEUE_FROZEN;
            logicalUnit->LuFlags |= PD_QUEUE_FROZEN;
        }

//#if DBG
//        if (logicalUnit->PdoState & PDOS_DEADMEAT) {
//            DbgBreakPoint();
//        }
//#endif

        //
        // Determine if a REQUEST SENSE command needs to be done.
        // Check that a CHECK_CONDITION was received, an autosense has not
        // been done already, and that autosense has been requested.
        //

        if (NEED_REQUEST_SENSE(srb)) {

            srb->SrbStatus |= SRB_STATUS_QUEUE_FROZEN;
            logicalUnit->LuFlags |= PD_QUEUE_FROZEN;

            //
            // If a request sense is going to be issued then any busy
            // requests must be requeue so that the time out routine does
            // not restart them while the request sense is being executed.
            //

            if (logicalUnit->LuFlags & PD_LOGICAL_UNIT_IS_BUSY) {

                DebugPrint((1, "IdeProcessCompletedRequest: Requeueing busy request to allow request sense.\n"));

                if (!KeInsertByKeyDeviceQueue(
                    &logicalUnit->DeviceObject->DeviceQueue,
                    &logicalUnit->BusyRequest->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey)) {

                    //
                    // This should never occur since there is a busy request.
                    // Complete the current request without request sense
                    // informaiton.
                    //

                    ASSERT(FALSE);
                    DebugPrint((3, "IdeProcessCompletedRequests: Iocompletion IRP %lx\n", irp ));

                    //
                    // Release the spinlock.
                    //

                    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                    //
                    // Decrement the logUnitExtension reference count
                    //
                    UnrefLogicalUnitExtensionWithTag(
                        DeviceExtension,
                        logicalUnit,
                        irp
                        );

                    IoCompleteRequest(irp, IO_DISK_INCREMENT);
                    return;

                }

                //
                // Clear the busy flag.
                //

                CLRMASK (logicalUnit->LuFlags, PD_LOGICAL_UNIT_IS_BUSY | PD_QUEUE_IS_FULL);

            }

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            //
            // Call IssueRequestSense and it will complete the request
            // after the REQUEST SENSE completes.
            //

            IssueRequestSense(logicalUnit, srb);

            return;
        }

        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    }

    //
    // Decrement the logUnitExtension reference count
    //
    UnrefLogicalUnitExtensionWithTag(
        DeviceExtension,
        logicalUnit,
        irp
        );


    IoCompleteRequest(irp, IO_DISK_INCREMENT);
}

PSRB_DATA
IdeGetSrbData(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This function returns the SRB data for the addressed unit.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension.

    Srb - Supplies the scsi request block 

Return Value:

    Returns a pointer to the SRB data.  NULL is returned if the address is not
    valid.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    PLOGICAL_UNIT_EXTENSION logicalUnit;


    irp = Srb->OriginalRequest;
    if (irp == NULL) {
        return NULL;
    }
    irpStack = IoGetCurrentIrpStackLocation(irp);
    logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);

    if (logicalUnit == NULL) {
        return NULL;
    }

    return &logicalUnit->SrbData;
}

VOID
IdeCompleteRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    IN UCHAR SrbStatus
    )
/*++

Routine Description:

    The routine completes the specified request.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension.

    SrbData - Supplies a pointer to the SrbData for the request to be
        completed.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb;

    //
    // Make sure there is a current request.
    //

    ASSERT(SrbData->CurrentSrb);
    srb = SrbData->CurrentSrb;

    if (srb == NULL || !(srb->SrbFlags & SRB_FLAGS_IS_ACTIVE)) {
        return;
    }

    //
    // Update SRB status.
    //

    srb->SrbStatus = SrbStatus;

    //
    // Indicate no bytes transferred.
    //
    if (!SRB_USES_DMA(srb)) {

        srb->DataTransferLength = 0;

    } else {

        // if we are doing DMA, preserve DataTransferLength.
        // so retry will know how many bytes to transfer
    }

    //
    // Call notification routine.
    //

    IdePortNotification(IdeRequestComplete,
                (PVOID)(DeviceExtension + 1),
                srb);

}

NTSTATUS
IdeSendMiniPortIoctl(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    )

/*++

Routine Description:

    This function sends a miniport ioctl to the miniport driver.
    It creates an srb which is processed normally by the port driver.
    This call is synchronous.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    RequestIrp - Supplies a pointe to the Irp which made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/

{
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    PSRB_IO_CONTROL         srbControl;
    SCSI_REQUEST_BLOCK      srb;
    KEVENT                  event;
    LARGE_INTEGER           startingOffset;
    IO_STATUS_BLOCK         ioStatusBlock;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    ULONG                   outputLength;
    ULONG                   length;
    ULONG                   target;
    IDE_PATH_ID             pathId;

    PAGED_CODE();
    startingOffset.QuadPart = (LONGLONG) 1;

    DebugPrint((3,"IdeSendMiniPortIoctl: Enter routine\n"));

    //
    // Get a pointer to the control block.
    //

    irpStack = IoGetCurrentIrpStackLocation(RequestIrp);
    srbControl = RequestIrp->AssociatedIrp.SystemBuffer;
    RequestIrp->IoStatus.Information = 0;

    //
    // Validiate the user buffer.
    //

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SRB_IO_CONTROL)){

        RequestIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        return(STATUS_INVALID_PARAMETER);
    }

    if (srbControl->HeaderLength != sizeof(SRB_IO_CONTROL)) {
        RequestIrp->IoStatus.Status = STATUS_REVISION_MISMATCH;
        return(STATUS_REVISION_MISMATCH);
    }

    length = srbControl->HeaderLength + srbControl->Length;
    if ((length < srbControl->HeaderLength) ||
        (length < srbControl->Length)) {

        //
        // total length overflows a ULONG
        //
        return(STATUS_INVALID_PARAMETER);
    }

    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < length &&
        irpStack->Parameters.DeviceIoControl.InputBufferLength < length ) {

        RequestIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Set the logical unit addressing to the first logical unit.  This is
    // merely used for addressing purposes.
    //
    pathId.l = 0;
    while (logicalUnit = NextLogUnitExtensionWithTag(
                             DeviceExtension,
                             &pathId,
                             FALSE,
                             RequestIrp
                             )) {

        //
        // Walk the logical unit list to the end, looking for a safe one.
        // If it was created for a rescan, it might be freed before this request is
        // complete.
        //

        if (!(logicalUnit->LuFlags & PD_RESCAN_ACTIVE)) {

            //
            // Found a good one!
            //
            break;
        }

        UnrefLogicalUnitExtensionWithTag (
            DeviceExtension,
            logicalUnit,
            RequestIrp
            );
    }

    if (logicalUnit == NULL) {
        RequestIrp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        return(STATUS_DEVICE_DOES_NOT_EXIST);
    }

    //
    // Initialize the notification event.
    //

    KeInitializeEvent(&event,
                        NotificationEvent,
                        FALSE);

    //
    // Build IRP for this request.
    // Note we do this synchronously for two reasons.  If it was done
    // asynchonously then the completion code would have to make a special
    // check to deallocate the buffer.  Second if a completion routine were
    // used then an additional IRP stack location would be needed.
    //

    irp = IoBuildSynchronousFsdRequest(
                IRP_MJ_SCSI,
                logicalUnit->DeviceObject,
                srbControl,
                length,
                &startingOffset,
                &event,
                &ioStatusBlock);

    if (irp==NULL) {

        IdeLogNoMemoryError(DeviceExtension,
                            logicalUnit->TargetId, 
                            NonPagedPool,
                            IoSizeOfIrp(logicalUnit->DeviceObject->StackSize),
                            IDEPORT_TAG_MPIOCTL_IRP
                            );

        UnrefLogicalUnitExtensionWithTag (
            DeviceExtension,
            logicalUnit,
            RequestIrp
            );

        RequestIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        return RequestIrp->IoStatus.Status;
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set major and minor codes.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Fill in SRB fields.
    //

    irpStack->Parameters.Others.Argument1 = &srb;

    //
    // Zero out the srb.
    //

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    srb.PathId = logicalUnit->PathId;
    srb.TargetId = logicalUnit->TargetId;
    srb.Lun = logicalUnit->Lun;

    srb.Function = SRB_FUNCTION_IO_CONTROL;
    srb.Length = sizeof(SCSI_REQUEST_BLOCK);

    srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_NO_QUEUE_FREEZE;

    srb.OriginalRequest = irp;

    //
    // Set timeout to requested value.
    //

    srb.TimeOutValue = srbControl->Timeout;

    //
    // Set the data buffer.
    //

    srb.DataBuffer = srbControl;
    srb.DataTransferLength = length;

    //
    // Flush the data buffer for output. This will insure that the data is
    // written back to memory.  Since the data-in flag is the the port driver
    // will flush the data again for input which will ensure the data is not
    // in the cache.
    //

    KeFlushIoBuffers(irp->MdlAddress, FALSE, TRUE);

    //
    // Call port driver to handle this request.
    //

    IoCallDriver(logicalUnit->DeviceObject, irp);

    //
    // Wait for request to complete.
    //

    KeWaitForSingleObject(&event,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    //
    // Set the information length to the smaller of the output buffer length
    // and the length returned in the srb.
    //

    RequestIrp->IoStatus.Information = srb.DataTransferLength > outputLength ?
        outputLength : srb.DataTransferLength;

    RequestIrp->IoStatus.Status = ioStatusBlock.Status;

    UnrefLogicalUnitExtensionWithTag (
        DeviceExtension,
        logicalUnit,
        RequestIrp
        );

    return RequestIrp->IoStatus.Status;
}

NTSTATUS
IdeGetInquiryData(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This functions copies the inquiry data to the system buffer.  The data
    is translate from the port driver's internal format to the user mode
    format.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    Irp - Supplies a pointer to the Irp which made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/

{
    PUCHAR bufferStart;
    PIO_STACK_LOCATION irpStack;
    PSCSI_ADAPTER_BUS_INFO  adapterInfo;
    PSCSI_BUS_DATA busData;
    PSCSI_INQUIRY_DATA inquiryData;
    ULONG inquiryDataSize;
    ULONG length;
    ULONG numberOfBuses;
    ULONG numberOfLus;
    ULONG j;
    PLOGICAL_UNIT_EXTENSION logUnitExtension;
    IDE_PATH_ID pathId;

    PAGED_CODE();

    DebugPrint((3,"IdeGetInquiryData: Enter routine\n"));

    //
    // Get a pointer to the control block.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    bufferStart = Irp->AssociatedIrp.SystemBuffer;

    numberOfBuses = MAX_IDE_BUS;

    // this number could be changing...
	// but we would always fill in the right info for the numLus.
    numberOfLus = DeviceExtension->NumberOfLogicalUnits;

    //
    // Caculate the size of the logical unit structure and round it to a word
    // alignment.
    //

    inquiryDataSize = ((sizeof(SCSI_INQUIRY_DATA) - 1 + INQUIRYDATABUFFERSIZE +
        sizeof(ULONG) - 1) & ~(sizeof(ULONG) - 1));

    // Based on the number of buses and logical unit, determine the minimum
    // buffer length to hold all of the data.
    //

    length = sizeof(SCSI_ADAPTER_BUS_INFO) +
        (numberOfBuses - 1) * sizeof(SCSI_BUS_DATA);
    length += inquiryDataSize * numberOfLus;

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < length) {

        Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Set the information field.
    //

    Irp->IoStatus.Information = length;

    //
    // Fill in the bus information.
    //

    adapterInfo = (PSCSI_ADAPTER_BUS_INFO) bufferStart;

    adapterInfo->NumberOfBuses = (UCHAR) numberOfBuses;
    inquiryData = (PSCSI_INQUIRY_DATA)(bufferStart + sizeof(SCSI_ADAPTER_BUS_INFO) +
        (numberOfBuses - 1) * sizeof(SCSI_BUS_DATA));

    for (j = 0; j < numberOfBuses; j++) {

        busData = &adapterInfo->BusData[j];
        busData->NumberOfLogicalUnits = 0;
        busData->InitiatorBusId = IDE_PSUEDO_INITIATOR_ID;

        //
        // Copy the data for the logical units.
        //
        busData->InquiryDataOffset = (ULONG)((PUCHAR) inquiryData - bufferStart);

        pathId.l = 0;
        pathId.b.Path = j;
        while (logUnitExtension = NextLogUnitExtensionWithTag (
                                      DeviceExtension,
                                      &pathId,
                                      TRUE,
                                      IdeGetInquiryData
                                      )) {

            INQUIRYDATA InquiryData;
            NTSTATUS status;

            if (pathId.b.Path != j) {

                UnrefLogicalUnitExtensionWithTag (
                    DeviceExtension,
                    logUnitExtension,
                    IdeGetInquiryData
                    );
                break;
            }

            inquiryData->PathId                 = logUnitExtension->PathId;
            inquiryData->TargetId               = logUnitExtension->TargetId;
            inquiryData->Lun                    = logUnitExtension->Lun;
            inquiryData->DeviceClaimed          = (BOOLEAN) (logUnitExtension->PdoState & PDOS_DEVICE_CLIAMED);
            inquiryData->InquiryDataLength      = INQUIRYDATABUFFERSIZE;
            inquiryData->NextInquiryDataOffset  = (ULONG)((PUCHAR) inquiryData +
                                                      inquiryDataSize - bufferStart);

            status = IssueInquirySafe(logUnitExtension->ParentDeviceExtension, logUnitExtension, &InquiryData, FALSE);

            if (NT_SUCCESS(status) || (status == STATUS_DATA_OVERRUN)) {

                RtlCopyMemory(
                    inquiryData->InquiryData,
                    &InquiryData,
                    INQUIRYDATABUFFERSIZE
                    );
            }

            inquiryData = (PSCSI_INQUIRY_DATA) ((PCHAR) inquiryData + inquiryDataSize);

            UnrefLogicalUnitExtensionWithTag (
                DeviceExtension,
                logUnitExtension,
                IdeGetInquiryData
                );

            busData->NumberOfLogicalUnits++;

            if (busData->NumberOfLogicalUnits >= (UCHAR) numberOfLus) {
                break;
            }
        }

        //
        // Fix up the last entry of the list.
        //

        if (busData->NumberOfLogicalUnits == 0) {

            busData->InquiryDataOffset = 0;

        } else {

            ((PSCSI_INQUIRY_DATA) ((PCHAR) inquiryData - inquiryDataSize))->
                NextInquiryDataOffset = 0;
        }
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return(STATUS_SUCCESS);
}

NTSTATUS
IdeSendPassThrough (
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    )

/*++

Routine Description:

    This function sends a user specified SCSI request block.
    It creates an srb which is processed normally by the port driver.
    This call is synchornous.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    RequestIrp - Supplies a pointe to the Irp which made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/

{
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_PASS_THROUGH      srbControl;
    SCSI_REQUEST_BLOCK      srb;
    KEVENT                  event;
    LARGE_INTEGER           startingOffset;
    IO_STATUS_BLOCK         ioStatusBlock;
    KIRQL                   currentIrql;
    ULONG                   outputLength;
    ULONG                   length;
    ULONG                   bufferOffset;
    PVOID                   buffer;
    PVOID                   endByte;
    PVOID                   senseBuffer;
    UCHAR                   majorCode;
    NTSTATUS                status;
    PLOGICAL_UNIT_EXTENSION logicalUnit;

#if defined (_WIN64)
    PSCSI_PASS_THROUGH32    srbControl32;
#endif

    PAGED_CODE();

    startingOffset.QuadPart = (LONGLONG) 1;

    DebugPrint((3,"IdeSendPassThrough: Enter routine\n"));

    //
    // Get a pointer to the control block.
    //

    irpStack = IoGetCurrentIrpStackLocation(RequestIrp);
    srbControl = RequestIrp->AssociatedIrp.SystemBuffer;


    //
    // Validiate the user buffer.
    //

#if defined (_WIN64)

    if (IoIs32bitProcess(RequestIrp)) {

        ULONG32 dataBufferOffset;
        ULONG   senseInfoOffset;

        srbControl32 = (PSCSI_PASS_THROUGH32) (RequestIrp->AssociatedIrp.SystemBuffer);

        //
        // copy the fields that follow the ULONG_PTR
        //
        dataBufferOffset = (ULONG32) (srbControl32->DataBufferOffset);
        senseInfoOffset = srbControl32->SenseInfoOffset;
        srbControl->DataBufferOffset = (ULONG_PTR) dataBufferOffset;
        srbControl->SenseInfoOffset = senseInfoOffset;

        RtlCopyMemory(srbControl->Cdb,
                      srbControl32->Cdb,
                      16*sizeof(UCHAR)
                      );

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SCSI_PASS_THROUGH32)){
            return(STATUS_INVALID_PARAMETER);
        }

        if (srbControl->Length != sizeof(SCSI_PASS_THROUGH32) &&
            srbControl->Length != sizeof(SCSI_PASS_THROUGH_DIRECT32)) {
            return(STATUS_REVISION_MISMATCH);
        }

    } else {

#endif
        if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SCSI_PASS_THROUGH)){
         return(STATUS_INVALID_PARAMETER);
        }

        if (srbControl->Length != sizeof(SCSI_PASS_THROUGH) &&
            srbControl->Length != sizeof(SCSI_PASS_THROUGH_DIRECT)) {
            return(STATUS_REVISION_MISMATCH);
        }

#if defined (_WIN64)
    }
#endif

    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Validate the rest of the buffer parameters.
    //

    if (srbControl->CdbLength > 16) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (srbControl->SenseInfoLength != 0 &&
        (srbControl->Length > srbControl->SenseInfoOffset ||
        (srbControl->SenseInfoOffset + srbControl->SenseInfoLength >
        srbControl->DataBufferOffset && srbControl->DataTransferLength != 0))) {

            return(STATUS_INVALID_PARAMETER);
    }

    majorCode = !srbControl->DataIn ? IRP_MJ_WRITE : IRP_MJ_READ;

    if (srbControl->DataTransferLength == 0) {

        length = 0;
        buffer = NULL;
        bufferOffset = 0;
        majorCode = IRP_MJ_FLUSH_BUFFERS;

    } else if (srbControl->DataBufferOffset > outputLength &&
        srbControl->DataBufferOffset > irpStack->Parameters.DeviceIoControl.InputBufferLength) {

        //
        // The data buffer offset is greater than system buffer.  Assume this
        // is a user mode address.
        //

        if (srbControl->SenseInfoOffset + srbControl->SenseInfoLength  > outputLength
            && srbControl->SenseInfoLength) {

            return(STATUS_INVALID_PARAMETER);

        }

        //
        // Make sure the buffer is properly aligned.
        //

        if (srbControl->DataBufferOffset &
            DeviceExtension->DeviceObject->AlignmentRequirement) {

            return(STATUS_INVALID_PARAMETER);

        }

        length = srbControl->DataTransferLength;
        buffer = (PCHAR) srbControl->DataBufferOffset;
        bufferOffset = 0;

        //
        // make sure the user buffer is valid
        //
        if (RequestIrp->RequestorMode != KernelMode) {
            if (length) {
                endByte =  (PVOID)((PCHAR)buffer + length - 1);
                if ((endByte > (PVOID)MM_HIGHEST_USER_ADDRESS) || (buffer >= endByte)) {
                    return STATUS_INVALID_USER_BUFFER;
                }
            }
        }

    } else {

        if (srbControl->DataIn != SCSI_IOCTL_DATA_IN) {

            if ((srbControl->SenseInfoOffset + srbControl->SenseInfoLength > outputLength
                && srbControl->SenseInfoLength != 0) ||
                srbControl->DataBufferOffset + srbControl->DataTransferLength >
                irpStack->Parameters.DeviceIoControl.InputBufferLength ||
                srbControl->Length > srbControl->DataBufferOffset) {

                return STATUS_INVALID_PARAMETER;
            }
        }

        if (srbControl->DataIn) {

            if (srbControl->DataBufferOffset + srbControl->DataTransferLength > outputLength ||
                srbControl->Length > srbControl->DataBufferOffset) {

                return STATUS_INVALID_PARAMETER;
            }
        }

        length = (ULONG)srbControl->DataBufferOffset +
                        srbControl->DataTransferLength;
        buffer = (PUCHAR) srbControl;
        bufferOffset = (ULONG)srbControl->DataBufferOffset;

    }

    //
    // Validate that the request isn't too large for the miniport.
    //

    if (srbControl->DataTransferLength &&
        ((ADDRESS_AND_SIZE_TO_SPAN_PAGES(
              (PUCHAR)buffer+bufferOffset,
              srbControl->DataTransferLength
              ) > DeviceExtension->Capabilities.MaximumPhysicalPages) ||
        (DeviceExtension->Capabilities.MaximumTransferLength <
         srbControl->DataTransferLength))) {

        return(STATUS_INVALID_PARAMETER);

    }


    if (srbControl->TimeOutValue == 0 ||
        srbControl->TimeOutValue > 30 * 60 * 60) {
            return STATUS_INVALID_PARAMETER;
    }

    //
    // Check for illegal command codes.
    //

    if (srbControl->Cdb[0] == SCSIOP_COPY ||
        srbControl->Cdb[0] == SCSIOP_COMPARE ||
        srbControl->Cdb[0] == SCSIOP_COPY_COMPARE) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // If this request came through a normal device control rather than from
    // class driver then the device must exist and be unclaimed. Class drivers
    // will set the minor function code for the device control.  It is always
    // zero for a user request.
    //
    logicalUnit = RefLogicalUnitExtensionWithTag(DeviceExtension,
                                          srbControl->PathId,
                                          srbControl->TargetId,
                                          srbControl->Lun,
                                          FALSE,
                                          RequestIrp
                                          );

    if (logicalUnit) {

        if (irpStack->MinorFunction == 0) {

            if (logicalUnit->PdoState & PDOS_DEVICE_CLIAMED) {

                UnrefLogicalUnitExtensionWithTag(
                    DeviceExtension,
                    logicalUnit,
                    RequestIrp
                    );
                logicalUnit = NULL;
            }
        }
    }

    if (logicalUnit == NULL) {

        return STATUS_INVALID_PARAMETER;
    }


    //
    // Allocate an aligned request sense buffer.
    //

    if (srbControl->SenseInfoLength != 0) {

        senseBuffer = ExAllocatePool( NonPagedPoolCacheAligned,
                                      srbControl->SenseInfoLength);

        if (senseBuffer == NULL) {

            IdeLogNoMemoryError(DeviceExtension,
                                logicalUnit->TargetId,
                                NonPagedPoolCacheAligned,
                                srbControl->SenseInfoLength,
                                IDEPORT_TAG_PASSTHRU_SENSE
                                );

            UnrefLogicalUnitExtensionWithTag(
                DeviceExtension,
                logicalUnit,
                RequestIrp
                );
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

    } else {

        senseBuffer = NULL;
    }

    //
    // Initialize the notification event.
    //

    KeInitializeEvent(&event,
                        NotificationEvent,
                        FALSE);

    //
    // Build IRP for this request.
    // Note we do this synchronously for two reasons.  If it was done
    // asynchonously then the completion code would have to make a special
    // check to deallocate the buffer.  Second if a completion routine were
    // used then an addation stack locate would be needed.
    //

    try {

        irp = IoBuildSynchronousFsdRequest(
                    majorCode,
                    logicalUnit->DeviceObject,
                    buffer,
                    length,
                    &startingOffset,
                    &event,
                    &ioStatusBlock);

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred while attempting to probe the
        // caller's parameters.  Dereference the file object and return
        // an appropriate error status code.
        //

        if (senseBuffer != NULL) {
            ExFreePool(senseBuffer);
        }
        UnrefLogicalUnitExtensionWithTag(
            DeviceExtension,
            logicalUnit,
            RequestIrp
            );

        return GetExceptionCode();

    }

    if (irp == NULL) {

        if (senseBuffer != NULL) {
            ExFreePool(senseBuffer);
        }

        IdeLogNoMemoryError(DeviceExtension,
                            logicalUnit->TargetId, 
                            NonPagedPool,
                            IoSizeOfIrp(logicalUnit->DeviceObject->StackSize),
                            IDEPORT_TAG_PASSTHRU_IRP
                            );

        UnrefLogicalUnitExtensionWithTag(
            DeviceExtension,
            logicalUnit,
            RequestIrp
            );
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set major code.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Fill in SRB fields.
    //

    irpStack->Parameters.Others.Argument1 = &srb;

    //
    // Zero out the srb.
    //

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Fill in the srb.
    //

    srb.Length = SCSI_REQUEST_BLOCK_SIZE;
    srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb.SrbStatus = SRB_STATUS_PENDING;
    srb.PathId = srbControl->PathId;
    srb.TargetId = srbControl->TargetId;
    srb.Lun = srbControl->Lun;
    srb.CdbLength = srbControl->CdbLength;
    srb.SenseInfoBufferLength = srbControl->SenseInfoLength;

    switch (srbControl->DataIn) {
    case SCSI_IOCTL_DATA_OUT:
       if (srbControl->DataTransferLength) {
           srb.SrbFlags = SRB_FLAGS_DATA_OUT;
       }
       break;

    case SCSI_IOCTL_DATA_IN:
       if (srbControl->DataTransferLength) {
           srb.SrbFlags = SRB_FLAGS_DATA_IN;
       }
       break;

    default:
        srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT;
        break;
    }

    if (srbControl->DataTransferLength == 0) {
        srb.SrbFlags = 0;
    } else {

        //
        // Flush the data buffer for output. This will insure that the data is
        // written back to memory.
        //

        KeFlushIoBuffers(irp->MdlAddress, FALSE, TRUE);

    }

    srb.SrbFlags |= (SRB_FLAGS_DISABLE_SYNCH_TRANSFER & DeviceExtension->SrbFlags);
    srb.SrbFlags |= SRB_FLAGS_NO_QUEUE_FREEZE;
    srb.DataTransferLength = srbControl->DataTransferLength;
    srb.TimeOutValue = srbControl->TimeOutValue;
    srb.DataBuffer = (PCHAR) buffer + bufferOffset;
    srb.SenseInfoBuffer = senseBuffer;
    srb.OriginalRequest = irp;
    RtlCopyMemory(srb.Cdb, srbControl->Cdb, srbControl->CdbLength);

    //
    // Call port driver to handle this request.
    //

    status = IoCallDriver(logicalUnit->DeviceObject, irp);

    //
    // Wait for request to complete.
    //

    if(status == STATUS_PENDING) {
          KeWaitForSingleObject(&event,
                                Executive,
                                KernelMode,
                                FALSE,
                                NULL);
    } else {
        ioStatusBlock.Status = status;
    }

    //
    // Copy the returned values from the srb to the control structure.
    //

    srbControl->ScsiStatus = srb.ScsiStatus;
    if (srb.SrbStatus  & SRB_STATUS_AUTOSENSE_VALID) {

        //
        // Set the status to success so that the data is returned.
        //

        ioStatusBlock.Status = STATUS_SUCCESS;
        srbControl->SenseInfoLength = srb.SenseInfoBufferLength;

        //
        // Copy the sense data to the system buffer.
        //

        RtlCopyMemory((PUCHAR) srbControl + srbControl->SenseInfoOffset,
                      senseBuffer,
                      srb.SenseInfoBufferLength);

    } else {
        srbControl->SenseInfoLength = 0;
    }

    //
    // Free the sense buffer.
    //

    if (senseBuffer != NULL) {
        ExFreePool(senseBuffer);
    }

    //
    // If the srb status is buffer underrun then set the status to success.
    // This insures that the data will be returned to the caller.
    //

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        ioStatusBlock.Status = STATUS_SUCCESS;

    }

    srbControl->DataTransferLength = srb.DataTransferLength;

    //
    // Set the information length
    //

    if (!srbControl->DataIn || bufferOffset == 0) {

        RequestIrp->IoStatus.Information = srbControl->SenseInfoOffset +
            srbControl->SenseInfoLength;

    } else {

        RequestIrp->IoStatus.Information = srbControl->DataBufferOffset +
            srbControl->DataTransferLength;

    }

    RequestIrp->IoStatus.Status = ioStatusBlock.Status;


	//
	// Queue should not be frozen
	//
    ASSERT(!(srb.SrbStatus & SRB_STATUS_QUEUE_FROZEN));
/**
    //
    // If the queue is frozen then unfreeze it.
    //
    if (srb.SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

        //
        // Acquire the spinlock to protect the flags structure and the saved
        // interrupt context.
        //

        KeAcquireSpinLock(&DeviceExtension->SpinLock, &currentIrql);

        //
        // Make sure the queue is frozen and that an ABORT is not
        // in progress.
        //

        if (!(logicalUnit->LuFlags & PD_QUEUE_FROZEN)) {

            KeReleaseSpinLock(&DeviceExtension->SpinLock, currentIrql);

        } else {

            CLRMASK (logicalUnit->LuFlags, PD_QUEUE_FROZEN);
            GetNextLuRequest(DeviceExtension, logicalUnit);

            KeLowerIrql(currentIrql);


            //
            // Get next request will release the spinlock.
            //

        }
    }
**/

    UnrefLogicalUnitExtensionWithTag(
        DeviceExtension,
        logicalUnit,
        RequestIrp
        );

    return ioStatusBlock.Status;
}

VOID
SyncAtaPassThroughCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context,
    IN NTSTATUS       Status
    )
{
    PSYNC_ATA_PASSTHROUGH_CONTEXT context = Context;

    context->Status = Status;

    KeSetEvent (&context->Event, 0, FALSE);

}

//
// <= DISPATCH_LEVEL
//
NTSTATUS
IssueAsyncAtaPassThroughSafe (
    IN PFDO_EXTENSION        DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION  LogUnitExtension,
    IN OUT PATA_PASS_THROUGH    AtaPassThroughData,
    IN BOOLEAN                  DataIn,
    IN ASYNC_PASS_THROUGH_COMPLETION Completion,
    IN PVOID                         CallerContext,
    IN BOOLEAN                  PowerRelated,
    IN ULONG                    TimeOut,
    IN BOOLEAN                    MustSucceed
)
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL currentIrql;
    NTSTATUS status;
    PSCSI_REQUEST_BLOCK srb;
    PSENSE_DATA senseInfoBuffer;
    ULONG             totalBufferSize;

    PATA_PASSTHROUGH_CONTEXT context;
    PENUMERATION_STRUCT enumStruct;

    status = STATUS_UNSUCCESSFUL;

    senseInfoBuffer = NULL;
    srb = NULL;
    irp = NULL;

    if (MustSucceed) {

        enumStruct = DeviceExtension->PreAllocEnumStruct;

        if (enumStruct == NULL) {
            ASSERT (DeviceExtension->PreAllocEnumStruct);

            //
            // Fall back to the usual course of action
            //
            MustSucceed=FALSE;
        } else {

            context = enumStruct->Context;

            ASSERT (context);

            senseInfoBuffer = enumStruct->SenseInfoBuffer;

            ASSERT (senseInfoBuffer);

            srb = enumStruct->Srb;

            ASSERT (srb);

            totalBufferSize = FIELD_OFFSET(ATA_PASS_THROUGH, DataBuffer) + AtaPassThroughData->DataBufferSize;

            irp = enumStruct->Irp1;

            ASSERT (irp);

            IoInitializeIrp(irp, 
                            IoSizeOfIrp(LogUnitExtension->DeviceObject->StackSize),
                            LogUnitExtension->DeviceObject->StackSize);

            irp->MdlAddress = enumStruct->MdlAddress;

            ASSERT (enumStruct->DataBufferSize >= totalBufferSize);
            RtlCopyMemory(enumStruct->DataBuffer, AtaPassThroughData, totalBufferSize);
        }
    } 

    if (!MustSucceed) {

        context = ExAllocatePool(NonPagedPool, sizeof (ATA_PASSTHROUGH_CONTEXT));

        if (context == NULL) {
            DebugPrint((1,"IssueAsyncAtaPassThrough: Can't allocate context buffer\n"));

            IdeLogNoMemoryError(DeviceExtension,
                                LogUnitExtension->TargetId,
                                NonPagedPool,
                                sizeof(ATA_PASSTHROUGH_CONTEXT),
                                (IDEPORT_TAG_ATAPASS_CONTEXT+AtaPassThroughData->IdeReg.bCommandReg)
                                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;
        }

        senseInfoBuffer = ExAllocatePool( NonPagedPoolCacheAligned, SENSE_BUFFER_SIZE);

        if (senseInfoBuffer == NULL) {
            DebugPrint((1,"IssueAsyncAtaPassThrough: Can't allocate request sense buffer\n"));

            IdeLogNoMemoryError(DeviceExtension,
                                LogUnitExtension->TargetId,
                                NonPagedPoolCacheAligned,
                                SENSE_BUFFER_SIZE,
                                (IDEPORT_TAG_ATAPASS_SENSE+AtaPassThroughData->IdeReg.bCommandReg)
                                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;
        }

        srb = ExAllocatePool (NonPagedPool, sizeof (SCSI_REQUEST_BLOCK));
        if (srb == NULL) {
            DebugPrint((1,"IssueAsyncAtaPassThrough: Can't SRB\n"));

            IdeLogNoMemoryError(DeviceExtension,
                                LogUnitExtension->TargetId,
                                NonPagedPool,
                                sizeof(SCSI_REQUEST_BLOCK),
                                (IDEPORT_TAG_ATAPASS_SRB+AtaPassThroughData->IdeReg.bCommandReg)
                                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;
        }

        totalBufferSize = FIELD_OFFSET(ATA_PASS_THROUGH, DataBuffer) + AtaPassThroughData->DataBufferSize;

        //
        // Build IRP for this request.
        //
        irp = IoAllocateIrp (
                  (CCHAR) (LogUnitExtension->DeviceObject->StackSize),
                  FALSE
                  );
        if (irp == NULL) {

            IdeLogNoMemoryError(DeviceExtension,
                                LogUnitExtension->TargetId, 
                                NonPagedPool,
                                IoSizeOfIrp(LogUnitExtension->DeviceObject->StackSize),
                                (IDEPORT_TAG_ATAPASS_IRP+AtaPassThroughData->IdeReg.bCommandReg)
                                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;
        }

        irp->MdlAddress = IoAllocateMdl( AtaPassThroughData,
                                         totalBufferSize,
                                         FALSE,
                                         FALSE,
                                         (PIRP) NULL );
        if (irp->MdlAddress == NULL) {

            IdeLogNoMemoryError(DeviceExtension,
                                LogUnitExtension->TargetId,
                                NonPagedPool,
                                totalBufferSize,
                                (IDEPORT_TAG_ATAPASS_MDL+AtaPassThroughData->IdeReg.bCommandReg)
                                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;
        }

        MmBuildMdlForNonPagedPool(irp->MdlAddress);

    }


    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Fill in SRB fields.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    irpStack->Parameters.Scsi.Srb = srb;

    srb->PathId      = LogUnitExtension->PathId;
    srb->TargetId    = LogUnitExtension->TargetId;
    srb->Lun         = LogUnitExtension->Lun;

    if (PowerRelated) {

        srb->Function = SRB_FUNCTION_ATA_POWER_PASS_THROUGH;
        srb->QueueSortKey = MAXULONG;
    } else {

        srb->Function = SRB_FUNCTION_ATA_PASS_THROUGH;
        srb->QueueSortKey = 0;
    }
    srb->Length = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set flags to disable synchronous negociation.
    //
    srb->SrbFlags  = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
    srb->SrbFlags |= DataIn ? 0 : SRB_FLAGS_DATA_OUT;

    if (AtaPassThroughData->IdeReg.bReserved & ATA_PTFLAGS_URGENT) {

        srb->SrbFlags |= SRB_FLAGS_BYPASS_FROZEN_QUEUE;
    }

    srb->SrbStatus = srb->ScsiStatus = 0;

    srb->NextSrb = 0;

    srb->OriginalRequest = irp;

    //
    // Set timeout to 15 seconds.
    //
    srb->TimeOutValue = TimeOut;

    srb->CdbLength = 6;

    //
    // Enable auto request sense.
    //

    srb->SenseInfoBuffer = senseInfoBuffer;
    srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    srb->DataBuffer = MmGetMdlVirtualAddress(irp->MdlAddress);
    srb->DataTransferLength = totalBufferSize;

    IoSetCompletionRoutine(
        irp,
        AtaPassThroughCompletionRoutine,
        context,
        TRUE,
        TRUE,
        TRUE
        );


    context->DeviceObject     = LogUnitExtension->DeviceObject;
    context->CallerCompletion = Completion;
    context->CallerContext    = CallerContext;
    context->SenseInfoBuffer  = senseInfoBuffer;
    context->Srb              = srb;
    context->MustSucceed      = MustSucceed? 1 : 0;
    context->DataBuffer       = AtaPassThroughData;

    //
    // send the pass through irp
    //
    status = IoCallDriver(LogUnitExtension->DeviceObject, irp);

    //
    // always return STATUS_PENDING when we actually send out the irp
    //
    return STATUS_PENDING;

GetOut:

    ASSERT (!MustSucceed);

    if (context) {

        ExFreePool (context);
    }

    if (senseInfoBuffer) {

        ExFreePool (senseInfoBuffer);
    }

    if (srb) {

        ExFreePool (srb);
    }

    if (irp && irp->MdlAddress) {

        IoFreeMdl (irp->MdlAddress);
    }

    if (irp) {

        IoFreeIrp( irp );
    }

    return status;

} // IssueAtaPassThrough

NTSTATUS
IssueSyncAtaPassThroughSafe (
    IN PFDO_EXTENSION        DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION  LogUnitExtension,
    IN OUT PATA_PASS_THROUGH    AtaPassThroughData,
    IN BOOLEAN                  DataIn,
    IN BOOLEAN                  PowerRelated,
    IN ULONG                    TimeOut,
    IN BOOLEAN                    MustSucceed
)
{
    NTSTATUS                     status;
    SYNC_ATA_PASSTHROUGH_CONTEXT context;
    ULONG retryCount=10;
    ULONG locked;


    status=STATUS_INSUFFICIENT_RESOURCES;

    if (MustSucceed) {

        //Lock
        ASSERT(InterlockedCompareExchange(&(DeviceExtension->EnumStructLock), 1, 0) == 0);

    }


    while ((status == STATUS_UNSUCCESSFUL || status == STATUS_INSUFFICIENT_RESOURCES) && retryCount--) {

        //
        // Initialize the notification event.
        //

        KeInitializeEvent(&context.Event,
                          NotificationEvent,
                          FALSE);

        status = IssueAsyncAtaPassThroughSafe (
                        DeviceExtension,
                        LogUnitExtension,
                        AtaPassThroughData,
                        DataIn,
                        SyncAtaPassThroughCompletionRoutine,
                        &context,
                        PowerRelated,
                        TimeOut,
                        MustSucceed
                        );


        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(&context.Event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            status=context.Status;
        }

        if (status == STATUS_UNSUCCESSFUL) {
            DebugPrint((1, "Retrying flushed request\n"));
        }
    }

    if (MustSucceed) {
        //Unlock
        ASSERT(InterlockedCompareExchange(&(DeviceExtension->EnumStructLock), 0, 1) == 1);
    }

    if (NT_SUCCESS(status)) {

        return context.Status;

    } else {

        return status;
    }
}

NTSTATUS
AtaPassThroughCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
{
    PATA_PASSTHROUGH_CONTEXT context = Context;
    PATA_PASS_THROUGH ataPassThroughData;



    DebugPrint((1, "AtaPassThroughCompletionRoutine: Irp = 0x%x status=%x\n", 
                    Irp, Irp->IoStatus.Status));

    if (context->Srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

        PLOGICAL_UNIT_EXTENSION logicalUnit;
        KIRQL currentIrql;

        DebugPrint((1, "AtaPassThroughCompletionRoutine: Unfreeze Queue TID %d\n",
            context->Srb->TargetId));

        logicalUnit = context->DeviceObject->DeviceExtension;

        ASSERT (logicalUnit);
        CLRMASK (logicalUnit->LuFlags, PD_QUEUE_FROZEN);

        KeAcquireSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, &currentIrql);
        GetNextLuRequest(logicalUnit->ParentDeviceExtension, logicalUnit);
        KeLowerIrql(currentIrql);
    }

    ataPassThroughData = (PATA_PASS_THROUGH) context->Srb->DataBuffer;
    if (ataPassThroughData->IdeReg.bReserved & ATA_PTFLAGS_OK_TO_FAIL) {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    if (context->MustSucceed) {
        RtlCopyMemory(context->DataBuffer, 
                      context->Srb->DataBuffer, context->Srb->DataTransferLength);
        DebugPrint((1, "AtaCompletionSafe: Device =%x, Status= %x, SrbStatus=%x\n",
                        context->Srb->TargetId,  Irp->IoStatus.Status, context->Srb->SrbStatus));
    }

    if (context->CallerCompletion) {

        context->CallerCompletion (context->DeviceObject, context->CallerContext, Irp->IoStatus.Status);
    }

    if (context->MustSucceed) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    ExFreePool (context->SenseInfoBuffer);
    ExFreePool (context->Srb);
    ExFreePool (context);

    if (Irp->MdlAddress) {

        IoFreeMdl (Irp->MdlAddress);
    }

    IoFreeIrp (Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
IdeClaimLogicalUnit(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function finds the specified device in the logical unit information
    and either updates the device object point or claims the device.  If the
    device is already claimed, then the request fails.  If the request succeeds,
    then the current device object is returned in the data buffer pointer
    of the SRB.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    Irp - Supplies a pointer to the Irp which made the original request.

Return Value:

    Returns the status of the operation.  Either success, no device or busy.

--*/

{
    KIRQL currentIrql;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    PDEVICE_OBJECT saveDevice;
    PPDO_EXTENSION pdoExtension;
	PVOID	sectionHandle;
    PAGED_CODE();

    //
    // Get SRB address from current IRP stack.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = (PSCSI_REQUEST_BLOCK) irpStack->Parameters.Others.Argument1;

    pdoExtension = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);
    ASSERT (pdoExtension);

#ifdef ALLOC_PRAGMA
    sectionHandle = MmLockPagableCodeSection(IdeClaimLogicalUnit);
#endif

    //
    // Lock the data.
    //
    KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

    if (srb->Function == SRB_FUNCTION_RELEASE_DEVICE) {

        CLRMASK (pdoExtension->PdoState, PDOS_DEVICE_CLIAMED | PDOS_LEGACY_ATTACHER);

        KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);
        srb->SrbStatus = SRB_STATUS_SUCCESS;

#ifdef ALLOC_PRAGMA
    MmUnlockPagableImageSection(sectionHandle);
#endif
        return(STATUS_SUCCESS);
    }

    //
    // Check for a claimed device.
    //

    if (pdoExtension->PdoState & PDOS_DEVICE_CLIAMED) {

        KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);
        srb->SrbStatus = SRB_STATUS_BUSY;

#ifdef ALLOC_PRAGMA
    MmUnlockPagableImageSection(sectionHandle);
#endif
        return(STATUS_DEVICE_BUSY);
    }

    //
    // Save the current device object.
    //

    saveDevice = pdoExtension->AttacherDeviceObject;

    //
    // Update the lun information based on the operation type.
    //

    if (srb->Function == SRB_FUNCTION_CLAIM_DEVICE) {

        pdoExtension->PdoState |= PDOS_DEVICE_CLIAMED;
    }

    if (srb->Function == SRB_FUNCTION_ATTACH_DEVICE) {
        pdoExtension->AttacherDeviceObject = srb->DataBuffer;
    }

    srb->DataBuffer = saveDevice;

    if (irpStack->DeviceObject == pdoExtension->ParentDeviceExtension->DeviceObject) {

        //
        // The original irp is sent to the parent.  The attacher must
        // be legacy class driver.  We can never do pnp remove safely.
        //
        pdoExtension->PdoState |= PDOS_LEGACY_ATTACHER;
    }

    KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);
    srb->SrbStatus = SRB_STATUS_SUCCESS;

#ifdef ALLOC_PRAGMA
    MmUnlockPagableImageSection(sectionHandle);
#endif

    return(STATUS_SUCCESS);
}

NTSTATUS
IdeRemoveDevice(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function finds the specified device in the logical unit information
    and deletes it. This is done in preparation for a failing device to be
    physically removed from a SCSI bus. An assumption is that the system
    utility controlling the device removal has locked the volumes so there
    is no outstanding IO to this device.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    Irp - Supplies a pointer to the Irp which made the original request.

Return Value:

    Returns the status of the operation.  Either success or no device.

--*/

{
    KIRQL currentIrql;
    PPDO_EXTENSION pdoExtension;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    NTSTATUS status;

    PAGED_CODE();

    // ISSUE:2000/02/11 : need to test this

    //
    // Get SRB address from current IRP stack.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);


    srb = (PSCSI_REQUEST_BLOCK) irpStack->Parameters.Others.Argument1;

    srb->SrbStatus = SRB_STATUS_NO_DEVICE;
    status = STATUS_DEVICE_DOES_NOT_EXIST;

    pdoExtension = RefLogicalUnitExtensionWithTag(
                       DeviceExtension,
                       srb->PathId,
                       srb->TargetId,
                       srb->Lun,
                       FALSE,
                       IdeRemoveDevice
                       );
    if (pdoExtension) {

        DebugPrint((1, "IdeRemove device removing Pdo %x\n", pdoExtension));
        status = FreePdoWithTag (pdoExtension, TRUE, TRUE, IdeRemoveDevice);

        if (NT_SUCCESS(status)) {

            srb->SrbStatus = SRB_STATUS_SUCCESS;
        }
    }
    return status;
}

VOID
IdeMiniPortTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine calls the miniport when its requested timer fires.
    It interlocks either with the port spinlock and the interrupt object.

Arguments:

    Dpc - Unsed.

    DeviceObject - Supplies a pointer to the device object for this adapter.

    SystemArgument1 - Unused.

    SystemArgument2 - Unused.

Return Value:

    None.

--*/

{
    PFDO_EXTENSION deviceExtension = ((PDEVICE_OBJECT) DeviceObject)->DeviceExtension;

    //
    // Acquire the port spinlock.
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

    //
    // Make sure the timer routine is still desired.
    //

    if (deviceExtension->HwTimerRequest != NULL) {

        KeSynchronizeExecution (
            deviceExtension->InterruptObject,
            (PKSYNCHRONIZE_ROUTINE) deviceExtension->HwTimerRequest,
            deviceExtension->HwDeviceExtension
            );

    }

    //
    // Release the spinlock.
    //

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    //
    // Check for miniport work requests. Note this is an unsynchonized
    // test on a bit that can be set by the interrupt routine; however,
    // the worst that can happen is that the completion DPC checks for work
    // twice.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

        //
        // Call the completion DPC directly.
        //

        IdePortCompletionDpc( NULL,
                               deviceExtension->DeviceObject,
                               NULL,
                               NULL);

    }
}

NTSTATUS
IdePortFlushLogicalUnit (
    PFDO_EXTENSION          FdoExtension,
    PLOGICAL_UNIT_EXTENSION LogUnitExtension,
    BOOLEAN                 Forced
)
{
    NTSTATUS             status;
    PIO_STACK_LOCATION   irpStack;
    PSCSI_REQUEST_BLOCK  srb;
    PKDEVICE_QUEUE_ENTRY packet;
    KIRQL                currentIrql;
    PIRP                 nextIrp;
    PIRP                 listIrp;
    PIRP                 powerRelatedIrp;

    //
    // Acquire the spinlock to protect the flags structure and the saved
    // interrupt context.
    //

    KeAcquireSpinLock(&FdoExtension->SpinLock, &currentIrql);

    //
    // Make sure the queue is frozen.
    //

    if ((!(LogUnitExtension->LuFlags & PD_QUEUE_FROZEN)) && (!Forced)) {

        DebugPrint((1,"IdePortFlushLogicalUnit:  Request to flush an unfrozen queue!\n"));

        KeReleaseSpinLock(&FdoExtension->SpinLock, currentIrql);
        status = STATUS_INVALID_DEVICE_REQUEST;

    } else {

        listIrp = NULL;
        powerRelatedIrp = NULL;

        if (LogUnitExtension->DeviceObject->DeviceQueue.Busy) {

            while ((packet =
                KeRemoveDeviceQueue(&LogUnitExtension->DeviceObject->DeviceQueue))
                != NULL) {

                nextIrp = CONTAINING_RECORD(packet, IRP, Tail.Overlay.DeviceQueueEntry);

                //
                // Get the srb.
                //

                irpStack = IoGetCurrentIrpStackLocation(nextIrp);
                srb = irpStack->Parameters.Scsi.Srb;

                if (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) {

                    ASSERT (!powerRelatedIrp);
                    powerRelatedIrp = nextIrp;
                    continue;
                }

                //
                // Set the status code.
                //

                srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
                nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

                //
                // Link the requests. They will be completed after the
                // spinlock is released.
                //

                nextIrp->Tail.Overlay.ListEntry.Flink = (PLIST_ENTRY)
                    listIrp;
                listIrp = nextIrp;
            }
        }

        //
        // clear the pending reuqest blocked by busy device
        //
        if ((LogUnitExtension->LuFlags & PD_LOGICAL_UNIT_IS_BUSY) &&
            (LogUnitExtension->BusyRequest)) {

            nextIrp = LogUnitExtension->BusyRequest;
            irpStack = IoGetCurrentIrpStackLocation(nextIrp);
            srb = irpStack->Parameters.Scsi.Srb;

            LogUnitExtension->BusyRequest = NULL;
            CLRMASK (LogUnitExtension->LuFlags, PD_LOGICAL_UNIT_IS_BUSY);

            if (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) {

                ASSERT (!powerRelatedIrp);
                powerRelatedIrp = nextIrp;

            } else {

                srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
                nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

                nextIrp->Tail.Overlay.ListEntry.Flink = (PLIST_ENTRY)
                    listIrp;
                listIrp = nextIrp;
            }
        }

        if (LogUnitExtension->PendingRequest) {

            nextIrp = LogUnitExtension->PendingRequest;
            LogUnitExtension->PendingRequest = NULL;

            irpStack = IoGetCurrentIrpStackLocation(nextIrp);
            srb = irpStack->Parameters.Scsi.Srb;

            if (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) {

                ASSERT (!powerRelatedIrp);
                powerRelatedIrp = nextIrp;

            } else {

                srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
                nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

                nextIrp->Tail.Overlay.ListEntry.Flink = (PLIST_ENTRY)
                    listIrp;
                listIrp = nextIrp;
            }
        }

        //
        // Mark the queue as unfrozen.  Since all the requests have
        // been removed and the device queue is no longer busy, it
        // is effectively unfrozen.
        //

        CLRMASK (LogUnitExtension->LuFlags, PD_QUEUE_FROZEN);

        //
        // Release the spinlock.
        //

        KeReleaseSpinLock(&FdoExtension->SpinLock, currentIrql);

        if (powerRelatedIrp) {

            PDEVICE_OBJECT deviceObject = LogUnitExtension->DeviceObject;

            DebugPrint ((DBG_POWER, "Resending power related pass through reuqest 0x%x\n", powerRelatedIrp));

            UnrefPdoWithTag(
                LogUnitExtension,
                powerRelatedIrp
                );

            IdePortDispatch(
                deviceObject,
                powerRelatedIrp
                );
        }

        //
        // Complete the flushed requests.
        //

        while (listIrp != NULL) {

            nextIrp = listIrp;
            listIrp = (PIRP) nextIrp->Tail.Overlay.ListEntry.Flink;

            UnrefLogicalUnitExtensionWithTag(
                FdoExtension,
                LogUnitExtension,
                nextIrp
                );

            IoCompleteRequest(nextIrp, 0);
        }

        status = STATUS_SUCCESS;
    }

    return status;
}


PVOID
IdeMapLockedPagesWithReservedMapping (
	IN PFDO_EXTENSION 	DeviceExtension,
	IN PSRB_DATA		SrbData,
	IN PMDL	    	  	Mdl
	)
/*++

Routine Description:

    This routine attempts to map the physical pages represented by the supplied
    MDL using the adapter's reserved page range.

Arguments:

    DeviceExtension - Points to the FDO extension

	SrbData - Points to SrbData structure for this request

    Mdl     - Points to an MDL that describes the physical range we
              are tring to map.

Return Value:

    Kernel VA of the mapped pages if mapped successfully.

    NULL if the reserved page range is too small or if the pages are 
    not successfully mapped.

    -1 if the reserved pages are already in use.

Notes:

    This routine is called with the spinlock held.

--*/
{
	ULONG_PTR	numberOfPages;
	PVOID		startingVa;
	PVOID		systemAddress;

	//
	// Check if the reserve pages are already in use
	//
	if (DeviceExtension->Flags & PD_RESERVED_PAGES_IN_USE) {

		DebugPrint((1,
					"Reserve pages in use...\n"
					));

		return (PVOID)-1;
	}

	startingVa = (PVOID)((PCHAR)Mdl->StartVa + Mdl->ByteOffset);
	numberOfPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(startingVa, Mdl->ByteCount);

	if (numberOfPages > IDE_NUM_RESERVED_PAGES) {

		systemAddress = NULL;

	} else {

		//
		// The reserved range is large enough to map all the pages.  Go ahead
		// and try to map them.  Since we are specifying MmCached as cache 
		// type and we've ensured that we have enough reserved pages to
		// cover the request, this should never fail.
		//
		systemAddress = MmMapLockedPagesWithReservedMapping (DeviceExtension->ReservedPages, 
															 'PedI', 
															 Mdl, 
															 MmCached );

		if (systemAddress == NULL) {

			DebugPrint((1,
						"mapping failed....\n"
						));

			ASSERT(systemAddress);

		} else {

			DebugPrint((1,
						"mapping....\n"
						));

			//
			// We need this flag to verify if the reserved pages are already
			// in use. The per request srbData flag is not available to make 
			// this check
			//
			ASSERT(!(DeviceExtension->Flags & PD_RESERVED_PAGES_IN_USE));
			SETMASK(DeviceExtension->Flags, PD_RESERVED_PAGES_IN_USE);


			//
			// we need this flag to unmap the pages. The flag in the
			// device extension cannot be relied upon as it might indicate
			// the flags for the next request
			//
			ASSERT(!(SrbData->Flags & SRB_DATA_RESERVED_PAGES));
			SETMASK(SrbData->Flags, SRB_DATA_RESERVED_PAGES);

		}
	}

	return systemAddress;

}

VOID
IdeUnmapReservedMapping (
	IN PFDO_EXTENSION 	DeviceExtension,
	IN PSRB_DATA		SrbData,
	IN PMDL	  			Mdl
	)
/*++

Routine Description :

	Unmap the physical pages represented by the Mdl
	
Arguments:

	DeviceExtension: The Fdo extension
	
	Mdl:	Mdl for the request
	
Return Value:

	No return value
	
Notes:

	This routine is called with the spinlock held			

--*/
{
	DebugPrint((1,
				"Unmapping....\n"
				));

	ASSERT(DeviceExtension->Flags & PD_RESERVED_PAGES_IN_USE);
	CLRMASK(DeviceExtension->Flags, PD_RESERVED_PAGES_IN_USE);

	ASSERT(SrbData->Flags & SRB_DATA_RESERVED_PAGES);
	CLRMASK(SrbData->Flags, SRB_DATA_RESERVED_PAGES);

	MmUnmapReservedMapping (
		DeviceExtension->ReservedPages,
		'PedI',
		Mdl
		);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\pdopower.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       pdopower.h
//
//--------------------------------------------------------------------------

#if !defined (___pdopower_h___)
#define ___pdopower_h___

typedef struct _SET_POWER_STATE_CONTEXT {

    KEVENT  Event;
    NTSTATUS  Status;

} SET_POWER_STATE_CONTEXT, *PSET_POWER_STATE_CONTEXT;

typedef struct _IDE_POWER_CONTEXT *PIDE_POWER_CONTEXT;

typedef struct _POWER_COMPLETION_CONTEXT {

    KEVENT       Event;
    NTSTATUS     Status;
    POWER_STATE  State;

} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;
                          
NTSTATUS
DeviceQueryPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortSetPdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortSetPdoSystemPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortSetPdoDevicePowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

//
// private functions
//
                      
VOID
IdePortPdoPowerStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
                      
NTSTATUS
PdoRequestParentPowerUpCompletionRoutine (
    PVOID    Context,
    NTSTATUS ParentPowerUpStatus
);

VOID
IdePortPdoRequestPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
IdePortPdoCompletePowerIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
                      
                       
VOID
IdePowerPassThroughCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIDE_POWER_CONTEXT Context,
    IN NTSTATUS           Status
    );
                          
VOID
DevicePowerUpInitCompletionRoutine (
    PVOID Context,
    NTSTATUS Status
    );
                          
//NTSTATUS
//IdePortSetPowerDispatch(
//    IN PDEVICE_OBJECT DeviceObject,
//    IN PIRP Irp
//    );
                          
                                        
#endif // ___pdopower_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\port.c ===
/*++

Copyright (C) 1990 - 99  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a dll for the kernel.

Revision History:

--*/

#include "ideport.h"
//#include "port.h"




VOID
IdePortNotification(
    IN IDE_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PFDO_EXTENSION deviceExtension = (PFDO_EXTENSION) HwDeviceExtension - 1;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSRB_DATA               srbData;
    PSCSI_REQUEST_BLOCK     srb;
    UCHAR                   pathId;
    UCHAR                   targetId;
    UCHAR                   lun;
    va_list                 ap;

    va_start(ap, HwDeviceExtension);

    switch (NotificationType) {

        case IdeNextRequest:

            //
            // Start next packet on adapter's queue.
            //

            deviceExtension->InterruptData.InterruptFlags |= PD_READY_FOR_NEXT_REQUEST;
            break;

        case IdeRequestComplete:

            srb = va_arg(ap, PSCSI_REQUEST_BLOCK);

            ASSERT(srb->SrbStatus != SRB_STATUS_PENDING);

            ASSERT(srb->SrbStatus != SRB_STATUS_SUCCESS || srb->ScsiStatus == SCSISTAT_GOOD || srb->Function != SRB_FUNCTION_EXECUTE_SCSI);

            //
            // If this srb has already been completed then return.
            //

            if (!(srb->SrbFlags & SRB_FLAGS_IS_ACTIVE)) {

                va_end(ap);
                return;
            }

            //
            // Clear the active flag.
            //

            CLRMASK (srb->SrbFlags, SRB_FLAGS_IS_ACTIVE);

            //
            // Treat abort completions as a special case.
            //

            if (srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

                PIRP irp;
                PIO_STACK_LOCATION irpStack;

                irp = srb->OriginalRequest;
                irpStack = IoGetCurrentIrpStackLocation(irp);
                logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP(irpStack);

                logicalUnit->CompletedAbort =
                    deviceExtension->InterruptData.CompletedAbort;

                deviceExtension->InterruptData.CompletedAbort = logicalUnit;

            } else {

                PIDE_REGISTERS_1 baseIoAddress1 = &(deviceExtension->
                                                    HwDeviceExtension->BaseIoAddress1);

                //
                // Get the SRB data and link it into the completion list.
                //

                srbData = IdeGetSrbData(deviceExtension, srb);

                ASSERT(srbData);
                ASSERT(srbData->CurrentSrb != NULL && srbData->CompletedRequests == NULL);

                if ((srb->SrbStatus == SRB_STATUS_SUCCESS) &&
                    ((srb->Cdb[0] == SCSIOP_READ) ||
                     (srb->Cdb[0] == SCSIOP_WRITE))) {
                    ASSERT(srb->DataTransferLength);
                }

                ASSERT (deviceExtension->InterruptData.CompletedRequests == NULL);

                srbData->CompletedRequests =
                    deviceExtension->InterruptData.CompletedRequests;
                deviceExtension->InterruptData.CompletedRequests = srbData;

                //
                // Save the task file registers
                //
                IdeLogSaveTaskFile(srbData, baseIoAddress1);
            }

            break;

        case IdeResetDetected:

            {
                PIRP irp;
                PIO_STACK_LOCATION irpStack;

                //
                // Notifiy the port driver that a reset has been reported.
                //
                srb = va_arg(ap, PSCSI_REQUEST_BLOCK);
    
                if (srb) {

                    irp = srb->OriginalRequest;
                    irpStack = IoGetCurrentIrpStackLocation(irp);
                    logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP(irpStack);

                } else {

                    logicalUnit = NULL;
                }
    
                ASSERT(deviceExtension->InterruptData.PdoExtensionResetBus == NULL);

                deviceExtension->InterruptData.InterruptFlags |= PD_RESET_REPORTED;
                deviceExtension->InterruptData.PdoExtensionResetBus = logicalUnit;
                break;
            }

        case IdeRequestTimerCall:

            //
            // The driver wants to set the miniport timer.
            // Save the timer parameters.
            //

            deviceExtension->InterruptData.InterruptFlags |=
                PD_TIMER_CALL_REQUEST;
            deviceExtension->InterruptData.HwTimerRequest =
                va_arg(ap, PHW_INTERRUPT);
            deviceExtension->InterruptData.MiniportTimerValue =
                va_arg(ap, ULONG);
            break;

        case IdeAllDeviceMissing:
            deviceExtension->InterruptData.InterruptFlags |= PD_ALL_DEVICE_MISSING;
            break;

        case IdeResetRequest:
            
            //
            // A reset was requested
            //
            deviceExtension->InterruptData.InterruptFlags |= PD_RESET_REQUEST;
            break;

        default:

             ASSERT(0);
    }

    va_end(ap);

    //
    // Request a DPC be queued after the interrupt completes.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_NOTIFICATION_REQUIRED;

} // end IdePortNotification()


VOID
IdePortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )

/*++

Routine Description:

    This routine saves the error log information, and queues a DPC if necessary.

Arguments:

    HwDeviceExtension - Supplies the HBA miniport driver's adapter data storage.

    Srb - Supplies an optional pointer to srb if there is one.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/

{
    PFDO_EXTENSION deviceExtension =
        ((PFDO_EXTENSION) HwDeviceExtension) - 1;
    PDEVICE_OBJECT DeviceObject = deviceExtension->DeviceObject;
    PSRB_DATA srbData;
    PERROR_LOG_ENTRY errorLogEntry;

    //
    // If the error log entry is already full, then dump the error.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_LOG_ERROR) {

#if DBG
        DebugPrint((1,"IdePortLogError: Dumping scsi error log packet.\n"));
        DebugPrint((1,
            "PathId = %2x, TargetId = %2x, Lun = %2x, ErrorCode = %x, UniqueId = %x.",
            PathId,
            TargetId,
            Lun,
            ErrorCode,
            UniqueId
            ));
#endif
        return;
    }

    //
    // Save the error log data in the log entry.
    //

    errorLogEntry = &deviceExtension->InterruptData.LogEntry;

    errorLogEntry->ErrorCode = ErrorCode;
    errorLogEntry->TargetId = TargetId;
    errorLogEntry->Lun = Lun;
    errorLogEntry->PathId = PathId;
    errorLogEntry->UniqueId = UniqueId;

    //
    // Get the sequence number from the SRB data.
    //

    if (Srb != NULL) {

        srbData = IdeGetSrbData(deviceExtension, Srb);

        if (srbData == NULL) {
            return;
        }

        errorLogEntry->SequenceNumber = srbData->SequenceNumber;
        errorLogEntry->ErrorLogRetryCount = srbData->ErrorLogRetryCount++;
    } else {
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->ErrorLogRetryCount = 0;
    }

    //
    // Indicate that the error log entry is in use.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_LOG_ERROR;

    //
    // Request a DPC be queued after the interrupt completes.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_NOTIFICATION_REQUIRED;

    return;

} // end IdePortLogError()


VOID
IdePortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN UCHAR SrbStatus
    )

/*++

Routine Description:

    Complete all active requests for the specified logical unit.

Arguments:

    DeviceExtenson - Supplies the HBA miniport driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    SrbStatus - Status to be returned in each completed SRB.

Return Value:

    None.

--*/

{
    PFDO_EXTENSION fdoExtension = ((PFDO_EXTENSION) HwDeviceExtension) - 1;
    PLOGICAL_UNIT_EXTENSION logUnitExtension;
    PIO_STACK_LOCATION irpStack;
    PIRP Irp;
    PSRB_DATA srbData;
    PLIST_ENTRY entry;
    ULONG limit = 0;

    Irp = (PIRP) Srb->OriginalRequest;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    logUnitExtension = IDEPORT_GET_LUNEXT_IN_IRP(irpStack);

    DebugPrint((2,
        "IdePortCompleteRequest: Complete requests for targetid %d\n",
        logUnitExtension->TargetId));

    //
    // Complete any pending abort reqeusts.
    //

    if (logUnitExtension->AbortSrb != NULL) {
        logUnitExtension->AbortSrb->SrbStatus = SrbStatus;

        IdePortNotification(
            IdeRequestComplete,
            HwDeviceExtension,
            logUnitExtension->AbortSrb
            );
    }

    IdeCompleteRequest(fdoExtension, &logUnitExtension->SrbData, SrbStatus);

    return;

} // end IdePortCompleteRequest()

BOOLEAN
TestForEnumProbing (
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    BOOLEAN enumProbing = FALSE;

    if (Srb) {

        if ((Srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) ||
            (Srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH)) {

            PATA_PASS_THROUGH    ataPassThroughData;

            ataPassThroughData = Srb->DataBuffer;

            enumProbing = ataPassThroughData->IdeReg.bReserved & ATA_PTFLAGS_ENUM_PROBING ? TRUE: FALSE;
        }
    }

    return enumProbing;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\pdopower.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    pdopower.c

Abstract:

--*/

#include "ideport.h"


VOID
IdePowerCheckBusyCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIDE_POWER_CONTEXT Context,
    IN NTSTATUS           Status
    );

NTSTATUS
DeviceQueryPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack;
    PPDO_EXTENSION pdoExtension;

    pdoExtension = RefPdoWithTag(
        DeviceObject,
        FALSE,
        Irp
        );

    if (pdoExtension) {

#if defined (DONT_POWER_DOWN_PAGING_DEVICE)
        irpStack = IoGetCurrentIrpStackLocation (Irp);

        if (!pdoExtension->CrashDumpPathCount ||
            ((irpStack->Parameters.Power.Type == SystemPowerState) &&
             (irpStack->Parameters.Power.State.SystemState == PowerSystemWorking)) ||
            ((irpStack->Parameters.Power.Type == DevicePowerState) &&
             (irpStack->Parameters.Power.State.SystemState == PowerDeviceD0))) {

            Irp->IoStatus.Status = STATUS_SUCCESS;

        } else {

            Irp->IoStatus.Status = STATUS_DEVICE_POWER_FAILURE;
        }
#else

        Irp->IoStatus.Status = STATUS_SUCCESS;

#endif // DONT_POWER_DOWN_PAGING_DEVICE

        UnrefPdoWithTag (pdoExtension, Irp);

    } else {

        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    PoStartNextPowerIrp (Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // Do not send this Irp down
    //

    return STATUS_SUCCESS;
}


NTSTATUS
IdePortSetPdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS           status;
    PIO_STACK_LOCATION irpStack;
    PPDO_EXTENSION     pdoExtension;


    irpStack     = IoGetCurrentIrpStackLocation (Irp);
    pdoExtension = DeviceObject->DeviceExtension;

    DebugPrint ((DBG_POWER,
                 "0x%x target %d got power irp 0x%x\n",
                 pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                 pdoExtension->TargetId,
                 Irp
                 ));


    DebugPrint ((DBG_POWER,
                 "IdePort: 0x%x device %d: current System Power State = 0x%x\n",
                 pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                 pdoExtension->TargetId,
                 pdoExtension->SystemPowerState));
    DebugPrint ((DBG_POWER,
                 "IdePort: 0x%x device %d: current Device Power State = 0x%x\n",
                 pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                 pdoExtension->TargetId,
                 pdoExtension->DevicePowerState));

    IoMarkIrpPending(Irp);

//    if (!(pdoExtension->LuFlags & PD_LOGICAL_UNIT_POWER_OK)) {
//
//        //
//        // The device does support power management commands
//        // just STATUS_SUCCESS everything.  If ACPI is around,
//        // it will power manage our device
//        //
//        status = STATUS_SUCCESS;
//
//    } else
    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        DebugPrint ((DBG_POWER, "IdePortSetPdoPowerState: 0x%x target %d got a SYSTEM power irp 0x%x for system state 0x%x \n",
                    pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                    pdoExtension->TargetId,
                    Irp,
                    irpStack->Parameters.Power.State.SystemState));

        ASSERT (pdoExtension->PendingSystemPowerIrp == NULL);
#if DBG
        pdoExtension->PendingSystemPowerIrp = Irp;
        ASSERT (pdoExtension->PendingSystemPowerIrp);
#endif // DBG

        status = IdePortSetPdoSystemPowerState (DeviceObject, Irp);

    } else if (irpStack->Parameters.Power.Type == DevicePowerState) {

        DebugPrint ((DBG_POWER, "IdePortSetPdoPowerState: 0x%x target %d got a DEVICE power irp 0x%x for device state 0x%x \n",
                    pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                    pdoExtension->TargetId,
                    Irp,
                    irpStack->Parameters.Power.State.DeviceState));

        ASSERT (pdoExtension->PendingDevicePowerIrp == NULL);
#if DBG
        pdoExtension->PendingDevicePowerIrp = Irp;
        ASSERT (pdoExtension->PendingDevicePowerIrp);
#endif // DBG

        status = IdePortSetPdoDevicePowerState (DeviceObject, Irp);

    } else {

        status = STATUS_NOT_IMPLEMENTED;
    }


    if (status != STATUS_PENDING) {

        Irp->IoStatus.Status = status;

        IdePortPdoCompletePowerIrp (
            DeviceObject,
            Irp
            );
    }

    return STATUS_PENDING;
}


NTSTATUS
IdePortSetPdoSystemPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS           status;
    PIO_STACK_LOCATION irpStack;
    PPDO_EXTENSION     pdoExtension;
    SYSTEM_POWER_STATE newSystemState;
    POWER_STATE        powerState;
    POWER_ACTION       shutdownType;

    pdoExtension   = DeviceObject->DeviceExtension;
    status = STATUS_SUCCESS;

    irpStack        = IoGetCurrentIrpStackLocation (Irp);
    newSystemState  = irpStack->Parameters.Power.State.SystemState;
    shutdownType    = irpStack->Parameters.Power.ShutdownType;

    if (pdoExtension->SystemPowerState != newSystemState) {

        //
        // new system state request
        //

        if (pdoExtension->SystemPowerState == PowerSystemWorking) {

            //
            // Getting out of working state.
            //
            if ((newSystemState == PowerSystemShutdown) &&
                (shutdownType == PowerActionShutdownReset)) {

                //
                // spin up for BIOS POST
                //
                powerState.DeviceState = PowerDeviceD0;

            } else {

                //
                // put the device to D3 and freeze the device queue
                //

                //
                // Issue a D3 to top of my drive stack
                //
                powerState.DeviceState = PowerDeviceD3;

                pdoExtension->PendingPowerDownSystemIrp = Irp;
            }

            status = PoRequestPowerIrp (
                         pdoExtension->DeviceObject,
                         IRP_MN_SET_POWER,
                         powerState,
                         IdePortPdoRequestPowerCompletionRoutine,
                         Irp,
                         NULL
                         );

            if (NT_SUCCESS(status)) {

                status = STATUS_PENDING;
            }

        } else {

            if (newSystemState == PowerSystemHibernate) {

                //
                // we can't hibernate when we are in some sleep state
                //
                ASSERT (FALSE);
            }
        }
    }
    return status;
}



NTSTATUS
IdePortSetPdoDevicePowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PPDO_EXTENSION     pdoExtension;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS           status;

    DEVICE_POWER_STATE newDeviceState;
    POWER_ACTION       shutdownType;

    BOOLEAN            issueIdeCommand;
    IDEREGS            ideReg;

    PIDE_POWER_CONTEXT context;
    BOOLEAN            powerUpParent;
    
    BOOLEAN            noopPassThrough;


    pdoExtension    = DeviceObject->DeviceExtension;
    status          = STATUS_SUCCESS;

    irpStack        = IoGetCurrentIrpStackLocation (Irp);
    newDeviceState  = irpStack->Parameters.Power.State.DeviceState;
    shutdownType    = irpStack->Parameters.Power.ShutdownType;

    powerUpParent   = FALSE;

    issueIdeCommand = FALSE;
    RtlZeroMemory (&ideReg, sizeof(ideReg));
      
    if (pdoExtension->DevicePowerState != newDeviceState) {

        if (pdoExtension->DevicePowerState == PowerDeviceD0) {

            POWER_STATE newPowerState;

            newPowerState.DeviceState = newDeviceState;

            //
            // getting out of D0 state, better call PoSetPowerState now
            // this gives the system a chance to flush before we
            // get out of D0
            //
            PoSetPowerState (
                pdoExtension->DeviceObject,
                DevicePowerState,
                newPowerState
                );
        }

        if (pdoExtension->DevicePowerState < newDeviceState) {

            KIRQL currentIrql;

            //
            // we are powering down, try to clean out the Lu device queue
            //
            KeAcquireSpinLock(&pdoExtension->ParentDeviceExtension->SpinLock, &currentIrql);

            pdoExtension->CurrentKey = 0;

            KeReleaseSpinLock(&pdoExtension->ParentDeviceExtension->SpinLock, currentIrql);
        }


        if ((newDeviceState == PowerDeviceD0) ||
            (newDeviceState == PowerDeviceD1)) {

            //
            // spinning up to D0 or D1...
            //
            DebugPrint ((DBG_POWER, "IdePort: Irp 0x%x to spin UP 0x%x %d...\n",
                        Irp,
                        pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                        pdoExtension->TargetId));

            if (pdoExtension->DevicePowerState == PowerDeviceD1) {

                //
                // D0-->D1
                // can't do much here

                DebugPrint ((DBG_POWER, "ATAPI: reqeust for PowerDeviceD1 to PowerDeviceD0\n"));

            } else if ((pdoExtension->DevicePowerState == PowerDeviceD0) ||
                       (pdoExtension->DevicePowerState == PowerDeviceD2)) {

                //
                // D1-->D0 or
                // D2-->D0 or D1
                //
                issueIdeCommand = TRUE;
                if (pdoExtension->ScsiDeviceType == READ_ONLY_DIRECT_ACCESS_DEVICE) {

                    ideReg.bCommandReg = IDE_COMMAND_ATAPI_RESET;
                    ideReg.bReserved = ATA_PTFLAGS_URGENT;

                } else {

                    ideReg.bCommandReg = IDE_COMMAND_IDLE_IMMEDIATE;
                    ideReg.bReserved = ATA_PTFLAGS_URGENT | ATA_PTFLAGS_STATUS_DRDY_REQUIRED;
                }

            } else {

                PFDO_EXTENSION fdoExtension = pdoExtension->ParentDeviceExtension;

                //
                // D3-->D0 or D1
                //
                issueIdeCommand = TRUE;
                ideReg.bReserved = ATA_PTFLAGS_BUS_RESET | ATA_PTFLAGS_URGENT;

                //
                // wait for busy to clear
                //
                if (fdoExtension->WaitOnPowerUp) {
                    ideReg.bSectorNumberReg = 3;
                }

                //
                // we are coming out of deeeeep sleep, make sure our parent
                // is awake (power up) before we can wake up
                //
                powerUpParent = TRUE;
            }

        } else if ((newDeviceState == PowerDeviceD2) ||
                   (newDeviceState == PowerDeviceD3)) {

            //
            // spinning down to D2 or D3...
            //
            DebugPrint ((DBG_POWER, "IdePort: Irp 0x%x to spin DOWN 0x%x %d...\n",
                         Irp,
                         pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                         pdoExtension->TargetId));

            if ((pdoExtension->DevicePowerState == PowerDeviceD0) ||
                (pdoExtension->DevicePowerState == PowerDeviceD1) ||
                (pdoExtension->DevicePowerState == PowerDeviceD2)) {

                //
                // going to D3
                //                                          
                if ((pdoExtension->PdoState & PDOS_NO_POWER_DOWN) ||
                    (shutdownType == PowerActionHibernate)) {
                    
                    //
                    // send an no-op command to block the queue
                    //
                    issueIdeCommand = TRUE;
                    ideReg.bReserved = ATA_PTFLAGS_NO_OP;
                    
                } else {
                    
                    //
                    // spin down
                    //
                    issueIdeCommand = TRUE;
                    ideReg.bCommandReg = IDE_COMMAND_STANDBY_IMMEDIATE;
                    ideReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;
                }

            } else if (pdoExtension->DevicePowerState == PowerDeviceD3) {

                //
                // PowerDeviceD3 -> PowerDeviceD2
                //
                // need to do a bus reset (spin up) and issue IDE_COMMAND_STANDBY_IMMEDIATE
                // (spin down).  this will cause uncessary INRUSH current.  bad
                // idea.  fail the request for now

                DebugPrint ((DBG_POWER, "ATAPI: reqeust for PowerDeviceD3 to PowerDeviceD2\n"));

                status = STATUS_INVALID_DEVICE_STATE;

            } else {

                status = STATUS_INVALID_DEVICE_STATE;
            }

        } else {

            status = STATUS_INVALID_DEVICE_STATE;
        }
    } 
    /*************
    else if ( pdoExtension->DevicePowerState == PowerDeviceD0) {

        //
        // Send a no-op so that it can drain the device queue
        //
        issueIdeCommand = TRUE;
        ideReg.bSectorCountReg = 1;
        ideReg.bReserved = ATA_PTFLAGS_NO_OP;
    }
    ***************/

    if (issueIdeCommand && NT_SUCCESS(status)) {

    
        if ((pdoExtension->PdoState & PDOS_DEADMEAT) ||
            (!(pdoExtension->PdoState & PDOS_STARTED))) {
            
            DebugPrint ((DBG_ALWAYS, 
                "ATAPI: power irp 0x%x for not-yet-started or deadmeat device 0x%x\n", 
                Irp, DeviceObject));
            
            //
            // even the device may not be ready to be
            // "power-managed", we still need to go 
            // through all the power code so that all
            // the flags/states will be consistent
            //                                 
            RtlZeroMemory (&ideReg, sizeof(ideReg));
            ideReg.bReserved = ATA_PTFLAGS_NO_OP | ATA_PTFLAGS_URGENT;
        }
                     
        //context = ExAllocatePool (NonPagedPool, sizeof(IDE_POWER_CONTEXT));
        ASSERT(InterlockedCompareExchange(&(pdoExtension->PowerContextLock), 1, 0) == 0);
        context = &(pdoExtension->PdoPowerContext);

        if (context) {

            context->PdoExtension       = pdoExtension;
            context->PowerIrp           = Irp;

            RtlZeroMemory (&context->AtaPassThroughData, sizeof(ATA_PASS_THROUGH));
            RtlMoveMemory (&context->AtaPassThroughData.IdeReg, &ideReg, sizeof(ideReg));

        } else {

            status = STATUS_NO_MEMORY;
            issueIdeCommand = FALSE;
        }
    }

    if (issueIdeCommand && NT_SUCCESS(status)) {

        if (powerUpParent) {

            status  = FdoChildRequestPowerUp (
                          pdoExtension->ParentDeviceExtension,
                          pdoExtension,
                          context
                          );
            ASSERT (NT_SUCCESS(status));

            //
            // the pass through will be issued by FdoChildRequestPowerUp() callback
            //
            issueIdeCommand = FALSE;
            status = STATUS_PENDING;
        }
    }

    if (issueIdeCommand && NT_SUCCESS(status)) {

        status = PdoRequestParentPowerUpCompletionRoutine (
                    context,
                    STATUS_SUCCESS
                    );

        //
        // this call will complete the power irp
        // always return STATUS_PENDING so that out callee
        // will not try to complete the same irp
        //
        status = STATUS_PENDING;
    }

    return status;
}

NTSTATUS
PdoRequestParentPowerUpCompletionRoutine (
    PVOID    Context,
    NTSTATUS ParentPowerUpStatus
)
{
    PIDE_POWER_CONTEXT context = Context;
    NTSTATUS status;

    if (NT_SUCCESS(ParentPowerUpStatus)) {

        PIDEREGS            ideReg;
        PATA_PASS_THROUGH   ataPassThrough;

        DebugPrint ((DBG_POWER, "PdoRequestParentPowerUpCompletionRoutine: calling IssueAsyncAtaPassThrough for pdo 0x%x\n", context->PdoExtension));

        //
        // hack. We need to check if the device is busy before we issue
        // the reset. Since there are no bits left in the bReserved 
        // register, we use the sectorCount register. It serves 2 purposes.
        // If it is non zero (and reserved has NO_OP set) then we would
        // perform a waitForBusy. It also indicates the time to wiat
        // in seconds.
        //
        ataPassThrough = &context->AtaPassThroughData;
        ideReg = &ataPassThrough->IdeReg;

        if ((ideReg->bReserved & ATA_PTFLAGS_BUS_RESET) &&
            (ideReg->bSectorNumberReg != 0)) {

            //
            // busy check
            //
            ideReg->bReserved = ATA_PTFLAGS_NO_OP | ATA_PTFLAGS_URGENT;

            status = IssueAsyncAtaPassThroughSafe (
                         context->PdoExtension->ParentDeviceExtension,
                         context->PdoExtension,
                         &context->AtaPassThroughData,
                         FALSE,
                         IdePowerCheckBusyCompletion,
                         context,
                         TRUE,
                         DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                         FALSE
                         );
        } else {

            //
            // parent woke up
            //
            status = IssueAsyncAtaPassThroughSafe (
                         context->PdoExtension->ParentDeviceExtension,
                         context->PdoExtension,
                         &context->AtaPassThroughData,
                         FALSE,
                         IdePowerPassThroughCompletion,
                         context,
                         TRUE,
                         DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                         FALSE
                         );
        }


    } else {

        status = ParentPowerUpStatus;
    }

    if (!NT_SUCCESS(status)) {

        context->PowerIrp->IoStatus.Status = status;

        IdePortPdoCompletePowerIrp (
                context->PdoExtension->DeviceObject,
                context->PowerIrp
                );

        ASSERT(InterlockedCompareExchange(&(context->PdoExtension->PowerContextLock), 0, 1) == 1);
        //ExFreePool (context);
    }

    return status;
}


VOID
IdePortPdoRequestPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PPDO_EXTENSION     pdoExtension;
    PIO_STACK_LOCATION irpStack;
    PIRP               irp = Context;

    pdoExtension         = (PPDO_EXTENSION) DeviceObject->DeviceExtension;
    irp->IoStatus.Status = IoStatus->Status;
    IdePortPdoCompletePowerIrp (
            pdoExtension->DeviceObject,
            irp
            );
    return;
}


VOID
IdePortPdoCompletePowerIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPDO_EXTENSION          pdoExtension;
    PFDO_EXTENSION          fdoExtension;
    PIO_STACK_LOCATION      irpStack;
    BOOLEAN                 callPoSetPowerState;
    KIRQL                   currentIrql;
    NTSTATUS                status;
    POWER_ACTION            shutdownType;

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    pdoExtension = DeviceObject->DeviceExtension;
    //shutdownType    = irpStack->Parameters.Power.ShutdownType;

    fdoExtension = pdoExtension->ParentDeviceExtension;

    status = Irp->IoStatus.Status;

    if (NT_SUCCESS(status)) {

        callPoSetPowerState = TRUE;

        Irp->IoStatus.Information = irpStack->Parameters.Power.State.DeviceState;

        if (irpStack->Parameters.Power.Type == SystemPowerState) {

            if (pdoExtension->SystemPowerState != irpStack->Parameters.Power.State.SystemState) {

                DebugPrint ((DBG_POWER,
                             "ATAPI: 0x%x target%d completing power Irp 0x%x with a new system state 0x%x\n",
                             pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             pdoExtension->TargetId,
                             Irp,
                             irpStack->Parameters.Power.State.SystemState));

                if (pdoExtension->SystemPowerState == PowerSystemWorking) {

                    KeAcquireSpinLock(&fdoExtension->SpinLock, &currentIrql);

                    //
                    // got out of S0, block the device queue
                    //
                    pdoExtension->PdoState |= PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM;

                    DebugPrint ((DBG_POWER,
                                 "IdePort: 0x%x target %d is powered down with 0x%x items queued\n",
                                 pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                                 pdoExtension->TargetId,
                                 pdoExtension->NumberOfIrpQueued));

                    KeReleaseSpinLock(&fdoExtension->SpinLock, currentIrql);
                }

                if (irpStack->Parameters.Power.State.SystemState == PowerSystemWorking) {

                    KeAcquireSpinLock(&fdoExtension->SpinLock, &currentIrql);

                    //
                    // got into S0, unblock and restart the device queue
                    //
                    CLRMASK (pdoExtension->PdoState, PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM);

                    DebugPrint ((DBG_POWER,
                                 "IdePort: 0x%x target %d is power up with 0x%x items queued\n",
                                 pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                                 pdoExtension->TargetId,
                                 pdoExtension->NumberOfIrpQueued));

                    GetNextLuPendingRequest (fdoExtension, pdoExtension);

                    KeLowerIrql(currentIrql);
                }

                pdoExtension->SystemPowerState = (int)Irp->IoStatus.Information;
            }

            pdoExtension->PendingPowerDownSystemIrp = NULL;

        } else /* if (irpStack->Parameters.Power.Type == DevicePowerState) */ {

            if (pdoExtension->DevicePowerState == PowerDeviceD0) {

                //
                // PoSetPowerState is called before we power down
                //

                callPoSetPowerState = FALSE;
            }

            if (pdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {

                DebugPrint ((DBG_POWER,
                             "ATAPI: 0x%x target %d completing power Irp 0x%x with a new device state 0x%x\n",
                             pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             pdoExtension->TargetId,
                             Irp,
                             irpStack->Parameters.Power.State.DeviceState));

                if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD3) {

#if 0
                    if (shutdownType == PowerActionHibernate) {
                        DebugPrint((0, "Don't power down the controller yet\n"));
                    } else {
#endif
                        //
						// should never do that if we are crashdump pointer
                        // tell parent that we just fell to sleep
                        //
                        FdoChildReportPowerDown (
                            fdoExtension,
                            pdoExtension
                            );
#if 0
                    }
#endif

                    KeAcquireSpinLock(&fdoExtension->SpinLock, &currentIrql);

                    //
                    // device is powered down.  block the device queue
                    //
                    SETMASK(pdoExtension->PdoState, PDOS_QUEUE_FROZEN_BY_POWER_DOWN);

                    DebugPrint ((DBG_POWER,
                                 "IdePort: 0x%x target %d is powered down with 0x%x items queued\n",
                                 pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                                 pdoExtension->TargetId,
                                 pdoExtension->NumberOfIrpQueued));

                    KeReleaseSpinLock(&fdoExtension->SpinLock, currentIrql);

                    if (pdoExtension->PendingPowerDownSystemIrp) {

                        //
                        // We get this power down irp
                        // because we are going to non-working state
                        // block the device queue
                        //

                        KeAcquireSpinLock(&fdoExtension->SpinLock, &currentIrql);

                        DebugPrint ((DBG_POWER,
                                     "ATAPI: blocking 0x%x target %d device queue\n",
                                     pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                                     pdoExtension->TargetId));

                        pdoExtension->PdoState |= PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM;

                        KeReleaseSpinLock(&fdoExtension->SpinLock, currentIrql);
                    }
                }

                if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD3) {

                    //
                    // get ready to reinit. the device via acpi data when
                    // we get out of D3
                    //
                    InterlockedIncrement (&pdoExtension->InitDeviceWithAcpiGtf);
                }

                if (pdoExtension->DevicePowerState == PowerDeviceD3) {

                    //
                    // just get out out D3, re-init. pdo
                    //
                    DebugPrint((DBG_POWER, "Calling DeviceInitDeviceState for irp 0x%x\n",
                                  Irp));
                    status = DeviceInitDeviceState (
                                 pdoExtension,
                                 DevicePowerUpInitCompletionRoutine,
                                 Irp
                                 );
                    if (!NT_SUCCESS(status)) {

                        DevicePowerUpInitCompletionRoutine (
                            Irp,
                            status
                            );
                    }

                    return;
                }

                pdoExtension->DevicePowerState = (int) Irp->IoStatus.Information;
            }
        }

        if ((callPoSetPowerState) && NT_SUCCESS(status)) {

            //
            // we didn't get out of device D0 state. calling PoSetPowerState now
            //

            PoSetPowerState (
                pdoExtension->DeviceObject,
                irpStack->Parameters.Power.Type,
                irpStack->Parameters.Power.State
                );
        }
    } else {

        if (irpStack->Parameters.Power.Type == SystemPowerState) {

            if (pdoExtension->SystemPowerState != irpStack->Parameters.Power.State.SystemState) {

                if (pdoExtension->SystemPowerState == PowerSystemWorking) {

                    //
                    // failed a system power down irp
                    //
                    KeAcquireSpinLock(&fdoExtension->SpinLock, &currentIrql);

                    //
                    // got into S0, unblock and restart the device queue
                    //
                    if (pdoExtension->PdoState & PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM) {

                        CLRMASK (pdoExtension->PdoState, PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM);

                        GetNextLuPendingRequest (fdoExtension, pdoExtension);

                        KeLowerIrql(currentIrql);

                    } else {

                        KeReleaseSpinLock(&fdoExtension->SpinLock, currentIrql);
                    }
                }
            }

            pdoExtension->PendingPowerDownSystemIrp = NULL;
        }
    }

    if (!NT_SUCCESS(status)) {

        DebugPrint ((DBG_ALWAYS,
                     "ATAPI: 0x%x target %d failed power Irp 0x%x. status = 0x%x\n",
                     pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                     pdoExtension->TargetId,
                     Irp,
                     Irp->IoStatus.Status));

        if (irpStack->Parameters.Power.Type == DevicePowerState) {

            //
            // ISSUE: 08/20/2000: Just failed a power D0 request...fail all pending irp
            //
            //ASSERT (irpStack->Parameters.Power.State.DeviceState != PowerDeviceD0);

            //
            // we will fail all the pending irps if we failed with status
            // no such device
            //
            if (status == STATUS_NO_SUCH_DEVICE) {

                DebugPrint ((0,
                             "Restarting the Lu queue after marking the device dead\n"
                             ));

                DebugPrint((0, 
                            "Device Power up irp failed with status 0x%x\n",
                            status
                            ));
                //
                // mark the pdo as dead
                // ISSUE: 12/19/2001. We should update deadmeat reason
                // for ease of debugging.
                //
                KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

                SETMASK (pdoExtension->PdoState, PDOS_DEADMEAT);

                KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

                //
                // ISSUE: 12/19/2001: Should we call IoInvalidateDeviceRelations?
                // we should get a remove irp in this case anyway.
                //
                IoInvalidateDeviceRelations (
                    fdoExtension->AttacheePdo,
                    BusRelations
                    );

                //
                // start any pending requests
                // ISSUE: 12/19/2001: We should hold the pdospinlock at 
                // this time. But in the other routines we seem to be
                // holding just the fdospinlock before modifying the 
                // pdostate. We will leave it as such to minimise regressions.
                //
                KeAcquireSpinLock(&fdoExtension->SpinLock, &currentIrql);

                if (pdoExtension->PdoState & PDOS_QUEUE_FROZEN_BY_POWER_DOWN) {

                    //
                    // ISSUE: 12/19/2001: We are not updating the device power
                    // state to D0. This would cause all the further requests
                    // to ask for a new power up irp. The system would be slow
                    // if we get too many requests. The remove irp should arrive
                    // eventually and end the misery.
                    //
                    CLRMASK (pdoExtension->PdoState, PDOS_QUEUE_FROZEN_BY_POWER_DOWN);

                    //
                    // restart the lu queue (on an lu that is marked dead)
                    // we didn't run GTF or do any of the other initialization.
                    // Since we marked the device dead above, we can restart the
                    // queue.They will get completed with status 
                    // device_does_not_exist.
                    //
                    GetNextLuPendingRequest (fdoExtension, pdoExtension);

                    KeLowerIrql(currentIrql);

                } else {

                    KeReleaseSpinLock(&fdoExtension->SpinLock, currentIrql);
                }
            } else {

                //
                // ISSUE: 12/192001: we handle only status_no_such device
                //
                ASSERT (irpStack->Parameters.Power.State.DeviceState != PowerDeviceD0);
            }
        }
    }

#if DBG
    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        DebugPrint ((DBG_POWER, "IdePortPdoCompletePowerIrp: 0x%x target %d completing a SYSTEM power irp 0x%x for system state 0x%x \n",
                     pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                     pdoExtension->TargetId,
                     Irp,
                     irpStack->Parameters.Power.State.SystemState));

        ASSERT (pdoExtension->PendingSystemPowerIrp == Irp);
        pdoExtension->PendingSystemPowerIrp = NULL;

    } else if (irpStack->Parameters.Power.Type == DevicePowerState) {

        DebugPrint ((DBG_POWER, "IdePortPdoCompletePowerIrp: 0x%x target %d completing a DEVICE power irp 0x%x for device state 0x%x \n",
                     pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                     pdoExtension->TargetId,
                     Irp,
                     irpStack->Parameters.Power.State.SystemState));

        ASSERT (pdoExtension->PendingDevicePowerIrp == Irp);
        pdoExtension->PendingDevicePowerIrp = NULL;
    }
#endif

    PoStartNextPowerIrp (Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

VOID
IdePowerCheckBusyCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIDE_POWER_CONTEXT Context,
    IN NTSTATUS           Status
    )
/*++

Routine Description

    Completion routine for ide pass through that would check if the
    device is busy. This is typically done before a reset to salvage
    drives that hang when a reset is issued while they are busy (due
    to a hardware reset)
    
Arguments:

    DeviceObject
    Context
    Status : Not used
    
Return Value

    None.
            
--*/
{
    PATA_PASS_THROUGH ataPassThrough;
    PIDEREGS ideReg;
    NTSTATUS status;

    ataPassThrough = &Context->AtaPassThroughData;
    ideReg = &ataPassThrough->IdeReg;

    //
    // send down the reset
    //

    RtlZeroMemory(ideReg, sizeof(IDEREGS));

    ideReg->bReserved = ATA_PTFLAGS_BUS_RESET | ATA_PTFLAGS_URGENT;

    status = IssueAsyncAtaPassThroughSafe (
                 Context->PdoExtension->ParentDeviceExtension,
                 Context->PdoExtension,
                 &Context->AtaPassThroughData,
                 FALSE,
                 IdePowerPassThroughCompletion,
                 Context,
                 TRUE,
                 DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                 FALSE
                 );

    return;
}

VOID
IdePowerPassThroughCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIDE_POWER_CONTEXT Context,
    IN NTSTATUS           Status
    )
{
    if (!NT_SUCCESS(Status)) {

        //
        // device failed power management command
        // will not try it anymore
        //
        KIRQL currentIrql;

        KeAcquireSpinLock(&Context->PdoExtension->PdoSpinLock, &currentIrql);

        SETMASK (Context->PdoExtension->PdoState, PDOS_NO_POWER_DOWN);

        KeReleaseSpinLock(&Context->PdoExtension->PdoSpinLock, currentIrql);

        Status = STATUS_SUCCESS;
    }

    Context->PowerIrp->IoStatus.Status = Status;

    IdePortPdoCompletePowerIrp (
        DeviceObject,
        Context->PowerIrp
        );

    ASSERT(InterlockedCompareExchange(&(Context->PdoExtension->PowerContextLock), 0, 1) == 1);
    //ExFreePool (Context);
}

VOID
DevicePowerUpInitCompletionRoutine (
    PVOID Context,
    NTSTATUS Status
    )
{
    PIRP irp = Context;
    PIO_STACK_LOCATION irpStack;
    PPDO_EXTENSION pdoExtension;
    KIRQL currentIrql;

    irpStack = IoGetCurrentIrpStackLocation (irp);
    pdoExtension = (PPDO_EXTENSION) irpStack->DeviceObject->DeviceExtension;

    if (!NT_SUCCESS(Status)) {

        //ASSERT (!"DevicePowerUpInitCompletionRoutine Failed\n");
        DebugPrint((DBG_ALWAYS, "ATAPI: ERROR: DevicePowerUpInitComplete failed with status %x\n",
                        Status));
    }

    ASSERT (pdoExtension->PendingDevicePowerIrp == irp);
    pdoExtension->PendingDevicePowerIrp = NULL;

    pdoExtension->DevicePowerState = (ULONG)irp->IoStatus.Information;

    PoSetPowerState (
        pdoExtension->DeviceObject,
        irpStack->Parameters.Power.Type,
        irpStack->Parameters.Power.State
        );

    KeAcquireSpinLock(&pdoExtension->ParentDeviceExtension->SpinLock, &currentIrql);

    //
    // got into D0, restart device queue
    //
    DebugPrint((DBG_POWER, "Clearing QUEUE_FROZEN_BY_POWER_DOWN flag\n"));
    CLRMASK(pdoExtension->PdoState, PDOS_QUEUE_FROZEN_BY_POWER_DOWN);

    GetNextLuPendingRequest (pdoExtension->ParentDeviceExtension, pdoExtension);

    KeLowerIrql(currentIrql);


    PoStartNextPowerIrp (irp);
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\regutils.h ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    regutil.h

Abstract:

--*/

#if !defined (___regutils_h___)
#define ___regutils_h___

// 
// Device Parameter Registry Flag Names
//        
#define MASTER_DEVICE_TYPE      L"MasterDeviceType"
#define SLAVE_DEVICE_TYPE       L"SlaveDeviceType"
#define MASTER_DEVICE_TYPE2     L"MasterDeviceType2"
#define SLAVE_DEVICE_TYPE2      L"SlaveDeviceType2"

#define DRIVER_PARAMETER_SUBKEY "Parameters"
                          
#define NEED_IDENT_DEVICE       L"NeedIdentDevice"
#define PIO_ONLY_DEVICE         L"PioOnlyDevice"
#define DEFAULT_PIO_DEVICE      L"DefaultPioAtapiDevice"
#define AUTO_EJECT_ZIP_DEVICE   L"AutoEjectZipDevice"
#define GHOST_SLAVE_DEVICE      L"GhostSlave"

#define CHECK_POWER_FLUSH_DEVICE L"UseCheckPowerForFlush"

#define NO_FLUSH_DEVICE         L"NoFlushDevice"
                  
#define NO_POWER_DOWN_DEVICE    L"NoPowerDownDevice"
                         
#define NONREMOVABLE_MEDIA_OVERRIDE L"NonRemovableMedia"

#define LEGACY_DETECTION        L"LegacyDetection"
                       
NTSTATUS
IdePortGetParameterFromServiceSubKey (
    IN     PDRIVER_OBJECT  DriverObject,
    IN     PWSTR           ParameterName,
    IN     ULONG           ParameterType,
    IN     BOOLEAN         Read,
    OUT    PVOID           *ParameterValue,
    IN     ULONG           ParameterValueWriteSize
);
  
NTSTATUS
IdePortRegQueryRoutine (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
);

NTSTATUS
IdePortGetDeviceParameter (
    IN     PFDO_EXTENSION  FdoExtension,
    IN     PWSTR           ParameterName,
    IN OUT PULONG          ParameterValue
    );

NTSTATUS
IdePortSaveDeviceParameter (
    IN PFDO_EXTENSION FdoExtension,
    IN PWSTR          ParameterName,
    IN ULONG          ParameterValue
    );

HANDLE
IdePortOpenServiceSubKey (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  SubKeyPath
);

VOID 
IdePortCloseServiceSubKey (
    IN HANDLE  SubServiceKey
);
                          
#endif // ___regutils_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\regutils.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    regutil.c

Abstract:

    This contain registry access routines

Author:

    Joe Dai (joedai)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "ideport.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IdePortGetParameterFromServiceSubKey)
#pragma alloc_text(PAGE, IdePortRegQueryRoutine)
#pragma alloc_text(PAGE, IdePortGetDeviceParameter)
#pragma alloc_text(PAGE, IdePortSaveDeviceParameter)
#pragma alloc_text(PAGE, IdePortOpenServiceSubKey)
#pragma alloc_text(PAGE, IdePortCloseServiceSubKey)

#endif // ALLOC_PRAGMA

NTSTATUS
IdePortGetParameterFromServiceSubKey (
    IN     PDRIVER_OBJECT  DriverObject,
    IN     PWSTR           ParameterName,
    IN     ULONG           ParameterType,
    IN     BOOLEAN         Read,
    OUT    PVOID           *ParameterValue,
    IN     ULONG           ParameterValueWriteSize
)
{
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    ULONG                    defaultParameterValue;   

    CCHAR                   deviceBuffer[50];
    ANSI_STRING             ansiString;
    UNICODE_STRING          subKeyPath;
    HANDLE                  subServiceKey;

    UNICODE_STRING          unicodeParameterName;

    PAGED_CODE();

    *ParameterValue = NULL;

    sprintf (deviceBuffer, DRIVER_PARAMETER_SUBKEY);
    RtlInitAnsiString(&ansiString, deviceBuffer);
    status = RtlAnsiStringToUnicodeString(&subKeyPath, &ansiString, TRUE);

    if (NT_SUCCESS(status)) {

        subServiceKey = IdePortOpenServiceSubKey (
                            DriverObject,
                            &subKeyPath
                            );

        RtlFreeUnicodeString (&subKeyPath);

        if (subServiceKey) {
        
            if (Read) {

                RtlZeroMemory(&queryTable, sizeof(queryTable));
            
                queryTable->QueryRoutine  = IdePortRegQueryRoutine;
                queryTable->Flags         = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
                queryTable->Name          = ParameterName;
                queryTable->EntryContext  = ParameterValue;
                queryTable->DefaultType   = 0;
                queryTable->DefaultData   = NULL;
                queryTable->DefaultLength = 0;
            
                status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                (PWSTR) subServiceKey,
                                                queryTable,
                                                ULongToPtr( ParameterType ),
                                                NULL);

            } else {

                RtlInitUnicodeString (&unicodeParameterName, ParameterName);


                status = ZwSetValueKey(
                             subServiceKey,
                             &unicodeParameterName,
                             0,
                             ParameterType,
                             ParameterValue,
                             ParameterValueWriteSize
                             );
            }


            //
            // close what we open
            //
            IdePortCloseServiceSubKey (
                subServiceKey
                );
        }
    }

    return status;
}
              
NTSTATUS
IdePortRegQueryRoutine (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)
{
    PVOID *parameterValue = EntryContext;
    ULONG parameterType = PtrToUlong(Context);

    PAGED_CODE();

    if (ValueType == parameterType) {

        if (ValueType == REG_MULTI_SZ) {
    
            *parameterValue = ExAllocatePool(PagedPool, ValueLength);
    
            if (*parameterValue) {
    
                RtlMoveMemory(*parameterValue, ValueData, ValueLength);
                return STATUS_SUCCESS;
            }

        } else if (ValueType == REG_DWORD) {
    
            PULONG ulongValue;

            ulongValue = (PULONG) parameterValue;
            *ulongValue = *((PULONG) ValueData);
            return STATUS_SUCCESS;
        }
    }

    return STATUS_UNSUCCESSFUL;
}


              
              
NTSTATUS
IdePortGetDeviceParameter (
    IN     PFDO_EXTENSION  FdoExtension,
    IN     PWSTR           ParameterName,
    IN OUT PULONG          ParameterValue
    )
/*++

Routine Description:

    retrieve a devnode registry parameter

Arguments:

    FdoExtension - FDO Extension
    
    ParameterName - parameter name to look up                                        
                                           
    ParameterValuse - default parameter value

Return Value:

    NT Status

--*/
{
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    ULONG                    defaultParameterValue;   

    PAGED_CODE();

    //
    // open the given parameter
    //
    status = IoOpenDeviceRegistryKey(FdoExtension->AttacheePdo,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_READ,
                                     &deviceParameterHandle);

    if(!NT_SUCCESS(status)) {

        return status;
    }

    RtlZeroMemory(&queryTable, sizeof(queryTable));

    defaultParameterValue = *ParameterValue;

    queryTable->Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    queryTable->Name          = ParameterName;
    queryTable->EntryContext  = ParameterValue;
    queryTable->DefaultType   = REG_DWORD;
    queryTable->DefaultData   = &defaultParameterValue;
    queryTable->DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                    (PWSTR) deviceParameterHandle,
                                    queryTable,
                                    NULL,
                                    NULL);
    if (!NT_SUCCESS(status)) {

        *ParameterValue = defaultParameterValue;
    }

    //
    // close what we open
    //
    ZwClose(deviceParameterHandle);

    return status;
} // IdePortGetDeviceParameter

NTSTATUS
IdePortSaveDeviceParameter (
    IN PFDO_EXTENSION FdoExtension,
    IN PWSTR          ParameterName,
    IN ULONG          ParameterValue
    )
/*++

Routine Description:

    save a devnode registry parameter

Arguments:

    FdoExtension - FDO Extension
    
    ParameterName - parameter name to save                                        
                                           
    ParameterValuse - parameter value to save

Return Value:

    NT Status

--*/
{
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;

    PAGED_CODE();

    //
    // open the given parameter
    //
    status = IoOpenDeviceRegistryKey(FdoExtension->AttacheePdo,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_WRITE,
                                     &deviceParameterHandle);

    if(!NT_SUCCESS(status)) {

        DebugPrint((DBG_WARNING,
                    "IdePortSaveDeviceParameter: IoOpenDeviceRegistryKey() returns 0x%x\n",
                    status));

        return status;
    }

    //
    // write the parameter value
    //
    status = RtlWriteRegistryValue(
                 RTL_REGISTRY_HANDLE,
                 (PWSTR) deviceParameterHandle,
                 ParameterName,
                 REG_DWORD,
                 &ParameterValue,
                 sizeof (ParameterValue)
                 );


    if(!NT_SUCCESS(status)) {

        DebugPrint((DBG_WARNING,
                    "IdePortSaveDeviceParameter: RtlWriteRegistryValue() returns 0x%x\n",
                    status));
    }

    //
    // close what we open
    //
    ZwClose(deviceParameterHandle);
    return status;
} // IdePortSaveDeviceParameter


HANDLE
IdePortOpenServiceSubKey (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  SubKeyPath
)
{
    PIDEDRIVER_EXTENSION ideDriverExtension;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE serviceKey;
    HANDLE subServiceKey;
    NTSTATUS status;

    ideDriverExtension = IoGetDriverObjectExtension(
                             DriverObject,
                             DRIVER_OBJECT_EXTENSION_ID
                             );

    if (!ideDriverExtension) {

        return NULL;
    }

    InitializeObjectAttributes(&objectAttributes,
                               &ideDriverExtension->RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&serviceKey,
                       KEY_ALL_ACCESS,
                       &objectAttributes);

    if (!NT_SUCCESS(status)) {

        return NULL;
    }

    InitializeObjectAttributes(&objectAttributes,
                               SubKeyPath,
                               OBJ_CASE_INSENSITIVE,
                               serviceKey,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&subServiceKey,
                       KEY_READ,
                       &objectAttributes);


    ZwClose(serviceKey);

    if (NT_SUCCESS(status)) {

        return subServiceKey;
    } else {

        return NULL;
    }
}

VOID 
IdePortCloseServiceSubKey (
    IN HANDLE  SubServiceKey
)
{
    ZwClose(SubServiceKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\wmi.c ===
/*++

Copyright (C) 1998-99  Microsoft Corporation

Module Name:

    wmi.c

Abstract:

--*/

#if defined (IDEPORT_WMI_SUPPORT)

#include <initguid.h>
#include "ideport.h"
#include <wmistr.h>

//
// Instantiate the GUIDs define in ntddscsi.h in this module.
//
#include <devguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IdePortWmiRegister)
#pragma alloc_text(PAGE, IdePortWmiDeregister)
#pragma alloc_text(PAGE, IdePortWmiSystemControl)
#pragma alloc_text(PAGE, DeviceQueryWmiDataBlock)
#pragma alloc_text(PAGE, DeviceSetWmiDataBlock)
#pragma alloc_text(PAGE, DeviceSetWmiDataItem)
#pragma alloc_text(PAGE, DeviceQueryWmiRegInfo)
#endif
                 
typedef enum {
    WmiScsiAddress = 0
} WMI_DATA_BLOCK_TYPE;

#define NUMBER_OF_WMI_GUID 1
WMIGUIDREGINFO IdePortWmiGuidList[NUMBER_OF_WMI_GUID];

VOID
IdePortWmiInit (VOID)
{
    PAGED_CODE();

    IdePortWmiGuidList[WmiScsiAddress].Guid  = &WmiScsiAddressGuid;
    IdePortWmiGuidList[WmiScsiAddress].InstanceCount = 1;
    IdePortWmiGuidList[WmiScsiAddress].Flags = 0;

    return;
}

NTSTATUS
IdePortWmiRegister(
    PDEVICE_EXTENSION_HEADER DoCommonExtension
    )
{
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(DoCommonExtension->AttacheePdo == NULL);

    DoCommonExtension->WmiLibInfo.GuidCount = NUMBER_OF_WMI_GUID;
    DoCommonExtension->WmiLibInfo.GuidList  = IdePortWmiGuidList;

    DoCommonExtension->WmiLibInfo.QueryWmiDataBlock  = DeviceQueryWmiDataBlock;
    DoCommonExtension->WmiLibInfo.QueryWmiRegInfo    = DeviceQueryWmiRegInfo;
    DoCommonExtension->WmiLibInfo.SetWmiDataBlock    = DeviceSetWmiDataBlock;
    DoCommonExtension->WmiLibInfo.SetWmiDataItem     = DeviceSetWmiDataItem;
    DoCommonExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DoCommonExtension->WmiLibInfo.WmiFunctionControl = NULL;

    status = IoWMIRegistrationControl(
                DoCommonExtension->DeviceObject,
                WMIREG_ACTION_REGISTER
                );

    if (!NT_SUCCESS(status)) {

        DebugPrint((
            DBG_ALWAYS, 
            "IdePortWmiRegister: IoWMIRegistrationControl(%x, WMI_ACTION_REGISTER) failed\n",
            DoCommonExtension->DeviceObject
            ));
    }

    return status;
}

NTSTATUS
IdePortWmiDeregister(
    PDEVICE_EXTENSION_HEADER DoCommonExtension
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = IoWMIRegistrationControl(
                 DoCommonExtension->DeviceObject,
                 WMIREG_ACTION_DEREGISTER
                 );

    if (!NT_SUCCESS(status)) {

        DebugPrint((
            DBG_ALWAYS, 
            "IdePortWmiDeregister: IoWMIRegistrationControl(%x, WMIREG_ACTION_DEREGISTER) failed\n",
            DoCommonExtension->DeviceObject
            ));
    }

    return status;
}


NTSTATUS
IdePortWmiSystemControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and call into the WMI system library and let
    it handle this IRP for us.

--*/
{
    PPDO_EXTENSION pdoExtension;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    PAGED_CODE();

    pdoExtension = RefPdoWithTag (DeviceObject, FALSE, (PVOID) ~(ULONG_PTR)Irp);

    if (pdoExtension) {

        status = WmiSystemControl(   &pdoExtension->WmiLibInfo,
                                     DeviceObject, 
                                     Irp,
                                     &disposition);
        switch(disposition)
        {
            case IrpProcessed:
            {
                //
                // This irp has been processed and may be completed 
                // or pending.
                break;
            }
            
            case IrpNotCompleted:
            {
                //
                // This irp has not been completed, but has been fully 
                // processed. We will complete it now
                IoCompleteRequest(Irp, IO_NO_INCREMENT);                
                break;
            }
            
            case IrpForward:
            case IrpNotWmi: 
            {
                //Fail the irp
                Irp->IoStatus.Status = status = STATUS_NOT_SUPPORTED;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);                
                break;
            }        
            default:
            {
                //
                // We really should never get here, but if we do just fail the irp
                ASSERT(FALSE);
                Irp->IoStatus.Status = status = STATUS_NOT_SUPPORTED;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);                
                break;
            }        
        }
        
        UnrefPdoWithTag (
            pdoExtension,
            (PVOID) ~(ULONG_PTR)Irp
            );

    } else {

        ASSERT(!"got WMI irp after the device is removed!\n");

        Irp->IoStatus.Status = status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
}

NTSTATUS
DeviceQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
                        
    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;
    ULONG numBytesReturned = sizeof(WMI_SCSI_ADDRESS);

    PAGED_CODE();

    ASSERT((InstanceIndex == 0) && (InstanceCount == 1));

    pdoExtension = RefPdoWithTag (DeviceObject, FALSE, Irp);

    if (!pdoExtension) {

        ASSERT(!"got WMI irp after the device is removed!\n");

        Irp->IoStatus.Status = status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    switch (GuidIndex) {
    case WmiScsiAddress: {

        PWMI_SCSI_ADDRESS scsiAddress;

        if (OutBufferSize < sizeof(WMI_SCSI_ADDRESS)) {
            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            scsiAddress = (PWMI_SCSI_ADDRESS) Buffer;
    
            scsiAddress->Bus = pdoExtension->PathId;
            scsiAddress->Target = pdoExtension->TargetId;
            scsiAddress->Lun = pdoExtension->Lun;

            *InstanceLengthArray = sizeof(WMI_SCSI_ADDRESS);
            status = STATUS_SUCCESS;
        }
        break;
    }

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  numBytesReturned,
                                  IO_NO_INCREMENT
                                  );

    UnrefPdoWithTag (
        pdoExtension,
        Irp
        );

    return status;
}

NTSTATUS
DeviceQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
                
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
    PIDEDRIVER_EXTENSION ideDriverExtension;
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    PAGED_CODE();

    pdoExtension = RefPdoWithTag (DeviceObject, FALSE, DeviceQueryWmiRegInfo);

    if (!pdoExtension) {

        ASSERT(!"got WMI callback after the device is removed!\n");
        status = STATUS_UNSUCCESSFUL;

    } else {

        ideDriverExtension = IoGetDriverObjectExtension(
                                 pdoExtension->DriverObject,
                                 DRIVER_OBJECT_EXTENSION_ID
                                 );
    
        if (!ideDriverExtension) {
    
            status = STATUS_UNSUCCESSFUL;
    
        } else {
    
            *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
            *RegistryPath = &ideDriverExtension->RegistryPath;
            *Pdo = pdoExtension->DeviceObject;
            status = STATUS_SUCCESS;
        }
    
        UnrefPdoWithTag (
            pdoExtension,
            DeviceQueryWmiRegInfo
            );
    }

    return status;
}

NTSTATUS
DeviceSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.
                        
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    PAGED_CODE();

    pdoExtension = RefPdoWithTag (DeviceObject, FALSE, Irp);

    if (!pdoExtension) {

        ASSERT(!"got WMI callback after the device is removed!\n");
        status = STATUS_UNSUCCESSFUL;

    } else {

        switch (GuidIndex) {
        case WmiScsiAddress: {
                        status = STATUS_WMI_READ_ONLY;
                        break;
                }
    
        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    
        status = WmiCompleteRequest(  DeviceObject,
                                      Irp,
                                      status,
                                      0,
                                      IO_NO_INCREMENT
                                      );

        UnrefPdoWithTag (
            pdoExtension,
            Irp
            );
    }
    
    return status;
}

NTSTATUS
DeviceSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.
                        
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    PAGED_CODE();

    pdoExtension = RefPdoWithTag (DeviceObject, FALSE, Irp);

    if (!pdoExtension) {

        ASSERT(!"got WMI callback after the device is removed!\n");
        status = STATUS_UNSUCCESSFUL;

    } else {

        switch(GuidIndex) {
    
        case WmiScsiAddress: {
                        status = STATUS_WMI_READ_ONLY;
                        break;
                }
    
        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    
        status = WmiCompleteRequest(  DeviceObject,
                                      Irp,
                                      status,
                                      0,
                                      IO_NO_INCREMENT
                                      );

        UnrefPdoWithTag (
            pdoExtension,
            Irp
            );
    }
    return status;
}

#endif // IDEPORT_WMI_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\port.h ===
/*++

Copyright (C) 1993-99  Microsoft Corporation

Module Name:

    port.h

Abstract:

--*/

#if !defined (___port_h___)
#define ___port_h___

//
// Notification Event Types
//

typedef enum _IDE_NOTIFICATION_TYPE {
    IdeRequestComplete,
    IdeNextRequest,
    IdeNextLuRequest,
    IdeResetDetected,
    IdeCallDisableInterrupts,
    IdeCallEnableInterrupts,
    IdeRequestTimerCall,
    IdeBusChangeDetected,     /* New */
    IdeWMIEvent,
    IdeWMIReregister,
    IdeAllDeviceMissing,
    IdeResetRequest
} IDE_NOTIFICATION_TYPE, *PIDE_NOTIFICATION_TYPE;

VOID
IdePortNotification(
    IN IDE_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    );

struct _SRB_DATA;

#define NUMBER_LOGICAL_UNIT_BINS 8
#define SP_NORMAL_PHYSICAL_BREAK_VALUE 17

#define IDE_NUM_RESERVED_PAGES	4

//
// Define a pointer to the synchonize execution routine.
//

typedef
BOOLEAN
(*PSYNCHRONIZE_ROUTINE) (
    IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    );

//
// Adapter object transfer information.
//

typedef struct _ADAPTER_TRANSFER {
    struct _SRB_DATA *SrbData;
    ULONG SrbFlags;
    PVOID LogicalAddress;
    ULONG Length;
}ADAPTER_TRANSFER, *PADAPTER_TRANSFER;

/**++ Not used

typedef struct _SRB_SCATTER_GATHER {
    // BUGBUG kenr 07-aug-92: PhysicalAddresses should be 64 bits
    ULONG PhysicalAddress;
    ULONG Length;
}SRB_SCATTER_GATHER, *PSRB_SCATTER_GATHER;

--**/

//
// Port driver error logging
//

typedef struct _ERROR_LOG_ENTRY {
    UCHAR MajorFunctionCode;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    ULONG ErrorCode;
    ULONG UniqueId;
    ULONG ErrorLogRetryCount;
    ULONG SequenceNumber;
} ERROR_LOG_ENTRY, *PERROR_LOG_ENTRY;

//
// SCSI request extension for port driver.
//

typedef struct _SRB_DATA {
    LIST_ENTRY RequestList;
    PSCSI_REQUEST_BLOCK CurrentSrb;
    struct _SRB_DATA *CompletedRequests;
    ULONG ErrorLogRetryCount;
    ULONG SequenceNumber;
    PCHAR SrbDataOffset;

#ifdef ENABLE_COMMAND_LOG
    PCOMMAND_LOG IdeCommandLog;
    ULONG IdeCommandLogIndex;
#endif

	ULONG Flags;

}SRB_DATA, *PSRB_DATA;

#define SRB_DATA_RESERVED_PAGES		0x100

//
// Define data storage for access at interrupt Irql.
//

typedef struct _PDO_EXTENSION * PPDO_EXTENSION;
typedef PPDO_EXTENSION PLOGICAL_UNIT_EXTENSION;

typedef struct _INTERRUPT_DATA {

    //
    // SCSI port interrupt flags
    //

    ULONG InterruptFlags;

    //
    // List head for singlely linked list of complete IRPs.
    //

    PSRB_DATA CompletedRequests;

    //
    // Adapter object transfer parameters.
    //

    ADAPTER_TRANSFER MapTransferParameters;

    //
    // Error log information.
    //

    ERROR_LOG_ENTRY  LogEntry;

    //
    // Logical unit to start next.
    //

    PLOGICAL_UNIT_EXTENSION ReadyLogicalUnit;

    //
    // List of completed abort reqeusts.
    //

    PLOGICAL_UNIT_EXTENSION CompletedAbort;

    //
    // Miniport timer request routine.
    //

    PHW_INTERRUPT HwTimerRequest;

    //
    // Mini port timer request time in micro seconds.
    //

    ULONG MiniportTimerValue;

    //
    // The PDO that causes a bus reset
    //
    PPDO_EXTENSION PdoExtensionResetBus;

} INTERRUPT_DATA, *PINTERRUPT_DATA;

//
// ACPI Firmware Settings
//
typedef struct _DEVICE_SETTINGS {

    ULONG   NumEntries;
    IDEREGS FirmwareSettings[0];

} DEVICE_SETTINGS, *PDEVICE_SETTINGS;

//
// Fdo Power Context (pre-alloced)
//
typedef struct _FDO_POWER_CONTEXT {

    BOOLEAN            TimingRestored;

    PIRP               OriginalPowerIrp;
    POWER_STATE_TYPE   newPowerType;
    POWER_STATE        newPowerState;

} FDO_POWER_CONTEXT, *PFDO_POWER_CONTEXT;

typedef enum _IDE_DEBUG_EVENT{
    CrcEvent =0,
    BusyEvent,
    RwEvent,
    MaxIdeEvent
}IDE_DEBUG_EVENT;

typedef struct _PDO_EXTENSION * PPDO_EXTENSION;
typedef struct _HW_DEVICE_EXTENSION * PHW_DEVICE_EXTENSION;
typedef struct _CONTROLLER_PARAMETERS * PCONTROLLER_PARAMETERS;
typedef struct _IDE_REGISTERS_1 *PIDE_REGISTERS_1;
typedef struct _IDE_REGISTERS_2 *PIDE_REGISTERS_2;
typedef struct _ENUMERATION_STRUCT *PENUMERATION_STRUCT;

//
// Device extension
//
typedef struct _FDO_EXTENSION {

    EXTENSION_COMMON_HEADER;
    PCM_RESOURCE_LIST   ResourceList;

    IDE_RESOURCE IdeResource;

    PCIIDE_SYNC_ACCESS_INTERFACE SyncAccessInterface;

    PCIIDE_XFER_MODE_INTERFACE TransferModeInterface;

    PCIIDE_REQUEST_PROPER_RESOURCES RequestProperResourceInterface;

    //
    // Device extension for miniport routines.
    //
    PHW_DEVICE_EXTENSION HwDeviceExtension;

    //
    // We are a child of a busmaster parent
    //
    BOOLEAN                BoundWithBmParent;

    BOOLEAN SymbolicLinkCreated;
    ULONG IdePortNumber;               // offset 0x0C
    ULONG ScsiPortNumber;               // offset 0x0C

    //
    // Active requests count.  This count is biased by -1 so a value of -1
    // indicates there are no requests out standing.
    //

    //LONG ActiveRequestCount;        // offset 0x10

    //
    // SCSI port driver flags
    //

    ULONG Flags;                    // offset 0x14

    ULONG FdoState;

    //
    // Srb flags to OR into all SRB.
    //

    ULONG SrbFlags;                 // offset 0x18
    LONG PortTimeoutCounter;        // offset 0x1C
    ULONG ResetCallAgain;
    PSCSI_REQUEST_BLOCK  ResetSrb;

    //
    // Number of SCSI buses
    //

    UCHAR MaxLuCount;               // offset 0x22
    PKINTERRUPT InterruptObject;    // offset 0x24

    //
    // Global device sequence number.
    //

    ULONG SequenceNumber;           // offset 0x30
    KSPIN_LOCK SpinLock;            // offset 0x34

    PADAPTER_OBJECT DmaAdapterObject;
    ADAPTER_TRANSFER FlushAdapterParameters;

    //
    // Pointer to the per SRB data array.
    //
    //PSRB_DATA SrbData;

    //
    // Pointer to the per SRB free list.
    //
    //PSRB_DATA FreeSrbData;

    //
    // Miniport service routine pointers.
    //
    PHW_INTERRUPT HwTimerRequest;

    //
    // Spinlock that protects LogicalUnitList manipulation
    //
    KSPIN_LOCK LogicalUnitListSpinLock;

    //
    // Number of logical unit in LogicalUnitList[]
    // Protected by LogicalUnitListSpinLock
    //
    UCHAR NumberOfLogicalUnits;

    //
    //
    //
    CCHAR NumberOfLogicalUnitsPowerUp;

    BOOLEAN DeviceChanged;
    //
    // panasonic pcmcia ide controller
    //
    BOOLEAN panasonicController;

    //
    // non-pcmcia controller, this is always set
    // if pcmcia controller, it is not set unless
    // registry flag PCMCIA_IDE_CONTROLLER_HAS_SLAVE
    // is non-zero
    //
    ULONG MayHaveSlaveDevice;

    //
    // Array of logical unit extensions.
    // Protected by LogicalUnitListSpinLock
    //
    PLOGICAL_UNIT_EXTENSION LogicalUnitList[NUMBER_LOGICAL_UNIT_BINS];

    //
    // Interrupt level data storage.
    //

    INTERRUPT_DATA InterruptData;

    //
    // SCSI Capabilities structure
    //

    IO_SCSI_CAPABILITIES Capabilities;

    //
    // Miniport timer object.
    //

    KTIMER MiniPortTimer;

    //
    // Miniport DPC for timer object.
    //

    KDPC MiniPortTimerDpc;

    //
    // channel timing from ACPI/BIOS
    //
    ACPI_IDE_TIMING BootAcpiTimingSettings;
    ACPI_IDE_TIMING AcpiTimingSettings;

    //
    // Transfermode cycle time
    //
    PULONG DefaultTransferModeTimingTable;

    //
    // User choice
    //
    IDE_DEVICETYPE UserChoiceDeviceType[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG UserChoiceTransferMode[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG UserChoiceTransferModeForAtapiDevice[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG TimingModeAllowed[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Use aggressive DMA
    //
    DMADETECTIONLEVEL DmaDetectionLevel;

    //
    // Pre-alloced context structure for power routines
    //
    FDO_POWER_CONTEXT   FdoPowerContext[2];

#if DBG
    //
    // Locks to synchronize access to the pre-alloced power context
    //
    ULONG   PowerContextLock[2];
#endif

#ifdef IDE_MEASURE_BUSSCAN_SPEED
    //
    // keep track of the time spent on the first busscan
    //
    ULONG BusScanTime;
#endif

    //
    // Pre-alloced structs used during enumeration
    //
#if DBG
    ULONG EnumStructLock;
#endif

    PENUMERATION_STRUCT PreAllocEnumStruct;

    //
    // Reserved error log entry per device to be used to log 
    // insufficient resources error
    //
    PVOID ReserveAllocFailureLogEntry[MAX_IDE_DEVICE];

	//
	// Temporary: Should be removed once I check in the fix 
	// for low memory condition
	//
	ULONG NumMemoryFailure;
	ULONG LastMemoryFailure;

	//
	// Reserve pages for use during low memory conditions
	//
	PVOID	ReservedPages;

#ifdef ENABLE_NATIVE_MODE
	//
	// Parent's interrupt interface
	//
    PCIIDE_INTERRUPT_INTERFACE InterruptInterface;
#endif

#ifdef ENABLE_48BIT_LBA
	ULONG EnableBigLba;
#endif

    ULONG WaitOnPowerUp;

#ifdef ENABLE_ATAPI_VERIFIER
    ULONG IdeVerifierFlags[MAX_IDE_DEVICE];
    ULONG IdeDebugVerifierFlags[MAX_IDE_DEVICE];
    ULONG IdeInternalVerifierFlags[MAX_IDE_DEVICE];
    ULONG IdeVerifierEventCount[MAX_IDE_DEVICE][MaxIdeEvent];
    ULONG IdeVerifierEventFrequency[MAX_IDE_DEVICE][MaxIdeEvent];
#endif

} FDO_EXTENSION, *PFDO_EXTENSION;

typedef struct _CONFIGURATION_CONTEXT {
    HANDLE BusKey;
    HANDLE ServiceKey;
    HANDLE DeviceKey;
    ULONG AdapterNumber;
    ULONG LastAdapterNumber;
    ULONG BusNumber;
    PVOID Parameter;
    PACCESS_RANGE AccessRanges;
    BOOLEAN DisableTaggedQueueing;
    BOOLEAN DisableMultipleLu;
}CONFIGURATION_CONTEXT, *PCONFIGURATION_CONTEXT;

typedef struct _INTERRUPT_CONTEXT {
    PFDO_EXTENSION DeviceExtension;
    PINTERRUPT_DATA SavedInterruptData;
}INTERRUPT_CONTEXT, *PINTERRUPT_CONTEXT;

typedef struct _RESET_CONTEXT {
    PFDO_EXTENSION DeviceExtension;
    UCHAR   PathId;
    BOOLEAN NewResetSequence;
    PSCSI_REQUEST_BLOCK  ResetSrb;
}RESET_CONTEXT, *PRESET_CONTEXT;

#define NEED_REQUEST_SENSE(Srb) (Srb->ScsiStatus == SCSISTAT_CHECK_CONDITION \
        && !(Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&                 \
        Srb->SenseInfoBuffer && Srb->SenseInfoBufferLength )

#define LONG_ALIGN (sizeof(LONG) - 1)

#define DEVICE_EXTENSION_SIZE sizeof(DEVICE_EXTENSION)


//
// Port driver extension flags.
//

//
// This flag indicates that a request has been passed to the miniport and the
// miniport has not indicated it is ready for another request.  It is set by
// IdeStartIoSynchronized. It is cleared by IdePortCompletionDpc when the
// miniport asks for another request.  Note the port driver will defer giving
// the miniport driver a new request if the current request disabled disconnects.
//

#define PD_DEVICE_IS_BUSY            0X00001

//
// Indicates that IdePortCompletionDpc needs to be run.  This is set when
// A miniport makes a request which must be done at DPC and is cleared when
// when the request information is gotten by IdeGetInterruptState.
//

#define PD_NOTIFICATION_REQUIRED     0X00004

//
// Indicates the miniport is ready for another request.  Set by
// ScsiPortNotification and cleared by IdeGetInterruptState.  This flag is
// stored in the interrupt data structure.
//

#define PD_READY_FOR_NEXT_REQUEST    0X00008

//
// Indicates the miniport wants the adapter channel flushed.  Set by
// IdePortFlushDma and cleared by IdeGetInterruptState.  This flag is
// stored in the data interrupt structure.  The flush adapter parameters
// are saved in the device object.
//

#define PD_FLUSH_ADAPTER_BUFFERS     0X00010

//
// Indicates the miniport wants the adapter channel programmed.  Set by
// IdePortIoMapTransfer and cleared by IdeGetInterruptState or
// IdePortFlushDma.  This flag is stored in the interrupt data structure.
// The I/O map transfer parameters are saved in the interrupt data structure.
//

#define PD_MAP_TRANSFER              0X00020

//
// Indicates the miniport wants to log an error.  Set by
// IdePortLogError and cleared by IdeGetInterruptState.  This flag is
// stored in the interrupt data structure.  The error log parameters
// are saved in the interrupt data structure.  Note at most one error per DPC
// can be logged.
//

#define PD_LOG_ERROR                 0X00040

//
// Indicates that no request should be sent to the miniport after
// a bus reset. Set when the miniport reports a reset or the port driver
// resets the bus. It is cleared by IdeTimeoutSynchronized.  The
// PortTimeoutCounter is used to time the length of the reset hold.  This flag
// is stored in the interrupt data structure.
//

#define PD_RESET_HOLD                0X00080

//
// Indicates a request was stopped due to a reset hold.  The held request is
// stored in the current request of the device object.  This flag is set by
// IdeStartIoSynchronized and cleared by IdeTimeoutSynchronized which also
// starts the held request when the reset hold has ended.  This flag is stored
// in the interrupt data structure.
//

#define PD_HELD_REQUEST              0X00100

//
// Indicates the miniport has reported a bus reset.  Set by
// IdePortNotification and cleared by IdeGetInterruptState.  This flag is
// stored in the interrupt data structure.
//

#define PD_RESET_REPORTED            0X00200

//
// Indicates there is a pending request for which resources
// could not be allocated.  This flag is set by IdeAllocateRequestStructures
// which is called from IdePortStartIo.  It is cleared by
// IdeProcessCompletedRequest when a request completes which then calls
// IdePortStartIo to try the request again.
//

#define PD_PENDING_DEVICE_REQUEST    0X00800

//
// This flag indicates that there are currently no requests executing with
// disconnects disabled.  This flag is normally on.  It is cleared by
// IdeStartIoSynchronized when a request with disconnect disabled is started
// and is set when that request completes.  IdeProcessCompletedRequest will
// start the next request for the miniport if PD_DEVICE_IS_BUSY is clear.
//

#define PD_DISCONNECT_RUNNING        0X01000

//
// Indicates the miniport wants the system interrupts disabled.  Set by
// IdePortNofitication and cleared by IdePortCompletionDpc.  This flag is
// NOT stored in the interrupt data structure.  The parameters are stored in
// the device extension.
//

#define PD_DISABLE_CALL_REQUEST      0X02000

//
// Indicates that system interrupts have been enabled and that the miniport
// has disabled its adapter from interruptint.  The miniport's interrupt
// routine is not called while this flag is set.  This flag is set by
// IdePortNotification when a CallEnableInterrupts request is made and
// cleared by IdeEnableInterruptSynchronized when the miniport requests that
// system interrupts be disabled.  This flag is stored in the interrupt data
// structure.
//

#define PD_DISABLE_INTERRUPTS        0X04000

//
// Indicates the miniport wants the system interrupt enabled.  Set by
// IdePortNotification and cleared by IdeGetInterruptState.  This flag is
// stored in the interrupt data structure.  The call enable interrupts
// parameters are saved in the device extension.
//

#define PD_ENABLE_CALL_REQUEST       0X08000

//
// Indicates the miniport is wants a timer request.  Set by
// IdePortNotification and cleared by IdeGetInterruptState.  This flag is
// stored in the interrupt data structure. The timer request parameters are
// stored in the interrupt data structure.
//

#define PD_TIMER_CALL_REQUEST        0X10000


//
// channel looks empty
//
#define PD_ALL_DEVICE_MISSING        0X20000

//
// Request a reset
//
#define PD_RESET_REQUEST             0x40000 

//
// Reserve pages are being used by another request
//
#define PD_RESERVED_PAGES_IN_USE     0x80000 

//
// The following flags should not be cleared from the interrupt data structure
// by IdeGetInterruptState.
//

#define PD_INTERRUPT_FLAG_MASK (PD_RESET_HOLD | PD_HELD_REQUEST | PD_DISABLE_INTERRUPTS)

//
// Logical unit extension flags.
//

//
// Indicates the logical unit queue is frozen.  Set by
// IdeProcessCompletedRequest when an error occurs and is cleared by the class
// driver.
//

#define PD_QUEUE_FROZEN              0X0001

//
// Indicates that the miniport has an active request for this logical unit.
// Set by IdeStartIoSynchronized when the request is started and cleared by
// GetNextLuRequest.  This flag is used to track when it is ok to start another
// request from the logical unit queue for this device.
//

#define PD_LOGICAL_UNIT_IS_ACTIVE    0X0002

//
// Indicates that a request for this logical unit has failed and a REQUEST
// SENSE command needs to be done. This flag prevents other requests from
// being started until an untagged, by-pass queue command is started.  This
// flag is cleared in IdeStartIoSynchronized.  It is set by
// IdeGetInterruptState.
//

#define PD_NEED_REQUEST_SENSE  0X0004

//
// Indicates that a request for this logical unit has completed with a status
// of BUSY or QUEUE FULL.  This flag is set by IdeProcessCompletedRequest and
// the busy request is saved in the logical unit structure.  This flag is
// cleared by IdePortTickHandler which also restarts the request.  Busy
// request may also be requeued to the logical unit queue if an error occurs
// on the device (This will only occur with command queueing.).  Not busy
// requests are nasty because they are restarted asynchronously by
// IdePortTickHandler rather than GetNextLuRequest. This makes error recovery
// more complex.
//

#define PD_LOGICAL_UNIT_IS_BUSY      0X0008

//
// This flag indicates a queue full has been returned by the device.  It is
// similar to PD_LOGICAL_UNIT_IS_BUSY but is set in IdeGetInterruptState when
// a QUEUE FULL status is returned.  This flag is used to prevent other
// requests from being started for the logical unit before
// IdeProcessCompletedRequest has a chance to set the busy flag.
//

#define PD_QUEUE_IS_FULL             0X0010


//
// Indicates that there is a request for this logical unit which cannot be
// executed for now.  This flag is set by IdeAllocateRequestStructures.  It is
// cleared by GetNextLuRequest when it detects that the pending request
// can now be executed. The pending request is stored in the logical unit
// structure.  A new single non-queued reqeust cannot be executed on a logical
// that is currently executing queued requests.  Non-queued requests must wait
// unit for all queued requests to complete.  A non-queued requests is one
// which is not tagged and does not have SRB_FLAGS_NO_QUEUE_FREEZE set.
// Normally only read and write commands can be queued.
//


//#define PD_LOGICAL_UNIT_MUST_SLEEP      0X0020
//#define PD_LOGICAL_UNIT_STOP_READY      0X0040
//#define PD_LOGICAL_UNIT_REMOVE_READY    0X0080
//#define PD_LOGICAL_UNIT_ALWAYS_QUEUE    (PD_LOGICAL_UNIT_STOP_READY | PD_LOGICAL_UNIT_REMOVE_READY)

//#define PD_LOGICAL_UNIT_POWER_OK        0X0100


//#define PD_LOGICAL_IN_PAGING_PATH       0X2000

//#define PD_LOGICAL_UNIT_LEGACY_ATTACHER 0X4000

//
// Indicates that the LogicalUnit has been allocated for a rescan request.
// This flag prevents IOCTL_SCSI_MINIPORT requests from attaching to this
// logical unit, since the possibility exists that it could be freed before
// the IOCTL request is complete.
//

#define PD_RESCAN_ACTIVE             0x8000



//
// FdoExtension FdoState
//
#define FDOS_DEADMEAT                (1 << 0)
#define FDOS_STARTED                 (1 << 1)
#define FDOS_STOPPED                 (1 << 2)


//
// Port Timeout Counter values.
//

#define PD_TIMER_STOPPED             -1
#define PD_TIMER_RESET_HOLD_TIME     1

//
// Define the mimimum and maximum number of srb extensions which will be allocated.
//

#define MINIMUM_SRB_EXTENSIONS        16
#define MAXIMUM_SRB_EXTENSIONS       512

//
// Size of the buffer used for registry operations.
//

#define SP_REG_BUFFER_SIZE 512

//
// Number of times to retry when a BUSY status is returned.
//

#define BUSY_RETRY_COUNT 20

//
// Number of times to retry an INQUIRY request.
//

#define INQUIRY_RETRY_COUNT 2

//
// Function declarations
//

IO_ALLOCATION_ACTION
CallIdeStartIoSynchronized (
    IN PVOID Reserved1,
    IN PVOID Reserved2,
    IN PVOID Reserved3,
    IN PVOID DeviceObject
    );

NTSTATUS
IdePortCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IdePortDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
IdePortAllocateAccessToken (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
IdePortStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
IdePortInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
IdePortCompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
IdePortDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
IdePortTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

BOOLEAN
AtapiRestartBusyRequest (
    PFDO_EXTENSION DeviceExtension,
    PPDO_EXTENSION LogicalUnit
    );

VOID
IssueRequestSense(
    IN PPDO_EXTENSION PdoExtension,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    );

VOID
IdePortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    );

NTSTATUS
IdePortInternalCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

BOOLEAN
IdeStartIoSynchronized (
    PVOID ServiceContext
    );

BOOLEAN
IdeResetBusSynchronized (
    PVOID ServiceContext
    );

BOOLEAN
IdeTimeoutSynchronized (
    PVOID ServiceContext
    );

VOID
IssueAbortRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

BOOLEAN
IdeGetInterruptState(
    IN PVOID ServiceContext
    );

VOID
LogErrorEntry(
    IN PFDO_EXTENSION DeviceExtension,
    IN PERROR_LOG_ENTRY LogEntry
    );

VOID
GetNextLuPendingRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

#if DBG

#define GetNextLuRequest(x, y)      GetNextLuRequest2(x, y, __FILE__, __LINE__)

VOID
GetNextLuRequest2(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PUCHAR FileName,
    IN ULONG  LineNumber
    );

#else

VOID
GetNextLuRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

#endif


VOID
IdeLogTimeoutError(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp,
    IN ULONG UniqueId
    );

NTSTATUS
IdeTranslateSrbStatus(
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
IdeProcessCompletedRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    OUT PBOOLEAN CallStartIo
    );

PSRB_DATA
IdeGetSrbData(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
IdeCompleteRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    IN UCHAR SrbStatus
    );

NTSTATUS
IdeSendMiniPortIoctl(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    );

NTSTATUS
IdeGetInquiryData(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
IdeSendPassThrough(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
IdeClaimLogicalUnit(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

VOID
IdeMiniPortTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
IdeSynchronizeExecution (
    IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    );

NTSTATUS
IdeGetCommonBuffer(
    PFDO_EXTENSION DeviceExtension,
    ULONG NonCachedExtensionSize
    );

VOID
IdeDeviceCleanup(
    PFDO_EXTENSION DeviceExtension
    );

NTSTATUS
IdeInitializeConfiguration(
    IN PFDO_EXTENSION DeviceExtension,
    IN PCONFIGURATION_CONTEXT Context
    );

#define IDEPORT_PUT_LUNEXT_IN_IRP(IrpStack, LogUnitExt) (IrpStack->Parameters.Others.Argument4 = LogUnitExt)
#define IDEPORT_GET_LUNEXT_IN_IRP(IrpStack)             ((PLOGICAL_UNIT_EXTENSION) (IrpStack->Parameters.Others.Argument4))

VOID
IdePortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN UCHAR SrbStatus
    );

NTSTATUS
IdePortFlushLogicalUnit (
    PFDO_EXTENSION          FdoExtension,
    PLOGICAL_UNIT_EXTENSION LogUnitExtension,
    BOOLEAN                 Forced
);

typedef VOID (*ASYNC_PASS_THROUGH_COMPLETION) (
    IN PDEVICE_OBJECT DeviceObject,
    PVOID Context,
    NTSTATUS Status
    );

NTSTATUS
IssueAsyncAtaPassThroughSafe (
    IN PFDO_EXTENSION                DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION       LogUnitExtension,
    IN OUT PATA_PASS_THROUGH         AtaPassThroughData,
    IN BOOLEAN                       DataIn,
    IN ASYNC_PASS_THROUGH_COMPLETION Completion,
    IN PVOID                         Context,
    IN BOOLEAN                       PowerRelated,
    IN ULONG                         TimeOut,
    IN BOOLEAN                         MustSucceed
);

typedef struct _ATA_PASSTHROUGH_CONTEXT {

    PDEVICE_OBJECT                DeviceObject;

    ASYNC_PASS_THROUGH_COMPLETION CallerCompletion;
    PVOID                         CallerContext;
    PSCSI_REQUEST_BLOCK           Srb;
    PSENSE_DATA                   SenseInfoBuffer;
    BOOLEAN                         MustSucceed;
    PATA_PASS_THROUGH             DataBuffer;

} ATA_PASSTHROUGH_CONTEXT, *PATA_PASSTHROUGH_CONTEXT;

NTSTATUS
AtaPassThroughCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

typedef struct _SYNC_ATA_PASSTHROUGH_CONTEXT {

    KEVENT      Event;
    NTSTATUS    Status;

} SYNC_ATA_PASSTHROUGH_CONTEXT, *PSYNC_ATA_PASSTHROUGH_CONTEXT;


typedef struct _FLUSH_ATA_PASSTHROUGH_CONTEXT {

    PIRP               FlushIrp;
    PATA_PASS_THROUGH  ataPassThroughData;

} FLUSH_ATA_PASSTHROUGH_CONTEXT, *PFLUSH_ATA_PASSTHROUGH_CONTEXT;

NTSTATUS
IssueSyncAtaPassThroughSafe (
    IN PFDO_EXTENSION           DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION  LogUnitExtension,
    IN OUT PATA_PASS_THROUGH    AtaPassThroughData,
    IN BOOLEAN                  DataIn,
    IN BOOLEAN                  PowerRelated,
    IN ULONG                    TimeOut,
    IN BOOLEAN                    MustSucceed
);

VOID
SyncAtaPassThroughCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context,
    IN NTSTATUS       Status
    );

VOID
IdeUnmapReservedMapping (
	IN PFDO_EXTENSION 	DeviceExtension,
	IN PSRB_DATA	  	SrbData,
	IN PMDL	  			Mdl
	);

PVOID
IdeMapLockedPagesWithReservedMapping (
	IN PFDO_EXTENSION DeviceExtension,
	IN PSRB_DATA	  SrbData,
	IN PMDL	    	  Mdl
	);

BOOLEAN
TestForEnumProbing (
    IN PSCSI_REQUEST_BLOCK Srb
    );

#define DEFAULT_ATA_PASS_THROUGH_TIMEOUT        15

#define INIT_IDE_SRB_FLAGS(Srb)         (Srb->SrbExtension = NULL)
#define SANITY_CHECK_SRB(Srb)           {ASSERT(!(((ULONG_PTR)Srb->SrbExtension) & ~7));}
#define MARK_SRB_AS_PIO_CANDIDATE(Srb)  {SANITY_CHECK_SRB(Srb); ((ULONG_PTR)Srb->SrbExtension) |= 1;}
#define MARK_SRB_AS_DMA_CANDIDATE(Srb)  {SANITY_CHECK_SRB(Srb); ((ULONG_PTR)Srb->SrbExtension) &= ~1;}
#define MARK_SRB_FOR_DMA(Srb)           {SANITY_CHECK_SRB(Srb); ((ULONG_PTR)Srb->SrbExtension) |= 2;}
#define MARK_SRB_FOR_PIO(Srb)           {SANITY_CHECK_SRB(Srb); ((ULONG_PTR)Srb->SrbExtension) &= ~2;}
#define SRB_IS_DMA_CANDIDATE(Srb)       (!(((ULONG_PTR)Srb->SrbExtension) & 1))
#define SRB_USES_DMA(Srb)               (((ULONG_PTR)Srb->SrbExtension) & 2)
#define TEST_AND_SET_SRB_FOR_RDP(ScsiDeviceType, Srb)   \
                                        if ((ScsiDeviceType == SEQUENTIAL_ACCESS_DEVICE) &&\
                                            ((Srb->Cdb[0] == SCSIOP_ERASE)  || (Srb->Cdb[0] == SCSIOP_LOAD_UNLOAD)||\
                                             (Srb->Cdb[0] == SCSIOP_LOCATE) || (Srb->Cdb[0] == SCSIOP_REWIND) ||\
                                             (Srb->Cdb[0] == SCSIOP_SPACE)  || (Srb->Cdb[0] == SCSIOP_SEEK)||\
                                             (Srb->Cdb[0] == SCSIOP_WRITE_FILEMARKS))) {\
                                            SANITY_CHECK_SRB(Srb);\
                                            ((ULONG_PTR)Srb->SrbExtension) |= 4;\
                                        } else if ((ScsiDeviceType == READ_ONLY_DIRECT_ACCESS_DEVICE) && \
                                            (Srb->Cdb[0]==SCSIOP_SEEK) ) {\
                                            SANITY_CHECK_SRB(Srb);\
                                            ((ULONG_PTR)Srb->SrbExtension) |= 4;\
                                        } else {\
                                            SANITY_CHECK_SRB(Srb);\
                                            ((ULONG_PTR)Srb->SrbExtension) &= ~4;\
                                        }
#define SRB_IS_RDP(Srb)                 (((ULONG_PTR)Srb->SrbExtension) & 4)

#define ERRLOGID_TOO_MANY_DMA_TIMEOUT   0x80000001
#define ERRLOGID_LYING_DMA_SYSTEM       0x80000002
#define ERRLOGID_TOO_MANY_CRC_ERROR     0x80000003

#define DEFAULT_SPINUP_TIME             (30)

//#define PUT_IRP_TRACKER(irpStack, num) if ((irpStack)->Parameters.Others.Argument2) {\
 //               (ULONG_PTR)((irpStack)->Parameters.Others.Argument2) |= (1<<num);}
#define PUT_IRP_TRACKER(irpStack, num)

#define FREE_IRP_TRACKER(irpStack)

#endif // ___port_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\inc\ideuser.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    ideuser.h

Abstract:

    These are the structures and defines that are used in the
    PCI IDE mini drivers.

Revision History:

--*/

#if !defined (___ideuser_h___)
#define ___ideuser_h___

//@@BEGIN_DDKSPLIT
 
typedef enum  {
    DeviceUnknown = 0,
    DeviceIsAta,
    DeviceIsAtapi,
    DeviceNotExist
} IDE_DEVICETYPE;

typedef enum  {
    DdlPioOnly = 0,
    DdlFirmwareOk,
    DdlAlways
} DMADETECTIONLEVEL;

#define DMA_DETECTION_LEVEL_REG_KEY L"DmaDetectionLevel"

#define PCMCIA_IDE_CONTROLLER_HAS_SLAVE L"PcmciaIdeHasSlaveDevice"

#define MASTER_DEVICE_TIMEOUT    L"MasterDeviceDetectionTimeout"
#define SLAVE_DEVICE_TIMEOUT     L"SlaveDeviceDetectionTimeout"

#define MASTER_DEVICE_TYPE_REG_KEY    L"MasterDeviceType"
#define SLAVE_DEVICE_TYPE_REG_KEY     L"SlaveDeviceType"
#define MASTER_DEVICE_TYPE2_REG_KEY   L"MasterDeviceType2"
#define SLAVE_DEVICE_TYPE2_REG_KEY    L"SlaveDeviceType2"

#define USER_MASTER_DEVICE_TYPE_REG_KEY    L"UserMasterDeviceType"
#define USER_SLAVE_DEVICE_TYPE_REG_KEY     L"UserSlaveDeviceType"
#define USER_MASTER_DEVICE_TYPE2_REG_KEY   L"UserMasterDeviceType2"
#define USER_SLAVE_DEVICE_TYPE2_REG_KEY    L"UserSlaveDeviceType2"

#define MASTER_DEVICE_TIMING_MODE    L"MasterDeviceTimingMode"
#define SLAVE_DEVICE_TIMING_MODE     L"SlaveDeviceTimingMode"
#define MASTER_DEVICE_TIMING_MODE2   L"MasterDeviceTimingMode2"
#define SLAVE_DEVICE_TIMING_MODE2    L"SlaveDeviceTimingMode2"

#define MASTER_DEVICE_TIMING_MODE_ALLOWED    L"MasterDeviceTimingModeAllowed"
#define SLAVE_DEVICE_TIMING_MODE_ALLOWED     L"SlaveDeviceTimingModeAllowed"
#define MASTER_DEVICE_TIMING_MODE_ALLOWED2   L"MasterDeviceTimingModeAllowed2"
#define SLAVE_DEVICE_TIMING_MODE_ALLOWED2    L"SlaveDeviceTimingModeAllowed2"

#define USER_MASTER_DEVICE_TIMING_MODE_ALLOWED    L"UserMasterDeviceTimingModeAllowed"
#define USER_SLAVE_DEVICE_TIMING_MODE_ALLOWED     L"UserSlaveDeviceTimingModeAllowed"
#define USER_MASTER_DEVICE_TIMING_MODE_ALLOWED2   L"UserMasterDeviceTimingModeAllowed2"
#define USER_SLAVE_DEVICE_TIMING_MODE_ALLOWED2    L"UserSlaveDeviceTimingModeAllowed2"

#define MASTER_IDDATA_CHECKSUM      L"MasterIdDataCheckSum"
#define SLAVE_IDDATA_CHECKSUM       L"SlaveIdDataCheckSum"
#define MASTER_IDDATA_CHECKSUM2     L"MasterIdDataCheckSum2"
#define SLAVE_IDDATA_CHECKSUM2      L"SlaveIdDataCheckSum2" 
 
//@@END_DDKSPLIT
  
#define PIO_MODE0           (1 << 0)
#define PIO_MODE1           (1 << 1)
#define PIO_MODE2           (1 << 2)
#define PIO_MODE3           (1 << 3)
#define PIO_MODE4           (1 << 4)

#define SWDMA_MODE0         (1 << 5)
#define SWDMA_MODE1         (1 << 6)
#define SWDMA_MODE2         (1 << 7)

#define MWDMA_MODE0         (1 << 8)
#define MWDMA_MODE1         (1 << 9)
#define MWDMA_MODE2         (1 << 10)

#define UDMA_MODE0          (1 << 11)
#define UDMA_MODE1          (1 << 12)
#define UDMA_MODE2          (1 << 13)
#define UDMA_MODE3          (1 << 14)
#define UDMA_MODE4          (1 << 15)
#define UDMA_MODE5          (1 << 16)

#define PIO_SUPPORT         (PIO_MODE0      | PIO_MODE1     | PIO_MODE2    | PIO_MODE3     | PIO_MODE4)
#define SWDMA_SUPPORT       (SWDMA_MODE0    | SWDMA_MODE1   | SWDMA_MODE2)
#define MWDMA_SUPPORT       (MWDMA_MODE0    | MWDMA_MODE1   | MWDMA_MODE2)
#define UDMA33_SUPPORT      (UDMA_MODE0     | UDMA_MODE1    | UDMA_MODE2)
#define UDMA66_SUPPORT      (UDMA_MODE3     | UDMA_MODE4)
#define UDMA100_SUPPORT     (UDMA_MODE5 )
#define UDMA_SUPPORT        (UNINITIALIZED_TRANSFER_MODE & (~(PIO_SUPPORT | SWDMA_SUPPORT | MWDMA_SUPPORT)))

#define DMA_SUPPORT         (SWDMA_SUPPORT  | MWDMA_SUPPORT | UDMA_SUPPORT)
#define ALL_MODE_SUPPORT    (PIO_SUPPORT | DMA_SUPPORT)

#define PIO0                        0
#define PIO1                        1
#define PIO2                        2
#define PIO3                        3
#define PIO4                        4
#define SWDMA0                      5
#define SWDMA1                      6
#define SWDMA2                      7
#define MWDMA0                      8
#define MWDMA1                      9
#define MWDMA2                      10
#define UDMA0                       11

#define MAX_XFER_MODE               17
#define UNINITIALIZED_CYCLE_TIME    0xffffffff
#define UNINITIALIZED_TRANSFER_MODE 0x7fffffff
#define IS_DEFAULT(mode)    (!(mode & 0x80000000))

#define GenTransferModeMask(i, mode) {\
    ULONG temp=0xffffffff; \
    mode |= (temp >> (31-(i)));\
}

//
// mode should not be 0
//
#define GetHighestTransferMode(mode, i) {\
    ULONG temp=(mode); \
    ASSERT(temp); \
    i=0; \
    while ( temp) { \
        temp = (temp >> 1);\
        i++;\
    } \
    i--; \
}

#define GetHighestDMATransferMode(mode, i) {\
    ULONG temp=mode >> 5;\
    i=5; \
    while ( temp) { \
        temp = (temp >> 1); \
        i++; \
    } \
    i--; \
}
#define GetHighestPIOTransferMode(mode, i) { \
    ULONG temp = (mode & PIO_SUPPORT); \
    i=0; \
    temp = temp >> 1; \
    while (temp) { \
        temp = temp >> 1; \
        i++; \
    } \
}

#define SetDefaultTiming(timingTable, length) {\
    timingTable[0]=PIO_MODE0_CYCLE_TIME; \
    timingTable[1]=PIO_MODE1_CYCLE_TIME; \
    timingTable[2]=PIO_MODE2_CYCLE_TIME; \
    timingTable[3]=PIO_MODE3_CYCLE_TIME; \
    timingTable[4]=PIO_MODE4_CYCLE_TIME; \
    timingTable[5]=SWDMA_MODE0_CYCLE_TIME; \
    timingTable[6]=SWDMA_MODE1_CYCLE_TIME; \
    timingTable[7]=SWDMA_MODE2_CYCLE_TIME; \
    timingTable[8]=MWDMA_MODE0_CYCLE_TIME; \
    timingTable[9]=MWDMA_MODE1_CYCLE_TIME; \
    timingTable[10]=MWDMA_MODE2_CYCLE_TIME; \
    timingTable[11]=UDMA_MODE0_CYCLE_TIME; \
    timingTable[12]=UDMA_MODE1_CYCLE_TIME; \
    timingTable[13]=UDMA_MODE2_CYCLE_TIME; \
    timingTable[14]=UDMA_MODE3_CYCLE_TIME; \
    timingTable[15]=UDMA_MODE4_CYCLE_TIME; \
    timingTable[16]=UDMA_MODE5_CYCLE_TIME; \
    length = MAX_XFER_MODE; \
}

#endif // ___ideuser_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\atapi\wmi.h ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    wmi.h

Abstract:

--*/

#if !defined (___wmi_h___)
#define ___wmi_h___

typedef struct _WMI_SCSI_ADDRESS {

    UCHAR Bus;
    UCHAR Target;
    UCHAR Lun;

} WMI_SCSI_ADDRESS, *PWMI_SCSI_ADDRESS;

VOID
IdePortWmiInit (
    VOID
    );

NTSTATUS
IdePortWmiRegister(
    PDEVICE_EXTENSION_HEADER DoCommonExtension
    );

NTSTATUS
IdePortWmiDeregister(
    PDEVICE_EXTENSION_HEADER DoCommonExtension
    );

NTSTATUS
IdePortWmiSystemControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
DeviceQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    );

NTSTATUS
DeviceQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
DeviceSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
DeviceSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

#endif // ___wmi_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\inc\ide.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    ide.h

Abstract:

    These are the structures and defines that are used in the
    PCI IDE mini drivers.

Revision History:

--*/


#if !defined (___ide_h___)
#define ___ide_h___

#include "ideuser.h"

#define MAX_IDE_DEVICE      2
#define MAX_IDE_LINE        2
#define MAX_IDE_CHANNEL     2

//
// Some miniports need this structure.
// IdentifyData is passed to the miniport in
// the XfermodeSelect structure
// 

//
// IDENTIFY data
//

#pragma pack (1)
typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumCylinders;                    // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumHeads;                        // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT NumSectorsPerTrack;              // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    UCHAR  SerialNumber[20];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    UCHAR  FirmwareRevision[8];             // 2E  23-26
    UCHAR  ModelNumber[40];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:3;        // 6A  53
    USHORT Reserved3:13;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[11];                   //     69-79
    USHORT MajorRevision;                   //     80
    USHORT MinorRevision;                   //     81
    USHORT Reserved6;                       //     82
    USHORT CommandSetSupport;               //     83
    USHORT Reserved6a[2];                   //     84-85
    USHORT CommandSetActive;                //     86
    USHORT Reserved6b;                      //     87
    USHORT UltraDMASupport : 8;             //     88
    USHORT UltraDMAActive  : 8;             //
    USHORT Reserved7[11];                   //     89-99
    ULONG  Max48BitLBA[2];                  //     100-103
    USHORT Reserved7a[22];                  //     104-125
    USHORT LastLun:3;                       //     126
    USHORT Reserved8:13;
    USHORT MediaStatusNotification:2;       //     127
    USHORT Reserved9:6;
    USHORT DeviceWriteProtect:1;
    USHORT Reserved10:7;
    USHORT Reserved11[128];                  //     128-255
} IDENTIFY_DATA, *PIDENTIFY_DATA;

//
// Identify data without the Reserved4.
//

//typedef struct _IDENTIFY_DATA2 {
//    USHORT GeneralConfiguration;            // 00 00
//    USHORT NumCylinders;                    // 02  1
//    USHORT Reserved1;                       // 04  2
//    USHORT NumHeads;                        // 06  3
//    USHORT UnformattedBytesPerTrack;        // 08  4
//    USHORT UnformattedBytesPerSector;       // 0A  5
//    USHORT NumSectorsPerTrack;              // 0C  6
//    USHORT VendorUnique1[3];                // 0E  7-9
//    UCHAR  SerialNumber[20];                // 14  10-19
//    USHORT BufferType;                      // 28  20
//    USHORT BufferSectorSize;                // 2A  21
//    USHORT NumberOfEccBytes;                // 2C  22
//    UCHAR  FirmwareRevision[8];             // 2E  23-26
//    UCHAR  ModelNumber[40];                 // 36  27-46
//    UCHAR  MaximumBlockTransfer;            // 5E  47
//    UCHAR  VendorUnique2;                   // 5F
//    USHORT DoubleWordIo;                    // 60  48
//    USHORT Capabilities;                    // 62  49
//    USHORT Reserved2;                       // 64  50
//    UCHAR  VendorUnique3;                   // 66  51
//    UCHAR  PioCycleTimingMode;              // 67
//    UCHAR  VendorUnique4;                   // 68  52
//    UCHAR  DmaCycleTimingMode;              // 69
//    USHORT TranslationFieldsValid:3;        // 6A  53
//    USHORT Reserved3:13;
//    USHORT NumberOfCurrentCylinders;        // 6C  54
//    USHORT NumberOfCurrentHeads;            // 6E  55
//    USHORT CurrentSectorsPerTrack;          // 70  56
//    ULONG  CurrentSectorCapacity;           // 72  57-58
//    USHORT CurrentMultiSectorSetting;       //     59
//    ULONG  UserAddressableSectors;          //     60-61
//    USHORT SingleWordDMASupport : 8;        //     62
//    USHORT SingleWordDMAActive : 8;
//    USHORT MultiWordDMASupport : 8;         //     63
//    USHORT MultiWordDMAActive : 8;
//    USHORT AdvancedPIOModes : 8;            //     64
//    USHORT Reserved4 : 8;
//    USHORT MinimumMWXferCycleTime;          //     65
//    USHORT RecommendedMWXferCycleTime;      //     66
//    USHORT MinimumPIOCycleTime;             //     67
//    USHORT MinimumPIOCycleTimeIORDY;        //     68
//    USHORT Reserved5[11];                   //     69-79
//    USHORT MajorRevision;                   //     80
//    USHORT MinorRevision;                   //     81
//    USHORT Reserved6[6];                    //     82-87
//    USHORT UltraDMASupport : 8;             //     88
//    USHORT UltraDMAActive  : 8;             //
//    USHORT Reserved7[37];                   //     89-125
//    USHORT LastLun:3;                       //     126
//    USHORT Reserved8:13;
//    USHORT MediaStatusNotification:2;       //     127
//    USHORT Reserved9:6;
//    USHORT DeviceWriteProtect:1;
//    USHORT Reserved10:7;
//} IDENTIFY_DATA2, *PIDENTIFY_DATA2;
#pragma pack ()

#define IDENTIFY_DATA_SIZE sizeof(IDENTIFY_DATA)


//
// The structure is passed to pci ide mini driver
// TransferModeSelect callback for selecting
// proper transfer mode the the devices connected
// to the given IDE channel
//
typedef struct _PCIIDE_TRANSFER_MODE_SELECT {

    //
    // Input Parameters
    //          
          
    //
    // IDE Channel Number.  0 or 1
    //                                       
    ULONG   Channel;

    //
    // Indicate whether devices are present
    //                                  
    BOOLEAN DevicePresent[MAX_IDE_DEVICE * MAX_IDE_LINE];
    
    //
    // Indicate whether devices are ATA harddisk
    //
    BOOLEAN FixedDisk[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicate whether devices support IO Ready Line
    //                                                
    BOOLEAN IoReadySupported[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicate the data transfer modes devices support
    //               
    ULONG DeviceTransferModeSupported[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicate devices' best timings for PIO, single word DMA,
    // multiword DMA, and Ultra DMA modes
    //
    ULONG BestPioCycleTime[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG BestSwDmaCycleTime[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG BestMwDmaCycleTime[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG BestUDmaCycleTime[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicate devices' current data transfer modes
    //
    ULONG DeviceTransferModeCurrent[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // The user's choice. This will allow pciidex to
    // default to a transfer mode indicated by the mini driver
    //
    ULONG UserChoiceTransferMode[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // This enables UDMA66 on the intel chipsets
    //
    ULONG EnableUDMA66;

    //
    //Some miniports need this
    // The miniport will save this data in their deviceExtension
    //
    IDENTIFY_DATA IdentifyData[MAX_IDE_DEVICE];


    //
    // Output Parameters
    //          
                      
    //
    // Indicate devices' data transfer modes chosen by
    // the pcii ide mini drive
    //
    ULONG DeviceTransferModeSelected[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Transfermode timings
    //
    PULONG TransferModeTimingTable;
    ULONG   TransferModeTableLength;

} PCIIDE_TRANSFER_MODE_SELECT, *PPCIIDE_TRANSFER_MODE_SELECT;

//
// possible ide channel state
//         
        
typedef enum {
    ChannelDisabled = 0,
    ChannelEnabled,
    ChannelStateUnknown
} IDE_CHANNEL_STATE;
                         
   
//
// Prototype for different PCI IDE mini driver
// callbacks
//   
typedef IDE_CHANNEL_STATE
    (*PCIIDE_CHANNEL_ENABLED) (
        IN PVOID DeviceExtension,
        IN ULONG Channel
        );

typedef BOOLEAN 
    (*PCIIDE_SYNC_ACCESS_REQUIRED) (
        IN PVOID DeviceExtension
        );

typedef NTSTATUS
    (*PCIIDE_TRANSFER_MODE_SELECT_FUNC) (
        IN     PVOID                     DeviceExtension,
        IN OUT PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect
        );

typedef    ULONG  
    (*PCIIDE_USEDMA_FUNC)(
        IN PVOID deviceExtension, 
        IN PVOID cdbCmd,
        IN UCHAR targetID
        ); 

typedef    NTSTATUS
    (*PCIIDE_UDMA_MODES_SUPPORTED) (
        IDENTIFY_DATA   IdentifyData,
        PULONG          BestXferMode,
        PULONG          CurrentMode
        );
// 
// This structure is for the PCI IDE mini driver to 
// return its properties
// 
typedef struct _IDE_CONTROLLER_PROPERTIES {

    //
    // sizeof (IDE_CONTROLLER_PROPERTIES)
    //
    ULONG Size;      
    
    //
    // Indicate the amount of memory PCI IDE mini driver
    // needs for its private data
    //
    ULONG ExtensionSize;

    //
    // Indicate all the data transfer modes the PCI IDE
    // controller supports
    //                                 
    ULONG SupportedTransferMode[MAX_IDE_CHANNEL][MAX_IDE_DEVICE];

    //
    // callback to query whether a IDE channel is enabled
    //                          
    PCIIDE_CHANNEL_ENABLED      PciIdeChannelEnabled;
    
    //
    // callback to query whether both IDE channels requires
    // synchronized access.  (one channel at a time)
    //                                                              
    PCIIDE_SYNC_ACCESS_REQUIRED PciIdeSyncAccessRequired;
    
    //
    // callback to select proper transfer modes for the
    // given devices
    //
    PCIIDE_TRANSFER_MODE_SELECT_FUNC PciIdeTransferModeSelect;

    //
    // at the end of a ATA data transfer, ignores busmaster 
    // status active bit.  Normally, it should be FALSE
    //                    
    BOOLEAN IgnoreActiveBitForAtaDevice;

    //
    // always clear the busmaster interrupt on every interrupt
    // generated by the device.  Normnally, it should be FALSE
    //
    BOOLEAN AlwaysClearBusMasterInterrupt;

    //
    // callback to determine whether DMA should be used or not
    // called for every IO
    //
    PCIIDE_USEDMA_FUNC PciIdeUseDma;


    //
    // if the miniport needs a different alignment
    //
    ULONG AlignmentRequirement;

    ULONG DefaultPIO;

    //
    // retrieves the supported udma modes from the Identify data
    //
    PCIIDE_UDMA_MODES_SUPPORTED PciIdeUdmaModesSupported;

} IDE_CONTROLLER_PROPERTIES, *PIDE_CONTROLLER_PROPERTIES;

//
// callback to query PCI IDE controller properties
//                            
typedef
NTSTATUS (*PCONTROLLER_PROPERTIES) (
    IN PVOID                      DeviceExtension,
    IN PIDE_CONTROLLER_PROPERTIES ControllerProperties
    );

                     
//
// To initailize PCI IDE mini driver
//                     
NTSTATUS
PciIdeXInitialize(
    IN PDRIVER_OBJECT           DriverObject,
    IN PUNICODE_STRING          RegistryPath,
    IN PCONTROLLER_PROPERTIES   PciIdeGetControllerProperties,
    IN ULONG                    ExtensionSize
    );

//
// To query PCI IDE config space data
//                                    
NTSTATUS
PciIdeXGetBusData(
    IN PVOID DeviceExtension,
    IN PVOID Buffer,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    );

//
// To save PCI IDE config space data
//                                    
NTSTATUS
PciIdeXSetBusData(
    IN PVOID DeviceExtension,
    IN PVOID Buffer,
    IN PVOID DataMask,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    );

                     
#pragma pack(1)
typedef struct _PCIIDE_CONFIG_HEADER {

    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)

    //
    //  Command
    //
    union {

        struct {

            USHORT  IoAccessEnable:1;           // Device control
            USHORT  MemAccessEnable:1;
            USHORT  MasterEnable:1;
            USHORT  SpecialCycle:1;
            USHORT  MemWriteInvalidateEnable:1;
            USHORT  VgaPaletteSnoopEnable:1;
            USHORT  ParityErrorResponse:1;
            USHORT  WaitCycleEnable:1;
            USHORT  SystemErrorEnable:1;
            USHORT  FastBackToBackEnable:1;
            USHORT  CommandReserved:6;
        } b;

        USHORT w;

    } Command;


    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)

    //
    //  Program Interface
    //
    UCHAR   Chan0OpMode:1;
    UCHAR   Chan0Programmable:1;
    UCHAR   Chan1OpMode:1;
    UCHAR   Chan1Programmable:1;
    UCHAR   ProgIfReserved:3;
    UCHAR   MasterIde:1;

    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    struct _PCI_HEADER_TYPE_0 type0;

} PCIIDE_CONFIG_HEADER, *PPCIIDE_CONFIG_HEADER;
#pragma pack()
                     
//
// Debug Print
//                        
#if DBG

VOID
PciIdeXDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define PciIdeXDebugPrint(x)    PciIdeXDebugPrint x
    
#else
    
#define PciIdeXDebugPrint(x)    

#endif // DBG
                     
#endif // ___ide_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\miniport\intel\timing.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       timing.h
//
//--------------------------------------------------------------------------

#if !defined (___timing_h___)
#define ___timing_h___

NTSTATUS
PiixIdeTransferModeSelect (
    IN     PDEVICE_EXTENSION            DeviceExtension,
    IN OUT PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect
    );

NTSTATUS
PiixIdepTransferModeSelect (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect,
    OUT ULONG DriveBestXferMode[MAX_IDE_DEVICE],
    OUT PPIIX_TIMING_REGISTER PiixTimingReg,
    OUT PPIIX3_SLAVE_TIMING_REGISTER PiixSlaveTimingReg,
    OUT PPIIX4_UDMA_CONTROL_REGISTER Piix4UdmaControlReg,
    OUT PPIIX4_UDMA_TIMING_REGISTER Piix4UdmaTimingReg,
    OUT PICH_IO_CONFIG_REGISTER ioConfigReg
    );
                         
#endif // ___timing_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\miniport\intel\intel.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       intel.h
//
//--------------------------------------------------------------------------

#if !defined (___intel_h___)
#define ___intel_h___

#include "stddef.h"
#include "ntddk.h"
#include "ntdddisk.h"
#include "ide.h"

#define INTEL_PCI_VENDOR_ID     ((USHORT)0x8086)
#define PIIX_DEVICE_ID          ((USHORT)0x1230)
#define PIIX3_DEVICE_ID         ((USHORT)0x7010)
#define PIIX4_DEVICE_ID         ((USHORT)0x7111)
#define ICH_DEVICE_ID           ((USHORT)0x2411)
#define ICH0_DEVICE_ID          ((USHORT)0x2421)
#define ICH2_LOWEND_DEVICE_ID   ((USHORT)0x2441)
#define ICH2_MOBILE_DEVICE_ID   ((USHORT)0x244A)
#define ICH2_HIGHEND_DEVICE_ID  ((USHORT)0x244B)
#define ICH3_DEVICE_ID          ((USHORT)0x248A)
#define ICH4_DEVICE_ID_1        ((USHORT)0x24C1)
#define ICH4_DEVICE_ID_2        ((USHORT)0x24CA)
#define ICH4_DEVICE_ID_3        ((USHORT)0x24CB)
#define SINGLE_CHANNEL_IDE_DEVICE_ID      ((USHORT)0x7199)
#define IA64_IDE_CONTROLLER_DEVICE_ID     ((USHORT)0x7601)

#define IS_INTEL(vendorId)                (vendorId == INTEL_PCI_VENDOR_ID)
#define IS_PIIX(deviceId)                 (deviceId == PIIX_DEVICE_ID)
#define IS_PIIX3(deviceId)                (deviceId == PIIX3_DEVICE_ID)
#define IS_PIIX4(deviceId)                (deviceId == PIIX4_DEVICE_ID)
#define IS_ICH_(deviceId)                 (deviceId == ICH_DEVICE_ID)
#define IS_ICH0(deviceId)                 (deviceId == ICH0_DEVICE_ID || deviceId == IA64_IDE_CONTROLLER_DEVICE_ID)
#define IS_ICH2_LOW(deviceId)             (deviceId == ICH2_LOWEND_DEVICE_ID)
#define IS_ICH2_MOBILE(deviceId)          (deviceId == ICH2_MOBILE_DEVICE_ID)
#define IS_ICH2_HIGH(deviceId)            (deviceId == ICH2_HIGHEND_DEVICE_ID)
#define IS_ICH2(deviceId)                 (IS_ICH2_LOW(deviceId) || IS_ICH2_MOBILE(deviceId) || IS_ICH2_HIGH(deviceId))
#define IS_ICH3(deviceId)                 (deviceId == ICH3_DEVICE_ID)
#define IS_ICH4(deviceId)                 ((deviceId == ICH4_DEVICE_ID_1) || (deviceId == ICH4_DEVICE_ID_2) || (deviceId == ICH4_DEVICE_ID_3))
#define IS_SINGLE_IDE(deviceId)           (deviceId == SINGLE_CHANNEL_IDE_DEVICE_ID)

#define IS_UDMA33_CONTROLLER(deviceId)    (IS_PIIX4(deviceId) || IS_ICH0(deviceId) || IS_ICH_(deviceId) || IS_SINGLE_IDE(deviceId) || IS_ICH2(deviceId) || IS_ICH3(deviceId) || IS_ICH4(deviceId))
#define IS_UDMA66_CONTROLLER(deviceId)    (IS_ICH_(deviceId) || IS_ICH2(deviceId) || IS_ICH3(deviceId) || IS_ICH4(deviceId))
#define IS_UDMA100_CONTROLLER(deviceId)   (IS_ICH2_MOBILE(deviceId) || IS_ICH2_HIGH(deviceId) || IS_ICH3(deviceId) || IS_ICH4(deviceId))
#define IS_UDMA_CONTROLLER(deviceId)      (IS_UDMA33_CONTROLLER(deviceId) || IS_UDMA66_CONTROLLER(deviceId) || IS_UDMA100_CONTROLLER(deviceId))

#pragma pack(1)
typedef struct _PIIX_SPECIAL_TIMING_REGISTER {

    union {

        UCHAR AsUChar;

        struct {

            UCHAR FastTimingBankDriveSelect:1;
            UCHAR IoReadySamplePointEnableDriveSelect:1;
            UCHAR PrefetchAndPostingEnable:1;
            UCHAR DmaTimingEnable:1;
        } b;
    };

} PIIX_SPECIAL_TIMING_REGISTER, *PPIIX_SPECIAL_TIMING_REGISTER;

typedef struct _PIIX_TIMING_REGISTER {

    union {

        struct {
            union {
                struct {
        
                    UCHAR Device0SpecialTiming:4;
                    UCHAR Device1SpecialTiming:4;
        
                } n;
        
                struct {
        
                    UCHAR FastTimingBankDriveSelect0:1;
                    UCHAR IoReadySamplePointEnableDriveSelect0:1;
                    UCHAR PrefetchAndPostingEnable0:1;
                    UCHAR DmaTimingEnable0:1;

                    UCHAR FastTimingBankDriveSelect1:1;
                    UCHAR IoReadySamplePointEnableDriveSelect1:1;
                    UCHAR PrefetchAndPostingEnable1:1;
                    UCHAR DmaTimingEnable1:1;
        
                } b;
            };
        
            UCHAR RecoveryTime:2;
            UCHAR Reserved:2;
        
            UCHAR IoReadySamplePoint:2;
            UCHAR SlaveTimingEnable:1;
            UCHAR ChannelEnable:1;
        }b;

        USHORT AsUShort;
    };

} PIIX_TIMING_REGISTER, *PPIIX_TIMING_REGISTER;

typedef struct _PIIX3_SLAVE_TIMING_REGISTER {

    union {

        struct {

            UCHAR Channel0RecoveryTime:2;
            UCHAR Channel0IoReadySamplePoint:2;

            UCHAR Channel1RecoveryTime:2;
            UCHAR Channel1IoReadySamplePoint:2;
        } b;

        UCHAR AsUChar;
    };

} PIIX3_SLAVE_TIMING_REGISTER, *PPIIX3_SLAVE_TIMING_REGISTER;

typedef struct _PIIX4_UDMA_CONTROL_REGISTER {

    union {

        struct {

            UCHAR Channel0Drive0UdmaEnable:1;
            UCHAR Channel0Drive1UdmaEnable:1;
            UCHAR Channel1Drive0UdmaEnable:1;
            UCHAR Channel1Drive1UdmaEnable:1;
            UCHAR Reserved:4;
        } b;

        UCHAR AsUChar;
    };

}PIIX4_UDMA_CONTROL_REGISTER, *PPIIX4_UDMA_CONTROL_REGISTER;

typedef struct _PIIX4_UDMA_TIMING_REGISTER {

    union {
        struct {

            UCHAR Drive0CycleTime:2;
            UCHAR Reserved0:2;
            UCHAR Drive1CycleTime:2;
            UCHAR Reserved1:2;
        } b;

        UCHAR AsUChar;
    };

}PIIX4_UDMA_TIMING_REGISTER, *PPIIX4_UDMA_TIMING_REGISTER;

typedef struct _ICH_IO_CONFIG_REGISTER {

    union {
    
        USHORT AsUShort;                        
        struct {
            USHORT PrimaryMasterBaseClock:1;
            USHORT PrimarySlaveBaseClock:1;
            USHORT SecondaryMasterBaseClock:1;
            USHORT SecondarySlaveBaseClock:1;
            
            USHORT PrimaryMasterCableReady:1;
            USHORT PrimarySlaveCableReady:1;
            USHORT SecondaryMasterCableReady:1;
            USHORT SecondarySlaveCableReady:1;
            
            USHORT Reserved1:2;
            USHORT WriteBufferPingPongEnable:1;
            USHORT Reserved2:1;

            USHORT FastPrimaryMasterBaseClock:1;
            USHORT FastPrimarySlaveBaseClock:1;
            USHORT FastSecondaryMasterBaseClock:1;
            USHORT FastSecondarySlaveBaseClock:1;
/***
            union {
                USHORT Reserved3:4;
                struct {
                    USHORT FastPrimaryMasterBaseClock:1;
                    USHORT FastPrimarySlaveBaseClock:1;
                    USHORT FastSecondaryMasterBaseClock:1;
                    USHORT FastSecondarySlaveBaseClock:1;
                }f;
            };
***/
        } b;
    };                                             // offset 54              
                       
}ICH_IO_CONFIG_REGISTER, *PICH_IO_CONFIG_REGISTER;
       
#define PIIX4_UDMA_MODE2_TIMING      2
#define PIIX4_UDMA_MODE1_TIMING      1
#define PIIX4_UDMA_MODE0_TIMING      0

typedef struct _PIIX4_PCI_CONFIG_DATA {

    PCIIDE_CONFIG_HEADER h;

    PIIX_TIMING_REGISTER Timing[MAX_IDE_CHANNEL];           // offset 40, 41, 42, 43
                                                            
    PIIX3_SLAVE_TIMING_REGISTER SlaveTiming;                // offset 44
                                                            
    UCHAR Reserved0[3];                                     // offset 45, 46, 47
                                                            
    PIIX4_UDMA_CONTROL_REGISTER UdmaControl;                // offset 48
                                                            
    UCHAR Reserved1[1];                                     // offset 49

    PIIX4_UDMA_TIMING_REGISTER UdmaTiming[MAX_IDE_CHANNEL]; // offset 4a, 4b
                        
} PIIX4_PCI_CONFIG_DATA, *PPIIX4_PCI_CONFIG_DATA;
            
#define ICH2_UDMA_MODE5_TIMING      1

#define ICH_UDMA_MODE4_TIMING       2
#define ICH_UDMA_MODE3_TIMING       1
                               
typedef enum {
    NoUdma=0,
    Udma33,
    Udma66,
    Udma100
}CONTROLLER_MODE;

typedef struct _ICH_PCI_CONFIG_DATA {

    PIIX4_PCI_CONFIG_DATA Piix4PciConfigData;                       
                       
    UCHAR Reserved2[8];                                     // offset 4c-53
    
    ICH_IO_CONFIG_REGISTER IoConfig;                        // offset 54
                        
} ICH_PCI_CONFIG_DATA, *PICH_PCI_CONFIG_DATA;
#pragma pack()

typedef struct _DEVICE_EXTENSION {

    USHORT DeviceId;

    ULONG TransferModeSupported[MAX_IDE_CHANNEL][MAX_IDE_DEVICE];
    
    BOOLEAN CableReady[MAX_IDE_CHANNEL][MAX_IDE_DEVICE];
    
    CONTROLLER_MODE  UdmaController; 

    IDENTIFY_DATA IdentifyData[MAX_IDE_DEVICE];

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define PIIX_TIMING_CHANNEL_ENABLE               0x8000
#define PIIX_TIMING_SLAVE_TIMING_ENABLE          0x4000

#define PIIX_TIMING_DMA_TIMING_ENABLE(x)           (x ? 0x0008 : 0)
#define PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(x) (x ? 0x0004 : 0)
#define PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(x) (x ? 0x0002 : 0)
#define PIIX_TIMING_FAST_TIMING_BANK_ENABLE(x)     (x ? 0x0001 : 0)


#define UDMA_MASK(controller, cable, enableUdma66, mask) {\
    switch (controller) { \
        case Udma100:   mask &= 0xffffffff;enableUdma66=1;break; \
        case Udma66:    mask &= 0x0000ffff;break; \
        case Udma33:    mask &= 0x00003fff;break; \
        default:        mask &= 0x000007ff;break; \
    } \
    if (!(cable && enableUdma66)) { \
        mask &= 0x00003fff; \
    } \
}


typedef enum {
    PiixMode_NotPresent = 0,
    PiixMode_Mode0,
    PiixMode_Mode2,
    PiixMode_Mode3,
    PiixMode_Mode4,
    PiixMode_MaxMode
} PIIX_TIMING_MODE;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS 
PiixIdeGetControllerProperties (
    IN PVOID                      DeviceExtension,
    IN PIDE_CONTROLLER_PROPERTIES ControllerProperties
    );

IDE_CHANNEL_STATE 
PiixIdeChannelEnabled (
    IN PVOID DeviceHandle,
    IN ULONG Channel
    );

BOOLEAN 
PiixIdeSyncAccessRequired (
    IN PVOID DeviceHandle
    );

NTSTATUS
PiixIdeTransferModeSelect (
    IN     PDEVICE_EXTENSION            DeviceExtension,
    IN OUT PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect
    );

NTSTATUS
PiixIdeUdmaModesSupported (
    IN IDENTIFY_DATA    IdentifyData,
    IN OUT PULONG       BestXferMode,
    IN OUT PULONG       CurrentMode
    );

#include "timing.h"

#endif // ___intel_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\miniport\intel\init.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       init.c
//
//--------------------------------------------------------------------------

#include "intel.h"


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    return PciIdeXInitialize (
        DriverObject,
        RegistryPath,
        PiixIdeGetControllerProperties,
        sizeof (DEVICE_EXTENSION)
        );
}


//
// Called on every I/O. Returns 1 if DMA is allowed.
// Returns 0 if DMA is not allowed.
//
ULONG
PiixIdeUseDma(
    IN PVOID DeviceExtension,
    IN PVOID cdbcmd,
    IN UCHAR slave)
/**++
 * Arguments : DeviceExtension
               Cdb
               Slave =1, if slave
                     =0, if master
--**/                     
{
    PDEVICE_EXTENSION deviceExtension = DeviceExtension;
    PUCHAR cdb= cdbcmd;

    return 1;
}


NTSTATUS 
PiixIdeGetControllerProperties (
    IN PVOID                      DeviceExtension,
    IN PIDE_CONTROLLER_PROPERTIES ControllerProperties
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceExtension;
    NTSTATUS    status;
    ULONG       i;
    ULONG       j;
    ULONG       mode;
    PCIIDE_CONFIG_HEADER pciData;

    if (ControllerProperties->Size != sizeof (IDE_CONTROLLER_PROPERTIES)) {

        return STATUS_REVISION_MISMATCH;
    }

    status = PciIdeXGetBusData (
                 deviceExtension,
                 &pciData, 
                 0,
                 sizeof (pciData)
                 );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    deviceExtension->DeviceId = pciData.DeviceID;

    if (!IS_INTEL(pciData.VendorID)) {

        return STATUS_UNSUCCESSFUL;
    }

    mode = PIO_SUPPORT;
    deviceExtension->UdmaController = NoUdma;
    if (pciData.MasterIde) {

        mode |= SWDMA_SUPPORT | MWDMA_SUPPORT;

        if (IS_UDMA33_CONTROLLER(pciData.DeviceID)) {
    
            mode |= UDMA33_SUPPORT;
            deviceExtension->UdmaController = Udma33;
            
        }
        
        if (IS_UDMA66_CONTROLLER(pciData.DeviceID)) {
        
            ICH_PCI_CONFIG_DATA ichPciData;
            status = PciIdeXGetBusData (
                         deviceExtension,
                         &ichPciData, 
                         0,
                         sizeof (ichPciData)
                         );
                         
            if (NT_SUCCESS(status)) {
            
                deviceExtension->CableReady[0][0] = (BOOLEAN) ichPciData.IoConfig.b.PrimaryMasterCableReady;
                deviceExtension->CableReady[0][1] = (BOOLEAN) ichPciData.IoConfig.b.PrimarySlaveCableReady;
                deviceExtension->CableReady[1][0] = (BOOLEAN) ichPciData.IoConfig.b.SecondaryMasterCableReady;
                deviceExtension->CableReady[1][1] = (BOOLEAN) ichPciData.IoConfig.b.SecondarySlaveCableReady;
                mode |= UDMA66_SUPPORT;
            }
            
            deviceExtension->UdmaController = Udma66;
        }

        if (IS_UDMA100_CONTROLLER(pciData.DeviceID)) {
        
            ASSERT(IS_UDMA33_CONTROLLER(pciData.DeviceID));
            ASSERT(IS_UDMA66_CONTROLLER(pciData.DeviceID));

            if (NT_SUCCESS(status)) {
                mode |= UDMA100_SUPPORT;
            }
            deviceExtension->UdmaController = Udma100;
        }
    }
    
    for (i=0; i< MAX_IDE_CHANNEL; i++) {

        for (j=0; j< MAX_IDE_DEVICE; j++) {

            ControllerProperties->SupportedTransferMode[i][j] =
                deviceExtension->TransferModeSupported[i][j] = 
                    deviceExtension->TransferModeSupported[i][j] = mode;
        }
    }

    //
    // use this when required
    // if ((pciData.VendorID == 0x8086) && // Intel
    //       (pciData.DeviceID == 0x84c4) && // 82450GX/KX Pentium Pro Processor to PCI bridge
    //       (pciData.RevisionID < 0x4)) {   // Stepping less than 4
    // NO DMA


    ControllerProperties->PciIdeChannelEnabled     = PiixIdeChannelEnabled;
    ControllerProperties->PciIdeSyncAccessRequired = PiixIdeSyncAccessRequired;
    ControllerProperties->PciIdeUseDma = PiixIdeUseDma;
    ControllerProperties->PciIdeUdmaModesSupported = PiixIdeUdmaModesSupported;
    ControllerProperties->AlignmentRequirement=1;
    
#ifdef PIIX_TIMING_REGISTER_SUPPORT
    ControllerProperties->PciIdeTransferModeSelect = PiixIdeTransferModeSelect;
#else    
    ControllerProperties->PciIdeTransferModeSelect = NULL;
#endif 
    

    return STATUS_SUCCESS;
}


IDE_CHANNEL_STATE
PiixIdeChannelEnabled (
    IN PVOID DeviceExtension,
    IN ULONG Channel
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceExtension;
    NTSTATUS status;
    PIIX4_PCI_CONFIG_DATA pciData;

    ASSERT ((Channel & ~1) == 0);

    if (Channel & ~1) {
        return FALSE;
    }

    status = PciIdeXGetBusData (
                 deviceExtension,
                 &pciData.Timing, 
                 FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, Timing),
                 sizeof (pciData.Timing)
                 );

    if (!NT_SUCCESS(status)) {

        //
        // can't tell
        //
        return ChannelStateUnknown;
    }

    return pciData.Timing[Channel].b.ChannelEnable ? ChannelEnabled : ChannelDisabled;
}

BOOLEAN 
PiixIdeSyncAccessRequired (
    IN PVOID DeviceHandle
    )
{
    //
    // Never!
    //
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\inc\idep.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       idep.h
//
//--------------------------------------------------------------------------

#if !defined (___idep_h___)
#define ___idep_h___

#include "ide.h"

#include "wmilib.h"

// go to ntddscsi.h
#define SRB_FUNCTION_ATA_POWER_PASS_THROUGH  0xC7
#define SRB_FUNCTION_ATA_PASS_THROUGH        0xC8

#define ATA_PTFLAGS_BUS_RESET               (1 << 0)
#define ATA_PTFLAGS_OK_TO_FAIL              (1 << 1)
#define ATA_PTFLAGS_EMPTY_CHANNEL_TEST      (1 << 2)
#define ATA_PTFLAGS_INLINE_HARD_RESET       (1 << 3)
#define ATA_PTFLAGS_ENUM_PROBING            (1 << 4)
#define ATA_PTFLAGS_NO_OP                   (1 << 5)
#define ATA_PTFLAGS_STATUS_DRDY_REQUIRED    (1 << 6)
#define ATA_PTFLAGS_URGENT                  (1 << 7)
    
#define MAX_TRANSFER_SIZE_PER_SRB           (0x100 * 0x200)  // 128k ATA limits

typedef struct _ATA_PASS_THROUGH {

    IDEREGS IdeReg;
    ULONG   DataBufferSize;             // byte size of DataBuffer[]
    UCHAR   DataBuffer[1];

}ATA_PASS_THROUGH, *PATA_PASS_THROUGH;
                                                                    
#define NUM_PNP_MINOR_FUNCTION      (0x19)
#define NUM_POWER_MINOR_FUNCTION    (0x04)
#define NUM_WMI_MINOR_FUNCTION      (0xc)
       
#define SAMPLE_CYLINDER_LOW_VALUE       0x55
#define SAMPLE_CYLINDER_HIGH_VALUE      0xaa

//
// Scsiops to suuport dvd operation
// Should go to scsi.h?
//
#if 0
#define SCSIOP_DVD_READ             0xA8
#endif

//
// IDE drive control definitions
//

#define IDE_DC_DISABLE_INTERRUPTS    0x02
#define IDE_DC_RESET_CONTROLLER      0x04
#define IDE_DC_REENABLE_CONTROLLER   0x00

//
// IDE status definitions
//
#define IDE_STATUS_ERROR             0x01
#define IDE_STATUS_INDEX             0x02
#define IDE_STATUS_CORRECTED_ERROR   0x04
#define IDE_STATUS_DRQ               0x08
#define IDE_STATUS_DSC               0x10
#define IDE_STATUS_DRDY              0x40
#define IDE_STATUS_IDLE              0x50
#define IDE_STATUS_BUSY              0x80

#define GetStatus(BaseIoAddress, Status) \
    Status = READ_PORT_UCHAR((BaseIoAddress)->Command);

//
// NEC 98: ide control port.
//
#define CURRENT_INTERRUPT_SENCE (PUCHAR)0x430
#define SELECT_IDE_PORT         (PUCHAR)0x432

//
// NEC 98: dip-switch 2 system port.
//
#define SYSTEM_PORT_A           (PUCHAR)0x31

//
// NEC 98: check enhanced ide support.
//
#define EnhancedIdeSupport() \
    (READ_PORT_UCHAR(CURRENT_INTERRUPT_SENCE)&0x40)?TRUE:FALSE

//
// Checking legacy ide on NEC 98.
//

#ifdef IsNEC_98
#undef IsNEC_98
#endif
#define IsNEC_98 0

#define Is98LegacyIde(BaseIoAddress) \
    (BOOLEAN)(IsNEC_98 && \
             ((BaseIoAddress)->RegistersBaseAddress == \
                        (PUCHAR)IDE_NEC98_COMMAND_PORT_ADDRESS))

//
// Select IDE line(Primary or Secondary).
//    lineNumber:
//        0 - Primary
//        1 - Secondary
//

#define SelectIdeLine(BaseIoAddress,lineNumber) \
{ \
    if (Is98LegacyIde(BaseIoAddress)) { \
        WRITE_PORT_UCHAR (SELECT_IDE_PORT, (UCHAR)((lineNumber) & 0x1)); \
    } \
}

#define SelectIdeDevice(BaseIoAddress, deviceNumber, additional) {\
    SelectIdeLine(BaseIoAddress, (deviceNumber) >>1);\
    WRITE_PORT_UCHAR ((BaseIoAddress)->DriveSelect, (UCHAR)((((deviceNumber) & 0x1) << 4) | 0xA0 | additional));\
    }

#define GetSelectedIdeDevice(BaseIoAddress, cmd) {\
    cmd=READ_PORT_UCHAR((BaseIoAddress)->DriveSelect);\
}

#define ReSelectIdeDevice(BaseIoAddress, cmd) {\
    WRITE_PORT_UCHAR ((BaseIoAddress)->DriveSelect, (UCHAR)cmd);\
}

//
// ISSUE: 08/30/2000 How can I reserve this ioctl value?
//
//#define IOCTL_IDE_BIND_BUSMASTER_PARENT     CTL_CODE(FILE_DEVICE_CONTROLLER, 0x0500, METHOD_BUFFERED, FILE_ANY_ACCESS)
//#define IOCTL_IDE_UNBIND_BUSMASTER_PARENT   CTL_CODE(FILE_DEVICE_CONTROLLER, 0x0502, METHOD_BUFFERED, FILE_ANY_ACCESS)
//#define IOCTL_IDE_GET_SYNC_ACCESS           CTL_CODE(FILE_DEVICE_CONTROLLER, 0x0503, METHOD_BUFFERED, FILE_ANY_ACCESS)
//#define IOCTL_IDE_TRANSFER_MODE_SELECT      CTL_CODE(FILE_DEVICE_CONTROLLER, 0x0504, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IDE_GET_RESOURCES_ALLOCATED   CTL_CODE(FILE_DEVICE_CONTROLLER, 0x0505, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define MAX_IDE_DEVICE      2

#define MAX_IDE_LINE        2

#define MAX_IDE_CHANNEL     2

#define MAX_IDE_BUS         1

#define MAX_IDE_PATH        MAX_IDE_BUS
#define MAX_IDE_TARGETID    MAX_IDE_DEVICE
#define MAX_IDE_LUN         8

#define IDE_STANDARD_PRIMARY_ADDRESS    (0x1f0)
#define IDE_STANDARD_SECONDARY_ADDRESS  (0x170)

#define IDE_NEC98_COMMAND_PORT_ADDRESS  (0x640)

typedef ULONG BMSTATUS;
#define BMSTATUS_NO_ERROR                       (0)
#define BMSTATUS_NOT_REACH_END_OF_TRANSFER      (1 << 0)
#define BMSTATUS_ERROR_TRANSFER                 (1 << 1)
#define BMSTATUS_INTERRUPT                      (1 << 2)
#define BMSTATUS_SUCCESS(x)                     ((x & ~BMSTATUS_INTERRUPT) == 0)


//
// IDE Cycle Timing
//
#define PIO_MODE0_CYCLE_TIME        600
#define PIO_MODE1_CYCLE_TIME        383
#define PIO_MODE2_CYCLE_TIME        240
#define PIO_MODE3_CYCLE_TIME        180
#define PIO_MODE4_CYCLE_TIME        120

#define SWDMA_MODE0_CYCLE_TIME      960
#define SWDMA_MODE1_CYCLE_TIME      480
#define SWDMA_MODE2_CYCLE_TIME      240

#define MWDMA_MODE0_CYCLE_TIME      480
#define MWDMA_MODE1_CYCLE_TIME      150
#define MWDMA_MODE2_CYCLE_TIME      120

#define UDMA_MODE0_CYCLE_TIME       120
#define UDMA_MODE1_CYCLE_TIME       80
#define UDMA_MODE2_CYCLE_TIME       60
#define UDMA_MODE3_CYCLE_TIME       45
#define UDMA_MODE4_CYCLE_TIME       30
#define UDMA_MODE5_CYCLE_TIME       20




typedef union _IDE_PATH_ID {

    struct {

        ULONG Lun:8;
        ULONG TargetId:8;
        ULONG Path:8;
        ULONG Reserved:8;
    } b;

    ULONG l;

} IDE_PATH_ID, *PIDE_PATH_ID;

typedef struct _IDE_REGISTERS_1 {
    PUCHAR RegistersBaseAddress;

    PUSHORT Data;
    PUCHAR Error;
    PUCHAR BlockCount;
    PUCHAR BlockNumber;
    PUCHAR CylinderLow;
    PUCHAR CylinderHigh;
    PUCHAR DriveSelect;
    PUCHAR Command;
} IDE_REGISTERS_1, *PIDE_REGISTERS_1;

typedef struct _IDE_REGISTERS_2 {
    PUCHAR RegistersBaseAddress;

    PUCHAR DeviceControl;
    PUCHAR DriveAddress;
} IDE_REGISTERS_2, *PIDE_REGISTERS_2;


//
// device extension header
//

#define EXTENSION_COMMON_HEADER     PDEVICE_OBJECT   AttacheeDeviceObject; \
                                    PDEVICE_OBJECT   AttacheePdo; \
                                    PDRIVER_OBJECT   DriverObject; \
                                    PDEVICE_OBJECT   DeviceObject; \
                                    ULONG            PagingPathCount;    /* keep track of page path */ \
                                    ULONG            HiberPathCount;     /* keep track of hiber path */ \
                                    ULONG            CrashDumpPathCount; /* keep track of crashdump path */ \
                                    SYSTEM_POWER_STATE SystemPowerState; \
                                    DEVICE_POWER_STATE DevicePowerState; \
                                    WMILIB_CONTEXT     WmiLibInfo; \
                                    PIRP             PendingSystemPowerIrp; /* DEBUG */ \
                                    PIRP             PendingDevicePowerIrp; /* DEBUG */ \
                                    PDRIVER_DISPATCH DefaultDispatch; \
                                    PDRIVER_DISPATCH *PnPDispatchTable; \
                                    PDRIVER_DISPATCH *PowerDispatchTable; \
                                    PDRIVER_DISPATCH *WmiDispatchTable

typedef struct _DEVICE_EXTENSION_HEADER {

    EXTENSION_COMMON_HEADER;

} DEVICE_EXTENSION_HEADER, * PDEVICE_EXTENSION_HEADER;

typedef struct _PCIIDE_BUSMASTER_INTERFACE {

    ULONG Size;

    ULONG SupportedTransferMode[MAX_IDE_DEVICE * MAX_IDE_LINE];

    ULONG MaxTransferByteSize;

    PVOID Context;

    NTSTATUS
    (* BmSetup) (
        IN  PVOID   Context,
        IN  PVOID   DataVirtualAddress,
        IN  ULONG   TransferByteCount,
        IN  PMDL    Mdl,
        IN  BOOLEAN DataIn,
        IN  VOID    (*BmCallback) (PVOID Context),
        IN  PVOID   CallbackContext
        );

    NTSTATUS
    (* BmArm) (
        IN  PVOID   Context
        );

    BMSTATUS
    (* BmDisarm) (
        IN  PVOID   Context
        );

    BMSTATUS
    (* BmFlush) (
        IN  PVOID   Context
        );

    BMSTATUS
    (* BmStatus) (
        IN  PVOID   Context
        );


    NTSTATUS
    (* BmTimingSetup) (
        IN  PVOID   Context
        );

    BOOLEAN IgnoreActiveBitForAtaDevice;

    BOOLEAN AlwaysClearBusMasterInterrupt;

    ULONG ContextSize;

    NTSTATUS
    (* BmSetupOnePage) (
      IN  PVOID   Context,
      IN  PVOID   DataVirtualPageAddress,
      IN  ULONG   TransferByteCount,
      IN  PMDL    Mdl,
      IN  BOOLEAN DataIn,
      IN  PVOID   RegionDescriptorTablePage
      );

    NTSTATUS
    (* BmCrashDumpInitialize) (
        IN PVOID Context
        );
                
    NTSTATUS
    (* BmFlushAdapterBuffers) (
      IN  PVOID   Context,
      IN  PVOID   DataVirtualPageAddress,
      IN  ULONG   TransferByteCount,
      IN  PMDL    Mdl,
      IN  BOOLEAN DataIn
      );

} PCIIDE_BUSMASTER_INTERFACE, * PPCIIDE_BUSMASTER_INTERFACE;

typedef struct _PCIIDE_SYNC_ACCESS_INTERFACE {

    VOID
    (*AllocateAccessToken) (
        PVOID              Token,
        PDRIVER_CONTROL    Callback,
        PVOID              CallbackContext
        );

    VOID
    (*FreeAccessToken) (
        PVOID              Token
        );

    PVOID   Token;

} PCIIDE_SYNC_ACCESS_INTERFACE, *PPCIIDE_SYNC_ACCESS_INTERFACE;

typedef enum PCIIDE_XFER_MODE_SUPPORT_LEVEL {
    PciIdeBasicXferModeSupport,
    PciIdeFullXferModeSupport
} PCIIDE_XFER_MODE_SUPPORT_LEVEL;

typedef struct _PCIIDE_INTERRUPT_INTERFACE {

	NTSTATUS
	(*PciIdeInterruptControl) (
		PVOID Context,
		ULONG Disable
		);

	PVOID Context;

} PCIIDE_INTERRUPT_INTERFACE, *PPCIIDE_INTERRUPT_INTERFACE;

typedef struct _PCIIDE_XFER_MODE_INTERFACE {

    PCIIDE_XFER_MODE_SUPPORT_LEVEL SupportLevel;
    PVOID   VendorSpecificDeviceExtension;

    NTSTATUS
    (*TransferModeSelect) (
        PVOID                        Context,
        PPCIIDE_TRANSFER_MODE_SELECT XferMode
        );


    ULONG
    (*UseDma) (
        PVOID       deviceExtension,
        PVOID       Cdbcmd,
        UCHAR       targetId
        );


    PVOID Context;

    PULONG  TransferModeTimingTable;
    ULONG   TransferModeTableLength;

    NTSTATUS
    (*UdmaModesSupported) (
        IDENTIFY_DATA   IdentifyData,
        PULONG          BestXferMode,
        PULONG          CurrentMode
        );

} PCIIDE_XFER_MODE_INTERFACE, *PPCIIDE_XFER_MODE_INTERFACE;

#define PCIIDE_PROGIF_MASTER_IDE        (1 << 7)


typedef IDE_CHANNEL_STATE
    (*PCIIDE_CHANNEL_ENABLED) (
        IN PVOID DeviceExtension,
        IN ULONG Channel
        );

typedef BOOLEAN 
    (*PCIIDE_SYNC_ACCESS_REQUIRED) (
        IN PVOID DeviceExtension
        );

typedef NTSTATUS
    (*PCIIDE_TRANSFER_MODE_SELECT_FUNC) (
        IN     PVOID                     DeviceExtension,
        IN OUT PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect
        );

typedef VOID
    (*PCIIDE_REQUEST_PROPER_RESOURCES) (
        IN PDEVICE_OBJECT PhysicalDeviceObject
        );

typedef
NTSTATUS (*PCONTROLLER_PROPERTIES) (
    IN PVOID                      DeviceExtension,
    IN PIDE_CONTROLLER_PROPERTIES ControllerProperties
    );

NTSTATUS
PciIdeXInitialize(
    IN PDRIVER_OBJECT           DriverObject,
    IN PUNICODE_STRING          RegistryPath,
    IN PCONTROLLER_PROPERTIES   PciIdeGetControllerProperties,
    IN ULONG                    ExtensionSize
    );


NTSTATUS
PciIdeXGetBusData(
    IN PVOID DeviceExtension,
    IN PVOID Buffer,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    );

NTSTATUS
PciIdeXSetBusData(
    IN PVOID DeviceExtension,
    IN PVOID Buffer,
    IN PVOID DataMask,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    );
                     
NTSTATUS
PciIdeXSaveDeviceParameter (
    IN PVOID DeviceExtension,
    IN PWSTR ParameterName,
    IN ULONG ParameterValue
    );

#if DBG
#define IdePortWaitOnBusyEx(a,b,c) IdePortpWaitOnBusyEx (a,b,c,__FILE__,__LINE__)
#else
#define IdePortWaitOnBusyEx(a,b,c) IdePortpWaitOnBusyEx (a,b,c)
#endif

#ifdef DPC_FOR_EMPTY_CHANNEL
#define IdePortWaitOnBusyExK(CmdRegBase, status, BadStatus) {\
        int ki; \
        for (ki=0; ki<20; ki++) {\
            GetStatus(CmdRegBase, status);\
            if (status == BadStatus) {\
                break;\
            } else if (status & IDE_STATUS_BUSY) {\
                KeStallExecutionProcessor(5);\
                continue;\
            } else {\
                break;\
            }\
        }\
        }
#endif

NTSTATUS
IdePortpWaitOnBusyEx (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN OUT PUCHAR       Status, 
    IN UCHAR            BadStatus
#if DBG
    ,
    IN PCSTR            FileName,
    IN ULONG            LineNumber
#endif 
);

VOID
IdeCreateIdeDirectory(
    VOID
    );


#define DEVICE_OJBECT_BASE_NAME     L"\\Device\\Ide"
                     
#define MEMORY_SPACE    0
#define IO_SPACE        1

#define CLRMASK(x, mask)     ((x) &= ~(mask));
#define SETMASK(x, mask)     ((x) |=  (mask));

#define IS_PDO(doExtension)  (doExtension->AttacheeDeviceObject == NULL)
#define IS_FDO(doExtension)  (doExtension->AttacheeDeviceObject != NULL)

    /* 681190ea-e4ea-11d0-ab82-00a0c906962f */
DEFINE_GUID(GUID_PCIIDE_BUSMASTER_INTERFACE, 0x681190ea, 0xe4ea, 0x11d0, 0xab, 0x82, 0x00, 0xa0, 0xc9, 0x06, 0x96, 0x2f);
    /* 681190eb-e4ea-11d0-ab82-00a0c906962f */
DEFINE_GUID(GUID_PCIIDE_SYNC_ACCESS_INTERFACE, 0x681190eb, 0xe4ea, 0x11d0, 0xab, 0x82, 0x00, 0xa0, 0xc9, 0x06, 0x96, 0x2f);
    /* 681190ec-e4ea-11d0-ab82-00a0c906962f */
DEFINE_GUID(GUID_PCIIDE_XFER_MODE_INTERFACE, 0x681190ec,  0xe4ea, 0x11d0, 0xab, 0x82, 0x00, 0xa0, 0xc9, 0x06, 0x96, 0x2f);
    /* 681190ed-e4ea-11d0-ab82-00a0c906962f */
DEFINE_GUID(GUID_PCIIDE_REQUEST_PROPER_RESOURCES, 0x681190ed, 0xe4ea, 0x11d0, 0xab, 0x82, 0x00, 0xa0, 0xc9, 0x06, 0x96, 0x2f);
    /* 681190ee-e4ea-11d0-ab82-00a0c906962f */
DEFINE_GUID(GUID_PCIIDE_INTERRUPT_INTERFACE, 0x681190ee, 0xe4ea, 0x11d0, 0xab, 0x82, 0x00, 0xa0, 0xc9, 0x06, 0x96, 0x2f);
    /* {14A001C6-F837-4157-BFC9-496F52C18998} */
DEFINE_GUID(INTERFACENAME4, 0x14a001c6, 0xf837, 0x4157, 0xbf, 0xc9, 0x49, 0x6f, 0x52, 0xc1, 0x89, 0x98);

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))
                     
#if !DBG
#define DECLARE_EXTRA_DEBUG_PARAMETER(t, x)   
#else
#define DECLARE_EXTRA_DEBUG_PARAMETER(t, x)    ,t x
#endif //DBG

//
// ATAPI Exports
//
BOOLEAN
IdePortChannelEmpty (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN PIDE_REGISTERS_2 CtrlRegBase,
    IN ULONG            MaxIdeDevice
);

#ifdef DPC_FOR_EMPTY_CHANNEL
ULONG
IdePortChannelEmptyQuick (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN PIDE_REGISTERS_2 CtrlRegBase,
    IN ULONG            MaxIdeDevice,
    PULONG              CurrentIdeDevice,
    PULONG              MoreWait,
    PULONG              NoRetry
);
#endif

typedef struct _IDE_RESOURCE {

    ULONG               CommandBaseAddressSpace;
    ULONG               ControlBaseAddressSpace;
    PUCHAR              TranslatedCommandBaseAddress;
    PUCHAR              TranslatedControlBaseAddress;
    KINTERRUPT_MODE     InterruptMode;
    ULONG               InterruptLevel;

    //
    // Primary and Secondary at disk address (0x1f0 and 0x170) claimed.
    //
    BOOLEAN AtdiskPrimaryClaimed;
    BOOLEAN AtdiskSecondaryClaimed;

} IDE_RESOURCE, *PIDE_RESOURCE;

NTSTATUS
DigestResourceList (
    IN OUT PIDE_RESOURCE                IdeResource,
    IN  PCM_RESOURCE_LIST               ResourceList,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *IrqPartialDescriptors
    );

VOID
AtapiBuildIoAddress (
    IN  PUCHAR            CmdBaseAddress,
    IN  PUCHAR            CtrlBaseAddress,
    OUT PIDE_REGISTERS_1  BaseIoAddress1,
    OUT PIDE_REGISTERS_2  BaseIoAddress2,
    OUT PULONG            BaseIoAddress1Length,
    OUT PULONG            BaseIoAddress2Length,
    OUT PULONG            MaxIdeDevice,
    OUT PULONG            MaxIdeTargetId
);

NTSTATUS
IdeGetDeviceCapabilities(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    );

#if DBG
static PUCHAR IdeDebugPnpIrpName[NUM_PNP_MINOR_FUNCTION] = {
    "IRP_MN_START_DEVICE",
    "IRP_MN_QUERY_REMOVE_DEVICE",
    "IRP_MN_REMOVE_DEVICE",
    "IRP_MN_CANCEL_REMOVE_DEVICE",
    "IRP_MN_STOP_DEVICE",
    "IRP_MN_QUERY_STOP_DEVICE",
    "IRP_MN_CANCEL_STOP_DEVICE",

    "IRP_MN_QUERY_DEVICE_RELATIONS",
    "IRP_MN_QUERY_INTERFACE",
    "IRP_MN_QUERY_CAPABILITIES",
    "IRP_MN_QUERY_RESOURCES",
    "IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
    "IRP_MN_QUERY_DEVICE_TEXT",
    "IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
    "an undefined PnP IRP",
    "IRP_MN_READ_CONFIG",
    "IRP_MN_WRITE_CONFIG",
    "IRP_MN_EJECT",
    "IRP_MN_SET_LOCK",
    "IRP_MN_QUERY_ID",
    "IRP_MN_QUERY_PNP_DEVICE_STATE",
    "IRP_MN_QUERY_BUS_INFORMATION",
    "IRP_MN_DEVICE_USAGE_NOTIFICATION",
    "IRP_MN_SURPRISE_REMOVAL",
    "IRP_MN_QUERY_LEGACY_BUS_INFORMATION"
};
static PUCHAR IdeDebugPowerIrpName[NUM_POWER_MINOR_FUNCTION] = {
    "IRP_MN_WAIT_WAKE",
    "IRP_MN_POWER_SEQUENCE",
    "IRP_MN_SET_POWER",
    "IRP_MN_QUERY_POWER"
};
static PUCHAR IdeDebugWmiIrpName[NUM_WMI_MINOR_FUNCTION] = {
    "IRP_MN_QUERY_ALL_DATA",
    "IRP_MN_QUERY_SINGLE_INSTANCE",
    "IRP_MN_CHANGE_SINGLE_INSTANCE",
    "IRP_MN_CHANGE_SINGLE_ITEM",
    "IRP_MN_ENABLE_EVENTS",
    "IRP_MN_DISABLE_EVENTS",
    "IRP_MN_ENABLE_COLLECTION",
    "IRP_MN_DISABLE_COLLECTION",
    "IRP_MN_REGINFO",
    "IRP_MN_EXECUTE_METHOD"
};
#endif

#endif // ___idep_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\miniport\intel\timing.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       timing.c
//
//--------------------------------------------------------------------------

#include "intel.h"

//
// PiixTiming[Master Timing Mode][Slave Timing Mode]
//    
PIIX_SPECIAL_TIMING_REGISTER PiixSpecialTiming[PiixMode_MaxMode] =
{
    {
    PIIX_TIMING_DMA_TIMING_ENABLE(0) | 
    PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(0) |
    PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(0) |
    PIIX_TIMING_FAST_TIMING_BANK_ENABLE(0)
    },                                                  // not present

    {
    PIIX_TIMING_DMA_TIMING_ENABLE(0) | 
    PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(0) |
    PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(0) |    
    PIIX_TIMING_FAST_TIMING_BANK_ENABLE(0)
    },                                                  // piix timing mode 0

    {
    PIIX_TIMING_DMA_TIMING_ENABLE(0) |
    PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(0) |
    PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(0) |    
    PIIX_TIMING_FAST_TIMING_BANK_ENABLE(1)
    },                                                  // piix timing mode 2

    {
    PIIX_TIMING_DMA_TIMING_ENABLE(0) |
    PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(0) |
    PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(1) |    
    PIIX_TIMING_FAST_TIMING_BANK_ENABLE(1)
    },                                                  // piix timing mode 3

    {
    PIIX_TIMING_DMA_TIMING_ENABLE(0) |
    PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(0) |
    PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(1) |
    PIIX_TIMING_FAST_TIMING_BANK_ENABLE(1)
    }                                                   // piix timing mode 4
};

UCHAR PiixIoReadySamplePointClockSetting[PiixMode_MaxMode] =
{
    0,
    0,
    1,
    2,
    2
};

UCHAR PiixRecoveryTimeClockSetting[PiixMode_MaxMode] =
{
    0,
    0,
    0,
    1,
    3
};

NTSTATUS
PiixIdeUdmaModesSupported (
    IN IDENTIFY_DATA    IdentifyData,
    IN OUT PULONG       BestXferMode,
    IN OUT PULONG       CurrentMode
    )
{
    ULONG bestXferMode =0;
    ULONG currentMode = 0;

    if (IdentifyData.TranslationFieldsValid & (1 << 2)) {

        if (IdentifyData.UltraDMASupport) {

            GetHighestTransferMode( IdentifyData.UltraDMASupport,
                                       bestXferMode);
            *BestXferMode = bestXferMode;
        }

        if (IdentifyData.UltraDMAActive) {

            GetHighestTransferMode( IdentifyData.UltraDMAActive,
                                       currentMode);
            *CurrentMode = currentMode;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PiixIdeTransferModeSelect (
    IN     PDEVICE_EXTENSION            DeviceExtension,
    IN OUT PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect
    )
{
    NTSTATUS status;
    ULONG driveBestXferMode[MAX_IDE_DEVICE];
    PIIX_TIMING_REGISTER piixTimingReg;
    PIIX3_SLAVE_TIMING_REGISTER piixSlaveTimingReg;
    PIIX4_UDMA_CONTROL_REGISTER piix4UdmaControlReg;
    PIIX4_UDMA_TIMING_REGISTER piix4UdmaTimingReg;
    ICH_IO_CONFIG_REGISTER ioConfigReg;
    USHORT dataMask;
    ULONG i;


    //
    // Store the identify data for later use.
    //
    for (i=0;i<MAX_IDE_DEVICE;i++) {
        DeviceExtension->IdentifyData[i]=TransferModeSelect->IdentifyData[i];
    }
    status = PiixIdepTransferModeSelect (
                 DeviceExtension,
                 TransferModeSelect,
                 driveBestXferMode,
                 &piixTimingReg,
                 &piixSlaveTimingReg,
                 &piix4UdmaControlReg,
                 &piix4UdmaTimingReg,
                 &ioConfigReg
                 );

    if (NT_SUCCESS(status)) {

#if DBG

    {
        PIIX_TIMING_REGISTER piixOldTimingReg[2];
        PIIX3_SLAVE_TIMING_REGISTER piixOldSlaveTimingReg;
        PIIX4_UDMA_CONTROL_REGISTER piix4OldUdmaControlReg;
        PIIX4_UDMA_TIMING_REGISTER piix4OldUdmaTimingReg;
        ICH_IO_CONFIG_REGISTER oldIoConfigReg;
        ULONG channel;

#define BitSet(Data, Mask, NewData)     Data = ((Data & ~Mask) | (Mask & NewData));

        piixOldSlaveTimingReg.AsUChar = 0;
        piix4OldUdmaControlReg.AsUChar = 0;
        piix4OldUdmaTimingReg.AsUChar = 0;

        channel = TransferModeSelect->Channel;

        PciIdeXGetBusData (
            DeviceExtension,
            &piixOldTimingReg, 
            FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, Timing),
            sizeof (piixOldTimingReg)
            );

        PciIdeXDebugPrint ((1, 
                     "Old PIIX Timing Register Value (IDETIM = 0x%x", 
                     piixOldTimingReg[channel].AsUShort));

        if (!IS_PIIX(DeviceExtension->DeviceId)) {

            PciIdeXGetBusData (
                DeviceExtension,
                &piixOldSlaveTimingReg, 
                FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, SlaveTiming),
                sizeof (piixOldSlaveTimingReg)
                );

            PciIdeXDebugPrint ((1, 
                         " SIDETIM (0x%x)", 
                         piixOldSlaveTimingReg.AsUChar));
        }

        if (IS_UDMA_CONTROLLER(DeviceExtension->DeviceId)) {

            PciIdeXGetBusData (
                DeviceExtension,
                &piix4OldUdmaControlReg, 
                FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, UdmaControl),
                sizeof (piix4OldUdmaControlReg)
                );

            PciIdeXDebugPrint ((1, 
                         " SDMACTL (0x%x)", 
                         piix4OldUdmaControlReg.AsUChar));

            PciIdeXGetBusData (
                DeviceExtension,
                &piix4OldUdmaTimingReg, 
                FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, UdmaTiming[channel]),
                sizeof (piix4OldUdmaTimingReg)
                );

            PciIdeXDebugPrint ((1, 
                         " SDMATIM (0x%x)", 
                         piix4OldUdmaTimingReg.AsUChar));
        }

        if (IS_ICH_(DeviceExtension->DeviceId) || 
            IS_ICH0(DeviceExtension->DeviceId)) {

            PciIdeXGetBusData (
                DeviceExtension,
                &oldIoConfigReg, 
                FIELD_OFFSET(ICH_PCI_CONFIG_DATA, IoConfig),
                sizeof (oldIoConfigReg)
                );

            PciIdeXDebugPrint ((1, 
                         " I/O Control (0x%x)", 
                         oldIoConfigReg.AsUShort));
        }
                              
        PciIdeXDebugPrint ((1, "\n"));

        if (channel == 0) {

            BitSet (piixOldSlaveTimingReg.AsUChar, 0x0f, piixSlaveTimingReg.AsUChar);
            BitSet (piix4OldUdmaControlReg.AsUChar, 0x03, piix4UdmaControlReg.AsUChar);
                               
        } else {

            BitSet (piixOldSlaveTimingReg.AsUChar, 0xf0, piixSlaveTimingReg.AsUChar);
            BitSet (piix4OldUdmaControlReg.AsUChar, 0x0c, piix4UdmaControlReg.AsUChar);
        }
        BitSet (oldIoConfigReg.AsUShort, 0x0f, ioConfigReg.AsUShort);
                     
        PciIdeXDebugPrint ((1, 
                     "New PIIX/ICH Timing Register Value (IDETIM = 0x%x, SIDETIM (0x%x), SDMACTL (0x%x), SDMATIM (0x%x), IOCTRL (0x%x)\n", 
                     piixTimingReg.AsUShort, 
                     piixOldSlaveTimingReg.AsUChar,
                     piix4OldUdmaControlReg.AsUChar,
                     piix4UdmaTimingReg.AsUChar,
                     oldIoConfigReg.AsUShort
                     ));
    }

#endif // DBG


#ifndef PIIX_TIMING_REGISTER_SUPPORT
    status = STATUS_UNSUCCESSFUL;
    goto GetOut;
#endif 


        dataMask = 0xffff;
        status = PciIdeXSetBusData (
                     DeviceExtension,
                     &piixTimingReg, 
                     &dataMask,
                     FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, Timing) + 
                         sizeof(piixTimingReg) * 
                         TransferModeSelect->Channel,
                     sizeof (piixTimingReg)
                     );
        if (!NT_SUCCESS(status)) {
            goto GetOut;
        }


        if (!IS_PIIX(DeviceExtension->DeviceId)) {

            dataMask = TransferModeSelect->Channel == 0 ? 0x0f : 0xf0;
            status = PciIdeXSetBusData (
                         DeviceExtension,
                         &piixSlaveTimingReg, 
                         &dataMask,
                         FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, SlaveTiming),
                         sizeof (piixSlaveTimingReg)
                         );
    
            if (!NT_SUCCESS(status)) {
    
                ASSERT(!"Unable to set pci config data\n");
                goto GetOut;
            }
        }
        
        if (IS_UDMA_CONTROLLER(DeviceExtension->DeviceId)) {

            //
            // UDMA Control Register
            //
            dataMask = TransferModeSelect->Channel == 0 ? 0x03 : 0x0c;
            status = PciIdeXSetBusData (
                         DeviceExtension,
                         &piix4UdmaControlReg, 
                         &dataMask,
                         FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, UdmaControl),
                         sizeof (piix4UdmaControlReg)
                         );
    
            if (!NT_SUCCESS(status)) {
    
                ASSERT(!"Unable to set pci config data\n");
                goto GetOut;
            }
            
            //
            // UDMA Timing Register
            //
            dataMask = 0xff;
            status = PciIdeXSetBusData (
                         DeviceExtension,
                         &piix4UdmaTimingReg, 
                         &dataMask,
                         FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, UdmaTiming) +
                             sizeof(piix4UdmaTimingReg) * 
                             TransferModeSelect->Channel,
                         sizeof (piix4UdmaTimingReg)
                         );
    
            if (!NT_SUCCESS(status)) {
    
                ASSERT(!"Unable to set pci config data\n");
                goto GetOut;
            }
        }
        
        if (IS_ICH_(DeviceExtension->DeviceId) || 
            IS_ICH0(DeviceExtension->DeviceId) ||
            IS_ICH2(DeviceExtension->DeviceId)) {

            //
            // UDMA Control Register
            //
            dataMask = TransferModeSelect->Channel == 0 ? 0x0403 : 0x040c;
            status = PciIdeXSetBusData (
                         DeviceExtension,
                         &ioConfigReg, 
                         &dataMask,
                         FIELD_OFFSET(ICH_PCI_CONFIG_DATA, IoConfig),
                         sizeof (ioConfigReg)
                         );
    
            if (!NT_SUCCESS(status)) {
    
                ASSERT(!"Unable to set pci config data\n");
                goto GetOut;
            }
        }
    }

GetOut:

    if (NT_SUCCESS(status)) {

        for (i = 0; i < MAX_IDE_DEVICE; i++) {
            TransferModeSelect->DeviceTransferModeSelected[i] = 
                driveBestXferMode[i];
        }
    }

    return status;
}

     
NTSTATUS
PiixIdepTransferModeSelect (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect,
    OUT ULONG DriveBestXferMode[MAX_IDE_DEVICE],
    OUT PPIIX_TIMING_REGISTER PiixTimingReg,
    OUT PPIIX3_SLAVE_TIMING_REGISTER PiixSlaveTimingReg,
    OUT PPIIX4_UDMA_CONTROL_REGISTER Piix4UdmaControlReg,
    OUT PPIIX4_UDMA_TIMING_REGISTER Piix4UdmaTimingReg,
    OUT PICH_IO_CONFIG_REGISTER IoConfigReg
    )
{
    ULONG i;
    ULONG xferMode;
    ULONG channel;
    NTSTATUS status;
    UCHAR ispClockSetting;
    UCHAR recoveryClockSetting;
    PIIX_TIMING_MODE piixTimingMode;
    PIIX_SPECIAL_TIMING_REGISTER piixSpecialTiming;

    ULONG driveBestXferMode[MAX_IDE_DEVICE];
    PIIX_TIMING_REGISTER piixTimingReg;
    PIIX3_SLAVE_TIMING_REGISTER piixSlaveTimingReg;
    PIIX4_UDMA_CONTROL_REGISTER piix4UdmaControlReg;
    PIIX4_UDMA_TIMING_REGISTER piix4UdmaTimingReg;
    ICH_IO_CONFIG_REGISTER ioConfigReg;

    ULONG transferModeSupported;
    PULONG transferModeTimingTable;

    channel = TransferModeSelect->Channel;

    piixTimingReg.AsUShort = 0;
    piixSlaveTimingReg.AsUChar = 0;

    transferModeTimingTable=TransferModeSelect->TransferModeTimingTable;
    ASSERT(transferModeTimingTable);

    for (i = 0; i < MAX_IDE_DEVICE; i++) {

        ULONG enableUdma66 = TransferModeSelect->EnableUDMA66;

        driveBestXferMode[i] = 0;

        if (TransferModeSelect->DevicePresent[i] == FALSE) {

            continue;
        }
#if 1
        //
        // UDMA transfer mode
        //
        transferModeSupported=TransferModeSelect->DeviceTransferModeSupported[i];

        //
        // translate drive reported udma settings to drive's best udma mode
        // UDMA_MASK masks out udma mode >2 if cableReady or enableUdma is not set for a
        // controller that supports modes > udma2. enableUdma flag is ignored for Udma100
        // controllers
        //                                                                               
        UDMA_MASK(DeviceExtension->UdmaController, DeviceExtension->CableReady[channel][i],
                  enableUdma66, transferModeSupported);

        GetHighestDMATransferMode(transferModeSupported, xferMode);


        if (xferMode >= UDMA0) {

            driveBestXferMode[i] = 1 << xferMode;
        }

        //
        // DMA transfer mode
        //

        //
        // Get the highest DMA mode (exclude UDMA)
        //
        transferModeSupported = TransferModeSelect->
                                    DeviceTransferModeSupported[i] & (MWDMA_SUPPORT | SWDMA_SUPPORT);
        GetHighestDMATransferMode(transferModeSupported, xferMode);

        //
        // if xfermode is mwdma2 or 1, select mwdma2 , 1 or swdma2 depending on the cycle time
        //
        if (xferMode >= MWDMA1) {

            while (xferMode >= SWDMA2) {
                //
                // MWDMA0 is not supported
                //
                if (xferMode == MWDMA0) {
                    xferMode--;
                    continue;
                }
                if (TransferModeSelect->BestMwDmaCycleTime[i] <= transferModeTimingTable[xferMode]) {
                    driveBestXferMode[i] |= (1 << xferMode);
                    break;
                }
                xferMode--;
            }

        } else if (xferMode == SWDMA2) {

            if (TransferModeSelect->BestSwDmaCycleTime[i] <= transferModeTimingTable[xferMode]) {

                driveBestXferMode[i] |= SWDMA_MODE2;

            } //else use PIO

        }
        //
        // Don't use SWDMA0 and SWDMA1
        // 

        //
        // PIO transfer mode
        //
        transferModeSupported=TransferModeSelect->DeviceTransferModeSupported[i];
        GetHighestPIOTransferMode(transferModeSupported, xferMode);

        //
        // if PIO2 is the highest PIO mode supported, don't check the
        // bestPIOTiming reported by the device.
        //
        if (xferMode == PIO2) {

            driveBestXferMode[i] |= (1 << xferMode);

        } else {
            //
            // PIO1 is not supported
            //
            while (xferMode > PIO1) {

                if (TransferModeSelect->BestPioCycleTime[i] <= transferModeTimingTable[xferMode]) {

                    driveBestXferMode[i] |= (1 << xferMode);
                    break;

                }
                xferMode--;
            }

            //
            // default to PIO0
            //
            if (xferMode <= PIO1) {
                driveBestXferMode[i] |= (1 << PIO0);
            }
        }

#endif
    }
    //
    // use the slower mode if we have a old piix and two devices on the channel
    // 
    if (IS_PIIX(DeviceExtension->DeviceId)) {

        if (TransferModeSelect->DevicePresent[0] && TransferModeSelect->DevicePresent[1]) {

            ULONG mode;
    
            if ((driveBestXferMode[0] & PIO_SUPPORT) <=
                (driveBestXferMode[1] & PIO_SUPPORT)) {
    
                mode = driveBestXferMode[0] & PIO_SUPPORT;
    
            } else {
    
                mode = driveBestXferMode[1] & PIO_SUPPORT;
            }
    
            if ((driveBestXferMode[0] & SWDMA_SUPPORT) <=
                (driveBestXferMode[1] & SWDMA_SUPPORT)) {
    
                mode |= driveBestXferMode[0] & SWDMA_SUPPORT;
    
            } else {
    
                mode |= driveBestXferMode[1] & SWDMA_SUPPORT;
            }
    
            if ((driveBestXferMode[0] & MWDMA_SUPPORT) <=
                (driveBestXferMode[1] & MWDMA_SUPPORT)) {
    
                mode |= driveBestXferMode[0] & MWDMA_SUPPORT;
    
            } else {
    
                mode |= driveBestXferMode[1] & MWDMA_SUPPORT;
            }
    
            if ((driveBestXferMode[0] & UDMA_SUPPORT) <=
                (driveBestXferMode[1] & UDMA_SUPPORT)) {
    
                mode |= driveBestXferMode[0] & UDMA_SUPPORT;
    
            } else {
    
                mode |= driveBestXferMode[1] & UDMA_SUPPORT;
            }
    
            driveBestXferMode[0] = driveBestXferMode[1] = mode;
        }
    }

    //
    // translate device ATA timing mode to piix timing mode
    //
    for (i = 0; i < MAX_IDE_DEVICE; i++) {

        piixSpecialTiming.AsUChar = 0;

        if (TransferModeSelect->DevicePresent[i] == FALSE) {

            piixTimingMode = PiixMode_NotPresent;

        } else {

            //
            // default
            //
            piixTimingMode = PiixMode_Mode0;

            if (!(driveBestXferMode[i] & DMA_SUPPORT)) {
    
                //
                // pio only device
                //
    
                if (driveBestXferMode[i] & PIO_MODE0) {
    
                    piixTimingMode = PiixMode_Mode0;

                } else if (driveBestXferMode[i] & PIO_MODE2) {

                    piixTimingMode = PiixMode_Mode2;

                    if (TransferModeSelect->IoReadySupported[i]) {

                        piixSpecialTiming.AsUChar |= PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(1);
                    }

                } else if (driveBestXferMode[i] & PIO_MODE3) {

                    piixTimingMode = PiixMode_Mode3;

                } else if (driveBestXferMode[i] & PIO_MODE4) {

                    piixTimingMode = PiixMode_Mode4;

                } else {

                    ASSERT(FALSE);
                }

            } else if (driveBestXferMode[i] & SWDMA_MODE2) {

                piixTimingMode = PiixMode_Mode2;

                if (driveBestXferMode[i] & PIO_MODE0) {

                    piixSpecialTiming.AsUChar |= PIIX_TIMING_DMA_TIMING_ENABLE(1);
                }

                if (TransferModeSelect->IoReadySupported[i]) {

                    piixSpecialTiming.AsUChar |= PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(1);
                }

            } else if (driveBestXferMode[i] & MWDMA_MODE1) {
    
                piixTimingMode = PiixMode_Mode3;

                if (driveBestXferMode[i] & (PIO_MODE0 | PIO_MODE2)) {

                    piixSpecialTiming.AsUChar |= PIIX_TIMING_DMA_TIMING_ENABLE(1);
                }

            } else if (driveBestXferMode[i] & MWDMA_MODE2) {
    
                if (driveBestXferMode[i] & PIO_MODE3) {

                    piixTimingMode = PiixMode_Mode3;

                } else {

                    piixTimingMode = PiixMode_Mode4;
                }

                if (driveBestXferMode[i] & (PIO_MODE0 | PIO_MODE2)) {

                    piixSpecialTiming.AsUChar |= PIIX_TIMING_DMA_TIMING_ENABLE(1);
                }
            }

            if (TransferModeSelect->FixedDisk[i]) {

                piixSpecialTiming.AsUChar |= PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(1);
            }
        }

        piixSpecialTiming.AsUChar |= PiixSpecialTiming[piixTimingMode].AsUChar;

        if (i == 0) {

            //
            // master device
            //
            piixTimingReg.b.IoReadySamplePoint = PiixIoReadySamplePointClockSetting[piixTimingMode];
            piixTimingReg.b.RecoveryTime = PiixRecoveryTimeClockSetting[piixTimingMode];

            piixTimingReg.b.n.Device0SpecialTiming = piixSpecialTiming.AsUChar & 0xf;

        } else {

            //
            // slave device
            //
            if (channel == 0) {

                piixSlaveTimingReg.b.Channel0IoReadySamplePoint = PiixIoReadySamplePointClockSetting[piixTimingMode];
                piixSlaveTimingReg.b.Channel0RecoveryTime = PiixRecoveryTimeClockSetting[piixTimingMode];

            } else {

                piixSlaveTimingReg.b.Channel1IoReadySamplePoint = PiixIoReadySamplePointClockSetting[piixTimingMode];
                piixSlaveTimingReg.b.Channel1RecoveryTime = PiixRecoveryTimeClockSetting[piixTimingMode];
            }

            piixTimingReg.b.n.Device1SpecialTiming = piixSpecialTiming.AsUChar & 0xf;
        }
    }

    if (!IS_PIIX(DeviceExtension->DeviceId)) {

        //
        // enable the timing setting for the slave
        //
        piixTimingReg.b.SlaveTimingEnable = 1;        

    } else {

        piixSlaveTimingReg.AsUChar = 0;
    }

    //
    // make sure the channel is enabled
    //
    piixTimingReg.b.ChannelEnable = 1;

    //
    // setup up udma
    //

    piix4UdmaControlReg.AsUChar = 0;
    piix4UdmaTimingReg.AsUChar = 0;
    ioConfigReg.AsUShort = 0;
    ioConfigReg.b.WriteBufferPingPongEnable = 1;

    for (i = 0; i < MAX_IDE_DEVICE; i++) {

        if (driveBestXferMode[i] & UDMA_SUPPORT) {

            UCHAR udmaTiming;

            if (driveBestXferMode[i] & UDMA_MODE5) {
            
                udmaTiming = ICH2_UDMA_MODE5_TIMING;
                   
            } else if (driveBestXferMode[i] & UDMA_MODE4) {
            
                udmaTiming = ICH_UDMA_MODE4_TIMING;
                   
            } else if (driveBestXferMode[i] & UDMA_MODE3) {
                                         
                udmaTiming = ICH_UDMA_MODE3_TIMING;
                                         
            } else if (driveBestXferMode[i] & UDMA_MODE2) {

                udmaTiming = PIIX4_UDMA_MODE2_TIMING;

            } else if (driveBestXferMode[i] & UDMA_MODE1) {

                udmaTiming = PIIX4_UDMA_MODE1_TIMING;

            } else if (driveBestXferMode[i] & UDMA_MODE0) {

                udmaTiming = PIIX4_UDMA_MODE0_TIMING;

            } else {

                ASSERT (!"intelide: Unknown UDMA MODE\n");
            }

            if (i == 0) {

                if (channel == 0) {
    
                    //
                    // primary master
                    //                                                            
                    piix4UdmaControlReg.b.Channel0Drive0UdmaEnable = 1;

                    if (driveBestXferMode[i] & UDMA66_SUPPORT) {
                    
                        ioConfigReg.b.PrimaryMasterBaseClock = 1;
                    }

                    if (driveBestXferMode[i] & UDMA100_SUPPORT) {
                    
                        ioConfigReg.b.FastPrimaryMasterBaseClock = 1;
                    }

                } else {

                    //
                    // secondary master
                    //                                                            
                    piix4UdmaControlReg.b.Channel1Drive0UdmaEnable = 1;
                    
                    if (driveBestXferMode[i] & UDMA66_SUPPORT) {
                    
                        ioConfigReg.b.SecondaryMasterBaseClock = 1;
                    }

                    if (driveBestXferMode[i] & UDMA100_SUPPORT) {
                    
                        ioConfigReg.b.FastSecondaryMasterBaseClock = 1;
                    }
                }

                piix4UdmaTimingReg.b.Drive0CycleTime = udmaTiming;

            } else {

                ASSERT(i==1);

                if (channel == 0) {
    
                    //
                    // primary slave
                    //                                                    
                    piix4UdmaControlReg.b.Channel0Drive1UdmaEnable = 1;

                    if (driveBestXferMode[i] & UDMA66_SUPPORT) {
                    
                        ioConfigReg.b.PrimarySlaveBaseClock = 1;
                    }

                    if (driveBestXferMode[i] & UDMA100_SUPPORT) {
                    
                        ioConfigReg.b.FastPrimarySlaveBaseClock = 1;
                    }
                                               
                } else {

                    //
                    // secondary slave
                    //                                                    
                    piix4UdmaControlReg.b.Channel1Drive1UdmaEnable = 1;
                    
                    if (driveBestXferMode[i] & UDMA66_SUPPORT) {
                    
                        ioConfigReg.b.SecondarySlaveBaseClock = 1;
                    }
                    if (driveBestXferMode[i] & UDMA100_SUPPORT) {
                    
                        ioConfigReg.b.FastSecondarySlaveBaseClock = 1;
                    }
                }

                piix4UdmaTimingReg.b.Drive1CycleTime = udmaTiming;
            }

            //
            // if the drive support UDMA, use UDMA
            // turn off other DMA mode
            //
            driveBestXferMode[i] &= ~(MWDMA_SUPPORT | SWDMA_SUPPORT);
        }
    }

    //
    // setup the return data
    //
    for (i = 0; i < MAX_IDE_DEVICE; i++) {
        DriveBestXferMode[i] = driveBestXferMode[i];
    }

    *PiixTimingReg       = piixTimingReg;
    *PiixSlaveTimingReg  = piixSlaveTimingReg;
    *Piix4UdmaControlReg = piix4UdmaControlReg;
    *Piix4UdmaTimingReg  = piix4UdmaTimingReg;
    *IoConfigReg         = ioConfigReg;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\miniport\pciide\pciide.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    init.c

Abstract:

    Generic PCI IDE mini driver

Revision History:

--*/
#if !defined (___pciide_h___)
#define ___pciide_h___

#include "ntddk.h"
#include "ntdddisk.h"
#include "ide.h"
      

//
// mini driver device extension
//
typedef struct _DEVICE_EXTENSION {

    //
    // pci config data cache
    //                               
    PCIIDE_CONFIG_HEADER pciConfigData;

    //
    // supported data transfer mode
    //                            
    ULONG SupportedTransferMode[MAX_IDE_CHANNEL][MAX_IDE_DEVICE];

    IDENTIFY_DATA IdentifyData[MAX_IDE_DEVICE];

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


#pragma pack(1)
typedef struct _VENDOR_ID_DEVICE_ID {

    USHORT  VendorId;
    USHORT  DeviceId;

} VENDOR_ID_DEVICE_ID, *PVENDOR_ID_DEVICE_ID;
#pragma pack()

//
// mini driver entry point
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

//
// callback to query controller properties
//                          
NTSTATUS 
GenericIdeGetControllerProperties (
    IN PVOID                      DeviceExtension,
    IN PIDE_CONTROLLER_PROPERTIES ControllerProperties
    );

//
// to query whether a IDE channel is enabled
//                                          
IDE_CHANNEL_STATE 
GenericIdeChannelEnabled (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG Channel
    );
             
//
// to query whether both IDE channels requires
// synchronized access
//                                          
BOOLEAN 
GenericIdeSyncAccessRequired (
    IN PDEVICE_EXTENSION DeviceExtension
    );

//
// to query the supported UDMA modes. This routine
// can be used to support newer UDMA modes
//
NTSTATUS
GenericIdeUdmaModesSupported (
    IN IDENTIFY_DATA    IdentifyData,
    IN OUT PULONG       BestXferMode,
    IN OUT PULONG       CurrentMode
    );
#endif // ___pciide_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\pciidex\bm.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bm.c
//
//--------------------------------------------------------------------------

#include "pciidex.h"

NTSTATUS
BmSetupOnePage (
    IN  PVOID   PdoExtension,
    IN  PVOID   DataVirtualPageAddress,
    IN  ULONG   TransferByteCount,
    IN  PMDL    Mdl,
    IN  BOOLEAN DataIn,
    IN  PVOID   RegionDescriptorTablePage
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BusMasterInitialize)
#pragma alloc_text(PAGE, BmQueryInterface)

#pragma alloc_text(NONPAGE, BmSetup)
#pragma alloc_text(NONPAGE, BmReceiveScatterGatherList)
#pragma alloc_text(NONPAGE, BmRebuildScatterGatherList)
#pragma alloc_text(NONPAGE, BmPrepareController)
#pragma alloc_text(NONPAGE, BmSetupOnePage)
#pragma alloc_text(NONPAGE, BmArm)
#pragma alloc_text(NONPAGE, BmDisarm)
#pragma alloc_text(NONPAGE, BmFlush)
#pragma alloc_text(NONPAGE, BmStatus)
#pragma alloc_text(NONPAGE, BmTimingSetup)
#endif // ALLOC_PRAGMA


NTSTATUS 
BusMasterInitialize (
    PCHANPDO_EXTENSION PdoExtension
    )
{
    NTSTATUS status;
    ULONG    numberOfMapRegisters;
    ULONG    scatterListSize;
    BOOLEAN  noBmRegister;

    PAGED_CODE();

    if (PdoExtension->ParentDeviceExtension->TranslatedBusMasterBaseAddress == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        noBmRegister = TRUE;

    } else {

        if (PdoExtension->ChannelNumber == 0) {

            PdoExtension->BmRegister = 
                PdoExtension->ParentDeviceExtension->TranslatedBusMasterBaseAddress;

        } else if (PdoExtension->ChannelNumber == 1) {

            PdoExtension->BmRegister = 
                (PIDE_BUS_MASTER_REGISTERS)
                (((PUCHAR) PdoExtension->ParentDeviceExtension->TranslatedBusMasterBaseAddress) + 8);
        } else {

            ASSERT (FALSE);
        }

        if (READ_PORT_UCHAR (&PdoExtension->BmRegister->Status) & BUSMASTER_ZERO_BITS) {

            //
            // The must-be-zero bits are not zero
            //
            DebugPrint ((0, "BusMasterInitialize: bad busmaster status register value (0x%x).  will never do busmastering ide\n"));
            PdoExtension->BmRegister = NULL;
            status = STATUS_INSUFFICIENT_RESOURCES;
            noBmRegister = TRUE;

        } else {

            status = STATUS_SUCCESS;
            noBmRegister = FALSE;
        }
    }

    //
    // Allocate Adapter Object
    //
    if (status == STATUS_SUCCESS) {

        DEVICE_DESCRIPTION deviceDescription;

        RtlZeroMemory(&deviceDescription, sizeof(deviceDescription));

        deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
        deviceDescription.Master = TRUE;
        deviceDescription.ScatterGather = TRUE;
        deviceDescription.DemandMode = FALSE;
        deviceDescription.AutoInitialize = FALSE;
        deviceDescription.Dma32BitAddresses = TRUE;
        deviceDescription.IgnoreCount = FALSE;
        deviceDescription.BusNumber = PdoExtension->ParentDeviceExtension->BmResourceList->List[0].BusNumber,
        deviceDescription.InterfaceType = PCIBus;


        //
        //  make sure MAX_TRANSFER_SIZE_PER_SRB is never larger than what
        //  the ide bus master controller can handle
        //
        ASSERT (MAX_TRANSFER_SIZE_PER_SRB <= (PAGE_SIZE * (PAGE_SIZE / sizeof(PHYSICAL_REGION_DESCRIPTOR))));
        deviceDescription.MaximumLength = MAX_TRANSFER_SIZE_PER_SRB;

        PdoExtension->DmaAdapterObject = IoGetDmaAdapter(
                                             PdoExtension->ParentDeviceExtension->AttacheePdo,
                                             &deviceDescription,
                                             &numberOfMapRegisters
                                             );

        ASSERT(PdoExtension->DmaAdapterObject);

        PdoExtension->MaximumPhysicalPages = numberOfMapRegisters;

        if (!PdoExtension->DmaAdapterObject) {

            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (status == STATUS_SUCCESS) {

        scatterListSize = PdoExtension->MaximumPhysicalPages * 
                              sizeof (PHYSICAL_REGION_DESCRIPTOR);

        PdoExtension->RegionDescriptorTable = 
            PdoExtension->DmaAdapterObject->DmaOperations->AllocateCommonBuffer(
                PdoExtension->DmaAdapterObject,
                scatterListSize,
                &PdoExtension->PhysicalRegionDescriptorTable,
                FALSE
                );

        ASSERT (PdoExtension->RegionDescriptorTable);
        ASSERT (PdoExtension->PhysicalRegionDescriptorTable.QuadPart);

        if (PdoExtension->RegionDescriptorTable) {

            RtlZeroMemory (
                PdoExtension->RegionDescriptorTable, 
                scatterListSize
                );

        } else {

            status = STATUS_INSUFFICIENT_RESOURCES;

        }
    }

    if (status != STATUS_SUCCESS) {

        //
        // free resources
        //
        if (PdoExtension->RegionDescriptorTable) {

                PdoExtension->DmaAdapterObject->DmaOperations->FreeCommonBuffer(
                    PdoExtension->DmaAdapterObject,
                    scatterListSize,
                    PdoExtension->PhysicalRegionDescriptorTable,
                    PdoExtension->RegionDescriptorTable,
                    FALSE
                    );
            PdoExtension->PhysicalRegionDescriptorTable.QuadPart = 0;
            PdoExtension->RegionDescriptorTable                  = NULL;
        }

        if (PdoExtension->DmaAdapterObject) {
            KIRQL currentIrql;

            KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);
            PdoExtension->DmaAdapterObject->DmaOperations->PutDmaAdapter (
                PdoExtension->DmaAdapterObject
                );
            KeLowerIrql(currentIrql);

            PdoExtension->DmaAdapterObject = NULL;
        }
    }

    //
    // init. is still ok if we just not a bm controller
    //
    if (noBmRegister) {

        status = STATUS_SUCCESS;
    }

    return status;
} // BusMasterInitialize

NTSTATUS 
BusMasterUninitialize (
    PCHANPDO_EXTENSION PdoExtension
    )
{
    ULONG scatterListSize;
    KIRQL currentIrql;
    ASSERT (PdoExtension->BmState == BmIdle);

    if (PdoExtension->DmaAdapterObject) {

        scatterListSize = PdoExtension->MaximumPhysicalPages * 
                              sizeof (PHYSICAL_REGION_DESCRIPTOR);
    
        if (PdoExtension->PhysicalRegionDescriptorTable.QuadPart) {

            PdoExtension->DmaAdapterObject->DmaOperations->FreeCommonBuffer( 
                PdoExtension->DmaAdapterObject,
                scatterListSize,
                PdoExtension->PhysicalRegionDescriptorTable,
                PdoExtension->RegionDescriptorTable,
                FALSE
                );
            PdoExtension->RegionDescriptorTable = NULL;
            PdoExtension->PhysicalRegionDescriptorTable.QuadPart = 0;
        }
        

        KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);
        PdoExtension->DmaAdapterObject->DmaOperations->PutDmaAdapter (
            PdoExtension->DmaAdapterObject
            );
        KeLowerIrql(currentIrql);

        PdoExtension->DmaAdapterObject = NULL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
BmSetup (
    IN  PVOID   PdoExtension,
    IN  PVOID   DataVirtualAddress,
    IN  ULONG   TransferByteCount,
    IN  PMDL    Mdl,
    IN  BOOLEAN DataIn,
    IN  VOID    (* BmCallback) (PVOID Context),
    IN  PVOID   CallbackContext
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    NTSTATUS status;
    PIDE_BUS_MASTER_REGISTERS bmRegister;

    ASSERT (pdoExtension->BmState == BmIdle);

    bmRegister = pdoExtension->BmRegister;

    pdoExtension->DataVirtualAddress = DataVirtualAddress;
    pdoExtension->TransferLength     = TransferByteCount;
    pdoExtension->Mdl                = Mdl;
    pdoExtension->DataIn             = DataIn;
    pdoExtension->BmCallback         = BmCallback;
    pdoExtension->BmCallbackContext  = CallbackContext;

    status = (*pdoExtension->DmaAdapterObject->DmaOperations->GetScatterGatherList)(
        pdoExtension->DmaAdapterObject,
        pdoExtension->DeviceObject,
        pdoExtension->Mdl,
        pdoExtension->DataVirtualAddress,
        pdoExtension->TransferLength,
        BmReceiveScatterGatherList,
        pdoExtension,
        (BOOLEAN) !pdoExtension->DataIn
        );

    return status;
} // BmSetup

VOID
BmReceiveScatterGatherList(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    )
{
    PCHANPDO_EXTENSION pdoExtension = Context;
    ASSERT (pdoExtension);

    BmRebuildScatterGatherList (pdoExtension, ScatterGather);

    BmPrepareController (pdoExtension);

    //
    // Call the FDO back
    //
    pdoExtension->BmCallback (pdoExtension->BmCallbackContext);

    return;
} // BmReceiveScatterGatherList


VOID
BmRebuildScatterGatherList(
    IN PCHANPDO_EXTENSION PdoExtension,
    IN PSCATTER_GATHER_LIST ScatterGather
    )
{
    ULONG   bytesToMap;
    ULONG   i, j;

    ASSERT (ScatterGather);
    ASSERT (PdoExtension);
    ASSERT (PdoExtension->TransferLength);
    ASSERT (PdoExtension->Mdl);

    DebugPrint ((3, "PciIdeX: BmReceiveScatterGatherList() DataBuffer 0x%x, length 0x%x\n", PdoExtension->DataVirtualAddress, PdoExtension->TransferLength));

    //
    // save the original list
    //
    PdoExtension->HalScatterGatherList = ScatterGather;

    for (i=j=0; j<ScatterGather->NumberOfElements; j++) {

        ULONG   physicalAddress;
        PSCATTER_GATHER_ELEMENT sgElements;

        sgElements = ScatterGather->Elements + j;

        //
        // get the next block physical address
        //
        physicalAddress = sgElements->Address.LowPart;
        ASSERT (!(physicalAddress & 0x1));
        ASSERT (!sgElements->Address.HighPart);

        //
        // get the next block byte size
        //
        bytesToMap = sgElements->Length;

        while (bytesToMap) {

            ULONG   bytesLeftInCurrent64KPage;

            ASSERT (i < PdoExtension->MaximumPhysicalPages);

            PdoExtension->RegionDescriptorTable[i].PhysicalAddress = physicalAddress;
            bytesLeftInCurrent64KPage = 0x10000 - (physicalAddress & 0xffff);
    
            if (bytesLeftInCurrent64KPage < bytesToMap) {
    
                PdoExtension->RegionDescriptorTable[i].ByteCount = bytesLeftInCurrent64KPage;

                physicalAddress += bytesLeftInCurrent64KPage;
                bytesToMap -= bytesLeftInCurrent64KPage;
    
            } else if (bytesToMap <= 0x10000) {
                //
                // got a perfect page, map all of it
                //
                PdoExtension->RegionDescriptorTable[i].ByteCount = bytesToMap & 0xfffe;
                physicalAddress += bytesToMap & 0xfffe;
                bytesToMap = 0;

            } else {
                //
                // got a perfectly aligned 64k page, map all of it but the count
                // need to be 0
                //
                PdoExtension->RegionDescriptorTable[i].ByteCount = 0;  // 64K
                physicalAddress += 0x10000;
                bytesToMap -= 0x10000;
            }

            PdoExtension->RegionDescriptorTable[i].EndOfTable = 0;
            i++;
        }
    }

    //
    // the bus master circutry need to know it hits the end of the PRDT
    //
    PdoExtension->RegionDescriptorTable[i - 1].EndOfTable = 1;  // end of table

    return;
} // BmReceiveScatterGatherList

VOID
BmPrepareController (
    PCHANPDO_EXTENSION PdoExtension
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    PIDE_BUS_MASTER_REGISTERS bmRegister;

    KeFlushIoBuffers(pdoExtension->Mdl,
                     (BOOLEAN) (pdoExtension->DataIn),
                     TRUE);

    bmRegister = pdoExtension->BmRegister;

    //
    // Init bus master contoller, but keep it disabled
    //

    //
    // Disable Controller
    //
    WRITE_PORT_UCHAR (
        &bmRegister->Command, 
        0
        );

    //
    // Clear Errors
    //
    WRITE_PORT_UCHAR (
        &bmRegister->Status, 
        BUSMASTER_INTERRUPT | BUSMASTER_ERROR
        );

    //
    // Init. Scatter Gather List Register
    //
    WRITE_PORT_ULONG (
        &bmRegister->DescriptionTable, 
        PdoExtension->PhysicalRegionDescriptorTable.LowPart
        );

    pdoExtension->BmState = BmSet;

    return;
} // BmPrepareController



NTSTATUS
BmSetupOnePage (
    IN  PVOID   PdoExtension,
    IN  PVOID   DataVirtualPageAddress,
    IN  ULONG   TransferByteCount,
    IN  PMDL    Mdl,
    IN  BOOLEAN DataIn,
    IN  PVOID   RegionDescriptorTablePage
    )
/*++

Routine Description:

    Does the same thing as BmSetup except that it sets up DMA controller
    for one page only and therefore it simple and straightforward and
    does not use any of kernel services unlike BmSetup.

Arguments:
    
    PdoExtension          - context pointer
    DataVirtualPageAddress- address of IO page
    TransferByteCount     - size of IO (IO region shall not cross page boundary)
    Mdl                   - MDL descriptor containing DataVirtualAddress
    DataIn                - TRUE if input, FALSE if output
    RegionDescriptorTable - memory to store 1 entry of RegionDescriptor (shall be page-aligned)

Attention! Obviousely, it's caller responsibility to retain the values addressed
by DataMemoryAddress and RegionDescriptor table until completion of DMA transfer

Return Value:

    STATUS_SUCCESS if all conditions listed above were met,
    STATUS_UNSUCCESSFUL otherwise

Environment:

    Kernel mode.  Currently used by only by ATAPI during hibernation.


--*/
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    PPHYSICAL_REGION_DESCRIPTOR RegionDescriptorTable = RegionDescriptorTablePage;
    PHYSICAL_ADDRESS OldPhysicalRegionDescriptorTable;
    PPHYSICAL_REGION_DESCRIPTOR OldRegionDescriptorTable;
    PHYSICAL_ADDRESS DataPhysicalPageAddress;
    ULONG Size;

    //
    // Check alignment of addresses and transfer size
    //
    Size = PAGE_SIZE - ((ULONG) (((ULONG_PTR) DataVirtualPageAddress) & (PAGE_SIZE-1)));
    if (
      TransferByteCount == 0 ||
      TransferByteCount > Size ||
      ((ULONG) ((ULONG_PTR)DataVirtualPageAddress | TransferByteCount) & 3) != 0 ||
      ((ULONG) (((ULONG_PTR)RegionDescriptorTablePage) & (PAGE_SIZE-1)))
    )
    {
      // Necessary requirements was not met, failure
      return (STATUS_UNSUCCESSFUL);
    }

    //
    // Initialize descriptor table
    //
    DataPhysicalPageAddress =(*pdoExtension->DmaAdapterObject->DmaOperations->MapTransfer)(
                                            (pdoExtension->DmaAdapterObject), 
                                             Mdl, 
                                             pdoExtension->MapRegisterBase, 
                                             DataVirtualPageAddress,
                                             &TransferByteCount, 
                                             !DataIn 
                                             );

    //DataPhysicalPageAddress = MmGetPhysicalAddress (DataVirtualPageAddress);
    RegionDescriptorTable[0].PhysicalAddress = DataPhysicalPageAddress.LowPart;
    RegionDescriptorTable[0].ByteCount  = TransferByteCount;
    RegionDescriptorTable[0].EndOfTable = 1;


    //
    // Preserve existing data table from context
    //
    OldPhysicalRegionDescriptorTable = pdoExtension->PhysicalRegionDescriptorTable;
    OldRegionDescriptorTable         = pdoExtension->RegionDescriptorTable;

    //
    // Set up IO request parameters
    //
    pdoExtension->PhysicalRegionDescriptorTable = MmGetPhysicalAddress (RegionDescriptorTable);
    pdoExtension->RegionDescriptorTable         = RegionDescriptorTable;
    pdoExtension->Mdl                           = Mdl;
    pdoExtension->DataIn                        = DataIn;

    //
    // Setup controller
    //
    BmPrepareController (pdoExtension);

    //
    // Restore original table values
    //
    pdoExtension->PhysicalRegionDescriptorTable = OldPhysicalRegionDescriptorTable;
    pdoExtension->RegionDescriptorTable         = OldRegionDescriptorTable;

    //
    // Done
    //
    return (STATUS_SUCCESS);
}


NTSTATUS
BmArm (
    IN  PVOID   PdoExtension
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    PIDE_BUS_MASTER_REGISTERS bmRegister;
    UCHAR bmStatus;

    ASSERT ((pdoExtension->BmState == BmSet) || (pdoExtension->BmState == BmDisarmed));

    bmRegister = pdoExtension->BmRegister;

//    if (Device == 0)
//        bmStatus = BUSMASTER_DEVICE0_DMA_OK;
//    else
//        bmStatus = BUSMASTER_DEVICE1_DMA_OK;

    //
    // clear the status bit
    //
    bmStatus = BUSMASTER_INTERRUPT | BUSMASTER_ERROR;

    WRITE_PORT_UCHAR (&bmRegister->Status, bmStatus);

    //
    // on your mark...get set...go!!
    //
#if !defined (FAKE_BAD_IDE_DMA_DEVICE)
    if (pdoExtension->DataIn) {
        WRITE_PORT_UCHAR (&bmRegister->Command, 0x09);  // enable BM read
    } else {
        WRITE_PORT_UCHAR (&bmRegister->Command, 0x01);  // enable BM write
    }
#endif // !FAKE_BAD_IDE_DMA_DEVICE

    pdoExtension->BmState = BmArmed;

    DebugPrint ((3, "PciIde: BmArm()\n"));

    return STATUS_SUCCESS;
} // BmArm

BMSTATUS
BmDisarm (
    IN  PVOID    PdoExtension
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    PIDE_BUS_MASTER_REGISTERS bmRegister = pdoExtension->BmRegister;
    BMSTATUS bmStatus;

    bmStatus = BmStatus (PdoExtension);

    WRITE_PORT_UCHAR (&bmRegister->Command, 0x0);  // disable BM
    WRITE_PORT_UCHAR (&bmRegister->Status, BUSMASTER_INTERRUPT);  // clear interrupt BM

    if (pdoExtension->BmState != BmIdle) {

        pdoExtension->BmState = BmDisarmed;

    }

    if (bmStatus) {

        DebugPrint ((1, "PciIdeX: BM 0x%x status = 0x%x\n", bmRegister, bmStatus));
    }

    return bmStatus;
} // BmDisarm


BMSTATUS
BmFlush (
    IN  PVOID   PdoExtension
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;

    ASSERT (pdoExtension->BmState != BmArmed);

    (*pdoExtension->DmaAdapterObject->DmaOperations->PutScatterGatherList)(
                          pdoExtension->DmaAdapterObject,
                          pdoExtension->HalScatterGatherList,
                          (BOOLEAN)(!pdoExtension->DataIn));

    pdoExtension->HalScatterGatherList  = NULL;
    pdoExtension->DataVirtualAddress    = NULL;
    pdoExtension->TransferLength        = 0;
    pdoExtension->Mdl                   = NULL;

    pdoExtension->BmState = BmIdle;

    DebugPrint ((3, "PciIde: BmFlush()\n"));

    return STATUS_SUCCESS;
} // BmFlush


BMSTATUS
BmStatus (
    IN  PVOID    PdoExtension
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    PIDE_BUS_MASTER_REGISTERS bmRegister;
    BMSTATUS bmStatus;
    UCHAR    bmRawStatus;

    bmRegister = pdoExtension->BmRegister;

    bmRawStatus = READ_PORT_UCHAR (&bmRegister->Status);

    bmStatus = 0;

    //
    // if we get back 0xff from the port, then the decodes
    // are probably not enabled (or the device is powered down). return 0.
    //
    if (bmRawStatus == 0xff) {
        return bmStatus;
    }

    if (bmRawStatus & BUSMASTER_ACTIVE) {

        bmStatus |= BMSTATUS_NOT_REACH_END_OF_TRANSFER;
    }

    if (bmRawStatus & BUSMASTER_ERROR) {
        bmStatus |= BMSTATUS_ERROR_TRANSFER;
    }

    if (bmRawStatus & BUSMASTER_INTERRUPT) {
        bmStatus |= BMSTATUS_INTERRUPT;
    }

    return bmStatus;
} // BmStatus

NTSTATUS
BmTimingSetup (
    IN  PVOID    PdoExtension
    )
{
    return STATUS_SUCCESS;
} // BmTimingSetup

NTSTATUS
BmCrashDumpInitialize (
    IN  PVOID    PdoExtension
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    ULONG nMapRegisters = pdoExtension->MaximumPhysicalPages-1;
    if (pdoExtension->DmaAdapterObject != NULL) {
        pdoExtension->MapRegisterBase = HalAllocateCrashDumpRegisters((PADAPTER_OBJECT)pdoExtension->DmaAdapterObject, 
                                                                      &nMapRegisters
                                                                      );
    }
    return STATUS_SUCCESS;
}

NTSTATUS 
BmQueryInterface (
    IN PCHANPDO_EXTENSION PdoExtension,
    IN OUT PPCIIDE_BUSMASTER_INTERFACE BusMasterInterface
    )
{
    PCTRLFDO_EXTENSION fdoExtension = PdoExtension->ParentDeviceExtension;

    PAGED_CODE();

    if (PdoExtension->BmRegister) {

        BusMasterInterface->Size = sizeof(PCIIDE_BUSMASTER_INTERFACE);

        BusMasterInterface->SupportedTransferMode[0] = 
            fdoExtension->ControllerProperties.SupportedTransferMode[PdoExtension->ChannelNumber][0];

        BusMasterInterface->SupportedTransferMode[1] = 
            fdoExtension->ControllerProperties.SupportedTransferMode[PdoExtension->ChannelNumber][1];
    
        BusMasterInterface->MaxTransferByteSize = (PdoExtension->MaximumPhysicalPages - 1) * PAGE_SIZE;
        BusMasterInterface->Context             = PdoExtension;
        BusMasterInterface->ContextSize         = sizeof (*PdoExtension);
    
        BusMasterInterface->BmSetup       = BmSetup;
        BusMasterInterface->BmArm         = BmArm;
        BusMasterInterface->BmDisarm      = BmDisarm;
        BusMasterInterface->BmFlush       = BmFlush;
        BusMasterInterface->BmStatus      = BmStatus;
        BusMasterInterface->BmTimingSetup = BmTimingSetup;
        BusMasterInterface->BmSetupOnePage= BmSetupOnePage;
        BusMasterInterface->BmCrashDumpInitialize= BmCrashDumpInitialize;
        BusMasterInterface->BmFlushAdapterBuffers= BmFlushAdapterBuffers;
        
        BusMasterInterface->IgnoreActiveBitForAtaDevice = 
            fdoExtension->ControllerProperties.IgnoreActiveBitForAtaDevice;

        BusMasterInterface->AlwaysClearBusMasterInterrupt = 
            (fdoExtension->ControllerProperties.AlwaysClearBusMasterInterrupt ||
            IsNativeMode(fdoExtension));
                            
        return STATUS_SUCCESS;

    } else {

        return STATUS_NOT_IMPLEMENTED;
    }
} // BmQueryInterface

NTSTATUS
BmFlushAdapterBuffers (
    IN  PVOID   PdoExtension,
    IN  PVOID   DataVirtualPageAddress,
    IN  ULONG   TransferByteCount,
    IN  PMDL    Mdl,
    IN  BOOLEAN DataIn
    )
/*++
--*/
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;

    ASSERT (pdoExtension->BmState != BmArmed);

    (pdoExtension->DmaAdapterObject->DmaOperations->FlushAdapterBuffers)(
																 (pdoExtension->DmaAdapterObject), 
																  Mdl, 
																  pdoExtension->MapRegisterBase, 
																  DataVirtualPageAddress,
																  TransferByteCount, 
																  !DataIn 
																  );

    pdoExtension->BmState = BmIdle;

	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\miniport\pciide\init.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    init.c

Abstract:

    Generic PCI IDE mini driver

Revision History:

--*/

#include "pciide.h"

//
// Driver Entry Point
//                               
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    //
    // call system pci ide driver (pciidex)
    // for initializeation
    //
    return PciIdeXInitialize (
        DriverObject,
        RegistryPath,
        GenericIdeGetControllerProperties,
        sizeof (DEVICE_EXTENSION)
        );
}


//
// Called on every I/O. Returns 1 if DMA is allowed.
// Returns 0 if DMA is not allowed.
//
ULONG
GenericIdeUseDma(
    IN PVOID DeviceExtension,
    IN PVOID cdbcmd,
    IN UCHAR slave)
/**++
 * Arguments : DeviceExtension
               Cdb
               Slave =1, if slave
                     =0, if master
--**/
{
    PDEVICE_EXTENSION deviceExtension = DeviceExtension;
    PUCHAR cdb= cdbcmd;

    return 1;
}

//
// Query controller properties
//                     
NTSTATUS 
GenericIdeGetControllerProperties (
    IN PVOID                      DeviceExtension,
    IN PIDE_CONTROLLER_PROPERTIES ControllerProperties
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceExtension;
    NTSTATUS    status;
    ULONG       i;
    ULONG       j;
    ULONG       xferMode;

    //
    // make sure we are in sync
    //                              
    if (ControllerProperties->Size != sizeof (IDE_CONTROLLER_PROPERTIES)) {

        return STATUS_REVISION_MISMATCH;
    }

    //
    // see what kind of PCI IDE controller we have
    //                               
    status = PciIdeXGetBusData (
                 deviceExtension,
                 &deviceExtension->pciConfigData, 
                 0,
                 sizeof (PCIIDE_CONFIG_HEADER)
                 );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // assume we support all DMA mode if PCI master bit is set
    //                            
    xferMode = PIO_SUPPORT;
    if ((deviceExtension->pciConfigData.MasterIde) &&
        (deviceExtension->pciConfigData.Command.b.MasterEnable)) {

        xferMode |= SWDMA_SUPPORT | MWDMA_SUPPORT | UDMA_SUPPORT;
    }

    //
    // Run PIO by default for the Sis Chipset
    //
    if ((deviceExtension->pciConfigData.VendorID == 0x1039) &&
        (deviceExtension->pciConfigData.DeviceID == 0x5513)) {
        ControllerProperties->DefaultPIO  = 1;
    }

// @@BEGIN_DDKSPLIT                    

    //
    // continuous status register polling causes some ALI
    // controller to corrupt data if the controller internal
    // FIFO is enabled
    //
    // to play safe, we will always disable the FIFO
    // see the ALi IDE controller programming spec for details
    //
    if ((deviceExtension->pciConfigData.VendorID == 0x10b9) && 
        (deviceExtension->pciConfigData.DeviceID == 0x5229)) {

        USHORT pciData;
        USHORT pciDataMask;

        pciData = 0;
        pciDataMask = 0xcccc;
        status = PciIdeXSetBusData(
                    DeviceExtension,
                    &pciData, 
                    &pciDataMask,
                    0x54,
                    0x2);
        if (!NT_SUCCESS(status)) {
    
            return status;
        }
    }

    //
    // ALi IDE controllers have lots of busmaster problems
    // some versions of them can't do busmaster with ATAPI devices
    // and some other versions of them return bogus busmaster status values
    // (the busmaster active bit doesn't get cleared when it should be
    // during an end of busmaster interrupt)
    //
    if ((deviceExtension->pciConfigData.VendorID == 0x10b9) && 
        (deviceExtension->pciConfigData.DeviceID == 0x5229) && 
        ((deviceExtension->pciConfigData.RevisionID == 0x20) || 
         (deviceExtension->pciConfigData.RevisionID == 0xc1))) {
        
        PciIdeXDebugPrint ((0, "pciide: overcome the sticky BM active bit problem in ALi controller\n"));

        ControllerProperties->IgnoreActiveBitForAtaDevice = TRUE;
    }
    
    if ((deviceExtension->pciConfigData.VendorID == 0x0e11) && 
        (deviceExtension->pciConfigData.DeviceID == 0xae33) && 
        (deviceExtension->pciConfigData.Chan0OpMode || 
         deviceExtension->pciConfigData.Chan1OpMode)) {
        
        PciIdeXDebugPrint ((0, "pciide: overcome the bogus busmaster interrupt in CPQ controller\n"));

        ControllerProperties->AlwaysClearBusMasterInterrupt = TRUE;
    }

// @@END_DDKSPLIT                    
    
    //
    // fill in the controller properties
    //            
    for (i=0; i< MAX_IDE_CHANNEL; i++) {

        for (j=0; j< MAX_IDE_DEVICE; j++) {

            ControllerProperties->SupportedTransferMode[i][j] =
                deviceExtension->SupportedTransferMode[i][j] = xferMode;
        }
    }

    ControllerProperties->PciIdeChannelEnabled     = GenericIdeChannelEnabled;
    ControllerProperties->PciIdeSyncAccessRequired = GenericIdeSyncAccessRequired;
    ControllerProperties->PciIdeTransferModeSelect = NULL;
    ControllerProperties->PciIdeUdmaModesSupported = GenericIdeUdmaModesSupported;
    ControllerProperties->PciIdeUseDma = GenericIdeUseDma;
    ControllerProperties->AlignmentRequirement=1;

    return STATUS_SUCCESS;
}

IDE_CHANNEL_STATE
GenericIdeChannelEnabled (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG Channel
    )
{
// @@BEGIN_DDKSPLIT                    
    NTSTATUS    status;
    PCI_COMMON_CONFIG pciHeader;
    ULONG pciDataByte;
    UCHAR maskByte = 0;

    status = PciIdeXGetBusData (
                 DeviceExtension,
                 &pciHeader, 
                 0,
                 sizeof (pciHeader)
                 );

    if (NT_SUCCESS(status)) {

        if ((pciHeader.VendorID == 0x0e11) && 
            (pciHeader.DeviceID == 0xae33)) {

            //
            // Compaq
            //
            status = PciIdeXGetBusData (
                         DeviceExtension,
                         &pciDataByte, 
                         0x80,
                         sizeof (pciDataByte)
                         );
    
            if (NT_SUCCESS(status)) {
    
                if (pciDataByte & (1 << Channel)) {
    
                    return ChannelEnabled;
                } else {
    
                    return ChannelDisabled;
                }
            }

        } else if ((pciHeader.VendorID == 0x1095) && 
                   ((pciHeader.DeviceID == 0x0646) || (pciHeader.DeviceID == 0x0643))) {

            //
            // CMD
            //
            status = PciIdeXGetBusData (
                         DeviceExtension,
                         &pciDataByte, 
                         0x51,
                         sizeof (pciDataByte)
                         );

            if (NT_SUCCESS(status)) {

                if (pciHeader.RevisionID < 0x3) {
    
                    //
                    // early revision doesn't have a
                    // bit to enable/disable primary
                    // channel since it is always enabled
                    
                    // newer version does have a bit defined 
                    // for this purpose.  to make the check 
                    // easier later.  we will set primary enable bit
                    // for the early revision
                    pciDataByte |= 0x4;
                }

                if (Channel == 0) {

                    maskByte = 0x4;

                } else {

                    maskByte = 0x8;
                }

                if (pciDataByte & maskByte) {
                    return ChannelEnabled;
                } else {
                    return ChannelDisabled;
                }
            }
        } else if ((pciHeader.VendorID == 0x1039) && 
                   (pciHeader.DeviceID == 0x5513)) {

            //
            // SiS
            //
            status = PciIdeXGetBusData (
                         DeviceExtension,
                         &pciDataByte, 
                         0x4a,
                         sizeof (pciDataByte)
                         );
            if (Channel == 0) {
                maskByte = 0x2;
            } else {
                maskByte = 0x4;
            }

            if (pciDataByte & maskByte) {
                return ChannelEnabled;
            } else {
                return ChannelDisabled;
            }
        } else if ((pciHeader.VendorID == 0x110A) &&
               (pciHeader.DeviceID == 0x0002)) {
            //
            // Siemens
            //
            ULONG configOffset = (Channel == 0)?0x41:0x49;

            status = PciIdeXGetBusData (
                      DeviceExtension,
                      &pciDataByte, 
                      configOffset,
                      sizeof (pciDataByte)
                      );
            if (NT_SUCCESS(status)) {

                maskByte = 0x08;

                if (pciDataByte & maskByte) {

                  return ChannelEnabled;

                } else {

                  return ChannelDisabled;

                }
            }
		} else if ((pciHeader.VendorID == 0x1106) &&
			(pciHeader.DeviceID == 0x0571)) {
            //
            // VIA
            //
            status = PciIdeXGetBusData (
                      DeviceExtension,
                      &pciDataByte, 
                      0x40,
                      sizeof (pciDataByte)
                      );
            if (NT_SUCCESS(status)) {

                maskByte = (Channel == 0)? 0x02:0x01;

                if (pciDataByte & maskByte) {

                  return ChannelEnabled;

                } else {

                  return ChannelDisabled;

                }
            }
		}
    }
// @@END_DDKSPLIT                    
    //
    // Can't tell if a channel is enabled or not.  
    //
    return ChannelStateUnknown;
}


// @@BEGIN_DDKSPLIT                    
VENDOR_ID_DEVICE_ID SingleFifoController[] = {
    {0x1095, 0x0640},         // CMD  640
    {0x1039, 0x0601}          // SiS ????
};
#define NUMBER_OF_SINGLE_FIFO_CONTROLLER (sizeof(SingleFifoController) / sizeof(VENDOR_ID_DEVICE_ID))
// @@END_DDKSPLIT                    

BOOLEAN 
GenericIdeSyncAccessRequired (
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    ULONG i;

// @@BEGIN_DDKSPLIT                    
    for (i=0; i<NUMBER_OF_SINGLE_FIFO_CONTROLLER; i++) {

        if ((DeviceExtension->pciConfigData.VendorID == SingleFifoController[i].VendorId) &&
            (DeviceExtension->pciConfigData.DeviceID == SingleFifoController[i].DeviceId)) {

            return TRUE;
        }
    }
// @@END_DDKSPLIT                    
    return FALSE;
}


NTSTATUS
GenericIdeUdmaModesSupported (
    IN IDENTIFY_DATA    IdentifyData,
    IN OUT PULONG       BestXferMode,
    IN OUT PULONG       CurrentMode
    )
{
    ULONG bestXferMode =0;
    ULONG currentMode = 0;

    if (IdentifyData.TranslationFieldsValid & (1 << 2)) {

        if (IdentifyData.UltraDMASupport) {

            GetHighestTransferMode( IdentifyData.UltraDMASupport,
                                       bestXferMode);
            *BestXferMode = bestXferMode;
        }

        if (IdentifyData.UltraDMAActive) {

            GetHighestTransferMode( IdentifyData.UltraDMAActive,
                                       currentMode);
            *CurrentMode = currentMode;
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\pciidex\ctlrfdo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctlrfdo.h
//
//--------------------------------------------------------------------------

#if !defined (___ctrlfdo_h___)
#define ___ctrlfdo_h___

//
// DeviceControlsFlags
//
// WARNING: all of these flags must be correctly reflected 
//          in the mshdc.inf and txtsetuo.sif files
//
#define PCIIDEX_DCF_NO_ATAPI_DMA        (1 << 0)

//
// determine how often we rescan for new unknown child.
// unknown child is IDE channel which we don't know 
// it is enabled or not unless we pnp start the channel 
// and poke at it to find out.
#define MIN_BUS_SCAN_PERIOD_IN_SEC      90

#define IsNativeMode(d) ((d)->NativeMode[0] && (d)->NativeMode[1])

struct _CONTROLLER_FDO_EXTENSION;
typedef struct _CONTROLLER_FDO_EXTENSION * PCTRLFDO_EXTENSION;
typedef struct _IDE_BUS_MASTER_REGISTERS * PIDE_BUS_MASTER_REGISTERS;

typedef struct _DRIVER_OBJECT_EXTENSION {

    PCONTROLLER_PROPERTIES PciIdeGetControllerProperties;

    ULONG                  ExtensionSize;

} DRIVER_OBJECT_EXTENSION, *PDRIVER_OBJECT_EXTENSION;

typedef struct _FDO_POWER_CONTEXT {

    PIRP               OriginalPowerIrp;
    POWER_STATE_TYPE   newPowerType;
    POWER_STATE        newPowerState;

} FDO_POWER_CONTEXT, *PFDO_POWER_CONTEXT;

typedef struct _PCIIDE_INTERRUPT_CONTEXT {

	PVOID	DeviceExtension;
	ULONG	ChannelNumber;

} PCIIDE_INTERRUPT_CONTEXT, *PPCIIDE_INTERRUPT_CONTEXT;

struct _CHANNEL_PDO_EXTENSION;
typedef struct _CHANNEL_PDO_EXTENSION * PCHANPDO_EXTENSION;

typedef struct _CONTROLLER_FDO_EXTENSION {

    EXTENSION_COMMON_HEADER;

    ULONG ControllerNumber;

    PDEVICE_OBJECT  PhysicalDeviceObject;

    PCHANPDO_EXTENSION  ChildDeviceExtension[MAX_IDE_CHANNEL]; 

    ULONG   NumberOfChildren;

    //
    // Interlocked* protected
    //
    ULONG   NumberOfChildrenPowerUp;

    //
    // native mode channels
    //
    BOOLEAN NativeMode[MAX_IDE_CHANNEL];

    //
    // initialized by AnalyzeResourceList()
    //
    BOOLEAN             PdoCmdRegResourceFound[MAX_IDE_CHANNEL];
    BOOLEAN             PdoCtrlRegResourceFound[MAX_IDE_CHANNEL];
    BOOLEAN             PdoInterruptResourceFound[MAX_IDE_CHANNEL];

    ULONG               PdoResourceListSize[MAX_IDE_CHANNEL];
    PCM_RESOURCE_LIST   PdoResourceList[MAX_IDE_CHANNEL];
    ULONG               BmResourceListSize;
    PCM_RESOURCE_LIST   BmResourceList;

    //
    // Bus Master Register
    //
    ULONG                     BusMasterBaseAddressSpace;
    PIDE_BUS_MASTER_REGISTERS TranslatedBusMasterBaseAddress;
    //
    // Vendor Specific Controller Properties
    //
    IDE_CONTROLLER_PROPERTIES ControllerProperties;

    //
    // Vendor Specific Device Extension
    //
    PVOID   VendorSpecificDeviceEntension;

    //
    // Controller Object for serailizing access to broken PCI-IDE controller
    //
    //
    PCONTROLLER_OBJECT ControllerObject;

    //
    // mutex for setting pci config data
    //
    KSPIN_LOCK  PciConfigDataLock;

    //
    // Special device specific parameter
    //
    ULONG DeviceControlsFlags;

    //
    // Bus Interface
    //
    BUS_INTERFACE_STANDARD BusInterface;

    //
    // Last BusScan Time in sec
    //
    ULONG LastBusScanTime;

    //
    // Flag to enable udma66
    //
    ULONG EnableUDMA66;

    //
    // Timings for the different transfer modes
    //
    PULONG TransferModeTimingTable;

    //
    // Length of the table
    //
    ULONG TransferModeTableLength;

	//
	// Pre-alloced context structure for power routines
	//
    FDO_POWER_CONTEXT FdoPowerContext[MAX_IDE_CHANNEL];

#if DBG
    ULONG   PowerContextLock[MAX_IDE_CHANNEL];
#endif

#ifdef ENABLE_NATIVE_MODE
	//
	// Interrupt object
	//
    PKINTERRUPT InterruptObject[MAX_IDE_CHANNEL]; 

	//
	// Context structure for the ISR
	//
	PCIIDE_INTERRUPT_CONTEXT InterruptContext[MAX_IDE_CHANNEL];

	//
	// IDE resources for native mode controllers
	//
	IDE_RESOURCE IdeResource;

    //
    // Base register locations
    //
    IDE_REGISTERS_1            BaseIoAddress1[MAX_IDE_CHANNEL];
    IDE_REGISTERS_2            BaseIoAddress2[MAX_IDE_CHANNEL];

	//
	//interrupt
	//
    PCM_PARTIAL_RESOURCE_DESCRIPTOR IrqPartialDescriptors[MAX_IDE_CHANNEL];
    //
    // Register length.
    //
    ULONG   BaseIoAddress1Length[MAX_IDE_CHANNEL];
    ULONG   BaseIoAddress2Length[MAX_IDE_CHANNEL];

    //
    // Max ide device/target-id
    //
    ULONG   MaxIdeDevice[MAX_IDE_CHANNEL];
    ULONG   MaxIdeTargetId[MAX_IDE_CHANNEL];

	//
	// Flags to close the interrupt window
	//
	BOOLEAN	ControllerIsrInstalled;
	BOOLEAN	NativeInterruptEnabled;
	BOOLEAN NoBusMaster[MAX_IDE_CHANNEL];

	//
	// Native Ide Interface obtained from PCI
	//
	PCI_NATIVE_IDE_INTERFACE	NativeIdeInterface;
#endif

} CTRLFDO_EXTENSION, *PCTRLFDO_EXTENSION;

NTSTATUS
ControllerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
ControllerStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ControllerStartDeviceCompletionRoutine(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PIRP            Irp,
    IN OUT PVOID           Context
    );

NTSTATUS
ControllerStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ControllerStopController (
    IN PCTRLFDO_EXTENSION fdoExtension
    );

NTSTATUS
ControllerSurpriseRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ControllerRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ControllerRemoveDeviceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
ControllerQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ControllerQueryResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
LoadControllerParameters (
    PCTRLFDO_EXTENSION FdoExtension
    );

NTSTATUS
AnalyzeResourceList (
    PCTRLFDO_EXTENSION FdoExtension,
    PCM_RESOURCE_LIST  ResourceList
    );

VOID
ControllerOpMode (
    IN PCTRLFDO_EXTENSION FdoExtension
    );
                         
VOID
EnablePCIBusMastering ( 
    IN PCTRLFDO_EXTENSION FdoExtension
    );
                         
IDE_CHANNEL_STATE
PciIdeChannelEnabled (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN ULONG Channel
);
      
VOID
ControllerTranslatorNull (
    IN PVOID Context
    );
      
NTSTATUS
ControllerTranslateResource (
    IN  PVOID Context,
    IN  PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN  RESOURCE_TRANSLATION_DIRECTION Direction,
    IN  ULONG AlternativesCount OPTIONAL,
    IN  IO_RESOURCE_DESCRIPTOR Alternatives[] OPTIONAL,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );
    
NTSTATUS
ControllerTranslateRequirement (
    IN  PVOID Context,
    IN  PIO_RESOURCE_DESCRIPTOR Source,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );
    
NTSTATUS
ControllerQueryInterface (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
VOID
PciIdeInitControllerProperties (
    IN PCTRLFDO_EXTENSION FdoExtension
    );
                         
NTSTATUS
ControllerUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ControllerUsageNotificationCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );
                         
NTSTATUS
PciIdeGetBusStandardInterface(
    IN PCTRLFDO_EXTENSION FdoExtension
    );
                         
NTSTATUS
ControllerQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PciIdeCreateTimingTable (
    IN PCTRLFDO_EXTENSION FdoExtension
    );

#ifdef ENABLE_NATIVE_MODE
NTSTATUS
ControllerInterruptControl (
	IN PCTRLFDO_EXTENSION 	FdoExtension,
	IN ULONG				Channel,
	IN ULONG 				Disconnect
	);

BOOLEAN
ControllerInterrupt(
    IN PKINTERRUPT Interrupt,
	PVOID Context
	);

NTSTATUS
PciIdeGetNativeModeInterface(
    IN PCTRLFDO_EXTENSION FdoExtension
    );

#define ControllerEnableInterrupt(FdoExtension) \
	if (FdoExtension->NativeIdeInterface.InterruptControl) { \
		(FdoExtension->NativeIdeInterface).InterruptControl((FdoExtension->NativeIdeInterface).Context,\
															TRUE);\
	}
#define ControllerDisableInterrupt(FdoExtension) \
	if (FdoExtension->NativeIdeInterface.InterruptControl) { \
		(FdoExtension->NativeIdeInterface).InterruptControl((FdoExtension->NativeIdeInterface).Context,\
															FALSE);\
	}

#endif //ENABLE_NATIVE_MODE
                         
#endif // ___ctrlfdo_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\pciidex\bm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bm.h
//
//--------------------------------------------------------------------------

#if !defined (___bm_h___)
#define ___bm_h___

//
// Busmaster Status Register Bit Definition

#define BUSMASTER_DMA_SIMPLEX_BIT     ((UCHAR) (1 << 7))
#define BUSMASTER_DEVICE1_DMA_OK      ((UCHAR) (1 << 6))
#define BUSMASTER_DEVICE0_DMA_OK      ((UCHAR) (1 << 5))
#define BUSMASTER_INTERRUPT           ((UCHAR) (1 << 2))
#define BUSMASTER_ERROR               ((UCHAR) (1 << 1))
#define BUSMASTER_ACTIVE              ((UCHAR) (1 << 0))
#define BUSMASTER_ZERO_BITS           ((UCHAR) ((1 << 3) | (1 << 4)))


#pragma pack (1)
//
// Bus Master Controller Register
//
typedef struct _IDE_BUS_MASTER_REGISTERS {
         UCHAR  Command;
         UCHAR  Reserved1;
         UCHAR  Status;
         UCHAR  Reserved2;
         ULONG  DescriptionTable;
} IDE_BUS_MASTER_REGISTERS, *PIDE_BUS_MASTER_REGISTERS;

//
// Bus Master Physical Region Descriptor
//
typedef struct _PHYSICAL_REGION_DESCRIPTOR {
    ULONG PhysicalAddress;
    ULONG ByteCount:16;
    ULONG Reserved:15;
    ULONG EndOfTable:1;
} PHYSICAL_REGION_DESCRIPTOR, * PPHYSICAL_REGION_DESCRIPTOR;
#pragma pack ()


NTSTATUS 
BusMasterInitialize (
    PCHANPDO_EXTENSION pdoExtension
    );

NTSTATUS 
BusMasterUninitialize (
    PCHANPDO_EXTENSION PdoExtension
    );

NTSTATUS
BmSetup (
    IN  PVOID   PdoExtension,
    IN  PVOID   DataVirtualAddress,
    IN  ULONG   TransferByteCount,
    IN  PMDL    Mdl,
    IN  BOOLEAN DataIn,
    IN  VOID    (* BmCallback) (PVOID Context),
    IN  PVOID   Context
    );

VOID
BmReceiveScatterGatherList(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    );

VOID
BmRebuildScatterGatherList(
    IN PCHANPDO_EXTENSION pdoExtension,
    IN PSCATTER_GATHER_LIST ScatterGather
    );

VOID
BmPrepareController (
    PCHANPDO_EXTENSION PdoExtension
    );

NTSTATUS
BmArm (
    IN  PVOID   PdoExtension
    );

BMSTATUS
BmDisarm (
    IN  PVOID   PdoExtension
    );

BMSTATUS
BmFlush (
    IN  PVOID   PdoExtension
    );

BMSTATUS
BmStatus (
    IN  PVOID   PdoExtension
    );

NTSTATUS
BmTimingSetup (
    IN  PVOID   PdoExtension
    );

NTSTATUS
BmFlushAdapterBuffers (
    IN  PVOID   PdoExtension,
    IN  PVOID   DataVirtualPageAddress,
    IN  ULONG   TransferByteCount,
    IN  PMDL    Mdl,
    IN  BOOLEAN DataIn
    );

NTSTATUS 
BmQueryInterface (
    IN PCHANPDO_EXTENSION PdoExtension,
    IN OUT PPCIIDE_BUSMASTER_INTERFACE BusMasterInterface
    );

#endif // ___bm_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\pciidex\ctlrfdo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctlrfdo.c
//
//--------------------------------------------------------------------------

#include "pciidex.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ControllerAddDevice)
#pragma alloc_text(PAGE, ControllerStartDevice)
#pragma alloc_text(PAGE, ControllerStopDevice)
#pragma alloc_text(PAGE, ControllerStopController)
#pragma alloc_text(PAGE, ControllerSurpriseRemoveDevice)
#pragma alloc_text(PAGE, ControllerRemoveDevice)
#pragma alloc_text(PAGE, ControllerQueryDeviceRelations)
#pragma alloc_text(PAGE, ControllerQueryInterface)
#pragma alloc_text(PAGE, AnalyzeResourceList)
#pragma alloc_text(PAGE, ControllerOpMode)
#pragma alloc_text(PAGE, PciIdeChannelEnabled)
#pragma alloc_text(PAGE, PciIdeCreateTimingTable)
#pragma alloc_text(PAGE, PciIdeInitControllerProperties)
#pragma alloc_text(PAGE, ControllerUsageNotification)
#pragma alloc_text(PAGE, PciIdeGetBusStandardInterface)
#pragma alloc_text(PAGE, ControllerQueryPnPDeviceState)

#pragma alloc_text(NONPAGE, EnablePCIBusMastering)
#pragma alloc_text(NONPAGE, ControllerUsageNotificationCompletionRoutine)
#pragma alloc_text(NONPAGE, ControllerRemoveDeviceCompletionRoutine)
#pragma alloc_text(NONPAGE, ControllerStartDeviceCompletionRoutine)
#endif // ALLOC_PRAGMA

//
// Must match mshdc.inf
//
static PWCHAR ChannelEnableMaskName[MAX_IDE_CHANNEL] = {
     L"MasterOnMask",
     L"SlaveOnMask"
};
static PWCHAR ChannelEnablePciConfigOffsetName[MAX_IDE_CHANNEL] = {
     L"MasterOnConfigOffset",
     L"SlaveOnConfigOffset"
};


static ULONG PciIdeXNextControllerNumber = 0;
static ULONG PciIdeXNextChannelNumber = 0;

NTSTATUS
ControllerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
{
    PDEVICE_OBJECT              deviceObject;
    PCTRLFDO_EXTENSION          fdoExtension;
    NTSTATUS                    status;
    PDRIVER_OBJECT_EXTENSION    driverObjectExtension;
    ULONG                       deviceExtensionSize;
    UNICODE_STRING              deviceName;
    WCHAR                       deviceNameBuffer[64];
    ULONG                       controllerNumber;

    PAGED_CODE();

    driverObjectExtension =
        (PDRIVER_OBJECT_EXTENSION) IoGetDriverObjectExtension(
                                       DriverObject,
                                       DRIVER_OBJECT_EXTENSION_ID
                                       );
    ASSERT (driverObjectExtension);

    //
    // devobj name
    //
    controllerNumber = InterlockedIncrement(&PciIdeXNextControllerNumber) - 1;
    swprintf(deviceNameBuffer, DEVICE_OJBECT_BASE_NAME L"\\PciIde%d", controllerNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    deviceExtensionSize = sizeof(CTRLFDO_EXTENSION) +
                          driverObjectExtension->ExtensionSize;

    //
    // We've been given the PhysicalDeviceObject for an IDE controller.  Create the
    // FunctionalDeviceObject.  Our FDO will be nameless.
    //

    status = IoCreateDevice(
                DriverObject,               // our driver object
                deviceExtensionSize,        // size of our extension
                &deviceName,                // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                FILE_DEVICE_SECURE_OPEN,    // device characteristics
                FALSE,                      // not exclusive
                &deviceObject               // store new device object here
                );

    if( !NT_SUCCESS( status )){

        return status;
    }

    fdoExtension = (PCTRLFDO_EXTENSION)deviceObject->DeviceExtension;
    RtlZeroMemory (fdoExtension, deviceExtensionSize);

    //
    // We have our FunctionalDeviceObject, initialize it.
    //

    fdoExtension->AttacheePdo                   = PhysicalDeviceObject;
    fdoExtension->DeviceObject                  = deviceObject;
    fdoExtension->DriverObject                  = DriverObject;
    fdoExtension->ControllerNumber              = controllerNumber;
    fdoExtension->VendorSpecificDeviceEntension = fdoExtension + 1;

    // Dispatch Table
    fdoExtension->DefaultDispatch               = PassDownToNextDriver;
    fdoExtension->PnPDispatchTable              = FdoPnpDispatchTable;
    fdoExtension->PowerDispatchTable            = FdoPowerDispatchTable;
    fdoExtension->WmiDispatchTable              = FdoWmiDispatchTable;

    //
    // Get the Device Control Flags out of the registry
    //
    fdoExtension->DeviceControlsFlags = 0;
    status = PciIdeXGetDeviceParameter (
               fdoExtension->AttacheePdo,
               L"DeviceControlFlags",
               &fdoExtension->DeviceControlsFlags
               );
    if (!NT_SUCCESS(status)) {

        DebugPrint ((1, "PciIdeX: Unable to get DeviceControlFlags from the registry\n"));

        //
        // this is not a serious error...continue to load
        //
        status = STATUS_SUCCESS;
    }

    //
    // Now attach to the PDO we were given.
    //
    fdoExtension->AttacheeDeviceObject = IoAttachDeviceToDeviceStack (
                                             deviceObject,
                                             PhysicalDeviceObject
                                             );

    if (fdoExtension->AttacheeDeviceObject == NULL){

        //
        // Couldn't attach.  Delete the FDO.
        //

        IoDeleteDevice (deviceObject);

    } else {

        //
        // fix up alignment requirement
        //
        deviceObject->AlignmentRequirement = fdoExtension->AttacheeDeviceObject->AlignmentRequirement;
        if (deviceObject->AlignmentRequirement < 1) {
            deviceObject->AlignmentRequirement = 1;
        }

        //
        // get the standard bus interface
        // (for READ_CONFIG/WRITE_CONFIG
        //
        status = PciIdeGetBusStandardInterface(fdoExtension);

        if (!NT_SUCCESS(status)) {

            IoDetachDevice (fdoExtension->AttacheeDeviceObject);
            IoDeleteDevice (deviceObject);

            return status;
        }
        //
        // Init operating mode (native or legacy)
        //
        ControllerOpMode (fdoExtension);

#ifdef ENABLE_NATIVE_MODE
		if (IsNativeMode(fdoExtension)) {

			NTSTATUS interfaceStatus = PciIdeGetNativeModeInterface(fdoExtension);

			//
			// bad pci.sys. 
			// we should still work. However, the window where an interrupt fires before
			// we are ready to dismiss it would not be closed. Can't do much at this point.
			//

			//ASSERT(NT_SUCCESS(interfaceStatus));
		}
#endif

        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }

    return status;
} // ControllerAddDevice


NTSTATUS
ControllerStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION              thisIrpSp;
    NTSTATUS                        status;
    PCTRLFDO_EXTENSION              fdoExtension;
    PCM_RESOURCE_LIST               resourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR irqPartialDescriptors;
    ULONG i;

    KEVENT                          event;

    POWER_STATE                     powerState;

    PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    fdoExtension = (PCTRLFDO_EXTENSION) DeviceObject->DeviceExtension;

    resourceList     = thisIrpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

    if (!resourceList) {

        DebugPrint ((1, "PciIde: Starting with no resource\n"));
    }

#ifdef ENABLE_NATIVE_MODE
	
	//
	// Let PCI know that we will manage the decodes
	//
	if (IsNativeMode(fdoExtension)) {
		ControllerDisableInterrupt(fdoExtension);
	}
#endif

    //
    // Call the lower level drivers with a the Irp
    //
    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE);

    IoCopyCurrentIrpStackLocationToNext (Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoSetCompletionRoutine(
        Irp,
        ControllerStartDeviceCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Pass the irp along
    //
    status = IoCallDriver(fdoExtension->AttacheeDeviceObject, Irp);

    //
    // Wait for it to come back...
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab back the 'real' status
        //
        status = Irp->IoStatus.Status;
    }

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    powerState.SystemState = PowerSystemWorking;
    status = PciIdeIssueSetPowerState (
                 fdoExtension,
                 SystemPowerState,
                 powerState,
                 TRUE
                 );
    if (status == STATUS_INVALID_DEVICE_REQUEST) {

        //
        // The DeviceObject below us does not support power irp,
        // we will assume we are powered up
        //
        fdoExtension->SystemPowerState = PowerSystemWorking;

    } else if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    powerState.DeviceState = PowerDeviceD0;
    status= PciIdeIssueSetPowerState (
                 fdoExtension,
                 DevicePowerState,
                 powerState,
                 TRUE
                 );
    if (status == STATUS_INVALID_DEVICE_REQUEST) {

        //
        // The DeviceObject Below us does not support power irp,
        // pretend we are powered up
        //
        fdoExtension->DevicePowerState = PowerDeviceD0;

    } else if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

#ifdef ENABLE_NATIVE_MODE
	if (!IsNativeMode(fdoExtension))  {
#endif

		//
		// Turn on PCI busmastering
		//
		EnablePCIBusMastering (
			fdoExtension
			);

#ifdef ENABLE_NATIVE_MODE
	}
#endif
    //
    // Initialize a fast mutex for later use
    //
    KeInitializeSpinLock(
        &fdoExtension->PciConfigDataLock
    );

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

	//
	// Analyze the resources
	//
    status = AnalyzeResourceList (fdoExtension, resourceList);

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    //
    // Initialize controller properties. We need the resources
	// at this point for Native mode IDE controllers
    //
    PciIdeInitControllerProperties (
        fdoExtension
        );

#ifdef ENABLE_NATIVE_MODE
	if (IsNativeMode(fdoExtension)) {

		IDE_CHANNEL_STATE channelState;

#if DBG
    {
        PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
        PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
        ULONG                           resourceListSize;
        ULONG                           i;
        ULONG                           j;

        fullResourceList = resourceList->List;
        resourceListSize = 0;

        DebugPrint ((1, "Pciidex: Starting native mode device: FDOe\n", fdoExtension));

        for (i=0; i<resourceList->Count; i++) {
            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

            for (j=0; j<partialResourceList->Count; j++) {
                if (partialDescriptors[j].Type == CmResourceTypePort) {
                    DebugPrint ((1, "pciidex: IO Port = 0x%x. Lenght = 0x%x\n", partialDescriptors[j].u.Port.Start.LowPart, partialDescriptors[j].u.Port.Length));
                } else if (partialDescriptors[j].Type == CmResourceTypeInterrupt) {
                    DebugPrint ((1, "pciidex: Int Level = 0x%x. Int Vector = 0x%x\n", partialDescriptors[j].u.Interrupt.Level, partialDescriptors[j].u.Interrupt.Vector));
                } else {
                    DebugPrint ((1, "pciidex: Unknown resource\n"));
                }
            }
            fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + j);
        }

    }

#endif // DBG


		fdoExtension->ControllerIsrInstalled = FALSE;

		for (i=0; i< MAX_IDE_CHANNEL; i++) {


			//
			// Analyze the resources we are getting
			//
			status = DigestResourceList( 
							&fdoExtension->IdeResource, 
							fdoExtension->PdoResourceList[i], 
							&fdoExtension->IrqPartialDescriptors[i] 
							);

			if (!NT_SUCCESS(status) ) {

				goto GetOut;
			}

			if (!fdoExtension->IrqPartialDescriptors[i]) {

				status = STATUS_INSUFFICIENT_RESOURCES;

				goto GetOut;
			}

			DebugPrint((1, 
						"Pciidex: Connecting interrupt for channel %x interrupt vector 0x%x\n", 
						i,
						fdoExtension->IrqPartialDescriptors[i]->u.Interrupt.Vector
						));

			channelState = PciIdeChannelEnabled (fdoExtension, i);

			if (channelState != ChannelDisabled) {

				//
				// Build io address structure.
				//
				AtapiBuildIoAddress(
						fdoExtension->IdeResource.TranslatedCommandBaseAddress,
						fdoExtension->IdeResource.TranslatedControlBaseAddress,
						&fdoExtension->BaseIoAddress1[i],
						&fdoExtension->BaseIoAddress2[i],
						&fdoExtension->BaseIoAddress1Length[i],
						&fdoExtension->BaseIoAddress2Length[i],
						&fdoExtension->MaxIdeDevice[i],
						NULL);

				//
				// Install the ISR
				//
				status = ControllerInterruptControl(fdoExtension, i, 0);

				if (!NT_SUCCESS(status)) {
					break;
				}
			}
		}

		if (!NT_SUCCESS(status)) {

			goto GetOut;
		}

		//
		// This flag is needed for the ISR to enable interrupts. 
		//
		fdoExtension->ControllerIsrInstalled = TRUE;

		//
		// Enable the interrupt in both the channels
		//
		ControllerEnableInterrupt(fdoExtension);

		fdoExtension->NativeInterruptEnabled = TRUE;

		//
		// See the comments in the ISR regarding these flags
		//
		ASSERT(fdoExtension->ControllerIsrInstalled == TRUE);
		ASSERT(fdoExtension->NativeInterruptEnabled == TRUE);

		//
		// Turn on PCI busmastering
		//
		EnablePCIBusMastering (
			fdoExtension
			);

		for (i=0; i< MAX_IDE_CHANNEL; i++) {

			PIDE_BUS_MASTER_REGISTERS   bmRegister;

			//
			// Check the bus master registers
			//
			bmRegister = (PIDE_BUS_MASTER_REGISTERS)(((PUCHAR)fdoExtension->TranslatedBusMasterBaseAddress) + i*8);

			if (READ_PORT_UCHAR (&bmRegister->Status) & BUSMASTER_ZERO_BITS) {
				fdoExtension->NoBusMaster[i] = TRUE;
			}

		}
	}
#endif

    status = PciIdeCreateSyncChildAccess (fdoExtension);

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    status = PciIdeCreateTimingTable(fdoExtension);

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

GetOut:

    if (NT_SUCCESS(status)) {

#if DBG
        {
            PCM_RESOURCE_LIST               resourceList;
            PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
            PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
            ULONG                           i;
            ULONG                           j;
            ULONG                           k;

            DebugPrint ((1, "PciIdeX: Starting device:\n"));

            for (k=0; k <MAX_IDE_CHANNEL + 1; k++) {

                if (k == MAX_IDE_CHANNEL) {

                    DebugPrint ((1, "PciIdeX: Busmaster resources:\n"));

                    resourceList = fdoExtension->BmResourceList;
                } else {

                    DebugPrint ((1, "PciIdeX: PDO %d resources:\n", k));
                    resourceList = fdoExtension->PdoResourceList[k];
                }

                if (resourceList) {

                    fullResourceList = resourceList->List;


                    for (i=0; i<resourceList->Count; i++) {

                        partialResourceList = &(fullResourceList->PartialResourceList);
                        partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

                        for (j=0; j<partialResourceList->Count; j++) {
                            if (partialDescriptors[j].Type == CmResourceTypePort) {
                                DebugPrint ((1, "IdePort: IO Port = 0x%x. Lenght = 0x%x\n", partialDescriptors[j].u.Port.Start.LowPart, partialDescriptors[j].u.Port.Length));
                            } else if (partialDescriptors[j].Type == CmResourceTypeMemory) {
                                    DebugPrint ((1, "IdePort: Memory Port = 0x%x. Lenght = 0x%x\n", partialDescriptors[j].u.Memory.Start.LowPart, partialDescriptors[j].u.Memory.Length));
                            } else if (partialDescriptors[j].Type == CmResourceTypeInterrupt) {
                                DebugPrint ((1, "IdePort: Int Level = 0x%x. Int Vector = 0x%x\n", partialDescriptors[j].u.Interrupt.Level, partialDescriptors[j].u.Interrupt.Vector));
                            } else {
                                DebugPrint ((1, "IdePort: Unknown resource\n"));
                            }
                        }
                        fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + j);
                    }
                }
            }
        }
#endif // DBG
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
} // ControllerStartDevice

NTSTATUS
ControllerStartDeviceCompletionRoutine(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PIRP            Irp,
    IN OUT PVOID           Context
    )
{
    PKEVENT event = (PKEVENT) Context;

    //
    // Signal the event
    //
    KeSetEvent( event, IO_NO_INCREMENT, FALSE );

    //
    // Always return MORE_PROCESSING_REQUIRED
    // will complete it later
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
} // ControllerStartDeviceCompletionRoutine

NTSTATUS
ControllerStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCTRLFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    status = ControllerStopController (
                fdoExtension
                );
    ASSERT (NT_SUCCESS(status));
    
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
} // ControllerStopDevice


NTSTATUS
ControllerStopController (
    IN PCTRLFDO_EXTENSION FdoExtension
    )
{
    ULONG i;

    PAGED_CODE();

    if (FdoExtension->BmResourceList) {
        ExFreePool (FdoExtension->BmResourceList);
        FdoExtension->BmResourceList = NULL;
    }

    for (i=0; i<MAX_IDE_CHANNEL; i++) {
        if (FdoExtension->PdoResourceList[i]) {
            ExFreePool (FdoExtension->PdoResourceList[i]);
            FdoExtension->PdoResourceList[i] = NULL;
        }
    }

#ifdef ENABLE_NATIVE_MODE

	//
	// We need to reset the flags in this order. Otherwise an interrupt would
	// result in the decodes to be enabled by the ISR. See the comments in the ISR
	//
	FdoExtension->ControllerIsrInstalled = FALSE;
	ControllerDisableInterrupt(FdoExtension);
	FdoExtension->NativeInterruptEnabled = FALSE;

	for (i=0; i< MAX_IDE_CHANNEL; i++) {

		NTSTATUS status;
		DebugPrint((1, "Pciidex: DisConnecting interrupt for channel %x\n", i));

		//
		// Disconnect the ISR
		//
		status = ControllerInterruptControl(FdoExtension, i, 1 );

		ASSERT(NT_SUCCESS(status));

	}

	ASSERT(FdoExtension->ControllerIsrInstalled == FALSE);
	ASSERT(FdoExtension->NativeInterruptEnabled == FALSE);

#endif

    PciIdeDeleteSyncChildAccess (FdoExtension);

    return STATUS_SUCCESS;
} // ControllerStopController


NTSTATUS
ControllerSurpriseRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCTRLFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS        status;
    ULONG           i;

    PAGED_CODE();

#if DBG
    //
    // make sure all the children are removed or surprise removed
    //
    for (i=0; i<MAX_IDE_CHANNEL; i++) {

        PCHANPDO_EXTENSION pdoExtension;

        pdoExtension = fdoExtension->ChildDeviceExtension[i];

        if (pdoExtension) {

            ASSERT (pdoExtension->PdoState & (PDOS_SURPRISE_REMOVED | PDOS_REMOVED));
        }
    }
#endif // DBG

    status = ControllerStopController (fdoExtension);
    ASSERT (NT_SUCCESS(status));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation ( Irp );
    return IoCallDriver(fdoExtension->AttacheeDeviceObject, Irp);

} // ControllerSurpriseRemoveDevice


NTSTATUS
ControllerRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCTRLFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS        status;
    KEVENT          event;
    ULONG           i;

    PAGED_CODE();

    //
    // Kill all the children if any
    //
    for (i=0; i<MAX_IDE_CHANNEL; i++) {

        PCHANPDO_EXTENSION pdoExtension;

        pdoExtension = fdoExtension->ChildDeviceExtension[i];

        if (pdoExtension) {

            status = ChannelStopChannel (pdoExtension);
            ASSERT (NT_SUCCESS(status));

            //
            // mark this device invalid
            //
            ChannelUpdatePdoState (
                pdoExtension,
                PDOS_DEADMEAT | PDOS_REMOVED,
                0
                );

            IoDeleteDevice (pdoExtension->DeviceObject);
            fdoExtension->ChildDeviceExtension[i] = NULL;
        }
    }

    status = ControllerStopController (fdoExtension);
    ASSERT (NT_SUCCESS(status));

    if (fdoExtension->TransferModeTimingTable) {
        ExFreePool(fdoExtension->TransferModeTimingTable);
        fdoExtension->TransferModeTimingTable = NULL;
        fdoExtension->TransferModeTableLength = 0;
    }

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext (Irp);

    IoSetCompletionRoutine(
        Irp,
        ControllerRemoveDeviceCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    status = IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }

    IoDetachDevice (fdoExtension->AttacheeDeviceObject);

    IoDeleteDevice (DeviceObject);

    //return STATUS_SUCCESS;
    return status;
} // ControllerRemoveDevice


NTSTATUS
ControllerRemoveDeviceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    PKEVENT event = Context;

    KeSetEvent(event, 0, FALSE);

    return STATUS_SUCCESS;
} // ControllerRemoveDeviceCompletionRoutine

NTSTATUS
ControllerQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PCTRLFDO_EXTENSION  fdoExtension;
    PDEVICE_RELATIONS   deviceRelations;
    NTSTATUS            status;
    ULONG               deviceRelationsSize;
    ULONG               channel;
    PCONFIGURATION_INFORMATION configurationInformation = IoGetConfigurationInformation();
    ULONG               nextUniqueNumber;

    PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    fdoExtension = (PCTRLFDO_EXTENSION) DeviceObject->DeviceExtension;
    status = STATUS_SUCCESS;

    switch (thisIrpSp->Parameters.QueryDeviceRelations.Type) {
        case BusRelations:
        DebugPrint ((3, "ControllerQueryDeviceRelations: bus relations\n"));

        deviceRelationsSize = FIELD_OFFSET (DEVICE_RELATIONS, Objects) +
                                MAX_IDE_CHANNEL * sizeof(PDEVICE_OBJECT);

        deviceRelations = ExAllocatePool (PagedPool, deviceRelationsSize);

        if(!deviceRelations) {

            DebugPrint ((1, 
                         "IdeQueryDeviceRelations: Unable to allocate DeviceRelations structures\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;

        }

        if (NT_SUCCESS(status)) {

            LARGE_INTEGER tickCount;
            ULONG newBusScanTime;
            ULONG newBusScanTimeDelta;
            BOOLEAN reportUnknownAsNewChild;

            //
            // determine if we should return unknown child as new child
            // unknown child is IDE channel which we don't know 
            // it is enabled or not unless we pnp start the channel 
            // and poke at it to find out.
            //
            // since we don't want to go into an infinite cycle of
            // starting and failing start on a unknown child, we will
            // limit our frequency
            //
            KeQueryTickCount(&tickCount);
            newBusScanTime = (ULONG) ((tickCount.QuadPart * 
                ((ULONGLONG) KeQueryTimeIncrement())) / ((ULONGLONG) 10000000));
            newBusScanTimeDelta = newBusScanTime - fdoExtension->LastBusScanTime;
            DebugPrint ((1, "PCIIDEX: Last rescan was %d seconds ago.\n", newBusScanTimeDelta));

            if ((newBusScanTimeDelta < MIN_BUS_SCAN_PERIOD_IN_SEC) &&
                (fdoExtension->LastBusScanTime != 0)) {

                reportUnknownAsNewChild = FALSE;

            } else {

                reportUnknownAsNewChild = TRUE;
            }
            fdoExtension->LastBusScanTime = newBusScanTime;

            RtlZeroMemory (deviceRelations, deviceRelationsSize);

            for (channel = 0; channel < MAX_IDE_CHANNEL; channel++) {

                PDEVICE_OBJECT      deviceObject;
                PCHANPDO_EXTENSION  pdoExtension;
                UNICODE_STRING      deviceName;
                WCHAR               deviceNameBuffer[256];
                PDEVICE_OBJECT      deviceObjectToReturn;
                IDE_CHANNEL_STATE   channelState;

                deviceObjectToReturn = NULL;

                pdoExtension = fdoExtension->ChildDeviceExtension[channel];
                channelState = PciIdeChannelEnabled (fdoExtension, channel);

                if (pdoExtension) {

                    //
                    // already got a DeviceObject for this channel
                    //
                    if (channelState == ChannelDisabled) {

                        ULONG pdoState;

                        pdoState = ChannelUpdatePdoState (
                                      pdoExtension,
                                      PDOS_DEADMEAT,
                                      0
                                      );
                    } else {

                        deviceObjectToReturn = pdoExtension->DeviceObject;
                    }

                } else if ((channelState == ChannelEnabled) ||
                           ((channelState == ChannelStateUnknown) && reportUnknownAsNewChild)) {

                    if (!fdoExtension->NativeMode[channel]) {

                        if (channel == 0) {

                            configurationInformation->AtDiskPrimaryAddressClaimed = TRUE;

                        } else {

                            configurationInformation->AtDiskSecondaryAddressClaimed = TRUE;
                        }
                    }

                    //
                    // Remove this when pnp mgr can deal with pdo with no names
                    //
                    nextUniqueNumber = InterlockedIncrement(&PciIdeXNextChannelNumber) - 1;
                    swprintf(deviceNameBuffer, DEVICE_OJBECT_BASE_NAME  L"\\PciIde%dChannel%d-%x", fdoExtension->ControllerNumber, channel, nextUniqueNumber);
                    RtlInitUnicodeString (&deviceName, deviceNameBuffer);

                    status = IoCreateDevice(
                                fdoExtension->DriverObject, // our driver object
                                sizeof(CHANPDO_EXTENSION),  // size of our extension
                                &deviceName,                // our name
                                FILE_DEVICE_CONTROLLER,     // device type
                                FILE_DEVICE_SECURE_OPEN,    // device characteristics
                                FALSE,                      // not exclusive
                                &deviceObject       // store new device object here
                                );

                    if (NT_SUCCESS(status)) {

                        pdoExtension = (PCHANPDO_EXTENSION) deviceObject->DeviceExtension;
                        RtlZeroMemory (pdoExtension, sizeof(CHANPDO_EXTENSION));

                        pdoExtension->DeviceObject          = deviceObject;
                        pdoExtension->DriverObject          = fdoExtension->DriverObject;
                        pdoExtension->ParentDeviceExtension = fdoExtension;
                        pdoExtension->ChannelNumber         = channel;

                        //
                        // Dispatch Table
                        //
                        pdoExtension->DefaultDispatch        = NoSupportIrp;
                        pdoExtension->PnPDispatchTable       = PdoPnpDispatchTable;
                        pdoExtension->PowerDispatchTable     = PdoPowerDispatchTable;
                        pdoExtension->WmiDispatchTable       = PdoWmiDispatchTable;

                        KeInitializeSpinLock(&pdoExtension->SpinLock);

                        fdoExtension->ChildDeviceExtension[channel]   = pdoExtension;

                        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

                        fdoExtension->NumberOfChildren++;

                        InterlockedIncrement(&fdoExtension->NumberOfChildrenPowerUp);

                        //
                        // fix up alignment requirement
                        // check with the miniport also
                        //
                        deviceObject->AlignmentRequirement = fdoExtension->ControllerProperties.AlignmentRequirement;
                        if (deviceObject->AlignmentRequirement < fdoExtension->AttacheeDeviceObject->AlignmentRequirement) {
                            deviceObject->AlignmentRequirement = 
                                        fdoExtension->DeviceObject->AlignmentRequirement;
                        }

                        if (deviceObject->AlignmentRequirement < 1) {
                            deviceObject->AlignmentRequirement = 1;
                        }


                        //
                        // return this new DeviceObject
                        //
                        deviceObjectToReturn = deviceObject;
                    }
                }

                if (deviceObjectToReturn) {

                    deviceRelations->Objects[(deviceRelations)->Count] = deviceObjectToReturn;

                    ObReferenceObjectByPointer(deviceObjectToReturn,
                                               0,
                                               0,
                                               KernelMode);

                    deviceRelations->Count++;
                }
            }
        }

        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
        Irp->IoStatus.Status = status;
        break;

    default:
        status=STATUS_SUCCESS;
        DebugPrint ((1, "PciIdeQueryDeviceRelations: Unsupported device relation\n"));
        break;
    }

    if (NT_SUCCESS(status)) {

        IoSkipCurrentIrpStackLocation ( Irp );
        return IoCallDriver(fdoExtension->AttacheeDeviceObject, Irp);

    } else {

        //
        //Complete the request
        //
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }
} // ControllerQueryDeviceRelations

NTSTATUS
ControllerQueryInterface (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION    thisIrpSp;
    PCTRLFDO_EXTENSION    fdoExtension;
    NTSTATUS              status;
    PTRANSLATOR_INTERFACE translator;
    ULONG                 busNumber;

    PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    fdoExtension = (PCTRLFDO_EXTENSION) DeviceObject->DeviceExtension;
    status = Irp->IoStatus.Status;

    if (RtlEqualMemory(&GUID_TRANSLATOR_INTERFACE_STANDARD,
                       thisIrpSp->Parameters.QueryInterface.InterfaceType,
                       sizeof(GUID))
     && (thisIrpSp->Parameters.QueryInterface.Size >=
        sizeof(TRANSLATOR_INTERFACE))
     && (PtrToUlong(thisIrpSp->Parameters.QueryInterface.InterfaceSpecificData) ==
        CmResourceTypeInterrupt)) {

        if (!fdoExtension->NativeMode[0] && !fdoExtension->NativeMode[1]) {

            //
            // we only return a translator only if we are legacy controller
            //
            status = HalGetInterruptTranslator(
                        PCIBus,
                        0,
                        InterfaceTypeUndefined, // special "IDE" cookie
                        thisIrpSp->Parameters.QueryInterface.Size,
                        thisIrpSp->Parameters.QueryInterface.Version,
                        (PTRANSLATOR_INTERFACE) thisIrpSp->Parameters.QueryInterface.Interface,
                        &busNumber
                        );
        }
    }

    //
    // Pass down.
    //

    Irp->IoStatus.Status = status;
    IoSkipCurrentIrpStackLocation ( Irp );
    return IoCallDriver(fdoExtension->AttacheeDeviceObject, Irp);
} // ControllerQueryInterface

//
// initialize PCTRLFDO_EXTENSION->PCM_PARTIAL_RESOURCE_DESCRIPTOR(s)
//
NTSTATUS
AnalyzeResourceList (
    PCTRLFDO_EXTENSION FdoExtension,
    PCM_RESOURCE_LIST  ResourceList
    )
{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    ULONG                           i;
    ULONG                           j;
    ULONG                           k;
    ULONG                           cmdChannel;
    ULONG                           ctrlChannel;
    ULONG                           intrChannel;
    ULONG                           bmAddr;

    ULONG                           pdoResourceListSize;
    PCM_RESOURCE_LIST               pdoResourceList[MAX_IDE_CHANNEL];
    PCM_FULL_RESOURCE_DESCRIPTOR    pdoFullResourceList[MAX_IDE_CHANNEL];
    PCM_PARTIAL_RESOURCE_LIST       pdoPartialResourceList[MAX_IDE_CHANNEL];
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pdoPartialDescriptors[MAX_IDE_CHANNEL];

    ULONG                           bmResourceListSize;
    PCM_RESOURCE_LIST               bmResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    bmFullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       bmPartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR bmPartialDescriptors;

    NTSTATUS                        status;

    PAGED_CODE();

    if (!ResourceList) {
        return STATUS_SUCCESS;
    }

    bmResourceListSize =
        sizeof (CM_RESOURCE_LIST) * ResourceList->Count; // This will have one CM_PARTIAL_RESOURCE_LIST

    bmResourceList = (PCM_RESOURCE_LIST) ExAllocatePool (NonPagedPool, bmResourceListSize);
    if (bmResourceList == NULL) {

        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory (bmResourceList, bmResourceListSize);

    pdoResourceListSize =
        sizeof (CM_RESOURCE_LIST) * ResourceList->Count + // This will have one CM_PARTIAL_RESOURCE_LIST
        sizeof (CM_PARTIAL_RESOURCE_LIST) * 2;

    for (i=0; i<MAX_IDE_CHANNEL; i++) {

        pdoResourceList[i] = (PCM_RESOURCE_LIST) ExAllocatePool (NonPagedPool, pdoResourceListSize);

        if (pdoResourceList[i] == NULL) {

            DebugPrint ((0, "Unable to allocate resourceList for PDOs\n"));

            for (j=0; j<i; j++) {

                ExFreePool (pdoResourceList[j]);
            }

            ExFreePool (bmResourceList);
            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory (pdoResourceList[i], pdoResourceListSize);
    }

    fullResourceList = ResourceList->List;

    bmResourceList->Count = 0;
    bmFullResourceList = bmResourceList->List;

    for (k=0; k<MAX_IDE_CHANNEL; k++) {

        pdoResourceList[k]->Count = 0;
        pdoFullResourceList[k] = pdoResourceList[k]->List;
    }

    cmdChannel = ctrlChannel = intrChannel = bmAddr = 0;
    for (j=0; j<ResourceList->Count; j++) {

        partialResourceList = &(fullResourceList->PartialResourceList);
        partialDescriptors  = partialResourceList->PartialDescriptors;

        RtlCopyMemory (
            bmFullResourceList,
            fullResourceList,
            FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR, PartialResourceList.PartialDescriptors)
            );

        bmPartialResourceList = &(bmFullResourceList->PartialResourceList);
        bmPartialResourceList->Count = 0;
        bmPartialDescriptors  = bmPartialResourceList->PartialDescriptors;

        for (k=0; k<MAX_IDE_CHANNEL; k++) {

            RtlCopyMemory (
                pdoFullResourceList[k],
                fullResourceList,
                FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR, PartialResourceList.PartialDescriptors)
                );

            pdoPartialResourceList[k] = &(pdoFullResourceList[k]->PartialResourceList);
            pdoPartialResourceList[k]->Count = 0;
            pdoPartialDescriptors[k]  = pdoPartialResourceList[k]->PartialDescriptors;

        }

        for (i=0; i<partialResourceList->Count; i++) {

            if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                 (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                 (partialDescriptors[i].u.Port.Length == 8) &&
                 (cmdChannel < MAX_IDE_CHANNEL)) {

                ASSERT (cmdChannel < MAX_IDE_CHANNEL);

                RtlCopyMemory (
                    pdoPartialDescriptors[cmdChannel] + pdoPartialResourceList[cmdChannel]->Count,
                    partialDescriptors + i,
                    sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR)
                    );

                pdoPartialResourceList[cmdChannel]->Count++;

                cmdChannel++;

            } else if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                        (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                        (partialDescriptors[i].u.Port.Length == 4) &&
                        (ctrlChannel < MAX_IDE_CHANNEL)) {

                ASSERT (ctrlChannel < MAX_IDE_CHANNEL);

                RtlCopyMemory (
                    pdoPartialDescriptors[ctrlChannel] + pdoPartialResourceList[ctrlChannel]->Count,
                    partialDescriptors + i,
                    sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR)
                    );

                pdoPartialResourceList[ctrlChannel]->Count++;

                ctrlChannel++;

            } else if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                        (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                        (partialDescriptors[i].u.Port.Length == 16) &&
                        (bmAddr < 1)) {

                ASSERT (bmAddr < 1);

                RtlCopyMemory (
                    bmPartialDescriptors + bmPartialResourceList->Count,
                    partialDescriptors + i,
                    sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR)
                    );

                bmPartialResourceList->Count++;

                bmAddr++;

            } else if ((partialDescriptors[i].Type == CmResourceTypeInterrupt) &&
                (intrChannel < MAX_IDE_CHANNEL)) {

                ASSERT (intrChannel < MAX_IDE_CHANNEL);

                RtlCopyMemory (
                    pdoPartialDescriptors[intrChannel] + pdoPartialResourceList[intrChannel]->Count,
                    partialDescriptors + i,
                    sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR)
                    );

                pdoPartialResourceList[intrChannel]->Count++;

                if (intrChannel == 0) {

                    if (FdoExtension->NativeMode[1]) {

                        intrChannel++;

                        //
						// ISSUE: 08/30/2000
                        // do I need to mark it sharable?
						// this needs to be revisited. (there are more issues)
                        //
                        RtlCopyMemory (
                            pdoPartialDescriptors[intrChannel] + pdoPartialResourceList[intrChannel]->Count,
                            partialDescriptors + i,
                            sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR)
                            );

                        pdoPartialResourceList[intrChannel]->Count++;
                    }
                }

                intrChannel++;

            } else if (partialDescriptors[i].Type == CmResourceTypeDeviceSpecific) {

                partialDescriptors += partialDescriptors[i].u.DeviceSpecificData.DataSize;
            }
        }

        if (bmPartialResourceList->Count) {

            bmResourceList->Count++;
            bmFullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR)
                (bmPartialDescriptors + bmPartialResourceList->Count);

        }

        for (k=0; k<MAX_IDE_CHANNEL; k++) {

            if (pdoPartialResourceList[k]->Count) {

                pdoResourceList[k]->Count++;
                pdoFullResourceList[k] = (PCM_FULL_RESOURCE_DESCRIPTOR)
                    (pdoPartialDescriptors[k] + pdoPartialResourceList[k]->Count);
            }
        }

        fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + i);
    }

    status = STATUS_SUCCESS;

    for (k=0; k<MAX_IDE_CHANNEL; k++) {

        if (FdoExtension->NativeMode[k]) {

            //
            // If the controller is in native mode, we should have all the resources
            //

            if ((k < cmdChannel) &&
                (k < ctrlChannel) &&
                (k < intrChannel)) {

                //
                // This is good
                //

            } else {

                cmdChannel  = 0;
                ctrlChannel = 0;
                intrChannel = 0;
                bmAddr      = 0;
                status      = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }


    //
    // If the controller is in legacy mode, we should not have any resources
    //
    if (!FdoExtension->NativeMode[0] && !FdoExtension->NativeMode[1]) {

        //
        // both channels in legacy mode
        //
        cmdChannel = 0;
        ctrlChannel = 0;
        intrChannel = 0;
    }


    FdoExtension->TranslatedBusMasterBaseAddress = NULL;
    if (0 < bmAddr) {

        FdoExtension->BmResourceList = bmResourceList;
        FdoExtension->BmResourceListSize = (ULONG)(((PUCHAR)bmFullResourceList) - ((PUCHAR)bmResourceList));

        if (FdoExtension->BmResourceList->List[0].PartialResourceList.PartialDescriptors->Type == CmResourceTypePort) {

            //
            // address is in i/o space
            //
            FdoExtension->TranslatedBusMasterBaseAddress =
                (PIDE_BUS_MASTER_REGISTERS) (ULONG_PTR)FdoExtension->BmResourceList->List[0].PartialResourceList.PartialDescriptors->u.Port.Start.QuadPart;
            FdoExtension->BusMasterBaseAddressSpace = IO_SPACE;

        } else if (FdoExtension->BmResourceList->List[0].PartialResourceList.PartialDescriptors->Type == CmResourceTypeMemory) {

            //
            // address is in memory space
            //
            FdoExtension->TranslatedBusMasterBaseAddress =
                (PIDE_BUS_MASTER_REGISTERS) MmMapIoSpace(
                                                FdoExtension->BmResourceList->List[0].PartialResourceList.PartialDescriptors->u.Port.Start,
                                                16,
                                                FALSE);
            ASSERT (FdoExtension->TranslatedBusMasterBaseAddress);

            // free mapped io resouces in stop/remove device
            // unmapiospace doesn't do anything. it is ok not to call it

            FdoExtension->BusMasterBaseAddressSpace = MEMORY_SPACE;

        } else {

            FdoExtension->TranslatedBusMasterBaseAddress = NULL;
            ASSERT (FALSE);
        }
    }

    if (FdoExtension->TranslatedBusMasterBaseAddress == NULL) {

        ExFreePool (bmResourceList);
        FdoExtension->BmResourceList = bmResourceList = NULL;
    }

    for (k=0; k<MAX_IDE_CHANNEL; k++) {

        if ((k < cmdChannel) ||
            (k < ctrlChannel) ||
            (k < intrChannel)) {

            FdoExtension->PdoResourceList[k] = pdoResourceList[k];
            FdoExtension->PdoResourceListSize[k] = (ULONG)(((PUCHAR)pdoFullResourceList[k]) - ((PUCHAR)pdoResourceList[k]));

            if (k < cmdChannel) {

                FdoExtension->PdoCmdRegResourceFound[k] = TRUE;
            }

            if (k < ctrlChannel) {

                FdoExtension->PdoCtrlRegResourceFound[k] = TRUE;
            }

            if (k < intrChannel) {

                FdoExtension->PdoInterruptResourceFound[k] = TRUE;
            }

        } else {

            ExFreePool (pdoResourceList[k]);
            FdoExtension->PdoResourceList[k] =
                pdoResourceList[k] = NULL;
        }

    }

    return status;
} // AnalyzeResourceList

VOID
ControllerOpMode (
    IN PCTRLFDO_EXTENSION FdoExtension
    )
{
    NTSTATUS    status;
    PCIIDE_CONFIG_HEADER pciIdeConfigHeader;

    PAGED_CODE();

    status = PciIdeBusData(
                 FdoExtension,
                 &pciIdeConfigHeader,
                 0,
                 sizeof (pciIdeConfigHeader),
                 TRUE
                 );

    FdoExtension->NativeMode[0] = FALSE;
    FdoExtension->NativeMode[1] = FALSE;

    if (NT_SUCCESS(status)) {

		//
		// ISSUE: 02/05/01: This should be removed. In pci we check for sublclass = 0x1
		// 
        if ((pciIdeConfigHeader.BaseClass == PCI_CLASS_MASS_STORAGE_CTLR) &&
            (pciIdeConfigHeader.SubClass == PCI_SUBCLASS_MSC_RAID_CTLR)) {

            //
            // We have a Promise Technology IDE "raid" controller
            //
            FdoExtension->NativeMode[0] = TRUE;
            FdoExtension->NativeMode[1] = TRUE;

        } else {

            if ((pciIdeConfigHeader.Chan0OpMode) &&
                (pciIdeConfigHeader.Chan1OpMode)) {

                //
                // we can't support a channel being legacy
                // and the other is in native because
                // we don't know what irq is for the native
                // channel
                //
                FdoExtension->NativeMode[0] = TRUE;
                FdoExtension->NativeMode[1] = TRUE;
            }
        }

        //
        // Have to be both TRUE or both FALSE
        //
        ASSERT ((FdoExtension->NativeMode[0] == FALSE) == (FdoExtension->NativeMode[1] == FALSE));
    }

    return;
} // ControllerOpMode

VOID
EnablePCIBusMastering (
    IN PCTRLFDO_EXTENSION FdoExtension
    )
{
    NTSTATUS             status;
    PCIIDE_CONFIG_HEADER pciIdeConfigHeader;

    status = PciIdeBusData(
                 FdoExtension,
                 &pciIdeConfigHeader,
                 0,
                 sizeof (PCIIDE_CONFIG_HEADER),
                 TRUE
                 );

    //
    // pci bus master disabled?
    //
    if (NT_SUCCESS(status) &&
        pciIdeConfigHeader.MasterIde &&
        !pciIdeConfigHeader.Command.b.MasterEnable) {

        //
        // Try to turn on pci bus mastering
        //
        pciIdeConfigHeader.Command.b.MasterEnable = 1;

        status = PciIdeBusData(
                     FdoExtension,
                     &pciIdeConfigHeader.Command.w,
                     FIELD_OFFSET (PCIIDE_CONFIG_HEADER, Command),
                     sizeof (pciIdeConfigHeader.Command.w),
                     FALSE
                     );
    }
    return;
} // EnablePCIBusMastering


#ifdef DBG
ULONG PciIdeXDebugFakeMissingChild = 0;
#endif // DBG

IDE_CHANNEL_STATE
PciIdeChannelEnabled (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN ULONG Channel
)
{
    NTSTATUS status;
    ULONG longMask;

    UCHAR channelEnableMask;
    ULONG channelEnablePciConfigOffset;
    UCHAR pciConfigData;

    PAGED_CODE();

#if DBG
    if (PciIdeXDebugFakeMissingChild & 0xff000000) {

        DebugPrint ((0, "PciIdeXDebugFakeMissingChild: fake missing channel 0x%x\n", Channel));

        if ((PciIdeXDebugFakeMissingChild & 0x0000ff) == Channel) {
    
            PciIdeXDebugFakeMissingChild = 0;
            return ChannelDisabled;
        }
    }
#endif


    longMask = 0;
    status = PciIdeXGetDeviceParameter (
               FdoExtension->AttacheePdo,
               ChannelEnableMaskName[Channel],
               &longMask
               );
    channelEnableMask = (UCHAR) longMask;

#if defined(_AMD64_SIMULATOR_)

    //
    // Use default values for an Intel controller which
    // is what the simulator is providing.
    //

    if (!NT_SUCCESS(status)) {
        channelEnableMask = 0x80;
        status = STATUS_SUCCESS;
    }

#endif

    if (!NT_SUCCESS(status)) {

        DebugPrint ((1, "PciIdeX: Unable to get ChannelEnableMask from the registry\n"));

    } else {

        channelEnablePciConfigOffset = 0;
        status = PciIdeXGetDeviceParameter (
                   FdoExtension->AttacheePdo,
                   ChannelEnablePciConfigOffsetName[Channel],
                   &channelEnablePciConfigOffset
                   );

#if defined(_AMD64_SIMULATOR_)

        //
        // See above
        //

        if (!NT_SUCCESS(status)) {

            if (Channel == 0) {
                channelEnablePciConfigOffset = 0x41;
            } else {
                channelEnablePciConfigOffset = 0x43;
            }
            status = STATUS_SUCCESS;
        }

#endif

        if (!NT_SUCCESS(status)) {

            DebugPrint ((1, "PciIdeX: Unable to get ChannelEnablePciConfigOffset from the registry\n"));

        } else {

            status = PciIdeBusData(
                         FdoExtension,
                         &pciConfigData,
                         channelEnablePciConfigOffset,
                         sizeof (pciConfigData),
                         TRUE                           // Read
                         );

            if (NT_SUCCESS(status)) {

                return (pciConfigData & channelEnableMask) ? ChannelEnabled : ChannelDisabled;
            }
        }
    }

    //
    // couldn't figure out whether is channel enabled
    // try the miniport port
    //
    if (FdoExtension->ControllerProperties.PciIdeChannelEnabled) {

        return FdoExtension->ControllerProperties.PciIdeChannelEnabled (
                   FdoExtension->VendorSpecificDeviceEntension,
                   Channel
                   );
    }

    return ChannelStateUnknown;
} // PciIdeChannelEnabled

NTSTATUS
PciIdeCreateTimingTable (
    IN PCTRLFDO_EXTENSION FdoExtension
    )
{
    PULONG timingTable;
    PWSTR regTimingList = NULL;
    ULONG i;
    ULONG temp;
    ULONG length = 0;
    NTSTATUS status; 

    PAGED_CODE();

    //
    // Try to procure the timing table from the registry
    //
    status = PciIdeXGetDeviceParameterEx (
               FdoExtension->AttacheePdo,
               L"TransferModeTiming",
               &(regTimingList)
               );

    //
    // Fill in the table entries
    //
    if (NT_SUCCESS(status) && regTimingList) {

        PWSTR string = regTimingList;
        UNICODE_STRING  unicodeString;

        i=0;

        while (string[0]) {

            RtlInitUnicodeString(
                &unicodeString,
                string
                );

            RtlUnicodeStringToInteger(&unicodeString,10, &temp);

            //
            // The first entry is the length of the table
            //
            if (i==0) {

                length = temp;
                ASSERT(length <=31);

                if (length > 31) {
                    length=temp=31;
                }

                //
                // The table should atleast be MAX_XFER_MODE long.
                // if not fill it up with 0s
                //
                if (temp < MAX_XFER_MODE) {
                    temp=MAX_XFER_MODE;
                }

                timingTable = ExAllocatePool(NonPagedPool, temp*sizeof(ULONG));
                if (timingTable == NULL) {

                    length = 0;
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;

                } else {

                    ULONG j;
                    //
                    // Initialize the known xferModes (default)
                    //
                    SetDefaultTiming(timingTable, j);

                    for (j=MAX_XFER_MODE; j<temp;j++) {
                        timingTable[j]=timingTable[MAX_XFER_MODE-1];
                    }
                }

            } else {

                if (i > length) {
                    DebugPrint((0, "Pciidex: Timing table overflow\n"));
                    break;
                }
                //
                // The timings (PIO0-...)
                // Use the default values if the cycletime is 0.
                //
                if (temp) {
                    timingTable[i-1]=temp;
                }
            }

            i++;
            string += (unicodeString.Length / sizeof(WCHAR)) + 1;
        }
        
        if (length < MAX_XFER_MODE) {
            length = MAX_XFER_MODE;
        }

        ExFreePool(regTimingList);

    } else {
        DebugPrint((1, "Pciidex: Unsuccessful regop status %x, regTimingList %x\n",
                    status, regTimingList));

        //
        // Nothing in the registry. Fill in the table with known transfer mode
        // timings.
        //
        status = STATUS_SUCCESS;
        timingTable=ExAllocatePool(NonPagedPool, MAX_XFER_MODE*sizeof(ULONG));

        if (timingTable == NULL) {
            length =0;
            status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            SetDefaultTiming(timingTable, length);
        }
    }

    FdoExtension->TransferModeTimingTable=timingTable;
    FdoExtension->TransferModeTableLength= length;

    /*
    for (i=0;i<FdoExtension->TransferModeTableLength;i++) {
        DebugPrint((0, "Table[%d]=%d\n", 
                    i,
                    FdoExtension->TransferModeTimingTable[i]));
    }
    */

    return status; 
}

VOID
PciIdeInitControllerProperties (
    IN PCTRLFDO_EXTENSION FdoExtension
    )
{
#if 1
    NTSTATUS status;
    PDRIVER_OBJECT_EXTENSION driverObjectExtension;
    ULONG                    i, j;

    PAGED_CODE();

    driverObjectExtension =
        (PDRIVER_OBJECT_EXTENSION) IoGetDriverObjectExtension(
                                       FdoExtension->DriverObject,
                                       DRIVER_OBJECT_EXTENSION_ID
                                       );
    ASSERT (driverObjectExtension);

    FdoExtension->ControllerProperties.Size = sizeof (IDE_CONTROLLER_PROPERTIES);

    FdoExtension->ControllerProperties.DefaultPIO = 0;
    status = (*driverObjectExtension->PciIdeGetControllerProperties) (
                 FdoExtension->VendorSpecificDeviceEntension,
                 &FdoExtension->ControllerProperties
                 );

    //
    // Look in the registry to determine whether
    // UDMA 66 should be enabled for INTEL chipsets
    //
    FdoExtension->EnableUDMA66 = 0;
    status = PciIdeXGetDeviceParameter (
               FdoExtension->AttacheePdo,
               L"EnableUDMA66",
               &(FdoExtension->EnableUDMA66)
               );

#else

    NTSTATUS status;
    PCIIDE_CONFIG_HEADER pciHeader;
    ULONG ultraDmaSupport;
    ULONG xferMode;
    ULONG i;
    ULONG j;

    PAGED_CODE();

    //
    // grab ultra dma flag from the registry
    //
    ultraDmaSupport = 0;
    status = PciIdeXGetDeviceParameter (
               FdoExtension,
               UltraDmaSupport,
               &ultraDmaSupport
               );

    //
    // grab ultra dma flag from the registry
    //
    status = PciIdeXGetBusData (
                 FdoExtension,
                 &pciHeader,
                 0,
                 sizeof (pciHeader)
                 );
    if (!NT_SUCCESS(status)) {

        //
        // could get the pci config data, fake it
        //
        pciHeader.MasterIde = 0;
        pciHeader.Command.b.MasterEnable = 0;
    }

    xferMode = PIO_SUPPORT;
    if (pciHeader.MasterIde && pciHeader.Command.b.MasterEnable) {

        xferMode |= SWDMA_SUPPORT | MWDMA_SUPPORT;

        if (ultraDmaSupport) {

            xferMode |= UDMA_SUPPORT;
        }
    }

    for (i=0; i<MAX_IDE_CHANNEL; i++) {
        for (i=0; i<MAX_IDE_DEVICE; i++) {

            FdoExtension->ControllerProperties.SupportedTransferMode[i][j] = xferMode;
        }
    }

#endif
} // PciIdeInitControllerProperties

NTSTATUS
ControllerUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCTRLFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;
    PULONG deviceUsageCount;

    ASSERT (DeviceObject);
    ASSERT (Irp);
    PAGED_CODE();

    fdoExtension = (PCTRLFDO_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT (fdoExtension);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging) {

        //
        // Adjust the paging path count for this device.
        //
        deviceUsageCount = &fdoExtension->PagingPathCount;

    } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation) {

        //
        // Adjust the paging path count for this device.
        //
        deviceUsageCount = &fdoExtension->HiberPathCount;

    } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile) {

        //
        // Adjust the paging path count for this device.
        //
        deviceUsageCount = &fdoExtension->CrashDumpPathCount;

    } else {

        deviceUsageCount = NULL;
        DebugPrint ((0,
                     "PCIIDEX: Unknown IRP_MN_DEVICE_USAGE_NOTIFICATION type: 0x%x\n",
                     irpSp->Parameters.UsageNotification.Type));
    }

    IoCopyCurrentIrpStackLocationToNext (Irp);

    IoSetCompletionRoutine (
        Irp,
        ControllerUsageNotificationCompletionRoutine,
        deviceUsageCount,
        TRUE,
        TRUE,
        TRUE);

    ASSERT(fdoExtension->AttacheeDeviceObject);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);

} // ControllerUsageNotification

NTSTATUS
ControllerUsageNotificationCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PCTRLFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;
    PULONG deviceUsageCount = Context;

    fdoExtension = (PCTRLFDO_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT (fdoExtension);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        if (deviceUsageCount) {

            IoAdjustPagingPathCount (
                deviceUsageCount,
                irpSp->Parameters.UsageNotification.InPath
                );
        }
    }

    return Irp->IoStatus.Status;
} // ControllerUsageNotificationCompletionRoutine


NTSTATUS
PciIdeGetBusStandardInterface(
    IN PCTRLFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine gets the bus iterface standard information from the PDO.

Arguments:

Return Value:

    NT status.

--*/
{
    KEVENT event;
    NTSTATUS status;
    PIRP irp;
    IO_STATUS_BLOCK ioStatusBlock;
    PIO_STACK_LOCATION irpStack;

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                        FdoExtension->AttacheeDeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        &event,
                                        &ioStatusBlock );

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation( irp );
    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack->Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_BUS_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Size = sizeof( BUS_INTERFACE_STANDARD );
    irpStack->Parameters.QueryInterface.Version = 1;
    irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->BusInterface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Initialize the status to error in case the ACPI driver decides not to
    // set it correctly.
    //

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    status = IoCallDriver(FdoExtension->AttacheeDeviceObject, irp);

    if (!NT_SUCCESS( status)) {

        return status;
    }

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
    }

    if (NT_SUCCESS(ioStatusBlock.Status)) {

        ASSERT (FdoExtension->BusInterface.SetBusData);
        ASSERT (FdoExtension->BusInterface.GetBusData);
    }

    return ioStatusBlock.Status;
}

NTSTATUS
ControllerQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCTRLFDO_EXTENSION fdoExtension;
    PPNP_DEVICE_STATE deviceState;

    fdoExtension = (PCTRLFDO_EXTENSION) DeviceObject->DeviceExtension;
 
    DebugPrint((2, "QUERY_DEVICE_STATE for FDOE 0x%x\n", fdoExtension));

    if(fdoExtension->PagingPathCount != 0) {
        deviceState = (PPNP_DEVICE_STATE) &(Irp->IoStatus.Information);
        SETMASK((*deviceState), PNP_DEVICE_NOT_DISABLEABLE);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoSkipCurrentIrpStackLocation (Irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
} // ControllerQueryPnPDeviceState

#ifdef ENABLE_NATIVE_MODE
NTSTATUS
ControllerInterruptControl (
	IN PCTRLFDO_EXTENSION 	FdoExtension,
	IN ULONG				Channel,
	IN ULONG 				Disconnect
	)
{
	NTSTATUS status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR irqPartialDescriptors;
    PCM_RESOURCE_LIST               resourceListForKeep = NULL;
	ULONG	i;

	status = STATUS_SUCCESS;


	if (Disconnect) {

		DebugPrint((1, "PciIdex: Interrupt control for %x - disconnect\n", Channel));
		
		//
		// Disconnect the ISR
		//
		if ( (FdoExtension->InterruptObject[Channel])) { 

			IoDisconnectInterrupt (
				FdoExtension->InterruptObject[Channel]
				);

			FdoExtension->InterruptObject[Channel] = 0;
		}


	} else  {

		//
		// connect the ISR
		//

		PPCIIDE_INTERRUPT_CONTEXT				context; 

		DebugPrint((1, "PciIdex: Interrupt control for %x - reconnect\n", Channel));

		irqPartialDescriptors = FdoExtension->IrqPartialDescriptors[Channel];

		if (!irqPartialDescriptors) {
			return STATUS_UNSUCCESSFUL;
		}

		//
		// Fill in the context
		//
		context = (PPCIIDE_INTERRUPT_CONTEXT) &(FdoExtension->InterruptContext[Channel]);
		context->DeviceExtension = (PVOID)FdoExtension;
		context->ChannelNumber = Channel;

        status = IoConnectInterrupt(&FdoExtension->InterruptObject[Channel],
                                    (PKSERVICE_ROUTINE) ControllerInterrupt,
                                    (PVOID) context,
                                    (PKSPIN_LOCK) NULL,
                                    irqPartialDescriptors->u.Interrupt.Vector,
                                    (KIRQL) irqPartialDescriptors->u.Interrupt.Level,
                                    (KIRQL) irqPartialDescriptors->u.Interrupt.Level,
                                    irqPartialDescriptors->Flags & CM_RESOURCE_INTERRUPT_LATCHED ? Latched : LevelSensitive,
                                    (BOOLEAN) (irqPartialDescriptors->ShareDisposition == CmResourceShareShared),
                                    irqPartialDescriptors->u.Interrupt.Affinity,
                                    FALSE);
    

        if (!NT_SUCCESS(status)) {
    
            DebugPrint((1, 
						"PciIde: Can't connect interrupt %d\n", 
						irqPartialDescriptors->u.Interrupt.Vector));

            FdoExtension->InterruptObject[Channel] = NULL;
        }
	}

	return status;
}

#define SelectDevice(BaseIoAddress, deviceNumber, additional) \
    WRITE_PORT_UCHAR ((BaseIoAddress)->DriveSelect, (UCHAR)((((deviceNumber) & 0x1) << 4) | 0xA0 | additional))

BOOLEAN
ControllerInterrupt(
    IN PKINTERRUPT Interrupt,
	PVOID Context
	)
{
	UCHAR statusByte;
	PPCIIDE_INTERRUPT_CONTEXT context = Context;
	PCTRLFDO_EXTENSION fdoExtension = context->DeviceExtension;
	ULONG channel = context->ChannelNumber;
	PIDE_REGISTERS_1 baseIoAddress1 = &(fdoExtension->BaseIoAddress1[channel]);
	BOOLEAN interruptCleared = FALSE;

	DebugPrint((1, "Pciidex: ISR called for channel %d\n", channel));

	//
	// Check if the interrupts are enabled.
	// Don't enable the interrupts if both the isrs are not installed
	//
	if (!fdoExtension->NativeInterruptEnabled) {

		if (fdoExtension->ControllerIsrInstalled) {

			//
			// we have just connected the ISRs. At this point we don't know whether
			// we actually enabled the decodes or not. So enable the decodes and set the
			// flag
			//
			//
			// if this fails we already bugchecked.
			//
			ControllerEnableInterrupt(fdoExtension);

			fdoExtension->NativeInterruptEnabled = TRUE;

		} else {

			// 
			// cannot be us
			//
			return FALSE;
		}

	} else {

		if (!fdoExtension->ControllerIsrInstalled) {

			//
			// At this point we don't know whether the decodes are disabled or not. We should
			// enable them.
			//
			//
			// if this fails we already bugchecked.
			//
			ControllerEnableInterrupt(fdoExtension);

			//
			// Now fall thru and determine whether it is our interrupt.
			// we will disable the decodes after that.
			//
		} else {

			//
			// all is well. Go process the interrupt.
			//
		}
	}


	//
	// Both the ISRs should be installed and the interrupts should
	// be enabled at this point
	//
	ASSERT(fdoExtension->NativeInterruptEnabled);

	// ControllerIsrInstalled need not be set.
	// if we get called, then it means that we are still connected
	// however, if the flag ControllerIsrInstalled is not set, then it is
	// safe to assume that we are in the process of stopping the controller.
	// Just dismiss the interrupt, the normal way. We are yet to turn off the decodes.
	//

    //
    // Clear interrupt by reading status.
    //
    GetStatus(baseIoAddress1, statusByte);

	//
	// Check the Bus master registers
	//
	if (!fdoExtension->NoBusMaster[channel]) {

		BMSTATUS bmStatus;
		PIDE_BUS_MASTER_REGISTERS   bmRegister;

		//
		// Get the correct bus master register
		//
		bmRegister = (PIDE_BUS_MASTER_REGISTERS)(((PUCHAR)fdoExtension->TranslatedBusMasterBaseAddress) + channel*8);

		bmStatus = READ_PORT_UCHAR (&bmRegister->Status);

		DebugPrint((1, "BmStatus = 0x%x\n", bmStatus));

		//
		// is Interrupt bit set?
		//
		if (bmStatus & BMSTATUS_INTERRUPT) {
			WRITE_PORT_UCHAR (&bmRegister->Command, 0x0);  // disable BM
			WRITE_PORT_UCHAR (&bmRegister->Status, BUSMASTER_INTERRUPT);  // clear interrupt BM
			interruptCleared = TRUE;
		}
	}
    
	DebugPrint((1, "ISR for %d returning %d\n", channel, interruptCleared?1:0));

	//
	// NativeInterruptEnabled should be set at this point
	//
	if (!fdoExtension->ControllerIsrInstalled) {

		// we are in the stop or remove code path where this flag has been cleared and
		// we are about to disconnect the ISR. Disable the decodes. 
		//
		ControllerDisableInterrupt(fdoExtension);

		//
		// we have dismissed our interrupt. Now clear the interruptEnabled flag.
		//
		fdoExtension->NativeInterruptEnabled = FALSE;

		//
		// return InterruptCleared.
		// 
	}
	return interruptCleared;
}

/***
NTSTATUS
ControllerEnableDecode(
	IN PCTRLFDO_EXTENSION 	FdoExtension,
	IN BOOLEAN			Enable
	)
{
	USHORT cmd;
	NTSTATUS status;
    PCIIDE_CONFIG_HEADER pciIdeConfigHeader;

    status = PciIdeBusData(
                 FdoExtension,
                 &pciIdeConfigHeader,
                 0,
                 sizeof (PCIIDE_CONFIG_HEADER),
                 TRUE
                 );

    //
    // get pci command register
    //
    if (!NT_SUCCESS(status)) {

		return status;
	}

    cmd = pciIdeConfigHeader.Command.w;

    cmd &= ~(PCI_ENABLE_IO_SPACE |
             PCI_ENABLE_MEMORY_SPACE |
             PCI_ENABLE_BUS_MASTER);

    if (Enable) {

        //
        // Set enables
        //

        cmd |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE | PCI_ENABLE_BUS_MASTER);
    }

    //
    // Set the new command register into the device.
    //
	status = PciIdeBusData(
				 FdoExtension,
				 &cmd,
				 FIELD_OFFSET (PCIIDE_CONFIG_HEADER, Command),
				 sizeof (pciIdeConfigHeader.Command.w),
				 FALSE
				 );

	return status;
}
**/

NTSTATUS
PciIdeGetNativeModeInterface(
    IN PCTRLFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine gets the native ide iterface information from the PDO.

Arguments:

Return Value:

    NT status.

--*/
{
    KEVENT event;
    NTSTATUS status;
    PIRP irp;
    IO_STATUS_BLOCK ioStatusBlock;
    PIO_STACK_LOCATION irpStack;

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                        FdoExtension->AttacheeDeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        &event,
                                        &ioStatusBlock );

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation( irp );
    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack->Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCI_NATIVE_IDE_INTERFACE;
    irpStack->Parameters.QueryInterface.Size = sizeof( PCI_NATIVE_IDE_INTERFACE );
    irpStack->Parameters.QueryInterface.Version = 1;
    irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->NativeIdeInterface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Initialize the status to error in case the ACPI driver decides not to
    // set it correctly.
    //

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    status = IoCallDriver(FdoExtension->AttacheeDeviceObject, irp);

    if (!NT_SUCCESS( status)) {

        return status;
    }

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
    }

    if (NT_SUCCESS(ioStatusBlock.Status)) {

        ASSERT (FdoExtension->NativeIdeInterface.InterruptControl);
    }

    return ioStatusBlock.Status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\pciidex\chanpdo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chanpdo.h
//
//--------------------------------------------------------------------------

#if !defined (___chanpdo_h___)
#define ___chanpdo_h___


typedef enum BMSTATE {
    BmIdle,
    BmSet,
    BmArmed,
    BmDisarmed,
} BMSTATE;


#define PDOS_STARTED          (1 << 0)
#define PDOS_DEADMEAT         (1 << 1)
#define PDOS_STOPPED          (1 << 2)
#define PDOS_REMOVED          (1 << 3)
#define PDOS_SURPRISE_REMOVED (1 << 4)
#define PDOS_DISABLED_BY_USER (1 << 5)

typedef struct _PHYSICAL_REGION_DESCRIPTOR * PPHYSICAL_REGION_DESCRIPTOR;

typedef struct _CHANNEL_PDO_EXTENSION {

    EXTENSION_COMMON_HEADER;

    PCTRLFDO_EXTENSION  ParentDeviceExtension;

    ULONG               ChannelNumber;

    KSPIN_LOCK          SpinLock;
    ULONG               PdoState;

    DMADETECTIONLEVEL   DmaDetectionLevel;

    ULONG               RefCount;

    ULONG               PnPDeviceState;

    //
    // Busmaster Properties
    //
    PIDE_BUS_MASTER_REGISTERS   BmRegister;
    PDMA_ADAPTER                DmaAdapterObject;
    ULONG                       MaximumPhysicalPages;
    PPHYSICAL_REGION_DESCRIPTOR RegionDescriptorTable;
    PHYSICAL_ADDRESS            PhysicalRegionDescriptorTable;
    PVOID                       DataVirtualAddress;
    PSCATTER_GATHER_LIST        HalScatterGatherList;
    ULONG                       TransferLength;
    PVOID                       MapRegisterBase;
    PMDL                        Mdl;
    BOOLEAN                     DataIn;
    VOID                        (* BmCallback) (PVOID Context);
    PVOID                       BmCallbackContext;
    BMSTATE                     BmState;

    UCHAR                       BootBmStatus;

    BOOLEAN                     EmptyChannel;
    BOOLEAN                     NeedToCallIoInvalidateDeviceRelations;

} CHANPDO_EXTENSION, *PCHANPDO_EXTENSION;

PCHANPDO_EXTENSION
ChannelGetPdoExtension(
    PDEVICE_OBJECT DeviceObject
    );

ULONG
ChannelUpdatePdoState(
    PCHANPDO_EXTENSION PdoExtension,
    ULONG SetFlags,
    ULONG ClearFlags
    );

NTSTATUS
ChannelStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelQueryStopRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelStopChannel (
    PCHANPDO_EXTENSION pdoExtension
    );

NTSTATUS
ChannelQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

PWSTR
ChannelBuildDeviceId(
    IN PCHANPDO_EXTENSION pdoExtension
    );

PWSTR
ChannelBuildInstanceId(
    IN PCHANPDO_EXTENSION pdoExtension
    );

PWSTR
ChannelBuildCompatibleId(
    IN PCHANPDO_EXTENSION pdoExtension
    );

PWSTR
ChannelBuildHardwareId(
    IN PCHANPDO_EXTENSION pdoExtension
    );

NTSTATUS
ChannelQueryCapabitilies (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelQueryResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChannelQueryResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChannelQueryResourceRequirementsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
ChannelInternalDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
NTSTATUS
ChannelQueryText (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PciIdeChannelQueryInterface (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
NTSTATUS
PciIdeChannelTransferModeInterface (
    IN PCHANPDO_EXTENSION PdoExtension,
    PPCIIDE_XFER_MODE_INTERFACE XferMode
    );

NTSTATUS
PciIdeChannelTransferModeSelect (
    IN PCHANPDO_EXTENSION PdoExtension,
    PPCIIDE_TRANSFER_MODE_SELECT XferMode
    );
    
NTSTATUS
ChannelQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
                         
NTSTATUS
ChannelUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
            
NTSTATUS
ChannelQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
                         
VOID
PciIdeChannelRequestProperResources(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ChannelFilterResourceRequirements (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#ifdef ENABLE_NATIVE_MODE
NTSTATUS
PciIdeInterruptControl (
	IN PVOID Context,
	IN ULONG DisConnect
	);

NTSTATUS
PciIdeChannelInterruptInterface (
    IN PCHANPDO_EXTENSION PdoExtension,
    PPCIIDE_INTERRUPT_INTERFACE InterruptInterface
    );
#endif

#endif // ___chanpdo_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\pciidex\chanpdo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chanpdo.c
//
//--------------------------------------------------------------------------

#include "pciidex.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ChannelStartDevice)
#pragma alloc_text(PAGE, ChannelQueryStopRemoveDevice)
#pragma alloc_text(PAGE, ChannelRemoveDevice)
#pragma alloc_text(PAGE, ChannelStopDevice)
#pragma alloc_text(PAGE, ChannelStopChannel)
#pragma alloc_text(PAGE, ChannelQueryId)
#pragma alloc_text(PAGE, ChannelBuildDeviceId)
#pragma alloc_text(PAGE, ChannelBuildInstanceId)
#pragma alloc_text(PAGE, ChannelBuildCompatibleId)
#pragma alloc_text(PAGE, ChannelBuildHardwareId)
#pragma alloc_text(PAGE, ChannelQueryCapabitilies)
#pragma alloc_text(PAGE, ChannelQueryResources)
#pragma alloc_text(PAGE, ChannelQueryResourceRequirements)
#pragma alloc_text(PAGE, ChannelInternalDeviceIoControl)
#pragma alloc_text(PAGE, ChannelQueryText)
#pragma alloc_text(PAGE, PciIdeChannelQueryInterface)
#pragma alloc_text(PAGE, ChannelQueryDeviceRelations)
#pragma alloc_text(PAGE, ChannelUsageNotification)
#pragma alloc_text(PAGE, ChannelQueryPnPDeviceState)

#pragma alloc_text(NONPAGE, ChannelGetPdoExtension)
#pragma alloc_text(NONPAGE, ChannelUpdatePdoState)
#pragma alloc_text(NONPAGE, PciIdeChannelTransferModeSelect)
#pragma alloc_text(NONPAGE, PciIdeChannelTransferModeInterface)

#endif // ALLOC_PRAGMA


PCHANPDO_EXTENSION
ChannelGetPdoExtension(
    PDEVICE_OBJECT DeviceObject
    )
{
    KIRQL currentIrql;
    PCHANPDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension;
    PKSPIN_LOCK spinLock;


    spinLock = &pdoExtension->SpinLock;
    KeAcquireSpinLock(spinLock, &currentIrql);

    if ((pdoExtension->PdoState & PDOS_DEADMEAT) &&
        (pdoExtension->PdoState & PDOS_REMOVED)) {

        pdoExtension = NULL;
    }

    KeReleaseSpinLock(spinLock, currentIrql);

    return pdoExtension;
}

ULONG
ChannelUpdatePdoState(
    PCHANPDO_EXTENSION PdoExtension,
    ULONG SetFlags,
    ULONG ClearFlags
    )
{
    ULONG pdoState;
    KIRQL currentIrql;

    ASSERT (PdoExtension);

    KeAcquireSpinLock(&PdoExtension->SpinLock, &currentIrql);

    SETMASK (PdoExtension->PdoState, SetFlags);
    CLRMASK (PdoExtension->PdoState, ClearFlags);
    pdoState = PdoExtension->PdoState;

    KeReleaseSpinLock(&PdoExtension->SpinLock, currentIrql);

    return pdoState;
}



NTSTATUS
ChannelStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCHANPDO_EXTENSION pdoExtension;
    NTSTATUS status;
    IDE_CHANNEL_STATE channelState;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        status = STATUS_SUCCESS;

        //
        // always keep native mode started
        //

        if (pdoExtension->ParentDeviceExtension->
            NativeMode[pdoExtension->ChannelNumber] == FALSE) {

            channelState = PciIdeChannelEnabled (
                               pdoExtension->ParentDeviceExtension,
                               pdoExtension->ChannelNumber
                               );
            //
            // ISSUE: we should free the resources assigned.
            //
            //ASSERT(channelState != ChannelDisabled);

            if (channelState == ChannelStateUnknown) {

                //
                // we don't really know if this channel
                // is acutally enabled
                //
                // we will do our empty channel test
                //

                PIO_STACK_LOCATION thisIrpSp;
                IDE_RESOURCE ideResource;
                PCM_PARTIAL_RESOURCE_DESCRIPTOR irqPartialDescriptors;
                IDE_REGISTERS_1  baseIoAddress1;
                IDE_REGISTERS_2  baseIoAddress2;
                ULONG baseIoAddressLength1;
                ULONG baseIoAddressLength2;
                ULONG maxIdeDevice;
                PCM_RESOURCE_LIST resourceList;

                thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

                //
                // legacy mode channel gets its the start device irp
                //
                resourceList = thisIrpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

                status = DigestResourceList (
                             &ideResource,
                             resourceList,
                             &irqPartialDescriptors
                             );

                if (NT_SUCCESS(status)) {

                    AtapiBuildIoAddress (
                        ideResource.TranslatedCommandBaseAddress,
                        ideResource.TranslatedControlBaseAddress,
                        &baseIoAddress1,
                        &baseIoAddress2,
                        &baseIoAddressLength1,
                        &baseIoAddressLength2,
                        &maxIdeDevice,
                        NULL
                        );

                    if (IdePortChannelEmpty (
                            &baseIoAddress1,
                            &baseIoAddress2,
                            maxIdeDevice)) {

                        //
                        // upgrade its state to "disabled"
                        //
                        channelState = ChannelDisabled;

                    } else {

                        channelState = ChannelEnabled;
                    }

                    //
                    // don't need the io resource anymore
                    // unmap io space if nesscessary
                    //
                    if ((ideResource.CommandBaseAddressSpace == MEMORY_SPACE) &&
                        (ideResource.TranslatedCommandBaseAddress)) {

                        MmUnmapIoSpace (
                            ideResource.TranslatedCommandBaseAddress,
                            baseIoAddressLength1
                            );
                    }
                    if ((ideResource.ControlBaseAddressSpace == MEMORY_SPACE) &&
                        (ideResource.TranslatedControlBaseAddress)) {

                        MmUnmapIoSpace (
                            ideResource.TranslatedControlBaseAddress,
                            baseIoAddressLength2
                            );
                    }

                }
                if (channelState == ChannelDisabled) {

                    pdoExtension->EmptyChannel = TRUE;

                    //
                    // channel looks empty
                    // change our resource requirement to free our irq for other devices
                    //
                    if (irqPartialDescriptors) {
                        SETMASK (pdoExtension->PnPDeviceState, PNP_DEVICE_FAILED | PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED);
                        IoInvalidateDeviceState (DeviceObject);
                    }
                } else {

                    pdoExtension->EmptyChannel = FALSE;
                }
            }
        }

        if (NT_SUCCESS(status)) {

            //
            // grab the DmaDetectionLevel from the registry
            // default is DdlFirmwareOk
            //
            pdoExtension->DmaDetectionLevel = DdlFirmwareOk;
            status = PciIdeXGetDeviceParameter (
                       pdoExtension->DeviceObject,
                       DMA_DETECTION_LEVEL_REG_KEY,
                       (PULONG)&pdoExtension->DmaDetectionLevel
                       );

            status = BusMasterInitialize (pdoExtension);
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // get the firmware initialized DMA capable bits
        //
        if (pdoExtension->BmRegister) {

            pdoExtension->BootBmStatus = READ_PORT_UCHAR (&pdoExtension->BmRegister->Status);
        }

        ChannelUpdatePdoState (
            pdoExtension,
            PDOS_STARTED,
            PDOS_DEADMEAT | PDOS_STOPPED | PDOS_REMOVED
            );

    }


#if DBG
    {
       ULONG data;
       USHORT vendorId =0;
       USHORT deviceId = 0;
       PVOID deviceExtension;

       data = 0;
       deviceExtension = pdoExtension->ParentDeviceExtension->VendorSpecificDeviceEntension;

       PciIdeXGetBusData (
           deviceExtension,
           &vendorId,
           FIELD_OFFSET(PCI_COMMON_CONFIG, VendorID),
           sizeof(vendorId)
           );

       PciIdeXGetBusData (
           deviceExtension,
           &deviceId,
           FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceID),
           sizeof(deviceId)
           );

       if (vendorId == 0x8086) {

           data = 0;
           PciIdeXGetBusData (
               deviceExtension,
               &data,
               0x40,    // IDETIM0
               2
               );

            PciIdeXSaveDeviceParameter (
                deviceExtension,
                L"Old IDETIM0",
                data
                );

            data = 0;
            PciIdeXGetBusData (
                deviceExtension,
                &data,
                0x42,    // IDETIM1
                2
                );

             PciIdeXSaveDeviceParameter (
                 deviceExtension,
                 L"Old IDETIM1",
                 data
                 );

            if (deviceId != 0x1230) {       // !PIIX

                data = 0;
                PciIdeXGetBusData (
                    deviceExtension,
                    &data,
                    0x44,
                    1
                    );

                PciIdeXSaveDeviceParameter (
                    deviceExtension,
                    L"Old SIDETIM",
                    data
                    );
            }

            if (deviceId == 0x7111) {

                USHORT t;

                data = 0;
                PciIdeXGetBusData (
                    deviceExtension,
                    &data,
                    0x48,
                    1
                    );

                PciIdeXSaveDeviceParameter (
                    deviceExtension,
                    L"Old SDMACTL",
                    data
                    );

                data = 0;
                PciIdeXGetBusData (
                    deviceExtension,
                    &data,
                    0x4a, //SDMATIM0
                    1
                    );

                PciIdeXSaveDeviceParameter (
                    deviceExtension,
                    L"Old SDMATIM0",
                    data
                    );

                data = 0;
                PciIdeXGetBusData (
                    deviceExtension,
                    &data,
                    0x4b, //SDMATIM1
                    1
                    );

                PciIdeXSaveDeviceParameter (
                    deviceExtension,
                    L"Old SDMATIM1",
                    data
                    );
            }
       }
    }
#endif // DBG



    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
} // ChannelStartDevice

NTSTATUS
ChannelQueryStopRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS           status;
    PCHANPDO_EXTENSION pdoExtension;

    pdoExtension = ChannelGetPdoExtension(DeviceObject);

    if (pdoExtension) {

        //
        // Check the paging path count for this device.
        //

        if (pdoExtension->PagingPathCount ||
            pdoExtension->CrashDumpPathCount) {
            status = STATUS_UNSUCCESSFUL;
        } else {
            status = STATUS_SUCCESS;
        }

    } else {

        status = STATUS_NO_SUCH_DEVICE;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

} // ChannelQueryStopRemoveDevice

NTSTATUS
ChannelRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCHANPDO_EXTENSION pdoExtension;
    NTSTATUS status;
    PDEVICE_OBJECT AttacheePdo;
    BOOLEAN removeFromParent;
    BOOLEAN callIoDeleteDevice;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension) {

        PIO_STACK_LOCATION thisIrpSp;
        ULONG actionFlag;

        thisIrpSp = IoGetCurrentIrpStackLocation(Irp);

        status = ChannelStopChannel (pdoExtension);
        ASSERT (NT_SUCCESS(status));

        if (thisIrpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {

            if (pdoExtension->PdoState & PDOS_DEADMEAT) {

               actionFlag = PDOS_REMOVED;
               removeFromParent = TRUE;
               callIoDeleteDevice = TRUE;

            } else {
               actionFlag = PDOS_DISABLED_BY_USER;
               removeFromParent = FALSE;
               callIoDeleteDevice = FALSE;
            }

        } else {

            actionFlag = PDOS_SURPRISE_REMOVED;
            removeFromParent = FALSE;
            callIoDeleteDevice = FALSE;
        }

        ChannelUpdatePdoState (
            pdoExtension,
            actionFlag,
            PDOS_STARTED | PDOS_STOPPED
            );

        if (removeFromParent) {

            PCTRLFDO_EXTENSION  fdoExtension;

            fdoExtension = pdoExtension->ParentDeviceExtension;

            fdoExtension->ChildDeviceExtension[pdoExtension->ChannelNumber] = NULL;

            if (callIoDeleteDevice) {

                IoDeleteDevice (pdoExtension->DeviceObject);
            }
        }

        if (pdoExtension->NeedToCallIoInvalidateDeviceRelations) {

            pdoExtension->NeedToCallIoInvalidateDeviceRelations = FALSE;
            IoInvalidateDeviceRelations (
                pdoExtension->ParentDeviceExtension->AttacheePdo,
                BusRelations
                );
        }

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_NO_SUCH_DEVICE;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
} // ChannelRemoveDevice

NTSTATUS
ChannelStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCHANPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        status = ChannelStopChannel (pdoExtension);
        ASSERT (NT_SUCCESS(status));

        ChannelUpdatePdoState (
            pdoExtension,
            PDOS_STOPPED,
            PDOS_STARTED
            );

        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
} // ChannelRemoveDevice

NTSTATUS
ChannelStopChannel (
    PCHANPDO_EXTENSION PdoExtension
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = BusMasterUninitialize (PdoExtension);
    ASSERT (NT_SUCCESS(status));

    return STATUS_SUCCESS;
} // ChannelStopChannel


NTSTATUS
ChannelQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PCHANPDO_EXTENSION  pdoExtension;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PWSTR idString = NULL;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
        switch (thisIrpSp->Parameters.QueryId.IdType) {

            case BusQueryDeviceID:

                //
                // Caller wants the bus ID of this device.
                //

                idString = ChannelBuildDeviceId (pdoExtension);
                break;

            case BusQueryInstanceID:

                //
                // Caller wants the unique id of the device
                //

                idString = ChannelBuildInstanceId (pdoExtension);
                break;

            case BusQueryCompatibleIDs:

                //
                // Caller wants the unique id of the device
                //

                idString = ChannelBuildCompatibleId (pdoExtension);
                break;

            case BusQueryHardwareIDs:

                //
                // Caller wants the unique id of the device
                //

                idString = ChannelBuildHardwareId (pdoExtension);
                break;

            default:
                idString = NULL;
                DebugPrint ((1, "pciide: QueryID type %d not supported\n", thisIrpSp->Parameters.QueryId.IdType));
                status = STATUS_NOT_SUPPORTED;
                break;
        }
    }

    if( idString != NULL ){
        Irp->IoStatus.Information = (ULONG_PTR) idString;
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // ChannelQueryId

PWSTR
ChannelBuildDeviceId(
    IN PCHANPDO_EXTENSION pdoExtension
    )
{
    PWSTR       idString;
    ULONG       idStringBufLen;
    NTSTATUS    status;
    WCHAR       deviceIdFormat[] = L"PCIIDE\\IDEChannel";

    PAGED_CODE();

    idStringBufLen = ( wcslen( deviceIdFormat ) + 1 ) * sizeof( WCHAR );
    idString = ExAllocatePool( PagedPool, idStringBufLen );
    if( idString == NULL ){

        return NULL;
    }

    //
    // Form the string and return it.
    //

    swprintf( idString,
              deviceIdFormat);

    return idString;
} // ChannelBuildDeviceId

PWSTR
ChannelBuildInstanceId(
    IN PCHANPDO_EXTENSION pdoExtension
    )
{
    PWSTR       idString;
    ULONG       idStringBufLen;
    NTSTATUS    status;
    WCHAR       instanceIdFormat[] = L"%d";

    PAGED_CODE();

    idStringBufLen = 10 * sizeof( WCHAR );
    idString = ExAllocatePool (PagedPool, idStringBufLen);
    if( idString == NULL ){

        return NULL;
    }

    //
    // Form the string and return it.
    //

    swprintf( idString,
              instanceIdFormat,
              pdoExtension->ChannelNumber);

    return idString;
} // ChannelBuildInstanceId

//
// Multi-string Compatible IDs
//
WCHAR ChannelCompatibleId[] = {
    L"*PNP0600"
    };
//
// internal Compatible IDs
//
PWCHAR ChannelInternalCompatibleId[MAX_IDE_CHANNEL] = {
    L"Primary_IDE_Channel",
    L"Secondary_IDE_Channel"
    };

PWSTR
ChannelBuildCompatibleId(
    IN PCHANPDO_EXTENSION pdoExtension
    )
{
    PWSTR idString;
    ULONG idStringBufLen;
    ULONG i;

    PAGED_CODE();

    idStringBufLen = sizeof(ChannelCompatibleId);
    idString = ExAllocatePool (PagedPool, idStringBufLen + sizeof (WCHAR) * 2);
    if( idString == NULL ){

        return NULL;
    }

    RtlCopyMemory (
        idString,
        ChannelCompatibleId,
        idStringBufLen
        );
    idString[idStringBufLen/2 + 0] = L'\0';
    idString[idStringBufLen/2 + 1] = L'\0';

    return idString;
} // ChannelBuildCompatibleId

PWSTR
ChannelBuildHardwareId(
    IN PCHANPDO_EXTENSION pdoExtension
    )
{
    NTSTATUS status;

    struct {
        USHORT  VendorId;
        USHORT  DeviceId;
    } hwRawId;

    PWSTR vendorIdString;
    PWSTR deviceIdString;
    WCHAR vendorId[10];
    WCHAR deviceId[10];

    PWSTR idString;
    ULONG idStringBufLen;

    ULONG stringLen;
    ULONG internalIdLen;

    PAGED_CODE();

    status = PciIdeBusData (
                 pdoExtension->ParentDeviceExtension,
                 &hwRawId,
                 0,
                 sizeof (hwRawId),
                 TRUE
                 );
    if (!NT_SUCCESS(status)) {

        return NULL;
    }

    vendorIdString = NULL;
    deviceIdString = NULL;

    switch (hwRawId.VendorId) {
        case 0x8086:
            vendorIdString = L"Intel";

            switch (hwRawId.DeviceId) {

                case 0x1230:
                    deviceIdString = L"PIIX";
                    break;

                case 0x7010:
                    deviceIdString = L"PIIX3";
                    break;

                case 0x7111:
                    deviceIdString = L"PIIX4";
                    break;
            }
            break;

        case 0x1095:
            vendorIdString = L"CMD";
            break;

        case 0x10b9:
            vendorIdString = L"ALi";
            break;

        case 0x1039:
            vendorIdString = L"SiS";
            break;

        case 0x0e11:
            vendorIdString = L"Compaq";
            break;

        case 0x10ad:
            vendorIdString = L"WinBond";
            break;
    }

    if (vendorIdString == NULL) {

        swprintf (vendorId,
                  L"%04x",
                  hwRawId.VendorId);

        vendorIdString = vendorId;
    }

    if (deviceIdString == NULL) {

        swprintf (deviceId,
                  L"%04x",
                  hwRawId.DeviceId);

        deviceIdString = deviceId;
    }

    idStringBufLen = (256 * sizeof (WCHAR));
    idStringBufLen += sizeof(ChannelCompatibleId);
    idString = ExAllocatePool( PagedPool, idStringBufLen);
    if( idString == NULL ){

        return NULL;
    }

    //
    // Form the string and return it.
    //
    swprintf (idString,
              L"%ws-%ws",
              vendorIdString,
              deviceIdString
              );
    stringLen = wcslen(idString);
    idString[stringLen] = L'\0';
    stringLen++;

    //
    // internal HW id
    //
    internalIdLen = wcslen(ChannelInternalCompatibleId[pdoExtension->ChannelNumber]);
    RtlCopyMemory (
        idString + stringLen,
        ChannelInternalCompatibleId[pdoExtension->ChannelNumber],
        internalIdLen * sizeof (WCHAR)
        );
    stringLen += internalIdLen;
    idString[stringLen] = L'\0';
    stringLen++;

    //
    // generic HW id
    //
    RtlCopyMemory (
        idString + stringLen,
        ChannelCompatibleId,
        sizeof(ChannelCompatibleId)
        );
    stringLen += sizeof(ChannelCompatibleId) / sizeof(WCHAR);
    idString[stringLen] = L'\0';
    stringLen++;
    idString[stringLen] = L'\0';
    stringLen++;

    return idString;
} // ChannelBuildHardwareId

NTSTATUS
ChannelQueryCapabitilies (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION      thisIrpSp;
    PCHANPDO_EXTENSION      pdoExtension;
    PDEVICE_CAPABILITIES    capabilities;
    NTSTATUS                status;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        DEVICE_CAPABILITIES parentDeviceCapabilities;

        status = IdeGetDeviceCapabilities(
                     pdoExtension->ParentDeviceExtension->AttacheePdo,
                     &parentDeviceCapabilities);

        if (NT_SUCCESS(status)) {

            thisIrpSp    = IoGetCurrentIrpStackLocation( Irp );
            capabilities = thisIrpSp->Parameters.DeviceCapabilities.Capabilities;

            *capabilities = parentDeviceCapabilities;

            capabilities->UniqueID          = FALSE;
            capabilities->Address           = pdoExtension->ChannelNumber;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
} // ChannelQueryCapabitilies


NTSTATUS
ChannelQueryResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCHANPDO_EXTENSION              pdoExtension;
    PCTRLFDO_EXTENSION              fdoExtension;
    PIO_STACK_LOCATION              thisIrpSp;
    NTSTATUS                        status;
    ULONG                           resourceListSize;
    PCM_RESOURCE_LIST               resourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    IDE_CHANNEL_STATE 				channelState;

    PAGED_CODE();

    resourceList = NULL;
    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
        fdoExtension = pdoExtension->ParentDeviceExtension;

        if (fdoExtension->NativeMode[pdoExtension->ChannelNumber]) {

            //
            // Don't make up resources for native mode controller
            // PCI bus driver should find them all
            //
            resourceList = NULL;
            status = STATUS_SUCCESS;
            goto GetOut;
        }

		//
		// Don't claim resources if the channel is disabled
		//
        channelState = PciIdeChannelEnabled (
										pdoExtension->ParentDeviceExtension,
										pdoExtension->ChannelNumber
										);
		if (channelState == ChannelDisabled) {

			resourceList = NULL;
			status = STATUS_SUCCESS;
			goto GetOut;
		}

        //
        // TEMP CODE for the time without a real PCI driver.
		// Actually pciidex should do this
        //

        resourceListSize = sizeof (CM_RESOURCE_LIST) - sizeof (CM_FULL_RESOURCE_DESCRIPTOR) +
                             FULL_RESOURCE_LIST_SIZE(3);   // primary IO (2) + IRQ
        resourceList = ExAllocatePool (PagedPool, resourceListSize);
        if (resourceList == NULL) {
            status = STATUS_NO_MEMORY;
            goto GetOut;
        }

        RtlZeroMemory(resourceList, resourceListSize);

        resourceList->Count = 1;
        fullResourceList = resourceList->List;
        partialResourceList = &(fullResourceList->PartialResourceList);
        partialResourceList->Count = 0;
        partialDescriptors = partialResourceList->PartialDescriptors;

        fullResourceList->InterfaceType = Isa;
        fullResourceList->BusNumber = 0;

        if (pdoExtension->ChannelNumber == 0) {

            if (!fdoExtension->PdoCmdRegResourceFound[0]) {

                partialDescriptors[partialResourceList->Count].Type                  = CmResourceTypePort;
                partialDescriptors[partialResourceList->Count].ShareDisposition      = CmResourceShareDeviceExclusive;
                partialDescriptors[partialResourceList->Count].Flags                 = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                partialDescriptors[partialResourceList->Count].u.Port.Start.QuadPart = 0x1f0;
                partialDescriptors[partialResourceList->Count].u.Port.Length         = 8;

                partialResourceList->Count++;
            }

            if (!fdoExtension->PdoCtrlRegResourceFound[0]) {

                partialDescriptors[partialResourceList->Count].Type                  = CmResourceTypePort;
                partialDescriptors[partialResourceList->Count].ShareDisposition      = CmResourceShareDeviceExclusive;
                partialDescriptors[partialResourceList->Count].Flags                 = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                partialDescriptors[partialResourceList->Count].u.Port.Start.QuadPart = 0x3f6;
                partialDescriptors[partialResourceList->Count].u.Port.Length         = 1;

                partialResourceList->Count++;
            }

            if (!fdoExtension->PdoInterruptResourceFound[0]) {

                partialDescriptors[partialResourceList->Count].Type                  = CmResourceTypeInterrupt;
                partialDescriptors[partialResourceList->Count].ShareDisposition      = CmResourceShareDeviceExclusive;
                partialDescriptors[partialResourceList->Count].Flags                 = CM_RESOURCE_INTERRUPT_LATCHED;
                partialDescriptors[partialResourceList->Count].u.Interrupt.Level     = 14;
                partialDescriptors[partialResourceList->Count].u.Interrupt.Vector    = 14;
                partialDescriptors[partialResourceList->Count].u.Interrupt.Affinity  = 0x1;  // ISSUE: 08/28/2000: To be looked into.

                partialResourceList->Count++;
            }

        } else { // if (pdoExtension->ChannelNumber == 1)

            if (!fdoExtension->PdoCmdRegResourceFound[1]) {

                partialDescriptors[partialResourceList->Count].Type                  = CmResourceTypePort;
                partialDescriptors[partialResourceList->Count].ShareDisposition      = CmResourceShareDeviceExclusive;
                partialDescriptors[partialResourceList->Count].Flags                 = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                partialDescriptors[partialResourceList->Count].u.Port.Start.QuadPart = 0x170;
                partialDescriptors[partialResourceList->Count].u.Port.Length         = 8;

                partialResourceList->Count++;
            }

            if (!fdoExtension->PdoCtrlRegResourceFound[1]) {

                partialDescriptors[partialResourceList->Count].Type                  = CmResourceTypePort;
                partialDescriptors[partialResourceList->Count].ShareDisposition      = CmResourceShareDeviceExclusive;
                partialDescriptors[partialResourceList->Count].Flags                 = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                partialDescriptors[partialResourceList->Count].u.Port.Start.QuadPart = 0x376;
                partialDescriptors[partialResourceList->Count].u.Port.Length         = 1;

                partialResourceList->Count++;
            }

            if (!fdoExtension->PdoInterruptResourceFound[1]) {

                partialDescriptors[partialResourceList->Count].Type                  = CmResourceTypeInterrupt;
                partialDescriptors[partialResourceList->Count].ShareDisposition      = CmResourceShareDeviceExclusive;
                partialDescriptors[partialResourceList->Count].Flags                 = CM_RESOURCE_INTERRUPT_LATCHED;
                partialDescriptors[partialResourceList->Count].u.Interrupt.Level     = 15;
                partialDescriptors[partialResourceList->Count].u.Interrupt.Vector    = 15;
                partialDescriptors[partialResourceList->Count].u.Interrupt.Affinity  = 0x1;  // ISSUE: 08/28/2000: To be Looked into

                partialResourceList->Count++;
            }
        }

        if (!partialResourceList->Count) {

            ExFreePool (resourceList);
            resourceList = NULL;
        }

        status = STATUS_SUCCESS;
    }

GetOut:

    Irp->IoStatus.Information = (ULONG_PTR) resourceList;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // ChannelQueryResources

NTSTATUS
ChannelQueryResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION              thisIrpSp;
    PCHANPDO_EXTENSION              pdoExtension;
    PCTRLFDO_EXTENSION              fdoExtension;
    NTSTATUS                        status;

    PIO_RESOURCE_REQUIREMENTS_LIST  requirementsList;
    PIO_RESOURCE_LIST               resourceList;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptor;
    ULONG                           requirementsListSize;

    BOOLEAN                         reportIrq;
    IDE_CHANNEL_STATE 				channelState;

    PAGED_CODE();

    requirementsList = NULL;
    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
        fdoExtension = pdoExtension->ParentDeviceExtension;

        if (fdoExtension->NativeMode[pdoExtension->ChannelNumber]) {

            //
            // Don't make up resources for native mode controller
            // PCI bus driver should find them all
            //
            requirementsList = NULL;
            status = STATUS_SUCCESS;
            goto GetOut;
        }

        //
        // legacy controller
        //
        channelState = PciIdeChannelEnabled (
										pdoExtension->ParentDeviceExtension,
										pdoExtension->ChannelNumber
										);

		//
		// Don't claim resources if the channel is disabled
		//
        if (channelState == ChannelStateUnknown ) {

            if (pdoExtension->EmptyChannel) {

                reportIrq = FALSE;

            } else {

                reportIrq = TRUE;
            }
        } else if (channelState == ChannelDisabled) {

            requirementsList = NULL;
            status = STATUS_SUCCESS;
            goto GetOut;
		}

        //
        // TEMP CODE for the time without a real PCI driver.
		// pciidex should do this.
        //

        requirementsListSize = sizeof (IO_RESOURCE_REQUIREMENTS_LIST) +
                               sizeof (IO_RESOURCE_DESCRIPTOR) * (3 - 1);
        requirementsList = ExAllocatePool (PagedPool, requirementsListSize);
        if( requirementsList == NULL ){
            status = STATUS_NO_MEMORY;
            goto GetOut;
        }

        RtlZeroMemory(requirementsList, requirementsListSize);

        requirementsList->ListSize          = requirementsListSize;
        requirementsList->InterfaceType     = Isa;
        requirementsList->BusNumber         = 0;    // ISSUE: 08/30/2000
        requirementsList->SlotNumber        = 0;
        requirementsList->AlternativeLists  = 1;

        resourceList            = requirementsList->List;
        resourceList->Version   = 1;
        resourceList->Revision  = 1;
        resourceList->Count     = 0;

        resourceDescriptor = resourceList->Descriptors;

        if (pdoExtension->ChannelNumber == 0) {

            if (!fdoExtension->PdoCmdRegResourceFound[0]) {

                resourceDescriptor[resourceList->Count].Option           = IO_RESOURCE_PREFERRED;
                resourceDescriptor[resourceList->Count].Type             = CmResourceTypePort;
                resourceDescriptor[resourceList->Count].ShareDisposition = CmResourceShareDeviceExclusive;
                resourceDescriptor[resourceList->Count].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                resourceDescriptor[resourceList->Count].u.Port.Length    = 8;
                resourceDescriptor[resourceList->Count].u.Port.Alignment = 1;
                resourceDescriptor[resourceList->Count].u.Port.MinimumAddress.QuadPart = 0x1f0;
                resourceDescriptor[resourceList->Count].u.Port.MaximumAddress.QuadPart = 0x1f7;

                resourceList->Count++;
            }

            if (!fdoExtension->PdoCtrlRegResourceFound[0]) {

                resourceDescriptor[resourceList->Count].Option           = IO_RESOURCE_PREFERRED;
                resourceDescriptor[resourceList->Count].Type             = CmResourceTypePort;
                resourceDescriptor[resourceList->Count].ShareDisposition = CmResourceShareDeviceExclusive;
                resourceDescriptor[resourceList->Count].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                resourceDescriptor[resourceList->Count].u.Port.Length    = 1;
                resourceDescriptor[resourceList->Count].u.Port.Alignment = 1;
                resourceDescriptor[resourceList->Count].u.Port.MinimumAddress.QuadPart = 0x3f6;
                resourceDescriptor[resourceList->Count].u.Port.MaximumAddress.QuadPart = 0x3f6;

                resourceList->Count++;
            }

            if (!fdoExtension->PdoInterruptResourceFound[0] && reportIrq) {

                resourceDescriptor[resourceList->Count].Option           = IO_RESOURCE_PREFERRED;
                resourceDescriptor[resourceList->Count].Type             = CmResourceTypeInterrupt;
                resourceDescriptor[resourceList->Count].ShareDisposition = CmResourceShareDeviceExclusive;
                resourceDescriptor[resourceList->Count].Flags            = CM_RESOURCE_INTERRUPT_LATCHED;
                resourceDescriptor[resourceList->Count].u.Interrupt.MinimumVector = 0xe;
                resourceDescriptor[resourceList->Count].u.Interrupt.MaximumVector = 0xe;

                resourceList->Count++;
            }

        } else { // if (pdoExtension->ChannelNumber == 1)

            if (!fdoExtension->PdoCmdRegResourceFound[1]) {

                resourceDescriptor[resourceList->Count].Option           = IO_RESOURCE_PREFERRED;
                resourceDescriptor[resourceList->Count].Type             = CmResourceTypePort;
                resourceDescriptor[resourceList->Count].ShareDisposition = CmResourceShareDeviceExclusive;
                resourceDescriptor[resourceList->Count].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                resourceDescriptor[resourceList->Count].u.Port.Length    = 8;
                resourceDescriptor[resourceList->Count].u.Port.Alignment = 1;
                resourceDescriptor[resourceList->Count].u.Port.MinimumAddress.QuadPart = 0x170;
                resourceDescriptor[resourceList->Count].u.Port.MaximumAddress.QuadPart = 0x177;

                resourceList->Count++;
            }

            if (!fdoExtension->PdoCtrlRegResourceFound[1]) {

                resourceDescriptor[resourceList->Count].Option           = IO_RESOURCE_PREFERRED;
                resourceDescriptor[resourceList->Count].Type             = CmResourceTypePort;
                resourceDescriptor[resourceList->Count].ShareDisposition = CmResourceShareDeviceExclusive;
                resourceDescriptor[resourceList->Count].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                resourceDescriptor[resourceList->Count].u.Port.Length    = 1;
                resourceDescriptor[resourceList->Count].u.Port.Alignment = 1;
                resourceDescriptor[resourceList->Count].u.Port.MinimumAddress.QuadPart = 0x376;
                resourceDescriptor[resourceList->Count].u.Port.MaximumAddress.QuadPart = 0x376;

                resourceList->Count++;
            }

            if (!fdoExtension->PdoInterruptResourceFound[1] && reportIrq) {

                resourceDescriptor[resourceList->Count].Option           = IO_RESOURCE_PREFERRED;
                resourceDescriptor[resourceList->Count].Type             = CmResourceTypeInterrupt;
                resourceDescriptor[resourceList->Count].ShareDisposition = CmResourceShareDeviceExclusive;
                resourceDescriptor[resourceList->Count].Flags            = CM_RESOURCE_INTERRUPT_LATCHED;
                resourceDescriptor[resourceList->Count].u.Interrupt.MinimumVector = 0xf;
                resourceDescriptor[resourceList->Count].u.Interrupt.MaximumVector = 0xf;

                resourceList->Count++;
            }
        }

        if (!resourceList->Count) {

            ExFreePool (requirementsList);
            requirementsList = NULL;
        }

        status = STATUS_SUCCESS;
    }

GetOut:

    Irp->IoStatus.Information = (ULONG_PTR) requirementsList;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // ChannelQueryResourceRequirements


NTSTATUS
ChannelInternalDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION              thisIrpSp;
    PCHANPDO_EXTENSION              pdoExtension;
    NTSTATUS                        status;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        thisIrpSp    = IoGetCurrentIrpStackLocation(Irp);

        switch (thisIrpSp->Parameters.DeviceIoControl.IoControlCode) {

            //
            // TEMP CODE for the time without a real PCI driver.
			// pciidex knows about the resources.
            //
            case IOCTL_IDE_GET_RESOURCES_ALLOCATED:
                {
                PCTRLFDO_EXTENSION              fdoExtension;
                ULONG                           resourceListSize;
                PCM_RESOURCE_LIST               resourceList;
                PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
                PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
                PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
                ULONG                           channel;

                channel = pdoExtension->ChannelNumber;
                fdoExtension = pdoExtension->ParentDeviceExtension;

                resourceListSize = fdoExtension->PdoResourceListSize[channel];

                //
                // have the callee allocate the buffer. 
                //
                resourceList = (PCM_RESOURCE_LIST) Irp->AssociatedIrp.SystemBuffer;
                ASSERT(resourceList);

                RtlCopyMemory (
                    resourceList,
                    fdoExtension->PdoResourceList[channel],
                    resourceListSize);

                Irp->IoStatus.Information = resourceListSize;
                status = STATUS_SUCCESS;
                }
                break;

            default:
                DebugPrint ((1,
                             "PciIde, Channel PDO got Unknown IoControlCode 0x%x\n",
                             thisIrpSp->Parameters.DeviceIoControl.IoControlCode));
                status = STATUS_INVALID_PARAMETER;
                break;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
} // ChannelInternalDeviceIoControl


NTSTATUS
ChannelQueryText (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PCHANPDO_EXTENSION  pdoExtension;
    PWCHAR              returnString;
    ANSI_STRING         ansiString;
    UNICODE_STRING      unicodeString;
    ULONG               stringLen;
    NTSTATUS            status;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        thisIrpSp    = IoGetCurrentIrpStackLocation (Irp);

        returnString = NULL;
        Irp->IoStatus.Information = 0;

        if (thisIrpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {

            PMESSAGE_RESOURCE_ENTRY messageEntry;

            status = RtlFindMessage(pdoExtension->DriverObject->DriverStart,
                                    11,
                                    LANG_NEUTRAL,
                                    PCIIDEX_IDE_CHANNEL,
                                    &messageEntry);

            if (!NT_SUCCESS(status)) {

                returnString = NULL;

            } else {

                if (messageEntry->Flags & MESSAGE_RESOURCE_UNICODE) {

                    //
                    // Our caller wants a copy they can free, also we need to
                    // strip the trailing CR/LF.  The Length field of the
                    // message structure includes both the header and the
                    // actual text.
                    //
                    // Note: The message resource entry length will always be a
                    // multiple of 4 bytes in length.  The 2 byte null terminator
                    // could be in either the last or second last WCHAR position.
                    //

                    ULONG textLength;

                    textLength = messageEntry->Length -
                                 FIELD_OFFSET(MESSAGE_RESOURCE_ENTRY, Text) -
                                 2 * sizeof(WCHAR);

                    returnString = (PWCHAR)(messageEntry->Text);
                    if (returnString[textLength / sizeof(WCHAR)] == 0) {
                        textLength -= sizeof(WCHAR);
                    }

                    returnString = ExAllocatePool(PagedPool, textLength);

                    if (returnString) {

                        //
                        // Copy the text except for the CR/LF/NULL
                        //

                        textLength -= sizeof(WCHAR);
                        RtlCopyMemory(returnString, messageEntry->Text, textLength);

                        //
                        // New NULL terminator.
                        //

                        returnString[textLength / sizeof(WCHAR)] = 0;
                    }

                } else {

                    //
                    // RtlFindMessage returns a string?   Wierd.
                    //

                    ANSI_STRING    ansiDescription;
                    UNICODE_STRING unicodeDescription;

                    RtlInitAnsiString(&ansiDescription, messageEntry->Text);

                    //
                    // Strip CR/LF off the end of the string.
                    //

                    ansiDescription.Length -= 2;

                    //
                    // Turn it all into a unicode string so we can grab the buffer
                    // and return that to our caller.
                    //

                    status = RtlAnsiStringToUnicodeString(
                                 &unicodeDescription,
                                 &ansiDescription,
                                 TRUE
                                 );

                    returnString = unicodeDescription.Buffer;
                }
            }
        } else if (thisIrpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextLocationInformation) {

            stringLen = 100;

            returnString = ExAllocatePool (
                               PagedPool,
                               stringLen
                               );

            if (returnString) {

                swprintf(returnString, L"%ws Channel",
                         ((pdoExtension->ChannelNumber == 0) ? L"Primary" :
                                                               L"Secondary"));

                RtlInitUnicodeString (&unicodeString, returnString);

                //
                // null terminate it
                //
                unicodeString.Buffer[unicodeString.Length/sizeof(WCHAR) + 0] = L'\0';
            }
        }

        Irp->IoStatus.Information = (ULONG_PTR) returnString;
        if (Irp->IoStatus.Information) {

            status = STATUS_SUCCESS;
        } else {

            //
            // return the original error code
            //
            status = Irp->IoStatus.Status;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

} // ChannelQueryText


NTSTATUS
PciIdeChannelQueryInterface (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION          thisIrpSp;
    PCHANPDO_EXTENSION          pdoExtension;
    NTSTATUS                    status;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        status = Irp->IoStatus.Status;
        thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

        if (RtlEqualMemory(&GUID_PCIIDE_BUSMASTER_INTERFACE,
                thisIrpSp->Parameters.QueryInterface.InterfaceType,
                sizeof(GUID)) &&
            (thisIrpSp->Parameters.QueryInterface.Size >=
                sizeof(PCIIDE_BUSMASTER_INTERFACE))) {

            //
            // The query is for an busmaster interface
            //
            status = BmQueryInterface (
                         pdoExtension,
                         (PPCIIDE_BUSMASTER_INTERFACE) thisIrpSp->Parameters.QueryInterface.Interface
                         );

        } else if (RtlEqualMemory(&GUID_PCIIDE_SYNC_ACCESS_INTERFACE,
                       thisIrpSp->Parameters.QueryInterface.InterfaceType,
                       sizeof(GUID)) &&
                  (thisIrpSp->Parameters.QueryInterface.Size >=
                       sizeof(PCIIDE_SYNC_ACCESS_INTERFACE))) {

            //
            // The query is for dual ide channel sync access interface
            //
            status = PciIdeQuerySyncAccessInterface (
                         pdoExtension,
                         (PPCIIDE_SYNC_ACCESS_INTERFACE) thisIrpSp->Parameters.QueryInterface.Interface
                         );

        } else if (RtlEqualMemory(&GUID_PCIIDE_XFER_MODE_INTERFACE,
                       thisIrpSp->Parameters.QueryInterface.InterfaceType,
                       sizeof(GUID)) &&
                  (thisIrpSp->Parameters.QueryInterface.Size >=
                       sizeof(PCIIDE_XFER_MODE_INTERFACE))) {

            //
            // The query is for dual ide channel sync access interface
            //
            status = PciIdeChannelTransferModeInterface (
                         pdoExtension,
                         (PPCIIDE_XFER_MODE_INTERFACE) thisIrpSp->Parameters.QueryInterface.Interface
                         );

#ifdef ENABLE_NATIVE_MODE

        } else if (RtlEqualMemory(&GUID_PCIIDE_INTERRUPT_INTERFACE,
                       thisIrpSp->Parameters.QueryInterface.InterfaceType,
                       sizeof(GUID)) &&
                  (thisIrpSp->Parameters.QueryInterface.Size >=
                       sizeof(PCIIDE_INTERRUPT_INTERFACE))) {

            //
            // The query is for the channel interrupt interface
            //
            status = PciIdeChannelInterruptInterface (
                         pdoExtension,
                         (PPCIIDE_INTERRUPT_INTERFACE) thisIrpSp->Parameters.QueryInterface.Interface
                         );
#endif

        } else if (RtlEqualMemory(&GUID_PCIIDE_REQUEST_PROPER_RESOURCES,
                       thisIrpSp->Parameters.QueryInterface.InterfaceType,
                       sizeof(GUID)) &&
                  (thisIrpSp->Parameters.QueryInterface.Size >=
                       sizeof(PCIIDE_REQUEST_PROPER_RESOURCES))) {

            //
            // The query is for dual ide channel sync access interface
            //
            *((PCIIDE_REQUEST_PROPER_RESOURCES *) thisIrpSp->Parameters.QueryInterface.Interface) =
                PciIdeChannelRequestProperResources;
            status = STATUS_SUCCESS;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // PciIdeChannelQueryInterface

#ifdef ENABLE_NATIVE_MODE

NTSTATUS
PciIdeInterruptControl (
	IN PVOID Context,
	IN ULONG DisConnect
	)
/*++
Description:

	Connects or disconnects the controller ISR. This intermediate function provides
	a clean interface to atapi. Since this is not a very frequently used function
	we can afford the extra call
	
Arguments :
	
	Context : Pdo extension
	Disconnect: 1 to disconnect and 0 to connect

	
Return Value:

	STATUS_SUCCESS : if the operation succeeds.	
	
--*/
{
	PCHANPDO_EXTENSION pdoExtension = Context;

	NTSTATUS status;

	//
	// Call the controller's interrupt control routine
	//
	status = ControllerInterruptControl(pdoExtension->ParentDeviceExtension,
										pdoExtension->ChannelNumber,
										DisConnect
										);

	return status;
}

NTSTATUS
PciIdeChannelInterruptInterface (
    IN PCHANPDO_EXTENSION PdoExtension,
    PPCIIDE_INTERRUPT_INTERFACE InterruptInterface
    )
{
	//
	// Return an interface only if we are in native mode.
	// Saves a few function calls on non native mode controllers
	//
	if (IsNativeMode(PdoExtension->ParentDeviceExtension)) {

		InterruptInterface->Context = PdoExtension;
		InterruptInterface->PciIdeInterruptControl = PciIdeInterruptControl;

		DebugPrint((1, "PciIdex: returing interrupt interface for channel %x\n", 
					PdoExtension->ChannelNumber));
	}

	return STATUS_SUCCESS;
}
#endif

NTSTATUS
PciIdeChannelTransferModeInterface (
    IN PCHANPDO_EXTENSION PdoExtension,
    PPCIIDE_XFER_MODE_INTERFACE XferMode
    )
{
    XferMode->TransferModeSelect = PciIdeChannelTransferModeSelect;
    XferMode->TransferModeTimingTable = PdoExtension->ParentDeviceExtension->
                                                                TransferModeTimingTable;
    XferMode->TransferModeTableLength = PdoExtension->ParentDeviceExtension->
                                                                TransferModeTableLength;
    XferMode->Context = PdoExtension;
    XferMode->VendorSpecificDeviceExtension=PdoExtension->
                    ParentDeviceExtension->VendorSpecificDeviceEntension;


    XferMode->UdmaModesSupported = PdoExtension->
                                    ParentDeviceExtension->
                                        ControllerProperties.PciIdeUdmaModesSupported;
    //
    //NULL is ok. checked in the IdePortDispatchRoutine
    //
    XferMode->UseDma = PdoExtension->
                            ParentDeviceExtension->
                                ControllerProperties.PciIdeUseDma;

    if (PdoExtension->
            ParentDeviceExtension->
                ControllerProperties.PciIdeTransferModeSelect) {

        //
        // Looks like the miniport fully support timing register programming
        //

        XferMode->SupportLevel = PciIdeFullXferModeSupport;

    } else {

        //
        // Looks like the miniport doens't support timing register programming
        //
        XferMode->SupportLevel = PciIdeBasicXferModeSupport;
    }

    //
    // This function can't fail
    //
    return STATUS_SUCCESS;
} // PciIdeChannelTransferModeInterface

NTSTATUS
PciIdeChannelTransferModeSelect (
    IN PCHANPDO_EXTENSION PdoExtension,
    PPCIIDE_TRANSFER_MODE_SELECT XferMode
    )
{
    ULONG i;
    NTSTATUS status;
    UCHAR    bmRawStatus;
    struct {
        USHORT  VendorID;
        USHORT  DeviceID;
    } pciId;

    //
    // check the registry for bus master mode
    // and overwrite the current if necessary
    //
    // if DMADetection = 0, clear current dma mode
    // if DMADetection = 1, set current mode
    // if DMADetection = 2, clear all current mode

    if (PdoExtension->DmaDetectionLevel == DdlPioOnly) {

        bmRawStatus = 0;

        for (i=0; i<MAX_IDE_DEVICE * MAX_IDE_LINE; i++) {

            XferMode->DeviceTransferModeSupported[i] &= PIO_SUPPORT;
            XferMode->DeviceTransferModeCurrent[i] &= PIO_SUPPORT;
        }

    } else if (PdoExtension->DmaDetectionLevel == DdlFirmwareOk) {

        if (PdoExtension->BmRegister) {

            //
            // get the firmware ok bits
            // the current value seems to be 0??
			//
            bmRawStatus = PdoExtension->BootBmStatus;

        } else {

            bmRawStatus = 0;
        }

    } else if (PdoExtension->DmaDetectionLevel == DdlAlways) {

        if (PdoExtension->BmRegister) {

            //
            // fake the firmware ok bits
            //
            bmRawStatus = BUSMASTER_DEVICE0_DMA_OK | BUSMASTER_DEVICE1_DMA_OK;

        } else {

            bmRawStatus = 0;
        }

    } else {

        bmRawStatus = 0;
    }

    //
    // in case there is no miniport support
    //
    status = STATUS_UNSUCCESSFUL;

    if (PdoExtension->DmaDetectionLevel != DdlPioOnly) {

        //
        // set up the channel number since the caller (atapi)
        // doesn't know how.
        //
        XferMode->Channel = PdoExtension->ChannelNumber;

        //
        // This decides whether UDMA modes > 2 should be supported or not
        // Currently impacts only the intel chipsets
        //
        XferMode->EnableUDMA66 = PdoExtension->ParentDeviceExtension->EnableUDMA66;

        if (PdoExtension->
                ParentDeviceExtension->
                    ControllerProperties.PciIdeTransferModeSelect) {

            status = (*PdoExtension->ParentDeviceExtension->ControllerProperties.PciIdeTransferModeSelect) (
                         PdoExtension->ParentDeviceExtension->VendorSpecificDeviceEntension,
                         XferMode
                         );
        }
    }

    DebugPrint((1, "Select in PCIIDEX: RawStatus=%x, current[0]=%x, current[1]=%x\n",
                bmRawStatus,
                XferMode->DeviceTransferModeCurrent[0],
                XferMode->DeviceTransferModeCurrent[1]));

    if (!NT_SUCCESS(status)) {

        status = STATUS_SUCCESS;

        if ((bmRawStatus & BUSMASTER_DEVICE0_DMA_OK) == 0) {

            XferMode->DeviceTransferModeSelected[0] = XferMode->DeviceTransferModeCurrent[0] & PIO_SUPPORT;
        } else {

            XferMode->DeviceTransferModeSelected[0] = XferMode->DeviceTransferModeCurrent[0];
        }

        if ((bmRawStatus & BUSMASTER_DEVICE1_DMA_OK) == 0) {

            XferMode->DeviceTransferModeSelected[1] = XferMode->DeviceTransferModeCurrent[1] & PIO_SUPPORT;
        } else {

            XferMode->DeviceTransferModeSelected[1] = XferMode->DeviceTransferModeCurrent[1];
        }

        for (i=0; i<MAX_IDE_DEVICE; i++) {

            DebugPrint((1, "Select in PCIIDEX: xfermode[%d]=%x\n",i,
                PdoExtension->ParentDeviceExtension->ControllerProperties.
                    SupportedTransferMode[PdoExtension->ChannelNumber][i]));


            if ((PdoExtension->ParentDeviceExtension->ControllerProperties.DefaultPIO == 1) && 
                (IS_DEFAULT(XferMode->UserChoiceTransferMode[i]))) {
                XferMode->DeviceTransferModeSelected[i] &= PIO_SUPPORT;
            }
            else  {
                XferMode->DeviceTransferModeSelected[i] &=
                    PdoExtension->ParentDeviceExtension->ControllerProperties.
                        SupportedTransferMode[PdoExtension->ChannelNumber][i];
            }
        }
    }

    return status;

} // PciIdeChannelTransferModeSelect

NTSTATUS
ChannelQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PDEVICE_RELATIONS   deviceRelations;
    NTSTATUS            status;

    PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

    switch (thisIrpSp->Parameters.QueryDeviceRelations.Type) {

        case TargetDeviceRelation:

            deviceRelations = ExAllocatePool (NonPagedPool, sizeof(*deviceRelations));

            if (deviceRelations != NULL) {

                deviceRelations->Count = 1;
                deviceRelations->Objects[0] = DeviceObject;

                ObReferenceObjectByPointer(DeviceObject,
                                           0,
                                           0,
                                           KernelMode);

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
            } else {

                Irp->IoStatus.Status = STATUS_NO_MEMORY;
                Irp->IoStatus.Information = 0;
            }
            break;
    }

    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // ChannelQueryDeviceRelations

NTSTATUS
ChannelUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS           status;
    PCHANPDO_EXTENSION pdoExtension;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT targetDeviceObject;
    IO_STATUS_BLOCK ioStatus;
    PULONG deviceUsageCount;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging) {

            //
            // Adjust the paging path count for this device.
            //
            deviceUsageCount = &pdoExtension->PagingPathCount;

            //
            // changing device state
            //
            SETMASK (pdoExtension->PnPDeviceState, PNP_DEVICE_NOT_DISABLEABLE);
            IoInvalidateDeviceState(pdoExtension->DeviceObject);

        } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation) {

            //
            // Adjust the paging path count for this device.
            //
            deviceUsageCount = &pdoExtension->HiberPathCount;

        } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile) {

            //
            // Adjust the paging path count for this device.
            //
            deviceUsageCount = &pdoExtension->CrashDumpPathCount;

        } else {

            deviceUsageCount = NULL;
            DebugPrint ((0,
                         "PCIIDEX: Unknown IRP_MN_DEVICE_USAGE_NOTIFICATION type: 0x%x\n",
                         irpSp->Parameters.UsageNotification.Type));
        }

        //
        // get the top of parent's device stack
        //
        targetDeviceObject = IoGetAttachedDeviceReference(
                                 pdoExtension->
                                     ParentDeviceExtension->
                                         DeviceObject);

        ioStatus.Status = STATUS_NOT_SUPPORTED;
        status = PciIdeXSyncSendIrp (targetDeviceObject, irpSp, &ioStatus);

        ObDereferenceObject (targetDeviceObject);

        if (NT_SUCCESS(status)) {

            if (deviceUsageCount) {

                IoAdjustPagingPathCount (
                    deviceUsageCount,
                    irpSp->Parameters.UsageNotification.InPath
                    );
            }
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

} // ChannelUsageNotification

NTSTATUS
ChannelQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PCHANPDO_EXTENSION pdoExtension;

    pdoExtension = ChannelGetPdoExtension(DeviceObject);

    if (pdoExtension) {

        PPNP_DEVICE_STATE deviceState;

        DebugPrint((2, "QUERY_DEVICE_STATE for PDOE 0x%x\n", pdoExtension));

        deviceState = (PPNP_DEVICE_STATE) &Irp->IoStatus.Information;
        SETMASK((*deviceState), pdoExtension->PnPDeviceState);

        CLRMASK (pdoExtension->PnPDeviceState, PNP_DEVICE_FAILED | PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED);

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_DEVICE_DOES_NOT_EXIST;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // ChannelQueryPnPDeviceState


VOID
PciIdeChannelRequestProperResources(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PCHANPDO_EXTENSION pdoExtension;

    //
    // the FDO thinks the channel is not empty
    // anymore
    //
    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension) {
        pdoExtension->EmptyChannel = FALSE;
        SETMASK (pdoExtension->PnPDeviceState, PNP_DEVICE_FAILED | PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED);
        IoInvalidateDeviceState (DeviceObject);
    }
}

NTSTATUS
ChannelFilterResourceRequirements (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PCHANPDO_EXTENSION pdoExtension;
    PIO_STACK_LOCATION thisIrpSp;
    ULONG             i, j;

    PIO_RESOURCE_REQUIREMENTS_LIST  requirementsListIn = NULL;
    PIO_RESOURCE_LIST               resourceListIn;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptorIn;

    PIO_RESOURCE_LIST               resourceListOut;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptorOut;

    ULONG newCount;

    PAGED_CODE();

    status = STATUS_NOT_SUPPORTED;

    //
    // the value will stay NULL if no filtering required
    //

#ifdef IDE_FILTER_PROMISE_TECH_RESOURCES
    if (NT_SUCCESS(ChannelFilterPromiseTechResourceRequirements (DeviceObject, Irp))) {
        goto getout;
    }
#endif // IDE_FILTER_PROMISE_TECH_RESOURCES

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (!pdoExtension) {
        goto getout;
    }


    //
    // filter out irq only if the channel is emtpy
    //
    if (!pdoExtension->EmptyChannel) {

        goto getout;
    }

    if (NT_SUCCESS(Irp->IoStatus.Status)) {
        //
        // already filtered.
        //
        requirementsListIn = (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;
    } else {
        thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
        requirementsListIn = thisIrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;
    }

    if (requirementsListIn == NULL) {
        goto getout;
    }

    if (requirementsListIn->AlternativeLists == 0) {
        goto getout;
    }

    resourceListIn = requirementsListIn->List;
    resourceListOut = resourceListIn;
    for (j=0; j<requirementsListIn->AlternativeLists; j++) {

        ULONG resCount;
        resourceDescriptorIn = resourceListIn->Descriptors;

        RtlMoveMemory (
           resourceListOut,
           resourceListIn,
           FIELD_OFFSET(IO_RESOURCE_LIST, Descriptors));
        resourceDescriptorOut = resourceListOut->Descriptors;

        resCount = resourceListIn->Count;
        for (i=newCount=0; i<resCount; i++) {

            if (resourceDescriptorIn[i].Type != CmResourceTypeInterrupt) {
                resourceDescriptorOut[newCount] = resourceDescriptorIn[i];
                newCount++;
            } else {
                status = STATUS_SUCCESS;
            }
        }
        resourceListIn = (PIO_RESOURCE_LIST) (resourceDescriptorIn + resCount);
        resourceListOut->Count = newCount;
        resourceListOut = (PIO_RESOURCE_LIST) (resourceDescriptorOut + newCount);
    }


getout:

    if (status != STATUS_NOT_SUPPORTED) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) requirementsListIn;
    } else {
        status = Irp->IoStatus.Status;
    }
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\pciidex\pciidex.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pciidex.c
//
//--------------------------------------------------------------------------

#include "pciidex.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, PciIdeXInitialize)
#pragma alloc_text(PAGE, PciIdeXAlwaysStatusSuccessIrp)
#pragma alloc_text(PAGE, DispatchPnp)
#pragma alloc_text(PAGE, DispatchWmi)
#pragma alloc_text(PAGE, PassDownToNextDriver)
#pragma alloc_text(PAGE, PciIdeInternalDeviceIoControl)
#pragma alloc_text(PAGE, PciIdeXGetDeviceParameter)
#pragma alloc_text(PAGE, PciIdeXGetDeviceParameterEx)
#pragma alloc_text(PAGE, PciIdeXRegQueryRoutine)

#pragma alloc_text(PAGE, PciIdeUnload)
#pragma alloc_text(PAGE, PciIdeXSyncSendIrp)

#pragma alloc_text(NONPAGE, PciIdeXGetBusData)
#pragma alloc_text(NONPAGE, PciIdeXSetBusData)
                         
#pragma alloc_text(NONPAGE, DispatchPower)
#pragma alloc_text(NONPAGE, NoSupportIrp)
#pragma alloc_text(NONPAGE, PciIdeBusData)
#pragma alloc_text(NONPAGE, PciIdeBusDataCompletionRoutine)
#pragma alloc_text(NONPAGE, PciIdeXSyncSendIrpCompletionRoutine)

#if DBG
#pragma alloc_text(PAGE, PciIdeXSaveDeviceParameter)
#endif // DBG
             
#endif // ALLOC_PRAGMA

//
// get the share code
//
#include "..\share\util.c"


#if DBG

ULONG PciIdeDebug = 0;
UCHAR DebugBuffer[128 * 6];

VOID
PciIdeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all SCSI drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= PciIdeDebug) {

        vsprintf(DebugBuffer, DebugMessage, ap);

        //DbgPrint(DebugBuffer);

#if 1
        DbgPrintEx(DPFLTR_PCIIDE_ID,
                   DPFLTR_INFO_LEVEL,
                   DebugBuffer
                   );
#endif
    }

    va_end(ap);

} // end DebugPrint()

#else

VOID
PciIdeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
    return;
}

#endif

//
// PnP Dispatch Table
//
PDRIVER_DISPATCH FdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];
PDRIVER_DISPATCH PdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];

//
// Po Dispatch Table
//
PDRIVER_DISPATCH FdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];
PDRIVER_DISPATCH PdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];

//
// Wmi Dispatch Table
//
PDRIVER_DISPATCH FdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];
PDRIVER_DISPATCH PdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    PAGED_CODE();

    return STATUS_SUCCESS;
} // DriverEntry

NTSTATUS
PciIdeXInitialize(
    IN PDRIVER_OBJECT           DriverObject,
    IN PUNICODE_STRING          RegistryPath,
    IN PCONTROLLER_PROPERTIES   PciIdeGetControllerProperties,
    IN ULONG                    ExtensionSize
    )
{
    NTSTATUS status;
    PDRIVER_EXTENSION driverExtension;
    PDRIVER_OBJECT_EXTENSION driverObjectExtension;
    ULONG i;

    PAGED_CODE();

    status = IoAllocateDriverObjectExtension(
                 DriverObject,
                 DRIVER_OBJECT_EXTENSION_ID,
                 sizeof (DRIVER_OBJECT_EXTENSION),
                 &driverObjectExtension
                 );

    if (!NT_SUCCESS(status)) {

        DebugPrint ((0, "PciIde: Unable to create driver extension\n"));
        return status; 
    }
    ASSERT (driverObjectExtension);

    driverObjectExtension->PciIdeGetControllerProperties = PciIdeGetControllerProperties;
    driverObjectExtension->ExtensionSize                 = ExtensionSize;

    //
    // some entry point init.
    //
    DriverObject->DriverUnload                                  = PciIdeUnload;
    DriverObject->MajorFunction[IRP_MJ_POWER]                   = DispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = DispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = PciIdeInternalDeviceIoControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]          = DispatchWmi;

    driverExtension = DriverObject->DriverExtension;
    driverExtension->AddDevice = ControllerAddDevice;

    //
    // FDO PnP Dispatch Table
    //
    for (i=0; i<NUM_PNP_MINOR_FUNCTION; i++) {

        FdoPnpDispatchTable[i] = PassDownToNextDriver;
    }
    FdoPnpDispatchTable[IRP_MN_START_DEVICE             ] = ControllerStartDevice;
    FdoPnpDispatchTable[IRP_MN_QUERY_REMOVE_DEVICE      ] = StatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_CANCEL_REMOVE_DEVICE     ] = StatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_STOP_DEVICE              ] = ControllerStopDevice;
    FdoPnpDispatchTable[IRP_MN_QUERY_STOP_DEVICE        ] = StatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_CANCEL_STOP_DEVICE       ] = StatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_REMOVE_DEVICE            ] = ControllerRemoveDevice;
    FdoPnpDispatchTable[IRP_MN_QUERY_DEVICE_RELATIONS   ] = ControllerQueryDeviceRelations;
    FdoPnpDispatchTable[IRP_MN_QUERY_INTERFACE          ] = ControllerQueryInterface;
    FdoPnpDispatchTable[IRP_MN_DEVICE_USAGE_NOTIFICATION] = ControllerUsageNotification;
    FdoPnpDispatchTable[IRP_MN_QUERY_PNP_DEVICE_STATE   ] = ControllerQueryPnPDeviceState;
    FdoPnpDispatchTable[IRP_MN_SURPRISE_REMOVAL         ] = ControllerSurpriseRemoveDevice;

    //
    // PDO PnP Dispatch Table
    //
    for (i=0; i<NUM_PNP_MINOR_FUNCTION; i++) {

        PdoPnpDispatchTable[i] = NoSupportIrp;
    }
    PdoPnpDispatchTable[IRP_MN_START_DEVICE               ] = ChannelStartDevice;
    PdoPnpDispatchTable[IRP_MN_QUERY_REMOVE_DEVICE        ] = ChannelQueryStopRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_REMOVE_DEVICE              ] = ChannelRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_CANCEL_REMOVE_DEVICE       ] = PciIdeXAlwaysStatusSuccessIrp;
    PdoPnpDispatchTable[IRP_MN_STOP_DEVICE                ] = ChannelStopDevice;
    PdoPnpDispatchTable[IRP_MN_QUERY_STOP_DEVICE          ] = ChannelQueryStopRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_CANCEL_STOP_DEVICE         ] = PciIdeXAlwaysStatusSuccessIrp;
    PdoPnpDispatchTable[IRP_MN_QUERY_CAPABILITIES         ] = ChannelQueryCapabitilies;
    PdoPnpDispatchTable[IRP_MN_QUERY_RESOURCES            ] = ChannelQueryResources;
    PdoPnpDispatchTable[IRP_MN_QUERY_RESOURCE_REQUIREMENTS] = ChannelQueryResourceRequirements;
    PdoPnpDispatchTable[IRP_MN_QUERY_DEVICE_TEXT          ] = ChannelQueryText;
    PdoPnpDispatchTable[IRP_MN_QUERY_ID                   ] = ChannelQueryId;
    PdoPnpDispatchTable[IRP_MN_QUERY_DEVICE_RELATIONS     ] = ChannelQueryDeviceRelations;
    PdoPnpDispatchTable[IRP_MN_QUERY_INTERFACE            ] = PciIdeChannelQueryInterface;
    PdoPnpDispatchTable[IRP_MN_DEVICE_USAGE_NOTIFICATION  ] = ChannelUsageNotification;
    PdoPnpDispatchTable[IRP_MN_QUERY_PNP_DEVICE_STATE     ] = ChannelQueryPnPDeviceState;
    PdoPnpDispatchTable[IRP_MN_SURPRISE_REMOVAL           ] = ChannelRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_FILTER_RESOURCE_REQUIREMENTS] = ChannelFilterResourceRequirements;

    //
    // FDO Power Dispatch Table
    //
    for (i=0; i<NUM_POWER_MINOR_FUNCTION; i++) {

        FdoPowerDispatchTable[i] = PassDownToNextDriver;
    }
    FdoPowerDispatchTable[IRP_MN_SET_POWER]   = PciIdeSetFdoPowerState;
    FdoPowerDispatchTable[IRP_MN_QUERY_POWER] = PciIdeXQueryPowerState;

    //
    // PDO Power Dispatch Table
    //
    for (i=0; i<NUM_POWER_MINOR_FUNCTION; i++) {

        PdoPowerDispatchTable[i] = NoSupportIrp;
    }
    PdoPowerDispatchTable[IRP_MN_SET_POWER]   = PciIdeSetPdoPowerState;
    PdoPowerDispatchTable[IRP_MN_QUERY_POWER] = PciIdeXQueryPowerState;

    //
    // FDO WMI Dispatch Table
    //
    for (i=0; i<NUM_WMI_MINOR_FUNCTION; i++) {

        FdoWmiDispatchTable[i] = PassDownToNextDriver;
    }

    //
    // PDO WMI Dispatch Table
    //
    for (i=0; i<NUM_WMI_MINOR_FUNCTION; i++) {

        PdoWmiDispatchTable[i] = NoSupportIrp;
    }

    //
    // Create device object name directory
    //
    IdeCreateIdeDirectory();

    return status;
} // PciIdeXInitialize

NTSTATUS
PciIdeXAlwaysStatusSuccessIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
/*++

Routine Description:

    Generic routine to STATUS_SUCCESS an irp

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/
    )
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
} // PciIdeXAlwaysStatusSuccessIrp

NTSTATUS
DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION       thisIrpSp;
    NTSTATUS                 status;
    PDEVICE_EXTENSION_HEADER doExtension;

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //
    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    DebugPrint ((2, 
                 "PciIde: %s %d got %s\n",
                 doExtension->AttacheeDeviceObject ? "FDO" : "PDO",
                 doExtension->AttacheeDeviceObject ? 0 :
                    ((PCHANPDO_EXTENSION) doExtension)->ChannelNumber,
                 IdeDebugPowerIrpName[thisIrpSp->MinorFunction]));


    switch (thisIrpSp->MinorFunction) {

        case IRP_MN_WAIT_WAKE:
            DebugPrint ((2, "IRP_MN_WAIT_WAKE\n"));
            break;

        case IRP_MN_POWER_SEQUENCE:
            DebugPrint ((2, "IRP_MN_POWER_SEQUENCE\n"));
            break;

        case IRP_MN_SET_POWER:
            DebugPrint ((2, "IRP_MN_SET_POWER\n"));
            break;

        case IRP_MN_QUERY_POWER:
            DebugPrint ((2, "IRP_MN_QUERY_POWER\n"));
            break;

        default:
            DebugPrint ((2, "IRP_MN_0x%x\n", thisIrpSp->MinorFunction));
            break;
    }

    // Should always pass the irp down. It is taken care by the corresponding dispatch
    // funtion. 
    //

    if (thisIrpSp->MinorFunction < NUM_POWER_MINOR_FUNCTION) {

        status = doExtension->PowerDispatchTable[thisIrpSp->MinorFunction] (DeviceObject, Irp);
    } else {

        DebugPrint ((1,
					 "ATAPI: Power Dispatch Table too small\n"
					 ));

        status = doExtension->DefaultDispatch (DeviceObject, Irp);
    }

    return status;
} // DispatchPower

NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine handles all IRP_MJ_PNP_POWER IRPs for this driver.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION  thisIrpSp;
    NTSTATUS            status;
    PDEVICE_EXTENSION_HEADER doExtension;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //
    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    DebugPrint ((2, 
                 "PciIde: %s %d got %s\n",
                 doExtension->AttacheeDeviceObject ? "FDO" : "PDO",
                 doExtension->AttacheeDeviceObject ? 0 :
                    ((PCHANPDO_EXTENSION) doExtension)->ChannelNumber,
                 IdeDebugPnpIrpName[thisIrpSp->MinorFunction]));

    if (thisIrpSp->MinorFunction < NUM_PNP_MINOR_FUNCTION) {

        status = doExtension->PnPDispatchTable[thisIrpSp->MinorFunction] (DeviceObject, Irp);
    } else {

        if (thisIrpSp->MinorFunction != 0xff) {

            ASSERT (!"ATAPI: PnP Dispatch Table too small\n");
        }

        status = doExtension->DefaultDispatch (DeviceObject, Irp);
    }

    return status;
} // DispatchPnp

NTSTATUS
DispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine handles all IRP_MJ_SYSTEM_CONTROL (WMI) IRPs for this driver.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION  thisIrpSp;
    NTSTATUS            status;
    PDEVICE_EXTENSION_HEADER doExtension;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //
    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    DebugPrint ((2, 
                 "PciIde: %s %d got %s\n",
                 doExtension->AttacheeDeviceObject ? "FDO" : "PDO",
                 doExtension->AttacheeDeviceObject ? 0 :
                    ((PCHANPDO_EXTENSION) doExtension)->ChannelNumber,
                 IdeDebugWmiIrpName[thisIrpSp->MinorFunction]));

    if (thisIrpSp->MinorFunction < NUM_WMI_MINOR_FUNCTION) {

        status = doExtension->WmiDispatchTable[thisIrpSp->MinorFunction] (DeviceObject, Irp);
    } else {

        DebugPrint ((1,
					 "ATAPI: WMI Dispatch Table too small\n"
					 ));

        status = doExtension->DefaultDispatch (DeviceObject, Irp);
    }

    return status;
} // DispatchWmi()


NTSTATUS
PassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PDEVICE_EXTENSION_HEADER deviceExtensionHeader;
    NTSTATUS            status;
    PIO_STACK_LOCATION  thisIrpSp;

    PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    deviceExtensionHeader = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    ASSERT (deviceExtensionHeader->AttacheeDeviceObject);

	if (thisIrpSp->MajorFunction == IRP_MJ_POWER) {

		//
		// call PoStartNextPowerIrp before completing a power irp
		//
		PoStartNextPowerIrp (Irp);
		IoSkipCurrentIrpStackLocation (Irp);
		status = PoCallDriver (deviceExtensionHeader->AttacheeDeviceObject, Irp);

	} else {

		//
		// Not a power irp
		//
		IoSkipCurrentIrpStackLocation (Irp);
		status = IoCallDriver (deviceExtensionHeader->AttacheeDeviceObject, Irp);
	}

    return status;
} // PassDownToNextDriver

NTSTATUS
StatusSuccessAndPassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PDEVICE_EXTENSION_HEADER deviceExtensionHeader;

    PAGED_CODE();

    IoSkipCurrentIrpStackLocation (Irp);

    deviceExtensionHeader = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return IoCallDriver (deviceExtensionHeader->AttacheeDeviceObject, Irp);
} // PassDownToNextDriver


NTSTATUS
NoSupportIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION       thisIrpSp;
    NTSTATUS status = Irp->IoStatus.Status;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

	//
	// You should call PoStartNextPowerIrp before completing a power irp
	//
	if (thisIrpSp->MajorFunction == IRP_MJ_POWER) {

		PoStartNextPowerIrp (Irp);

	}

    DebugPrint ((
        1,
        "IdePort: devobj 0x%x failing unsupported Irp (0x%x, 0x%x) with status = %x\n",
        DeviceObject,
        thisIrpSp->MajorFunction,
        thisIrpSp->MinorFunction,
		status
        ));

    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // NoSupportIrp

NTSTATUS
PciIdeXGetBusData(
    IN PVOID DeviceExtension,
    IN PVOID Buffer,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    )
{
    PCTRLFDO_EXTENSION fdoExtension = ((PCTRLFDO_EXTENSION) DeviceExtension) - 1;

    return PciIdeBusData(
               fdoExtension,
               Buffer,
               ConfigDataOffset,
               BufferLength,
               TRUE
               );
} // PciIdeXGetBusData

NTSTATUS
PciIdeXSetBusData(
    IN PVOID DeviceExtension,
    IN PVOID Buffer,
    IN PVOID DataMask,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    )
{
    PCTRLFDO_EXTENSION fdoExtension = ((PCTRLFDO_EXTENSION) DeviceExtension) - 1;
    NTSTATUS status;
    PUCHAR pciData;
    KIRQL currentIrql;

    pciData = ExAllocatePool (NonPagedPool, BufferLength);
    if (pciData == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeAcquireSpinLock(
        &fdoExtension->PciConfigDataLock, 
        &currentIrql);
             
    //
    // get the current values
    //
    status = PciIdeBusData(
                 fdoExtension,
                 pciData,
                 ConfigDataOffset,
                 BufferLength,
                 TRUE
                 );
    if (NT_SUCCESS(status)) {

        ULONG i;
        PUCHAR dataMask = (PUCHAR) DataMask;
        PUCHAR newData = (PUCHAR) Buffer;

        for (i=0; i<BufferLength; i++) {

            // optimize for ULONG

            //
            // update bits according to the mask
            //
            pciData[i] = (pciData[i] & ~dataMask[i]) | (dataMask[i] & newData[i]);
        }

        status = PciIdeBusData(
                     fdoExtension,
                     pciData,
                     ConfigDataOffset,
                     BufferLength,
                     FALSE
                     );
    }

    KeReleaseSpinLock(
        &fdoExtension->PciConfigDataLock, 
        currentIrql);
        
    ExFreePool (pciData);
    return status;

} // PciIdeXSetBusData

NTSTATUS
PciIdeBusData(
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN OUT PVOID Buffer,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength,
    IN BOOLEAN ReadConfigData
    )
{
    ULONG byteTransferred;
    PGET_SET_DEVICE_DATA BusDataFunction;

    if (ReadConfigData) {

        BusDataFunction = FdoExtension->BusInterface.GetBusData;

    } else {

        BusDataFunction = FdoExtension->BusInterface.SetBusData;
    }

 //   if (!BusDataFunction) {
  //      DebugPrint((0, "PCIIDEX: ERROR: NULL BusDataFunction\n"));
   //     return STATUS_UNSUCCESSFUL;
    //}

    byteTransferred = BusDataFunction (
                         FdoExtension->BusInterface.Context,
                         PCI_WHICHSPACE_CONFIG,
                         Buffer,
                         ConfigDataOffset,
                         BufferLength
                         );

    if (byteTransferred != BufferLength) {

        return STATUS_UNSUCCESSFUL;

    } else {

        return STATUS_SUCCESS;
    }

} // PciIdeBusData

NTSTATUS
PciIdeBusDataCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
{
    PIO_STATUS_BLOCK ioStatus = (PIO_STATUS_BLOCK) Context;
    PKEVENT          event;

    ioStatus->Status = Irp->IoStatus.Status;
    event = (PKEVENT) ioStatus->Information;
    KeSetEvent (event, 0, FALSE);

    IoFreeIrp (Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
} // PciIdeBusDataCompletionRoutine

NTSTATUS
PciIdeInternalDeviceIoControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PDEVICE_EXTENSION_HEADER DoExtensionHeader;
    NTSTATUS status;

    PAGED_CODE();

    DoExtensionHeader = DeviceObject->DeviceExtension;

    if (DoExtensionHeader->AttacheeDeviceObject == NULL) {

        //
        // PDO
        //
        status = ChannelInternalDeviceIoControl (
            DeviceObject,
            Irp
            );

    } else {

        //
        // FDO
        //

        status = Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
} // PciIdeInternalDeviceIoControl

NTSTATUS
PciIdeXRegQueryRoutine (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)
{
    PVOID *parameterValue = EntryContext;

    PAGED_CODE();

    if (ValueType == REG_MULTI_SZ) {

        *parameterValue = ExAllocatePool(PagedPool, ValueLength);

        if (*parameterValue) {

            RtlMoveMemory(*parameterValue, ValueData, ValueLength);
            return STATUS_SUCCESS;
        }

    } else if (ValueType == REG_DWORD) {

        PULONG ulongValue;

        ulongValue = (PULONG) parameterValue;
        *ulongValue = *((PULONG) ValueData);
        return STATUS_SUCCESS;
    }

    return STATUS_UNSUCCESSFUL;
}
NTSTATUS
PciIdeXGetDeviceParameterEx (
    IN     PDEVICE_OBJECT      DeviceObject,
    IN     PWSTR               ParameterName,
    IN OUT PVOID              *ParameterValue
    )
/*++

Routine Description:

    retrieve a devnode registry parameter

Arguments:

    FdoExtension - FDO Extension
    
    ParameterName - parameter name to look up                                        
                                           
    ParameterValuse - default parameter value

Return Value:

    NT Status

--*/
{
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    ULONG                    i;
    ULONG                    flag;

    PAGED_CODE();

    *ParameterValue = NULL;

    for (i=0; i<2; i++) {

        if (i == 0) {

            flag = PLUGPLAY_REGKEY_DRIVER | PLUGPLAY_REGKEY_CURRENT_HWPROFILE;

        } else {

            flag = PLUGPLAY_REGKEY_DRIVER;
        }
        //
        // open the given parameter
        //
        status = IoOpenDeviceRegistryKey(DeviceObject,
                                         flag,
                                         KEY_READ,
                                         &deviceParameterHandle);
    
        if(!NT_SUCCESS(status)) {
    
            continue;
        }
    
        RtlZeroMemory(queryTable, sizeof(queryTable));
    
        queryTable->QueryRoutine  = PciIdeXRegQueryRoutine;
        queryTable->Flags         = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
        queryTable->Name          = ParameterName;
        queryTable->EntryContext  = ParameterValue;
        queryTable->DefaultType   = REG_NONE;
        queryTable->DefaultData   = NULL;
        queryTable->DefaultLength = 0;
    
        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) deviceParameterHandle,
                                        queryTable,
                                        NULL,
                                        NULL);
        if (!NT_SUCCESS(status)) {
    
            *ParameterValue = NULL;
        }
    
        //
        // close what we open
        //
        ZwClose(deviceParameterHandle);

        if (NT_SUCCESS(status)) {

            break;
        }
    }
    return status;

} // PciIdeXGetDeviceParameter

NTSTATUS
PciIdeXGetDeviceParameter (
    IN     PDEVICE_OBJECT      DeviceObject,
    IN     PWSTR               ParameterName,
    IN OUT PULONG              ParameterValue
    )
/*++

Routine Description:

    retrieve a devnode registry parameter

Arguments:

    FdoExtension - FDO Extension
    
    ParameterName - parameter name to look up                                        
                                           
    ParameterValuse - default parameter value

Return Value:

    NT Status

--*/
{
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    ULONG                    defaultParameterValue;   
    ULONG                    i;
    ULONG                    flag;

    PAGED_CODE();

    for (i=0; i<2; i++) {

        if (i == 0) {

            flag = PLUGPLAY_REGKEY_DRIVER | PLUGPLAY_REGKEY_CURRENT_HWPROFILE;

        } else {

            flag = PLUGPLAY_REGKEY_DRIVER;
        }
        //
        // open the given parameter
        //
        status = IoOpenDeviceRegistryKey(DeviceObject,
                                         flag,
                                         KEY_READ,
                                         &deviceParameterHandle);
    
        if(!NT_SUCCESS(status)) {
    
            continue;
        }
    
        RtlZeroMemory(queryTable, sizeof(queryTable));
    
        defaultParameterValue = *ParameterValue;
    
        queryTable->Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
        queryTable->Name          = ParameterName;
        queryTable->EntryContext  = ParameterValue;
        queryTable->DefaultType   = REG_NONE;
        queryTable->DefaultData   = NULL;
        queryTable->DefaultLength = 0;
    
        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) deviceParameterHandle,
                                        queryTable,
                                        NULL,
                                        NULL);
        if (!NT_SUCCESS(status)) {
    
            *ParameterValue = defaultParameterValue;
        }
    
        //
        // close what we open
        //
        ZwClose(deviceParameterHandle);

        if (NT_SUCCESS(status)) {

            break;
        }
    }
    return status;

} // PciIdeXGetDeviceParameter


VOID
PciIdeUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    get ready to be unloaded

Arguments:

    DriverObject - the driver being unloaded

Return Value:

    none

--*/

{
    PAGED_CODE();

    DebugPrint ((1, "PciIde: unloading...\n"));

    ASSERT (DriverObject->DeviceObject == NULL);
    return;
} // PciIdeUnload

NTSTATUS
PciIdeXSyncSendIrp (
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT OPTIONAL PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION  newIrpSp;
    PIRP                newIrp;
    KEVENT              event;
    NTSTATUS            status;

    ASSERT (TargetDeviceObject);
    ASSERT (IrpSp);
    PAGED_CODE();

    //
    // Allocate an IRP for below
    //
    newIrp = IoAllocateIrp (TargetDeviceObject->StackSize, FALSE);      // Get stack size from PDO
    if (newIrp == NULL) {

        DebugPrint ((0, "PciIdeXSyncSendIrp: Unable to get allocate an irp"));
        return STATUS_NO_MEMORY;
    }

    newIrpSp = IoGetNextIrpStackLocation(newIrp);
    RtlMoveMemory (newIrpSp, IrpSp, sizeof (*IrpSp));

    if (IoStatus) {

        newIrp->IoStatus.Status = IoStatus->Status;

    } else {

        newIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    }

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    IoSetCompletionRoutine (
        newIrp, 
        PciIdeXSyncSendIrpCompletionRoutine, 
        &event, 
        TRUE, 
        TRUE, 
        TRUE);
    status = IoCallDriver (TargetDeviceObject, newIrp);

    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject(&event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
    }
    status = newIrp->IoStatus.Status;

    if (IoStatus) {

        *IoStatus = newIrp->IoStatus;
    }

    IoFreeIrp (newIrp);
    return status;
} // PciIdeXSyncSendIrp

NTSTATUS
PciIdeXSyncSendIrpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PKEVENT event = Context;

    KeSetEvent(
        event,
        EVENT_INCREMENT,
        FALSE
        );

    return STATUS_MORE_PROCESSING_REQUIRED;
} // IdePortSyncSendIrpCompletionRoutine

#if DBG

NTSTATUS
PciIdeXSaveDeviceParameter (
    IN PVOID DeviceExtension,
    IN PWSTR ParameterName,
    IN ULONG ParameterValue
    )
/*++

Routine Description:

    save a devnode registry parameter

Arguments:

    FdoExtension - FDO Extension
    
    ParameterName - parameter name to save                                        
                                           
    ParameterValuse - parameter value to save

Return Value:

    NT Status

--*/
{
    NTSTATUS           status;
    HANDLE             deviceParameterHandle;
    PCTRLFDO_EXTENSION fdoExtension = ((PCTRLFDO_EXTENSION) DeviceExtension) - 1;

    PAGED_CODE();

    //
    // open the given parameter
    //
    status = IoOpenDeviceRegistryKey(fdoExtension->AttacheePdo,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_WRITE,
                                     &deviceParameterHandle);

    if(!NT_SUCCESS(status)) {

        DebugPrint((1,
                    "PciIdeXSaveDeviceParameter: IoOpenDeviceRegistryKey() returns 0x%x\n",
                    status));

        return status;
    }

    //
    // write the parameter value
    //
    status = RtlWriteRegistryValue(
                 RTL_REGISTRY_HANDLE,
                 (PWSTR) deviceParameterHandle,
                 ParameterName,
                 REG_DWORD,
                 &ParameterValue,
                 sizeof (ParameterValue)
                 );


    if(!NT_SUCCESS(status)) {

        DebugPrint((1,
                    "PciIdeXSaveDeviceParameter: RtlWriteRegistryValue() returns 0x%x\n",
                    status));
    }

    //
    // close what we open
    //
    ZwClose(deviceParameterHandle);
    return status;
} // IdePortSaveDeviceParameter

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\ide\pciidex\power.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       power.c
//
//--------------------------------------------------------------------------

#include "pciidex.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciIdeIssueSetPowerState)

#pragma alloc_text(NONPAGE, PciIdePowerCompletionRoutine)
#pragma alloc_text(NONPAGE, PciIdeSetPdoPowerState)
#pragma alloc_text(NONPAGE, PciIdeSetFdoPowerState)
#pragma alloc_text(NONPAGE, FdoContingentPowerCompletionRoutine)
#pragma alloc_text(NONPAGE, FdoPowerCompletionRoutine)
#pragma alloc_text(NONPAGE, FdoChildReportPowerDown)
#pragma alloc_text(NONPAGE, FdoChildRequestPowerUp)
#pragma alloc_text(NONPAGE, FdoChildRequestPowerUpCompletionRoutine)
#endif // ALLOC_PRAGMA


NTSTATUS
PciIdeIssueSetPowerState (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN POWER_STATE_TYPE   Type,
    IN POWER_STATE        State,
    IN BOOLEAN            Sync
    )
{
    PIRP                      irp = NULL;
    PIO_STACK_LOCATION        irpStack;
    SET_POWER_STATE_CONTEXT   context;
    NTSTATUS                  status;
    CCHAR                     stackSize;

    PAGED_CODE();

    if (Sync) {

        KeInitializeEvent(
            &context.Event,
            NotificationEvent,
            FALSE
            );
    }

    stackSize = (CCHAR) (FdoExtension->DeviceObject->StackSize + 1);

    irp = IoAllocateIrp(
            stackSize,
            FALSE
            );

    if (irp == NULL) {

        status = STATUS_NO_MEMORY;
        goto GetOut;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_POWER;
    irpStack->MinorFunction = IRP_MN_SET_POWER;

    irpStack->Parameters.Power.SystemContext = 0;
    irpStack->Parameters.Power.Type          = Type;
    irpStack->Parameters.Power.State         = State;

    IoSetCompletionRoutine(irp,
                           PciIdePowerCompletionRoutine,
                           Sync ? &context : NULL,
                           TRUE,
                           TRUE,
                           TRUE);

    status = PoCallDriver(FdoExtension->DeviceObject, irp);


    //
    //Wait for the completion routine. It will be called anyway.
    //
//    if ((status == STATUS_PENDING) && (Sync)) {
    if (Sync) {

        KeWaitForSingleObject(&context.Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = context.Status;
    }

GetOut:

    return status;
} // PciIdeIssueSetPowerState

NTSTATUS
PciIdePowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PSET_POWER_STATE_CONTEXT context = Context;

    if (context) {

        context->Status = Irp->IoStatus.Status;

        KeSetEvent(
            &context->Event,
            EVENT_INCREMENT,
            FALSE
            );
    }

    IoFreeIrp (Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
} // PciIdePowerCompletionRoutine


NTSTATUS
PciIdeXQueryPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PDEVICE_EXTENSION_HEADER deviceExtensionHeader;
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;

    deviceExtensionHeader = DeviceObject->DeviceExtension;

#if defined (DONT_POWER_DOWN_PAGING_DEVICE)

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    if (!deviceExtensionHeader->CrashDumpPathCount ||
        ((irpStack->Parameters.Power.Type == SystemPowerState) &&
         (irpStack->Parameters.Power.State.SystemState == PowerSystemWorking)) ||
        ((irpStack->Parameters.Power.Type == DevicePowerState) &&
         (irpStack->Parameters.Power.State.SystemState == PowerDeviceD0))) {

        status = STATUS_SUCCESS