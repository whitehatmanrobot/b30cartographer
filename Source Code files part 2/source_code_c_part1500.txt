ADPTR(lpdwSize,sizeof(DWORD)) )
	{
		return E_POINTER;
	}

	if( dwFlags != 0 )
	{
		return DVERR_INVALIDFLAGS;
	}

	DWORD dwIndex, dwReadIndex;
	DWORD dwRequiredSize = 0;
	DWORD dwTmpSize;

	LPDVCOMPRESSIONINFO lpdvTargetList;

	LPBYTE lpbExtraLoc = (LPBYTE) lpBuffer;

	*lpdwNumElements = 0;

	DVCDBProvider *pTmpProvider;

	pTmpProvider = g_dvcdbProviderList;

	while( pTmpProvider != NULL )
	{
		for( dwIndex = 0; dwIndex < pTmpProvider->dwNumElements; dwIndex++ )
		{
			dwRequiredSize += DVCDB_GetCompressionInfoSize( (LPDVCOMPRESSIONINFO) &pTmpProvider->pInfo[dwIndex] );
			(*lpdwNumElements)++;
		}
		
		pTmpProvider = pTmpProvider->pNext;
	}

	if( *lpdwSize < dwRequiredSize )
	{
		*lpdwSize = dwRequiredSize;	
		return DVERR_BUFFERTOOSMALL;
	}

	*lpdwSize = dwRequiredSize;	

	if( lpBuffer == NULL || !DNVALID_WRITEPTR(lpBuffer,dwRequiredSize) )
	{
		return E_POINTER;
	}

	lpbExtraLoc += (*lpdwNumElements)*sizeof(DVCOMPRESSIONINFO);
	lpdvTargetList = (LPDVCOMPRESSIONINFO) lpBuffer;

	pTmpProvider = g_dvcdbProviderList;

	dwIndex = 0;

	while( pTmpProvider != NULL )
	{
		for( dwReadIndex = 0; dwReadIndex < pTmpProvider->dwNumElements; dwReadIndex++, dwIndex++ )
		{
			memcpy( &lpdvTargetList[dwIndex], &pTmpProvider->pInfo[dwReadIndex], sizeof(DVCOMPRESSIONINFO) );

			if( pTmpProvider->pInfo[dwReadIndex].lpszDescription != NULL )
			{
				dwTmpSize = (wcslen( pTmpProvider->pInfo[dwReadIndex].lpszDescription )*2)+2;
				memcpy( lpbExtraLoc, pTmpProvider->pInfo[dwReadIndex].lpszDescription, dwTmpSize );
				lpdvTargetList[dwIndex].lpszDescription = (LPWSTR) lpbExtraLoc;
				lpbExtraLoc += dwTmpSize;
			}

			if( pTmpProvider->pInfo[dwReadIndex].lpszName != NULL )
			{
				dwTmpSize = (wcslen( pTmpProvider->pInfo[dwReadIndex].lpszName )*2)+2;
				memcpy( lpbExtraLoc, pTmpProvider->pInfo[dwReadIndex].lpszName, dwTmpSize );
				lpdvTargetList[dwIndex].lpszName = (LPWSTR) lpbExtraLoc;
				lpbExtraLoc += dwTmpSize;
			}
		}
		
		pTmpProvider = pTmpProvider->pNext;
	}	

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_GetCompressionInfoSize"
DWORD DVCDB_GetCompressionInfoSize( LPDVCOMPRESSIONINFO lpdvCompressionInfo )
{
	DNASSERT( lpdvCompressionInfo != NULL );

	DWORD dwSize;

	dwSize = sizeof( DVCOMPRESSIONINFO );
	
	if( lpdvCompressionInfo->lpszDescription != NULL )
	{
		dwSize += (wcslen( lpdvCompressionInfo->lpszDescription )*2)+2;
	}

	if( lpdvCompressionInfo->lpszName != NULL )
	{
		dwSize += (wcslen( lpdvCompressionInfo->lpszName)*2)+2;
	}

	return dwSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dxvtimer.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		timer.cpp
 *  Content:	Class to handle multimedia timers
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 10/05/99		rodtoll Added DPF_MODNAMEs
 * 01/14/2000	rodtoll	Updated to use DWORD_PTR to allow proper 64-bit operation 
 *
 ***************************************************************************/

#include "dxvutilspch.h"


// ORIGINAL HEADER:
// 
// Timer.cpp
//
// This file is from the MSDN, Visual Studuio 6.0 Edition
//
// Article:
// Streaming Wave Files With DirectSound
// 
// Author:
// Mark McCulley, Microsoft Corporation
//

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

static bool TimeKillSynchronousFlagAvailable( void );
static MMRESULT CompatibleTimeSetEvent( UINT uDelay, UINT uResolution, LPTIMECALLBACK lpTimeProc, DWORD_PTR dwUser, UINT fuEvent );

// constructor
#undef DPF_MODNAME
#define DPF_MODNAME "Timer::Timer"
Timer::Timer (void)
{
    DPFX(DPFPREP,  DVF_INFOLEVEL, "Timer::Timer\n\r");

    m_nIDTimer = NULL;
}


// Destructor
#undef DPF_MODNAME
#define DPF_MODNAME "Timer::~Timer"
Timer::~Timer (void)
{
    DPFX(DPFPREP,  DVF_INFOLEVEL, "Timer::~Timer\n\r");

    if (m_nIDTimer)
    {
        timeKillEvent (m_nIDTimer);
    }
}


// Create
#undef DPF_MODNAME
#define DPF_MODNAME "Timer::Create"
BOOL Timer::Create (UINT nPeriod, UINT nRes, DWORD_PTR dwUser, TIMERCALLBACK pfnCallback)
{
    BOOL bRtn = SUCCESS;    // assume success
    
    DPFX(DPFPREP,  DVF_INFOLEVEL, "Timer::Create\n\r");

    DNASSERT (pfnCallback);
    DNASSERT (nPeriod > 10);
    DNASSERT (nPeriod >= nRes);

    m_nPeriod = nPeriod;
    m_nRes = nRes;
    m_dwUser = dwUser;
    m_pfnCallback = pfnCallback;

    if ((m_nIDTimer = CompatibleTimeSetEvent (m_nPeriod, m_nRes, TimeProc, (DWORD_PTR) this, TIME_PERIODIC | TIME_KILL_SYNCHRONOUS)) == NULL)
    {
        bRtn = FAILURE;
    }

    return (bRtn);
}

/******************************************************************************

CompatibleTimeSetEvent

    CompatibleTimeSetEvent() unsets the TIME_KILL_SYNCHRONOUS flag before calling
timeSetEvent() if the current operating system does not support the 
TIME_KILL_SYNCHRONOUS flag.  TIME_KILL_SYNCHRONOUS is supported on Windows XP and
later operating systems.

Parameters:
- The same parameters as timeSetEvent().  See timeSetEvent()'s documentation in 
the Platform SDK for more information.

Return Value:
- The same return value as timeSetEvent().  See timeSetEvent()'s documentation in 
the Platform SDK for more information.

******************************************************************************/
MMRESULT CompatibleTimeSetEvent( UINT uDelay, UINT uResolution, LPTIMECALLBACK lpTimeProc, DWORD_PTR dwUser, UINT fuEvent )
{
    static bool fCheckedVersion = false;
    static bool fTimeKillSynchronousFlagAvailable = false; 

    if( !fCheckedVersion ) {
        fTimeKillSynchronousFlagAvailable = TimeKillSynchronousFlagAvailable();
        fCheckedVersion = true;
    }

    if( !fTimeKillSynchronousFlagAvailable ) {
        fuEvent = fuEvent & (TIME_ONESHOT |
                             TIME_PERIODIC |
                             TIME_CALLBACK_FUNCTION |
                             TIME_CALLBACK_EVENT_SET |
                             TIME_CALLBACK_EVENT_PULSE);
    }
 
    return timeSetEvent( uDelay, uResolution, lpTimeProc, dwUser, fuEvent );
}

bool TimeKillSynchronousFlagAvailable( void )
{
    OSVERSIONINFO osverinfo;

    osverinfo.dwOSVersionInfoSize = sizeof(osverinfo);

    if( GetVersionEx( &osverinfo ) ) {
        
        // Windows XP's major version is 5 and its' minor version is 1.
        // timeSetEvent() started supporting the TIME_KILL_SYNCHRONOUS flag
        // in Windows XP.
        if( (osverinfo.dwMajorVersion > 5) || 
            ( (osverinfo.dwMajorVersion == 5) && (osverinfo.dwMinorVersion >= 1) ) ) {
            return true;
        }
    }

    return false;
}

// Timer proc for multimedia timer callback set with timeSetTime().
//
// Calls procedure specified when Timer object was created. The 
// dwUser parameter contains "this" pointer for associated Timer object.
// 
#undef DPF_MODNAME
#define DPF_MODNAME "Timer::TimeProc"
void CALLBACK Timer::TimeProc(UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)
{
    // dwUser contains ptr to Timer object
    Timer * ptimer = (Timer *) dwUser;

    if( ptimer != NULL )
    {
        // Call user-specified callback and pass back user specified data
        (ptimer->m_pfnCallback) (ptimer->m_dwUser);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dxvutilspch.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxvutilspch.h
 *  Content:    DirectPlayVoice DXVUTILS master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DXVUTILSPCH_H__
#define __DXVUTILSPCH_H__

// 
// Public includes
//
#include <windows.h>
#include <string>
#include <mmsystem.h>
#include <tchar.h>
#include <string>
#include <list>
#include <vector>
#include <math.h>
#include <mmddk.h>

// 
// DirectX public includes
//
#include <dsoundp.h>
#include <dsprv.h>

// 
// DirectPlay public includes
//
#include "dvoice.h"
#include "dpvcp.h"

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dndbg.h"
#include "comutil.h"
#include "creg.h"
#include "strutils.h"

// 
// DirectPlay Voice private includes
//
//#include "fdtcfg.h"

// 
// DirectPlay Voice Utils includes
//
#include "dvcdb.h"
#include "aplayb.h"
#include "aplayd.h"
#include "arecb.h"
#include "mixline.h"
#include "dsplayb.h"
#include "diagnos.h"
#include "sndutils.h"
#include "dsplayd.h"
#include "dsprvobj.h"
#include "dxexcp.h"
#include "dsutils.h"
#include "inqueue2.h"
#include "innerque.h"
#include "bfcsynch.h"
#include "wiutils.h"
#include "arecd.h"
#include "dscrecd.h"
#include "Timer.h"
#include "devmap.h"
#include "dscrecb.h"
#include "decibels.h"
#include "frame.h"
#include "agcva.h"
#include "agcva1.h"
#include "wavformat.h"

#include "resource.h"

#include "..\..\..\bldcfg\dpvcfg.h"

#endif // __DXVUTILSPCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dxexcp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dxexcp.h
 *  Content:	Definition of the DirectXException class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 11/12/99		rodtoll	Aded include for tchar, required.
 *
 ***************************************************************************/

#ifndef __DIRECTXEXCEPTION_H
#define __DIRECTXEXCEPTION_H

// These constants are used by the DirectX Exception class.
//
const unsigned int cMaxFuncLength = 100;
const unsigned int cMaxErrorLength = 100;

// DirectXException
//
// This class is the exception class for handling exceptions from
// errors from DirectX libraries.  It is used as the base class
// for the various DirectX exceptions.  (E.g. DirectSoundException).
//
class DirectXException: public exception
{
public:

    DirectXException( const TCHAR *funcName, HRESULT result, const unsigned int moduleID = 0, unsigned int lineNumber = 0 )
    {
        _tcscpy( m_szFunctionName, funcName );
        m_uiModuleID = moduleID;
        m_uiLineNumber = lineNumber;
        m_result = result;
        MapResultToString();
    }

    DirectXException( const DirectXException &except )
    {
        m_result = except.m_result;
        m_uiModuleID = except.m_uiModuleID;
        _tcscpy( m_szFunctionName, except.m_szFunctionName );
        _tcscpy( m_szErrorString, except.m_szErrorString );
    }

    virtual const TCHAR *what()
    {
        return m_szErrorString;
    }

    unsigned int    m_uiLineNumber;
    unsigned int    m_uiModuleID;
    HRESULT         m_result;
    TCHAR           m_szFunctionName[cMaxFuncLength];
    TCHAR           m_szErrorString[cMaxErrorLength];

protected:
    virtual void MapResultToString( ) {};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dverror.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dverror.cpp
 *  Content:	Error string handling
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 01/21/2000	pnewson Created
 *  04/19/2000	pnewson	    Error handling cleanup  
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define MESSAGE_STRING_MAX_LEN 256
#define MAX_ERROR_CODE_STRING_LEN 8

static const TCHAR* g_tszDefaultMessage = "DirectPlay Voice has encountered an error\r\n(The error code was 0x%x)";
static const TCHAR* g_tszDefaultMessageCaption = "Error";

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DisplayDefaultErrorBox"
void DV_DisplayDefaultErrorBox(HRESULT hr, HWND hwndParent)
{
	DPFX(DPFPREP, DVF_ERRORLEVEL, "DV_DisplayDefaultErrorBox called");

	TCHAR tszMsgFmt[MESSAGE_STRING_MAX_LEN];
	
	if (_tcslen(g_tszDefaultMessage) + MAX_ERROR_CODE_STRING_LEN + 1 < MESSAGE_STRING_MAX_LEN)
	{
		_stprintf(tszMsgFmt, g_tszDefaultMessage, hr);
	}
	else
	{	
		// Programmer mess up, DNASSERT if we're in debug, otherwise just
		// copy what we can of the default message over.
		DNASSERT(FALSE);
		_tcsncpy(tszMsgFmt, g_tszDefaultMessage, MESSAGE_STRING_MAX_LEN - 1);
	}
	
	MessageBox(hwndParent, tszMsgFmt, g_tszDefaultMessageCaption, MB_OK|MB_ICONERROR);
	
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DisplayErrorBox"
void DV_DisplayErrorBox(HRESULT hr, HWND hwndParent, UINT idsErrorMessage)
{
	DPFX(DPFPREP, DVF_ERRORLEVEL, "DV_DisplayErrorBox called");

	TCHAR tszMsg[MESSAGE_STRING_MAX_LEN];
	TCHAR tszMsgFmt[MESSAGE_STRING_MAX_LEN];
	TCHAR tszCaption[MESSAGE_STRING_MAX_LEN];
	
	HINSTANCE hDPVoiceDll = LoadLibrary("dpvoice.dll");
	if (hDPVoiceDll == NULL)
	{
		// Very weird! go with a default message.
		DPFX(DPFPREP, DVF_ERRORLEVEL, "LoadLibrary(dpvoice.dll) failed - using default hardcoded message");
		DV_DisplayDefaultErrorBox(hr, hwndParent);
		return;
	}
	
	if (!LoadString(hDPVoiceDll, IDS_ERROR_CAPTION, tszCaption, MESSAGE_STRING_MAX_LEN))
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "LoadString failed - using default hardcoded message");
		DV_DisplayDefaultErrorBox(hr, hwndParent);
		return;
	}

	if (idsErrorMessage == 0)
	{
		if (!LoadString(hDPVoiceDll, IDS_ERROR_MSG, tszMsg, MESSAGE_STRING_MAX_LEN))
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "LoadString failed - using default hardcoded message");
			DV_DisplayDefaultErrorBox(hr, hwndParent);
			return;
		}

		if (_tcslen(tszMsg) + MAX_ERROR_CODE_STRING_LEN + 1 < MESSAGE_STRING_MAX_LEN)
		{
			_stprintf(tszMsgFmt, tszMsg, hr);
		}
		else
		{	
			// Programmer mess up, DNASSERT if we're in debug, otherwise just
			// copy what we can of the default message over.
			DNASSERT(FALSE);
			_tcsncpy(tszMsgFmt, tszMsg, MESSAGE_STRING_MAX_LEN - 1);
		}
	}
	else
	{
		// This is the only custom error message that we expect at this time
		DNASSERT(idsErrorMessage == IDS_ERROR_NODEVICES);
		if (!LoadString(hDPVoiceDll, IDS_ERROR_NODEVICES, tszMsgFmt, MESSAGE_STRING_MAX_LEN))
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "LoadString failed - using default hardcoded message");
			DV_DisplayDefaultErrorBox(hr, hwndParent);
			return;
		}		
	}
	
	if (!IsWindow(hwndParent))
	{
		hwndParent = NULL;
	}

	PlaySound( _T("SystemExclamation"), NULL, SND_ASYNC );	
	MessageBox(hwndParent, tszMsgFmt, tszCaption, MB_OK|MB_ICONERROR);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\innerque.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		innerque.cpp
 *  Content:
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 07/27/99		pnewson Overhauled to support new message numbering method 
 * 08/03/99		pnewson General clean up
 * 08/24/99		rodtoll	Fixed for release builds -- removed m_wQueueId from debug block
 * 10/28/99		pnewson Bug #113933 debug spew too verbose
 *						implement inner queue pool code
 * 10/29/99		rodtoll	Bug #113726 - Integrate Voxware Codecs.  Plugged memory leak
 *                      caused as a result of new architecture.
 * 01/14/2000	rodtoll	Updated to use new Frame SetEqual function
 * 01/31/2000	pnewson replace SAssert with DNASSERT
 * 06/28/2000	rodtoll	Prefix Bug #38022
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define MODULE_ID   INNERQUEUE

// the number of slots reseved to account for 
// out of order startup frames. For example, if the first
// three frames of a message arrive in the order 3, 2, 1, instead
// of 1, 2, 3, we must reserve 2 slots in front of the "first"
// frame (3) so we'll have a place to put the tardy 1 and 2.
const BYTE c_bNumStartSlots = 2;

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::CInnerQueue"
CInnerQueue::CInnerQueue(
	BYTE bNumSlots,
	WORD wFrameSize,
	CFramePool* pfpFramePool,
	DNCRITICAL_SECTION* pcsQueue,
	BYTE bMsgNum,
	BYTE bHighWaterMark,
	WORD wQueueId
	)
	: m_bNumSlots(bNumSlots)
	, m_eState(CInnerQueue::empty)
	, m_bHighWaterMark(bHighWaterMark)
	, m_bQueueSize(0)
	, m_bHeadSeqNum(0)
	, m_fFirstDequeue(true)
	//, m_rgeSlotStates(NULL)
	, m_rgpfrSlots(NULL)
	, m_bFillingDequeueReqs(0)
	, m_wMissingFrames(0)
	, m_wDuplicateFrames(0)
	, m_wOverflowFrames(0)
	, m_wLateFrames(0)
	, m_wPossibleZeroLengthDequeues(0)
	, m_wKnownZeroLengthDequeues(0)
	, m_dwMsgLen(0)
	, m_wQueueId(wQueueId)
	, m_bMsgNum(bMsgNum)
	, m_pfpFramePool(pfpFramePool)
	, m_pcsQueue(pcsQueue)
	, m_fInited(FALSE)
{
	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::CInnerQueue() CFramePool: %p", m_wQueueId, m_bMsgNum, m_pfpFramePool);
	#endif

	// verify that bNumSlots is at least 8, and is a
	// power of 2.
	DNASSERT(bNumSlots == 0x08 || 
		bNumSlots == 0x10 ||
		bNumSlots == 0x20 ||
		bNumSlots == 0x40 ||
		bNumSlots == 0x80);

	// Check to make sure the watermark is not larger
	// than the number of slots. It should really be 
	// significantly less than bNumSlots, but oh well.
	// 
	DNASSERT(bHighWaterMark < bNumSlots - c_bNumStartSlots);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::Init"
HRESULT CInnerQueue::Init()
{
	int i;

	/*
	// allocate the slot state array
	m_rgeSlotStates = new ESlotState[m_bNumSlots];
	if (m_rgeSlotStates == NULL)
	{
		goto error;		
	}
	*/

	// allocate the slot array
	m_rgpfrSlots = new CFrame*[m_bNumSlots];
	if (m_rgpfrSlots == NULL)
	{
		goto error;		
	}

	// Initialize the slot states and the slots
	for (i = 0; i < m_bNumSlots; ++i)
	{
		//m_rgeSlotStates[i] = essEmpty;
		m_rgpfrSlots[i] = NULL;
	}

	m_fInited = TRUE;
	return S_OK;

error:
	/*
	if (m_rgeSlotStates != NULL)
	{
		delete [] m_rgeSlotStates;
		m_rgeSlotStates = NULL;
	}
	*/
	if (m_rgpfrSlots != NULL)
	{
		delete [] m_rgpfrSlots;
		m_rgpfrSlots = NULL;		
	}
	m_fInited = FALSE;
	return E_FAIL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::~CInnerQueue"
CInnerQueue::~CInnerQueue()
{
	if (m_fInited)
	{
		/*
		if (m_rgeSlotStates != NULL)
		{
			delete [] m_rgeSlotStates;
			m_rgeSlotStates = NULL;
		}
		*/
		if (m_rgpfrSlots != NULL)
		{
			// check to ensure that no frames are in use
			for (int i = 0; i < m_bNumSlots; ++i)
			{
				if( m_rgpfrSlots[i] != NULL )
					m_rgpfrSlots[i]->Return();
			}
	
			delete [] m_rgpfrSlots;
			m_rgpfrSlots = NULL;
		}
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::Reset"
void CInnerQueue::Reset()
{
	if (!m_fInited)
	{
		return;
	}
	
	// loop through and make sure none of the frames are currently locked and clear the slot states
	for (int i = 0; i < m_bNumSlots; ++i)
	{
		if (m_rgpfrSlots[i] != NULL)
		{
			m_rgpfrSlots[i]->Return();
		}
		//m_rgeSlotStates[i] = essEmpty;
	}

	m_eState = CInnerQueue::empty;
	m_bQueueSize = 0;
	m_bHeadSeqNum = 0;
	m_fFirstDequeue = true;
	m_bFillingDequeueReqs = 0;

	ResetStats();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::ResetStats"
void CInnerQueue::ResetStats()
{
	if (!m_fInited)
	{
		return;
	}

	m_wMissingFrames = 0;
	m_wDuplicateFrames = 0;
	m_wOverflowFrames = 0;
	m_wLateFrames = 0;
	m_dwMsgLen = 0;
	m_wPossibleZeroLengthDequeues = 0;
	m_wKnownZeroLengthDequeues = 0;
}

// This function is not inline because it needs the module id, sigh.
#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::SetHighWaterMark"
void CInnerQueue::SetHighWaterMark(BYTE bHighWaterMark) 
{ 	
	if (!m_fInited)
	{
		return;
	}

	DNASSERT(bHighWaterMark < m_bNumSlots);
	m_bHighWaterMark = bHighWaterMark;
}

// Note: this class does not have it's own critical
// section. The caller must ensure that enqueue and
// dequeue are not called at the same time. It is 
// intended that this class is used only within
// the InputQueue2 class, which does have a critical
// section.
#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::Enqueue"
void CInnerQueue::Enqueue(const CFrame& frFrame)
{
	if (!m_fInited)
	{
		return;
	}

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() MsgNum[%i] SeqNum[%i]", m_wQueueId, m_bMsgNum, frFrame.GetMsgNum(), frFrame.GetSeqNum());
	#endif

	DNASSERT(m_eState != finished);

	if (m_eState == empty)
	{
		// This is the first frame, so set the head of the queue.
		// NOTE: It may seem strange to set the head of the
		// queue to 2 frames before the first one we receive,
		// but this covers the case where the first frame
		// we receive is not the first frame of the message.
		// By using this logic, if any of the first, second
		// or third frames arrive first, we will not chop
		// off the start of the message. When the user
		// asks for the first dequeue, it will skip the
		// empty slots at the head of the queue, assuming
		// they haven't been filled in.
		m_bHeadSeqNum = (frFrame.GetSeqNum() - c_bNumStartSlots);
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() new message - m_bHeadSeqNum[%i]", m_wQueueId, m_bMsgNum, m_bHeadSeqNum);
		DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() state changed to filling", m_wQueueId, m_bMsgNum);
		#endif
		m_eState = filling;
	}

	// Check to see if we should put this frame into the queue.
	//
	// NOTE: The logic below implicitly checks for queue overflows.
	// if the sequence number is out of the allowable range, one
	// of two things may have happened.
	// 1) queue overflow
	// 2) frame arrived too late
	//
	// First we need to know if we are dealing with a wraparound 
	// problem.
	bool fKeepFrame = false;
	if ((BYTE)(m_bHeadSeqNum + m_bNumSlots) < m_bHeadSeqNum)
	{
		// we've got a wraparound problem, so use this alternate logic
		if (frFrame.GetSeqNum() >= m_bHeadSeqNum
			|| frFrame.GetSeqNum() < (BYTE)(m_bHeadSeqNum + m_bNumSlots))
		{
			fKeepFrame = true;
		}
	}
	else
	{
		// no wraparound problem, so use the straightforward logic
		if (frFrame.GetSeqNum() >= m_bHeadSeqNum
			&& frFrame.GetSeqNum() < m_bHeadSeqNum + m_bNumSlots)
		{
			fKeepFrame = true;
		}
	}

	// if we're supposed to keep this frame, copy it into the
	// appropriate slot
	if (fKeepFrame)
	{
		BYTE bSlot = frFrame.GetSeqNum() % m_bNumSlots;

		// check to see if this slot is full
		//if (m_rgeSlotStates[bSlot] == essFull)
		if (m_rgpfrSlots[bSlot] != NULL)
		{
			// This is a duplicate frame, so don't do anything
			// with it, but tell the debugger about it, and
			// update our stats.
			//
			// NOTE: We know that this a duplicate frame and
			// not a queue overflow because we have already
			// checked for queue overflow above.
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() Ignoring duplicate frame, sequence number[%i], slot[%i]",
				m_wQueueId, m_bMsgNum, frFrame.GetSeqNum(), bSlot);
			#endif
			m_wDuplicateFrames++;
		}
		else
		{
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() putting frame in slot[%i]", m_wQueueId, m_bMsgNum, bSlot);
			#endif

			// if the frame previously occupying this slot has not
			// yet been released, this slot will not have a null pointer.
			DNASSERT(m_rgpfrSlots[bSlot] == NULL);

			// get a frame from the pool
			//m_rgpfrSlots[bSlot] = m_pfpFramePool->Get(m_pcsQueue, &m_rgpfrSlots[bSlot]);
			m_rgpfrSlots[bSlot] = m_pfpFramePool->Get(m_pcsQueue, NULL);

			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() got frame from pool, Addr:%p", m_wQueueId, m_bMsgNum, m_rgpfrSlots[bSlot]);
			#endif
				
			/* RMT -- Added new func to copy frames directly.

			// the client number is the same
			m_rgpfrSlots[bSlot]->SetClientId(frFrame.GetClientId());

            // copy the target
            m_rgpfrSlots[bSlot]->SetTarget(frFrame.GetTarget());

			// No one but this function should be using
			// the sequence number, so just zero it out.
			m_rgpfrSlots[bSlot]->SetSeqNum(0);

			// copy the frame's data, also sets the frame length
			m_rgpfrSlots[bSlot]->CopyData(frFrame);

			// set the silence flag
			m_rgpfrSlots[bSlot]->SetIsSilence(frFrame.GetIsSilence()); */

			HRESULT hr;

			hr = m_rgpfrSlots[bSlot]->SetEqual(frFrame);

			if( FAILED( hr ) )
			{
				DNASSERT( FALSE );
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to copy frame in innerque" );
			}
			
			// this buffer is now full
			//m_rgeSlotStates[bSlot] = essFull;

			// increment the queue size
			++m_bQueueSize;
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() new queue size[%i]", m_wQueueId, m_bMsgNum, m_bQueueSize);
			#endif

			// if the queue is currently filling, check to see if we've
			// passed the high water mark.
			if (m_eState == filling && m_bQueueSize > m_bHighWaterMark)
			{
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() High Water Mark hit, now in ready state", m_wQueueId, m_bMsgNum);
				#endif
				m_bFillingDequeueReqs = 0;
				m_eState = ready;
			}
		}
	}
	else
	{
		// Make a guess as to what caused this: overflow or late frame
		// Sequence numbers are allowed to be in the range 0 to 255.
		// if a sequence number is somewhere in the range 127 prior
		// to the current queue head (accounting for wraparound) then
		// assume it's a late frame. Otherwise, assume it's an overflow frame.
		if ((frFrame.GetSeqNum() < m_bHeadSeqNum
			&& frFrame.GetSeqNum() > (int)m_bHeadSeqNum - 127)
			|| (frFrame.GetSeqNum() > (128 + m_bHeadSeqNum)))
		{
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() Late frame, discarded", m_wQueueId, m_bMsgNum);
			#endif
			m_wLateFrames++;
		}
		else
		{
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Enqueue() Overflow frame, discarded", m_wQueueId, m_bMsgNum);
			#endif
			m_wOverflowFrames++;
		}
	}

	return;
}

// Note: this class does not have it's own critical
// section. The caller must ensure that enqueue and
// dequeue are not called at the same time. It is 
// intended that this class is used only within
// the InputQueue2 class, which does have a critical
// section.
#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueue::Dequeue"
CFrame* CInnerQueue::Dequeue()
{
	CFrame* pfrReturn;
	
	if (!m_fInited)
	{
		return NULL;
	}

	// make sure that we're in the ready state
	DNASSERT(m_eState == ready);

	// The only class that should be using this one should
	// never call dequeue when there's nothing to get, so assert
	DNASSERT(m_bQueueSize != 0);

	// If we get here, there is at least one frame in the queue, somewhere.

	// increment the length of the message
	++m_dwMsgLen;

	// find the index of the oldest frame, starting with the frame at the 
	// head of the queue.
	BYTE bSlot = m_bHeadSeqNum % m_bNumSlots;
	int i = 0;

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Dequeue() Checking slot[%i]", m_wQueueId, m_bMsgNum, bSlot);
	#endif
	//while (m_rgeSlotStates[bSlot] != essFull)
	while (m_rgpfrSlots[bSlot] == NULL)
	{
		// if this is the first dequeue, then we want to skip any empty
		// slots to find the first frame in the message. Otherwise, this
		// is a lost frame, and should be treated accordingly.
		if (m_fFirstDequeue == true)
		{
			// The current slot does not have a frame, try the
			// next. Put in a little sanity check for infinite
			// looping.
			DNASSERT(i++ < m_bNumSlots);
			++bSlot;
			bSlot %= m_bNumSlots;
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Dequeue() slot empty, checking slot[%i]", m_wQueueId, m_bMsgNum, bSlot);
			#endif

			// increment the head sequence number
			++m_bHeadSeqNum;
		}
		else
		{
			// This is a lost frame
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Dequeue() Frame Missing", m_wQueueId, m_bMsgNum);
			#endif
			++m_wMissingFrames;

			// this missing frame is part of the message too, so 
			// increment the total message size
			++m_dwMsgLen;

			// increment the head sequence number
			++m_bHeadSeqNum;

			// this is no longer the first dequeue
			m_fFirstDequeue = false;

			// return a silent frame marked as lost
			CFrame* pfr = m_pfpFramePool->Get(m_pcsQueue, NULL);
			pfr->SetIsSilence(true);
			pfr->SetIsLost(true);

			return pfr;
		}
	}

	m_fFirstDequeue = false;

	// By now, bSlot points to a valid, useful frame, which
	// we should return.

	// mark the slot we are about to return as empty
	//m_rgeSlotStates[bSlot] = essEmpty;

	// decrement the queue size
	--m_bQueueSize;
	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP, DVF_INFOLEVEL, "** QUEUE ** %i:%i ** CInnerQueue::Dequeue() Returning frame in slot[%i]; New queue size[%i]", m_wQueueId, m_bMsgNum, bSlot, m_bQueueSize);
	#endif

	// increment the head sequence number
    ++m_bHeadSeqNum;

	// this is not a lost frame
	//m_rgpfrSlots[bSlot]->SetIsLost(false);
	pfrReturn = m_rgpfrSlots[bSlot];
	pfrReturn->SetIsLost(false);
	m_rgpfrSlots[bSlot] = NULL;

	//return(m_rgpfrSlots[bSlot]);
	return(pfrReturn);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueuePool::CInnerQueuePool"
CInnerQueuePool::CInnerQueuePool(
	BYTE bNumSlots,
	WORD wFrameSize,
	CFramePool* pfpFramePool,
	DNCRITICAL_SECTION* pcsQueue)
	: m_bNumSlots(bNumSlots)
	, m_wFrameSize(wFrameSize)
	, m_pfpFramePool(pfpFramePool)
	, m_pcsQueue(pcsQueue)
	, m_fCritSecInited(FALSE)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueuePool::~CInnerQueuePool"
CInnerQueuePool::~CInnerQueuePool()
{
	for (std::vector<CInnerQueue *>::iterator iter1 = m_vpiqPool.begin(); iter1 < m_vpiqPool.end(); ++iter1)
	{
		delete *iter1;
	}
	if (m_fCritSecInited)
	{
		DNDeleteCriticalSection(&m_lock);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueuePool::Get"
CInnerQueue* CInnerQueuePool::Get(		
		BYTE bHighWaterMark,
		WORD wQueueId,
		BYTE bMsgNum
)
{
	HRESULT hr;
	
	BFCSingleLock csl(&m_lock);
	csl.Lock(); 

	CInnerQueue* piq;
	if (m_vpiqPool.empty())
	{
		// the pool is empty, return a new inner queue
		piq = new CInnerQueue(
			m_bNumSlots,
			m_wFrameSize,
			m_pfpFramePool,
			m_pcsQueue,
			bMsgNum,
			bHighWaterMark,
			wQueueId);

		if( piq == NULL )
			return NULL;

		hr = piq->Init();	
		if (FAILED(hr))
		{
			delete piq;
			return NULL;
		}
	}
	else
	{
		// there are some inner queues in the pool, pop
		// the last one off the back of the vector
		piq = m_vpiqPool.back();
		m_vpiqPool.pop_back();
		piq->SetMsgNum(bMsgNum);
		piq->SetQueueId(wQueueId);
		piq->SetHighWaterMark(bHighWaterMark);
		piq->Reset();
	}

	return piq;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInnerQueuePool::Return"
void CInnerQueuePool::Return(CInnerQueue* piq)
{
	BFCSingleLock csl(&m_lock);
	csl.Lock(); 

	// drop this inner queue on the back for reuse
	m_vpiqPool.push_back(piq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\inqueue2.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		inqueue2.cpp
 *  Content:
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 07/27/99		pnewson Overhauled to support new message numbering method 
 * 08/03/99		pnewson General clean up
 * 08/24/99		rodtoll	Fixed for release builds -- removed m_wQueueId from debug block
 * 10/28/99		pnewson Bug #113933 debug spew too verbose 
 * 01/31/2000	pnewson replace SAssert with DNASSERT
 * 02/17/2000	rodtoll	Bug #133691 - Choppy audio - queue was not adapting
 * 07/09/2000	rodtoll	Added signature bytes 
 * 08/28/2000	masonb  Voice Merge: Change #if DEBUG to #ifdef DEBUG
 * 09/13/2000	rodtoll	Bug #44519 - Fix for fix.  
 * 10/24/2000	rodtoll	Bug #47645 - DPVOICE: Memory corruption - quality array end being overwritten
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define MODULE_ID   INPUTQUEUE2

const int c_iHighestQualitySliderValue = 31;
const int c_iHighestRecentBiasSliderValue = 31;
const double c_dHighestPossibleQuality = 0.001;
const double c_dLowestPossibleQuality = 0.05;
const double c_dHighestPossibleAggr = 5000.0;
const double c_dLowestPossibleAggr = 120000.0;
const double c_dMaxDistanceFromOpt = 100.0;
const double c_dQualityTimeFactor = 1000.0; // in ms
const double c_dQualityFactor = 2.0;

const int c_iFinishedQueueLifetime = 2000; // in ms

#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::CInputQueue2"
CInputQueue2::CInputQueue2( )
		: m_dwSignature(VSIG_INPUTQUEUE2)
		, m_fFirstDequeue(TRUE)
		, m_fFirstEnqueue(TRUE)
		, m_bCurMsgNum(0)
		, m_vdQualityRatings(0)
		, m_vdFactoredOptQuals(0)
		, m_bCurHighWaterMark(0)
		, m_bMaxHighWaterMark(0)
		, m_bInitHighWaterMark(0)
		, m_wQueueId(0)
		, m_dwTotalFrames(0)
		, m_dwTotalMessages(0)
		, m_dwTotalBadMessages(0)
		, m_dwDiscardedFrames(0)
		, m_dwDuplicateFrames(0)
		, m_dwLostFrames(0)
		, m_dwLateFrames(0)
		, m_dwOverflowFrames(0)
		, m_wMSPerFrame(0)
		, m_pFramePool(NULL)
{
}

HRESULT CInputQueue2::Initialize( PQUEUE_PARAMS pParams )
{
    m_fFirstDequeue = TRUE;
    m_fFirstEnqueue = TRUE;
    m_bCurMsgNum = 0;
    m_vdQualityRatings.resize(pParams->bMaxHighWaterMark);
    m_vdFactoredOptQuals.resize(pParams->bMaxHighWaterMark);
    m_bCurHighWaterMark = pParams->bInitHighWaterMark;
    m_bMaxHighWaterMark = pParams->bMaxHighWaterMark;
    m_bInitHighWaterMark = pParams->bInitHighWaterMark;
    m_wQueueId = pParams->wQueueId;
    m_dwTotalFrames = 0;
    m_dwTotalMessages = 0;
    m_dwTotalBadMessages = 0;
    m_dwDiscardedFrames = 0;
    m_dwDuplicateFrames = 0;
    m_dwLostFrames = 0;
    m_dwLateFrames = 0;
    m_dwOverflowFrames = 0;
    m_wMSPerFrame = pParams->wMSPerFrame;
    m_pFramePool = pParams->pFramePool;

	if (!DNInitializeCriticalSection(&m_csQueue))
	{
		return DVERR_OUTOFMEMORY;
	}

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::CInputQueue2() bInnerQueueSize: %i"), m_wQueueId, bInnerQueueSize);
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::CInputQueue2() bMaxHighWaterMark: %i"), m_wQueueId, bMaxHighWaterMark);
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::CInputQueue2() bInitHighWaterMark: %i"), m_wQueueId, bInitHighWaterMark);
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::CInputQueue2() pFramePool: %p"), m_wQueueId, m_pFramePool);
	#endif

	//// TODO(pnewson, "use one inner queuepool for all queues")
	m_pInnerQueuePool = 
		new CInnerQueuePool(
			pParams->bInnerQueueSize,
			pParams->wFrameSize,
			m_pFramePool,
			&m_csQueue);

    if( m_pInnerQueuePool == NULL )
    {
        DPFX(DPFPREP,  0, "Error allocating innerqueue pool!" );
		DNDeleteCriticalSection(&m_csQueue);
        return DVERR_OUTOFMEMORY;
    }

	if (!m_pInnerQueuePool->Init())
	{
		delete m_pInnerQueuePool;
		DNDeleteCriticalSection(&m_csQueue);
		return DVERR_OUTOFMEMORY;
	}

	// see header for explanation
	// since this is the first time, init the
	// member variables, before we call the set
	// functions. Weird, but it makes the debug
	// messages cleaner. It doesn't acutally 
	// fix a real problem.
	#ifdef DEBUG
	m_iQuality = pParams->iQuality;
	m_iHops = pParams->iHops;
	m_iAggr = pParams->iAggr;
	#endif
	SetQuality(pParams->iQuality, pParams->iHops);
	SetAggr(pParams->iAggr);

	// set the queue to an empty state
	Reset();

    return DV_OK;
}

void CInputQueue2::GetStatistics( PQUEUE_STATISTICS pQueueStats )
{
    pQueueStats->dwTotalFrames = GetTotalFrames();
    pQueueStats->dwTotalMessages = GetTotalMessages();
    pQueueStats->dwTotalBadMessages = GetTotalBadMessages();
    pQueueStats->dwDiscardedFrames = GetDiscardedFrames();
    pQueueStats->dwDuplicateFrames = GetDuplicateFrames();
    pQueueStats->dwLostFrames = GetLostFrames();
    pQueueStats->dwLateFrames = GetLateFrames();
    pQueueStats->dwOverflowFrames = GetOverflowFrames();
}

void CInputQueue2::DeInitialize()
{
	// delete anything remaining in the inner queue list
	for (std::list<CInnerQueue*>::iterator iter = m_lpiqInnerQueues.begin(); iter != m_lpiqInnerQueues.end(); ++iter)
	{
		delete *iter;
    }

	m_lpiqInnerQueues.clear();

	if( m_pInnerQueuePool )
	{
	    delete m_pInnerQueuePool;
	    m_pInnerQueuePool = NULL;	
	}

	DNDeleteCriticalSection(&m_csQueue);
}

// The destructor. Release all the resources we acquired in the
// constructor
#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::~CInputQueue2"
CInputQueue2::~CInputQueue2()
{
    DeInitialize();
	m_dwSignature = VSIG_INPUTQUEUE2_FREE;
}

// This function clears all the input buffers and 
// resets the other class information to an initial
// state. The queue should not be in use when this 
// function is called. i.e. there should not be any
// locked frames.
#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::Reset"
void CInputQueue2::Reset()
{
	// make sure no one is using the queue right now
	BFCSingleLock csl(&m_csQueue);
	csl.Lock();

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Reset()"), m_wQueueId);
	#endif

	// loop through and return all inner queues to the pool
	for (std::list<CInnerQueue*>::iterator iter = m_lpiqInnerQueues.begin(); iter != m_lpiqInnerQueues.end(); ++iter)
	{
		m_pInnerQueuePool->Return(*iter);
    }

	// the next frame will be the first one we accept
	m_fFirstEnqueue = TRUE;

	// we have not yet received a dequeue request
	m_fFirstDequeue = TRUE;

	// we don't yet know the first message number, so just use zero
	m_bCurMsgNum = 0;

	// we should reset back to zero for the current high water mark
	m_bCurHighWaterMark = m_bInitHighWaterMark;

	// reset the track record on the various high water marks
	for (int i = 0; i < m_bMaxHighWaterMark; ++i)
	{
		m_vdQualityRatings[i] = m_vdFactoredOptQuals[i];
	}

	// reset all the other stats too
	m_dwDiscardedFrames = 0;
	m_dwDuplicateFrames = 0;
	m_dwLateFrames = 0;
	m_dwLostFrames = 0;
	m_dwOverflowFrames = 0;
	m_dwQueueErrors = 0;
	m_dwTotalBadMessages = 0;
	m_dwTotalFrames = 0;
	m_dwTotalMessages = 0;
}

// Call this function to add a frame to the queue.  I 
// considered returning a reference to a frame which 
// the caller could then stuff, but because the frames
// will not always arrive in order, that would mean I would have
// to copy the frame sometimes anyway.  So, for simplicity, the
// caller has allocated a frame, which it passes a reference
// to, and this function will copy that frame into the
// appropriate place in the queue, according to its
// sequence number.
#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::Enqueue"
void CInputQueue2::Enqueue(const CFrame& fr)
{
	// start the critical section
	BFCSingleLock csl(&m_csQueue);
	csl.Lock();

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** ******************************************"), m_wQueueId);
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() MsgNum[%i] SeqNum[%i]"), m_wQueueId, fr.GetMsgNum(), fr.GetSeqNum());
	#endif

	// Only add the frame if a dequeue has been
	// requested. This allows the producer and
	// consumer threads to sync up during their
	// startup, or after a reset.
	if (m_fFirstDequeue == TRUE)
	{
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() First Dequeue Not Yet Received - Frame Discarded"), m_wQueueId);
		#endif
		return;
	}

	// check to see if this is the first enqueue request
	// we've accepted.
	if (m_fFirstEnqueue == TRUE)
	{
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() First Enqueue"), m_wQueueId);
		#endif

		// clear the first frame flag
		m_fFirstEnqueue = FALSE;

		// Since this is the first frame we are accepting, 
		// we can just get a new inner queue without
		// worry that one already exists for this message.
		// Note that there should not be any queues already!
		DNASSERT(m_lpiqInnerQueues.size() == 0);
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() Creating Inner queue for MsgNum %i"), m_wQueueId, fr.GetMsgNum());
		#endif
		m_lpiqInnerQueues.push_back(m_pInnerQueuePool->Get(m_bCurHighWaterMark, m_wQueueId, fr.GetMsgNum()));

		// stuff the frame into the inner queue
		(*m_lpiqInnerQueues.begin())->Enqueue(fr);
	}
	else
	{
		// see if we already have a queue started for this message number
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() Checking for an inner queue to put this frame into"), m_wQueueId);
		#endif
		bool fDone = false;
		for (std::list<CInnerQueue*>::iterator iter = m_lpiqInnerQueues.begin(); iter != m_lpiqInnerQueues.end(); ++iter)
		{
			#if defined(DPVOICE_QUEUE_DEBUG)
			DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() found inner queue for msg number %i"), m_wQueueId, (*iter)->GetMsgNum());
			#endif
			if ((*iter)->GetMsgNum() == fr.GetMsgNum())
			{
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() this is the one, queue size: %i"), m_wQueueId, (*iter)->GetSize());
				#endif
				// we have found the queue for this frame
				switch ((*iter)->GetState())
				{
				case CInnerQueue::empty:
					// we should not get here, since this state is
					// only valid for the first frame of a message,
					// which is added to the queue below, not in this
					// case statement.
					DNASSERT(false);
					break;

				case CInnerQueue::filling:
					// check to see if the queue was empty
					#if defined(DPVOICE_QUEUE_DEBUG)
					DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() inner queue in filling state"), m_wQueueId);
					#endif
					if ((*iter)->GetSize() == 0)
					{
						// the queue was empty. If we have been
						// trying to dequeue from it, we now know
						// that the message was not done, so those
						// dequeues were breaks in the speech.
						// update the stats accordingly
						#if defined(DPVOICE_QUEUE_DEBUG)
						DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() - converting possible zero length dequeues to known in MsgNum[%i]"), m_wQueueId, fr.GetMsgNum());
						#endif						
						(*iter)->AddToKnownZeroLengthDequeues(
							(*iter)->GetPossibleZeroLengthDequeues());
					}

					// NOTE: falling through!!!

				case CInnerQueue::ready:
					#if defined(DPVOICE_QUEUE_DEBUG)
					DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() inner queue in ready state (unless the previous message said filling)"), m_wQueueId);
					DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() calling InnerQueue->Enqueue MsgNum[%i]"), m_wQueueId, fr.GetMsgNum());
					#endif
					(*iter)->Enqueue(fr);
					break;

				case CInnerQueue::finished:
					// do nothing, just discard the frame
					#if defined(DPVOICE_QUEUE_DEBUG)
					DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() not calling InnerQueue->Enqueue - MsgNum[%i] in finished state, discarding frame"), m_wQueueId, fr.GetMsgNum());
					#endif
					break;
				}

				// done, get out.
				return;
			}
		}

		// If we get here, there is not already a queue active for this 
		// message number, so create one and stuff it with the frame and add
		// it to the list.
		
		//// TODO(pnewson, "Use the message number to insert the new inner queue in the right place")
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() Creating Inner queue for MsgNum %i"), m_wQueueId, fr.GetMsgNum());
		#endif		
		CInnerQueue* piq = m_pInnerQueuePool->Get(m_bCurHighWaterMark, m_wQueueId, fr.GetMsgNum());
		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Enqueue() calling InnerQueue->Enqueue MsgNum[%i]"), m_wQueueId, fr.GetMsgNum());
		#endif
		piq->Enqueue(fr);
		m_lpiqInnerQueues.push_back(piq);
	}
}

// This function retrieves the next frame from the head of
// the queue.  For speed, it does not copy the data out of the
// buffer, but instead returns a pointer to the actual
// frame from the queue.  When the caller is finished with 
// the CFrame object, it should call Return() on it. This will
// return the frame to the frame pool, and update the queue's
// internal pointers to show that the queue slot is now free. 
// If the caller doesn't call Return() in time, when the queue
// attempts to reuse the slot, it will DNASSERT(). The caller
// should always Return frame before it attempts to dequeue 
// another one.
#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::Dequeue"
CFrame* CInputQueue2::Dequeue()
{
	// start the critical section
	BFCSingleLock csl(&m_csQueue);
	csl.Lock();

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** ******************************************"), m_wQueueId);
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue()"), m_wQueueId);
	#endif
	
	CFrame* pfrReturn = 0;

	if (m_fFirstDequeue == TRUE)
	{
		#if defined(DPVOICE_QUEUE_DEBUG)
        DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() First Dequeue"), m_wQueueId);
		#endif
		
		// trigger the interlock, so we're free to start enqueueing
		m_fFirstDequeue = FALSE;

		// since we're not allowed to enqueue until after the
		// first dequeue, there will be no inner queues. 
		// So return a silent frame
		pfrReturn = m_pFramePool->Get(&m_csQueue, NULL);
	    pfrReturn->SetIsSilence(TRUE);
		pfrReturn->SetIsLost(false);
		return pfrReturn;
	}
	else
	{
		pfrReturn = 0;
		int iDeadTime;
		// cycle through the list of active inner queues
		std::list<CInnerQueue*>::iterator iter = m_lpiqInnerQueues.begin();
		while (iter != m_lpiqInnerQueues.end())
		{
			std::list<CInnerQueue*>::iterator cur = iter;
			std::list<CInnerQueue*>::iterator next = ++iter;
			switch ((*cur)->GetState())
			{
			case CInnerQueue::finished:
				// We keep these old, dead inner queues around for a while
				// so that any late straggling frames that were part of this
				// message get discarded. We know when to kill them off for 
				// good because we keep incrementing the possible zero length
				// dequeue count. If this finished queue is stale enough,
				// return it to the pool.
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() current queue in finished state"), m_wQueueId);
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() PossibleZeroLengthDequeues: %i"), m_wQueueId, (*cur)->GetPossibleZeroLengthDequeues());
				#endif
				(*cur)->IncPossibleZeroLengthDequeues();
				iDeadTime = (*cur)->GetPossibleZeroLengthDequeues() * m_wMSPerFrame;
				if (iDeadTime > c_iFinishedQueueLifetime)
				{
					// this queue has been dead long enough, kill it off
					#if defined(DPVOICE_QUEUE_DEBUG)
					DPFX(DPFPREP, DVF_INFOLEVEL, "***** RETURNING INNER QUEUE TO POOL *****");
					#endif
					m_pInnerQueuePool->Return(*cur);
					m_lpiqInnerQueues.erase(cur);
				}
				break;

			case CInnerQueue::filling:
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() current queue in filling state"), m_wQueueId);
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() queue size: %i"), m_wQueueId, (*cur)->GetSize());
				#endif
				if ((*cur)->GetSize() > 0)
				{
					// If there is a message after this one, then release this
					// message for playback.
					// OR
					// If we have been spinning trying to release this message
					// for a while, then just let it go... The message may be
					// too short to trip the high water mark.
					#if defined(DPVOICE_QUEUE_DEBUG)
					DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() filling dequeue reqs: %i"), m_wQueueId, (*cur)->GetFillingDequeueReqs());
					#endif
					if (next != m_lpiqInnerQueues.end()
						|| (*cur)->GetFillingDequeueReqs() > (*cur)->GetHighWaterMark())
					{
						// set the state to ready, and dequeue
						#if defined(DPVOICE_QUEUE_DEBUG)
						DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() setting state to ready and dequeing"), m_wQueueId);
						#endif						
						(*cur)->SetState(CInnerQueue::ready);
						return (*cur)->Dequeue();
					}
				}
				else
				{
					// there is nothing in this queue
					// check to see if another message has begun to arrive
					if (next != m_lpiqInnerQueues.end())
					{
						// there is another message coming in after this
						// one, so flip this queue to the finished state
						#if defined(DPVOICE_QUEUE_DEBUG)
						DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() new message arriving, setting state to finished"), m_wQueueId);
						#endif
						(*cur)->SetState(CInnerQueue::finished);

						// harvest the stats from this message, now that it
						// is done
						HarvestStats(*cur);
						
						// Go to the next iteration of this loop, which will
						// either dequeue a frame from the next message, or 
						// return an empty frame
						break;
					}
				}

				// if we get here, there is something in this queue, but we are 
				// not yet ready to release it yet.
				// we should return an extra frame and remember
				// that we've been here...
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() not ready to release message, returning empty frame"), m_wQueueId);
				#endif				
				(*cur)->IncFillingDequeueReqs();
				pfrReturn = m_pFramePool->Get(&m_csQueue, NULL);
				pfrReturn->SetIsSilence(TRUE);
				pfrReturn->SetIsLost(false);
				return pfrReturn;

			case CInnerQueue::ready:
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() Queue Size: %i"), m_wQueueId, (*cur)->GetSize());
				#endif
				// check to see if this ready queue is empty
				if ((*cur)->GetSize() == 0)
				{
					// increment the possible zero length dequeue count
					(*cur)->IncPossibleZeroLengthDequeues();

					// check to see if another message has begun to arrive
					if (next != m_lpiqInnerQueues.end())
					{
						#if defined(DPVOICE_QUEUE_DEBUG)
						DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() queue is empty, new message arriving, setting state to finished"), m_wQueueId);
						#endif
						
						// there is another message coming in after this
						// one, so flip this queue to the finished state
						(*cur)->SetState(CInnerQueue::finished);

						// harvest the stats from this message, now that it
						// is done
						HarvestStats(*cur);

						// Go to the next iteration of this loop, which will
						// either dequeue a frame from the next message, or 
						// return an empty frame
						break;
					}

					// there is nothing in this queue, and there are no more 
					// messages arriving after this one, so boot this inner 
					// queue into the filling state so if this is just a long
					// pause in the message, it will fill to the high water mark
					// again before it begins to play again.
					#if defined(DPVOICE_QUEUE_DEBUG)
					DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() queue is empty, setting state to filling, returning empty frame"), m_wQueueId);
					#endif
					(*cur)->SetState(CInnerQueue::filling);

					// return an extra frame
					pfrReturn = m_pFramePool->Get(&m_csQueue, NULL);
					pfrReturn->SetIsSilence(TRUE);
					pfrReturn->SetIsLost(false);
					return pfrReturn;
				}
				else
				{
					// there's something to return, so do it
					return (*cur)->Dequeue();
				}
			}
		}

		#if defined(DPVOICE_QUEUE_DEBUG)
		DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::Dequeue() nothing available in inner queues, returning empty frame"), m_wQueueId);
		#endif
		// if we get here, there was nothing suitable in the queues
		// (if there were any queues) so return an extra frame
		pfrReturn = m_pFramePool->Get(&m_csQueue, NULL);
		pfrReturn->SetIsSilence(TRUE);
		pfrReturn->SetIsLost(false);
		return pfrReturn;
	}
}
		
// This function should be called each time a queue is moved to the finished
// state. That's when we have officially declared that the message is finished,
// so it's a good time to see how we handled it. This will also reset the 
// stats so the next message starts fresh.
#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::HarvestStats"
void CInputQueue2::HarvestStats(CInnerQueue* piq)
{
	m_dwDuplicateFrames += piq->GetDuplicateFrames();

	// now that the message is actually complete, we're in a better
	// position to decide accurately how many frames were late
	// vs. how many were actually lost. When something isn't
	// there when it's needed, we increment the missing frames
	// count. If it subsequently arrives, it's counted as late.
	// Therefore the true count of lost frames is the difference
	// between the missing and late counts. Ditto if a frame,
	// overflows. We discard it so it's not there when we need it,
	// it will then get reported as missing. So subtract that too.
	m_dwLostFrames += piq->GetMissingFrames() 
		- piq->GetLateFrames() - piq->GetOverflowFrames();

	m_dwLateFrames += piq->GetLateFrames();
	m_dwOverflowFrames += piq->GetOverflowFrames();

	// What to do with the zero length dequeue stat? From a 
	// certain point of view, only one frame was late. From
	// another point of view, all the subsequent frames were
	// late. Hmmm.... Lets take the middle road and say that
	// for each failed zero length dequeue we'll count it as
	// equivalent to a late frame
	m_dwLateFrames += piq->GetKnownZeroLengthDequeues();

	m_dwTotalFrames += piq->GetMsgLen();

	m_dwTotalMessages++;

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::HarvestStats() DuplicateFrames:%i; MissingFrames:%i; LateFrames:%i; OverflowFrames:%i; KnownZeroLengthDequeues:%i; MsgLen:%i;"),
		m_wQueueId, piq->GetDuplicateFrames(), piq->GetMissingFrames(), piq->GetLateFrames(), piq->GetOverflowFrames(), piq->GetKnownZeroLengthDequeues(), piq->GetMsgLen());
	#endif		

	// Build a carefully formatted debug string that will give me some data,
	// but not give away all of our wonderful queue secrets.

	// dump the string to the debug log
	// Note!!! If you change the format of this debug string,
	// please roll the version number, i.e. HVT1A -> HVT2A so
	// we can decode any logs!
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("HVT1A:%i:%i:%i:%i:%i:%i"),
		m_wQueueId, 
		m_bCurHighWaterMark,
		(int)(m_vdQualityRatings[m_bCurHighWaterMark] * 10000),
		piq->GetMsgLen(), 
		piq->GetKnownZeroLengthDequeues() + piq->GetLateFrames(), 
		piq->GetMissingFrames());

	// The idea:
	// The quality quotient is a number between 0 and 1 that indicates
	// the quality of the current connection. 0 means perfect - no bad
	// stuff, ever. 1 means awful -  100% bad stuff. The number
	// is really a weighted average of the number of good frames vs the number
	// of bad frames, biased towards the recent frames. The message
	// we just received makes up 'm_wFrameStrength * m_wMsgLen' percent of the 
	// total value. The past history is deweighted by (1 - m_wFrameStrength*m_wMsgLen)
	// so the significance of a message decays as time goes by 
	// and according to the size of the message (number of frames).
	//
	// Another idea:
	// Keep a vector that tracks how good the quality is at each
	// high water mark.
	// That way, when we want to make a jump up or down in the
	// water mark, we can consider it carefully first. This 
	// gives the adaptive algorithm some memory of what life
	// was like at each queue level.
	// We choose an optimum level, like .02, that we are 
	// shooting for. We keep searching the space of high water 
	// marks until we find the one that's closest to the 
	// optimum. This optimum is configurable.
	//
	// The initial quality of each of the high water marks
	// is set to the optimum. This quality will then
	// vary as that high water mark gains experience.
	// If it dips below a certain threshold, then 
	// we'll jump to the next level up. If that one
	// is too good, it will go above a threshold, at
	// which point we can consider going back down.
	//
	// The problem with this is the sudden things that games
	// dish out (like when Q2 starts up) when they don't
	// lets us have the CPU for a while. These could 
	// unduly punish a particular high water mark,
	// there's really not much we can do about it. 
	// Oh, well. We'll give it a shot.

	// Adjust the quality rating of this watermark.
	// The algorithm is requires the results from the last
	// message, contained in the inner queue, along with the
	// current quality rating.
	DNASSERT( m_bCurHighWaterMark < m_bMaxHighWaterMark );
	m_vdQualityRatings[m_bCurHighWaterMark] = 
		AdjustQuality(piq, m_vdQualityRatings[m_bCurHighWaterMark]);

	// see if this put us above the highest acceptable quality rating
	// we asserted that m_dOptimumQuality != 0.0 in SetQuality, so we
	// don't need to check for division by zero
	if (m_vdQualityRatings[m_bCurHighWaterMark] / m_vdFactoredOptQuals[m_bCurHighWaterMark] > m_dQualityThreshold)
	{
		// Check to see which is closer
		// the the optimum quality - the current high water
		// mark or the one above it. Only do this test if
		// we're not already at the maximum high water mark
		if (m_bCurHighWaterMark < (m_bMaxHighWaterMark-1) )
		{
			// To check the "distance" from the optimum, use the 
			// inverse of the qualities. That normalizes it to 
			// our perception of quality

			// calculate how far the current high water mark
			// is from optimum
			double dCurDistFromOpt = m_vdQualityRatings[m_bCurHighWaterMark] / m_vdFactoredOptQuals[m_bCurHighWaterMark];
			if (dCurDistFromOpt < 1)
			{
				// quality ratings can never go to zero (enforced in 
				// AdjustQuality() so this division will never by by zero
				dCurDistFromOpt = 1.0 / dCurDistFromOpt;
			}

			// calculate how far the next high water mark is from
			// optimum
			//
			// quality ratings can never go to zero (enforced in 
			// AdjustQuality() so this division will never by by zero
			double dNextDistFromOpt = m_vdFactoredOptQuals[m_bCurHighWaterMark + 1] / m_vdQualityRatings[m_bCurHighWaterMark + 1];
			if (dNextDistFromOpt < 1)
			{
				dNextDistFromOpt = 1.0 / dNextDistFromOpt;
			}

			// if the next high water mark is closer to the 
			// optimum than this one, switch to it.
			if (dNextDistFromOpt < dCurDistFromOpt)
			{
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::HarvestStats() Raising High Water Mark to %i"), m_wQueueId, m_bCurHighWaterMark + 1); 
				#endif
				SetNewHighWaterMark(m_bCurHighWaterMark + 1);
			}
		}
	}

	// see if this put us below the low threshold
	//
	// quality ratings can never go to zero (enforced in 
	// AdjustQuality() so this division will never by by zero
	if (m_vdFactoredOptQuals[m_bCurHighWaterMark] / m_vdQualityRatings[m_bCurHighWaterMark] > m_dQualityThreshold)
	{
		// The quality has moved below the high quality threshold
		// Check to see what is closer to the optimum quality -
		// the current high water mark or the one below this one.
		// Only do this test if we're not already at a zero
		// high water mark.
		if (m_bCurHighWaterMark > 0)
		{
			// To check the "distance" from the optimum, use the 
			// inverse of the qualities. That normalizes it to 
			// our perception of quality

			// calculate how far the current high water mark
			// is from optimum
			double dCurDistFromOpt = m_vdQualityRatings[m_bCurHighWaterMark] / m_vdFactoredOptQuals[m_bCurHighWaterMark];
			if (dCurDistFromOpt < 1)
			{
				dCurDistFromOpt = 1.0 / dCurDistFromOpt;
			}

			// calculate how far the previous (lower) high water mark is from
			// optimum
			double dPrevDistFromOpt = m_vdFactoredOptQuals[m_bCurHighWaterMark - 1] / m_vdQualityRatings[m_bCurHighWaterMark - 1];
			if (dPrevDistFromOpt < 1)
			{
				dPrevDistFromOpt = 1.0 / dPrevDistFromOpt;
			}

			// if the prev high water mark is closer to the 
			// optimum than this one, switch to it.
			if (dPrevDistFromOpt < dCurDistFromOpt)
			{
				#if defined(DPVOICE_QUEUE_DEBUG)
				DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::HarvestStats() Lowering High Water Mark to %i"), m_wQueueId, m_bCurHighWaterMark - 1); 
				#endif
				SetNewHighWaterMark(m_bCurHighWaterMark - 1);
			}
		}
	}

	// clear the stats on the inner queue
	piq->ResetStats();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::AdjustQuality"
double CInputQueue2::AdjustQuality(CInnerQueue* piq, double dCurrentQuality)
{
	// if the message is zero length, no adjustment is made
	// to the queue...
	if (piq->GetMsgLen() == 0)
	{
		return dCurrentQuality;
	}

	// The longer a message, the stronger its effect on the
	// current quality rating.
	double dWeighting = min(piq->GetMsgLen() * m_dFrameStrength, 1.0);

	// The message quality is the quotient of bad
	// stuff that happened (zero length dequeues
	// and late frames) to the total number of 
	// frames in the message. Note that we do not
	// count lost frames against the message since
	// moving to a higher water mark wouldn't help.
	// Note that we impose a "worst case" of 1.0
	double dMsgQuality = min(((double)(piq->GetKnownZeroLengthDequeues() + piq->GetLateFrames()) / (double)piq->GetMsgLen()), 1.0);

	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::AdjustQuality() dWeighting: %g; dMsgQuality: %g; dCurrentQuality %g;"), 
		m_wQueueId, dWeighting, dMsgQuality, dCurrentQuality); 
	#endif

	// The new quality rating is a combination of the
	// current quality rating, and the quality of the 
	// most recent message, weighted by the message length.
	double dNewQuality = (dCurrentQuality * (1.0 - dWeighting)) + (dMsgQuality * dWeighting);

	// We don't want to allow extremes of quality, or else they will set up 
	// barriers in the queue statistics that can never be overcome (especially
	// a "perfect" quality of zero). So we check here to make sure that the
	// new quality is within reason.
	double dCurDistFromOpt = dNewQuality / m_dOptimumQuality;
	if (dCurDistFromOpt < 1.0 / c_dMaxDistanceFromOpt)
	{
		dNewQuality = m_dOptimumQuality / c_dMaxDistanceFromOpt;
	}
	else if (dCurDistFromOpt > c_dMaxDistanceFromOpt)
	{
		dNewQuality = m_dOptimumQuality * c_dMaxDistanceFromOpt;
	}
	return dNewQuality;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::SetNewHighWaterMark"
void CInputQueue2::SetNewHighWaterMark(BYTE bNewHighWaterMark)
{
	DNASSERT( bNewHighWaterMark < m_bMaxHighWaterMark );

	if( bNewHighWaterMark >= m_bMaxHighWaterMark )
	{
		DNASSERT( FALSE );
		return;
	}
		
	m_bCurHighWaterMark = bNewHighWaterMark;

	for (std::list<CInnerQueue*>::iterator iter = m_lpiqInnerQueues.begin(); iter != m_lpiqInnerQueues.end(); iter++)
	{
		(*iter)->SetHighWaterMark(bNewHighWaterMark);
	}

	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::SetQuality"
void CInputQueue2::SetQuality(int iQuality, int iHops)
{
	m_iQuality = iQuality;
	m_iHops = iHops;
	double dQualityRatio = c_dHighestPossibleQuality / c_dLowestPossibleQuality;
	double dInputRatio = (double) iQuality / (double) c_iHighestQualitySliderValue;
	m_dOptimumQuality = pow(dQualityRatio, dInputRatio) * c_dLowestPossibleQuality;
	#if defined(DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::SetQuality(%i, %i): m_dOptimumQuality: %f" ), m_wQueueId, iQuality, iHops, m_dOptimumQuality);
	#endif

	// The quality that the user has requested should be considered
	// over the number of hops involved. At the end of each hop is
	// a queue who's watermark will be set according to this rating,
	// To get an end to end quality that reflects the user's choice,
	// this queue's quality rating must be better if it is not the
	// only queue in the path. The total number of on time packets is
	// the product (as in multiple) of on time packets for each hop.
	// Therefore we need to take the Nth root of 1-m_dOptimumQuality
	// where N is the number of hops, and subtract that value from 1
	// to get the appropriate quality rating for this queue. (get that?)
	if (m_iHops > 1)
	{
		m_dOptimumQuality = (1 - pow((1.0 - m_dOptimumQuality), 1.0 / (double)m_iHops));
	}

	// the optimum quality should never be zero, or completely perfect,
	// or the algorithm will not work.
	DNASSERT(m_dOptimumQuality != 0.0);

	// update the vector of factored qualities
	// We don't just use the raw optimum as provided by the
	// caller. We "factor" it such that as the high watermark
	// gets larger (and the latency therefore longer) we are
	// willing to accept a lower quality.
	for (int i = 0; i < m_bMaxHighWaterMark; ++i)
	{
		m_vdFactoredOptQuals[i] = m_dOptimumQuality *
			pow(c_dQualityFactor, (double)(i * m_wMSPerFrame) / c_dQualityTimeFactor);
	}

	// Build a carefully formatted debug string that will give me some data,
	// but not give away all of our wonderful queue secrets.

	// dump the string to the debug log
	// Note!!! If you change the format of this debug string,
	// please roll the version number, i.e. HVT1B -> HVT2B so
	// we can decode any logs!
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("HVT1B:%i:%i:%i:%i"), m_wQueueId, m_iQuality, m_iHops, m_iAggr);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::SetAggr"
void CInputQueue2::SetAggr(int iAggr)
{
	m_iAggr = iAggr;
	double dAggrRatio = c_dHighestPossibleAggr / c_dLowestPossibleAggr;
	double dInputRatio = (double) iAggr / (double) c_iHighestQualitySliderValue;
	double dAggr = pow(dAggrRatio, dInputRatio) * c_dLowestPossibleAggr;

	// The aggressiveness is the number of milliseconds of "memory" the queue
	// has for each watermark. To find the frame strength, divide the 
	// number of milliseconds per frame by the "memory".
	m_dFrameStrength = (double)m_wMSPerFrame / dAggr;
		
	// We are using a fixed 1% threshold now - the aggressiveness is now set
	// through the frame strength. This low threshold will make the queue
	// adapt very quickly at first, while it is learning something about
	// the various watermarks, but will settle down more after that.
	m_dQualityThreshold = 1.01;

	#if defined (DPVOICE_QUEUE_DEBUG)
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("** QUEUE ** %i ** CInputQueue2::SetAggr(%i): dAggr: %f, m_dFrameStrength: %f, m_dQualityThreshold %f"), m_wQueueId, m_iAggr, dAggr, m_dFrameStrength, m_dQualityThreshold);
	#endif

	// Build a carefully formatted debug string that will give me some data,
	// but not give away all of our wonderful queue secrets.

	// dump the string to the debug log
	// Note!!! If you change the format of this debug string,
	// please roll the version number, i.e. HVT1C -> HVT2C so
	// we can decode any logs!
	DPFX(DPFPREP,  DVF_INFOLEVEL, _T("HVT1C:%i:%i:%i:%i"), m_wQueueId, m_iQuality, m_iHops, m_iAggr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\inqueue2.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		inqueue2.h
 *  Content:	Definition of the CInputQueue2 class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 07/27/99		pnewson Overhauled to support new message numbering method 
 * 08/03/99		pnewson General clean up
 * 08/24/99		rodtoll	Fixed for release builds -- removed m_wQueueId from debug block
 * 01/31/2000	pnewson replace SAssert with DNASSERT
 * 03/26/2000   rodtoll Modified queue to be more FPM friendly
 * 03/29/2000	rodtoll Bug #30753 - Added volatile to the class definition
 *  07/09/2000	rodtoll	Added signature bytes 
 *
 ***************************************************************************/

#ifndef _INPUTQUEUE2_H_
#define _INPUTQUEUE2_H_

class CFrame;
class CFramePool;
class CInnerQueue;
class CInnerQueuePool;

typedef struct _QUEUE_PARAMS
{
    WORD wFrameSize;
	BYTE bInnerQueueSize;
	BYTE bMaxHighWaterMark;
	int iQuality;
	int iHops;
	int iAggr;
	BYTE bInitHighWaterMark;
	WORD wQueueId;
	WORD wMSPerFrame;
	CFramePool* pFramePool;
} QUEUE_PARAMS, *PQUEUE_PARAMS;

typedef struct _QUEUE_STATISTICS
{
    DWORD dwTotalFrames;
    DWORD dwTotalMessages;
    DWORD dwTotalBadMessages;
    DWORD dwDiscardedFrames;
    DWORD dwDuplicateFrames;
    DWORD dwLostFrames;
    DWORD dwLateFrames;
    DWORD dwOverflowFrames;
} QUEUE_STATISTICS, *PQUEUE_STATISTICS;

// This class manages a queue of frames. It is designed
// to allow a client class to remove frames from the queue
// at regular intervals, and to hide any out of order
// frame reception, or dropped frames from the caller.
// If for whatever reason there is no frame available
// to give a client, this class will still provide a
// frame marked as silent.  This allows the client to
// simply call the dequeue function once per period, and
// consume the data at the agreed rate.  So for example,
// the client to this class could be a thread which
// is consuming input data and passing it to DirectSound
// for playback. It can simply get a frame every 1/10 of
// a second (or however long a frame is), and play it.
//
// This is the second generation of input queue. It 
// manages a set of inner queues, each of which is used
// for a "message". The stream of speech is divided into
// a series of messages, using silence as the divider.
// This class will not function well if the audio stream
// is not divided into separate messages.
//
#define VSIG_INPUTQUEUE2		'QNIV'
#define VSIG_INPUTQUEUE2_FREE	'QNI_'
//
volatile class CInputQueue2
{
private:
	DWORD m_dwSignature; // Debug signature

	// A list of pointers to InnerQueue objects. This is where
	// the frames get stored. InnerQueues are retrieved from
	// a pool of InnerQueues and added to this list as new 
	// messages arrive. When a message is finished, the InnerQueue
	// is removed from this list and returned to the pool.
	std::list<CInnerQueue*> m_lpiqInnerQueues;

	// The queue will not enqueue any input frames until at least
	// one dequeue has been requested. This will function as an interlock
	// to ensure that the queue does not fill with data until the
	// consumer thread is ready to take it.
	BOOL m_fFirstDequeue;

	// This flag remembers if it's the first time a frame
	// has been accepted for enqueue. We need this so we
	// know what the first message number is.
	BOOL m_fFirstEnqueue;

	// The message number currently at the head of the queue
	BYTE m_bCurMsgNum;

	// A critical section used to exclude the enqueue, dequeue and reset
	// functions from one another. Also passed to the frame class so 
	// Return calls can be synchronized. These two classes need to share
	// a critical section because the CFramePool class updates the
	// CFrame pointers in the inner queues when a frame is returned to 
	// the frame pool.
	DNCRITICAL_SECTION m_csQueue;

	// a vector of the quality ratings of each high water mark
	std::vector<double> m_vdQualityRatings;

	// A vector that contains the factored optimum quality for
	// each high water mark. As the high water mark gets larger
	// we become more tolerant of lost packets. While you may 
	// want to have a 0.5% late packet rate at 0.1 or 0.2 second
	// long queues, you probably don't want to strive for that
	// when the queue size reaches 2 seconds!
	std::vector<double> m_vdFactoredOptQuals;

	// the quality parameters

	// Quality is measured by a floating point number.
	// This number represents the ratio of "bad stuff" that occurs
	// relative to the amount of "stuff" going on.
	//
	// In intuitive terms, if one of the last 100 frames was bad
	// (bad meaning late) the quality rating would be 0.01. (Note
	// that we don't count lost frames against the queue, since
	// increasing the queue size won't do anything to help lost
	// frames.)
	//
	// However, the measurement isn't quite that simple, because we 
	// bias it towards the more recent frames. That's what the frame
	// strength parameter is for. It represents the "weight" given to
	// the most recent frames. A frame strength of 0.01 would mean that 
	// the most recent frame counts for 1% of the quality of the queue,
	// either good or bad.
	//
	// Note that when we want to compare the "distance" between two
	// quality ratings, we'll use the inverse of the value, not the value
	// itself. That should match our perception of quality a bit
	// more (kind of like our hearing).
	// 
	// For example, the perceived difference in quality between 0.01 
	// and 0.02 is about 2 - twice as many errors occur on 0.02 than
	// 0.01 so the "distance" between 0.01 and 0.02 should be calculated
	// like 0.02/0.01 = 2. And the distance between 0.02 and 0.04 should
	// be calculated like 0.04/0.02 = 2. So the 'point' 0.04 is the same
	// 'distance' from 0.02 as the 'point' 0.01.
	//
	// Note the wording is weird - bad (low) quality has a higher numerical 
	// value, oh well
	//
	// The threshold value is the distance the quality value must wander
	// from the optimum in order to warrant considering a change of
	// high water mark. For example, a value of 2 would mean that 
	// for an optimum value of 0.02, the value would have to wander to
	// 0.01 or 0.04 before we'd consider a change. This is currently set
	// very low so the algorithm will quickly hunt out the best watermarks.
	double m_dOptimumQuality;
	double m_dQualityThreshold;
	double m_dFrameStrength;

	// the number of milliseconds in a frame. This is used to normalize
	// the frame strength to time, so a particular input aggressiveness
	// will provide the same results regardless of the current frame size.
	WORD m_wMSPerFrame;

	// We are interfacing to the outside world via 
	// two parameters, Quality and Aggressiveness.
	// these members are integers in the range
	// defined by the constants above, and are used
	// to set the double values above appropriately.
	// We need to provide the hop count for reasons 
	// discussed in the SetQuality() function.
	int m_iQuality;
	int m_iHops;
	int m_iAggr;

	// the current high water mark
	BYTE m_bCurHighWaterMark;

	// the cap on the high water mark
	BYTE m_bMaxHighWaterMark;

	// the initial high water mark on a new or reset queue
	BYTE m_bInitHighWaterMark;

	// Some statistics to track.
	DWORD m_dwTotalFrames;
	DWORD m_dwTotalMessages;
	DWORD m_dwTotalBadMessages;
	DWORD m_dwDiscardedFrames;
	DWORD m_dwDuplicateFrames;
	DWORD m_dwLostFrames;
	DWORD m_dwLateFrames;
	DWORD m_dwOverflowFrames;
	DWORD m_dwQueueErrors;

	// An abritrary queue ID, provided to the constructor, 
	// used to identify which queue an instrumentation message
	// is coming from. It serves no other purpose, and can be
	// ignored except for debug purposes.
	WORD m_wQueueId;

	// the frame pool to manage the frames so we don't have to
	// allocate a huge number of them when only a few are 
	// actually in use.
	CFramePool* m_pFramePool;

	// the inner queue pool to manage innner queues. Same idea
	// as the frame pool
	CInnerQueuePool* m_pInnerQueuePool;

public:

	// The constructor. 
	CInputQueue2();
    
    HRESULT Initialize( PQUEUE_PARAMS pQueueParams );
    void DeInitialize();

    void GetStatistics( PQUEUE_STATISTICS pStats );

	// The destructor. Release all the resources we acquired in the
	// constructor
	~CInputQueue2();

	// This function clears all buffers and resets the other class 
	// information to an initial state. DO NOT CALL THIS FUNCTION
	// IF THE QUEUE IS IN USE! i.e. do not call it if you have
	// not called Return() on every frame that you have
	// taken from this queue.
	void Reset();

	// Call this function to add a frame to the queue.  I 
	// considered returning a reference to a frame which 
	// the caller could then stuff, but because the frames
	// will not always arrive in order, that would mean I would have
	// to copy the frame sometimes anyway.  So, for simplicity, the
	// caller has allocated a frame, which it passes a reference
	// to, and this function will copy that frame into the
	// appropriate place in the queue, according to its
	// message number and sequence number.
	void Enqueue(const CFrame& fr);

	// This function retrieves the next frame from the head of
	// the queue. For speed, it does not copy the data out of the
	// buffer, but instead returns a pointer to the actual
	// frame from the queue. Of course, there is the danger
	// that the CInputQueue2 object which returns a reference to the
	// frame may try to reuse that frame before the caller is 
	// finished with it. The CFrame's lock and unlock member functions
	// are used to ensure this does not happen.  When the caller
	// is finished with the CFrame object, it should call vUnlock()
	// on it. If the caller doesn't unlock the frame, bad things
	// will happen when the input queue tries lock it again when 
	// it wants to reuse that frame. In any case, the caller
	// should always unlock the returned frame before it attempts
	// to dequeue another frame.
	CFrame* Dequeue();

	// get and set the quality parameters
	int GetQuality() { return m_iQuality; }
	void SetQuality(int iQuality, int iHops = 1);
	int GetAggr() { return m_iAggr; }
	void SetAggr(int iAggr);

	// get and set the default high watermark
	BYTE GetInitHighWaterMark() { return m_bInitHighWaterMark; }
	void SetInitHighWaterMark(BYTE bInitHighWaterMark) { m_bInitHighWaterMark = bInitHighWaterMark; }

	// get stats
	DWORD GetDiscardedFrames() { return m_dwDiscardedFrames; }
	DWORD GetDuplicateFrames() { return m_dwDuplicateFrames; }
	DWORD GetLateFrames() { return m_dwLateFrames; }
	DWORD GetLostFrames() { return m_dwLostFrames; }
	DWORD GetOverflowFrames() { return m_dwOverflowFrames; }
	DWORD GetQueueErrors() { return m_dwQueueErrors; }
	DWORD GetTotalBadMessages() { return m_dwTotalBadMessages; }
	DWORD GetTotalFrames() { return m_dwTotalFrames; }
	DWORD GetTotalMessages() { return m_dwTotalMessages; }
	BYTE GetHighWaterMark() { return m_bCurHighWaterMark; }

private:
	// a function to collect the stats from an input queue after a 
	// message is complete, and perform the queue adaptation
	void HarvestStats(CInnerQueue* piq);

	// a function which looks at a finished inner queue and decides
	// if the message was 'good' or 'bad'.
	double AdjustQuality(CInnerQueue* piq, double dCurQuality);

	// set a new high water mark
	void SetNewHighWaterMark(BYTE bNewHighWaterMark);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\innerque.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		innerque.h
 *  Content:	declaration of the CInnerQueue class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 07/27/99		pnewson Overhauled to support new message numbering method
 * 08/03/99		pnewson General clean up
 * 08/24/99		rodtoll	Fixed for release builds -- removed m_wQueueId from debug block
 * 10/28/99		pnewson Bug #113933 debug spew too verbose
 *						implement inner queue pool code
 *
 ***************************************************************************/

#ifndef _INNERQUEUE_H_
#define _INNERQUEUE_H_

// The inner queue class is used to queue up a single voice message.
// A 'message' in this context means a series of frames that have the
// same message number and are part of the same stream of speech.

// an enum to specify the allowed states of the frame slots
// I appear to have to declare this out here, instead of inside
// the class, otherwise the vector declaration gets confused.
enum ESlotState
{
	essEmpty = 1,
	essFull,
};

volatile class CInnerQueue
{
public:
	// The constructor. bNumSlots must be at least 8, and must be
	// a power of 2.
	CInnerQueue(BYTE bNumSlots, 
		WORD wFrameSize, 
		CFramePool* pfpFramePool,
		DNCRITICAL_SECTION* pcsQueue,
		BYTE bMsgNum,
		BYTE bHighWaterMark = 0,
		WORD wQueueId = 0);
		
	HRESULT Init();

	// The destructor
	~CInnerQueue();
	
	// An enum used to describe the possible queue states.
	enum EState
	{
		empty = 1,	// The queue is currently empty, awaiting the first frame
					// Enqueue allowed, Dequeue not allowed.
		filling,	// The queue is currently filling to the high water mark
					// Enqueue allowed. Dequeue not allowed.
		ready,		// The queue has filled to the high water mark
					// Enqueue allowed, Dequeue allowed
		finished	// The queue has emptied. No new frames accepted
					// Enqueue not allowed, Dequeue not allowed.
	};

	// Get the current state of the queue.
	EState GetState() { return m_eState; }

	// Set the current state of the queue.
	void SetState(EState eState) { m_eState = eState; }

	// Get the current size of the queue
	BYTE GetSize() { return m_bQueueSize; }

	// Get the current high water mark
	BYTE GetHighWaterMark() { return m_bHighWaterMark; }

	// Set the current high water mark
	void SetHighWaterMark(BYTE bHighWaterMark);

	// Get, set, and increment the filling dequeue count
	BYTE GetFillingDequeueReqs() { return m_bFillingDequeueReqs; }
	void SetFillingDequeueReqs(BYTE bFillingDequeueReqs) { m_bFillingDequeueReqs = bFillingDequeueReqs; }
	void IncFillingDequeueReqs() { m_bFillingDequeueReqs++; }

	// Get the stats for the current message
	WORD GetMissingFrames() { return m_wMissingFrames; }
	WORD GetDuplicateFrames() { return m_wDuplicateFrames; }
	WORD GetOverflowFrames() { return m_wOverflowFrames; }
	WORD GetLateFrames() { return m_wLateFrames; }
	DWORD GetMsgLen() { return m_dwMsgLen; }

	// More stats stuff
	void AddToKnownZeroLengthDequeues(WORD w) { m_wKnownZeroLengthDequeues += w; }
	WORD GetKnownZeroLengthDequeues() { return m_wKnownZeroLengthDequeues; }
	void IncPossibleZeroLengthDequeues() { m_wPossibleZeroLengthDequeues++; } 
	void SetPossibleZeroLengthDequeues(WORD w) { m_wPossibleZeroLengthDequeues = w; }
	WORD GetPossibleZeroLengthDequeues() { return m_wPossibleZeroLengthDequeues; }
	
	// Add a frame to the Queue
	void Enqueue(const CFrame& frFrame);

	// Get a frame from the Queue
	CFrame* Dequeue();

	// reset the queue to its initial empty state
	void Reset();

	// reset all the class' stats
	void ResetStats();

	// get the message number this queue holds
	BYTE GetMsgNum() { return m_bMsgNum; }
	void SetMsgNum(BYTE bMsgNum) { m_bMsgNum = bMsgNum; }
	void SetQueueId(WORD wQueueId) { m_wQueueId = wQueueId; }

private:
	// Has the init function completed successfully?
	BOOL m_fInited;

	// The current state of the inner queue.
	EState m_eState;

	// The number of frame slots in the queue. must be a power
	// of two, or else things will get bad if the sequence number
	// rolls over.
	BYTE m_bNumSlots;

	// The number of frames required before the queue moves from
	// 'filling' to 'ready' state.
	BYTE m_bHighWaterMark;

	// The current 'size' of the queue. The size of the queue is
	// considered to be the number of filled slots, which may not
	// be the same as the distance between the first filled slot
	// and the last filled slot.
	BYTE m_bQueueSize;

	// The sequence number of the frame at the head of the queue.
	BYTE m_bHeadSeqNum;

	// A flag to track the first dequeue action.
	bool m_fFirstDequeue;

	// an array of slot states
	//ESlotState* m_rgeSlotStates;

	// An array of pointers to frames. This has to be pointers
	// to frames, because CFrame has no default constructor.
	CFrame** m_rgpfrSlots;

	// This is a little stat that will help us to detect
	// when a short message is getting hung up in a queue
	// because it's not long enough to trigger the high
	// water mark. It counts the number of times an outer dequeue
	// operation has been declined because this inner queue
	// is in the filling state. This gets reset to 0 when the
	// high water mark is hit
	BYTE m_bFillingDequeueReqs;

	// These vars keep stats on the current message, presumably so
	// we can intelligently adjust the high water mark

	// A frame is considered missing if it has not arrived by the time
	// it is required, but some frames following it have arrived.
	WORD m_wMissingFrames;

	// This one is pretty obvious. If we get the same frame twice, it's a duplicate
	// aarono will bet his car that this can never happen, so if you every see this
	// variable above one, call him up and make that bet!
	WORD m_wDuplicateFrames;

	// Overflow and late frames. If you look at where these are incremented
	// you'll see that it is pretty much a judgement call if we're throwing
	// away a frame due to an overflow or it being late, so take them with
	// a grain of salt. The sum of the two stats is however an accurate count
	// of how many frames arrived that we chucked.
	WORD m_wOverflowFrames;
	WORD m_wLateFrames;

	// These are used by the outer queue to remember if it
	// needed a frame from this queue when it's size was zero.
	WORD m_wPossibleZeroLengthDequeues;
	WORD m_wKnownZeroLengthDequeues;

	// This is the number of frames that make up the current message
	DWORD m_dwMsgLen; // make a dword in case of no voice detection

	// The Queue ID is just used for debug messages
	WORD m_wQueueId;

	// The message number this queue is for
	BYTE m_bMsgNum;

	// frame pool stuff
	CFramePool* m_pfpFramePool;
	DNCRITICAL_SECTION* m_pcsQueue;
};

// Inner queues are requested as needed by the CInputQueue2 class.
// This class manages a pool of inner queues so that actual memory
// allocations are few and far between.
class CInnerQueuePool
{
private:
	BYTE m_bNumSlots;
	WORD m_wFrameSize;
	CFramePool* m_pfpFramePool;
	DNCRITICAL_SECTION* m_pcsQueue;
	std::vector<CInnerQueue *> m_vpiqPool;
    DNCRITICAL_SECTION m_lock; // to exclude Get and Return from each other
	BOOL m_fCritSecInited;

public:
	CInnerQueuePool(
		BYTE bNumSlots,
		WORD wFrameSize,
		CFramePool* pfpFramePool,
		DNCRITICAL_SECTION* pcsQueue);

	~CInnerQueuePool();

	BOOL Init() 
	{
		if (DNInitializeCriticalSection(&m_lock) )
		{
			m_fCritSecInited = TRUE;
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

	CInnerQueue* Get(
		BYTE bHighWaterMark = 0,
		WORD wQueueId = 0,
		BYTE bMsgNum = 0);

	void Return(CInnerQueue* piq);
};

#endif // _INNERQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\mixline.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		MixLine.cpp
 *  Content:	Class for managing the mixerLine API.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/30/99		rodtoll	Created based on source from dsound
 * 01/24/2000	rodtoll	Mirroring changes from dsound bug #128264
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define DVF_MIXERLINE_PROCEDURE_DEBUG_LEVEL			DVF_INFOLEVEL

#define DPFLVL_INFO	5
#define DPF_MIXER		DPFX

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::CMixerLine"
CMixerLine::CMixerLine(
	): 	m_fAcquiredVolCtrl(FALSE), 
		m_pmxMuxFlags(NULL), 
		m_dwRangeMin(0), 
		m_dwRangeSize(0xFFFF),
		m_uWaveDeviceId(0),
		m_pfMicValue(NULL)
{
	ZeroMemory( &m_mxcdMasterVol, sizeof( MIXERCONTROLDETAILS ) );
	ZeroMemory( &m_mxcdMasterMute, sizeof( MIXERCONTROLDETAILS ) );
	ZeroMemory( &m_mxcdMasterMux, sizeof( MIXERCONTROLDETAILS ) );
	ZeroMemory( &m_mxcdMicVol, sizeof( MIXERCONTROLDETAILS ) );
	ZeroMemory( &m_mxcdMicMute, sizeof( MIXERCONTROLDETAILS ) );
	ZeroMemory( &m_mxVolume, sizeof( MIXERCONTROLDETAILS_UNSIGNED ) );
	ZeroMemory( &m_mxMute, sizeof( MIXERCONTROLDETAILS_BOOLEAN ) );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::~CMixerLine"
CMixerLine::~CMixerLine()
{
	if( m_pmxMuxFlags != NULL )
	{
		delete [] m_pmxMuxFlags;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::Initialize"
HRESULT CMixerLine::Initialize( UINT uiDeviceID )
{
	if( m_fAcquiredVolCtrl )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize has not been called" );
		return DVERR_INITIALIZED;
	}
		
	m_uWaveDeviceId = uiDeviceID;
	
    // Set up the master waveIn destination mixer line
    MIXERLINE mxMastLine;
    ZeroMemory(&mxMastLine, sizeof mxMastLine);
    mxMastLine.cbStruct = sizeof mxMastLine;
    mxMastLine.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;

    // Set up the microphone source line
    MIXERLINE mxMicLine;
    ZeroMemory(&mxMicLine, sizeof mxMicLine);

    // Set up the mixer-line control structure
    MIXERCONTROL mxCtrl;
    ZeroMemory(&mxCtrl, sizeof mxCtrl);
    mxCtrl.cbStruct = sizeof mxCtrl;

    // Set up the 1-element array of controls
    MIXERLINECONTROLS mxLineCtrls;
    ZeroMemory(&mxLineCtrls, sizeof mxLineCtrls);
    mxLineCtrls.cbStruct = sizeof mxLineCtrls;
    mxLineCtrls.cControls = 1;
    mxLineCtrls.cbmxctrl = sizeof mxCtrl;
    mxLineCtrls.pamxctrl = &mxCtrl;

    // Set up the control details structures
    m_mxcdMasterVol.cbDetails = sizeof m_mxVolume;
    m_mxcdMasterVol.paDetails = &m_mxVolume;
    m_mxcdMasterVol.cChannels = 1;
    m_mxcdMasterMute.cbDetails = sizeof m_mxMute;
    m_mxcdMasterMute.paDetails = &m_mxMute;
    m_mxcdMasterMute.cChannels = 1;
    m_mxcdMicVol.cbDetails = sizeof m_mxVolume;
    m_mxcdMicVol.paDetails = &m_mxVolume;
    m_mxcdMicVol.cChannels = 1;
    m_mxcdMicMute.cbDetails = sizeof m_mxMute;
    m_mxcdMicMute.paDetails = &m_mxMute;
    m_mxcdMicMute.cChannels = 1;

    // We use the waveIn device ID instead of a "real" mixer device below
    HMIXEROBJ   hMixObj;
    MMRESULT mmr = mixerGetID((HMIXEROBJ) ((UINT_PTR)m_uWaveDeviceId), (LPUINT)&hMixObj, MIXER_OBJECTF_WAVEIN);

    if (MMSYSERR_NOERROR == mmr)
    {
        DPF_MIXER(DPFPREP, DPFLVL_INFO, "mixerGetID failed.");
    }

    // Find the master recording destination line
    mmr = mixerGetLineInfo(hMixObj, &mxMastLine, MIXER_GETLINEINFOF_COMPONENTTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found the master recording mixer line");
        // Look for a volume fader control on the master line
        mxLineCtrls.dwLineID = mxMastLine.dwLineID;
        mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
        mmr = mixerGetLineControls(hMixObj, &mxLineCtrls, MIXER_GETLINECONTROLSF_ONEBYTYPE);
        if (mmr == MMSYSERR_NOERROR)
        {
            // Found it - use the cbStruct field to flag success
            DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found a volume fader on the master line");
            m_mxcdMasterVol.cbStruct = sizeof m_mxcdMasterVol;
            m_mxcdMasterVol.dwControlID = mxCtrl.dwControlID;
            m_dwRangeMin = mxCtrl.Bounds.dwMinimum;
            m_dwRangeSize = mxCtrl.Bounds.dwMaximum - mxCtrl.Bounds.dwMinimum;
            mmr = mixerGetControlDetails(hMixObj, &m_mxcdMasterVol, MIXER_GETCONTROLDETAILSF_VALUE);
        }
        if (mmr != MMSYSERR_NOERROR)
            m_mxcdMasterVol.cbStruct = 0;

        // Look for a mute control on the master line
        mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_MUTE;
        mmr = mixerGetLineControls(hMixObj, &mxLineCtrls, MIXER_GETLINECONTROLSF_ONEBYTYPE);
        if (mmr == MMSYSERR_NOERROR)
        {
            DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found a mute control on the master line");
            m_mxcdMasterMute.cbStruct = sizeof m_mxcdMasterMute;
            m_mxcdMasterMute.dwControlID = mxCtrl.dwControlID;
            mmr = mixerGetControlDetails(hMixObj, &m_mxcdMasterMute, MIXER_GETCONTROLDETAILSF_VALUE);
        }
        if (mmr != MMSYSERR_NOERROR)
            m_mxcdMasterMute.cbStruct = 0;

        // Look for the microphone source line
        mxMicLine.cbStruct = sizeof mxMicLine;
        mxMicLine.dwDestination = mxMastLine.dwDestination;
        for (UINT i=0; i < mxMastLine.cConnections; ++i)
        {
            mxMicLine.dwSource = i;
            // Note: for some mysterious reason, I had to remove MIXER_OBJECTF_WAVEIN
            // from this call to mixerGetLineInfo() to make it work.
            mmr = mixerGetLineInfo(hMixObj, &mxMicLine, MIXER_GETLINEINFOF_SOURCE);
            if (mmr != MMSYSERR_NOERROR || mxMicLine.dwComponentType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE)
                break;
        }
        if (mxMicLine.dwComponentType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE)
        {
            DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found a microphone mixer line");
            // Look for a volume fader control on the mic line
            mxLineCtrls.dwLineID = mxMicLine.dwLineID;
            mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
            mmr = mixerGetLineControls(hMixObj, &mxLineCtrls, MIXER_GETLINECONTROLSF_ONEBYTYPE);
            if (mmr == MMSYSERR_NOERROR)
            {
                DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found a volume fader on the mic line");
                m_mxcdMicVol.cbStruct = sizeof m_mxcdMicVol;
                m_mxcdMicVol.dwControlID = mxCtrl.dwControlID;
                m_dwRangeMin = mxCtrl.Bounds.dwMinimum;
                m_dwRangeSize = mxCtrl.Bounds.dwMaximum - mxCtrl.Bounds.dwMinimum;
                mmr = mixerGetControlDetails(hMixObj, &m_mxcdMicVol, MIXER_GETCONTROLDETAILSF_VALUE);
            }
            if (mmr != MMSYSERR_NOERROR)
                m_mxcdMicVol.cbStruct = 0;

            // Look for a mute control on the mic line
            mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_MUTE;
            mmr = mixerGetLineControls(hMixObj, &mxLineCtrls, MIXER_GETLINECONTROLSF_ONEBYTYPE);
            if (mmr == MMSYSERR_NOERROR)
            {
                DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found a mute control on the mic line");
                m_mxcdMicMute.cbStruct = sizeof m_mxcdMicMute;
                m_mxcdMicMute.dwControlID = mxCtrl.dwControlID;
                mmr = mixerGetControlDetails(hMixObj, &m_mxcdMicMute, MIXER_GETCONTROLDETAILSF_VALUE);
            }
            if (mmr != MMSYSERR_NOERROR)
                m_mxcdMicMute.cbStruct = 0;

            // Look for a MUX or MIXER control on the master line
            mxLineCtrls.dwLineID = mxMastLine.dwLineID;
            mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_MUX;
            m_fMasterMuxIsMux = TRUE;
            mmr = mixerGetLineControls(hMixObj, &mxLineCtrls, MIXER_GETLINECONTROLSF_ONEBYTYPE);
            if (mmr != MMSYSERR_NOERROR)
            {
                mxLineCtrls.dwControlType = MIXERCONTROL_CONTROLTYPE_MIXER;
                m_fMasterMuxIsMux = FALSE;
                mmr = mixerGetLineControls(hMixObj, &mxLineCtrls, MIXER_GETLINECONTROLSF_ONEBYTYPE);
            }
            if (mmr == MMSYSERR_NOERROR)
            {
                DPF_MIXER(DPFPREP, DPFLVL_INFO, "Found an item list control on the master line");
                m_mxcdMasterMux.cbStruct = sizeof m_mxcdMasterMux;
                m_mxcdMasterMux.dwControlID = mxCtrl.dwControlID;
                m_mxcdMasterMux.cMultipleItems = mxCtrl.cMultipleItems;
                
                // We save the cChannels value, because some evil VxD drivers (read: Aureal
                // Vortex) will set it to 0 in the call to mixerGetControlDetails() below
                int nChannels = (mxCtrl.fdwControl & MIXERCONTROL_CONTROLF_UNIFORM) ? 1 : mxMastLine.cChannels;
                m_mxcdMasterMux.cChannels = nChannels;

                // Get the MUX or MIXER list items
                m_mxcdMasterMux.cbDetails = sizeof(MIXERCONTROLDETAILS_LISTTEXT);
                MIXERCONTROLDETAILS_LISTTEXT *pList = new MIXERCONTROLDETAILS_LISTTEXT [ m_mxcdMasterMux.cbDetails * m_mxcdMasterMux.cChannels * mxCtrl.cMultipleItems ];
                if (pList != NULL)
                {
                    m_mxcdMasterMux.paDetails = pList;
                    mmr = mixerGetControlDetails(hMixObj, &m_mxcdMasterMux, MIXER_GETCONTROLDETAILSF_LISTTEXT);
                    if (mmr == MMSYSERR_NOERROR)
                    {
                        DPF_MIXER(DPFPREP, DPFLVL_INFO, "Got the list controls's LISTTEXT details");
                        // Get the MUX or MIXER list values
                        m_mxcdMasterMux.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
                        m_mxcdMasterMux.cChannels = nChannels;
                        m_pmxMuxFlags = new MIXERCONTROLDETAILS_BOOLEAN [ m_mxcdMasterMux.cbDetails * m_mxcdMasterMux.cChannels * mxCtrl.cMultipleItems ];
                        if (m_pmxMuxFlags != NULL)
                        {
                            m_mxcdMasterMux.paDetails = m_pmxMuxFlags;
                            mmr = mixerGetControlDetails(hMixObj, &m_mxcdMasterMux, MIXER_GETCONTROLDETAILSF_VALUE);
                            if (mmr == MMSYSERR_NOERROR)  // Enable the item corresponding to the mic line
                            {
                                DPF_MIXER(DPFPREP, DPFLVL_INFO, "Got the list controls's VALUE details");
                                for (UINT i=0; i < mxCtrl.cMultipleItems; ++i)
                                {
                                    if (pList[i].dwParam1 == mxMicLine.dwLineID)
                                        m_pfMicValue = &m_pmxMuxFlags[i].fValue;
                                    else if (mxLineCtrls.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX)
                                        m_pmxMuxFlags[i].fValue = FALSE;
                                    DPF_MIXER(DPFPREP, DPFLVL_INFO, "Set list item %d to %d", i, pList[i].dwParam1 == mxMicLine.dwLineID);
                                }
                            }
                        }
                    }
                    delete[] pList;
					pList = NULL;
                }
                if (!m_pmxMuxFlags || !m_pfMicValue || mmr != MMSYSERR_NOERROR)
                    m_mxcdMasterMux.cbStruct = 0;
            }
        }
    }
  
    // To be able to control the recording level, we minimally require
    // a volume fader on the master line or one on the microphone line:
    m_fAcquiredVolCtrl = m_mxcdMasterVol.cbStruct || m_mxcdMicVol.cbStruct;
    
    HRESULT hr = m_fAcquiredVolCtrl ? DS_OK : DSERR_CONTROLUNAVAIL;

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::SetMicrophoneVolume"
HRESULT CMixerLine::SetMicrophoneVolume( LONG lMicrophoneVolume )
{
	if( !m_fAcquiredVolCtrl )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize has not been called" );
		return DVERR_NOTINITIALIZED;
	}

    MMRESULT mmr = MMSYSERR_NOTSUPPORTED;  // Default return code

    // Set the microphone recording level control if available
    if (m_mxcdMicVol.cbStruct)
    {
        // Convert the DSBVOLUME level to an amplification factor from 0 to 0xFFFF
        m_mxVolume.dwValue = DBToAmpFactor(lMicrophoneVolume);

        // Adjust range if necessary
        if (m_dwRangeMin != 0 || m_dwRangeSize != 0xFFFF)
            m_mxVolume.dwValue = DWORD(m_dwRangeMin + m_dwRangeSize*double(m_mxVolume.dwValue)/0xFFFF);

        mmr = mixerSetControlDetails((HMIXEROBJ)((UINT_PTR)m_uWaveDeviceId),
                                     &m_mxcdMicVol, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);
    }                             

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::GetMicrophoneVolume"
HRESULT CMixerLine::GetMicrophoneVolume( LPLONG plMicrophoneVolume )
{
	if( !m_fAcquiredVolCtrl )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize has not been called" );
		return DVERR_NOTINITIALIZED;
	}

    MMRESULT mmr = MMSYSERR_NOTSUPPORTED;  // Default return code

    DNASSERT(plMicrophoneVolume != NULL);

    // Get the microphone recording level if available
    if (m_mxcdMicVol.cbStruct != 0)
    {
        mmr = mixerGetControlDetails( (HMIXEROBJ)((UINT_PTR)m_uWaveDeviceId),
                                     &m_mxcdMicVol, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);
        if (mmr == MMSYSERR_NOERROR)
        {
            DNASSERT(m_mxVolume.dwValue >= m_dwRangeMin && m_mxVolume.dwValue <= m_dwRangeMin + m_dwRangeSize);

            // Adjust range if necessary
            if (m_dwRangeMin != 0 || m_dwRangeSize != 0xFFFF)
                m_mxVolume.dwValue = DWORD(double(m_mxVolume.dwValue-m_dwRangeMin) / m_dwRangeSize * 0xFFFF);

            // Convert the amplification factor to a DSBVOLUME level
            *plMicrophoneVolume = AmpFactorToDB(m_mxVolume.dwValue);
        }
    }

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::SetMasterRecordVolume"
HRESULT CMixerLine::SetMasterRecordVolume( LONG lRecordVolume )
{
	if( !m_fAcquiredVolCtrl )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize has not been called" );
		return DVERR_NOTINITIALIZED;
	}
	
    MMRESULT mmr = MMSYSERR_NOTSUPPORTED;  // Default return code

    // Set the master recording level control if available
    if (m_mxcdMasterVol.cbStruct)
    {
        // Convert the DSBVOLUME level to an amplification factor from 0 to 0xFFFF
        m_mxVolume.dwValue = DBToAmpFactor(lRecordVolume);

        // Adjust range if necessary
        if (m_dwRangeMin != 0 || m_dwRangeSize != 0xFFFF)
            m_mxVolume.dwValue = DWORD(m_dwRangeMin + m_dwRangeSize*double(m_mxVolume.dwValue)/0xFFFF);

        mmr = mixerSetControlDetails((HMIXEROBJ)((UINT_PTR)m_uWaveDeviceId),
                                     &m_mxcdMasterVol, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);
    }

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::GetMasterRecordVolume"
HRESULT CMixerLine::GetMasterRecordVolume( LPLONG plRecordVolume )
{
	if( !m_fAcquiredVolCtrl )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize has not been called" );
		return DVERR_NOTINITIALIZED;
	}

    DNASSERT(plRecordVolume != NULL);

    MMRESULT mmr = MMSYSERR_NOTSUPPORTED;  // Default return code

    // Get the master recording level if available
    if (m_mxcdMasterVol.cbStruct != 0)
    {
        mmr = mixerGetControlDetails((HMIXEROBJ)((UINT_PTR)m_uWaveDeviceId),
                                     &m_mxcdMasterVol, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);
        if (mmr == MMSYSERR_NOERROR)
        {
            DNASSERT(m_mxVolume.dwValue >= m_dwRangeMin && m_mxVolume.dwValue <= m_dwRangeMin + m_dwRangeSize);

            // Adjust range if necessary
            if (m_dwRangeMin != 0 || m_dwRangeSize != 0xFFFF)
                m_mxVolume.dwValue = DWORD(double(m_mxVolume.dwValue-m_dwRangeMin) / m_dwRangeSize * 0xFFFF);

            // Convert the amplification factor to a DSBVOLUME level
            *plRecordVolume = AmpFactorToDB(m_mxVolume.dwValue);
        }
    }

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    return hr;	

}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::SelectMicrophone"
HRESULT CMixerLine::EnableMicrophone( BOOL fEnable )
{
	if( !m_fAcquiredVolCtrl )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize has not been called" );
		return DVERR_NOTINITIALIZED;
	}

    HMIXEROBJ hMixObj = (HMIXEROBJ)((UINT_PTR)m_uWaveDeviceId);
    MMRESULT mmr = MMSYSERR_NOERROR;
    HRESULT hr;

    // Check for presence of microphone controls
    if (!m_mxcdMasterMux.cbStruct && !m_mxcdMasterMute.cbStruct && !m_mxcdMicMute.cbStruct)
    {
        // We cannot do anything to enable the microphone line
        hr = DSERR_UNSUPPORTED;
    }
    else
    {
        // Select the mic on the Mux control, if available
        //
        if (m_mxcdMasterMux.cbStruct && !(m_fMasterMuxIsMux && !fEnable))
        {
            *m_pfMicValue = fEnable;
            mmr = mixerSetControlDetails(hMixObj, &m_mxcdMasterMux, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);
        }

        // Mute/unmute the lines, if mute controls are available
        m_mxMute.fValue = !fEnable;
        if (m_mxcdMasterMute.cbStruct && mmr == MMSYSERR_NOERROR)
            mmr = mixerSetControlDetails(hMixObj, &m_mxcdMasterMute, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);
        if (m_mxcdMicMute.cbStruct && mmr == MMSYSERR_NOERROR)
            mmr = mixerSetControlDetails(hMixObj, &m_mxcdMicMute, MIXER_OBJECTF_WAVEIN | MIXER_GETCONTROLDETAILSF_VALUE);

        hr = MMRESULTtoHRESULT(mmr);
    }

    return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CMixerLine::MMRESULTtoHRESULT"
HRESULT CMixerLine::MMRESULTtoHRESULT( MMRESULT mmr )
{
    HRESULT                 hr;
    
    switch(mmr)
    {
        case MMSYSERR_NOERROR:
            hr = DS_OK;
            break;

        case MMSYSERR_BADDEVICEID:
        case MMSYSERR_NODRIVER:
            hr = DSERR_NODRIVER;
            break;
        
        case MMSYSERR_ALLOCATED:
            hr = DSERR_ALLOCATED;
            break;

        case MMSYSERR_NOMEM:
            hr = DSERR_OUTOFMEMORY;
            break;

        case MMSYSERR_NOTSUPPORTED:
            hr = DSERR_UNSUPPORTED;
            break;
        
        case WAVERR_BADFORMAT:
            hr = DSERR_BADFORMAT;
            break;

        default:
            hr = DSERR_GENERIC;
            break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\frame.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		frame.h
 *  Content:	declaration of the CFrame and CFramePool classes
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 07/22/99		rodtoll	Updated target to be DWORD
 * 08/03/99		pnewson General clean up, updated target to DVID
 * 01/14/2000	rodtoll	Updated to support multiple targets.  Frame will 
 *						automatically allocate memory as needed for targets.
 *				rodtoll	Added SetEqual function to making copying of frame
 *						in Queue easier. 
 *				rodtoll	Added support for "user controlled memory" frames.
 *						When the default constructor is used with the UserOwn_XXXX
 *						functions the frames use user specified buffers.  
 *						(Removes a buffer copy when queueing data).
 *  01/31/2000	pnewson replace SAssert with DNASSERT
 * 03/29/2000	rodtoll Bug #30753 - Added volatile to the class definition
 *  07/09/2000	rodtoll	Added signature bytes 
 *
 ***************************************************************************/

#ifndef _FRAME_H_
#define _FRAME_H_

// forward declaration
class CFramePool;

#define VSIG_FRAME		'MRFV'
#define VSIG_FRAME_FREE	'MRF_'

// This class is designed to manage one frame of sound data.
//
// tag: fr
volatile class CFrame
{
private:

	DWORD				m_dwSignature;
	// The critical section object which is used to protect the 
	// return method. This is passed in by CInputQueue2 and/or CInnerQueue
	// class, so that the return method is serialized with calls to 
	// Reset, Enqueue and Dequeue. If no critical section is passed,
	// the Return member should not be used, and this frame should
	// not be part of a managed pool.
	DNCRITICAL_SECTION	*m_pCriticalSection;

    // Length of the data within the frame.  There may be less then a whole
    // frame worth of data in the buffer due to compression/decompression may
    // result in a slightly different size buffer.
    WORD m_wFrameLength;

	// The size of this frame.  It would be easier to make
	// this a class constant, but we're probably going to want to 
	// toy with the frame sizes while we're optimizing, and
	// we may even get really fancy in the future and have
	// the client and server negotiate the frame size at connection
	// time, all of which will be easier if we bite the bullet now
	// and make this a member variable.  Note this is constant,
	// so once a frame is instantiated, it's size is permanently set.
	WORD m_wFrameSize;

	// The client number this frame is coming from or
	// going to.
	WORD m_wClientId;

	// The frame sequence number.
	BYTE m_wSeqNum;

	// The message number the frame is part of
    BYTE m_bMsgNum;

    // The target of the frame
    PDVID m_pdvidTargets;
    DWORD m_dwNumTargets;
    DWORD m_dwMaxTargets;

    bool m_fOwned;

	// A flag to specify that this frame contains nothing but silence.
	// When this flag is set, the data in the frame buffer should not 
	// be used - it's probably not valid.
	BYTE m_bIsSilence;

	// A pointer to the frame's data
	BYTE* m_pbData;

	// If this frame is part of a managed frame pool, this
	// member will be non-null.
	CFramePool* m_pFramePool;

	// If this frame is part of a managed frame pool, this
	// points to the "primary" pointer to this frame.
	// When the frame is unlocked, and therefore returned
	// to the pool, the pointer this member points to will 
	// be set to null. This action is protected by the
	// critical section passed to the class.
	CFrame** m_ppfrPrimary;

	// A flag to indicate if this frame was "lost". This is
	// used to distinguish the silent frames pulled from the
	// queue between messages from the dead space caused by 
	// a known lost packet.
	bool m_fIsLost;


	// don't allow copy construction or assignment of these
	// structures, as this would kill our performance, and
	// we don't want to do it by accident
	CFrame(const CFrame& fr);
	CFrame& operator=(const CFrame& fr);

public:

	// This constructor sets all the frame's info, and allocates
	// the data buffer, but does not set the data inside the buffer
	// to anything.  Defaults are provided for all the parameters
	// except for the frame size.  Note: no default constructor,
	// since you must specify the frame size.
	CFrame(WORD wFrameSize, 
		WORD wClientNum = 0,
		BYTE wSeqNum = 0,
        BYTE bMsgNum = 0,
		BYTE bIsSilence = 0,
		CFramePool *pFramePool = NULL,
		DNCRITICAL_SECTION* pCriticalSection = NULL,
		CFrame** ppfrPrimary = NULL);

	// A frame which manages user ownded memory
	CFrame();

	// The destructor cleans up the memory allocated by the
	// constructor
	~CFrame();

	inline DWORD GetNumTargets() const { return m_dwNumTargets; };
	inline const PDVID const GetTargetList() const { return m_pdvidTargets; };

    // Length of the data within the buffer
    WORD GetFrameLength() const { return m_wFrameLength; }

	// returns the frame size, (the length of the data buffer)
	WORD GetFrameSize() const { return m_wFrameSize; }

	HRESULT SetEqual( const CFrame &frSourceFrame );

	// These are just a bunch of set and get functions for 
	// the simple parts of the class, the client id, the
	// sequence number, the silence flag, etc.
    HRESULT GetTargets( PDVID pdvidTargets, PDWORD pdwNumTargets ) const;
    HRESULT SetTargets( PDVID pdvidTargets, DWORD dwNumTargets );
    
    BYTE GetMsgNum() const { return m_bMsgNum; }
    void SetMsgNum( BYTE msgNum ) { m_bMsgNum = msgNum; }
	void SetClientId(WORD wClientId) {	m_wClientId = wClientId; }
	WORD GetClientId() const {	return m_wClientId;	}
	void SetSeqNum(BYTE wSeqNum) {	m_wSeqNum = wSeqNum; }
	BYTE GetSeqNum() const { return m_wSeqNum; }
	void SetIsSilence(BYTE bIsSilence) { m_bIsSilence = bIsSilence; }
    void SetFrameLength(const WORD &length) { m_wFrameLength = length; }
	BYTE GetIsSilence() const { return m_bIsSilence; }
	bool GetIsLost() const { return m_fIsLost;	}
	void SetIsLost(bool fIsLost) {	m_fIsLost = fIsLost; }
	
	// Now we have the functions which handle the data.  This
	// class is pretty trusting, because it will give out the
	// pointer to it's data.  This is to avoid all non-required
	// buffer copies.  For example, when you hand a buffer to
	// a wave in function, you can give it the pointer to this
	// buffer, and it will fill in the frame's buffer directly.
	// Between this function and the GetFrameSize() and 
	// GetFrameLength() functions, you can do anything you want 
	// with the buffer.
	BYTE* GetDataPointer() const { return m_pbData; }

	// This copies the data from another frame into this frame
	void CopyData(const CFrame& fr)
	{
		memcpy(m_pbData, fr.GetDataPointer(), fr.GetFrameLength() );
        m_wFrameLength = fr.GetFrameLength();
	}

	void UserOwn_SetData( BYTE *pbData, DWORD dwLength )
	{
		m_pbData = pbData;
		m_wFrameLength = dwLength;
		m_wFrameSize = dwLength;
	}

	void UserOwn_SetTargets( PDVID pdvidTargets, DWORD dwNumTargets )
	{
		m_pdvidTargets = pdvidTargets;
		m_dwNumTargets = dwNumTargets;
		m_dwMaxTargets = dwNumTargets;
	}

	// This copies data from a buffer into this frame's
	// buffer.
	void CopyData(const BYTE* pbData, WORD wFrameLength);

	// If this frame is part of a frame pool managed by a
	// CFramePool object, then call this function when you 
	// are done with the frame and want to return it to the
	// pool.
    void Return();

	void SetCriticalSection(DNCRITICAL_SECTION* pCrit)	{ m_pCriticalSection = pCrit; }
	void SetPrimaryPointer(CFrame** ppfrPrimary) {	m_ppfrPrimary = ppfrPrimary; }
	void SetFramePool(CFramePool* pFramePool) { m_pFramePool = pFramePool;	}
};

// This class manages a pool of frames, to reduce memory requirements.
// Only a few buffers are actually in use at any time by the queue
// class, and yet it may have to allocate hundreds of them unless 
// a class such as this is used to manage their reuse.
volatile class CFramePool
{
private:
	// the pool is simply a vector of frame objects
	std::vector<CFrame *> m_vpfrPool;

	// All the frames in the pool must be the same size,
	// which is stored here.
	WORD m_wFrameSize;

	// This critical section is used to exclude the Get()
	// and return members from each other.
    DNCRITICAL_SECTION m_lock;

	BOOL m_fCritSecInited;

public:
	// Each frame pool manages frames of a certain size,
	// so they can be easily reused. If you need multiple
	// different frame sizes, you'll need more than one 
	// frame pool.
	CFramePool(WORD wFrameSize); 
	~CFramePool();

	BOOL Init() 
	{ 
		if (DNInitializeCriticalSection( &m_lock ))
		{
			m_fCritSecInited = TRUE;
			return TRUE;
		}
		else
		{
			return FALSE; 
		}
	}

	// Use Get to retrieve a frame from the pool. ppfrPrimary
	// is a pointer to a point that you want set to null when
	// this frame is returned to the pool. pCriticalSection 
	// points to a critical section that will be entered before
	// setting the pointer to null, and left after setting the 
	// pointer to null. This is so external classes (such as 
	// CInnerQueue) can pass in a critical section that they also
	// use to before examining the pointer referred to by ppfrPrimary
	CFrame* Get(DNCRITICAL_SECTION* pCriticalSection, CFrame** ppfrPrimary);

	// Call Return to give a frame back to the frame pool. 
	// This may set a pointer to null and enter a critical
	// section, as described in Get() above.
	void Return(CFrame* pFrame);
};


#endif /* _FRAME_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\frame.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wirecd.cpp
 *  Content:
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 08/03/99		pnewson General clean up, updated target to DVID
 * 01/14/2000	rodtoll	Updated to support multiple targets.  Frame will 
 *						automatically allocate memory as needed for targets.
 *				rodtoll	Added SetEqual function to making copying of frame
 *						in Queue easier. 
 *				rodtoll	Added support for "user controlled memory" frames.
 *						When the default constructor is used with the UserOwn_XXXX
 *						functions the frames use user specified buffers.  
 *						(Removes a buffer copy when queueing data). 
 *  01/31/2000	pnewson replace SAssert with DNASSERT
 *  02/17/2000	rodtoll	Updated so sequence/msg numbers are copied when you SetEqual
 *  07/09/2000	rodtoll	Added signature bytes 
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define MODULE_ID   FRAME

// SetEqual
//
// This function sets the current frame to match the data in frSourceFrame
//
#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::SetEqual"
HRESULT CFrame::SetEqual( const CFrame &frSourceFrame )
{
	HRESULT hr;
	
	SetClientId( frSourceFrame.GetClientId());
	SetSeqNum(frSourceFrame.GetSeqNum());
	SetMsgNum(frSourceFrame.GetMsgNum());
	CopyData(frSourceFrame);
	SetIsSilence(frSourceFrame.GetIsSilence());

	hr = SetTargets( frSourceFrame.GetTargetList(), frSourceFrame.GetNumTargets() );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error copying frame for queue" );
	}

	return hr;
}

// GetTargets
//
// This program gets the targets for this frame
#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::GetTargets"
HRESULT CFrame::GetTargets( PDVID pdvidTargets, PDWORD pdwNumTargets ) const
{
	DNASSERT( pdwNumTargets != NULL );
		
	if( pdwNumTargets != NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid param" );
		return DVERR_INVALIDPARAM;
	}

	if( *pdwNumTargets < m_dwNumTargets || pdvidTargets == NULL )
	{
		*pdwNumTargets = m_dwNumTargets;
		return DVERR_BUFFERTOOSMALL;
	}

	*pdwNumTargets = m_dwNumTargets;

	memcpy( pdvidTargets, m_pdvidTargets, sizeof(DVID)*m_dwNumTargets );

	return DV_OK;
}

// SetTargets
//
// This program sets the targets for this frame.  It will expand the 
// target list (if required) or use a subset of the current buffer.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::SetTargets"
HRESULT CFrame::SetTargets( PDVID pdvidTargets, DWORD dwNumTargets )
{
	DNASSERT( m_fOwned );
	
	if( dwNumTargets > m_dwMaxTargets )
	{
		if( m_pdvidTargets != NULL )
		{
			delete [] m_pdvidTargets;
		}

		m_pdvidTargets = new DVID[dwNumTargets];

		if( m_pdvidTargets == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory allocation failure" );
			return DVERR_OUTOFMEMORY;
		}
		
		m_dwMaxTargets = dwNumTargets;
	}

	m_dwNumTargets = dwNumTargets;

	memcpy( m_pdvidTargets, pdvidTargets, sizeof(DVID)*dwNumTargets );

	return DV_OK;
}

// This function is called to return a frame to the frame
// pool that is managing it. If a primary pointer was 
// provided, it will be set to NULL.
#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::Return"
void CFrame::Return()
{
	// the CInputQueue2 or CInnerQueue class is supposed to give us 
	// the critical section object. If it does not, these functions 
	// should not be called.
	DNASSERT(m_pCriticalSection != NULL);

	BFCSingleLock csl(m_pCriticalSection);
	csl.Lock();

	// this frame is supposed to be part of a frame pool if
	// this function is called
	DNASSERT(m_pFramePool != NULL);

	// return the frame to the pool, and set the primary
	// frame pointer to null to signal to the caller that
	// this frame is now gone. Note that this pointer update
	// is done within the critical section passed to this
	// class, and so the caller should also use this 
	// critical section to check the pointer value. This
	// is true for CInputQueue, which uses the critical
	// section for Reset, Enqueue and Dequeue.
	m_pFramePool->Return(this);

	if (m_ppfrPrimary != NULL)
	{
		*m_ppfrPrimary = NULL;
	}
}

// CFrame Constructor
//
// This is the primary constructor which is used for creating frames
// that are used by the frame pool.
//
// If you want to create a non-pooled frame then use the default constructor
//
#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::CFrame"
CFrame::CFrame(WORD wFrameSize, 
	WORD wClientNum,
	BYTE wSeqNum,
    BYTE bMsgNum,
	BYTE bIsSilence,
	CFramePool* pFramePool,
	DNCRITICAL_SECTION* pCriticalSection,
	CFrame** ppfrPrimary)
	: m_dwSignature(VSIG_FRAME),
	m_wFrameSize(wFrameSize),
	m_wClientId(wClientNum),
	m_wSeqNum(wSeqNum),
	m_bMsgNum(bMsgNum),
	m_bIsSilence(bIsSilence),
    m_wFrameLength(wFrameSize),
	m_pFramePool(pFramePool),
	m_pCriticalSection(pCriticalSection),
	m_ppfrPrimary(ppfrPrimary),
	m_fIsLost(false),
	m_pdvidTargets(NULL),
	m_dwNumTargets(0),
	m_dwMaxTargets(0),
	m_fOwned(true)
{
	m_pbData = new BYTE[m_wFrameSize];
}

// CFrame Constructor
//
// This is the constructor to use when creating a standalone frame.  This 
// type of frame can take an external buffer to eliminate a buffer copy.
//
// The frame doesn't "own" the buffer memory so it doesn't attempt to 
// free it.
//
// To set the data for the frame use the UserOwn_SetData member.
//
// Target information can be handled the same way by using UserOwn_SetTargets 
//
#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::CFrame"
CFrame::CFrame(
	): 	m_dwSignature(VSIG_FRAME),
		m_wFrameSize(0),
		m_wClientId(0),
		m_wSeqNum(0),
		m_bMsgNum(0),
		m_bIsSilence(true),
	    m_wFrameLength(0),
		m_pFramePool(NULL),
		m_pCriticalSection(NULL),
		m_ppfrPrimary(NULL),
		m_fIsLost(false),
		m_pdvidTargets(NULL),
		m_dwNumTargets(0),
		m_dwMaxTargets(0),
		m_fOwned(false)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::~CFrame"
CFrame::~CFrame() 
{	
	if( m_fOwned )
	{
		delete [] m_pbData; 

		if( m_pdvidTargets != NULL )
		{
			delete [] m_pdvidTargets;
		}
	}

	m_dwSignature = VSIG_FRAME_FREE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFrame::CopyData"
void CFrame::CopyData(const BYTE* pbData, WORD wFrameLength)
{
	DNASSERT(pbData != 0);
	memcpy(m_pbData, pbData, wFrameLength);
    m_wFrameLength = wFrameLength;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFramePool::CFramePool"
CFramePool::CFramePool(WORD wFrameSize)
	: m_wFrameSize(wFrameSize), m_fCritSecInited(FALSE)
{
	// Push a couple of frames into the pool to start with
	for (int i = 0; i < 2; ++i)
	{
		m_vpfrPool.push_back(new CFrame(m_wFrameSize));
	}

	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFramePool::~CFramePool"
CFramePool::~CFramePool()
{
	for (std::vector<CFrame *>::iterator iter1 = m_vpfrPool.begin(); iter1 < m_vpfrPool.end(); ++iter1)
	{
		delete *iter1;
	}

	if (m_fCritSecInited)
	{
		DNDeleteCriticalSection(&m_lock);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFramePool::Get"
CFrame* CFramePool::Get(DNCRITICAL_SECTION* pCriticalSection, CFrame** ppfrPrimary)
{
	BFCSingleLock csl(&m_lock);
	csl.Lock(); 

	CFrame* pfr;
	if (m_vpfrPool.empty())
	{
		// the pool is empty, return a new frame
		pfr = new CFrame(m_wFrameSize);

		if( pfr == NULL )
		{
			DPFX(DPFPREP,  0, "Error allocating memory" );
			return NULL;
		}
	}
	else
	{
		// there are some frames in the pool, pop
		// the last one off the back of the vector
		pfr = m_vpfrPool.back();
		m_vpfrPool.pop_back();
	}

	pfr->SetCriticalSection(pCriticalSection);
	pfr->SetPrimaryPointer(ppfrPrimary);
	pfr->SetFramePool(this);

	// clear up the rest of the flags, but don't bother messing
	// with the data.
	pfr->SetIsLost(false);
	pfr->SetMsgNum(0);
	pfr->SetSeqNum(0);
	pfr->SetIsSilence(FALSE);

	return pfr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFramePool::Return"
void CFramePool::Return(CFrame* pFrame)
{
	BFCSingleLock csl(&m_lock);
	csl.Lock(); 

	// drop this frame on the back for reuse
	m_vpfrPool.push_back(pFrame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\mixline.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		MixLine.h
 *  Content:	Class for managing the mixerLine API.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/30/99		rodtoll	Created based on source from dsound
 * 01/24/2000	rodtoll	Mirroring changes from dsound bug #128264
 *
 ***************************************************************************/
#ifndef __MIXLINE_H
#define __MIXLINE_H

class CMixerLine
{
public:
	CMixerLine();
	~CMixerLine();

	HRESULT Initialize( UINT uiDeviceID );

	HRESULT SetMicrophoneVolume( LONG lMicrophoneVolume );
	HRESULT GetMicrophoneVolume( LPLONG plMicrophoneVolume );

	HRESULT SetMasterRecordVolume( LONG lRecordVolume );
	HRESULT GetMasterRecordVolume( LPLONG plRecordVolume );

	HRESULT EnableMicrophone( BOOL fEnable );

	static HRESULT MMRESULTtoHRESULT( MMRESULT mmr );	
	
private:
	BOOL m_fMasterMuxIsMux;
    BOOL m_fAcquiredVolCtrl;
    
    MIXERCONTROLDETAILS m_mxcdMasterVol;
    MIXERCONTROLDETAILS m_mxcdMasterMute;
    MIXERCONTROLDETAILS m_mxcdMasterMux;
    MIXERCONTROLDETAILS m_mxcdMicVol;
    MIXERCONTROLDETAILS m_mxcdMicMute;
    MIXERCONTROLDETAILS_UNSIGNED m_mxVolume;
    MIXERCONTROLDETAILS_BOOLEAN m_mxMute;
    MIXERCONTROLDETAILS_BOOLEAN* m_pmxMuxFlags;
    LONG *m_pfMicValue;
    DWORD m_dwRangeMin;
    DWORD m_dwRangeSize;    
    UINT m_uWaveDeviceId;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\sndutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		sndutils.h
 *  Content:	Declares sound related untility functions
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated util functions to take GUIDs and allow for 
 *                      users to pre-create capture/playback devices and
 *						pass them into InitXXXXDuplex
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 * 08/30/99		rodtoll	Added new playback format param to sound init
 * 11/12/99		rodtoll	Updated full duplex test to use new abstracted recording
 *						and playback systems.  
 *				rodtoll	Updated to allow passing of sounddeviceconfig flags in dwflags
 *						parameter to init is effected by the flags specified by user
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Updated to eliminate pointer to GUIDs.
 * 01/27/2000	rodtoll	Updated tests to accept buffer descriptions and play flags/priority 
 * 07/12/2000	rodtoll Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 * 08/03/2000	rodtoll	Bug #41457 - DPVOICE: need way to discover which specific dsound call failed when returning DVERR_SOUNDINITFAILURE 
 * 08/29/2000	rodtoll Bug #43553 and Bug #43620 - Buffer lockup handling.
 * 11/16/2000	rodtoll	Bug #47783 - DPVOICE: Improve debugging of failures caused by DirectSound errors. 
 *
 ***************************************************************************/

class CAudioPlaybackBuffer;
class CAudioPlaybackDevice;
class CAudioRecordDevice;
class CAudioRecordBuffer;

//
// This module contains the definition of sound relatedt utility
// functions.  Functions in this module manipulate WAVEFORMATEX
// structures and provide full duplex initialization / testing
// facilities.
//
// This module also contains the routines used to measure peak
// of an audio buffer and for voice activation.
//
//
#ifndef __SOUNDUTILS_H
#define __SOUNDUTILS_H


void DV_SetupBufferDesc( LPDSBUFFERDESC lpdsBufferDesc, LPDSBUFFERDESC lpdsBufferSource, LPWAVEFORMATEX lpwfxFormat, DWORD dwBufferSize );

HRESULT InitFullDuplex( 
    HWND hwnd,
    const GUID &guidPlayback,
    CAudioPlaybackDevice **audioPlaybackDevice,
    LPDSBUFFERDESC lpdsBufferDesc,        
    CAudioPlaybackBuffer **audioPlaybackBuffer,
    const GUID &guidRecord,
    CAudioRecordDevice **audioRecordDevice,
    CAudioRecordBuffer **audioRecordBuffer,
    GUID guidCT,
    WAVEFORMATEX *primaryFormat,
    WAVEFORMATEX *lpwfxPlayFormat,
    BOOL aso,
    DWORD dwPlayPriority,
    DWORD dwPlayFlags,
    DWORD dwFlags
);

HRESULT InitHalfDuplex( 
    HWND hwnd,
    const GUID &guidPlayback,
    CAudioPlaybackDevice **audioPlaybackDevice,
    LPDSBUFFERDESC lpdsBufferDesc,        
    CAudioPlaybackBuffer **audioPlaybackBuffer,
    GUID guidCT,
    WAVEFORMATEX *primaryFormat,
    WAVEFORMATEX *lpwfxPlayFormat,
    DWORD dwPlayPriority,
    DWORD dwPlayFlags,
    DWORD dwFlags
    );

HRESULT InitializeRecordBuffer( HWND hwnd, LPDVFULLCOMPRESSIONINFO lpdvfInfo, CAudioRecordDevice *parecDevice, CAudioRecordBuffer **pparecBuffer, DWORD dwFlags );

BYTE FindPeak( BYTE *data, DWORD frameSize, BOOL eightBit );    

void DSERTRACK_Update( const char *szAPICall, HRESULT hrResult );
void DSERRTRACK_Reset();
BOOL DSERRTRACK_Init();
void DSERRTRACK_UnInit();

extern BOOL g_fDSErrorBreak;

#if defined(DEBUG) || defined(DBG) || defined(_DEBUG)
#define DSASSERT(condition) if( g_fDSErrorBreak ) { DNASSERT( condition ); }
#else
#define DSASSERT(condition)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\sndutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		sndutils.cpp
 *  Content:
 *		This module contains the implementation of sound related utility
 *		functions.  Functions in this module manipulate WAVEFORMATEX
 *		structures and provide full duplex initialization / testing
 *		facilities.
 *
 *		This module also contains the routines used to measure peak
 *		of an audio buffer and for voice activation.
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated util functions to take GUIDs and allow for 
 *                      users to pre-create capture/playback devices and
 *						pass them into InitXXXXDuplex
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 * 08/30/99		rodtoll	Added new playback format param to sound init 
 * 09/03/99		rodtoll	Fixed return codes on InitFullDuplex
 * 09/20/99		rodtoll	Now checks for invalid GUIDs for playback/record
 * 10/05/99		rodtoll	Added DPF_MODNAMEs
 * 10/29/99		rodtoll	Bug #113726 - Fixed memory leak when full duplex
 *						fails caused by architecture update.
 * 11/12/99		rodtoll	Updated full duplex test to use new abstracted recording
 *						and playback systems.  
 *				rodtoll	Updated to allow passing of sounddeviceconfig flags in dwflags
 *						parameter to init is effected by the flags specified by user
 *				rodtoll	Sound buffers (rec and playback) are now set to silence before
 *						recording/playback is started.
 * 11/22/99		rodtoll	Removed unnessessary set of recording buffer to silence.
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Updated for new parameters added by above bug.
 * 12/08/99		rodtoll	Bug #121054 - Support for capture focus and removed flags
 *						from buffer, allow dsound to manage buffer location.
 * 01/21/2000	pnewson	Fixed error cleanup code in InitHalfDuplex
 * 01/27/2000	rodtoll	Updated tests to accept buffer descriptions and play flags/priority  
 * 02/10/2000	rodtoll	Removed more capture focus
 * 02/23/2000	rodtoll	Fix to allow to run on dsound7.  
 * 05/19/2000   rodtoll Bug #35395 - Unable to run two copies of DPVHELP on same system without 
 *                      DirectX 8 installed.
 * 06/21/2000	rodtoll Bug #35767 - Must implement ability to use effects processing on voice buffers
 *						Updated sound initialization routines to handle buffers being passed in.
 * 07/12/2000	rodtoll Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 * 10/04/2000	rodtoll	Bug #43510 - DPVOICE: Apps receive a DVMSGID_SESSIONLOST w/DVERR_LOCKEDBUFFER 
 * 01/04/2001	rodtoll	WinBug #94200 - Remove stray comments 
 * 01/26/2001	rodtoll	WINBUG #293197 - DPVOICE: [STRESS} Stress applications cannot tell difference between out of memory and internal errors.
 *						Remap DSERR_OUTOFMEMORY to DVERR_OUTOFMEMORY instead of DVERR_SOUNDINITFAILURE.
 *						Remap DSERR_ALLOCATED to DVERR_PLAYBACKSYSTEMERROR instead of DVERR_SOUNDINITFAILURE. 
 * 04/12/2001	kareemc	WINBUG #360971 - Wizard Memory Leaks
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

#define DSERRBREAK_NAME				"DSASSERT"

DNCRITICAL_SECTION	g_csDSDebug;

CHAR g_szLastDirectSoundAPI[100] = "";
HRESULT g_hrLastDirectSoundResult = DS_OK;
BOOL g_fDSErrorBreak = FALSE;

void DSERTRACK_Update( const char *szAPICall, HRESULT hrResult )
{
	DNEnterCriticalSection( &g_csDSDebug );		
	if( SUCCEEDED( g_hrLastDirectSoundResult ) )
	{
		g_hrLastDirectSoundResult = hrResult;
		strcpy( g_szLastDirectSoundAPI , szAPICall );
	}
	DNLeaveCriticalSection( &g_csDSDebug );			
}

void DSERRTRACK_Reset()
{
	DNEnterCriticalSection( &g_csDSDebug );			
	g_hrLastDirectSoundResult = DS_OK;
	g_szLastDirectSoundAPI[0] = 0;
	DNLeaveCriticalSection( &g_csDSDebug );			
}

BOOL DSERRTRACK_Init()
{
	if (!DNInitializeCriticalSection( &g_csDSDebug ))
	{
		return FALSE;
	}

	// Load the setting for the directsound assert  
	g_fDSErrorBreak = GetProfileIntA( "DirectPlay8", DSERRBREAK_NAME, FALSE );

	return TRUE;
}

void DSERRTRACK_UnInit()
{
	DNDeleteCriticalSection( &g_csDSDebug );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_SetupBufferDesc"
void DV_SetupBufferDesc( LPDSBUFFERDESC lpdsBufferDesc, LPDSBUFFERDESC lpdsBufferSource, LPWAVEFORMATEX lpwfxFormat, DWORD dwBufferSize )
{
	// Confirm specified buffer description is valid
	if( lpdsBufferSource != NULL )
	{
		if( lpdsBufferSource->dwSize == sizeof( DSBUFFERDESC1 ) )
		{
			memcpy( lpdsBufferDesc, lpdsBufferSource, sizeof( DSBUFFERDESC1 ) );
		}
		else
		{
			memcpy( lpdsBufferDesc, lpdsBufferSource, sizeof( DSBUFFERDESC ) );
		}

		// We require the following flags, at a minimum so they should always be set
		lpdsBufferDesc->dwFlags |= DSBCAPS_CTRL3D | DSBCAPS_CTRLVOLUME | DSBCAPS_GETCURRENTPOSITION2;
	}
	// User did not specify a buffer description, let's use our own!
	else
	{
		lpdsBufferDesc->dwSize = sizeof( DSBUFFERDESC );
		lpdsBufferDesc->dwFlags = DSBCAPS_CTRL3D | DSBCAPS_CTRLVOLUME | DSBCAPS_GLOBALFOCUS | DSBCAPS_GETCURRENTPOSITION2;
		lpdsBufferDesc->dwBufferBytes = 0;
		lpdsBufferDesc->dwReserved = 0;
		lpdsBufferDesc->lpwfxFormat = NULL;
		lpdsBufferDesc->guid3DAlgorithm = DS3DALG_DEFAULT;
	}

	lpdsBufferDesc->lpwfxFormat = lpwfxFormat;
	lpdsBufferDesc->dwBufferBytes = dwBufferSize;

}


#undef DPF_MODNAME
#define DPF_MODNAME "SetRecordBufferToSilence"
HRESULT SetPlaybackBufferToSilence( CAudioPlaybackBuffer *pRecBuffer, LPWAVEFORMATEX lpwfxFormat )
{
	HRESULT hr;
	LPVOID pBufferPtr1, pBufferPtr2;
	DWORD dwBufferSize1, dwBufferSize2;

	hr = pRecBuffer->Lock( 0, 0, &pBufferPtr1, &dwBufferSize1, &pBufferPtr2, &dwBufferSize2, DSBLOCK_ENTIREBUFFER );

	DSERTRACK_Update( "Lock", hr );

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "Lock() failed during silence write hr=0x%x", hr );
		return hr;
	}

	memset( pBufferPtr1, (lpwfxFormat->wBitsPerSample==8) ? 0x80 : 0x00, dwBufferSize1 );	

	hr = pRecBuffer->UnLock( pBufferPtr1, dwBufferSize1, pBufferPtr2, dwBufferSize2 );

	DSERTRACK_Update( "UnLock", hr );	

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "Unlock() failed uffer unlock failed hr=0x%x", hr );
		return hr;
	}

	return DV_OK;
}




#undef DPF_MODNAME
#define DPF_MODNAME "InitHalfDuplex"
// InitHalfDuplex
//
// This function initializes the playback system for the 
// specified compression type and the specified playback
// format.  This function is used to initialize
// the AudioPlaybackDevice and AudioPlaybackBuffer.
//
// It also starts the audio buffer which is used for voice
// output playing.  (In looping mode).
//
// Parameters:
// HWND hwnd - 
//		Window handle for the window where the output will
//      be associated
// ARDID playbackDeviceID -
//		The deviceID for the device which will be used for
//		playback
// CAudioPlaybackDevice ** - 
//		A pointer to a pointer which will contain a pointer
//		to a newly created CAudioPlaybackDevice which will 
//      represent the playback device on success.
// CAudioPlaybackBuffer ** - 
//		A pointer to a pointer which will contain a pointer
//		to a newly created CAudioPlaybacKbuffer which will
//		be used for voice audio output on success.
// CompressionType ct -
//		The type of compression which will be in use.  Used
//		to determine buffer sizes etc.
// WAVEFORMATEX *primaryFormat -
//		Pointer to a WAVEFORMATEX structure describing the
//      format of the voice output.  (This will also be used
//		to set the primary format of the output device if
//      normal is set to false).
// bool normal - 
//		Specifies if normal mode should be used or not.  
//      (Only used when using the DirectSound playback
//      system.  Set to true for normal cooperative mode, 
//      false for priority mode).
//
// Returns:
// bool -
//		Returns true if playback was initializes succesfully, 
//      false if initialization fails.
// 
HRESULT InitHalfDuplex( 
    HWND hwnd,
    const GUID &guidPlayback,
    CAudioPlaybackDevice **audioPlaybackDevice,
    LPDSBUFFERDESC lpdsBufferDesc,    
    CAudioPlaybackBuffer **audioPlaybackBuffer,
	GUID guidCT,
    WAVEFORMATEX *primaryFormat,
	WAVEFORMATEX *lpwfxPlayFormat,    
    DWORD dwPlayPriority,
    DWORD dwPlayFlags,
    DWORD dwFlags
    )
{
    DWORD frameSize;
    HRESULT hr;
	DWORD dwBufferSize;
	BOOL fPriorityMode;
	DSBUFFERDESC dsBufferDesc;
	BOOL fPlaybackDeviceAllocated = FALSE;
	BOOL fPlaybackBufferAllocated = FALSE;

	fPriorityMode = !( dwFlags & DVSOUNDCONFIG_NORMALMODE );

//    *audioPlaybackBuffer = NULL;

    DPFX(DPFPREP,  DVF_INFOLEVEL, "HALFDUPLEX INIT: Begin ==========" );

	LPDVFULLCOMPRESSIONINFO lpdvfInfo;

	hr = DVCDB_GetCompressionInfo( guidCT, &lpdvfInfo );

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "Error loading compression type: hr = 0x%x", hr );
		goto INIT_EXIT_ERROR2;
	}

	if( (*audioPlaybackDevice) == NULL )
	{
#ifdef __WAVESUBSYSTEM
		if( !(dwFlags & DVSOUNDCONFIG_FORCEWAVEOUT) )
		{
#endif
			// Create the object to represent the device using the playback subsystem's
			// CreateDevice function
			(*audioPlaybackDevice) = new CDirectSoundPlaybackDevice();
			fPlaybackDeviceAllocated = TRUE;
			
			if( *audioPlaybackDevice == NULL )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "> Out of memory" );
				hr = DVERR_OUTOFMEMORY;
				goto INIT_EXIT_ERROR2;
			}

			hr = (*audioPlaybackDevice)->Initialize( guidPlayback, hwnd, primaryFormat, fPriorityMode );

#ifndef __WAVESUBSYSTEM
			if( FAILED( hr ) )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize playback.  hr=0x%x", hr );
				goto INIT_EXIT_ERROR2;
			}
#endif

#ifdef __WAVESUBSYSTEM
		}

		if( dwFlags & DVSOUNDCONFIG_FORCEWAVEOUT || 
		    ((dwFlags & DVSOUNDCONFIG_ALLOWWAVEOUT) && FAILED( hr )) 
		  )
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "Could not initialize directsound, defaulting to waveout hr=0x%x", hr );
			delete (*audioPlaybackDevice);

			(*audioPlaybackDevice) = new CWaveOutPlaybackDevice( );
			fPlaybackDeviceAllocated = TRUE;
			
			if( (*audioPlaybackDevice) == NULL )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "> Out of memory" );
				hr = DVERR_OUTOFMEMORY;				
				goto INIT_EXIT_ERROR2;
			}

			hr = (*audioPlaybackDevice)->Initialize( guidPlayback, hwnd, primaryFormat, fPriorityMode );

			if( FAILED( hr ) )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Could not initalize waveOut.  Init failed hr=0x%x", hr );
				goto INIT_EXIT_ERROR2;
			}
		}
		else if( FAILED( hr ) )
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize playback.  hr=0x%x", hr );
			goto INIT_EXIT_ERROR2;
		}
#endif
		// At this point we should have a valid device, waveOut or DirectSound
	}

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Play init" );

	// Create a buffer if the user didn't specify one
	if( !(*audioPlaybackBuffer) )
	{
		frameSize = DVCDB_CalcUnCompressedFrameSize( lpdvfInfo, lpwfxPlayFormat ); 
		dwBufferSize = lpdvfInfo->dwFramesPerBuffer * frameSize;

		DV_SetupBufferDesc( &dsBufferDesc, lpdsBufferDesc, lpwfxPlayFormat, dwBufferSize );

		// Create the audio buffer which will be used for output 
		hr = (*audioPlaybackDevice)->CreateBuffer( &dsBufferDesc, frameSize, audioPlaybackBuffer);
		fPlaybackBufferAllocated = TRUE;

		if( FAILED( hr ) )
		{
    		Diagnostics_Write( DVF_ERRORLEVEL, "Unable to create sound buffer. hr=0x%x", hr );
			goto INIT_EXIT_ERROR2;
		}
	}

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Play  init 2" );

	hr = SetPlaybackBufferToSilence( *audioPlaybackBuffer, lpwfxPlayFormat );

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "> Unable to set playback to silence" );
		goto INIT_EXIT_ERROR2;
	}

	DPFX(DPFPREP,  DVF_INFOLEVEL, "> Play init 3" );

	// Start the audio playback buffer playing
    hr = (*audioPlaybackBuffer)->Play( dwPlayPriority, dwPlayFlags );

	if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "> Can't play" );
        goto INIT_EXIT_ERROR2;
    }

	Diagnostics_Write( DVF_INFOLEVEL, "Half Duplex Init Result = DV_OK " );

    return DV_OK;

// Handle errors
INIT_EXIT_ERROR2:

    if( fPlaybackBufferAllocated && *audioPlaybackBuffer != NULL )
    {
        delete *audioPlaybackBuffer;
        *audioPlaybackBuffer = NULL;
    }

    if( fPlaybackDeviceAllocated && *audioPlaybackDevice != NULL )
    {
        delete *audioPlaybackDevice;
        *audioPlaybackDevice = NULL;
    }

	Diagnostics_Write( DVF_ERRORLEVEL, "Half Duplex Init Result = 0x%x", hr );

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "InitializeRecordBuffer"
HRESULT InitializeRecordBuffer( HWND hwnd, LPDVFULLCOMPRESSIONINFO lpdvfInfo, CAudioRecordDevice *parecDevice, CAudioRecordBuffer **pparecBuffer, DWORD dwFlags )
{
	WAVEFORMATEX *lpwfxRecordFormat;
	DSCBUFFERDESC1 dscdesc;
	DWORD dwFrameSize;
	HRESULT hr;
	
	for( DWORD dwIndex = 0; dwIndex < GetNumRecordFormats(); dwIndex++ )
	{
		lpwfxRecordFormat = GetRecordFormat( dwIndex );
		
		dwFrameSize = DVCDB_CalcUnCompressedFrameSize( lpdvfInfo, lpwfxRecordFormat );			

		memset( &dscdesc, 0x00, sizeof( DSCBUFFERDESC1 ) );
		dscdesc.dwSize = sizeof( DSCBUFFERDESC1 );
		dscdesc.dwFlags = 0;
		dscdesc.lpwfxFormat = lpwfxRecordFormat;
		dscdesc.dwBufferBytes = dwFrameSize*lpdvfInfo->dwFramesPerBuffer;

		if( !(dwFlags & DVSOUNDCONFIG_NOFOCUS) )
		{
			dscdesc.dwFlags |= DSCBCAPS_FOCUSAWARE;

			if( dwFlags & DVSOUNDCONFIG_STRICTFOCUS )
			{
				dscdesc.dwFlags |= DSCBCAPS_STRICTFOCUS;
			}
		}

		hr = parecDevice->CreateBuffer( (DSCBUFFERDESC *) &dscdesc, hwnd, dwFrameSize, pparecBuffer );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Could not initialize %d hz, %d bits, %s (hr=0x%x)", lpwfxRecordFormat->nSamplesPerSec, 
			                       lpwfxRecordFormat->wBitsPerSample, (lpwfxRecordFormat->nChannels==1) ? "Mono" : "Stereo", hr );
			continue;
			
		}
		else
		{
			Diagnostics_Write( DVF_INFOLEVEL, "Recording Initialized.  Format=" );
			Diagnositcs_WriteWAVEFORMATEX( DVF_INFOLEVEL, lpwfxRecordFormat );
		}

		hr = (*pparecBuffer)->Record(TRUE);			

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Could not start rec at %d hz, %d bits, %s (hr=0x%x)", lpwfxRecordFormat->nSamplesPerSec, 
			                       lpwfxRecordFormat->wBitsPerSample, (lpwfxRecordFormat->nChannels==1) ? "Mono" : "Stereo", hr );
			delete (*pparecBuffer);
			(*pparecBuffer) = NULL;
			continue;
		}
		else
		{
			Diagnostics_Write( DVF_INFOLEVEL, "Recording Started.  Format=" );
			Diagnositcs_WriteWAVEFORMATEX( DVF_INFOLEVEL, lpwfxRecordFormat );
			// Reset the directsound erros as we expect errors in this part and if we suceed we handled
			// them.
			return DV_OK;
		}
		
	}

	return DVERR_RECORDSYSTEMERROR;
}

#undef DPF_MODNAME
#define DPF_MODNAME "InitFullDuplex"
// InitFullDuplex
//
// The tricky part.
//
// This function is responsible for initializing the system into full duplex
// mode using the specified parameters.  This function will create and
// initialize the playback and record devices as well as start the 
// playback device playing and the recording device recording.  (On success).
// This is neccessary because the order of Play and Record and device
// creation is important.
//
// Parameters:
// HWND hwnd - 
//		Window handle for the window where the output will
//      be associated
// ARDID playbackDeviceID -
//		The deviceID for the device which will be used for
//		playback
// CAudioPlaybackDevice ** - 
//		A pointer to a pointer which will contain a pointer
//		to a newly created CAudioPlaybackDevice which will 
//      represent the playback device on success.
// CAudioPlaybackBuffer ** - 
//		A pointer to a pointer which will contain a pointer
//		to a newly created CAudioPlaybacKbuffer which will
//		be used for voice audio output on success.
// ARDID recordDeviceID -
//		The ARDID for the device which will be used for recording.
// CAudioRecordSubSystem *recordSubSystem - 
//		This parameter is a pointer to the object representing
//      the subsystem which will be used for recording.
// CAudioRecordDevice ** - 
//		A pointer to a pointer which will contain a newly 
//		create CAudioRecordDevice for voice recording on 
//		success.  
// CompressionType ct -
//		The type of compression which will be in use.  Used
//		to determine buffer sizes etc.
// WAVEFORMATEX *primaryFormat -
//		Pointer to a WAVEFORMATEX structure describing the
//      format of the voice output.  (This will also be used
//		to set the primary format of the output device if
//      normal is set to false).
// bool aso -
//		This parameter controls the ASO option.  The ASO
//		option controls the "Startup Order".  Enabling 
//      this option allows full duplex to be initialized
//      on some troublesome cards.  
// bool normal - 
//		Specifies if normal mode should be used or not.  
//      (Only used when using the DirectSound playback
//      system.  Set to true for normal cooperative mode, 
//      false for priority mode).
//
// Returns:
// bool - true on successful full duplex initialization,
//        false on failure.
//
HRESULT InitFullDuplex( 
    HWND hwnd,
    const GUID &guidPlayback,
    CAudioPlaybackDevice **audioPlaybackDevice,
    LPDSBUFFERDESC lpdsBufferDesc,    
    CAudioPlaybackBuffer **audioPlaybackBuffer,
    const GUID &guidRecord,
    CAudioRecordDevice **audioRecordDevice,
    CAudioRecordBuffer **audioRecordBuffer,
    GUID guidCT,
    WAVEFORMATEX *primaryFormat,
	WAVEFORMATEX *lpwfxPlayFormat,
    BOOL aso,
    DWORD dwPlayPriority,
    DWORD dwPlayFlags,
    DWORD dwFlags
)
{
    DWORD frameSize;
    DWORD dwBufferSize;
	HRESULT hr;
	DSBUFFERDESC dsbdesc;
	BOOL fPriorityMode;
	BOOL fPlaybackDeviceAllocated = FALSE;
	BOOL fPlaybackBufferAllocated = FALSE;
	BOOL fRecordDeviceAllocated = FALSE;

	fPriorityMode = !(dwFlags & DVSOUNDCONFIG_NORMALMODE);

//    *audioPlaybackBuffer = NULL;
    *audioRecordBuffer = NULL;

    DPFX(DPFPREP,  DVF_INFOLEVEL, "FULLDUPLEX INIT: Begin ==========" );

	LPDVFULLCOMPRESSIONINFO lpdvfInfo;

	hr = DVCDB_GetCompressionInfo( guidCT, &lpdvfInfo );

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "Error loading compression type: hr = 0x%x", hr );
		goto INIT_EXIT_ERROR;
	}

	if( (*audioPlaybackDevice) == NULL )
	{
#ifdef __WAVESUBSYSTEM
		if( !(dwFlags & DVSOUNDCONFIG_FORCEWAVEOUT) )	
		{
#endif
			// Create the object to represent the device using the playback subsystem's
			// CreateDevice function
			(*audioPlaybackDevice) = new CDirectSoundPlaybackDevice();
			fPlaybackDeviceAllocated = TRUE;
			
			if( *audioPlaybackDevice == NULL )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "> Out of memory" );
				hr = DVERR_OUTOFMEMORY;
				goto INIT_EXIT_ERROR;
			}

			hr = (*audioPlaybackDevice)->Initialize( guidPlayback, hwnd, primaryFormat, fPriorityMode );

#ifndef __WAVESUBSYSTEM
			if( FAILED( hr ) )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize playback.  hr=0x%x", hr );
				goto INIT_EXIT_ERROR;
			}
#endif

#ifdef __WAVESUBSYSTEM
		}

		if( dwFlags & DVSOUNDCONFIG_FORCEWAVEOUT || 
		    ((dwFlags & DVSOUNDCONFIG_ALLOWWAVEOUT) && FAILED( hr )) ) 
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "Could not initialize directsound, defaulting to waveout hr=0x%x", hr );
			delete (*audioPlaybackDevice);

			(*audioPlaybackDevice) = new CWaveOutPlaybackDevice();
			fPlaybackDeviceAllocated = TRUE;

			if( (*audioPlaybackDevice) == NULL )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "> Out of memory" );
				hr = DVERR_OUTOFMEMORY;				
				goto INIT_EXIT_ERROR;
			}

			hr = (*audioPlaybackDevice)->Initialize( guidPlayback, hwnd, primaryFormat, fPriorityMode );

			if( FAILED( hr ) )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Could not initalize waveOut.  Init failed hr=0x%x", hr );
				goto INIT_EXIT_ERROR;
			}
		}
		else if( FAILED( hr ) )
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize playback.  hr=0x%x", hr );
			goto INIT_EXIT_ERROR;
		}
#endif	
	}

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Play init" );

	frameSize = DVCDB_CalcUnCompressedFrameSize( lpdvfInfo, lpwfxPlayFormat );

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Play init" );

    dwBufferSize = lpdvfInfo->dwFramesPerBuffer * frameSize;

	if( !(*audioPlaybackBuffer) )
	{
		DV_SetupBufferDesc( &dsbdesc, lpdsBufferDesc, lpwfxPlayFormat, dwBufferSize );

		// Create the audio buffer which will be used for output 
		hr = (*audioPlaybackDevice)->CreateBuffer( &dsbdesc, frameSize, audioPlaybackBuffer);
		fPlaybackBufferAllocated = TRUE;
	
		if( FAILED( hr ) )
		{
    		Diagnostics_Write( DVF_ERRORLEVEL, "Unable to create sound buffer. hr=0x%x", hr );
			goto INIT_EXIT_ERROR;
		}
	}

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Play  init 2" );

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Initing Recording" );

	// We're creating the device..
	if( (*audioRecordDevice) == NULL )
	{
#ifdef __WAVESUBSYSTEM
		if( !(dwFlags & DVSOUNDCONFIG_FORCEWAVEIN) )	
		{
#endif
			(*audioRecordDevice) = new CDirectSoundCaptureRecordDevice();
			fRecordDeviceAllocated = TRUE;
			
			if( *audioRecordDevice == NULL )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "> Out of memory" );
				hr = DVERR_OUTOFMEMORY;
				goto INIT_EXIT_ERROR;
			}

			hr = (*audioRecordDevice)->Initialize( guidRecord );

			// DSC Init passed, try getting a buffer
			if( SUCCEEDED( hr ) )
			{
				hr = InitializeRecordBuffer( hwnd, lpdvfInfo, *audioRecordDevice, audioRecordBuffer, dwFlags );
				if( FAILED( hr ) )
				{
					Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize dsc buffer hr=0x%x", hr );
#ifndef __WAVESUBSYSTEM
					Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize record.  hr=0x%x", hr );
					goto INIT_EXIT_ERROR;
#endif
				}
				else
				{
					// Need to reset because we expect errors during initialization.  
					DSERRTRACK_Reset();					
				}
			}
#ifndef __WAVESUBSYSTEM			
			else
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize record.  hr=0x%x", hr );
				goto INIT_EXIT_ERROR;
			}
#endif			
#ifdef __WAVESUBSYSTEM
		}

		// DSC Init failed, try and get a waveIn device
		if( dwFlags & DVSOUNDCONFIG_FORCEWAVEIN || 
		    ((dwFlags & DVSOUNDCONFIG_ALLOWWAVEIN) && FAILED( hr ))) 
		{
		
			Diagnostics_Write( DVF_ERRORLEVEL, "Could not initialize directsoundcapture, defaulting to wavein hr=0x%x", hr );
			delete (*audioRecordDevice);

			(*audioRecordDevice) = new CWaveInRecordDevice();
			fRecordDeviceAllocated = TRUE;
			
			if( (*audioRecordDevice) == NULL )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "> Out of memory" );
				hr = DVERR_OUTOFMEMORY;				
				goto INIT_EXIT_ERROR;
			}

			hr = (*audioRecordDevice)->Initialize( guidPlayback );

			if( FAILED( hr ) )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Could not initalize waveIn.  Init failed hr=0x%x", hr );
				goto INIT_EXIT_ERROR;
			}

			hr = InitializeRecordBuffer( hwnd, lpdvfInfo, *audioRecordDevice, audioRecordBuffer, dwFlags );

			if( FAILED( hr ) )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize waveIn buffer hr=0x%x", hr );
				goto INIT_EXIT_ERROR;
			}			
		}
		else if( FAILED( hr ) )
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize record.  hr=0x%x", hr );
			goto INIT_EXIT_ERROR;
		}
#endif
	}
	// Use specified device, just try and create the buffer
	else
	{
		hr = InitializeRecordBuffer( hwnd, lpdvfInfo, *audioRecordDevice, audioRecordBuffer, dwFlags );

		if( FAILED( hr ) )
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "Unable to initialize dsc buffer hr=0x%x", hr );
			goto INIT_EXIT_ERROR;
		}
	}

    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Rec Init 2" );

	hr = SetPlaybackBufferToSilence( *audioPlaybackBuffer, lpwfxPlayFormat );

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "> Unable to set playback to silence" );
		goto INIT_EXIT_ERROR;
	}
	
    DPFX(DPFPREP,  DVF_INFOLEVEL, "> Rec Init 3" );

	// Depending on the ASO parameter start the playback buffer
	// playing and the recording buffer recording.
    if( aso )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "> ASO " );

        hr = (*audioPlaybackBuffer)->Play( dwPlayPriority, dwPlayFlags );

        if( FAILED( hr ) )
        {
            Diagnostics_Write( DVF_ERRORLEVEL, "> Can't play" );
            goto INIT_EXIT_ERROR;
        }

        hr = (*audioRecordBuffer)->Record(TRUE);

		if( FAILED( hr ) )
        {
            Diagnostics_Write( DVF_ERRORLEVEL, "> Can't start recording" );
            goto INIT_EXIT_ERROR;
        }
    }
    else
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "> !ASO " );

/*        hr = (*audioRecordBuffer)->Record(TRUE);

		if( FAILED( hr ) )
        {
            Diagnostics_Write( DVF_ERRORLEVEL, "> Can't start recording" );
            goto INIT_EXIT_ERROR;
        }  */

        hr = (*audioPlaybackBuffer)->Play( dwPlayPriority, dwPlayFlags );

        if( FAILED( hr ) )
        {
            Diagnostics_Write( DVF_ERRORLEVEL, "> Can't play" );
            goto INIT_EXIT_ERROR;
        }
    }
   
    DPFX(DPFPREP,  DVF_INFOLEVEL, "FULL DUPLEX INIT: End ==========" );

	Diagnostics_Write( DVF_INFOLEVEL, "Full Duplex Init Result = DV_OK" );

    return DV_OK;

INIT_EXIT_ERROR:

	if( *audioRecordBuffer != NULL )
	{
		delete *audioRecordBuffer;
		*audioRecordBuffer = NULL;
	}

	// Only delete on error if we allocated
    if( fRecordDeviceAllocated && *audioRecordDevice != NULL )
    {
        delete *audioRecordDevice;
        *audioRecordDevice = NULL;
    }

	// Only delete on error if we allocated
    if( fPlaybackBufferAllocated && *audioPlaybackBuffer != NULL )
    {
        delete *audioPlaybackBuffer;
        *audioPlaybackBuffer = NULL;
    }

	// Only delete on error if we allocated
    if( fPlaybackDeviceAllocated && *audioPlaybackDevice != NULL )
    {
        delete *audioPlaybackDevice;
        *audioPlaybackDevice = NULL;
    }

	Diagnostics_Write( DVF_ERRORLEVEL, "Full Duplex Init Result = 0x%x", hr );

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FindPeak8Bit"
// FindPeak8Bit
//
// This function determines what the peak for a buffer
// of 8 bit audio is.  Peak is defined as the loudest 
// sample in a set of audio data rated on a scale of 
// between 0 and 100.  
//
// Parameters:
// BYTE *data -
//		Pointer to the buffer containing the audio data
//      to find the peak of. 
// DWORD frameSize -
//		The size in bytes of the audio data we are
//      checking.
//
// Returns:
// BYTE -
// The peak of the audio buffer, a value between 0 and 100.
//		
BYTE FindPeak8Bit( BYTE *data, DWORD frameSize )
{
    BYTE peak = 0;
    int tmpData;

    for( int index = 0; index < frameSize; index++ )
    {
        tmpData = data[index];

        tmpData -= 0x80;

        if( tmpData < 0 )
            tmpData *= -1;

        if( tmpData > peak )
        {
            peak = (unsigned char) tmpData;
        }
    }

    tmpData = peak * 100 / 0x7F;

    return (BYTE) tmpData;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FindPeak16Bit"
// FindPeak16Bit
//
// This function determines what the peak for a buffer
// of 16 bit audio is.  Peak is defined as the loudest 
// sample in a set of audio data rated on a scale of 
// between 0 and 100.  
//
// Parameters:
// BYTE *data -
//		Pointer to the buffer containing the audio data
//      to find the peak of. 
// DWORD frameSize -
//		The size in bytes of the audio data we are
//      checking.
//
// Returns:
// BYTE -
// The peak of the audio buffer, a value between 0 and 100.
//		
BYTE FindPeak16Bit( short *data, DWORD frameSize )
{
    int peak,       
        tmpData;

    frameSize /= 2;
    peak = 0;
    
    for( int index = 0; index < frameSize; index++ )
    {
        tmpData = data[index];

        if( tmpData < 0 )
        {
            tmpData *= -1;
        }

        if( tmpData > peak )
        {
            peak = tmpData;
        }
    }

    tmpData = (peak * 100) / 0x7FFF;

    return (BYTE) tmpData;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FindPeak"
// FindPeak
//
// This function determines what the peak for a buffer
// of 8 or 16 bit audio is.  Peak is defined as the loudest 
// sample in a set of audio data rated on a scale of 
// between 0 and 100.  
//
// Parameters:
// BYTE *data -
//		Pointer to the buffer containing the audio data
//      to find the peak of. 
// DWORD frameSize -
//		The size in bytes of the audio data we are
//      checking.
// BOOL eightBit -
//		Determins if the buffer is 8 bit or not.  Set to 
//      TRUE for 8 bit data, FALSE for 16 bit data.  
//
// Returns:
// BYTE -
// The peak of the audio buffer, a value between 0 and 100.
//		
BYTE FindPeak( BYTE *data, DWORD frameSize, BOOL eightBit )
{
    if( eightBit )
    {
        return FindPeak8Bit( data, frameSize );
    }
    else
    {
        return FindPeak16Bit( (signed short *) data, frameSize );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\winutil.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		winutil.h
 *  Content:	Windows GUI utility functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/21/99		pnewson	Created
 ***************************************************************************/

#ifndef _WINUTIL_H_
#define _WINUTIL_H_

HRESULT CenterWindowOnWorkspace(HWND hWnd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\wavformat.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wavformat.cpp
 *  Content:
 *		This module contains the CWaveFormat class which is used to work with
 *		WAVEFORMATEX structures.  
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/00		rodtoll	Created
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define REGISTRY_WAVEFORMAT_RATE			L"Rate"
#define REGISTRY_WAVEFORMAT_BITS			L"Bits"
#define REGISTRY_WAVEFORMAT_CHANNELS		L"Channels"
#define REGISTRY_WAVEFORMAT_TAG				L"Tag"
#define REGISTRY_WAVEFORMAT_AVGPERSEC		L"AvgPerSec"
#define REGISTRY_WAVEFORMAT_BLOCKALIGN		L"BlockAlign"
#define REGISTRY_WAVEFORMAT_CBSIZE			L"cbsize"
#define REGISTRY_WAVEFORMAT_CBDATA			L"cbdata"

// Cleanup -- Frees memory 
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::Cleanup"

void CWaveFormat::Cleanup()
{
	if( m_pwfxFormat )
	{
		if( m_fOwned )
		{
			delete m_pwfxFormat;
			m_fOwned = FALSE;
			m_pwfxFormat = NULL;
		}
	}
}

// Initialize with full parameters
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::Initialize"

HRESULT CWaveFormat::Initialize( WORD wFormatTag, DWORD nSamplesPerSec, WORD nChannels, WORD wBitsPerSample, 
			  	                 WORD nBlockAlign, DWORD nAvgBytesPerSec, WORD cbSize, void *pvExtra )
{
	Cleanup();

	m_pwfxFormat = (LPWAVEFORMATEX) (new BYTE[sizeof(WAVEFORMATEX)+cbSize]);

	if( !m_pwfxFormat )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DVERR_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	m_pwfxFormat->wFormatTag = wFormatTag;
	m_pwfxFormat->nSamplesPerSec = nSamplesPerSec;
	m_pwfxFormat->nChannels = nChannels;
	m_pwfxFormat->wBitsPerSample = wBitsPerSample;
	m_pwfxFormat->nBlockAlign = nBlockAlign;
	m_pwfxFormat->nAvgBytesPerSec = nAvgBytesPerSec;
	m_pwfxFormat->cbSize = cbSize;

	if( m_pwfxFormat->cbSize )
	{
		memcpy( &m_pwfxFormat[1], pvExtra, m_pwfxFormat->cbSize );
	}

	return DV_OK;
}

// Initialize and copy the specified format
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializeCPY"

HRESULT CWaveFormat::InitializeCPY( LPWAVEFORMATEX pwfxFormat, void *pvExtra )
{
	Cleanup();

	m_pwfxFormat = (LPWAVEFORMATEX) (new BYTE[sizeof( WAVEFORMATEX ) + pwfxFormat->cbSize] );

	if( !m_pwfxFormat )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DVERR_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	memcpy( m_pwfxFormat, pwfxFormat, sizeof( WAVEFORMATEX ) );
	memcpy( &m_pwfxFormat[1], pvExtra, pwfxFormat->cbSize );

	return DV_OK;
}

// Build a standard PCM format
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializePCM"

HRESULT CWaveFormat::InitializePCM( WORD wHZ, BOOL fStereo, BYTE bBitsPerSample )
{
	Cleanup();

	m_pwfxFormat = new WAVEFORMATEX;

	if( !m_pwfxFormat )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DVERR_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	m_pwfxFormat->wFormatTag		= WAVE_FORMAT_PCM;
	m_pwfxFormat->nSamplesPerSec	= (WORD) wHZ;
	m_pwfxFormat->nChannels			= (fStereo) ? 2 : 1;
	m_pwfxFormat->wBitsPerSample	= (WORD) bBitsPerSample;
	m_pwfxFormat->nBlockAlign		= (bBitsPerSample * m_pwfxFormat->nChannels / 8);
	m_pwfxFormat->nAvgBytesPerSec	= m_pwfxFormat->nSamplesPerSec * m_pwfxFormat->nBlockAlign;
	m_pwfxFormat->cbSize			= 0;

	return DV_OK;
}

// Create a WAVEFORMAT that is of size dwSize
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializeMEM"

HRESULT CWaveFormat::InitializeMEM( DWORD dwSize )
{
	Cleanup();

	m_pwfxFormat = (LPWAVEFORMATEX) new BYTE[dwSize];

	if( !m_pwfxFormat )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DVERR_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	return DV_OK;
}

// Initialize but unowned
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializeUSE"

HRESULT CWaveFormat::InitializeUSE( WAVEFORMATEX *pwfxFormat )
{
	Cleanup();

	m_pwfxFormat = pwfxFormat;

	m_fOwned = FALSE;

	return DV_OK;
}

// Set this object equal to the parameter
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::SetEqual"

HRESULT CWaveFormat::SetEqual( CWaveFormat *pwfxFormat )
{
	Cleanup();

	if( pwfxFormat )
	{
		LPWAVEFORMATEX pwfxTmp = pwfxFormat->GetFormat();

		DNASSERT( pwfxFormat->GetFormat() );
	
		return Initialize( pwfxTmp->wFormatTag, pwfxTmp->nSamplesPerSec, 
						   pwfxTmp->nChannels, pwfxTmp->wBitsPerSample,
						   pwfxTmp->nBlockAlign, pwfxTmp->nAvgBytesPerSec,
						   pwfxTmp->cbSize, (pwfxTmp->cbSize) ? &pwfxTmp[1] : NULL );
	}

	return DV_OK;
}

// Are these two types equal?
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::IsEqual"

BOOL CWaveFormat::IsEqual( CWaveFormat *pwfxFormat )
{
	if( !pwfxFormat )
		return FALSE;

	DNASSERT( pwfxFormat->GetFormat() );

	if( pwfxFormat->GetFormat()->cbSize != m_pwfxFormat->cbSize )
		return FALSE;

	if( memcmp( pwfxFormat->GetFormat(), m_pwfxFormat, sizeof( WAVEFORMATEX ) ) != 0 )
		return FALSE;

	if( memcmp( &(pwfxFormat->GetFormat())[1], &m_pwfxFormat[1], m_pwfxFormat->cbSize ) != 0 )
		return FALSE;

	return TRUE;
}

// Write the contained value to the registry
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::WriteREG"

HRESULT CWaveFormat::WriteREG( HKEY hKeyRoot, const WCHAR *wszPath )
{
	CRegistry waveKey;
	HRESULT hr;

	if( !waveKey.Open( hKeyRoot, wszPath, FALSE, TRUE ) )
	{
		return E_FAIL; 
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_CBSIZE, m_pwfxFormat->cbSize ) )
	{
		return E_FAIL;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_RATE, m_pwfxFormat->nSamplesPerSec ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_BITS, m_pwfxFormat->wBitsPerSample ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_CHANNELS, m_pwfxFormat->nChannels ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_TAG, m_pwfxFormat->wFormatTag ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_AVGPERSEC, m_pwfxFormat->nAvgBytesPerSec ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_BLOCKALIGN, m_pwfxFormat->nBlockAlign ) ) 
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteBlob( REGISTRY_WAVEFORMAT_CBDATA, (LPBYTE) &m_pwfxFormat[1], m_pwfxFormat->cbSize ) )
	{
		goto WRITE_FAILURE;
	}

	return S_OK;

WRITE_FAILURE:

	DPFX(DPFPREP,  0, "Error writing waveformat" );

	return E_FAIL;
}


// Initialize from registry 
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializeREG"

HRESULT CWaveFormat::InitializeREG( HKEY hKeyRoot, const WCHAR *wszPath )
{
	CRegistry waveKey;
	HRESULT hr;

	if( !waveKey.Open( hKeyRoot, wszPath, TRUE, FALSE ) )
	{
		return E_FAIL; 
	}

	DWORD dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_CBSIZE, dwTmp ) )
	{
		return E_FAIL;
	}

	m_pwfxFormat = (LPWAVEFORMATEX) new BYTE[dwTmp+sizeof(WAVEFORMATEX)];

	if( m_pwfxFormat == NULL )
	{
		return E_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	m_pwfxFormat->cbSize = (BYTE) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_RATE, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->nSamplesPerSec = dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_BITS, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->wBitsPerSample = (WORD) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_CHANNELS, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->nChannels = (INT) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_TAG, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->wFormatTag = (WORD) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_AVGPERSEC, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->nAvgBytesPerSec = (INT) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_BLOCKALIGN, dwTmp ) ) 
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->nBlockAlign = (INT) dwTmp;

	dwTmp = m_pwfxFormat->cbSize;

	if( !waveKey.ReadBlob( REGISTRY_WAVEFORMAT_CBDATA, (LPBYTE) &m_pwfxFormat[1], &dwTmp ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading waveformat blob" );
		goto READ_FAILURE;
	}

	return S_OK;

READ_FAILURE:

	Cleanup();

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\timer.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		timer.h
 *  Content:	Timer class - lifted from MSDN
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 01/14/2000	rodtoll	Updated to use DWORD_PTR to allow proper 64-bit operation
 * 01/08/2001   rodtoll	WINBUG #271079 - Pointer being sliced by cast through a DWORD 
 *
 ***************************************************************************/

// 
// Timer.h
//
// This file is from the MSDN, Visual Studuio 6.0 Edition
//
// Article:
// Streaming Wave Files With DirectSound
// 
// Author:
// Mark McCulley, Microsoft Corporation
//

#ifndef _INC_TIMER
#define _INC_TIMER

// Constants
#ifndef SUCCESS
#define SUCCESS TRUE        // Error returns for all member functions
#define FAILURE FALSE
#endif // SUCCESS


typedef BOOL (*TIMERCALLBACK)(DWORD_PTR);

// Classes

// Timer
//
// Wrapper class for Windows multimedia timer services. Provides
// both periodic and one-shot events. User must supply callback
// for periodic events.
// 

class Timer
{
public:
    Timer (void);
    ~Timer (void);
    BOOL Create (UINT nPeriod, UINT nRes, DWORD_PTR dwUser,  TIMERCALLBACK pfnCallback);
protected:
    static void CALLBACK TimeProc(UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);
    TIMERCALLBACK m_pfnCallback;
    DWORD_PTR m_dwUser;
    UINT m_nPeriod;
    UINT m_nRes;
    UINT m_nIDTimer;
};

#endif // _INC_TIMER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\wavformat.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wavformat.h
 *  Content:
 *		This module contains the CWaveFormat class which is used to work with
 *		WAVEFORMATEX structures.  
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/00		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __WAVFORMAT_H
#define __WAVFORMAT_H

/////////////////////////////////////////////////////////////////////
//
// CWaveFormat
//
// Used to store and manipulate WAVEFORMATEX structures.
//
class CWaveFormat
{
public:

	CWaveFormat(): m_pwfxFormat(NULL), m_fOwned(FALSE) {};
	~CWaveFormat() { Cleanup(); };

	// Initialize with full parameters
	HRESULT Initialize( WORD wFormatTag, DWORD nSamplesPerSec, WORD nChannels, WORD wBitsPerSample, 
		                WORD nBlockAlign, DWORD nAvgBytesPerSec, WORD cbSize, void *pvExtra );

	// Initialize and copy the specified format
	HRESULT InitializeCPY( LPWAVEFORMATEX pwfxFormat, void *pvExtra );

	// Build a standard PCM format
	HRESULT InitializePCM( WORD wHZ, BOOL fStereo, BYTE bBitsPerSample );

	// Create a WAVEFORMAT that is of size dwSize
	HRESULT InitializeMEM( DWORD dwSize );

	// Initialize but unowned
	HRESULT InitializeUSE( WAVEFORMATEX *pwfxFormat );

	// Initialize from registry 
	HRESULT InitializeREG( HKEY hKeyRoot, const WCHAR *wszPath );

	// Set this object equal to the parameter
	HRESULT SetEqual( CWaveFormat *pwfxFormat );

	// Are these two types equal?
	BOOL IsEqual( CWaveFormat *pwfxFormat );

	// Return a pointer to the format
	inline WAVEFORMATEX *GetFormat() { return m_pwfxFormat; };

	inline WAVEFORMATEX *Disconnect() { m_fOwned = FALSE; return GetFormat(); };

	// Is this an eight bit waveformat?
	inline BOOL IsEightBit() { return (m_pwfxFormat->wBitsPerSample==8); };

	// Write the contained value to the registry
	HRESULT WriteREG( HKEY hKeyRoot, const WCHAR *wszPath );

protected:

	void Cleanup();

	WAVEFORMATEX	*m_pwfxFormat;
	BOOL			m_fOwned;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\winutil.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		winutil.cpp
 *  Content:	Windows GUI utility functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/21/99		pnewson	Created
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

#undef DPF_MODNAME
#define DPF_MODNAME "CenterWindowOnWorkspace"
HRESULT CenterWindowOnWorkspace(HWND hWnd)
{
	DPF_ENTER();
	
	// Center the dialog on the desktop
	RECT rtWnd;
	RECT rtWorkArea;
	
	// First get the current dimensions of the dialog
	if (!GetWindowRect(hWnd, &rtWnd))
	{
		// Get window rect failed. Log it to the debugger, don't move
		// the window.
		DPFX(DPFPREP, DVF_ERRORLEVEL, "GetWindowRect() failed, code: %i", GetLastError());
		DPF_EXIT();
		return E_FAIL;
	}

	// Now get the dimensions of the work area
	if (!SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID)&rtWorkArea, 0))
	{
		// Weird.
		DPFX(DPFPREP, DVF_ERRORLEVEL, "SystemParametersInfo() failed, code: %i", GetLastError());
		DPF_EXIT();
		return E_FAIL;
	}

	if (!MoveWindow(
		hWnd, 
		rtWorkArea.left + (rtWorkArea.right - rtWorkArea.left)/2 - (rtWnd.right - rtWnd.left)/2, 
		rtWorkArea.top + (rtWorkArea.bottom - rtWorkArea.top)/2 - (rtWnd.bottom - rtWnd.top)/2, 
		rtWnd.right - rtWnd.left, 
		rtWnd.bottom - rtWnd.top,
		FALSE))
	{
		// Move window failed. Log it to the debugger.
		DPFX(DPFPREP, DVF_ERRORLEVEL, "MoveWindow() failed, code: %i", GetLastError());
		DPF_EXIT();
		return E_FAIL;
	}
	DPF_EXIT();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\wiutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wirecs.cpp
 *  Content:
 *		This module contains the implementation of the WaveInException class
 *		the recording format db.
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 * 09/03/99		rodtoll	Fixed WaveFormatToString
 * 09/20/99		rodtoll	Updated to check for memory allocation failures
 * 10/05/99		rodtoll	Added DPF_MODNAMES
 * 03/28/2000   rodtoll Removed code which was no longer used 
 * 04/14/2000   rodtoll Fix: Bug #32498 - Updating format list to ensure that 8Khz formats are
 *                      tried first to reduce compression overhead / quality loss
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define __VOXWARE

// NUM_RECORD_FORMATS
//
// This define determines the number of recording formats which
// will be present in the recording db.  (Since they are currently
// hard-coded.
#define NUM_RECORD_FORMATS  16

#define MODULE_ID   WAVEINUTILS

// g_waveInDBInitialized
//
// This flag is used to report when the recording db has been initialized.  
BOOL g_waveInDBInitialized = FALSE;

// g_pwfRecordFormats
//
// This is the actual record format db.  It contains a list of the formats
// that are tried when attempting to find a format which will allow 
// full duplex operation.  They are listed in the order in which they 
// should be tried.
WAVEFORMATEX **g_pwfRecordFormats;

#undef DPF_MODNAME
#define DPF_MODNAME "GetRecordFormat"
// GetRecordFormat
//
// This function returns the recording format at the index specified
// by index in the recording format DB.  
// 
// The recording format db must be initialized before this can be called.
//
// Parameters:
// UINT index -
//		The 0-based index into the recording format db that the user
//		wishes to retrieve.  
//
// Returns:
// WAVEFORMATEX * -
//		A pointer to a WAVEFORMATEX structure describing the format
//      at the given index in the recording db.  This will be NULL
//      if index >= NUM_RECORD_FORMATS or if the recording db has
//      not been initialized.
//
// WARNING:
// The pointer returned is to the actual entry in the recording db and
// is owned by it.  Therefore the caller should not modify or free
// the memory returned by the pointer.  
//
WAVEFORMATEX *GetRecordFormat( UINT index )
{
	if( !g_waveInDBInitialized )
		return NULL;

    if( index >= NUM_RECORD_FORMATS )
    {
        return NULL;
    }
    else
    {
        return g_pwfRecordFormats[index];
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetNumRecordFormats"
// GetNumRecordFormats
//
// This function returns the number of recording formats stored
// in the recording format db.  
//
// Parameters:
// N/A
//
// Returns:
// UINT - 
//		The number of formats in the recording format db.
//
UINT GetNumRecordFormats()
{
	if( !g_waveInDBInitialized )
		return 0;

    return NUM_RECORD_FORMATS;
}

#undef DPF_MODNAME
#define DPF_MODNAME "InitRecordFormats"
// InitRecordFormats
//
// This function initializes the recording format db with the formats which 
// should be tried when initializing recording.  This should be the first
// function called from the recording format db.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
void InitRecordFormats()
{
	if( g_waveInDBInitialized )
		return;

    DPFX(DPFPREP,  DVF_ENTRYLEVEL, "- WDB: Init End" );

    g_pwfRecordFormats = new WAVEFORMATEX*[NUM_RECORD_FORMATS];

    if( g_pwfRecordFormats == NULL )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to init recordb, memory alloc failure" );
    	return;
    }

    g_pwfRecordFormats[0] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 8000, 16 );
    g_pwfRecordFormats[1] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 8000, 8 );
    
    g_pwfRecordFormats[2] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 11025, 16 );
    g_pwfRecordFormats[3] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 22050, 16 );
    g_pwfRecordFormats[4] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 44100, 16 );

    g_pwfRecordFormats[5] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 11025, 8 );
    g_pwfRecordFormats[6] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 22050, 8 );
    g_pwfRecordFormats[7] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 44100, 8 );
     
    g_pwfRecordFormats[8] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 8000, 16 );
    g_pwfRecordFormats[9] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 8000, 8 ); 

    g_pwfRecordFormats[10] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 11025, 16 );    
    g_pwfRecordFormats[11] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 22050, 16 );  
    g_pwfRecordFormats[12] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 44100, 16 );   
    
    g_pwfRecordFormats[13] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 11025, 8 );    
    g_pwfRecordFormats[14] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 22050, 8 );
    g_pwfRecordFormats[15] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 44100, 8 );    
 
/*
    g_pwfRecordFormats[0] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 22050, 8 );
    g_pwfRecordFormats[1] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 22050, 8 );
    g_pwfRecordFormats[2] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 22050, 16 );
    g_pwfRecordFormats[3] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 22050, 16 );  

    g_pwfRecordFormats[4] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 11025, 8 );
    g_pwfRecordFormats[5] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 11025, 8 );
    g_pwfRecordFormats[6] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 11025, 16 );
    g_pwfRecordFormats[7] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 11025, 16 );

    g_pwfRecordFormats[8] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 44100, 8 );
    g_pwfRecordFormats[9] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 44100, 8 );
    g_pwfRecordFormats[10] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 44100, 16 );
    g_pwfRecordFormats[11] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 44100, 16 );   

    g_pwfRecordFormats[12] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 8000, 16 );
    g_pwfRecordFormats[13] = CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 8000, 8 );
    g_pwfRecordFormats[14] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 8000, 16 );       
    g_pwfRecordFormats[15] = CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 8000, 8 );
    */

    g_waveInDBInitialized = TRUE;

    DPFX(DPFPREP,  DVF_ENTRYLEVEL, "- WDB: Init End" );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DeInitRecordFormats"
// DeInitRecordFormats
//
// This function releases the memory associated with the  recording
// format DB.  
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
void DeInitRecordFormats()
{
    if( g_waveInDBInitialized )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "- WDB: DeInit Begin" );

        for( int index = 0; index < NUM_RECORD_FORMATS; index++ )
        {
            delete g_pwfRecordFormats[index];
        }

        delete [] g_pwfRecordFormats;

        DPFX(DPFPREP,  DVF_INFOLEVEL, "- WDB: DeInit End" );

        g_waveInDBInitialized = FALSE;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CreateWaveFormat"
// CreateWaveFormat
//
// This utility function is used to allocate and fill WAVEFORMATEX 
// structures for the various formats used. This function
// currently supports the following formats:
//
// WAVE_FORMAT_ADPCM
// WAVE_FORMAT_DSPGROUP_TRUESPEECH
// WAVE_FORMAT_GSM610
// WAVE_FORMAT_LH_CODEC
// WAVE_FORMAT_PCM
//
// The function will allocate the required memory for the sturcture
// (including extra bytes) as required by the format and will fill
// in all the members of the sturcture.  The structure which is 
// returned belongs to the caller and must be deallocated by the
// caller.
//
// Parameters:
// short formatTag -
//		The format tag for the wav format.
//
// BOOL stereo -
//		Specify TRUE for stereo, FALSE for mono
//
// int hz - 
//		Specify the sampling rate of the format.  E.g. 22050
//
// int bits - 
//		Specify the number of bits / sample.  E.g. 8 or 16
//
// Returns:
// WAVEFORMATEX * - 
//		A pointer to a newly allocated WAVEFORMATEX structure 
//      for the specified format, or NULL if format is not supported
//
WAVEFORMATEX *CreateWaveFormat( short formatTag, BOOL stereo, int hz, int bits ) {

	switch( formatTag ) {
	case WAVE_FORMAT_PCM:
		{
			WAVEFORMATEX *format		= new WAVEFORMATEX;

            if( format == NULL )
            {
				goto EXIT_MEMALLOC_CREATEWAV;            
			}
			
			format->wFormatTag			= WAVE_FORMAT_PCM;
			format->nSamplesPerSec		= hz;
			format->nChannels			= (stereo) ? 2 : 1;
			format->wBitsPerSample		= (WORD) bits;
			format->nBlockAlign			= (bits * format->nChannels / 8);
			format->nAvgBytesPerSec		= format->nSamplesPerSec * format->nBlockAlign;
			format->cbSize				= 0;
			return format;
		}
		break;
    default:
        DNASSERT( TRUE );
	}

EXIT_MEMALLOC_CREATEWAV:

	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to alloc buffer for waveformat, or invalid format" );
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\wiutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dsplayd.h
 *  Content:	general wave in utilty functions and classes
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 * 03/28/2000   rodtoll Removed code which was no longer used
 *
 ***************************************************************************/

#ifndef __WAVEINUTILS_H
#define __WAVEINUTILS_H

// Recording Format DB
//
// The Recording Format DB contains a list of the formats that should
// be used when attempting to initialize a recording device in full 
// duplex mode.  They are listed in the database in the order in which 
// they should be tried.

WAVEFORMATEX *GetRecordFormat( UINT index );
UINT GetNumRecordFormats();

void InitRecordFormats();
void DeInitRecordFormats();
BOOL IsValidRecordDevice( UINT deviceID );


WAVEFORMATEX *CreateWaveFormat( short formatTag, BOOL stereo, int hz, int bits );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\acmconv.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		acmconv.cpp
 *  Content:	This module contains the implementation of the CACMConverter class
 *				which is responsible for handling audio conversions with codecs
 *				through the ACM.  
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 * 09/20/99		rodtoll	Added memory alloc failure checks 
 * 10/05/99		rodtoll	Added dpf_modnames
 *
 ***************************************************************************/

#include "stdafx.h"
#include "acmconv.h"
#include "dndbg.h"
#include "OSInd.h"

#undef DPF_MODNAME
#define DPF_MODNAME "CACMConverter::CACMConverter"
CACMConverter::CACMConverter( 
	WAVEFORMATEX *pwfSrcFormat, DVFULLCOMPRESSIONINFO *lpdvfTargetFormat  
	):	CAudioConverter( pwfSrcFormat,lpdvfTargetFormat ),
		m_bDirectConvert(FALSE),
		m_pwfInnerFormat(NULL),
		m_pbInnerBuffer(NULL),
		m_dwInnerBufferSize(0)
{
	Initialize( pwfSrcFormat, m_lpdvfInfo->lpwfxFormat, pwfSrcFormat  );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CACMConverter::CACMConverter"
CACMConverter::CACMConverter( 
	DVFULLCOMPRESSIONINFO *lpdvfSrcFormat, WAVEFORMATEX *pwfTargetFormat 
	): CAudioConverter( lpdvfSrcFormat, pwfTargetFormat ),
		m_bDirectConvert(FALSE),
		m_pwfInnerFormat(NULL),
		m_pbInnerBuffer(NULL),
		m_dwInnerBufferSize(0)
{
	Initialize( lpdvfSrcFormat->lpwfxFormat, pwfTargetFormat, pwfTargetFormat );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CACMConverter::Initialize"
void CACMConverter::Initialize( WAVEFORMATEX *pwfSrcFormat, WAVEFORMATEX *pwfTargetFormat, WAVEFORMATEX *pwfUnCompressedFormat )
{
    HRESULT retValue;

	m_pwfInnerFormat = GetInnerFormat();

    try 
    {
        // Attempt the conversion directly
        retValue = acmStreamOpen( &m_hacmSource, NULL, pwfSrcFormat, pwfTargetFormat, NULL, 0, 0, ACM_STREAMOPENF_NONREALTIME );

        // If it's not possible, we'll have to do a two step conversion
	    if( retValue == ACMERR_NOTPOSSIBLE ) {

            ACMCHECK( acmStreamOpen( &m_hacmSource, NULL, pwfSrcFormat, m_pwfInnerFormat, NULL, 0, 0, ACM_STREAMOPENF_NONREALTIME ) );

            ACMCHECK( acmStreamOpen( &m_hacmTarget, NULL, m_pwfInnerFormat, pwfTargetFormat, NULL, 0, 0, ACM_STREAMOPENF_NONREALTIME ) );

            m_bDirectConvert = FALSE;

        } 
        // Still not possible
        else if( retValue != 0 )
        {
            ACMCHECK( retValue );
        }
        // Direct conversion was possible
        else
        {
            m_bDirectConvert = TRUE;
        }

        // If we're not direct converting, create an inner conversion 
        // buffer
        if( !m_bDirectConvert )
        {
			m_dwInnerBufferSize = CAudioConverter::CalcUnCompressedFrameSize( m_lpdvfInfo, m_pwfInnerFormat );
            m_pbInnerBuffer = new BYTE[m_dwInnerBufferSize];

            if( m_pbInnerBuffer == NULL )
            {
            	acmStreamClose( m_hacmSource, 0 );
            	acmStreamClose( m_hacmTarget, 0 );
	            m_bValid = FALSE;            	
            }
        }
        else
        {
            m_pbInnerBuffer = NULL;
            m_dwInnerBufferSize = 0;
            m_pwfInnerFormat = NULL;
        }

    }
    // Caught an ACM exception.  Free everything
    // and mark the class as not valid.
    catch( ACMException &ae )
    {
		DPFX(DPFPREP,  DVF_ERRORLEVEL, ae.what() );

        if( m_hacmSource != NULL )
        {
            acmStreamClose( m_hacmSource, 0 );
        }

        if( m_hacmTarget != NULL )
        {
            acmStreamClose( m_hacmTarget, 0 );
        }

        delete [] m_pbInnerBuffer;
        m_pbInnerBuffer = NULL;

        m_bValid = FALSE;

        return;

    }

    m_bValid = TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CACMConverter::~CACMConverter"
// CAudioConverter Destructor
//
// This is called when the class is destroyed.  Closes up the ACM connections
// and deallocates all the memory.
//
CACMConverter::~CACMConverter()
{
    // If this isn't valid, just return, no shutdown required.
    if( !m_bValid )
        return;

    // Shutdown the ACM object
    try
    {

        ACMCHECK( acmStreamClose( m_hacmSource, 0 ) );

        if( !m_bDirectConvert )
        {
            // Unprepare the header
            ACMCHECK( acmStreamClose( m_hacmTarget, 0 ) );
        }

    }
    catch( ACMException &ae )
    {
		DPFX(DPFPREP,  DVF_ERRORLEVEL, ae.what() );
    }

    delete [] m_pbInnerBuffer;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CACMConverter::Convert"
bool CACMConverter::Convert( BYTE *input, UINT inputSize, BYTE *output, UINT &outputSize, BOOL inputSilence )
{
    DWORD tmpLength;	// Used for storing tmp length values

	// Shortcut for silence
	// Fill output buffer with silence, return full length
    if( inputSilence )
    {
		DNASSERT( m_pwfTargetFormat->wFormatTag == WAVE_FORMAT_PCM );
        tmpLength = outputSize;
        memset( output, (m_pwfTargetFormat->wBitsPerSample == 8) ? 0x80 : 0x00, outputSize );
        return true;
    }

    try
    {
        if( m_bDirectConvert )
        {
            // Setup the acm function
            memset( &m_ashSource, 0, sizeof( ACMSTREAMHEADER ) );
            m_ashSource.cbStruct = sizeof( ACMSTREAMHEADER );
            m_ashSource.fdwStatus = 0;
            m_ashSource.dwUser = 0;
            m_ashSource.cbSrcLength = inputSize;
            m_ashSource.pbSrc = input;
            m_ashSource.cbSrcLengthUsed = 0;
            m_ashSource.dwSrcUser = 0;
            m_ashSource.pbDst = output;
            m_ashSource.cbDstLength = outputSize;
            m_ashSource.cbDstLengthUsed = 0;
            m_ashSource.dwDstUser = 0;

            // Prepare the header for conversion
            ACMCHECK( acmStreamPrepareHeader( m_hacmSource, &m_ashSource , 0) );

            // Convert the data
            ACMCHECK( acmStreamConvert( m_hacmSource, &m_ashSource, ACM_STREAMCONVERTF_BLOCKALIGN ) );

            ACMCHECK( acmStreamUnprepareHeader( m_hacmSource, &m_ashSource, 0 ) );

            tmpLength = m_ashSource.cbDstLengthUsed;
        }
        else
        {
            // Setup the acm header for conversion fro mthe source to the
            // inner format
            memset( &m_ashSource, 0, sizeof( ACMSTREAMHEADER ) );
            m_ashSource.cbStruct = sizeof( ACMSTREAMHEADER );
            m_ashSource.fdwStatus = 0;
            m_ashSource.dwUser = 0;
            m_ashSource.cbSrcLength = inputSize;
            m_ashSource.pbSrc = input;
            m_ashSource.cbSrcLengthUsed = 0;
            m_ashSource.dwSrcUser = 0;
            m_ashSource.pbDst = m_pbInnerBuffer;
            m_ashSource.cbDstLength = m_dwInnerBufferSize;
            m_ashSource.cbDstLengthUsed = 0;
            m_ashSource.dwDstUser = 0;

            // Prepare the header for conversion
            ACMCHECK( acmStreamPrepareHeader( m_hacmSource, &m_ashSource , 0) );

            // Convert the data
            ACMCHECK( acmStreamConvert( m_hacmSource, &m_ashSource, ACM_STREAMCONVERTF_BLOCKALIGN ) );

            ACMCHECK( acmStreamUnprepareHeader( m_hacmSource, &m_ashSource, 0 ) );

			DPFX(DPFPREP,  DVF_INFOLEVEL, "CONVERTER: Filling in %d bytes", m_dwInnerBufferSize -  m_ashSource.cbDstLengthUsed );

            memset( &m_ashTarget, 0, sizeof( ACMSTREAMHEADER ) );
            m_ashTarget.cbStruct = sizeof( ACMSTREAMHEADER );
            m_ashTarget.fdwStatus = 0;
            m_ashTarget.dwUser = 0;
            m_ashTarget.cbSrcLength = m_dwInnerBufferSize;
            m_ashTarget.pbSrc = m_pbInnerBuffer;
            m_ashTarget.cbSrcLengthUsed = 0;
            m_ashTarget.dwSrcUser = 0;
            m_ashTarget.pbDst = output;
            m_ashTarget.cbDstLength = outputSize;
            m_ashTarget.cbDstLengthUsed = 0;
            m_ashTarget.dwDstUser = 0;

            // Prepare the header for conversion
            ACMCHECK( acmStreamPrepareHeader( m_hacmTarget, &m_ashTarget , 0) );

            // Convert the data
            ACMCHECK( acmStreamConvert( m_hacmTarget, &m_ashTarget, ACM_STREAMCONVERTF_BLOCKALIGN ) );

            ACMCHECK( acmStreamUnprepareHeader( m_hacmTarget, &m_ashTarget, 0 ) );

            tmpLength = m_ashTarget.cbDstLengthUsed;
        }
    }
    catch( ACMException &ae )
    {
		DPFX(DPFPREP,  DVF_ERRORLEVEL, ae.what() );
        return false;
    }

	// Fill in the remaining buffer if the output is not of the exact size
	// This is often in the case when upconverting.  
	{
		DWORD offset;
		offset = outputSize - tmpLength;

		if( offset > 0 )
		{
			DNASSERT( m_pwfTargetFormat->wFormatTag == WAVE_FORMAT_PCM );

			memset( &output[outputSize - offset], (m_pwfTargetFormat->wBitsPerSample == 8) ? 0x80 : 0x00, offset );
		}
	}

	// Always return the right length
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\acmconv.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		acmconv.h
 *  Content:	Definition of the CACMConverter class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system
 *
 ***************************************************************************/

#ifndef __CACMCONVERTER_H
#define __CACMCONVERTER_H

#include "dvoice.h"
#include "dvcdb.h"
#include "acmutils.h"
#include "aconv.h"

// CACMConverter
//
// ACM implementation of the CAudioConverter class.
//
class CACMConverter: public CAudioConverter
{
public:

    CACMConverter( WAVEFORMATEX *pwfSrcFormat, DVFULLCOMPRESSIONINFO *lpdvfTargetFormat  );
	CACMConverter( DVFULLCOMPRESSIONINFO *lpdvfSrcFormat, WAVEFORMATEX *pwfTargetFormat );

    virtual ~CACMConverter();

	bool Convert( BYTE *input, UINT inputSize, BYTE *output, UINT &outputSize, BOOL inputSilence = FALSE);

protected:

	virtual void Initialize( WAVEFORMATEX *pwfSrcFormat, WAVEFORMATEX *pwfTargetFormat, WAVEFORMATEX *pwfUnCompressedFormat );

	// ACM Conversion control
    ACMSTREAMHEADER m_ashSource;
    ACMSTREAMHEADER m_ashTarget;
	HACMSTREAM      m_hacmSource;
    HACMSTREAM      m_hacmTarget;

    bool			m_bDirectConvert;		// Is it a direct conversion

    WAVEFORMATEX	*m_pwfInnerFormat;		// Format of the intermediate format
    BYTE			*m_pbInnerBuffer;		// Buffer for intermediate step of conversion
    DWORD			m_dwInnerBufferSize;	// Size of the buffer
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\acmutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		acmutils.cpp
 *  Content:	This module contains the implementation of the ACMException class.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 09/21/99		rodtoll	Updated to remove strings from retail build
 * 10/05/99		rodtoll	Added DPF_MODNAMEs
 *
 ***************************************************************************/

#include "stdafx.h"
#include "acmutils.h"
#include "OSInd.h"

#define MODULE_ID   ACMUTILS

#undef DPF_MODNAME
#define DPF_MODNAME "ACMException::MapResultToString"
// ACMException::MapResultToString
//
// This function sets the m_szErrorString member to be a string
// representation of the error code this exception represents.
//
// PArameters:
// N/A
//
// Returns:
// N/A
//
void ACMException::MapResultToString()
{
#ifdef _DEBUG
    switch( m_result )
    {
    case 0:
        _tcscpy( m_szErrorString, _T("No error.") );
        break;
	case ACMERR_NOTPOSSIBLE:
        _tcscpy( m_szErrorString, _T("The requested operation cannot be performed.") );	
		break;
	case MMSYSERR_INVALFLAG:
        _tcscpy( m_szErrorString, _T("At least one flag is invalid. ") );			
		break;
	case MMSYSERR_INVALHANDLE:
        _tcscpy( m_szErrorString, _T("The specified handle is invalid. ") );
		break;
	case MMSYSERR_INVALPARAM:
        _tcscpy( m_szErrorString, _T("At least one parameter is invalid.") );
		break;
	case MMSYSERR_NOMEM:
        _tcscpy( m_szErrorString, _T("No memory") );
		break;
	case ACMERR_CANCELED:
        _tcscpy( m_szErrorString, _T("User cancelled the dialog") );
		break;
	case MMSYSERR_NODRIVER :
        _tcscpy( m_szErrorString, _T("A suitable driver is not available to provide valid format selections.") );
		break;
	default:
        _tcscpy( m_szErrorString, _T("Unknown") );
		break;
	}
#else
	_tcscpy( m_szErrorString, _T("") );
#endif	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\aconv.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		aconv.h
 *  Content:	Definition of the CAudioConverter class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 *
 ***************************************************************************/

#ifndef __AUDIOCONVERTER_H
#define __AUDIOCONVERTER_H

#include "dvoice.h"
#include "dvcdb.h"

// CAudioConverter
//
// The base class of champions.  :)
// 
// This class is the base class for all converter classes.  Users use it by accessing the 
// Convert function with the appropriate parameters.  To implement a converter, you must
// at the minimum:
//
// Implement: InnerConvert and bIsValid
//
class CAudioConverter
{
public: // Public interface
    CAudioConverter( WAVEFORMATEX *pwfSrcFormat, DVFULLCOMPRESSIONINFO *lpdvfTargetFormat  );
	CAudioConverter( DVFULLCOMPRESSIONINFO *lpdvfSrcFormat, WAVEFORMATEX *pwfTargetFormat );

    virtual ~CAudioConverter();

	virtual bool Convert( BYTE *input, UINT inputSize, BYTE *output, UINT &outputSize, BOOL inputSilence = FALSE) = 0;

public: // Data Access Functions

    inline WAVEFORMATEX *pwfGetSourceFormat() { return m_pwfSourceFormat; };
    inline WAVEFORMATEX *pwfGetTargetFormat() { return m_pwfTargetFormat; };

	inline DVFULLCOMPRESSIONINFO *GetCI() { return m_lpdvfInfo; };

    BOOL bIsValid() { return m_bValid; };

	virtual inline DWORD GetUnCompressedFrameSize() { return m_dwUnCompressedFrameSize; }
	virtual inline DWORD GetCompressedFrameSize() { return m_dwCompressedFrameSize; };
	virtual inline DWORD GetNumFramesPerBuffer() { return m_dwNumFramesPerBuffer; };

	static DWORD CalcUnCompressedFrameSize( LPDVFULLCOMPRESSIONINFO lpdvfInfo, WAVEFORMATEX *pwfFormat );

protected:

	virtual void Initialize( WAVEFORMATEX *pwfSrcFormat, WAVEFORMATEX *pwfTargetFormat, WAVEFORMATEX *pwfUnCompressedFormat );

	LPDVFULLCOMPRESSIONINFO m_lpdvfInfo;
	WAVEFORMATEX *m_pwfSourceFormat;
	WAVEFORMATEX *m_pwfTargetFormat;
	BOOL m_bValid;

	DWORD m_dwUnCompressedFrameSize;
	DWORD m_dwCompressedFrameSize;
	DWORD m_dwNumFramesPerBuffer;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\aconv.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		aconv.cpp
 *  Content:	Contains implementation of the CAudioConverter class.  See AudioConverter.h
 *				for class description.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 * 10/05/99		rodtoll	Added DPF_MODNAMEs
 *
 ***************************************************************************/

#include "stdafx.h"
#include "aconv.h"
#include "dndbg.h"
#include "wiutils.h"
#include "OSInd.h"

#define MODULE_ID   AUDIOCONVERTER

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioConverter::CAudioConverter"
CAudioConverter::CAudioConverter( 
	WAVEFORMATEX *pwfSrcFormat, DVFULLCOMPRESSIONINFO *lpdvfTargetFormat 
	):	m_lpdvfInfo( lpdvfTargetFormat ),
		m_bValid(FALSE)
{
	Initialize( pwfSrcFormat, m_lpdvfInfo->lpwfxFormat, pwfSrcFormat  );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioConverter::CAudioConverter"
CAudioConverter::CAudioConverter( 
	DVFULLCOMPRESSIONINFO *lpdvfSrcFormat, WAVEFORMATEX *pwfTargetFormat 
	):	m_lpdvfInfo( lpdvfSrcFormat ),
		m_bValid(FALSE)
{
	Initialize( lpdvfSrcFormat->lpwfxFormat, pwfTargetFormat, pwfTargetFormat );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioConverter::~CAudioConverter"
CAudioConverter::~CAudioConverter()
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioConverter::Initialize"
void CAudioConverter::Initialize( WAVEFORMATEX *pwfSrcFormat, WAVEFORMATEX *pwfTargetFormat, WAVEFORMATEX *pwfUnCompressedFormat )
{
	m_pwfSourceFormat = pwfSrcFormat;
	m_pwfTargetFormat = pwfTargetFormat;
	m_dwNumFramesPerBuffer = m_lpdvfInfo->dwFramesPerBuffer;

	m_dwCompressedFrameSize = m_lpdvfInfo->dwFrameLength;

	m_dwUnCompressedFrameSize = CalcUnCompressedFrameSize( m_lpdvfInfo, pwfUnCompressedFormat );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioConverter::CalcUnCompressedFrameSize"
DWORD CAudioConverter::CalcUnCompressedFrameSize( LPDVFULLCOMPRESSIONINFO lpdvfInfo, WAVEFORMATEX *pwfFormat )
{
	DWORD frameSize;

    switch( pwfFormat->nSamplesPerSec )
    {
    case 8000:      frameSize = lpdvfInfo->dwFrame8Khz;      break;
    case 11025:     frameSize = lpdvfInfo->dwFrame11Khz;     break;
    case 22050:     frameSize = lpdvfInfo->dwFrame22Khz;     break;
    case 44100:     frameSize = lpdvfInfo->dwFrame44Khz;     break;
    default:        return 0;
    }

	return CalculateSizeFromBase( frameSize, pwfFormat );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\acmutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		acmutils.h
 *  Content:	Definition of the ACMException class and ACM utilities
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __ACMUTILS_H
#define __ACMUTILS_H

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <list>

// ACMException
//
// This class is the exception class for handling exceptions from
// errors from the ACM library.  
//
class ACMException: public exception
{
public:

    ACMException( const TCHAR *funcName, HRESULT result, unsigned int moduleID = 0, unsigned int lineNumber = 0 )
    {
        _tcscpy( m_szFunctionName, funcName );

        m_uiModuleNumber = moduleID;
        m_uiLineNumber = lineNumber;
        m_result = result;
        MapResultToString();
    }

    ACMException( const ACMException &except )
    {
        m_result = except.m_result;
        m_uiLineNumber = except.m_uiModuleNumber;
        _tcscpy( m_szFunctionName, except.m_szFunctionName );
        _tcscpy( m_szErrorString, except.m_szErrorString );
    }

    virtual const TCHAR *what()
    {
        return m_szErrorString;
    }

    unsigned int    m_uiLineNumber;
    unsigned int    m_uiModuleNumber;
    HRESULT         m_result;
    TCHAR           m_szFunctionName[100];
    TCHAR           m_szErrorString[MAXERRORLENGTH+1];

protected:
    virtual void MapResultToString( );
};

// ACMCHECK
// 
// This macro can be passed the result from an ACM function and
// it will throw an exception if the result indicates an error.
//
#define ACMCHECK(x) if( x != 0 ) { throw ACMException( _T(""), x, 0, __LINE__ ); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\aconv2.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		aconv2.h
 *  Content:	This module delcares the CAudioConverter2 class. This class
 * 				relies on the ACM for actual conversions, but manages
 *				the headaches of mismatched block sizes and multi step
 *				conversions. In order for this class to work, one of the
 *				following must be true:
 *				- the ACM can perform the conversion between the input
 *				  and output format in one step
 *				- the ACM can convert both the input and output formats 
 *   			  to some form of mono PCM in one step, and the ACM can 
 * 				  perform conversions between those mono PCM formats.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/30/99		pnewson	Created
 *
 ***************************************************************************/

#ifndef __CAUDIOCONVERTER2_H
#define __CAUDIOCONVERTER2_H

#include "aconvs.h"

#include <memory>

class CAudioConverter2
{
	// create an audio converter, 
    CAudioConverter2( 
    	WAVEFORMATEX *pwfSrc, 
    	WAVEFORMATEX *pwfDst,
    	BOOL* bAble);
    virtual ~CAudioConverter2();

	// Given input of wInputSize, what is the largest
	// output buffer that could possibly be required to
	// hold the output of a Conver() call. Useful for
	// allocating destination buffers.
	void MaxOutputSize(DWORD dwInputSize, DWORD* pdwOutputSize);

	// Do a conversion from the input buffer to the
	// output buffer. Note that if the input is not
	// large enough, the output may be zero length.
	//
	// Note that an instance of this class is required
	// for every stream that is being converted, since
	// the class encapsulates stream specific state 
	// information between calls to Convert().
	void Convert(
		BYTE* pbInputBuf, 
		DWORD dwInputSize,
		BYTE* pbOutputBuf, 
		DWORD dwOutputBufSize, 
		DWORD* pdwActualSize);

	// Call this to flush any snippets of data in holding
	// due to mismatched block sizes.
	void Flush();

private:
	int m_iNumSteps;
	std::auto_ptr<CAudioConverterSingle> m_apacsStepOne;
	std::auto_ptr<BYTE> m_apbStepOneBuf;
	DWORD m_dwStepOneBufSize;
	std::auto_ptr<CAudioConverterSingle> m_apacsStepTwo;
	std::auto_ptr<BYTE> m_apbStepTwoBuf;
	DWORD m_dwStepTwoBufSize;
	std::auto_ptr<CAudioConverterSingle> m_apacsStepThree;

	// helper functions
	bool CanACMConvert(WAVEFORMATEX* pwfxSrc, WAVEFORMATEX* pwfxDst);
	void SelectBestFmt(WAVEFORMATEX* pwfx, DWORD fAvailFmts);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\aconvs.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		aconvs.cpp
 *  Content:	This module implements the CAudioConverterSingle class. This 
 *				class relies on the ACM for actual conversions, but manages
 *				the headaches of mismatched block sizes. It does NOT manage
 *				multistep conversions.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/30/99		pnewson	Created
 *
 ***************************************************************************/

#include "stdafx.h"

#include "aconvs.h"
#include "acmutils.h"
#include "dndbg.h"
#include "OSInd.h"

CAudioConverterSingle::CAudioConverterSingle( 
    	WAVEFORMATEX *pwfxSrc, 
    	WAVEFORMATEX *pwfxDst )
{
	ACMCHECK( acmStreamOpen(&m_has, NULL, pwfxSrc, pwfxDst, NULL, 0, 0, 0) );

	// I don't want to count on the fact that realloc is going
	// to allocate a new buffer if I pass in a NULL pointer
	// for the current buffer. So allocate a small 8 byte buffer 
	// here. Why 8? Because it is a "nice" sized buffer on all
	// machines up to 64 bit processors, but still small enough
	// to cause a realloc pretty much right away.
	m_dwHoldingBufSize = 8;
	m_apbHoldingBuf = std::auto_ptr<BYTE>(new BYTE[m_dwHoldingBufSize]);
	if (m_apbHoldingBuf.get() == NULL)
	{
		//// TODO(pnewson, "memory alloc failure cleanup")
		throw exception();
	}
	m_dwHoldingBufUsed = 0;

	// figure out how much slack to add to output buffer estimates
	// to account for data that may be in the holding buffer from
	// previous calls to Convert. This slack estimate is based on the
	// assumption that the ACM will eat up all the input data until
	// there is not enough input data to produce another full block of
	// output data

	DWORD dwSingleBlockOutputSize;
	ACMCHECK( acmStreamSize(m_has, pwfxSrc->nBlockAlign, &dwSingleBlockOutputSize, 
		ACM_STREAMSIZEF_SOURCE) );

	// remember the output format's block size
	m_dwOutputBlockSize = pwfxDst->nBlockAlign;

	m_ash.cbStruct = sizeof(ACMSTREAMHEADER);
	m_ash.dwUser = 0;
	m_ash.dwSrcUser = 0;
	m_ash.dwDstUser = 0;
}

CAudioConverterSingle::~CAudioConverterSingle()
{
	ACMCHECK( acmStreamClose(m_has, 0) );

	// the auto_ptr takes care of the buffer
}

void CAudioConverterSingle::MaxOutputSize(DWORD dwInputSize, DWORD* pdwOutputSize)
{
	// figure out how much the ACM thinks it will output
	ACMCHECK( acmStreamSize(m_has, dwInputSize, pdwOutputSize, 
		ACM_STREAMSIZEF_SOURCE) );

	// Add some slack to the output buffer estimates
	// to account for data that may be in the holding buffer from
	// previous calls to Convert. This slack estimate is based on the
	// assumption that the ACM will eat up all the input data until
	// there is not enough input data to produce another full block of
	// output data. Therefore the slack will not account for more
	// than one full block of output data. (Note: the ACM may already
	// take this into account when generating it's estimates, by
	// rounding up somewhere, but better safe than sorry.)
	pdwOutputSize += m_dwOutputBlockSize;
	
	return;
}

void CAudioConverterSingle::Convert(
	BYTE* pbInputBuf, 
	DWORD dwInputSize, 
	BYTE* pbOutputBuf, 
	DWORD dwOutputBufSize, 
	DWORD* pdwActualSize)
{
	// copy the input data into the internal buffer
	// don't overwrite any data already in that buffer
	// that was held over from the previous conversion
	if (m_dwHoldingBufUsed + dwInputSize > m_dwHoldingBufSize)
	{
		// need more space in the input buffer
		m_dwHoldingBufSize = m_dwHoldingBufUsed + dwInputSize;
		std::auto_ptr<BYTE> apbNewBuf(new BYTE[m_dwHoldingBufSize]);
		if (apbNewBuf.get() == NULL)
		{
			//// TODO(pnewson, "memory alloc failure cleanup")
			throw exception();
		}
		memcpy(apbNewBuf.get(), m_apbHoldingBuf.get(), m_dwHoldingBufUsed);

		// note - auto_ptr deletes old buffer here
		m_apbHoldingBuf = apbNewBuf;
	}
	memcpy(m_apbHoldingBuf.get() + m_dwHoldingBufUsed,
		pbInputBuf, dwInputSize);

	m_ash.fdwStatus = 0;
	m_ash.pbSrc = m_apbHoldingBuf.get();
	m_ash.cbSrcLength = m_dwHoldingBufUsed;
	m_ash.cbSrcLengthUsed = 0;
	m_ash.pbDst = pbOutputBuf;
	m_ash.cbDstLength = dwOutputBufSize;
	m_ash.cbDstLengthUsed = 0;

	ACMCHECK( acmStreamPrepareHeader(m_has, &m_ash, 0) );

	ACMCHECK( acmStreamConvert(m_has, &m_ash, ACM_STREAMCONVERTF_BLOCKALIGN) );

	ACMCHECK( acmStreamUnprepareHeader(m_has, &m_ash, 0) );

	// save the unused input data
	m_dwHoldingBufUsed = m_ash.cbSrcLength - m_ash.cbSrcLengthUsed;
	memmove(m_apbHoldingBuf.get(), m_apbHoldingBuf.get() + m_ash.cbSrcLengthUsed,
		m_dwHoldingBufUsed);

	// tell the caller how much of the output buffer
	// we used, if they care
	if (pdwActualSize != NULL)
	{
		*pdwActualSize = m_ash.cbSrcLengthUsed;
	}
	
	return;
};

void CAudioConverterSingle::Flush()
{
	m_dwHoldingBufUsed = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\aconv2.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		aconv2.h
 *  Content:	This module implements the CAudioConverter2 class. 
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 08/02/99		pnewson	Created
 *
 ***************************************************************************/

#include "stdafx.h"

#include "aconv2.h"
#include "acmutils.h"
#include "dndbg.h"
#include "OSInd.h"

// some flags used to remember what PCM formats are supported
// for converting from the source format, and converting to
// the destination format
#define ACONV2_MONO_08BIT_08000HZ 0x00000001
#define ACONV2_MONO_08BIT_11025HZ 0x00000002
#define ACONV2_MONO_08BIT_22050HZ 0x00000004
#define ACONV2_MONO_08BIT_44100HZ 0x00000008
#define ACONV2_MONO_16BIT_08000HZ 0x00000010
#define ACONV2_MONO_16BIT_11025HZ 0x00000020
#define ACONV2_MONO_16BIT_22050HZ 0x00000040
#define ACONV2_MONO_16BIT_44100HZ 0x00000080

CAudioConverter2::CAudioConverter2(WAVEFORMATEX *pwfxSrc,
	WAVEFORMATEX *pwfxDst, BOOL* pbAble)
	: m_iNumSteps(0)
	, m_apacsStepOne(NULL)
	, m_apbStepOneBuf(NULL)
	, m_dwStepOneBufSize(0)
	, m_apacsStepTwo(NULL)
	, m_apbStepTwoBuf(NULL)
	, m_dwStepTwoBufSize(0)
	, m_apacsStepThree(NULL)
{
	WAVEFORMATEX wfx;

	// assume we'll be able to convert
	*pbAble = TRUE;
		
	// see if we can go between these two formats in one
	// step.
	if (CanACMConvert(pwfxSrc, pwfxDst))
	{
		// a single step conversion is possible, use it
		m_iNumSteps = 1;
		m_apacsStepOne = std::auto_ptr<CAudioConverterSingle>(
			new CAudioConverterSingle(pwfxSrc, pwfxDst));
		if (m_apacsStepOne.get() == NULL)
		{
			//// TODO(pnewson, "memory alloc failure cleanup")
			throw exception();
		}
		return;
	}

	// a single step conversion wouldn't do it. 

	// determine the mono PCM formats we can use
	// to convert to the destination format
	DWORD fDstInFmts = 0;
	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.cbSize = 0;

	// check 8bit, 8kHz, mono
	wfx.nSamplesPerSec = 8000;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(&wfx, pwfxDst))
	{
		fDstInFmts |= ACONV2_MONO_08BIT_08000HZ;
	}
	
	// check 8bit, 11kHz, mono
	wfx.nSamplesPerSec = 11025;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(&wfx, pwfxDst))
	{
		fDstInFmts |= ACONV2_MONO_08BIT_11025HZ;
	}
	
	// check 8bit, 22kHz, mono
	wfx.nSamplesPerSec = 22050;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(&wfx, pwfxDst))
	{
		fDstInFmts |= ACONV2_MONO_08BIT_22050HZ;
	}
	
	// check 8bit, 44kHz, mono
	wfx.nSamplesPerSec = 44100;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(&wfx, pwfxDst))
	{
		fDstInFmts |= ACONV2_MONO_08BIT_44100HZ;
	}

	// check 16bit, 8kHz, mono
	wfx.nSamplesPerSec = 8000;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = 2;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(&wfx, pwfxDst))
	{
		fDstInFmts |= ACONV2_MONO_16BIT_08000HZ;
	}
	
	// check 16bit, 11kHz, mono
	wfx.nSamplesPerSec = 11025;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = 2;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(&wfx, pwfxDst))
	{
		fDstInFmts |= ACONV2_MONO_16BIT_11025HZ;
	}
	
	// check 16bit, 22kHz, mono
	wfx.nSamplesPerSec = 22050;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = 2;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(&wfx, pwfxDst))
	{
		fDstInFmts |= ACONV2_MONO_16BIT_22050HZ;
	}
	
	// check 16bit, 44kHz, mono
	wfx.nSamplesPerSec = 44100;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = 2;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(&wfx, pwfxDst))
	{
		fDstInFmts |= ACONV2_MONO_16BIT_44100HZ;
	}

	// determine the mono PCM formats we can use
	// to convert from the source format
	DWORD fSrcOutFmts = 0;
	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.cbSize = 0;

	// check 8bit, 8kHz, mono
	wfx.nSamplesPerSec = 8000;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(pwfxSrc, &wfx))
	{
		fSrcOutFmts |= ACONV2_MONO_08BIT_08000HZ;
	}
	
	// check 8bit, 11kHz, mono
	wfx.nSamplesPerSec = 11025;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(pwfxSrc, &wfx))
	{
		fSrcOutFmts |= ACONV2_MONO_08BIT_11025HZ;
	}
	
	// check 8bit, 22kHz, mono
	wfx.nSamplesPerSec = 22050;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(pwfxSrc, &wfx))
	{
		fSrcOutFmts |= ACONV2_MONO_08BIT_22050HZ;
	}
	
	// check 8bit, 44kHz, mono
	wfx.nSamplesPerSec = 44100;
	wfx.wBitsPerSample = 8;
	wfx.nBlockAlign = 1;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(pwfxSrc, &wfx))
	{
		fSrcOutFmts |= ACONV2_MONO_08BIT_44100HZ;
	}

	// check 16bit, 8kHz, mono
	wfx.nSamplesPerSec = 8000;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = 2;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(pwfxSrc, &wfx))
	{
		fSrcOutFmts |= ACONV2_MONO_16BIT_08000HZ;
	}
	
	// check 16bit, 11kHz, mono
	wfx.nSamplesPerSec = 11025;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = 2;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(pwfxSrc, &wfx))
	{
		fSrcOutFmts |= ACONV2_MONO_16BIT_11025HZ;
	}
	
	// check 16bit, 22kHz, mono
	wfx.nSamplesPerSec = 22050;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = 2;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(pwfxSrc, &wfx))
	{
		fSrcOutFmts |= ACONV2_MONO_16BIT_22050HZ;
	}
	
	// check 16bit, 44kHz, mono
	wfx.nSamplesPerSec = 44100;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = 2;
	wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
	if (CanACMConvert(pwfxSrc, &wfx))
	{
		fSrcOutFmts |= ACONV2_MONO_16BIT_44100HZ;
	}

	// if any of these formats intersect, we can do a 
	// two step conversion
	DWORD fAvailFmts = fSrcOutFmts & fDstInFmts;
	if (fAvailFmts)
	{
		// two steps it is
		// Try to use the highest quality intermediate
		// format available. Since voice tends to be
		// pretty restricted in it's frequency spectrum,
		// the number of bits is more important than the
		// sampling rate, so prefer any 16 bit format to
		// any 8 bit format.

		SelectBestFmt(&wfx, fAvailFmts);

		// wfx now holds the intermediate format, so init the
		// two single step conversions.
		m_iNumSteps = 2;
		m_apacsStepOne = std::auto_ptr<CAudioConverterSingle>(
			new CAudioConverterSingle(pwfxSrc, &wfx));
		if (m_apacsStepOne.get() == NULL)
		{
			//// TODO(pnewson, "memory alloc failure cleanup")
			throw exception();
		}
		m_apacsStepTwo = std::auto_ptr<CAudioConverterSingle>(
			new CAudioConverterSingle(&wfx, pwfxDst));
		if (m_apacsStepTwo.get() == NULL)
		{
			//// TODO(pnewson, "memory alloc failure cleanup")
			throw exception();
		}

		// Now initialize our intermediate buffer. Start with
		// an intermediate buffer large enough to convert one
		// block of input data.
		m_apacsStepOne->MaxOutputSize(pwfxSrc->nBlockAlign, &m_dwStepOneBufSize);
		m_apbStepOneBuf = std::auto_ptr<BYTE>(new BYTE[m_dwStepOneBufSize]);
		return;
	}
	else
	{
		// make sure that both the source and destination format
		// actually can convert to PCM data!
		if (fSrcOutFmts == 0 && fDstInFmts == 0)
		{
			// can't do it
			if (pbAble != NULL)
			{
				*pbAble = FALSE;
			}
			m_iNumSteps = 0;
			return;
		}

		// ok, so we can do something, even though it's going to take us
		// three steps!
		m_iNumSteps = 3;
		
		// choose the highest quality intermediate formats
		WAVEFORMATEX wfx2;
		SelectBestFmt(&wfx, fSrcOutFmts);
		SelectBestFmt(&wfx2, fDstInFmts);

		// confirm that the ACM will be able to go between these
		// two intermedate formats!!!
		if (!CanACMConvert(&wfx, &wfx2))
		{
			// can't do it
			if (pbAble != NULL)
			{
				*pbAble = FALSE;
			}
			m_iNumSteps = 0;
			return;
		}

		// initialize the first converter
		m_apacsStepOne = std::auto_ptr<CAudioConverterSingle>(
			new CAudioConverterSingle(pwfxSrc, &wfx));
		if (m_apacsStepOne.get() == NULL)
		{
			//// TODO(pnewson, "memory alloc failure cleanup")
			throw exception();
		}

		// initialize the second converter
		m_apacsStepTwo= std::auto_ptr<CAudioConverterSingle>(
			new CAudioConverterSingle(&wfx, &wfx2));
		if (m_apacsStepTwo.get() == NULL)
		{
			//// TODO(pnewson, "memory alloc failure cleanup")
			throw exception();
		}

		// initialize the third converter
		m_apacsStepThree = std::auto_ptr<CAudioConverterSingle>(
			new CAudioConverterSingle(&wfx2, pwfxDst));
		if (m_apacsStepThree.get() == NULL)
		{
			//// TODO(pnewson, "memory alloc failure cleanup")
			throw exception();
		}

		// Now initialize our intermediate buffers. Start with
		// intermediate buffers large enough to convert one
		// block of input data.
		m_apacsStepOne->MaxOutputSize(pwfxSrc->nBlockAlign, &m_dwStepOneBufSize);
		m_apbStepOneBuf = std::auto_ptr<BYTE>(new BYTE[m_dwStepOneBufSize]);
		if (m_apbStepOneBuf.get() == NULL)
		{
			//// TODO(pnewson, "memory alloc failure cleanup")
			throw exception();
		}
		m_apacsStepTwo->MaxOutputSize(m_dwStepOneBufSize, &m_dwStepTwoBufSize);
		m_apbStepTwoBuf = std::auto_ptr<BYTE>(new BYTE[m_dwStepTwoBufSize]);
		if (m_apbStepTwoBuf.get() == NULL)
		{
			//// TODO(pnewson, "memory alloc failure cleanup")
			throw exception();
		}
		return;
	}
		
	return;
}

CAudioConverter2::~CAudioConverter2()
{
	// auto ptrs will clean up automatically
	return;
}

void CAudioConverter2::MaxOutputSize(DWORD dwInputSize,
	DWORD* pdwOutputSize)
{
	DWORD dwStepOne;
	DWORD dwStepTwo;
	
	switch (m_iNumSteps)
	{
	case 1:
		m_apacsStepOne->MaxOutputSize(dwInputSize, pdwOutputSize);
		break;
		
	case 2:
		m_apacsStepOne->MaxOutputSize(dwInputSize, &dwStepOne);
		m_apacsStepTwo->MaxOutputSize(dwStepOne, pdwOutputSize);
		break;
		
	case 3:
		m_apacsStepOne->MaxOutputSize(dwInputSize, &dwStepOne);
		m_apacsStepTwo->MaxOutputSize(dwStepOne, &dwStepTwo);
		m_apacsStepThree->MaxOutputSize(dwStepTwo, pdwOutputSize);
		break;
		
	default:
		// this catches the case where the converter was not 
		// able to do the conversion.
		//// TODO(pnewson, "revisit this error case")
		DNASSERT(TRUE);
	}
	
	return;
}

void CAudioConverter2::Convert(
	BYTE* pbInputBuf, 
	DWORD dwInputSize,
	BYTE* pbOutputBuf, 
	DWORD dwOutputBufSize, 
	DWORD* pdwActualSize)
{
	DWORD dwStepOneSize; 
	DWORD dwStepOneOutputSize;
	DWORD dwStepTwoSize; 
	DWORD dwStepTwoOutputSize;

	switch (m_iNumSteps)
	{
	case 1:
		// one step, so just do it
		m_apacsStepOne->Convert(pbInputBuf, dwInputSize, 
			pbOutputBuf, dwOutputBufSize, pdwActualSize);
		break;
		
	case 2:
		// two steps, so we need to convert it to our internal
		// first step buffer first, and then to the caller's 
		// output buffer
		
		// check the buffer size
		m_apacsStepOne->MaxOutputSize(dwInputSize, &dwStepOneSize);
		if (dwStepOneSize > m_dwStepOneBufSize)
		{
			// need a bigger buffer
			std::auto_ptr<BYTE> apbNewBuf(new BYTE[dwStepOneSize]);
			if (apbNewBuf.get() == NULL)
			{
				//// TODO(pnewson, "memory alloc failure cleanup")
				throw exception();
			}

			// note - auto_ptr deletes old buffer
			m_apbStepOneBuf = apbNewBuf;
			m_dwStepOneBufSize = dwStepOneSize;
		}
		
		// we have a large enough temp buffer, so do the first step
		// conversion
		m_apacsStepOne->Convert(pbInputBuf, dwInputSize, 
			m_apbStepOneBuf.get(), m_dwStepOneBufSize, &dwStepOneOutputSize);

		// now do the second step conversion, into the caller's buffer
		m_apacsStepTwo->Convert(m_apbStepOneBuf.get(), dwStepOneOutputSize,
			pbOutputBuf, dwOutputBufSize, pdwActualSize);
		break;
		
	case 3:
		// three steps, so we need to convert it to our internal
		// first step buffer first, and then to seconds step buffer,
		// and then finally into to the caller's output buffer
		
		// check the first step buffer size
		m_apacsStepOne->MaxOutputSize(dwInputSize, &dwStepOneSize);
		if (dwStepOneSize > m_dwStepOneBufSize)
		{
			// need a bigger buffer
			std::auto_ptr<BYTE> apbNewBuf(new BYTE[dwStepOneSize]);
			if (apbNewBuf.get() == NULL)
			{
				//// TODO(pnewson, "memory alloc failure cleanup")
				throw exception();
			}

			// note - auto_ptr deletes old buffer
			m_apbStepOneBuf = apbNewBuf;
			m_dwStepOneBufSize = dwStepOneSize;
		}
		
		// we have a large enough temp buffer, so do the first step
		// conversion
		m_apacsStepOne->Convert(pbInputBuf, dwInputSize, 
			m_apbStepOneBuf.get(), m_dwStepOneBufSize, &dwStepOneOutputSize);

		// check the second step buffer size
		m_apacsStepTwo->MaxOutputSize(dwStepOneOutputSize, &dwStepTwoSize);
		if (dwStepTwoSize > m_dwStepTwoBufSize)
		{
			// need a bigger buffer
			std::auto_ptr<BYTE> apbNewBuf(new BYTE[dwStepTwoSize]);
			if (apbNewBuf.get() == NULL)
			{
				//// TODO(pnewson, "memory alloc failure cleanup")
				throw exception();
			}

			// note - auto_ptr deletes old buffer
			m_apbStepTwoBuf = apbNewBuf;
			m_dwStepTwoBufSize = dwStepTwoSize;
		}
		
		// we have a large enough temp buffer, so do the second step
		// conversion
		m_apacsStepTwo->Convert(m_apbStepOneBuf.get(), dwStepOneOutputSize, 
			m_apbStepTwoBuf.get(), m_dwStepTwoBufSize, &dwStepTwoOutputSize);


		// now do the third step conversion, into the caller's buffer
		m_apacsStepThree->Convert(m_apbStepTwoBuf.get(), dwStepTwoOutputSize,
			pbOutputBuf, dwOutputBufSize, pdwActualSize);
		break;
		
	default:
		// this catches the case where the converter was not 
		// able to do the conversion.
		//// TODO(pnewson, "revisit this error case")
		DNASSERT(TRUE);
	}
	
	return;
}

void CAudioConverter2::Flush()
{
	switch(m_iNumSteps)
	{
	case 3:
		m_apacsStepThree->Flush();
		// Note - falling through!
	case 2:
		m_apacsStepTwo->Flush();
		// Note - falling through!
	case 1:
		m_apacsStepOne->Flush();
		break;
	default:
		// this catches the case where the converter was not 
		// able to do the conversion.
		//// TODO(pnewson, "revisit this error case")
		DNASSERT(TRUE);
	}
}


bool CAudioConverter2::CanACMConvert(WAVEFORMATEX* pwfxSrc, WAVEFORMATEX* pwfxDst)
{
	MMRESULT mmr;
	mmr = acmStreamOpen(NULL, NULL, pwfxSrc, pwfxDst, 
		NULL, 0, 0, ACM_STREAMOPENF_QUERY);
	if (mmr == 0)
	{
		return true;
	}
	if (mmr != ACMERR_NOTPOSSIBLE)
	{
		// this was an unexpected error, so throw an exception.
		ACMCHECK(mmr);
	}
	return false;	
}

void CAudioConverter2::SelectBestFmt(WAVEFORMATEX* pwfx, DWORD fAvailFmts)
{
	pwfx->wFormatTag = WAVE_FORMAT_PCM;
	pwfx->nChannels = 1;
	pwfx->cbSize = 0;

	if (fAvailFmts & ACONV2_MONO_16BIT_44100HZ)
	{
		pwfx->nSamplesPerSec = 44100;
		pwfx->wBitsPerSample = 16;
		pwfx->nBlockAlign = 2;
		pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
	}
	else if (fAvailFmts & ACONV2_MONO_16BIT_22050HZ)
	{
		pwfx->nSamplesPerSec = 22050;
		pwfx->wBitsPerSample = 16;
		pwfx->nBlockAlign = 2;
		pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
	}
	else if (fAvailFmts & ACONV2_MONO_16BIT_11025HZ)
	{
		pwfx->nSamplesPerSec = 11025;
		pwfx->wBitsPerSample = 16;
		pwfx->nBlockAlign = 2;
		pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
	}
	else if (fAvailFmts & ACONV2_MONO_16BIT_08000HZ)
	{
		pwfx->nSamplesPerSec = 8000;
		pwfx->wBitsPerSample = 16;
		pwfx->nBlockAlign = 2;
		pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
	}
	else if (fAvailFmts & ACONV2_MONO_08BIT_44100HZ)
	{
		pwfx->nSamplesPerSec = 44100;
		pwfx->wBitsPerSample = 8;
		pwfx->nBlockAlign = 1;
		pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
	}
	else if (fAvailFmts & ACONV2_MONO_08BIT_22050HZ)
	{
		pwfx->nSamplesPerSec = 22050;
		pwfx->wBitsPerSample = 8;
		pwfx->nBlockAlign = 1;
		pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
	}
	else if (fAvailFmts & ACONV2_MONO_08BIT_11025HZ)
	{
		pwfx->nSamplesPerSec = 11025;
		pwfx->wBitsPerSample = 8;
		pwfx->nBlockAlign = 1;
		pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
	}
	else if (fAvailFmts & ACONV2_MONO_08BIT_08000HZ)
	{
		pwfx->nSamplesPerSec = 8000;
		pwfx->wBitsPerSample = 8;
		pwfx->nBlockAlign = 1;
		pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
	}
	else
	{
		// we should never get here. one of the
		// formats above was supposed to work!
		DNASSERT(FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\aconvs.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		aconvs.h
 *  Content:	This module delcares the CAudioConverterSingle class. This 
 *				class relies on the ACM for actual conversions, but manages
 *				the headaches of mismatched block sizes. It does NOT manage
 *				multistep conversions.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/30/99		pnewson	Created
 *
 ***************************************************************************/

#ifndef __CAUDIOCONVERTERSINGLE_H
#define __CAUDIOCONVERTERSINGLE_H

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

#include <memory>

class CAudioConverterSingle
{
public:
    CAudioConverterSingle( 
    	WAVEFORMATEX *pwfSrc, 
    	WAVEFORMATEX *pwfDst );
    virtual ~CAudioConverterSingle();

	// Given input of wInputSize, what is the largest
	// output buffer that could possibly be required to
	// hold the output of a Conver() call? Useful for
	// allocating destination buffers.
	void MaxOutputSize(DWORD dwInputSize, DWORD* pdwOutputSize);

	// Do a conversion from the input buffer to the
	// output buffer. Note that if the input is not
	// large enough, the output may be zero length.
	//
	// Note that an instance of this class is required
	// for every stream that is being converted, since
	// the class encapsulates stream specific state 
	// information between calls to Convert().
	void Convert(
		BYTE* pbInputBuf, 
		DWORD dwInputSize,
		BYTE* pbOutputBuf, 
		DWORD dwOutputBufSize, 
		DWORD* pdwActualSize);

	// Call this to flush any snippets of data in holding
	// due to mismatched block sizes.
	void Flush();

private:
	HACMSTREAM m_has;
	ACMSTREAMHEADER m_ash;

	std::auto_ptr<BYTE> m_apbHoldingBuf;
	DWORD m_dwHoldingBufSize;	
	DWORD m_dwHoldingBufUsed;

	DWORD m_dwOutputBlockSize;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\aplays.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		aplays.cpp
 *  Content:	This module contains the implementation of the CAudioPlayback
 *              class.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 10/05/99		rodtoll	Added DPF_MODNAMEs 
 *
 ***************************************************************************/

#include "stdafx.h"
#include "aplays.h"
#include "OSInd.h"

#define MODULE_ID AUDIOPLAYBACKSUBSYSTEM

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioPlaybackSubSystem::CAudioPlaybackSubSystem"
// CAudioPlaybackSubSystem Constructor
//
// This is the constructor for this class, it initializes the
// member variables to valid values.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CAudioPlaybackSubSystem::CAudioPlaybackSubSystem(): m_valid(false)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioPlaybackSubSystem::~CAudioPlaybackSubSystem"
// CAudioPlaybackSubSystem Destructor
//
// This is the destructor for this class.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CAudioPlaybackSubSystem::~CAudioPlaybackSubSystem()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\aplays.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		aplays.h
 *  Content:	Definition of the CAudioPlaybackSubSystem class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __AUDIOPLAYBACKSUBSYSTEM_H
#define __AUDIOPLAYBACKSUBSYSTEM_H

// CAudioPlaybackSubSystem
//
// For a particular playback subsystem describes available 
// devices, device capabilities and creates devices.  For each
// subsystem implementation you must inherit from and implement
// this class.  This is the interface used.
//
// The implementation of these classes are also responsible for
// assigning ARDID's to each available device of a subsystem.
//
class CAudioPlaybackSubSystem
{
public:
    CAudioPlaybackSubSystem();
    virtual ~CAudioPlaybackSubSystem();

public:
    inline virtual bool IsValid() { return m_valid; };

public: // Device Handling functions

	// IsValidDevice
	//
	// This function determines if the given device ID is valid
	// for this subsystem.
	//
	// Parameters:
	// ARDID deviceID - The deviceID to check
	//
	// Returns:
	// bool - true or false denoting validity of the given deviceID
	//
    virtual bool IsValidDevice( ARDID deviceID ) = 0;

	// CreateDevice
	//
	// This function creates an object to represent the deviceID
	// given in the deviceID parameter for the subsystem represented
	// by the object implementing this interface.
	//
	// Parameters:
	// ARDID deviceID - The deviceID to create an object for
	//
	// Returns:
	// CAudioPlaybackDevice * - Pointer to the newly created object
	//                          representing the device or NULL on
	//                          failure.  
	//
	// NOTE:
	// The object returned by this function must be destroyed by the
	// application, and must be destroyed BEFORE the sub system is
	// destroyed.
	//
    virtual CAudioPlaybackDevice *CreateDevice( ARDID deviceID ) = 0;

	// GetDeviceInfo
	//
	// This function retrieves information on the specified deviceID
	// (if it is valid) and returns it in the device parameter.
	//
	// Parameters:
	// ARDID deviceID - DeviceID of device you want information about.
	// ARDeviceInfo &device - Place to put device information.  If the
	//                        deviceID is not valid this is not touched.
	//
	// Returns:
	// bool - true on success, false on failure
	//
    virtual bool GetDeviceInfo( ARDID deviceID, ARDeviceInfo &device ) = 0;

	// GetNumDevices
	//
	// This function returns the number of devices supported by this
	// subsystem.  
	//
	// Parameters:
	// N/A
	// 
	// Returns:
	// unsigned int - The number of devices supported by this subsystem.
	//
    virtual unsigned int GetNumDevices() = 0;

	// GetSubSystemName
	//
	// This function returns a string describing the subsystem implemented
	// by the object with this interface.  E.g. "DirectSound" or "WaveOut".
	//
	// Parameters:
	// N/A
	//
	// Returns:
	// const TCHAR * - String description of subsystem implementation
	//
    virtual const TCHAR *GetSubSystemName() = 0;

protected:
    bool m_valid;	// Is the subsystem valid.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\arecd.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		arecd.cpp
 *  Content:	This module contains the implementation of the CAudioRecordDevice
 *              class.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/04/99		rodtoll	Updated to take dsound ranges for volume
 * 10/05/99		rodtoll	Added DPF_MODNAMEs  
 * 11/12/99		rodtoll	NO LONGER REQUIRED
 *
 ***************************************************************************/

#include "stdafx.h"
#if 0
#include "arecd.h"
#include "wiutils.h"
#include "OSInd.h"

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioRecordDevice::CAudioRecordDevice"
// CAudioRecordDevice Constructor
//
// This is the constructor for the CAudioRecordDevice class.  It sets
// the class member variables to sensible values.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CAudioRecordDevice::CAudioRecordDevice(
    ): m_recordFormat(NULL), m_waveInDeviceID(0),
       m_recordStartTimeout(0), m_recordLockTimeout(0),
       m_recordShutdownTimeout(0), m_deviceID(0),
       m_valid(false), m_recording(false),
       m_recordStartLock(false), m_recordShutdownLock(false),
       m_recordLock(false),
       m_volume(0), m_initialized(false)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioRecordDevice::~CAudioRecordDevice"
// CAudioRecordDevice Destructor
//
// This is the destructor for the CAudioRecordDevice class.  Placeholder
// for now.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CAudioRecordDevice::~CAudioRecordDevice()
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioRecordDevice::SelectMicrophone"
// SelectMicrophone
//
// This function causes the microphone to be selected in the
// windows recording mixer for the device represented by this
// object.  
//
// Parameters:
// N/A
//
// Returns:
// bool - true on success, false on failure
//
bool CAudioRecordDevice::SelectMicrophone()
{
    return (bool) MicrophoneSelect( m_waveInDeviceID );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioRecordDevice::GetVolume"
// GetVolume
//
// This function returns the current volume setting of the device
// represented by this object.  It will either use the last value
// retrieved or query the device for the current value.
//
// Parameters:
// bool query - true to query the device, false to use cached value
//
// Returns:
// unsigned char - The current volume of the record device, a value
//                 between 0 and 100.
//
LONG CAudioRecordDevice::GetVolume( bool query )
{
    if( !query )
    {
        return m_volume;
    }
    else
    {
        MicrophoneGetVolume( m_waveInDeviceID, m_volume );

        return m_volume;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioRecordDevice::SetVolume"
// SetVolume
//
// This function sets the volume of the device represented by this
// object to the value specified by volume.  
//
// Parameters:
// unsigned char volume - The volume to set, 0-100
//
// Returns:
// bool - true on success, false on failure
//
bool CAudioRecordDevice::SetVolume( LONG volume )
{
    m_volume = volume;
    return (bool) MicrophoneSetVolume( m_waveInDeviceID, volume );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioRecordDevice::ClearLockedFlags"
// ClearLockedFlags
//
// This function clears the flags which indicate if a lockup has
// occured.  A useful utility function for derived classes.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
void CAudioRecordDevice::ClearLockedFlags()
{
    m_recordStartLock = false;
    m_recordShutdownLock = false;
    m_recordLock = false;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\arecs.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		arecs.cpp
 *  Content:	This module contains the implementation of the CAudioRecordSubSystem
 *              class.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 10/05/99		rodtoll	Added DPF_MODNAMEs   
 *
 ***************************************************************************/

#include "stdafx.h"
#include "arecs.h"
#include "OSInd.h"

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioRecordSubSystem::CAudioRecordSubSystem"
// CAudioRecordSubSystem Constructor
//
// Placeholder
//
CAudioRecordSubSystem::CAudioRecordSubSystem()
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAudioRecordSubSystem::~CAudioRecordSubSystem"
// CAudioRecordSubSystem Destructor
//
// Placeholder
//
CAudioRecordSubSystem::~CAudioRecordSubSystem()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\dscrecs.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dscrecs.h
 *  Content:	Declaration of the CDirectSoundCaptureRecordSubSystem class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated to allow creation via GUID
 *
 ***************************************************************************/

#ifndef __DIRECTSOUNDCAPTURERECORDSUBSYSTEM_H
#define __DIRECTSOUNDCAPTURERECORDSUBSYSTEM_H

// CDirectSoundCaptureRecordSubSystem
//
// This class provides an implementation for the CAudioRecordSubSystem 
// interface using the DirectSoundCapture subsystem.  (If available).
//
// It is responsible for:
// 1. Detecting if DirectSoundCapture is available on the system.
// 2. Enumerating available DirectSoundCapture devices
// 3. Mapping from DirectSoundCapture ID's to the subsystem 
//    independent ARDID's 
// 4. Mapping from DirectsoundCapture ID's to waveIN id's.
// 5. Creating objects which provide the CAudioRecordDevice 
//    interface for specified ARDID's.  
//    
// To use this class, simply construct the class and then check
// the valid flag to determine if the subsystem is available. 
//
class CDirectSoundCaptureRecordSubSystem: public CAudioRecordSubSystem
{
public:
    CDirectSoundCaptureRecordSubSystem();
    ~CDirectSoundCaptureRecordSubSystem();

public:
    bool IsValid();

public:
    bool IsValidDevice( ARDID deviceID );
    CAudioRecordDevice *CreateDevice( ARDID deviceID );
	CAudioRecordDevice *CreateDevice( LPGUID lpGuid );
    bool GetDeviceInfo( ARDID deviceID, ARDeviceInfo &device );
    unsigned int GetNumDevices();

    const TCHAR *GetSubSystemName();

    typedef std::map<ARDID,ARDeviceInfo *> DeviceMap;	// Map ARDID <--> ARDeviceInfo
    typedef std::pair<GUID,unsigned int> DSCPair;	
    typedef std::map<ARDID,DSCPair> DSCMap;				// Map ARDID <--> DSCPair
    typedef DeviceMap::iterator DeviceMapIterator;		// For enumerating DeviceMaps
    typedef DSCMap::iterator DSCMapIterator;			// For enumerating DSCMaps

protected:
    void CleanupDeviceMap();

protected:

    HINSTANCE	m_dsDLL;		// Instance Handle for the DSOUND DLL
    DeviceMap	m_deviceMap;	// Map from ARDID <--> ARDeviceInfo
    DSCMap		m_dscMap;		// Map from ARDID <--> DSCPair
    bool		m_valid;		// Marks if subsystem is available
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\arecs.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		arecs.h
 *  Content:	Definition of the CAudioRecordSubSystem class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __AUDIORECORDSUBSYSTEM_H
#define __AUDIORECORDSUBSYSTEM_H

// CAudioRecordSubSystem
//
// For a particular recording subsystem describes available 
// devices, device capabilities and creates devices.  For each recording
// subsystem type in the system (DirectSoundCapture/WaveIN) there is 
// an implementation of this class which derives from this base class.
//
// You must implement the following functions to implement this class:
// - IsValid
// - CreateDevice
// - GetDeviceInfo
// - GetNumDevices
// - GetSubSystemName
//
class CAudioRecordSubSystem
{
public:
    CAudioRecordSubSystem();
    virtual ~CAudioRecordSubSystem();

public:
	// IsValid
	//
	// This function returns a boolean describing if this object
	// is valid.  (E.g. present in the system).
	//
	// Parameters:
	// N/A
	//
	// Returns:
	// bool - true if the subsystem is valid
	//
    virtual bool IsValid() = 0;

public: // Device Handling functions

	// IsValidDevice
	//
	// Checks to see if the specified device is valid.  
	//
	// Parameters:
	// ARDID deviceID - The ID of the device to check.
	//
	// Returns:
	// bool - true if device identified by deviceID is valid, false
	//        otherwise
	//
    virtual bool IsValidDevice( ARDID deviceID ) = 0;

	// CreateDevice
	//
	// Creates and returns an object derived from CAudioRecordDevice
	// which represents the device specified in the deviceID parameter.
	//
	// Parameters:
	// ARDID deviceID - The deviceID of the device to create an object for.
	//
	// Returns:
	// CAudioRecordDevice * - A pointer to an object implementing the
	//                        CAudioRecordDevice interface for the specified
	//                        device, or NULL on failure.
	//
	// NOTES:
	//
	// The object returned by this function must be deallocated by
	// the application.  Also, it must be destroyed BEFORE the
	// subsystem object is destroyed.
	//
    virtual CAudioRecordDevice *CreateDevice( ARDID deviceID ) = 0;

	// GetDeviceInfo
	//
	// Returns a ARDeviceInfo structure describing the device identified
	// by the deviceID parameter.  (If it exists).
	//
	// Parameters:
	// ARDID deviceID - The ID of the recording device to get information about
	// ARDeviceInfo &device - Structure into which the device description is
	//                        placed.  This structure is not touched
	//                        if deviceID is not a valid device ID.
	//
	// Returns:
	// bool - returns true on success, false on failure
	//
    virtual bool GetDeviceInfo( ARDID deviceID, ARDeviceInfo &device ) = 0;

	// GetNumDevices
	//
	// This function returns the number of devices which this subsystem
	// has detected in the system.
	//
	// Parameters:
	// N/A
	//
	// Returns:
	// unsigned int - the number of valid devices supported by this subsystem
	//
    virtual unsigned int GetNumDevices() = 0;

	// GetSubSystemName
	//
	// Returns a string describing the recording subsystem represented
	// by the object.
	//
	// Parameters:
	// N/A
	//
	// Returns:
	// const TCHAR * - A string description of the subsystem.
	//
    virtual const TCHAR *GetSubSystemName() = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\dputils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dputils.cpp
 *  Content:
 *		This module contains the implementation of the  of the DirectPlay
 *		related definitions, structures and utility functions.
 *		The directplay utility module maintains a list of providers 
 *		support so that we don't need to continue to enumerate the 
 *		providers when we want a list.	
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 09/21/99		rodtoll	Updated to remove strings from retail build
 *
 ***************************************************************************/

#include "stdafx.h"
#include <iostream.h>
#include "dputils.h"
#include "OSInd.h"

#define MODULE_ID   DIRECTPLAYUTILS

#undef DPF_MODNAME
#define DPF_MODNAME "MapResultToString"
// MapResultToString
//
// This function maps an HRESULT returned from a DirectPlay function
// and stored in this exception to it's string equivalent in 
// m_szErrorString.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
void DirectPlayException::MapResultToString()
{
#ifdef _DEBUG
    switch( m_result )
    {
    case DP_OK: 
        _tcscpy( m_szErrorString, _T( "The request completed successfully." ) );   
        break;
    case DPERR_ACCESSDENIED: 
        _tcscpy( m_szErrorString, _T( "The session is full or an incorrect password was supplied." ) );
        break;
    case DPERR_ACTIVEPLAYERS:
        _tcscpy( m_szErrorString, _T( "The requested operation cannot be performed because there are existing active players." ) );
        break;
    case DPERR_ALREADYINITIALIZED:
        _tcscpy( m_szErrorString, _T( "This object is already initialized." ) );
        break;
    case DPERR_APPNOTSTARTED:
        _tcscpy( m_szErrorString, _T( "The application has not been started yet." ) );
        break;
    case DPERR_AUTHENTICATIONFAILED:
        _tcscpy( m_szErrorString, _T( "The password or credentials supplied could not be authenticated." ) );
        break;
    case DPERR_BUFFERTOOLARGE:
        _tcscpy( m_szErrorString, _T( "The data buffer is too large to store." ) );
        break;
    case DPERR_BUSY:
        _tcscpy( m_szErrorString, _T( "A message cannot be sent because the transmission medium is busy." ) );
        break;
    case DPERR_BUFFERTOOSMALL:
        _tcscpy( m_szErrorString, _T( "The supplied buffer is not large enough to contain the requested data." ) );
        break;
    case DPERR_CANTADDPLAYER:
        _tcscpy( m_szErrorString, _T( "The player cannot be added to the session." ) );
        break;
    case DPERR_CANTCREATEGROUP:
        _tcscpy( m_szErrorString, _T( "A new group cannot be created." ) );
        break;
    case DPERR_CANTCREATEPLAYER:
        _tcscpy( m_szErrorString, _T( "A new player cannot be created." ) );
        break;
    case DPERR_CANTCREATEPROCESS:
        _tcscpy( m_szErrorString, _T( "Cannot start the application." ) );
        break;
    case DPERR_CANTCREATESESSION:
        _tcscpy( m_szErrorString, _T( "A new session cannot be created." ) );
        break;
    case DPERR_CANTLOADCAPI:
        _tcscpy( m_szErrorString, _T( "No credentials were supplied and the CryptoAPI package (CAPI) to use for cryptography." ) );
        break;
    case DPERR_CANTLOADSECURITYPACKAGE:
        _tcscpy( m_szErrorString, _T( "The software security package cannot be loaded." ) );
        break;
    case DPERR_CANTLOADSSPI:
        _tcscpy( m_szErrorString, _T( "No credentials were supplied and  (SSPI) cannot be loaded." ) );
        break;
    case DPERR_CAPSNOTAVAILABLEYET:
        _tcscpy( m_szErrorString, _T( "The capabilities of the DirectPlay object have not been determined yet." ) );
        break;
    case DPERR_CONNECTING:
        _tcscpy( m_szErrorString, _T( "The method is in the process of connecting to the network." ) );
        break;
    case DPERR_ENCRYPTIONFAILED:
        _tcscpy( m_szErrorString, _T( "The requested information could not be digitally encrypted." ) );
        break;
    case DPERR_EXCEPTION:
        _tcscpy( m_szErrorString, _T( "An exception occurred when processing the request." ) );
        break;
    case DPERR_GENERIC:
        _tcscpy( m_szErrorString, _T( "An undefined error condition occurred." ) );
        break;
    case DPERR_INVALIDFLAGS:
        _tcscpy( m_szErrorString, _T( "The flags passed to this method are invalid." ) );
        break;
    case DPERR_INVALIDGROUP:
        _tcscpy( m_szErrorString, _T( "The group ID is not recognized as a valid group ID for this game session." ) );
        break;
    case DPERR_INVALIDINTERFACE:
        _tcscpy( m_szErrorString, _T( "The interface parameter is invalid." ) );
        break;
    case DPERR_INVALIDOBJECT:
        _tcscpy( m_szErrorString, _T( "The DirectPlay object pointer is invalid." ) );
        break;
    case DPERR_INVALIDPARAMS:
        _tcscpy( m_szErrorString, _T( "One or more of the parameters passed to the method are invalid." ) );
        break;
    case DPERR_INVALIDPASSWORD:
        _tcscpy( m_szErrorString, _T( "An invalid password was supplied when attempting to join a session that requires one." ) );
        break;
    case DPERR_INVALIDPLAYER:
        _tcscpy( m_szErrorString, _T( "The player ID is not recognized as a valid player ID for this game session." ) );
        break;
    case DPERR_LOGONDENIED:
        _tcscpy( m_szErrorString, _T( "The session could not be opened because credentials are required." ) );
        break;
    case DPERR_NOCAPS:
        _tcscpy( m_szErrorString, _T( "The communication link that DirectPlay is attempting to use is not capable of this function." ) );
        break;
    case DPERR_NOCONNECTION:
        _tcscpy( m_szErrorString, _T( "No communication link was established." ) );
        break;
    case DPERR_NOINTERFACE:
        _tcscpy( m_szErrorString, _T( "The interface is not supported." ) );
        break;
    case DPERR_NOMESSAGES:
        _tcscpy( m_szErrorString, _T( "There are no messages in the receive queue." ) );
        break;
    case DPERR_NONAMESERVERFOUND:
        _tcscpy( m_szErrorString, _T( "No name server (host) could be found or created. A host must exist to create a player." ) );
        break;
    case DPERR_NONEWPLAYERS:
        _tcscpy( m_szErrorString, _T( "The session is not accepting any new players." ) );
        break;
    case DPERR_NOPLAYERS:
        _tcscpy( m_szErrorString, _T( "There are no active players in the session." ) );
        break;
    case DPERR_NOSESSIONS:
        _tcscpy( m_szErrorString, _T( "There are no existing sessions for this game." ) );
        break;
    case DPERR_NOTLOBBIED:
        _tcscpy( m_szErrorString, _T( "Application was not started by using the IDirectPlayLobby2::RunApplication .." ) );
        break;
    case DPERR_NOTLOGGEDIN:
        _tcscpy( m_szErrorString, _T( "An action cannot be performed because a player or client application is not logged in." ) );
        break;
    case DPERR_OUTOFMEMORY:
        _tcscpy( m_szErrorString, _T( "There is insufficient memory to perform the requested operation." ) );
        break;
    case DPERR_PLAYERLOST:
        _tcscpy( m_szErrorString, _T( "A player has lost the connection to the session." ) );
        break;
    case DPERR_SENDTOOBIG:
        _tcscpy( m_szErrorString, _T( "The message being sent by the IDirectPlay3::Send method is too large." ) );
        break;
    case DPERR_SESSIONLOST:
        _tcscpy( m_szErrorString, _T( "The connection to the session has been lost." ) );
        break;
    case DPERR_SIGNFAILED:
        _tcscpy( m_szErrorString, _T( "The requested information could not be digitally signed." ) );
        break;
    case DPERR_TIMEOUT:
        _tcscpy( m_szErrorString, _T( "The operation could not be completed in the specified time." ) );
        break;
    case DPERR_UNAVAILABLE:
        _tcscpy( m_szErrorString, _T( "The requested function is not available at this time." ) );
        break;
    case DPERR_UNINITIALIZED:
        _tcscpy( m_szErrorString, _T( "The requested object has not been initialized." ) );
        break;
    case DPERR_UNKNOWNAPPLICATION:
        _tcscpy( m_szErrorString, _T( "An unknown application was specified." ) );
        break;
    case DPERR_UNSUPPORTED:
        _tcscpy( m_szErrorString, _T( "The function is not available in this implementation." ) );
        break;
    case DPERR_USERCANCEL:
        _tcscpy( m_szErrorString, _T( "1) The user canceled the connection process..." ) );
        break;
    default:
        _tcscpy( m_szErrorString, _T( "Unknown" ) );
        break;
    }
#else
	_tcscpy( m_szErrorString, _T( "" ) );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\dputils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dputils.h
 *  Content:	Declaration of DirectPlay related definitions, structures 
 *				and functions
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __DIRECTPLAYUTILS_H
#define __DIRECTPLAYUTILS_H

// DirectPlayException
//
// This class is the exception class for handling exceptions from
// errors from the DirectPlay library.  
//
class DirectPlayException: public DirectXException
{
public:
    DirectPlayException( 
        const TCHAR *funcName, HRESULT result, 
        const unsigned int moduleID = 0, unsigned int lineNumber = 0 
    ): DirectXException( funcName, result, moduleID, lineNumber ) 
    {
        MapResultToString();
    };
protected:
    void MapResultToString();
};

// DPCHECK
// 
// This macro can be passed the result from an DirectPlay function 
// and it will throw an exception if the result indicates an error.
//
#define DPCHECK(x) if( x != DP_OK ) { throw DirectPlayException( _T(""), x, MODULE_ID, __LINE__ ); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\dscrecs.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dscrecs.cpp
 *  Content:
 *		This module contains the implementation of the 
 *		DirectSoundCaptureRecordSubSystem.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated to allow creation w/GUID
 * 09/20/99		rodtoll	Added memory allocation failure checks 
 * 10/05/99		rodtoll	Added DPF_MODNAMEs       
 *
 ***************************************************************************/

#include "stdafx.h"
#include "dscrecs.h"
#include "dscrecd.h"
#include "wiutils.h"
#include "dsutils.h"
#include "dndbg.h"

typedef HRESULT (WINAPI *DSCENUM)(LPDSENUMCALLBACK lpDSEnumCallback,LPVOID lpContext);


// DSCEnumParam
//
// This structure is used when enumerating the available DirectSoundCapture
// Devices.  The enumeration function adds to the maps this structure points
// to.
//
struct DSCEnumParam
{
    CDirectSoundCaptureRecordSubSystem::DSCMap *m_dscMap;
													// Map of ARDID <--> (GUID,waveINID)
    CDirectSoundCaptureRecordSubSystem::DeviceMap *m_deviceMap;
													// Map of ARDID <--> ARDeviceInfo *
    ARDID m_nextID;									// The ID the current device
													// will have
};

#undef DPF_MODNAME
#define DPF_MODNAME "DSCCEnum"
// DSCCEnum
//
// This function is used to enumerate the available DirectSoundCapture devices
// in a system.  It is used to fill a list of information about the available
// devices in the DirectSoundCapture subsystem.  It is also responsible for
// assigning ARDID's to individual devices.  
//
// Parameters / Return Values:
// See documentation for DirectSoundCaptureEnumerate
// 
BOOL CALLBACK DSCSSEnum(
    LPGUID lpGUID, 
    LPCTSTR lpszDesc,
    LPCTSTR lpszDrvName, 
    LPVOID lpContext 
) {
    BFC_STRING tmpString;

	// Ignore the default device
    if( lpGUID == NULL )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "DSCSSEnum: Ignore default" );
        return TRUE;
    }
    
	// Check to ensure driver / descriptions are not NULL
    if( lpszDesc == NULL || lpszDrvName == NULL )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "DSCSSEnum: Ignoring invalid" );
        return TRUE;
    }


    DSCEnumParam *params = (DSCEnumParam *) lpContext;

    ARDeviceInfo *info = new ARDeviceInfo;   // New Device Record 

    if( info == NULL )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "DSCSSEnum: Alloc failure" );
    	return TRUE;
    }
    
    unsigned int deviceID;
    ARDID aID;

    info->m_deviceName = lpszDesc;				// fill in new record
    info->m_emulated   = false;					// fill in new record

    aID = params->m_nextID;						// asign next available ARDID to this 
												// device

	// Attempt to read the waveIN device ID from the lpszDrvName which usually
	// takes the form waveIN <waveIN ID>.  If that's not possible fill in 
	// waveIN ID for this device to equal the ARDID for the device
	//
    if( _stscanf( lpszDrvName, "WaveIn %u", &deviceID ) != 1 )
    {
		tmpString  = "DSCSSEnum: Device: ";
		tmpString += lpszDrvName;
		tmpString += " Desc: ";
		tmpString += lpszDesc;
		tmpString += " (Can't map)";

        DPFX(DPFPREP,  DVF_INFOLEVEL, BFC_STRING_TOLPSTR( tmpString ) );
        deviceID = aID;
    }

	// Create records to add to the lists
    std::pair<const ARDID,ARDeviceInfo *> devicePair(aID,info);
    std::pair<const ARDID,CDirectSoundCaptureRecordSubSystem::DSCPair> dscPair(aID,CDirectSoundCaptureRecordSubSystem::DSCPair(*lpGUID,deviceID));

	// Insert the new record into the lists
    params->m_deviceMap->insert( devicePair );
    params->m_dscMap->insert( dscPair );

	// Increment the ARDID 
    params->m_nextID++;

    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordSubSystem::CDirectSoundCaptureRecordSubSystem"
// CDirectSoundCaptureRecordSubSystem
//
// This is the constructor for the CDirectSoundCaptureRecordSubSystem 
// object.  It is responsible for building the list of available 
// devices for the DirectSoundCapture sub-system as well as determining
// if DirectSoundCapture is available on the system.  If DirectSoundCapture
// is not available on the system the object's valid flag will be marked
// as false.  The DirectSoundCapture subsystem is also considered to be
// invalid if there are no available devices.
//
// This function does not link to any DirectSoundCapture functions, 
// the DSOUND.DLL available on the system is checked to see if it 
// supports the DirectSoundCapture interfaces. This eliminates need
// to link to newer DirectSound DLL.  (Which is not available on NT).
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CDirectSoundCaptureRecordSubSystem::CDirectSoundCaptureRecordSubSystem()
{
    BFC_STRING format;
    DSCENUM enumFunc;

	m_dsDLL = NULL;

	// Attempt to load the directsound DLL
    m_dsDLL = LoadLibrary( _T("DSOUND.DLL") );

	// If it couldn't be loaded, this sub system is not supported
	// on this system.
    if( m_dsDLL == NULL )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "DSCSS: Unable to load DirectSound" );
        m_valid = false;
        return;
    }

	// Attempt to get the DirectSoundCaptureEnumerateA function from the
	// DSOUND.DLL.  If it's not available then this class assumes it's
	// not supported on this system.
    enumFunc = (DSCENUM) GetProcAddress( m_dsDLL, "DirectSoundCaptureEnumerateA" );

    if( enumFunc == NULL )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "DSCSS: No proc" );
        m_valid = false;
        FreeLibrary( m_dsDLL );
        return;
    }

    DSCEnumParam param;

	// Setup the class for the enumeration of available devices.
    param.m_dscMap = &m_dscMap;
    param.m_deviceMap = &m_deviceMap;
    param.m_nextID = 0;

	// Attempt the enumeration using the enumeration function
	// above using the function pointer provided by GetProcAddress
    try
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "DSCSS: Start" );
        DSCHECK( (*enumFunc)( DSCSSEnum ,&param) );
        DPFX(DPFPREP,  DVF_INFOLEVEL, "DSCSS: Done" );
    }
    catch( DirectSoundException &dse )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "DSCSS: Unable to list" );
        DPFX(DPFPREP,  DVF_ERRORLEVEL, dse.what() );
        CleanupDeviceMap();
        FreeLibrary( m_dsDLL );
        m_valid = false;
        return;
    } 

	// It is also considered an error if there are no devices available
    if( GetNumDevices() == 0 )
    {
        m_valid = false;
        return;
    }

    m_valid = true;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordSubSystem::CleanupDeviceMap"
// CleanupDeviceMap
//
// This utility function is used to free the memory associated with the 
// device map within this class.   
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
void CDirectSoundCaptureRecordSubSystem::CleanupDeviceMap()
{
    DeviceMapIterator deviceIterator;

    deviceIterator = m_deviceMap.begin();

    while( deviceIterator != m_deviceMap.end() )
    {
        delete (*deviceIterator).second;
        deviceIterator++;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordSubSystem::~CDirectSoundCaptureRecordSubSystem"
// CDirectSoundCaptureRecordSubSystem Destructor
//
// This is the destructor for the CDirectSoundCaptureRecordSubSystem
// class.  It frees any memory associated with this subsystem and
// will unload the directsound DLL if it was loaded by the class.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CDirectSoundCaptureRecordSubSystem::~CDirectSoundCaptureRecordSubSystem()
{
	if( m_valid )
	{
		if( m_dsDLL != NULL )
			FreeLibrary( m_dsDLL );		
	}

    CleanupDeviceMap();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordSubSystem::IsValid"
// IsValid
//
// This function returns the value of this object's valid flag.  
// The valid flag is true if the DirectSoundCapture subsystem
// is available on this system, false otherwise.  
//
// Parameters:
// N/A
//
// Returns:
// bool - value of valid flag.
//
bool CDirectSoundCaptureRecordSubSystem::IsValid()
{
    return m_valid;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordSubSystem::IsValidDevice"
// IsValidDevice
//
// This function allows the caller to ask the DirectSoundCapture subsystem
// if the specified ARDID is available on this subsystem.  
//
// Parameters:
// ARDID deviceID - The ID of the device we want to check
//
// Returns:
// bool - true if the specified device is a valid device in the DirectSoundCapture
//        subsystem, false otherwise.
//
bool CDirectSoundCaptureRecordSubSystem::IsValidDevice( ARDID deviceID )
{
    DeviceMapIterator deviceIterator;

    deviceIterator = m_deviceMap.begin();

    if( deviceIterator != m_deviceMap.end() )
    {
        return true;
    }
    else
    {
        return false;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordSubSystem::CreateDevice"
// CreateDevice
//
// This function creates an object to represent the device specified by the
// deviceID parameter.  It returns a CAudioRecordDevice * to the object.
// The object returned is owned by the caller, therefore it must be freed
// by the process calling this function.
//
// Parameters:
// ARDID deviceID - The identifier of the device for which the user wants
//                  to create an object to represent.  
//
// Returns:
// CAudioRecordDevice * - A CAudioRecordDevice pointer to a newly allocated
//                        and constructed CDirectSoundCaptureRecordDevice, 
//                        or NULL on failure.
//
CAudioRecordDevice *CDirectSoundCaptureRecordSubSystem::CreateDevice( ARDID deviceID )
{
    if( IsValidDevice( deviceID ) )
    {
        DeviceMapIterator deviceIterator;
        DSCMapIterator dcsIterator;
        GUID tmpGUID;

        deviceIterator = m_deviceMap.find( deviceID );
        dcsIterator = m_dscMap.find( deviceID );

        DNASSERT( deviceIterator != m_deviceMap.end() );
        DNASSERT( dcsIterator != m_dscMap.end() );

        tmpGUID = (*dcsIterator).second.first;

		// Create the object with the appropriate parameters
        return new CDirectSoundCaptureRecordDevice( tmpGUID, (*dcsIterator).second.second, deviceID, false );
    }
    else
    {
        return NULL;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordSubSystem::GetDeviceInfo"
// GetDeviceInfo
//
// This function retrieves the ARDeviceInfo structure for the specified device identifier.
//
// Parameters:
// ARDID deviceID - 
//		The device identifier for the device you wish to retrieve information about
//
// ARDeviceInfo &device -
//		A ARDeviceINfo structure which will be filled with the details of the specified
//      device on success.
//
// Returns:
// bool - true if the specified device was valid and information was returned, false
//        otherwise.
// 
bool CDirectSoundCaptureRecordSubSystem::GetDeviceInfo( ARDID deviceID, ARDeviceInfo &device )
{
    DeviceMapIterator deviceIterator;

    deviceIterator = m_deviceMap.find(deviceID);

    if( deviceIterator != m_deviceMap.end() )
    {
        device = *((*deviceIterator).second);
        return true;
    }
    else
    {
        return false;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordSubSystem::GetNumDevices"
// GetNumDevices
//
// This function returns the number of valid devices detected in the DirectSoundCapture
// subsystem.  
//
// Parameters:
// N/A
//
// Returns:
// unsigned int - Number of devices available in the DirectSOundCapture subsystem.
unsigned int CDirectSoundCaptureRecordSubSystem::GetNumDevices()
{
    return m_deviceMap.size();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordSubSystem::GetSubSystemName"
// GetSubSystemName
//
// This function returns the string name which identifies the sub system
// this class is implementing.  In this case it will always return
// the string "DirectSoundCapture".
//
// Parameters:
// N/A
//
// Returns:
// const TCHAR * = "DirectSoundCapture"
//
const TCHAR *CDirectSoundCaptureRecordSubSystem::GetSubSystemName()
{
    return _T("DirectSoundCapture");
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordSubSystem::CreateDevice"
CAudioRecordDevice *CDirectSoundCaptureRecordSubSystem::CreateDevice( LPGUID lpGUID )
{
	if( lpGUID == NULL )
	{
		return CreateDevice( (ARDID) 0 );
	}

	DSCMapIterator dsIterator = m_dscMap.begin();

	while( dsIterator != m_dscMap.end() )
	{	
		if( (*dsIterator).second.first == *lpGUID ) 
		{
			return CreateDevice( (*dsIterator).first );
		}

		dsIterator++;
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\dstrwave.cpp ===
/*========================================================================== 
 * 
 *  Copyright (C) 1995-1996 Microsoft Corporation. All Rights Reserved. 
 * 
 *  File:               dstrwave.c 
 *  Content:    Wave library routines. 
 * 
 *      This file is used for loading/saving waves, and reading and 
 *      writing waves in smaller blocks. 
 *      Uses WaveOpenFile, WaveReadFile and WaveCloseReadFile for 
 *      single block access to reading wave files. 
 *      Uses WaveCreateFile, WaveWriteFile, WaveCloseWriteFile for 
 *      single block access for writing  wave files. 
 *      Uses WaveLoadFile to load a whole wave file into memory. 
 *      Uses WaveSaveFile to save a whole wave file from memory. 
 * 
 ***************************************************************************/ 
 
/* PROTOTYPES */ 
#include "stdafx.h"
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "dstrwave.h"
#include "windowsx.h"
#include "dndbg.h"
#include "OSInd.h"

#define MODULE_ID   DSTRWAVE

/*#include <windows.h> 
#include <windowsx.h> 
#include <mmsystem.h>  */
//#include "dsstream.h" 
//#include "wassert.h" 
 
 
/* ROUTINES */ 
/* -------------------------------------------------------*/ 
 
/* This function will open a wave input file and prepare it for reading, 
 * so the data can be easily 
 * read with WaveReadFile. Returns 0 if successful, the error code if not. 
 *      pszFileName - Input filename to load. 
 *      phmmioIn    - Pointer to handle which will be used 
 *          for further mmio routines. 
 *      ppwfxInfo   - Ptr to ptr to WaveFormatEx structure 
 *          with all info about the file.                         
 *       
*/ 
int WaveOpenFile( 
        const char *pszFileName,                              // (IN) 
        HMMIO *phmmioIn,                                // (OUT) 
        WAVEFORMATEX **ppwfxInfo,                       // (OUT) 
        MMCKINFO *pckInRIFF                             // (OUT) 
                        ) 
{ 
        HMMIO           hmmioIn; 
        MMCKINFO        ckIn;           // chunk info. for general use. 
        PCMWAVEFORMAT   pcmWaveFormat;  // Temp PCM structure to load in.        
        WORD            cbExtraAlloc;   // Extra bytes for waveformatex  
        int             nError;         // Return value. 


        // Initialization... 
        *ppwfxInfo = NULL; 
        nError = 0; 
        hmmioIn = NULL; 

        char tmpFileName[_MAX_PATH];

        strcpy( tmpFileName, pszFileName );
     
        if ((hmmioIn = mmioOpen(tmpFileName, NULL, MMIO_ALLOCBUF | MMIO_READ)) == NULL) 
                { 
                nError = ER_CANNOTOPEN; 
                goto ERROR_READING_WAVE; 
                } 

        if ((nError = (int)mmioDescend(hmmioIn, pckInRIFF, NULL, 0)) != 0) 
                { 
                goto ERROR_READING_WAVE; 
                } 


        if ((pckInRIFF->ckid != FOURCC_RIFF) || (pckInRIFF->fccType != mmioFOURCC('W', 'A', 'V', 'E'))) 
                { 
                nError = ER_NOTWAVEFILE; 
                goto ERROR_READING_WAVE; 
                } 
                     
        /* Search the input file for for the 'fmt ' chunk.     */ 
    ckIn.ckid = mmioFOURCC('f', 'm', 't', ' '); 
    if ((nError = (int)mmioDescend(hmmioIn, &ckIn, pckInRIFF, MMIO_FINDCHUNK)) != 0) 
                { 
                goto ERROR_READING_WAVE;                 
                } 
                                     
        /* Expect the 'fmt' chunk to be at least as large as <PCMWAVEFORMAT>; 
    * if there are extra parameters at the end, we'll ignore them */ 
 
    if (ckIn.cksize < (long) sizeof(PCMWAVEFORMAT)) 
                { 
                nError = ER_NOTWAVEFILE; 
                goto ERROR_READING_WAVE; 
                } 
                                                                                                                     
        /* Read the 'fmt ' chunk into <pcmWaveFormat>.*/      
    if (mmioRead(hmmioIn, (HPSTR) &pcmWaveFormat, (long) sizeof(pcmWaveFormat)) != (long) sizeof(pcmWaveFormat)) 
                { 
                nError = ER_CANNOTREAD; 
                goto ERROR_READING_WAVE; 
                } 
                                                     

        // Ok, allocate the waveformatex, but if its not pcm 
        // format, read the next word, and thats how many extra 
        // bytes to allocate. 
        if (pcmWaveFormat.wf.wFormatTag == WAVE_FORMAT_PCM) 
                cbExtraAlloc = 0;                                
                                                     
        else 
                { 
                // Read in length of extra bytes. 
                if (mmioRead(hmmioIn, (LPSTR) &cbExtraAlloc, 
                        (long) sizeof(cbExtraAlloc)) != (long) sizeof(cbExtraAlloc)) 
                        { 
                        nError = ER_CANNOTREAD; 
                        goto ERROR_READING_WAVE; 
                        } 

                } 
                                                     
        // Ok, now allocate that waveformatex structure. 
        if ((*ppwfxInfo = (WAVEFORMATEX *) GlobalAlloc(GMEM_FIXED, sizeof(WAVEFORMATEX)+cbExtraAlloc)) == NULL) 
                { 
                nError = ER_MEM; 
                goto ERROR_READING_WAVE; 
                } 

        // Copy the bytes from the pcm structure to the waveformatex structure 
        memcpy(*ppwfxInfo, &pcmWaveFormat, sizeof(pcmWaveFormat)); 
        (*ppwfxInfo)->cbSize = cbExtraAlloc; 

        // Now, read those extra bytes into the structure, if cbExtraAlloc != 0. 
        if (cbExtraAlloc != 0) 
                { 
                if (mmioRead(hmmioIn, (LPSTR) (((BYTE*)&((*ppwfxInfo)->cbSize))+sizeof(cbExtraAlloc)), 
                        (long) (cbExtraAlloc)) != (long) (cbExtraAlloc)) 
                        { 
                        nError = ER_NOTWAVEFILE; 
                        goto ERROR_READING_WAVE; 
                        } 
                } 

        /* Ascend the input file out of the 'fmt ' chunk. */                                                             
        if ((nError = mmioAscend(hmmioIn, &ckIn, 0)) != 0) 
                { 
                goto ERROR_READING_WAVE; 

                } 
     

        goto TEMPCLEANUP;                

ERROR_READING_WAVE: 
        if (*ppwfxInfo != NULL) 
                { 
                GlobalFree(*ppwfxInfo); 
                *ppwfxInfo = NULL; 
                }                

        if (hmmioIn != NULL) 
        { 
        mmioClose(hmmioIn, 0); 
                hmmioIn = NULL; 
                } 
     
TEMPCLEANUP: 
        *phmmioIn = hmmioIn; 

        return(nError); 

} 

/*      This routine has to be called before WaveReadFile as it searchs for the chunk to descend into for 
        reading, that is, the 'data' chunk.  For simplicity, this used to be in the open routine, but was 
        taken out and moved to a separate routine so there was more control on the chunks that are before 
        the data chunk, such as 'fact', etc... */ 

int WaveStartDataRead( 
                                        HMMIO *phmmioIn, 
                                        MMCKINFO *pckIn, 
                                        MMCKINFO *pckInRIFF 
                                        ) 
{ 
        int                     nError; 

        nError = 0; 
     
        // Do a nice little seek... 
        if ((nError = mmioSeek(*phmmioIn, pckInRIFF->dwDataOffset + sizeof(FOURCC), SEEK_SET)) == -1) 
                { 
                DNASSERT(FALSE); 
                } 

        nError = 0; 
        //      Search the input file for for the 'data' chunk. 
        pckIn->ckid = mmioFOURCC('d', 'a', 't', 'a'); 
        if ((nError = mmioDescend(*phmmioIn, pckIn, pckInRIFF, MMIO_FINDCHUNK)) != 0) 
                { 
                goto ERROR_READING_WAVE; 
                } 

        goto CLEANUP; 

ERROR_READING_WAVE: 

CLEANUP:         
        return(nError); 
} 


/*      This will read wave data from the wave file.  Makre sure we're descended into 
        the data chunk, else this will fail bigtime! 
        hmmioIn         - Handle to mmio. 
        cbRead          - # of bytes to read.    
        pbDest          - Destination buffer to put bytes. 
        cbActualRead- # of bytes actually read. 

             

*/ 


int WaveReadFile( 
                HMMIO hmmioIn,                          // IN 
                UINT cbRead,                            // IN            
                BYTE *pbDest,                           // IN 
                MMCKINFO *pckIn,                        // IN. 
                UINT *cbActualRead                      // OUT. 
             
                ) 
{ 

        MMIOINFO    mmioinfoIn;         // current status of <hmmioIn> 
        int                     nError; 
        UINT                    cT, cbDataIn, uCopyLength; 

        nError = 0; 

        if (nError = mmioGetInfo(hmmioIn, &mmioinfoIn, 0) != 0) 
                { 
                goto ERROR_CANNOT_READ; 
                } 
                             
        cbDataIn = cbRead; 
        if (cbDataIn > pckIn->cksize)  
                cbDataIn = pckIn->cksize;        

        pckIn->cksize -= cbDataIn; 
     
        for (cT = 0; cT < cbDataIn; ) 
                { 
                /* Copy the bytes from the io to the buffer. */ 
                if (mmioinfoIn.pchNext == mmioinfoIn.pchEndRead) 
                        { 
            if ((nError = mmioAdvance(hmmioIn, &mmioinfoIn, MMIO_READ)) != 0) 
                                { 
                goto ERROR_CANNOT_READ; 
                                }  
            if (mmioinfoIn.pchNext == mmioinfoIn.pchEndRead) 
                                { 
                                nError = ER_CORRUPTWAVEFILE; 
                goto ERROR_CANNOT_READ; 
                                } 
                        } 
                     
                // Actual copy. 
                uCopyLength = (UINT)(mmioinfoIn.pchEndRead - mmioinfoIn.pchNext); 
                if((cbDataIn - cT) < uCopyLength ) 
                        uCopyLength = cbDataIn - cT; 
                memcpy( (BYTE*)(pbDest+cT), (BYTE*)mmioinfoIn.pchNext, uCopyLength ); 
                cT += uCopyLength; 
                mmioinfoIn.pchNext += uCopyLength; 
                } 

        if ((nError = mmioSetInfo(hmmioIn, &mmioinfoIn, 0)) != 0) 
                { 
                goto ERROR_CANNOT_READ; 
                } 

        *cbActualRead = cbDataIn; 
        goto FINISHED_READING; 

ERROR_CANNOT_READ: 
        *cbActualRead = 0; 

FINISHED_READING: 
        return(nError); 

} 

/*      This will close the wave file openned with WaveOpenFile.   
        phmmioIn - Pointer to the handle to input MMIO. 
        ppwfxSrc - Pointer to pointer to WaveFormatEx structure. 

        Returns 0 if successful, non-zero if there was a warning. 

*/ 
int WaveCloseReadFile( 
                        HMMIO *phmmio,                                  // IN 
                        WAVEFORMATEX **ppwfxSrc                 // IN 
                        ) 
{ 

        if (*ppwfxSrc != NULL) 
                { 
                GlobalFree(*ppwfxSrc); 
                *ppwfxSrc = NULL; 
                } 

        if (*phmmio != NULL) 
                { 
                mmioClose(*phmmio, 0); 
                *phmmio = NULL; 
                } 

        return(0); 

} 

/*      This routine will create a wave file for writing.  This will automatically overwrite any 
        existing file with the same name, so be careful and check before hand!!! 
        pszFileName     - Pointer to filename to write. 
        phmmioOut               - Pointer to HMMIO handle that is used for further writes 
        pwfxDest                - Valid waveformatex destination structure. 
        pckOut                  - Pointer to be set with the MMCKINFO. 
        pckOutRIFF              - Pointer to be set with the RIFF info. 

*/ 
int WaveCreateFile( 
                        const char *pszFileName,                              // (IN) 
                        HMMIO *phmmioOut,                               // (OUT) 
                        WAVEFORMATEX *pwfxDest,                 // (IN) 
                        MMCKINFO *pckOut,                               // (OUT) 
                        MMCKINFO *pckOutRIFF                    // (OUT) 

                        ) 
{ 
         
        int             nError;                         // Return value. 
        DWORD           dwFactChunk;            // Contains the actual fact chunk. Garbage until WaveCloseWriteFile. 
        MMCKINFO        ckOut1; 

        dwFactChunk = (DWORD)-1; 
        nError = 0; 

        char tmpFileName[_MAX_PATH];

        strcpy( tmpFileName, pszFileName );

        *phmmioOut = mmioOpen(tmpFileName, NULL, 
                        MMIO_ALLOCBUF | MMIO_READWRITE|MMIO_CREATE); 

    if (*phmmioOut == NULL) 
                { 
                nError = ER_CANNOTWRITE; 
        goto ERROR_CANNOT_WRITE;    // cannot save WAVE file 
                } 

    /* Create the output file RIFF chunk of form type 'WAVE'. 
     */ 
    pckOutRIFF->fccType = mmioFOURCC('W', 'A', 'V', 'E');        
        pckOutRIFF->cksize = 0;  
    if ((nError = mmioCreateChunk(*phmmioOut, pckOutRIFF, MMIO_CREATERIFF)) != 0) 
                { 
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably 
                } 

    /* We are now descended into the 'RIFF' chunk we just created. 
     * Now create the 'fmt ' chunk. Since we know the size of this chunk, 
     * specify it in the MMCKINFO structure so MMIO doesn't have to seek 
     * back and set the chunk size after ascending from the chunk. 
     */ 
    pckOut->ckid = mmioFOURCC('f', 'm', 't', ' '); 
    pckOut->cksize = sizeof(PCMWAVEFORMAT);   // we know the size of this ck. 
    if ((nError = mmioCreateChunk(*phmmioOut, pckOut, 0)) != 0) 
                { 
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably 
                } 

    /* Write the PCMWAVEFORMAT structure to the 'fmt ' chunk if its that type. */ 
    if (pwfxDest->wFormatTag == WAVE_FORMAT_PCM) 
                { 
            if (mmioWrite(*phmmioOut, (HPSTR) pwfxDest, sizeof(PCMWAVEFORMAT)) 
                != sizeof(PCMWAVEFORMAT)) 
                        { 
                        nError = ER_CANNOTWRITE; 
                goto ERROR_CANNOT_WRITE;    // cannot write file, probably 
                        } 
                } 
     
        else  
                { 
                // Write the variable length size. 
                if ((UINT)mmioWrite(*phmmioOut, (HPSTR) pwfxDest, sizeof(*pwfxDest)+pwfxDest->cbSize) 
                != (sizeof(*pwfxDest)+pwfxDest->cbSize)) 
                        { 
                        nError = ER_CANNOTWRITE; 
                goto ERROR_CANNOT_WRITE;    // cannot write file, probably 
                        }  

                }   

    /* Ascend out of the 'fmt ' chunk, back into the 'RIFF' chunk. 
     */ 
    if ((nError = mmioAscend(*phmmioOut, pckOut, 0)) != 0) 
                { 
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably 
                } 

        // Now create the fact chunk, not required for PCM but nice to have.  This is filled 
        // in when the close routine is called. 
        ckOut1.ckid = mmioFOURCC('f', 'a', 'c', 't'); 
        ckOut1.cksize = 0; 
    if ((nError = mmioCreateChunk(*phmmioOut, &ckOut1, 0)) != 0) 
                { 
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably 
                } 

        if (mmioWrite(*phmmioOut, (HPSTR)&dwFactChunk, sizeof(dwFactChunk)) != sizeof(dwFactChunk)) 
                { 
                nError = ER_CANNOTWRITE; 
                goto ERROR_CANNOT_WRITE; 
                } 

        // Now ascend out of the fact chunk... 
    if ((nError = mmioAscend(*phmmioOut, &ckOut1, 0)) != 0) 
                { 
        nError = ER_CANNOTWRITE;        // cannot write file, probably 
                goto ERROR_CANNOT_WRITE; 
                } 

      

        goto DONE_CREATE; 

ERROR_CANNOT_WRITE: 
        // Maybe delete the half-written file?  Ah forget it for now, its good to leave the 
        // file there for debugging... 

DONE_CREATE: 
        return(nError); 

} 

/*      This routine has to be called before any data is written to the wave output file, via wavewritefile.  This 
        sets up the data to write, and creates the data chunk. 
*/ 

int WaveStartDataWrite( 
                                HMMIO *phmmioOut,                               // (IN) 
                                MMCKINFO *pckOut,                               // (IN) 
                                MMIOINFO *pmmioinfoOut                  // (OUT) 
                                ) 
{ 

        int             nError; 

        nError = 0; 
 /* Create the 'data' chunk that holds the waveform samples.  */ 
    pckOut->ckid = mmioFOURCC('d', 'a', 't', 'a'); 
        pckOut->cksize = 0; 
    if ((nError = mmioCreateChunk(*phmmioOut, pckOut, 0)) != 0) 
                { 
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably 
                } 

        if ((nError = mmioGetInfo(*phmmioOut, pmmioinfoOut, 0)) != 0) 
                { 
        goto ERROR_CANNOT_WRITE; 
        } 

        goto CLEANUP; 
ERROR_CANNOT_WRITE:      

CLEANUP: 
        return(nError); 
} 

/* This routine will write out data to a wave file.  
        hmmioOut                - Handle to hmmioOut filled by WaveCreateFile 
        cbWrite                 - # of bytes to write out. 
        pbSrc                   - Pointer to source. 
        pckOut                  - pointer to ckOut filled by WaveCreateFile 
        cbActualWrite   - # of actual bytes written. 
        pmmioinfoOut    - Pointer to mmioinfoOut filled by WaveCreateFile. 

        Returns 0 if successful, else the error code. 

 */ 


int WaveWriteFile( 
                HMMIO hmmioOut,                         // (IN) 
                UINT cbWrite,                           // (IN) 
                BYTE *pbSrc,                            // (IN) 
                MMCKINFO *pckOut,                       // (IN) 
                UINT *cbActualWrite,            // (OUT) 
                MMIOINFO *pmmioinfoOut          // (IN) 
                ) 
{ 
             
     
        int                     nError; 
        UINT            cT; 

        nError = 0; 
     
        *cbActualWrite = 0; 

        for (cT=0; cT < cbWrite; cT++) 
                {        
                if (pmmioinfoOut->pchNext == pmmioinfoOut->pchEndWrite) 
                { 
                pmmioinfoOut->dwFlags |= MMIO_DIRTY; 
                if ((nError = mmioAdvance(hmmioOut, pmmioinfoOut, MMIO_WRITE)) != 0) 
                                { 
                    goto ERROR_CANNOT_WRITE; 
                                } 
                } 

                *((BYTE *) pmmioinfoOut->pchNext) = *((BYTE*)pbSrc+cT);
                pmmioinfoOut->pchNext++;
                (*cbActualWrite)++;

                /* *((BYTE*)pmmioinfoOut->pchNext)++ = *((BYTE*)pbSrc+cT); 
                (*cbActualWrite)++;  */
/*

                pmmioinfoOut->pchNext++;



                //*((BYTE *) pmmioinfoOut->pchNext)++;
                *((BYTE*)pmmioinfoOut->pchNext)++;
                *((BYTE*)pmmioinfoOut->pchNext) = *((BYTE*)pbSrc+cT); 
                (*cbActualWrite)++;  */
                } 
     
     
ERROR_CANNOT_WRITE: 
        // What to do here?  Well, for now, nothing, just return that error.  (maybe delete the 
        // file later? 

        return(nError); 

} 



/*      This routine will close a wave file used for writing.  Returns 0 if successful, else 
        the error code. 
        phmmioOut       - Pointer to mmio handle for saving. 
        pckOut          - Pointer to the MMCKINFO for saving. 
        pckOutRiff      - Pointer to the riff MMCKINFO for saving. 
        pmmioinfoOut- Pointer to mmioinfo for saving. 
        cSamples        - # of samples saved, for the fact chunk.  For PCM, this isn't used but 
                                  will be written anyway, so this can be zero as long as programs ignore 
                                  this field when they load PCM formats. 



*/ 
int WaveCloseWriteFile( 
                        HMMIO *phmmioOut,               // (IN) 
                        MMCKINFO *pckOut,               // (IN) 
                        MMCKINFO *pckOutRIFF,   // (IN) 
                        MMIOINFO *pmmioinfoOut, // (IN) 
                        DWORD cSamples                  // (IN) 
                        ) 
{ 
             
        int                     nError;                          
                                                             
        nError = 0; 

        if (*phmmioOut == NULL) 
                return(0); 

        pmmioinfoOut->dwFlags |= MMIO_DIRTY; 
    if ((nError = mmioSetInfo(*phmmioOut, pmmioinfoOut, 0)) != 0) 
                { 
                // cannot flush, probably... 
        goto ERROR_CANNOT_WRITE;                                 
                } 

         /* Ascend the output file out of the 'data' chunk -- this will cause 
     * the chunk size of the 'data' chunk to be written. 
     */ 
    if ((nError = mmioAscend(*phmmioOut, pckOut, 0)) != 0) 
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably 


        // Do this here instead... 
        if ((nError = mmioAscend(*phmmioOut, pckOutRIFF, 0)) != 0) 
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably 


        nError = mmioSeek(*phmmioOut, 0, SEEK_SET); 
        if ((nError = (int)mmioDescend(*phmmioOut, pckOutRIFF, NULL, 0)) != 0) 
                { 
                goto ERROR_CANNOT_WRITE; 
                } 

        nError = 0; 
        pckOut->ckid = mmioFOURCC('f', 'a', 'c', 't'); 
        if ((nError = mmioDescend(*phmmioOut, pckOut, pckOutRIFF, MMIO_FINDCHUNK)) == 0) 
                { 
                // If it didn't fail, write the fact chunk out, if it failed, not critical, just 
                // assert (below). 
            nError = mmioWrite(*phmmioOut, (HPSTR)&cSamples, sizeof(DWORD)); 
                nError = mmioAscend(*phmmioOut, pckOut, 0);  
                nError = 0; 
                } 
        else  
                { 
                nError = 0; 
                DNASSERT(FALSE); 
                } 

// CANTWRITEFACT: 
    /* Ascend the output file out of the 'RIFF' chunk -- this will cause 
     * the chunk size of the 'RIFF' chunk to be written. 
     */ 
    if ((nError = mmioAscend(*phmmioOut, pckOutRIFF, 0)) != 0) 
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably 
     
     

ERROR_CANNOT_WRITE: 
        if (*phmmioOut != NULL) 
                { 
        mmioClose(*phmmioOut, 0); 
                *phmmioOut = NULL; 
                } 

        return(nError); 

} 

/*      This routine will copy from a source wave file to a destination wave file all those useless chunks 
        (well, the ones useless to conversions, etc --> apparently people use them!).  The source will be 
        seeked to the begining, but the destination has to be at a current pointer to put the new chunks. 
        This will also seek     back to the start of the wave riff header at the end of the routine. 

        phmmioIn                - Pointer to input mmio file handle. 
        pckIn                   - Pointer to a nice ckIn to use. 
        pckInRiff               - Pointer to the main riff. 
        phmmioOut               - Pointer to output mmio file handle. 
        pckOut                  - Pointer to nice ckOut to use. 
        pckOutRiff              - Pointer to the main riff. 


        Returns 0 if successful, else the error code.  If this routine fails, it still attemps to seek back to 
        the start of the wave riff header, though this too could be unsuccessful. 
*/ 

int WaveCopyUselessChunks( 
                                        HMMIO *phmmioIn,  
                                        MMCKINFO *pckIn,  
                                        MMCKINFO *pckInRiff,  
                                        HMMIO *phmmioOut,  
                                        MMCKINFO *pckOut,  
                                        MMCKINFO *pckOutRiff) 
{ 

        int                             nError; 

        nError = 0; 
        // First seek to the stinking start of the file, not including the riff header... 
        if ((nError = mmioSeek(*phmmioIn, pckInRiff->dwDataOffset + sizeof(FOURCC), SEEK_SET)) == -1) 
                { 
                nError = ER_CANNOTREAD; 
                goto ERROR_IN_PROC; 
                } 

        nError = 0;                      

    while (mmioDescend(*phmmioIn, pckIn, pckInRiff, 0) == 0) 
    { 
     
        //  quickly check for corrupt RIFF file--don't ascend past end!         
        if ((pckIn->dwDataOffset + pckIn->cksize) > (pckInRiff->dwDataOffset + pckInRiff->cksize)) 
            goto ERROR_IN_PROC; 

        switch (pckIn->ckid) 
        {                    
            //  explicitly skip these...             
            case mmioFOURCC('f', 'm', 't', ' '): 
                break; 

            case mmioFOURCC('d', 'a', 't', 'a'): 
                break; 

            case mmioFOURCC('f', 'a', 'c', 't'): 
                break; 

            case mmioFOURCC('J', 'U', 'N', 'K'): 
                break; 

            case mmioFOURCC('P', 'A', 'D', ' '): 
                break; 

            case mmioFOURCC('c', 'u', 'e', ' '): 
                break;                                                   
         
            //  copy chunks that are OK to copy             
            case mmioFOURCC('p', 'l', 's', 't'): 
                // although without the 'cue' chunk, it doesn't make much sense 
                riffCopyChunk(*phmmioIn, *phmmioOut, pckIn); 
                break; 

            case mmioFOURCC('D', 'I', 'S', 'P'): 
                riffCopyChunk(*phmmioIn, *phmmioOut, pckIn); 
                break; 

             
            //  don't copy unknown chunks 
            default: 
                break; 
        } 

     
        //  step up to prepare for next chunk..         
        mmioAscend(*phmmioIn, pckIn, 0); 
    } 

ERROR_IN_PROC:   
        { 
        int nErrorT; 
        // Seek back to riff header      
        nErrorT = mmioSeek(*phmmioIn, pckInRiff->dwDataOffset + sizeof(FOURCC), SEEK_SET); 
        } 

        return(nError); 
} 

/** BOOL RIFFAPI riffCopyChunk(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck) 
 * 
 *  DESCRIPTION: 
 *       
 * 
 *  ARGUMENTS: 
 *      (LPWAVECONVCB lpwc, LPMMCKINFO lpck) 
 * 
 *  RETURN (BOOL NEAR PASCAL): 
 * 
 * 
 *  NOTES: 
 * 
 **  */ 






/*      This routine loads a full wave file into memory.  Be careful, wave files can get 
        pretty big these days :).   
        szFileName      -       sz Filename 
        cbSize          -       Size of loaded wave (returned) 
        cSamples        -       # of samples loaded. 
        ppwfxInfo       -       Pointer to pointer to waveformatex structure.  The wfx structure 
                                        IS ALLOCATED by this routine!  Make sure to free it! 
        ppbData         -       Pointer to a byte pointer (globalalloc) which is allocated by this  
                                        routine.  Make sure to free it! 

        Returns 0 if successful, else the error code. 
*/ 

int WaveLoadFile( 
                        const char *pszFileName,                      // (IN) 
                        UINT *cbSize,                           // (OUT) 
                        DWORD *pcSamples,                       // (OUT) 
                        WAVEFORMATEX **ppwfxInfo,       // (OUT) 
                        BYTE **ppbData                          // (OUT) 
                        ) 
{ 

        HMMIO                           hmmioIn;         
        MMCKINFO                        ckInRiff; 
        MMCKINFO                        ckIn; 
        int                                     nError; 
        UINT                            cbActualRead; 

        *ppbData = NULL; 
        *ppwfxInfo = NULL; 
        *cbSize = 0; 
     
        if ((nError = WaveOpenFile(pszFileName, &hmmioIn, ppwfxInfo, &ckInRiff)) != 0) 
                { 
                goto ERROR_LOADING; 
                } 

        if ((nError = WaveStartDataRead(&hmmioIn, &ckIn, &ckInRiff)) != 0) 
                { 
                goto ERROR_LOADING; 
                } 

        // Ok, size of wave data is in ckIn, allocate that buffer. 
        if ((*ppbData = (BYTE *)GlobalAlloc(GMEM_FIXED, ckIn.cksize)) == NULL) 
                { 
                nError = ER_MEM; 
                goto ERROR_LOADING; 
                } 

        if ((nError = WaveReadFile(hmmioIn, ckIn.cksize, *ppbData, &ckIn, &cbActualRead)) != 0) 

                { 
                goto ERROR_LOADING; 
                }         
     
        *cbSize = cbActualRead; 
        goto DONE_LOADING; 

ERROR_LOADING: 
        if (*ppbData != NULL) 
                { 
                GlobalFree(*ppbData); 
                *ppbData = NULL; 
                } 
        if (*ppwfxInfo != NULL) 
                { 
                GlobalFree(*ppwfxInfo); 
                *ppwfxInfo = NULL; 
                } 
                     
DONE_LOADING: 
        // Close the wave file.  
        if (hmmioIn != NULL) 
                { 
                mmioClose(hmmioIn, 0); 
                hmmioIn = NULL; 
                } 

        return(nError); 

} 

/*      This routine saves a wave file in currently in memory. 
        pszFileName -   FileName to save to.  Automatically overwritten, be careful! 
        cbSize          -       Size in bytes to write. 
        cSamples        -       # of samples to write, used to make the fact chunk. (if !PCM) 
        pwfxDest        -       Pointer to waveformatex structure. 
        pbData          -       Pointer to the data. 
*/       

int WaveSaveFile( 
                                const char *pszFileName,                      // (IN) 
                                UINT cbSize,                            // (IN) 
                                DWORD cSamples,                         // (IN)  
                                WAVEFORMATEX *pwfxDest,         // (IN) 
                                BYTE *pbData                            // (IN) 
                                ) 
{ 

        HMMIO           hmmioOut; 
        MMCKINFO        ckOut; 
        MMCKINFO        ckOutRIFF; 
        MMIOINFO        mmioinfoOut; 
        UINT            cbActualWrite; 
        int                     nError; 

        if ((nError = WaveCreateFile(pszFileName, &hmmioOut, pwfxDest, &ckOut, &ckOutRIFF)) != 0) 
                { 
                goto ERROR_SAVING; 
                } 

        if ((nError = WaveStartDataWrite(&hmmioOut, &ckOut, &mmioinfoOut)) != 0) 
                { 
                goto ERROR_SAVING; 
                } 

        if ((nError = WaveWriteFile(hmmioOut, cbSize, pbData, &ckOut, &cbActualWrite, &mmioinfoOut)) != 0) 
                { 
                goto ERROR_SAVING; 
                } 
     
        if ((nError = WaveCloseWriteFile(&hmmioOut, &ckOut, &ckOutRIFF, &mmioinfoOut, cSamples)) != 0) 
                { 
                goto ERROR_SAVING; 
                }        

ERROR_SAVING: 
     
        return(nError);          

} 

BOOL riffCopyChunk(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck) { 
    MMCKINFO    ck;     
    HPSTR       hpBuf;      //     //     // 
    hpBuf = (HPSTR)GlobalAllocPtr(GHND, lpck->cksize);     
    if (!hpBuf) 
        return (FALSE);      
    ck.ckid   = lpck->ckid; 
    ck.cksize = lpck->cksize;     
    if (mmioCreateChunk(hmmioDst, &ck, 0)) 
        goto rscc_Error;          
    if (mmioRead(hmmioSrc, hpBuf, lpck->cksize) != (LONG)lpck->cksize) 
        goto rscc_Error;  
    if (mmioWrite(hmmioDst, hpBuf, lpck->cksize) != (LONG)lpck->cksize) 
        goto rscc_Error;      
    if (mmioAscend(hmmioDst, &ck, 0)) 
        goto rscc_Error;      
    if (hpBuf)         
        GlobalFreePtr(hpBuf);  
    return (TRUE);  
rscc_Error:      
    if (hpBuf)         
        GlobalFreePtr(hpBuf);  
    return (FALSE); 
} /* RIFFSupCopyChunk() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\wavformat.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wavformat.h
 *  Content:
 *		This module contains the CWaveFormat class which is used to work with
 *		WAVEFORMATEX structures.  
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/00		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __WAVFORMAT_H
#define __WAVFORMAT_H

/////////////////////////////////////////////////////////////////////
//
// CWaveFormat
//
// Used to store and manipulate WAVEFORMATEX structures.
//
class CWaveFormat
{
public:

	CWaveFormat(): m_pwfxFormat(NULL), m_fOwned(FALSE) {};
	~CWaveFormat() { Cleanup(); };

	// Initialize with full parameters
	HRESULT Initialize( WORD wFormatTag, DWORD nSamplesPerSec, WORD nChannels, WORD wBitsPerSample, 
		                WORD nBlockAlign, DWORD nAvgBytesPerSec, WORD cbSize, void *pvExtra );

	// Initialize and copy the specified format
	HRESULT InitializeCPY( LPWAVEFORMATEX pwfxFormat, void *pvExtra );

	// Build a standard PCM format
	HRESULT InitializePCM( WORD wHZ, BOOL fStereo, BYTE bBitsPerSample );

	// Create a WAVEFORMAT that is of size dwSize
	HRESULT InitializeMEM( DWORD dwSize );

	// Initialize but unowned
	HRESULT InitializeUSE( WAVEFORMATEX *pwfxFormat );

	// Initialize from registry 
	HRESULT InitializeREG( HKEY hKeyRoot, const WCHAR *wszPath );

	// Set this object equal to the parameter
	HRESULT SetEqual( CWaveFormat *pwfxFormat );

	// Are these two types equal?
	BOOL IsEqual( CWaveFormat *pwfxFormat );

	// Return a pointer to the format
	inline WAVEFORMATEX *GetFormat() { return m_pwfxFormat; };

	inline WAVEFORMATEX *Disconnect() { m_fOwned = FALSE; return GetFormat(); };

	// Is this an eight bit waveformat?
	inline BOOL IsEightBit() { return (m_pwfxFormat->wBitsPerSample==8); };

	// Write the contained value to the registry
	HRESULT WriteREG( HKEY hKeyRoot, const WCHAR *wszPath );

protected:

	void Cleanup();

	WAVEFORMATEX	*m_pwfxFormat;
	BOOL			m_fOwned;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\dsplays.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dsplays.h
 *  Content:	Definition of the CDirectSoundPlaybackSubSystem class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll Updated to allow creation with a GUID
 *
 ***************************************************************************/

#ifndef __DIRECTSOUNDPLAYBACKSUBSYSTEM_H
#define __DIRECTSOUNDPLAYBACKSUBSYSTEM_H

#include "aplays.h"
#include <map>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

#include <map>

// CDirectSoundPlaybackSubSystem
//
// This class provides an implementation of the CAudioPlaybackSubSystem
// interface for the DirectSound sub-system.
//
// The purpose of this class is to be used as a factory for 
// creation of objects supporting the CAudioPlaybackDevice interface
// for DirectSound devices.  It is also used by the CAudioPLaybackSystem
// to check for DirectSound support on the system and get information
// about the available devices through directsound.
//
// This class is not usually instantiated directly, usually the user
// queries the CAudioPlaybackDevice for the DirectSound sub-system
// which returns one of these objects.
//
// When created it enumerates the available directsound devices 
// and allows users to ask it for information about those devices.
//
// It is also responsible for mapping from ARDID's to DirectSound
// device identifiers.
//
class CDirectSoundPlaybackSubSystem: public CAudioPlaybackSubSystem
{
public:
    CDirectSoundPlaybackSubSystem();
    ~CDirectSoundPlaybackSubSystem();

public:
    bool IsValidDevice( ARDID deviceID );
    CAudioPlaybackDevice *CreateDevice( ARDID deviceID );
    CAudioPlaybackDevice *CreateDevice( LPGUID lpGuid );
    bool GetDeviceInfo( ARDID deviceID, ARDeviceInfo &device );
    unsigned int GetNumDevices();

    const TCHAR *GetSubSystemName();

	// Handy typedefs
    typedef std::map<ARDID,ARDeviceInfo *> DeviceMap;
    typedef std::map<ARDID,GUID> DSMap;
    typedef DeviceMap::iterator DeviceMapIterator;
    typedef DSMap::iterator DSMapIterator;

protected:

    void CleanupDeviceMap();

    DeviceMap	m_deviceMap;	// Map ARDID <--> ARDeviceInfo *
    DSMap		m_dsMap;		// Map ARDID <--> GUID's
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\dsplays.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dsplays.cpp
 *  Content:
 *		This module contains the implementation of the 
 *		CDirectSoundPlaybackSubSystem.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated to allow creation with a GUID
 * 09/20/99		rodtoll	Added memory allocation failure checks 
 * 10/05/99		rodtoll	Added DPF_MODNAMEs         
 *
 ***************************************************************************/

#include "stdafx.h"
#include "dsplays.h"
#include "dsplayd.h"
#include "dsutils.h"
#include "dndbg.h"
#include "OSInd.h"

// DSCEnumParam
//
// This structure is used when enumerating the available DirectSound
// Devices.  The enumeration function adds to the maps this structure points
// to.
//
struct DSEnumParam
{
    CDirectSoundPlaybackSubSystem::DSMap *m_dsMap;
    CDirectSoundPlaybackSubSystem::DeviceMap *m_deviceMap;
    ARDID m_nextID;
};

#undef DPF_MODNAME
#define DPF_MODNAME "DSSSEnum"
// DSSSEnum
//
// This function is used to enumerate the available DirectSound devices
// in a system.  It fills the device map with a list of information about the 
// available devices in the DirectSound subsystem.  It is also responsible for
// assigning ARDID's to individual devices.  
//
// Parameters / Return Values:
// See documentation for DirectSoundEnumerate
// 
BOOL CALLBACK DSSSEnum(
    LPGUID lpGUID, 
    LPCTSTR lpszDesc,
    LPCTSTR lpszDrvName, 
    LPVOID lpContext 
) {
	// Ignore the default device, it's always there
    if( lpGUID == NULL )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL,  "DSSSEnum: Ignore default" );
        return TRUE;
    }
    
	// Ignore entries with NULL descriptions or driver
	// names
    if( lpszDesc == NULL || lpszDrvName == NULL )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL,  "DSSSEnum: Ignoring invalid" );
        return TRUE;
    }

    DSEnumParam *params = (DSEnumParam *) lpContext;

	// Create and fill the device info for this device
    ARDeviceInfo *info = new ARDeviceInfo;    
    ARDID aID;

    if( info == NULL )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure for new device record" );
    	return TRUE;
    }

    info->m_deviceName = lpszDesc;
    info->m_emulated   = false;

	// Assign device the next ARDID
    aID = params->m_nextID;

    std::pair<const ARDID,ARDeviceInfo *> devicePair(aID,info);
    std::pair<const ARDID,GUID> dsPair(aID,*lpGUID);

	// Add the device to the device map
    params->m_deviceMap->insert( devicePair );
    params->m_dsMap->insert( dsPair );

	// Increment the ARDID so next device gets next id
    params->m_nextID++;

    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackSubSystem::CDirectSoundPlaybackSubSystem"
// CDirectSoundPlaybackSubSystem
//
// This is the constructor for the CDirectSoundPlaybackSubSystem 
// object.  It is responsible for building the list of available 
// devices for the DirectSound sub-system as well as determining
// if DirectSound is available on the system.  If DirectSound
// is not available on the system the object's valid flag will be marked
// as false.  The DirectSound subsystem is also considered to be
// invalid if there are no available devices.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CDirectSoundPlaybackSubSystem::CDirectSoundPlaybackSubSystem(): CAudioPlaybackSubSystem()
{
    DSEnumParam param;

    param.m_dsMap = &m_dsMap;
    param.m_deviceMap = &m_deviceMap;
    param.m_nextID = 0;

	// Enumerate the available devices
    try
    {
        DSCHECK( DirectSoundEnumerate( DSSSEnum, &param ) );
    }
    catch( DirectSoundException &dse )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL,  "DSSS: Unable to list" );
        DPFX(DPFPREP,  DVF_ERRORLEVEL, dse.what() );
        CleanupDeviceMap();
        m_valid = false;
        return;
    }

	// Mark as invalid if there are no devices
    if( GetNumDevices() == 0 )
    {
        m_valid = false;
        return;
    }

    m_valid = true;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackSubSystem::CleanupDeviceMap"
// CleanupDeviceMap
//
// This is a utility function, responsible for cleaning up the
// memory in the device map contained in this object.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
void CDirectSoundPlaybackSubSystem::CleanupDeviceMap()
{
    DeviceMapIterator deviceIterator;

    deviceIterator = m_deviceMap.begin();

    while( deviceIterator != m_deviceMap.end() )
    {
        delete (*deviceIterator).second;
        deviceIterator++;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackSubSystem::~CDirectSoundPlaybackSubSystem"
// CDirectSoundPlaybackSubSystem Destructor
//
// This is the destructor for the CDirectSoundPlaybackSubSystem
// class.  It cleans up the memory used by the device map.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CDirectSoundPlaybackSubSystem::~CDirectSoundPlaybackSubSystem()
{
    CleanupDeviceMap();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackSubSystem::IsValidDevice"
// IsValidDevice
//
// This function allows the user to query this object to determine
// if the specified ARDID is valid for this subsystem.  If it is,
// the function returns true, otherwise it returns false.
//
// Parameters:
// ARDID deviceID - 
//		The ARDID for the device you wish to check for.
//
// Returns:
// bool -
//		Returns true if the device is available in this subsystem
//
bool CDirectSoundPlaybackSubSystem::IsValidDevice( ARDID deviceID )
{
    DeviceMapIterator deviceIterator;

    deviceIterator = m_deviceMap.begin();

    if( deviceIterator != m_deviceMap.end() )
    {
        return true;
    }
    else
    {
        return false;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackSubSystem::CreateDevice"
// CreateDevice
//
// This function acts as a class factory, creating CDirectSoundPlaybackDevice
// objects for devices.  It allocates and constructs with the appropriate
// parameters the object and then returns a CAudioPlaybackDevice pointer
// to the new object.  The created object is now owned by the caller of the
// function and must be destroyed BEFORE destroying the subsystem object.
//
// Parameters:
// ARDID deviceID -
//		Specifies the device the user wishes to create an object for.
//
// Returns:
// CAudioPlaybackDevice * -
//		A CAudioPLaybackDevice pointer to a newly created CDirectSoundPlaybackDevice
//		object representing the specified device.  If the device ID is not valid
//      for this subsystem NULL is returned.
//
CAudioPlaybackDevice *CDirectSoundPlaybackSubSystem::CreateDevice( ARDID deviceID )
{
	// If the device is valid, create an object
    if( IsValidDevice( deviceID ) )
    {
        DeviceMapIterator deviceIterator;
        DSMapIterator dsIterator;
        GUID tmpGUID;

		// Find the device information structure and the
		// GUID of the device to create in the device map
        deviceIterator = m_deviceMap.find( deviceID );
        dsIterator = m_dsMap.find( deviceID );

        BFC_ASSERT(  deviceIterator != m_deviceMap.end() );
        BFC_ASSERT(  dsIterator != m_dsMap.end() );

        tmpGUID = (*dsIterator).second;

		// Construct the object
        return new CDirectSoundPlaybackDevice( tmpGUID, deviceID, false, this );
    }
	// If the device is not valid, return NULL
    else
    {
        return NULL;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackSubSystem::GetDeviceInfo"
// GetDeviceInfo
//
// This function fills the specified structure with information about the device
// specified in the deviceID parameter, if it is valid for this subsystem.  If it
// is not valid for this subsystem then the function returns false.
//
// Parameters:
// ARDID deviceID - 
//		The device for which we wish to retrieve information
//
// ARDeviceInfo &device -
//		The structure to fill with details about the device
//
// Returns:
// bool -
//		true if the device is valid and the device structure has been filled with
//      the details, false if the device is not valid.
//
bool CDirectSoundPlaybackSubSystem::GetDeviceInfo( ARDID deviceID, ARDeviceInfo &device )
{
    DeviceMapIterator deviceIterator;

    deviceIterator = m_deviceMap.find(deviceID);

    if( deviceIterator != m_deviceMap.end() )
    {
        device = *((*deviceIterator).second);
        return true;
    }
    else
    {
        return false;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackSubSystem::GetNumDevices"
// GetNumDevices
//
// This function returns the number of devices supported by this playback subsystem.
//
// Parameters:
// N/A
//
// Returns:
// unsigned int - The number of devices supported by this subsystem.
//
unsigned int CDirectSoundPlaybackSubSystem::GetNumDevices()
{
    return m_deviceMap.size();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackSubSystem::GetSubSystemName"
// GetSubSystemName
//
// This function returns a string describing the type of playback subsystem
// implemented by this object.  In this case it always returns
// "DirectSound".
//
// Parameters:
// N/A
//
// Returns:
// const TCHAR * - "DirectSound"
//
const TCHAR *CDirectSoundPlaybackSubSystem::GetSubSystemName()
{
    return _T("DirectSound");
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackSubSystem::CreateDevice"
CAudioPlaybackDevice *CDirectSoundPlaybackSubSystem::CreateDevice( LPGUID lpGUID )
{
	if( lpGUID == NULL )
	{
		return CreateDevice( (ARDID) 0 );
	}

	DSMapIterator dsIterator = m_dsMap.begin();

	while( dsIterator != m_dsMap.end() )
	{	
		if( (*dsIterator).second == *lpGUID ) 
		{
			return CreateDevice( (*dsIterator).first );
		}

		dsIterator++;
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\dstrwave.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dstrwave.h
 *  Content:	wave file functions - lifted from MSDN
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __DSTRWAVE_H
#define __DSTRWAVE_H

#define ER_CANNOTOPEN   -1
#define ER_NOTWAVEFILE  -1
#define ER_CANNOTREAD   -1
#define ER_MEM          -1
#define ER_CORRUPTWAVEFILE  -1
#define ER_CANNOTWRITE  -1

/* This function will open a wave input file and prepare it for reading, 
 * so the data can be easily 
 * read with WaveReadFile. Returns 0 if successful, the error code if not. 
 *      pszFileName - Input filename to load. 
 *      phmmioIn    - Pointer to handle which will be used 
 *          for further mmio routines. 
 *      ppwfxInfo   - Ptr to ptr to WaveFormatEx structure 
 *          with all info about the file.                         
 *       
*/ 
int WaveOpenFile( 
        const char *pszFileName,                              // (IN) 
        HMMIO *phmmioIn,                                // (OUT) 
        WAVEFORMATEX **ppwfxInfo,                       // (OUT) 
        MMCKINFO *pckInRIFF                             // (OUT) 
);

/*      This routine has to be called before WaveReadFile as it searchs for the chunk to descend into for 
        reading, that is, the 'data' chunk.  For simplicity, this used to be in the open routine, but was 
        taken out and moved to a separate routine so there was more control on the chunks that are before 
        the data chunk, such as 'fact', etc... */ 

int WaveStartDataRead( 
                                        HMMIO *phmmioIn, 
                                        MMCKINFO *pckIn, 
                                        MMCKINFO *pckInRIFF 
);

int WaveReadFile( 
                HMMIO hmmioIn,                          // IN 
                UINT cbRead,                            // IN            
                BYTE *pbDest,                           // IN 
                MMCKINFO *pckIn,                        // IN. 
                UINT *cbActualRead                      // OUT. 
                 
                ); 
/*      This will close the wave file openned with WaveOpenFile.   
        phmmioIn - Pointer to the handle to input MMIO. 
        ppwfxSrc - Pointer to pointer to WaveFormatEx structure. 
 
        Returns 0 if successful, non-zero if there was a warning. 
 
*/ 
int WaveCloseReadFile( 
                        HMMIO *phmmio,                                  // IN 
                        WAVEFORMATEX **ppwfxSrc                 // IN 
                        );
 
/*      This routine will create a wave file for writing.  This will automatically overwrite any 
        existing file with the same name, so be careful and check before hand!!! 
        pszFileName     - Pointer to filename to write. 
        phmmioOut               - Pointer to HMMIO handle that is used for further writes 
        pwfxDest                - Valid waveformatex destination structure. 
        pckOut                  - Pointer to be set with the MMCKINFO. 
        pckOutRIFF              - Pointer to be set with the RIFF info. 
 
*/ 
int WaveCreateFile( 
                        const char *pszFileName,                              // (IN) 
                        HMMIO *phmmioOut,                               // (OUT) 
                        WAVEFORMATEX *pwfxDest,                 // (IN) 
                        MMCKINFO *pckOut,                               // (OUT) 
                        MMCKINFO *pckOutRIFF                    // (OUT) 
 
                        ); 
 
/*      This routine has to be called before any data is written to the wave output file, via wavewritefile.  This 
        sets up the data to write, and creates the data chunk. 
*/ 
 
int WaveStartDataWrite( 
                                HMMIO *phmmioOut,                               // (IN) 
                                MMCKINFO *pckOut,                               // (IN) 
                                MMIOINFO *pmmioinfoOut                  // (OUT) 
                                );
 
/* This routine will write out data to a wave file.  
        hmmioOut                - Handle to hmmioOut filled by WaveCreateFile 
        cbWrite                 - # of bytes to write out. 
        pbSrc                   - Pointer to source. 
        pckOut                  - pointer to ckOut filled by WaveCreateFile 
        cbActualWrite   - # of actual bytes written. 
        pmmioinfoOut    - Pointer to mmioinfoOut filled by WaveCreateFile. 
 
        Returns 0 if successful, else the error code. 
 
 */ 
 
 
int WaveWriteFile( 
                HMMIO hmmioOut,                         // (IN) 
                UINT cbWrite,                           // (IN) 
                BYTE *pbSrc,                            // (IN) 
                MMCKINFO *pckOut,                       // (IN) 
                UINT *cbActualWrite,            // (OUT) 
                MMIOINFO *pmmioinfoOut          // (IN) 
                );
 
/*      This routine will close a wave file used for writing.  Returns 0 if successful, else 
        the error code. 
        phmmioOut       - Pointer to mmio handle for saving. 
        pckOut          - Pointer to the MMCKINFO for saving. 
        pckOutRiff      - Pointer to the riff MMCKINFO for saving. 
        pmmioinfoOut- Pointer to mmioinfo for saving. 
        cSamples        - # of samples saved, for the fact chunk.  For PCM, this isn't used but 
                                  will be written anyway, so this can be zero as long as programs ignore 
                                  this field when they load PCM formats. 
 
 
 
*/ 
int WaveCloseWriteFile( 
                        HMMIO *phmmioOut,               // (IN) 
                        MMCKINFO *pckOut,               // (IN) 
                        MMCKINFO *pckOutRIFF,   // (IN) 
                        MMIOINFO *pmmioinfoOut, // (IN) 
                        DWORD cSamples                  // (IN) 
                        );
 
/*      This routine will copy from a source wave file to a destination wave file all those useless chunks 
        (well, the ones useless to conversions, etc --> apparently people use them!).  The source will be 
        seeked to the begining, but the destination has to be at a current pointer to put the new chunks. 
        This will also seek     back to the start of the wave riff header at the end of the routine. 
 
        phmmioIn                - Pointer to input mmio file handle. 
        pckIn                   - Pointer to a nice ckIn to use. 
        pckInRiff               - Pointer to the main riff. 
        phmmioOut               - Pointer to output mmio file handle. 
        pckOut                  - Pointer to nice ckOut to use. 
        pckOutRiff              - Pointer to the main riff. 
 
 
        Returns 0 if successful, else the error code.  If this routine fails, it still attemps to seek back to 
        the start of the wave riff header, though this too could be unsuccessful. 
*/ 
 
int WaveCopyUselessChunks( 
                                        HMMIO *phmmioIn,  
                                        MMCKINFO *pckIn,  
                                        MMCKINFO *pckInRiff,  
                                        HMMIO *phmmioOut,  
                                        MMCKINFO *pckOut,  
                                        MMCKINFO *pckOutRiff);
 
/*      This routine loads a full wave file into memory.  Be careful, wave files can get 
        pretty big these days :).   
        szFileName      -       sz Filename 
        cbSize          -       Size of loaded wave (returned) 
        cSamples        -       # of samples loaded. 
        ppwfxInfo       -       Pointer to pointer to waveformatex structure.  The wfx structure 
                                        IS ALLOCATED by this routine!  Make sure to free it! 
        ppbData         -       Pointer to a byte pointer (globalalloc) which is allocated by this  
                                        routine.  Make sure to free it! 
 
        Returns 0 if successful, else the error code. 
*/ 
 
int WaveLoadFile( 
                        const char *pszFileName,                      // (IN) 
                        UINT *cbSize,                           // (OUT) 
                        DWORD *pcSamples,                       // (OUT) 
                        WAVEFORMATEX **ppwfxInfo,       // (OUT) 
                        BYTE **ppbData                          // (OUT) 
                        );
 
int WaveSaveFile( 
                                const char *pszFileName,                      // (IN) 
                                UINT cbSize,                            // (IN) 
                                DWORD cSamples,                         // (IN)  
                                WAVEFORMATEX *pwfxDest,         // (IN) 
                                BYTE *pbData                            // (IN) 
                                );


BOOL riffCopyChunk(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\micutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		micutils.h
 *  Content:	declaration of the mic utility functions
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/04/99		rodtoll	Modified to use DSound volumes
 *
 ***************************************************************************/

#ifndef __MICROPHONEUTILS_H
#define __MICROPHONEUTILS_H

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

bool MicrophoneClearMute( UINT deviceID );
bool MicrophoneSelect( UINT deviceID );
bool MicrophoneSetVolume( UINT waveInDevice, LONG volume );
bool MicrophoneGetVolume( UINT waveInDevice, LONG &volume );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\micutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		micutils.cpp
 *  Content:
 *		This module contains utility functions for working with the 
 *		microphone recording line in windows.
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/03/99		rodtoll	Modified to use dsound range on volume funcs
 * 09/20/99		rodtoll	Added checks for memory allocation failures 
 * 10/05/99		rodtoll Added DPF_MODNAMEs
 * 12/01/99		rodtoll NO LONGER USED
 *
 ***************************************************************************/

#include "stdafx.h"
#include "micutils.h"
#include "wiutils.h"
#include "dndbg.h"
#include "dsound.h"
#include "OSInd.h"
#include "decibels.h"

#define MODULE_ID	MICROPHONEUTILS

// These functions were adapted from routines in the Microsoft 
// Developer Network, Visual C++ 6.0 Edition
//
// PRB: No Signal is Recorded When Using MCI or waveInxxx APIs
// Last reviewed: November 22, 1996
// Article ID: Q159753  

#undef DPF_MODNAME
#define DPF_MODNAME "MicrophoneClearMute"
// MicrophoneClearMute
//
// This function clears the mute attribute on the playback line from
// the microphone.  
//
// Parameters:
// UINT deviceID - 
//		The waveIN device ID for the device to clear the mutes for.
//
// Returns:
// bool - 
//		true on succes, false on failure
//
bool MicrophoneClearMute( UINT deviceID )
{
    MIXERLINE mixerLine;
    MIXERCONTROL mixerControl;
    MIXERLINECONTROLS mixerLineControls;
    MIXERCONTROLDETAILS controlDetails;
    MIXERCONTROLDETAILS_BOOLEAN micrMuteDetails;

    MMRESULT result;

    HMIXER hmx = NULL;

    try 
    {
        WAVEINCHECK( mixerOpen(&hmx, deviceID, 0, 0, MIXER_OBJECTF_WAVEIN) );

        mixerLine.cbStruct = sizeof( MIXERLINE );
        mixerLine.dwComponentType = MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE;

        if( (result = mixerGetLineInfo( (HMIXEROBJ) hmx, &mixerLine, MIXER_GETLINEINFOF_COMPONENTTYPE )) == MMSYSERR_NOERROR  )
        {
            mixerLineControls.dwLineID = mixerLine.dwLineID;
            mixerLineControls.cbStruct = sizeof( MIXERLINECONTROLS );
            mixerLineControls.cbmxctrl = sizeof( MIXERCONTROL );
            mixerLineControls.pamxctrl = &mixerControl;
            mixerLineControls.dwControlType = MIXERCONTROL_CONTROLTYPE_MUTE;

            mixerControl.cbStruct = sizeof( MIXERCONTROL );
            mixerControl.dwControlType = 0;

            WAVEINCHECK( mixerGetLineControls( (HMIXEROBJ) hmx, &mixerLineControls, MIXER_GETLINECONTROLSF_ONEBYTYPE ) );

            controlDetails.cbStruct = sizeof( MIXERCONTROLDETAILS );
            controlDetails.cbDetails = sizeof( MIXERCONTROLDETAILS_UNSIGNED );
            controlDetails.paDetails = &micrMuteDetails;
            controlDetails.cChannels = mixerLine.cChannels;
            controlDetails.dwControlID = mixerControl.dwControlID;
            controlDetails.cMultipleItems = 0;

            WAVEINCHECK( mixerGetControlDetails( (HMIXEROBJ) hmx, &controlDetails, 0 ) );

            micrMuteDetails.fValue = 0;

            WAVEINCHECK( mixerSetControlDetails( (HMIXEROBJ) hmx, &controlDetails, 0 ) );

            return true;
        }
        else
        {
            WAVEINCHECK( result );
            return false;
        }
    }
    catch( WaveInException &wie )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, wie.what() );

        if( hmx != NULL )
        {
            mixerClose( hmx );
        }

        return false;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicrophoneGetVolume"
// MicrophoneGetVolume
//
// This function retrieves the current volume of the microphone
// recording line.  
//
// Parameters:
// UINT waveInDevice -
//		This specifies the device for which we wish to get 
//      the microphone recording volume.  This is the 
//      waveIN device ID for the desired device.
//
// BYTE &volume -
//		[output] The current volume of the microphone recording
//               line for the specified device.  (DSound Range)
//
// BOOL -
//		true on success, false on failure
//
bool MicrophoneGetVolume( UINT waveInDevice, LONG &volume ) { 

    MMRESULT result;

   // Open the mixer device
   HMIXER hmx = NULL;
   LPMIXERCONTROLDETAILS_UNSIGNED pUnsigned = NULL;
   LPMIXERCONTROL pmxctrl = NULL;

   bool foundMicrophone = false;
   int i;

   try 
   {
       WAVEINCHECK( mixerOpen(&hmx, waveInDevice, 0, 0, MIXER_OBJECTF_WAVEIN) );

       // Get the line info for the wave in destination line
       MIXERLINE mxl;
       mxl.cbStruct = sizeof(mxl);
       mxl.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;
       mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_COMPONENTTYPE); 

       // Now find the microphone source line connected to this wave in
       // destination
       DWORD cConnections = mxl.cConnections;

       for(i=0; i<cConnections; i++)
       {
          mxl.dwSource = i;
          mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE);
          if (MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE == mxl.dwComponentType)
          {
             foundMicrophone = true;
             break;
          }
       }

        if( !foundMicrophone )
        {
            for(i=0; i<cConnections; i++)
            {
               mxl.dwSource = i;
               WAVEINCHECK( mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE) );
               if (MIXERLINE_COMPONENTTYPE_SRC_LINE == mxl.dwComponentType)
               {
                  foundMicrophone = true;
                  break;
               }
            }   
    
            if( !foundMicrophone )
            {
                for(i=0; i<cConnections; i++)
                {
                   mxl.dwSource = i;
                   WAVEINCHECK( mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE) );
                   if (MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY == mxl.dwComponentType)
                   {
                      foundMicrophone = true;
                      break;
                   }
                }   
            }
        }

        if( !foundMicrophone )
        {
            DPFX(DPFPREP,  DVF_INFOLEVEL, "ERROR: Unable to find microphone source" );
            return false;
        }

       // Find a volume control, if any, of the microphone line
       pmxctrl = new MIXERCONTROL;

       if( pmxctrl == NULL )
       {
       		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to alloc mixercontrol" );
       		return false;
       	}

       MIXERLINECONTROLS mxlctrl = {
           sizeof(mxlctrl), mxl.dwLineID, MIXERCONTROL_CONTROLTYPE_VOLUME, 
           1, sizeof(MIXERCONTROL), pmxctrl 
       };

       if( (result = mixerGetLineControls((HMIXEROBJ) hmx, &mxlctrl, MIXER_GETLINECONTROLSF_ONEBYTYPE)) == MMSYSERR_NOERROR )
       { 
          // Found!
          DWORD cChannels = mxl.cChannels;

          if (MIXERCONTROL_CONTROLF_UNIFORM & pmxctrl->fdwControl)
             cChannels = 1;

          pUnsigned = new MIXERCONTROLDETAILS_UNSIGNED[cChannels];

          if( pUnsigned == NULL )
          {
	          	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to alloc unsigneds" );
	          	delete pmxctrl;
	          	return false;
	      }

          MIXERCONTROLDETAILS mxcd = {
              sizeof(mxcd), pmxctrl->dwControlID, 
              cChannels, (HWND)0, sizeof(MIXERCONTROLDETAILS_UNSIGNED), 
              (LPVOID) pUnsigned
          };

          WAVEINCHECK( mixerGetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_GETCONTROLDETAILSF_VALUE) );

          volume = AmpFactorToDB( pUnsigned[0].dwValue );

          WAVEINCHECK( mixerSetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE) ); 

          WAVEINCHECK( mixerClose(hmx) );

          delete pmxctrl;
          delete [] pUnsigned;

          return true;
       }
       else
       {
          WAVEINCHECK( result );
          return false;
       }
   }
   catch( WaveInException &wie )
   {
       DPFX(DPFPREP,  DVF_ERRORLEVEL, wie.what() );

       if( hmx != NULL )
       {
           mixerClose( hmx );
       }

       delete pmxctrl;
       delete [] pUnsigned;
       return false;
   }

} 

#undef DPF_MODNAME
#define DPF_MODNAME "MicrophoneSetVolume"
// MicrophoneSetVolume
//
// This function sets the volume of the microphone recording
// line for the specified device. 
//
// Parameters:
// UINT waveInDevice -
//		The waveIN device ID for the device you wish to set
//		the volume on.
//
// BYTE volume -
//		The volume to set the device to.  (0-100)
//
// Returns:
// BOOL -
//		true on success, false on failure
//
bool MicrophoneSetVolume( UINT waveInDevice, LONG volume ) { 

    MMRESULT result;

    bool foundMicrophone = false;
    int i;

    // Open the mixer device
    HMIXER hmx = NULL;
    LPMIXERCONTROL pmxctrl = NULL;
    LPMIXERCONTROLDETAILS_UNSIGNED pUnsigned = NULL;

    try
    {
		DPFX(DPFPREP,  DVF_INFOLEVEL, "OPEN %i\n", waveInDevice );

        WAVEINCHECK( mixerOpen(&hmx, waveInDevice, 0, 0, MIXER_OBJECTF_WAVEIN) );

		DPFX(DPFPREP,  DVF_INFOLEVEL, "OPENED %i\n", waveInDevice );

        // Get the line info for the wave in destination line
        MIXERLINE mxl;

        mxl.cbStruct = sizeof(mxl);
        mxl.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;
        WAVEINCHECK( mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_COMPONENTTYPE) ); 
        // Now find the microphone source line connected to this wave in
        // destination
        DWORD cConnections = mxl.cConnections;

        for(i=0; i<cConnections; i++)
        {
           mxl.dwSource = i;
           WAVEINCHECK( mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE) );
           if (MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE == mxl.dwComponentType)
           {
              foundMicrophone = true;
              break;
           }
        }

        if( !foundMicrophone )
        {
            for(i=0; i<cConnections; i++)
            {
               mxl.dwSource = i;
               WAVEINCHECK( mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE) );
               if (MIXERLINE_COMPONENTTYPE_SRC_LINE == mxl.dwComponentType)
               {
                  foundMicrophone = true;
                  break;
               }
            }   
            
            if( !foundMicrophone )
            {
                for(i=0; i<cConnections; i++)
                {
                   mxl.dwSource = i;
                   WAVEINCHECK( mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE) );
                   if (MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY == mxl.dwComponentType)
                   {
                      foundMicrophone = true;
                      break;
                   }
                }   
            }
        }

        if( !foundMicrophone )
        {
            DPFX(DPFPREP,  DVF_INFOLEVEL, "ERROR: Unable to find microphone source" );
            return false;
        }

        // Find a volume control, if any, of the microphone line
        pmxctrl = new MIXERCONTROL;

        if( pmxctrl == NULL )
        {
        	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to alloc mixercontrol" );
        	return false;
        }

        MIXERLINECONTROLS mxlctrl = {
           sizeof(mxlctrl), mxl.dwLineID, MIXERCONTROL_CONTROLTYPE_VOLUME, 
           1, sizeof(MIXERCONTROL), pmxctrl 
        };

       if( (result = mixerGetLineControls((HMIXEROBJ) hmx, &mxlctrl, MIXER_GETLINECONTROLSF_ONEBYTYPE)) == MMSYSERR_NOERROR)
       { 
          // Found!
          DWORD cChannels = mxl.cChannels;

          if (MIXERCONTROL_CONTROLF_UNIFORM & pmxctrl->fdwControl)
             cChannels = 1;

          pUnsigned = new MIXERCONTROLDETAILS_UNSIGNED[cChannels];

          if( pUnsigned == NULL )
          {
          		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to alloc mixercondetails" );
          		delete pmxctrl;
          		return false;
          }

          MIXERCONTROLDETAILS mxcd = {
              sizeof(mxcd), pmxctrl->dwControlID, 
              cChannels, (HWND)0, sizeof(MIXERCONTROLDETAILS_UNSIGNED), 
              (LPVOID) pUnsigned
          };

          WAVEINCHECK( mixerGetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE) ); 

          // Set the volume to the middle  (for both channels as needed)
          pUnsigned[0].dwValue = pUnsigned[cChannels-1].dwValue = DBToAmpFactor( volume );

          WAVEINCHECK( mixerSetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE) );

          delete pmxctrl;
          delete [] pUnsigned;
          mixerClose(hmx);
          return true;
       }
       else
       {
           WAVEINCHECK( result );
           return false;
       }
    }
    catch( WaveInException &wie )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, wie.what() );
        DPFX(DPFPREP,  DVF_INFOLEVEL, "Error Setting Recording Volume" );

        delete pmxctrl;
        delete [] pUnsigned;
        mixerClose(hmx);
        return false;
    }
} 

#undef DPF_MODNAME
#define DPF_MODNAME "MicrophoneSelect"
// MicrophoneSelect
//
// This function selects the microphone line for recording on the 
// specified device.  
//
// NOTE:
// This function has a bug, as on some older cards (Ensoniq 
// ViVo this selects the line in instead of the microphone).
// The same effect has been noticed on some Sonic Impact cards.
//
// Parameters:
// UINT deviceID -
//		The waveIN deviceID for the desired device
//
// Returns:
// BOOL - 
//		true on success, false on failure
//
bool MicrophoneSelect( UINT deviceID ) { 

   // Open the mixer device
   HMIXER hmx = NULL;
   LPMIXERCONTROL pmxctrl = NULL;
   LPMIXERCONTROLDETAILS_BOOLEAN plistbool = NULL;
   LPMIXERCONTROLDETAILS_LISTTEXT plisttext = NULL;

   try
   {
       WAVEINCHECK( mixerOpen(&hmx, deviceID, 0, 0, MIXER_OBJECTF_WAVEIN) );

       // Get the line info for the wave in destination line
       MIXERLINE mixerLine;

       mixerLine.cbStruct = sizeof(MIXERLINE);
       mixerLine.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;

       WAVEINCHECK( mixerGetLineInfo((HMIXEROBJ)hmx, &mixerLine, MIXER_GETLINEINFOF_COMPONENTTYPE) );

       // Find a LIST control, if any, for the wave in line
       pmxctrl = new MIXERCONTROL[mixerLine.cControls]; 

       if( pmxctrl == NULL )
       {
       		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to create mixercontrols" );
       		return false;
       }

       MIXERLINECONTROLS mxlctrl = {
           sizeof(mxlctrl), mixerLine.dwLineID, 0,
           mixerLine.cControls, sizeof(MIXERCONTROL), pmxctrl
       };

       WAVEINCHECK( mixerGetLineControls((HMIXEROBJ) hmx, &mxlctrl, MIXER_GETLINECONTROLSF_ALL) );

       // Now walk through each control to find a type of LIST control. This
       // can be either Mux, Single-select, Mixer or Multiple-select.
       DWORD i;

       for(i=0; i < mixerLine.cControls; i++)
       {
          // Found a LIST control
          // Check if the LIST control is a Mux or Single-select type
          BOOL bOneItemOnly = false;

          switch (pmxctrl[i].dwControlType) {
          case MIXERCONTROL_CONTROLTYPE_MUX:
          case MIXERCONTROL_CONTROLTYPE_SINGLESELECT:
              bOneItemOnly = true;
          }

          DWORD cChannels = mixerLine.cChannels, cMultipleItems = 0;

          if (MIXERCONTROL_CONTROLF_UNIFORM & pmxctrl[i].fdwControl)
             cChannels = 1;

          if (MIXERCONTROL_CONTROLF_MULTIPLE & pmxctrl[i].fdwControl)
             cMultipleItems = pmxctrl[i].cMultipleItems;

          // Get the text description of each item
          plisttext = new MIXERCONTROLDETAILS_LISTTEXT[(cChannels * cMultipleItems)]; 

          if( plisttext == NULL )
          {
          		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to create details" );
          		delete [] pmxctrl;
          		return false;
          }

          MIXERCONTROLDETAILS mxcd = {
              sizeof(mxcd), pmxctrl[i].dwControlID,
              cChannels, (HWND)cMultipleItems, sizeof(MIXERCONTROLDETAILS_LISTTEXT),
              (LPVOID) plisttext
          }; 

          WAVEINCHECK( mixerGetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_GETCONTROLDETAILSF_LISTTEXT) );

          // Now get the value for each item
          plistbool = new MIXERCONTROLDETAILS_BOOLEAN[(cChannels * cMultipleItems)]; 

          if( plistbool == NULL )
          {
          		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to create details bool" );
          		delete [] pmxctrl;
          		delete [] plisttext;
          		return false;
          }
          
          mxcd.cbStruct = sizeof(MIXERCONTROLDETAILS);
          mxcd.dwControlID = pmxctrl[i].dwControlID;
          mxcd.cChannels = cChannels;
          mxcd.cMultipleItems = cMultipleItems;
          mxcd.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
          mxcd.paDetails = plistbool;

          WAVEINCHECK( mixerGetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_GETCONTROLDETAILSF_VALUE) );

          // Select the "Microphone" item
          for (DWORD j=0; j<cMultipleItems; j = j + cChannels)
          {
             if (0 == strcmp(plisttext[j].szName, "Microphone"))
             {
                // Select it for both left and right channels
                plistbool[j].fValue = plistbool[j+ cChannels - 1].fValue = 1;
             }
             else if (bOneItemOnly)
             {
                // Mux or Single-select allows only one item to be selected
                // so clear other items as necessary
                plistbool[j].fValue = plistbool[j+ cChannels - 1].fValue = 0;
             }
          } 

          // Now actually set the new values in
          WAVEINCHECK( mixerSetControlDetails( (HMIXEROBJ) hmx, (LPMIXERCONTROLDETAILS) &mxcd, MIXER_SETCONTROLDETAILSF_VALUE ) );

          delete pmxctrl;
          delete [] plisttext;
          delete [] plistbool;
          mixerClose(hmx);
          return true;
      }

   }
   catch( WaveInException &wie )
   {
       DPFX(DPFPREP,  DVF_ERRORLEVEL, wie.what()  );
       DPFX(DPFPREP,  DVF_INFOLEVEL, "Error Selecting Recording Device" );

       if( hmx != NULL )
       {
           mixerClose( hmx );
       }

       delete pmxctrl;
       delete [] plisttext;
       delete [] plistbool;

       return false;
   }
   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\sassert.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		sassert.h
 *  Content:	Exception based inline assert function, SAssert
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 *
 ***************************************************************************/

//
// This file contains the exception based assert inline function
// described by Stroustrup in section 24.3.7.2 of "The C++ Programming
// Language, 3rd Edition".  
//

#ifndef _SASSERT_H_
#define _SASSERT_H_

#include <string>
#include "BFCTypes.h"

template<class X, class A> inline void SAssert(A assertion)
{
	if (!assertion) throw X();
}

template<class A, class E> inline void SAssert(A assertion, E except)
{
	if (!assertion) throw except;
}

// This is a little inline funtion to build a string with the
// current file and line information, plus an optional message.
// It's meant to be called from the FLM() macro.
inline BFC_STRING _flm_(const unsigned int moduleID, 
					int iLine, const TCHAR *szMsg) throw()
{
	try
	{
		// itoa stuffs at most 17 bytes, add some padding for peace of mind
		TCHAR szTemp[25];
        BFC_STRING module(_itoa(moduleID,szTemp,10));
  	    BFC_STRING sColon(": ");
		BFC_STRING sLine(_itoa(iLine, szTemp, 10));
		BFC_STRING sMsg(szMsg);

		BFC_STRING sOut = module + sColon + sLine + sColon + sMsg;
		return sOut;
	}
	catch (...)
	{
		return _T("");
	}
}

// This macro is designed to be used to generate a string message
// to pass to exception class constructors.  It uses _flm_ to generate
// a string containing the current file, the current line, and a 
// user supplied message.
#define FLM(szMsg) _flm_(0, __LINE__, szMsg)

// This macro is the same as FLM, except that it does not accept a 
// message parameter, so the string generated has only file and line info
// plus a generic "assert failed" message
#define FL FLM(_T("SAssert() failed"))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\wirecb.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wirecb.cpp
 *  Content:
 *		This module contains the implementation of the CWaveInRecordBuffer
 *		class.  
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/04/99		rodtoll	Created
 * 11/18/99		rodtoll	Fixed bug which causes lockup when stopping a buffer then 
 *				 		restarting it.
 * 11/23/99		rodtoll	Added SelectMicrophone call to the interface 
 * 12/01/99		rodtoll	Bug #115783 - Always adjusts default device.
 *						Added support for new mixerline class which supports
 *						proper selection of devices/adjusting of volumes 
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						- Added hwndOwner param for capture focus support
 *						- Added lpfLostFocus param to GetCurrentPosition so upper 
 *						  layers can detect lost focus.
 * 01/14/2000	rodtoll	Updated to use DWORD_PTR to allow proper 64-bit operation  
 * 01/28/2000	rodtoll	Bug #130465: Record Mute/Unmute must call YieldFocus() / ClaimFocus() 
 *
 ***************************************************************************/

#include "stdafx.h"
#include "wirecd.h"
#include "dndbg.h"
#include "OSInd.h"
#include "wirecb.h"
#include "dvoice.h"
#include "micutils.h"

#define WAVEIN_STARTLATENCY		2

#define WIFAILED( x )  (x != MMSYSERR_NOERROR)

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::GetStartupLatency"
DWORD CWaveInRecordBuffer::GetStartupLatency()
{
	return WAVEIN_STARTLATENCY;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::CWaveInRecordBuffer"
CWaveInRecordBuffer::CWaveInRecordBuffer(
): CAudioRecordBuffer(), m_hwiDevice(NULL), m_uDeviceID(0), m_dwCurrentPosition(0),
   m_lpWaveHeaders(NULL), m_dwBufferSize(0), m_dwNumBuffers(0), m_dwFrameSize(0),
   m_fRecording(FALSE), m_lpbShadowBuffer(NULL), m_dwShadowStart(0), 
   m_hFrameProcessed(NULL), m_lpwfxRecordFormat(NULL),
   m_fStopping( FALSE )
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::~CWaveInRecordBuffer"
CWaveInRecordBuffer::~CWaveInRecordBuffer()
{
	// Stop the buffers and unprepare them if they are prepared
	Stop();
	
	if( m_dwNumBuffers )
	{
		for( DWORD dwIndex = 0; dwIndex < m_dwNumBuffers; dwIndex++ )
		{
			delete [] ((LPBYTE) m_lpWaveHeaders[dwIndex].lpData);
		}

		delete [] m_lpWaveHeaders;
	}

	// Close the device
	if( m_hwiDevice != NULL )
	{
		waveInClose( m_hwiDevice );
	}
	
	if( m_lpbShadowBuffer != NULL )
	{
		delete [] m_lpbShadowBuffer;
	}

	CloseHandle( m_hFrameProcessed );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::Initialize"
HRESULT CWaveInRecordBuffer::Initialize( UINT uDeviceID, LPDSCBUFFERDESC lpdscDesc, DWORD dwFrameSize )
{
	HRESULT hr;
	DWORD dwIndex;

	m_hFrameProcessed = CreateEvent( NULL, FALSE, FALSE, NULL );

	if( m_hFrameProcessed == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create event" );
		return DVERR_GENERIC;
	}

	hr = m_mixerLine.Initialize( uDeviceID );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to acquire volume controls" );
		return hr;
	}		

	hr = waveInOpen( &m_hwiDevice, uDeviceID, lpdscDesc->lpwfxFormat, (DWORD_PTR) WaveInHandler, (DWORD_PTR) this, CALLBACK_FUNCTION ) ; 

	if( WIFAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to open waveIn Device (mmresult) hr=0x%x", hr );
		return DVERR_RECORDSYSTEMERROR;
	}

	m_dwNumBuffers = lpdscDesc->dwBufferBytes / dwFrameSize;	

	m_lpWaveHeaders = new WAVEHDR[m_dwNumBuffers];

	if( m_lpWaveHeaders == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		hr = DVERR_OUTOFMEMORY;

		goto INITIALIZE_ERROR;
	}

	for( dwIndex = 0; dwIndex < m_dwNumBuffers; dwIndex++ )
	{
		m_lpWaveHeaders[dwIndex].lpData = (LPSTR) new BYTE[dwFrameSize];

		if( m_lpWaveHeaders[dwIndex].lpData == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );

			// Make sure rest of buffer pointers are NULL;
			for( ; dwIndex < m_dwNumBuffers; dwIndex++ )
			{
				m_lpWaveHeaders[dwIndex].lpData = NULL;
			}

			hr = DVERR_OUTOFMEMORY;

			goto INITIALIZE_ERROR;
		}

		if( lpdscDesc->lpwfxFormat->wBitsPerSample == 8  )
		{
			memset( m_lpWaveHeaders[dwIndex].lpData, 0x80, dwFrameSize );
		}
		else
		{
			memset( m_lpWaveHeaders[dwIndex].lpData, 0x00, dwFrameSize );		
		}

		m_lpWaveHeaders[dwIndex].dwBufferLength = dwFrameSize;
		m_lpWaveHeaders[dwIndex].dwBytesRecorded = 0;

		// Used to specify buffer location when this buffer is complete
		if( dwIndex == (m_dwNumBuffers-1))
		{
			m_lpWaveHeaders[dwIndex].dwUser = 0;
		}
		else
		{
			m_lpWaveHeaders[dwIndex].dwUser = dwFrameSize*(dwIndex+1);		
		}
		
		m_lpWaveHeaders[dwIndex].dwFlags = 0; 
		m_lpWaveHeaders[dwIndex].dwLoops = 0;
		m_lpWaveHeaders[dwIndex].lpNext = NULL;
		m_lpWaveHeaders[dwIndex].reserved = 0;
	}

	m_lpbShadowBuffer = new BYTE[lpdscDesc->dwBufferBytes];

	m_lpwfxRecordFormat = lpdscDesc->lpwfxFormat;
	m_uDeviceID = uDeviceID;
	m_dwFrameSize = dwFrameSize;
	m_dwCurrentPosition = 0;
	m_dwBufferSize = lpdscDesc->dwBufferBytes;
	m_fRecording = FALSE;

	return DV_OK;

INITIALIZE_ERROR:

	if( m_lpbShadowBuffer != NULL )
	{
		delete [] m_lpbShadowBuffer;
		m_lpbShadowBuffer = NULL;
	}

	if( m_lpWaveHeaders != NULL )
	{
		for( dwIndex = 0; dwIndex < m_dwNumBuffers; dwIndex++ )
		{
			if( m_lpWaveHeaders[dwIndex].lpData != NULL )
			{
				delete [] ((LPBYTE) m_lpWaveHeaders[dwIndex].lpData);
			}
		}

		delete [] m_lpWaveHeaders;
		m_lpWaveHeaders = NULL;
	}

	if( m_hwiDevice != NULL )
	{
		waveInClose( m_hwiDevice );
		m_hwiDevice = NULL;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::WaveInHandler"
void CWaveInRecordBuffer::WaveInHandler( HWAVEIN hwi, UINT uMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2 )
{
	CWaveInRecordBuffer *This = (CWaveInRecordBuffer *) dwInstance;
	
	DNASSERT( This != NULL );

	HRESULT hr;

	DPFX(DPFPREP,  DVF_INFOLEVEL, "WaveInHandler: Wakeup" );
	
	if( uMsg == WIM_DATA && !This->m_fStopping)
	{
		WAVEHDR *lpWaveHeader = (WAVEHDR *) dwParam1;

		hr = waveInUnprepareHeader( This->m_hwiDevice, lpWaveHeader, sizeof( WAVEHDR ) );

		if( WIFAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error unpreparing header (mmresult) hr=0x%x", hr );
			return;
		}
		else
		{
			DPFX(DPFPREP,  DVF_INFOLEVEL, "WaveInHandler: Unpreparing for location: %d", lpWaveHeader->dwUser );
		}

		This->m_dwCurrentPosition = lpWaveHeader->dwUser;

		if( !This->m_fRecording )
		{
			SetEvent( This->m_hFrameProcessed );
			DPFX(DPFPREP,  DVF_INFOLEVEL, "WaveInHandler: Signalling single frame done" );
		}
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::Lock"
HRESULT CWaveInRecordBuffer::Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lplpvBuffer1, LPDWORD lpdwSize1, LPVOID *lplpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags )
{
	*lpdwSize2 = 0;
	*lplpvBuffer2 = NULL;

	// Special case for the entire buffer
	if( dwFlags & DSCBLOCK_ENTIREBUFFER )
	{
		if( m_fRecording )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot lock entire buffer while recording!" );
			return DVERR_GENERIC;
		}
		
		*lplpvBuffer1 = m_lpbShadowBuffer;
		*lpdwSize1 = m_dwBufferSize;
		m_dwShadowStart = 0;
		
		return DV_OK;
	}

	if( dwWriteBytes % m_dwFrameSize != 0 )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Can only lock block aligned sizes" );
		return DVERR_GENERIC;
	}

	// We're working with a shadow buffer
	if( dwWriteBytes > m_dwFrameSize )
	{
		*lplpvBuffer1 = m_lpbShadowBuffer;
		*lpdwSize1 = dwWriteBytes;
		m_dwShadowStart = dwWriteCursor;

		return DV_OK;
	}

	// We're doing a plain old lock of a buffer.  When we do the unlock we'll commit the buffer
	m_dwShadowStart = dwWriteCursor / m_dwFrameSize;

	*lpdwSize1 = m_dwFrameSize;
	*lplpvBuffer1 = m_lpWaveHeaders[m_dwShadowStart].lpData;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::UnLock"
HRESULT CWaveInRecordBuffer::UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 )
{
	HRESULT hr;
	// We used the shadow buffer, we're writing across multiple buffers.
	//
	// We don't commit the buffers to the sound device because this is always used for 
	// setting silence into the buffers
	if( dwSize1 > m_dwFrameSize )
	{
		DWORD dwCurrentBuffer = m_dwShadowStart / m_dwFrameSize;
		LPBYTE lpCurrentShadowLoc = m_lpbShadowBuffer;

		for( DWORD dwIndex = 0; dwIndex < (dwSize1 / m_dwFrameSize); dwIndex++ )
		{
			memcpy( m_lpWaveHeaders[dwCurrentBuffer].lpData , lpCurrentShadowLoc, m_dwFrameSize );

			lpCurrentShadowLoc += m_dwFrameSize;
			dwCurrentBuffer++;

			dwCurrentBuffer %= m_dwNumBuffers;
		}

		return DV_OK;
	}

	// We got just one buffer and we're now ready to commit it to the device

	m_lpWaveHeaders[m_dwShadowStart].dwFlags = 0;

	hr = waveInPrepareHeader( m_hwiDevice, &m_lpWaveHeaders[m_dwShadowStart], sizeof( WAVEHDR ) );

	if( WIFAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to prepare the header for output to the sound device (mmresult) hr = 0x%x", hr );
		return DVERR_RECORDSYSTEMERROR;
	}

	hr = waveInAddBuffer( m_hwiDevice, &m_lpWaveHeaders[m_dwShadowStart], sizeof( WAVEHDR ) );

	if( WIFAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to write the buffer (mmresult) hr=0x%x", hr );
		waveInUnprepareHeader( m_hwiDevice, &m_lpWaveHeaders[m_dwShadowStart], sizeof( WAVEHDR ) );
		return DVERR_RECORDSYSTEMERROR;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::SetVolume"
HRESULT CWaveInRecordBuffer::GetVolume( LPLONG lplVolume )
{
	HRESULT hr;

	hr = m_mixerLine.GetMicrophoneVolume( lplVolume );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to get mic volume, using master rec volume hr=0x%x", hr );
		
		hr = m_mixerLine.GetMasterRecordVolume( lplVolume );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get recording volume hr=0x%x", hr );
			return hr;
		}
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::SetVolume"
HRESULT CWaveInRecordBuffer::SetVolume( LONG lVolume )
{
	HRESULT hr;

	hr = m_mixerLine.SetMasterRecordVolume( lVolume );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to set master recording volume hr=0x%x", hr );
	}

	hr = m_mixerLine.SetMicrophoneVolume( lVolume );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to set mic volume hr=0x%x", hr );
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::GetCurrentPosition"
HRESULT CWaveInRecordBuffer::GetCurrentPosition( LPDWORD lpdwPosition, LPBOOL lpfLostFocus )
{
	*lpdwPosition = m_dwCurrentPosition;
	*lpfLostFocus = FALSE;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::Record"
HRESULT CWaveInRecordBuffer::Record( BOOL fLooping )
{
	// Always send two buffers to the record device in order to allow
	// for significant write-ahead

	HRESULT hr;

	m_fRecording = FALSE;

	m_dwCurrentPosition = 0;

	for( DWORD dwIndex = 0; dwIndex < m_dwNumBuffers; dwIndex++ )
	{
		m_lpWaveHeaders[dwIndex].dwFlags = 0;

		hr = waveInPrepareHeader( m_hwiDevice, &m_lpWaveHeaders[dwIndex], sizeof( WAVEHDR ) );

		if( WIFAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to prepare header for recording (mmresult) hr=0x%x", hr );
			return DVERR_RECORDSYSTEMERROR;
		}

		hr = waveInAddBuffer( m_hwiDevice, &m_lpWaveHeaders[dwIndex], sizeof( WAVEHDR ) );

		if( WIFAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to write wave chunk (mmresult) hr=0x%x", hr );
			return DVERR_RECORDSYSTEMERROR;
		}		
	}

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Starting recording" );

	hr = waveInStart( m_hwiDevice );

	if( WIFAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to start input (mmresult) hr=0x%x", hr );
		return DVERR_RECORDSYSTEMERROR;
	}

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Waiting for a frame to be processed" );

	// Delay for one frame to allow waveIn to start up. 
	//
	WaitForSingleObject( m_hFrameProcessed, INFINITE );

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Frame processed, recording proceeding" );

	m_fRecording = TRUE;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::Stop"
HRESULT CWaveInRecordBuffer::Stop()
{
	HRESULT hr;
	DWORD dwIndex;

	m_fStopping = TRUE;

	hr = waveInReset( m_hwiDevice );

	if( WIFAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Stop failed on waveInReset (mmresult) hr=0x%x", hr );
		return DVERR_RECORDSYSTEMERROR;
	}

	ResetEvent( m_hFrameProcessed );

	for( dwIndex = 0; dwIndex < m_dwNumBuffers; dwIndex++ )
	{
		hr = waveInUnprepareHeader( m_hwiDevice, &m_lpWaveHeaders[dwIndex], sizeof( WAVEHDR ) );

		if( WIFAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to unprepare header for recording (mmresult) hr=0x%x", hr );
		}
	}

	m_fStopping = FALSE;	
	m_fRecording = FALSE;

	// This should cause the callback to be called which will
	// unprepare all the headers.

	return DV_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::GetRecordFormat"
LPWAVEFORMATEX CWaveInRecordBuffer::GetRecordFormat()
{
	return m_lpwfxRecordFormat;	
}


#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::SelectMicrophone"
HRESULT CWaveInRecordBuffer::SelectMicrophone( BOOL fSelect )
{
	return m_mixerLine.EnableMicrophone( fSelect );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::ClaimFocus"
HRESULT CWaveInRecordBuffer::ClaimFocus(  )
{
	return DVERR_NOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordBuffer::YieldFocus"
HRESULT CWaveInRecordBuffer::YieldFocus(  )
{
	return DVERR_NOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\wavformat.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wavformat.cpp
 *  Content:
 *		This module contains the CWaveFormat class which is used to work with
 *		WAVEFORMATEX structures.  
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/00		rodtoll	Created
 *
 ***************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "wavformat.h"
#include "dndbg.h"
#include "osind.h"
#include "creg.h"
#include "dvoice.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define REGISTRY_WAVEFORMAT_RATE			L"Rate"
#define REGISTRY_WAVEFORMAT_BITS			L"Bits"
#define REGISTRY_WAVEFORMAT_CHANNELS		L"Channels"
#define REGISTRY_WAVEFORMAT_TAG				L"Tag"
#define REGISTRY_WAVEFORMAT_AVGPERSEC		L"AvgPerSec"
#define REGISTRY_WAVEFORMAT_BLOCKALIGN		L"BlockAlign"
#define REGISTRY_WAVEFORMAT_CBSIZE			L"cbsize"
#define REGISTRY_WAVEFORMAT_CBDATA			L"cbdata"

// Cleanup -- Frees memory 
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::Cleanup"

void CWaveFormat::Cleanup()
{
	if( m_pwfxFormat )
	{
		if( m_fOwned )
		{
			delete m_pwfxFormat;
			m_fOwned = FALSE;
			m_pwfxFormat = NULL;
		}
	}
}

// Initialize with full parameters
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::Initialize"

HRESULT CWaveFormat::Initialize( WORD wFormatTag, DWORD nSamplesPerSec, WORD nChannels, WORD wBitsPerSample, 
			  	                 WORD nBlockAlign, DWORD nAvgBytesPerSec, WORD cbSize, void *pvExtra )
{
	Cleanup();

	m_pwfxFormat = (LPWAVEFORMATEX) (new BYTE[sizeof(WAVEFORMATEX)+cbSize]);

	if( !m_pwfxFormat )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DVERR_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	m_pwfxFormat->wFormatTag = wFormatTag;
	m_pwfxFormat->nSamplesPerSec = nSamplesPerSec;
	m_pwfxFormat->nChannels = nChannels;
	m_pwfxFormat->wBitsPerSample = wBitsPerSample;
	m_pwfxFormat->nBlockAlign = nBlockAlign;
	m_pwfxFormat->nAvgBytesPerSec = nAvgBytesPerSec;
	m_pwfxFormat->cbSize = cbSize;

	if( m_pwfxFormat->cbSize )
	{
		memcpy( &m_pwfxFormat[1], pvExtra, m_pwfxFormat->cbSize );
	}

	return DV_OK;
}

// Initialize and copy the specified format
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializeCPY"

HRESULT CWaveFormat::InitializeCPY( LPWAVEFORMATEX pwfxFormat, void *pvExtra )
{
	Cleanup();

	m_pwfxFormat = (LPWAVEFORMATEX) (new BYTE[sizeof( WAVEFORMATEX ) + pwfxFormat->cbSize] );

	if( !m_pwfxFormat )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DVERR_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	memcpy( m_pwfxFormat, pwfxFormat, sizeof( WAVEFORMATEX ) );
	memcpy( &m_pwfxFormat[1], pvExtra, pwfxFormat->cbSize );

	return DV_OK;
}

// Build a standard PCM format
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializePCM"

HRESULT CWaveFormat::InitializePCM( WORD wHZ, BOOL fStereo, BYTE bBitsPerSample )
{
	Cleanup();

	m_pwfxFormat = new WAVEFORMATEX;

	if( !m_pwfxFormat )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DVERR_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	m_pwfxFormat->wFormatTag		= WAVE_FORMAT_PCM;
	m_pwfxFormat->nSamplesPerSec	= (WORD) wHZ;
	m_pwfxFormat->nChannels			= (fStereo) ? 2 : 1;
	m_pwfxFormat->wBitsPerSample	= (WORD) bBitsPerSample;
	m_pwfxFormat->nBlockAlign		= (bBitsPerSample * m_pwfxFormat->nChannels / 8);
	m_pwfxFormat->nAvgBytesPerSec	= m_pwfxFormat->nSamplesPerSec * m_pwfxFormat->nBlockAlign;
	m_pwfxFormat->cbSize			= 0;

	return DV_OK;
}

// Create a WAVEFORMAT that is of size dwSize
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializeMEM"

HRESULT CWaveFormat::InitializeMEM( DWORD dwSize )
{
	Cleanup();

	m_pwfxFormat = (LPWAVEFORMATEX) new BYTE[dwSize];

	if( !m_pwfxFormat )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DVERR_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	return DV_OK;
}

// Initialize but unowned
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializeUSE"

HRESULT CWaveFormat::InitializeUSE( WAVEFORMATEX *pwfxFormat )
{
	Cleanup();

	m_pwfxFormat = pwfxFormat;

	m_fOwned = FALSE;

	return DV_OK;
}

// Set this object equal to the parameter
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::SetEqual"

HRESULT CWaveFormat::SetEqual( CWaveFormat *pwfxFormat )
{
	Cleanup();

	if( pwfxFormat )
	{
		LPWAVEFORMATEX pwfxTmp = pwfxFormat->GetFormat();

		DNASSERT( pwfxFormat->GetFormat() );
	
		return Initialize( pwfxTmp->wFormatTag, pwfxTmp->nSamplesPerSec, 
						   pwfxTmp->nChannels, pwfxTmp->wBitsPerSample,
						   pwfxTmp->nBlockAlign, pwfxTmp->nAvgBytesPerSec,
						   pwfxTmp->cbSize, (pwfxTmp->cbSize) ? &pwfxTmp[1] : NULL );
	}

	return DV_OK;
}

// Are these two types equal?
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::IsEqual"

BOOL CWaveFormat::IsEqual( CWaveFormat *pwfxFormat )
{
	if( !pwfxFormat )
		return FALSE;

	DNASSERT( pwfxFormat->GetFormat() );

	if( pwfxFormat->GetFormat()->cbSize != m_pwfxFormat->cbSize )
		return FALSE;

	if( memcmp( pwfxFormat->GetFormat(), m_pwfxFormat, sizeof( WAVEFORMATEX ) ) != 0 )
		return FALSE;

	if( memcmp( &(pwfxFormat->GetFormat())[1], &m_pwfxFormat[1], m_pwfxFormat->cbSize ) != 0 )
		return FALSE;

	return TRUE;
}

// Write the contained value to the registry
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::WriteREG"

HRESULT CWaveFormat::WriteREG( HKEY hKeyRoot, const WCHAR *wszPath )
{
	CRegistry waveKey;
	HRESULT hr;

	if( !waveKey.Open( hKeyRoot, wszPath, FALSE, TRUE ) )
	{
		return E_FAIL; 
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_CBSIZE, m_pwfxFormat->cbSize ) )
	{
		return E_FAIL;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_RATE, m_pwfxFormat->nSamplesPerSec ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_BITS, m_pwfxFormat->wBitsPerSample ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_CHANNELS, m_pwfxFormat->nChannels ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_TAG, m_pwfxFormat->wFormatTag ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_AVGPERSEC, m_pwfxFormat->nAvgBytesPerSec ) )
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteDWORD( REGISTRY_WAVEFORMAT_BLOCKALIGN, m_pwfxFormat->nBlockAlign ) ) 
	{
		goto WRITE_FAILURE;
	}

	if( !waveKey.WriteBlob( REGISTRY_WAVEFORMAT_CBDATA, (LPBYTE) &m_pwfxFormat[1], m_pwfxFormat->cbSize ) )
	{
		goto WRITE_FAILURE;
	}

	return S_OK;

WRITE_FAILURE:

	DPFX(DPFPREP,  0, "Error writing waveformat" );

	return E_FAIL;
}


// Initialize from registry 
#undef DPF_MODNAME
#define DPF_MODNAME "CWaveFormat::InitializeREG"

HRESULT CWaveFormat::InitializeREG( HKEY hKeyRoot, const WCHAR *wszPath )
{
	CRegistry waveKey;
	HRESULT hr;

	if( !waveKey.Open( hKeyRoot, wszPath, TRUE, FALSE ) )
	{
		return E_FAIL; 
	}

	DWORD dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_CBSIZE, dwTmp ) )
	{
		return E_FAIL;
	}

	m_pwfxFormat = (LPWAVEFORMATEX) new BYTE[dwTmp+sizeof(WAVEFORMATEX)];

	if( m_pwfxFormat == NULL )
	{
		return E_OUTOFMEMORY;
	}

	m_fOwned = TRUE;

	m_pwfxFormat->cbSize = (BYTE) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_RATE, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->nSamplesPerSec = dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_BITS, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->wBitsPerSample = (WORD) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_CHANNELS, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->nChannels = (INT) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_TAG, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->wFormatTag = (WORD) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_AVGPERSEC, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->nAvgBytesPerSec = (INT) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_BLOCKALIGN, dwTmp ) ) 
	{
		goto READ_FAILURE;
	}

	m_pwfxFormat->nBlockAlign = (INT) dwTmp;

	dwTmp = m_pwfxFormat->cbSize;

	if( !waveKey.ReadBlob( REGISTRY_WAVEFORMAT_CBDATA, (LPBYTE) &m_pwfxFormat[1], &dwTmp ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading waveformat blob" );
		goto READ_FAILURE;
	}

	return S_OK;

READ_FAILURE:

	Cleanup();

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\wirecd.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wirecd.h
 *  Content:	Definition of the CWaveInRecordDevice class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 11/12/99		rodtoll	Modified abstraction for new waveIn support.
 *						Now abstracted types look almost like dsoundcap objects    
 * 12/01/99		rodtoll Bug #121815 - Static in playback/record
 *						Added implementations of Set/GetMixerQuality
 *						(Not supported w/waveIn).  
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						- Added hwndOwner param for capture focus support
 *						- Added lpfLostFocus param to GetCurrentPosition so upper 
 *						  layers can detect lost focus.
 *
 ***************************************************************************/

#ifndef __WAVEINRECORDDEVICE_H
#define __WAVEINRECORDDEVICE_H

#include "arecd.h"
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

// CWaveInRecordDevice
//
// This class provides an implementation of the CAudioRecordDevice class which
// is an implementation of the recording device abstraction using waveIN.  
//
class CWaveInRecordDevice: public CAudioRecordDevice
{
public:
	CWaveInRecordDevice();
    
    virtual ~CWaveInRecordDevice();

public: // Initialization

    HRESULT Initialize( const GUID &refguidDevice );
    HRESULT CreateBuffer( LPDSCBUFFERDESC lpdscBufferDesc, HWND hwndOwner, DWORD dwFrameSize, CAudioRecordBuffer **lpapBuffer );    

    LPDIRECTSOUNDCAPTURE GetCaptureDevice();

    HRESULT GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality );
    HRESULT SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality );       

protected:

	UINT m_uiDeviceID;
	GUID m_guidDevice;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\wirecs.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wirecs.h
 *  Content:	Definition of the CWaveInRecordSubSystem class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 09/21/99		rodtoll	Added define which is defined when wavein is available 
 *
 ***************************************************************************/

#ifndef __WAVEINRECORDSUBSYSTEM_H
#define __WAVEINRECORDSUBSYSTEM_H

#include "arecs.h"
#include <map>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

#include <map>

#define USE_WAVEIN	1

// CWaveINRecordSubSystem
//
// This class provides an implementation for the CAudioRecordSubSystem 
// interface using the WaveIN subsystem.  (If available).
//
// It is responsible for:
// 1. Detecting if waveIN is available on the system.
// 2. Enumerating available waveIN devices
// 3. Mapping from waveIN device ID's to the subsystem 
//    independent ARDID's.  
// 4. Creating objects which provide the CAudioRecordDevice 
//    interface for specified ARDID's.  
//    
// To use this class, simply construct the class and then check
// the valid flag to determine if the subsystem is available. 
//
// In this implementation of the CAudioRecordSubSystem the 
// ARDID's are equivalent to waveIN device IDs.
//
class CWaveInRecordSubSystem: public CAudioRecordSubSystem
{
public:
    CWaveInRecordSubSystem();
    ~CWaveInRecordSubSystem();

public:
    bool IsValid();

public:
    bool IsValidDevice( ARDID deviceID );
    CAudioRecordDevice *CreateDevice( ARDID deviceID );
    bool GetDeviceInfo( ARDID deviceID, ARDeviceInfo &device );
    unsigned int GetNumDevices();

    const TCHAR *GetSubSystemName();
protected:

    typedef std::map<unsigned int,ARDeviceInfo *>::iterator DeviceMapIterator;

    std::map<unsigned int,ARDeviceInfo *> m_deviceMap;	// Map waveIN id/ARDID <--> ARDeviceInfo
    bool								  m_valid;		// Is this subsystem valid?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\wirecb.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wirecb.h
 *  Content:	Definition of the CWaveInRecordBuffer class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/04/99		rodtoll	Created
 * 11/23/99		rodtoll	Added SelectMicrophone call to the interface 
 * 12/01/99		rodtoll	Bug #115783 - Always adjusts default device.
 *						Added support for new mixerline class which supports
 *						proper selection of devices/adjusting of volumes
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						- Added hwndOwner param for capture focus support
 *						- Added lpfLostFocus param to GetCurrentPosition so upper 
 *						  layers can detect lost focus.
 *  01/28/2000	rodtoll	Bug #130465: Record Mute/Unmute must call YieldFocus() / ClaimFocus() 
 *
 ***************************************************************************/

#ifndef __WAVEOUTPLAYBACKBUFFER_H
#define __WAVEOUTPLAYBACKBUFFER_H

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

#include "arecb.h"
#include "mixline.h"

// CWaveInRecordBuffer
//
// This class provides an implementation of the CAudioRecordBuffer class
// for waveIN.  
//
class CWaveInRecordBuffer: public CAudioRecordBuffer
{
public:
    CWaveInRecordBuffer( );
    virtual ~CWaveInRecordBuffer();

public: 

    HRESULT Initialize( UINT uDeviceID, LPDSCBUFFERDESC lpdsDesc, DWORD dwFrameSize );

public: // Implementation of the buffer params

    HRESULT Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lpvBuffer1, LPDWORD lpdwSize1, LPVOID *lpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags );
    HRESULT UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 );
    HRESULT GetVolume( LPLONG lplVolume );
    HRESULT SetVolume( LONG lVolume );
    HRESULT GetCurrentPosition( LPDWORD lpdwPosition, LPBOOL lpfLostFocus );
    HRESULT Record( BOOL fLooping );
    HRESULT Stop();
    HRESULT SelectMicrophone( BOOL fSelect );

    HRESULT YieldFocus();
    HRESULT ClaimFocus();    

	LPWAVEFORMATEX GetRecordFormat();
    DWORD GetStartupLatency();

protected: 

	static void CALLBACK WaveInHandler( HWAVEIN hwi, UINT uMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2 );

protected:

	UINT 		m_uDeviceID;
	DWORD 		m_dwCurrentPosition;
	HWAVEIN		m_hwiDevice;
	DWORD		m_dwBufferSize;
	DWORD		m_dwNumBuffers;
	DWORD		m_dwFrameSize;
	WAVEHDR		*m_lpWaveHeaders;
	BOOL		m_fRecording;
	LPBYTE		m_lpbShadowBuffer;
	DWORD		m_dwShadowStart;
	HANDLE		m_hFrameProcessed;
	LPWAVEFORMATEX m_lpwfxRecordFormat;
	BOOL		m_fStopping;
	CMixerLine	m_mixerLine;	
};	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\wirecd.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wirecd.cpp
 *  Content:
 *		This module contains the implementation of the CWaveInRecordDevice
 *		class.  
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 09/20/99		rodtoll	Updated to check for out of memory conditions
 * 11/12/99		rodtoll	Modified abstraction for new waveIn support.
 *						Now abstracted types look almost like dsoundcap objects     
 * 11/29/99		rodtoll	Fix: Bug #115783 - Regardless of specified device, adjusts volume for default
 *                      Prevents any other device then default from being used w/waveIN
 * 12/01/99		rodtoll Bug #121815 - Static in playback/record
 *						Added implementations of Set/GetMixerQuality
 *						(Not supported w/waveIn).   
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						- Added hwndOwner param for capture focus support
 *						- Added lpfLostFocus param to GetCurrentPosition so upper 
 *						  layers can detect lost focus.
 *
 ***************************************************************************/

#include "stdafx.h"
#include <objbase.h>
#include "wirecd.h"
#include "wirecb.h"
#include "dndbg.h"
#include "OSInd.h"
#include "Dvoice.h"
#include "devmap.h"
#include "dsprv.h"
#include "dsprvobj.h"

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordDevice::CWaveInRecordDevice"
CWaveInRecordDevice::CWaveInRecordDevice( 
): CAudioRecordDevice(), m_uiDeviceID(0), m_guidDevice(GUID_NULL)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordDevice::CWaveInRecordDevice"
CWaveInRecordDevice::~CWaveInRecordDevice()
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordDevice::Initialize"
HRESULT CWaveInRecordDevice::Initialize( const GUID &guidDevice )
{
	HRESULT hr;
	DWORD dwDeviceID;

	m_guidDevice = guidDevice;

	hr = DV_MapGUIDToWaveID( TRUE, guidDevice, &dwDeviceID );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to map GUID to waveIn.  Defaulting to ID 0 hr=0x%x", hr );
		m_uiDeviceID = 0;
	}
	else
	{
		m_uiDeviceID = dwDeviceID;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordDevice::CreateBuffer"
HRESULT CWaveInRecordDevice::CreateBuffer( LPDSCBUFFERDESC lpdscBufferDesc, HWND hwndOwner, DWORD dwFrameSize, CAudioRecordBuffer **lplparBuffer )
{
	CWaveInRecordBuffer *lpNewBuffer;
	HRESULT hr;

	lpNewBuffer = new CWaveInRecordBuffer();

	if( lpNewBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		return DVERR_OUTOFMEMORY;
	}

	hr = lpNewBuffer->Initialize( m_uiDeviceID, lpdscBufferDesc, dwFrameSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Buffer Init failed hr=0x%x", hr );
		delete lpNewBuffer;
		return hr;
	}

	*lplparBuffer = lpNewBuffer;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordDevice::GetCaptureDevice"
LPDIRECTSOUNDCAPTURE CWaveInRecordDevice::GetCaptureDevice()
{
	return NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordDevice::GetMixerQuality"
HRESULT CWaveInRecordDevice::GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality )
{
	return DVERR_NOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveInRecordDevice::SetMixerQuality"
HRESULT CWaveInRecordDevice::SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality )
{
	return DVERR_NOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\woplayb.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		woplayb.cpp
 *  Content:
 *		This module contains the implementation of the CWaveOutPlaybackBuffer
 *		class.  
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/04/99		rodtoll	Updated to take dsound ranges for volume
 * 09/20/99		rodtoll	Updated to check for out of memory conditions
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects      
 * 11/18/99		rodtoll Fixed bug causing glitch in waveout playback
 * 01/14/2000	rodtoll	Updated to use DWORD_PTR to allow proper 64-bit operation  
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1
 *
 ***************************************************************************/

#include "stdafx.h"
#include "woplayd.h"
#include "wiutils.h"
#include "dndbg.h"
#include "OSInd.h"
#include "woplayb.h"
#include "dvoice.h"

#define	WAVEOUT_STARTUPLATENCY 	2

#define WOFAILED( x )  (x != MMSYSERR_NOERROR)

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::CWaveOutPlaybackBuffer"
CWaveOutPlaybackBuffer::CWaveOutPlaybackBuffer(
): CAudioPlaybackBuffer(), m_hwoDevice(NULL), m_uDeviceID(0), m_dwCurrentPosition(0),
   m_lpWaveHeaders(NULL), m_dwBufferSize(0), m_dwNumBuffers(0), m_dwFrameSize(0),
   m_fPlaying(FALSE), m_lpbShadowBuffer(NULL), m_dwShadowStart(0), m_hFrameProcessed(NULL), m_fStopping(FALSE)
{
	m_hFrameProcessed = CreateEvent( NULL, FALSE, FALSE, NULL );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::~CWaveOutPlaybackBuffer"
CWaveOutPlaybackBuffer::~CWaveOutPlaybackBuffer()
{
	// Stop the buffers and unprepare them if they are prepared
	Stop();
	
	if( m_dwNumBuffers )
	{
		for( DWORD dwIndex = 0; dwIndex < m_dwNumBuffers; dwIndex++ )
		{
			delete [] ((LPBYTE) m_lpWaveHeaders[dwIndex].lpData);
		}

		delete [] m_lpWaveHeaders;
	}

	// Close the device
	if( m_hwoDevice != NULL )
	{
		waveOutClose( m_hwoDevice );
	}

	if( m_lpbShadowBuffer != NULL )
	{
		delete [] m_lpbShadowBuffer;
	}

	if( m_hFrameProcessed != NULL )
	{
		CloseHandle( m_hFrameProcessed );
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::Initialize"
HRESULT CWaveOutPlaybackBuffer::Initialize( UINT uDeviceID, LPDSBUFFERDESC lpdsDesc, DWORD dwFrameSize )
{
	HRESULT hr;
	DWORD dwIndex;

	hr = waveOutOpen( &m_hwoDevice, uDeviceID, lpdsDesc->lpwfxFormat, (DWORD_PTR) WaveOutHandler, (DWORD_PTR) this, CALLBACK_FUNCTION ) ; 

	if( WOFAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to open waveOut Device (mmresult) hr=0x%x", hr );
		return DVERR_PLAYBACKSYSTEMERROR;
	}

	m_dwNumBuffers = lpdsDesc->dwBufferBytes / dwFrameSize;	

	m_lpWaveHeaders = new WAVEHDR[m_dwNumBuffers];

	if( m_lpWaveHeaders == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		hr = DVERR_OUTOFMEMORY;

		goto INITIALIZE_ERROR;
	}

	for( dwIndex = 0; dwIndex < m_dwNumBuffers; dwIndex++ )
	{
		m_lpWaveHeaders[dwIndex].lpData = (LPSTR) new BYTE[dwFrameSize];

		if( m_lpWaveHeaders[dwIndex].lpData == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );

			// Make sure rest of buffer pointers are NULL;
			for( ; dwIndex < m_dwNumBuffers; dwIndex++ )
			{
				m_lpWaveHeaders[dwIndex].lpData = NULL;
			}

			hr = DVERR_OUTOFMEMORY;

			goto INITIALIZE_ERROR;
		}

		m_lpWaveHeaders[dwIndex].dwBufferLength = dwFrameSize;
		m_lpWaveHeaders[dwIndex].dwBytesRecorded = 0;

		// Used to specify buffer location when this buffer is complete
/*		if( dwIndex == (m_dwNumBuffers-1))
		{
			m_lpWaveHeaders[dwIndex].dwUser = 0;
		}
		else
		{
			m_lpWaveHeaders[dwIndex].dwUser = dwFrameSize*(dwIndex+1);		
		}*/

		m_lpWaveHeaders[dwIndex].dwUser = dwFrameSize * dwIndex;
		
		m_lpWaveHeaders[dwIndex].dwFlags = 0; 
		m_lpWaveHeaders[dwIndex].dwLoops = 0;
		m_lpWaveHeaders[dwIndex].lpNext = NULL;
		m_lpWaveHeaders[dwIndex].reserved = 0;
	}

	m_lpbShadowBuffer = new BYTE[lpdsDesc->dwBufferBytes];

	m_uDeviceID = uDeviceID;
	m_dwFrameSize = dwFrameSize;
	m_dwCurrentPosition = 0;
	m_dwBufferSize = lpdsDesc->dwBufferBytes;
	m_fPlaying = FALSE;

	return DV_OK;

INITIALIZE_ERROR:

	if( m_lpbShadowBuffer != NULL )
	{
		delete [] m_lpbShadowBuffer;
		m_lpbShadowBuffer = NULL;
	}

	if( m_lpWaveHeaders != NULL )
	{
		for( dwIndex = 0; dwIndex < m_dwNumBuffers; dwIndex++ )
		{
			if( m_lpWaveHeaders[dwIndex].lpData != NULL )
			{
				delete [] ((LPBYTE) m_lpWaveHeaders[dwIndex].lpData);
			}
		}

		delete [] m_lpWaveHeaders;
		m_lpWaveHeaders = NULL;
	}

	if( m_hwoDevice != NULL )
	{
		waveOutClose( m_hwoDevice );
		m_hwoDevice = NULL;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::WaveOutHandler"
void CWaveOutPlaybackBuffer::WaveOutHandler( HWAVEOUT hwo, UINT uMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2 )
{
	CWaveOutPlaybackBuffer *This = (CWaveOutPlaybackBuffer *) dwInstance;
	
	DNASSERT( This != NULL );

	HRESULT hr;
	
	if( uMsg == WOM_DONE && !This->m_fStopping )
	{
		WAVEHDR *lpWaveHeader = (WAVEHDR *) dwParam1;

		hr = waveOutUnprepareHeader( This->m_hwoDevice, lpWaveHeader, sizeof( WAVEHDR ) );

		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unpreparing header for loc: %d", lpWaveHeader->dwUser );

		if( WOFAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error unpreparing header (mmresult) hr=0x%x", hr );
		}

		This->m_dwCurrentPosition = lpWaveHeader->dwUser;

		if( !This->m_fPlaying )
		{
			SetEvent( This->m_hFrameProcessed );
		}
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::Lock"
HRESULT CWaveOutPlaybackBuffer::Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lplpvBuffer1, LPDWORD lpdwSize1, LPVOID *lplpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags )
{
	*lpdwSize2 = 0;
	*lplpvBuffer2 = NULL;

	// Special case for the entire buffer
	if( dwFlags & DSBLOCK_ENTIREBUFFER )
	{
		if( m_fPlaying )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot lock entire buffer while playing!" );
			return DVERR_GENERIC;
		}
		
		*lplpvBuffer1 = m_lpbShadowBuffer;
		*lpdwSize1 = m_dwBufferSize;
		m_dwShadowStart = 0;
		
		return DV_OK;
	}

	if( dwWriteBytes % m_dwFrameSize != 0 )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Can only lock block aligned sizes" );
		return DVERR_GENERIC;
	}

	// We're working with a shadow buffer
	if( dwWriteBytes > m_dwFrameSize )
	{
		*lplpvBuffer1 = m_lpbShadowBuffer;
		*lpdwSize1 = dwWriteBytes;
		m_dwShadowStart = dwWriteCursor;

		return DV_OK;
	}

	// We're doing a plain old lock of a buffer.  When we do the unlock we'll commit the buffer
	m_dwShadowStart = dwWriteCursor / m_dwFrameSize;

	*lpdwSize1 = m_dwFrameSize;
	*lplpvBuffer1 = m_lpWaveHeaders[m_dwShadowStart].lpData;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::UnLock"
HRESULT CWaveOutPlaybackBuffer::UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 )
{
	HRESULT hr;
	// We used the shadow buffer, we're writing across multiple buffers.
	//
	// We don't commit the buffers to the sound device because this is always used for 
	// setting silence into the buffers
	if( dwSize1 > m_dwFrameSize )
	{
		DWORD dwCurrentBuffer = m_dwShadowStart / m_dwFrameSize;
		LPBYTE lpCurrentShadowLoc = m_lpbShadowBuffer;

		for( DWORD dwIndex = 0; dwIndex < (dwSize1 / m_dwFrameSize); dwIndex++ )
		{
			memcpy( m_lpWaveHeaders[dwCurrentBuffer].lpData , lpCurrentShadowLoc, m_dwFrameSize );

			lpCurrentShadowLoc += m_dwFrameSize;
			dwCurrentBuffer++;

			dwCurrentBuffer %= m_dwNumBuffers;
		}

		return DV_OK;
	}

	// Only prepare buffers if they have not yet been prepared
	if( !(m_lpWaveHeaders[m_dwShadowStart].dwFlags & WHDR_PREPARED) )
	{
		// We got just one buffer and we're now ready to commit it to the device

		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Preparing header for loc: %d", m_lpWaveHeaders[m_dwShadowStart].dwUser );

		hr = waveOutPrepareHeader( m_hwoDevice, &m_lpWaveHeaders[m_dwShadowStart], sizeof( WAVEHDR ) );

		if( WOFAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to prepare the header for output to the sound device (mmresult) hr = 0x%x", hr );
			return DVERR_PLAYBACKSYSTEMERROR;
		}

		hr = waveOutWrite( m_hwoDevice, &m_lpWaveHeaders[m_dwShadowStart], sizeof( WAVEHDR ) );

		if( WOFAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to write the buffer (mmresult) hr=0x%x", hr );
			waveOutUnprepareHeader( m_hwoDevice, &m_lpWaveHeaders[m_dwShadowStart], sizeof( WAVEHDR ) );
			return DVERR_PLAYBACKSYSTEMERROR;
		}
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::SetVolume"
HRESULT CWaveOutPlaybackBuffer::SetVolume( LONG lVolume )
{
    LONG woVolume;
	HRESULT hr;

    woVolume = (0xFFFF * lVolume) / (DSBVOLUME_MAX-DSBVOLUME_MIN);
    woVolume -= DSBVOLUME_MIN;

	hr = waveOutSetVolume( m_hwoDevice, woVolume );

	if( WOFAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to set volume (mmresult) hr=0x%x", hr );
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::GetCurrentPosition"
HRESULT CWaveOutPlaybackBuffer::GetCurrentPosition( LPDWORD lpdwPosition )
{
	*lpdwPosition = m_dwCurrentPosition;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::SetCurrentPosition"
HRESULT CWaveOutPlaybackBuffer::SetCurrentPosition( DWORD dwPosition )
{
	DPFX(DPFPREP,  DVF_ERRORLEVEL, "SetCurrentPosition is not supported" );
	return DVERR_NOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::Get3DBuffer"
HRESULT CWaveOutPlaybackBuffer::Get3DBuffer( LPDIRECTSOUND3DBUFFER *lplpds3dBuffer )
{
	DPFX(DPFPREP,  DVF_ERRORLEVEL, "3D buffers are not supported" );
	*lplpds3dBuffer = NULL;
	return DVERR_NOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::Play"
HRESULT CWaveOutPlaybackBuffer::Play( DWORD dwPriority, DWORD dwFlags )
{
	HRESULT hr;

	if( dwFlags != 0 )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "WaveOut playback ignores flags" );
	}

	m_fPlaying = FALSE;

	m_dwCurrentPosition = 0;

	for( DWORD dwIndex = 0; dwIndex < WAVEOUT_STARTUPLATENCY; dwIndex++ )
	{
		m_lpWaveHeaders[dwIndex].dwFlags = 0;

		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Preparing header for loc: %d", m_lpWaveHeaders[dwIndex].dwUser );

		hr = waveOutPrepareHeader( m_hwoDevice, &m_lpWaveHeaders[dwIndex], sizeof( WAVEHDR ) );

		if( WOFAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to prepare header for recording (mmresult) hr=0x%x", hr );
			return DVERR_PLAYBACKSYSTEMERROR;
		}

		hr = waveOutWrite( m_hwoDevice, &m_lpWaveHeaders[dwIndex], sizeof( WAVEHDR ) );

		if( WOFAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to write wave chunk (mmresult) hr=0x%x", hr );
			return DVERR_PLAYBACKSYSTEMERROR;
		}		
	}

	// Delay for one frame to allow waveIn to start up. 
	//
	WaitForSingleObject( m_hFrameProcessed, INFINITE );

	m_fPlaying = TRUE;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::Stop"
HRESULT CWaveOutPlaybackBuffer::Stop()
{
	HRESULT hr;
	DWORD dwIndex;

	m_fStopping = TRUE;

	hr = waveOutReset( m_hwoDevice );

	if( WOFAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Stop failed on waveOutReset (mmresult) hr=0x%x", hr );
		return DVERR_PLAYBACKSYSTEMERROR;
	}

	for( dwIndex = 0; dwIndex < m_dwNumBuffers; dwIndex++ )
	{
        if( m_lpWaveHeaders[dwIndex].dwFlags & WHDR_PREPARED )
		{
			hr = waveOutUnprepareHeader( m_hwoDevice, &m_lpWaveHeaders[dwIndex], sizeof( WAVEHDR ) );

			if( WOFAILED( hr ) )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to prepare header for recording (mmresult) hr=0x%x", hr );
				return DVERR_PLAYBACKSYSTEMERROR;
			}
		}
	}

	// This should cause the callback to be called which will
	// unprepare all the headers.

	m_fStopping = FALSE;
	m_fPlaying = FALSE;

	return DV_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::Restore"
HRESULT CWaveOutPlaybackBuffer::Restore()
{
	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Restore not supported" );
	return DVERR_NOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackBuffer::GetStartupLatency"
DWORD CWaveOutPlaybackBuffer::GetStartupLatency()
{
	return WAVEOUT_STARTUPLATENCY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\wirecs.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wirecs.cpp
 *  Content:
 *		This module contains the implemenation of the CWaveInRecordSubSystem
 *		class.  See the class definition for a description
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 09/20/99		rodtoll	Updated to check for out of memory conditions
 *
 ***************************************************************************/

#include "stdafx.h"
#include "wirecd.h"
#include "wirecs.h"
#include "wiutils.h"
#include "dndbg.h"
#include "OSInd.h"

#define MODULE_ID WAVEINRECORDSUBSYSTEM

// CWaveInRecordSubSystem Constructor
//
// This constructor checks for the existance of the waveIN recording
// subsystem (which is always there), enumerates available waveIN 
// devices and sets the valid flag for the object.
//
// The object is considered valid if there are at least one valid
// waveIN record devices.  Otherwise it is considered invalid.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CWaveInRecordSubSystem::CWaveInRecordSubSystem()
{
    unsigned int numDevices;
    WAVEINCAPS waveCaps;
    ARDeviceInfo *info;
    BFC_STRING format;
	TCHAR tmpID[10];

	// Find the number of devices
    numDevices = waveInGetNumDevs();

	// Loop through all the devices and created ARDeviceInfo
	// structures to describe each.
    for( unsigned int deviceID = 0; deviceID < numDevices; deviceID++ )
    {
        try
        {
			// Attempt to retieve caps for the specified deviceID
            WAVEINCHECK( waveInGetDevCaps( deviceID, &waveCaps, sizeof( WAVEINCAPS ) ) );
    
			// Device is valid, create a structure to describe it
			// and add it to the map/
            info = new ARDeviceInfo;

            if( info == NULL )
            {
            	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to allocate device struct" );
            	continue;
            }

            info->m_deviceName = waveCaps.szPname ;
            info->m_emulated   = FALSE;

			_ltot( deviceID, tmpID, 10 );

			format  = _T("WIRS: Device ");
			format += tmpID;
			format += _T(" valid" );

            DPFX(DPFPREP,  DVF_INFOLEVEL, BFC_STRING_TOLPSTR( format ) );

            m_deviceMap[deviceID] = info;
        }
        catch( WaveInException &wie )
        {
            DPFX(DPFPREP,  DVF_INFOLEVEL, wie.what() );
			format  = _T("WIRS: Device ");
			format += tmpID;
			format += _T(" invalid" );

            DPFX(DPFPREP,  DVF_INFOLEVEL, BFC_STRING_TOLPSTR( format ) );
        }
    }

	// If there are no devices available, mark the object as invalid.
    if( GetNumDevices() == 0 )
    {
        m_valid = false;
        return;
    }

    m_valid = true;
}

// CWaveInRecordSubSystem Destructor
//
// This is the destructor for the CWaveInRecordSubSystem class.
// It cleans up the allocated memory for the class. 
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CWaveInRecordSubSystem::~CWaveInRecordSubSystem()
{
    DeviceMapIterator deviceIterator;

    deviceIterator = m_deviceMap.begin();

    while( deviceIterator != m_deviceMap.end() )
    {
        delete (*deviceIterator).second;
        deviceIterator++;
    }
}

// IsValid
//
// This function returns the value of the valid flag for this
// object.  The object will be valid if there is at least one
// waveIN device ID available.  
//
// Parameters:
// N/A
//
// Returns:
// bool -
//		Value of the object's valid flag
//
bool CWaveInRecordSubSystem::IsValid()
{
    return m_valid;
}

// IsValidDevice
//
// This function asks the object if the specified ARDID is valid
// for this subsystem.  
//
// Parameters:
// ARDID deviceID -
//		The ARDID for the device which is checked for validity
//
// Returns:
// bool -
//		true if the specified ARDID is valid for this subsystem,
//		false otherwise.
bool CWaveInRecordSubSystem::IsValidDevice( ARDID deviceID )
{
    DeviceMapIterator deviceIterator;

    deviceIterator = m_deviceMap.begin();

    if( deviceIterator != m_deviceMap.end() )
    {
        return true;
    }
    else
    {
        return false;
    }
}

// CreateDevice
//
// This function constructs a CWaveInRecordDevice object supporting
// the CAudioRecordDevice interface to represent the device specified
// by the deviceID parameter.
//
// The newly allocated object belongs to the caller and should be
// freed by the caller.  In addition, it should be freed BEFORE
// this object is.  
//
// Parameters:
// ARDID deviceID -
//		The ARDID for the device which you wish to create an object for
//
// Returns:
// CAudioRecordDevice * -
//		A CAudioRecordDevice pointer to a newly created
//      CWaveInRecordDevice object or NULL if the specified deviceID
//		is not valid.
//
CAudioRecordDevice *CWaveInRecordSubSystem::CreateDevice( ARDID deviceID )
{
    if( IsValidDevice( deviceID ) )
    {
        return new CWaveInRecordDevice( deviceID );
    }
    else
    {
        return NULL;
    }
}

// GetDeviceInfo
//
// This function retrieves information about the specified ARDID if 
// it is a valid device.  If the specified ARDID is not valid then
// the device parameter will not be touched.  
//
// Parameters:
// ARDID deviceID -
//		ARDID for the device you wish to retrieve information about
// ARDeviceInfo &device -
//		A structure to hold the information about the requested device.
//
// Returns:
// bool - 
//		true on success, false on failure
//
bool CWaveInRecordSubSystem::GetDeviceInfo( ARDID deviceID, ARDeviceInfo &device )
{
    DeviceMapIterator deviceIterator;

    deviceIterator = m_deviceMap.find(deviceID);

    if( deviceIterator != m_deviceMap.end() )
    {
        device = *((*deviceIterator).second);
        return true;
    }
    else
    {
        return false;
    }
}

// GetNumDevices
//
// This function returns the number of valid devices which were detected in the
// waveIN recording subsystem.
//
// PArameters:
// N/A
//
// Returns:
// unsigned int - 
//		The number of valid devices in the waveIN subsystem.
//
unsigned int CWaveInRecordSubSystem::GetNumDevices()
{
    return m_deviceMap.size();
}

// GetSubSystemName
//
// This function returns a pointer to a string containing
// a description of the type of recording subsystem managed
// by this object.
//
// Parameters:
// N/A
//
// Returns:
// const TCHAR * -
//		Always points to a string which says "WAVEIN".
const TCHAR *CWaveInRecordSubSystem::GetSubSystemName()
{
    return _T("WAVEIN");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\woplayd.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		woplayd.cpp
 *  Content:
 *		This module contains the implementation of the CWaveOutPlaybackDevice 
 *		class.
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects      
 * 12/01/99		rodtoll Bug #121815 - Static in playback/record
 *						Added implementations of Set/GetMixerQuality
 *						(Not supported w/waveout).
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1
 *
 ***************************************************************************/

#include "stdafx.h"
#include <objbase.h>
#include "woplayd.h"
#include "woplayb.h"
#include "dndbg.h"
#include "OSInd.h"
#include "dvoice.h"
#include "devmap.h"
#include "dsprv.h"
#include "dsprvobj.h"

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackDevice::CWaveOutPlaybackDevice"
CWaveOutPlaybackDevice::CWaveOutPlaybackDevice( 
): CAudioPlaybackDevice(), m_waveID(0), m_guidDevice(GUID_NULL)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackDevice::~CWaveOutPlaybackDevice"
CWaveOutPlaybackDevice::~CWaveOutPlaybackDevice()
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackDevice::Initialize"
HRESULT CWaveOutPlaybackDevice::Initialize( const GUID &guidDevice, HWND hwndOwner, WAVEFORMATEX *lpwfxFormat, BOOL fPriorityMode )
{
	HRESULT hr;
	DWORD dwDeviceID;

	m_guidDevice = guidDevice;

	hr = DV_MapGUIDToWaveID( FALSE, guidDevice, &dwDeviceID );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to map GUID to waveOut.  Defaulting to ID 0 hr=0x%x", hr );
		m_waveID = 0;
	}
	else
	{
		m_waveID = dwDeviceID;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackDevice::CreateBuffer"
HRESULT CWaveOutPlaybackDevice::CreateBuffer( LPDSBUFFERDESC lpdsBufferDesc, DWORD dwFrameSize, CAudioPlaybackBuffer **lplpapBuffer )
{
	CWaveOutPlaybackBuffer *lpNewBuffer;
	HRESULT hr;

	lpNewBuffer = new CWaveOutPlaybackBuffer();

	if( lpNewBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		return DVERR_OUTOFMEMORY;
	}

	hr = lpNewBuffer->Initialize( m_waveID, lpdsBufferDesc, dwFrameSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Buffer Init failed hr=0x%x", hr );
		delete lpNewBuffer;
		return hr;
	}

	*lplpapBuffer = lpNewBuffer;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackDevice::GetPlaybackDevice"
LPDIRECTSOUND CWaveOutPlaybackDevice::GetPlaybackDevice( )
{
	return NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackDevice::GetMixerQuality"
HRESULT CWaveOutPlaybackDevice::GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality )
{
	return DVERR_NOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CWaveOutPlaybackDevice::SetMixerQuality"
HRESULT CWaveOutPlaybackDevice::SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality )
{
	return DVERR_NOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\woplayd.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		woplayd.h
 *  Content:	Definition of the CWaveOutPlaybackDevice class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 10/01/99		rodtoll	Updated to conform to new interface
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects      
 * 12/01/99		rodtoll Bug #121815 - Static in playback/record
 *						Added implementations of Set/GetMixerQuality
 *						(Not supported w/waveOut). 
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1
 *
 ***************************************************************************/

#ifndef __WAVEOUTPLAYBACKDEVICE_H
#define __WAVEOUTPLAYBACKDEVICE_H

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

// Required because of the circular dependency between
// WaveOutPlaybackBuffer.h and this file.
class CWaveOutPlaybackDevice;

#include "aplayd.h"

// CWaveOutPlaybackDevice
//
// This class is responsible for providing an implementation of the 
// CAudioPlaybackDevice class for waveOUT.  A single instance
// of this class represents a waveOUT playback device.
//
//
// To use this class you must make a succesful call to the
// Initialize function.
//
// WARNING:
// Unlike DirectSound, waveOUT devices can only create a 
// single waveout buffer object / channel available on the
// output card.  Old SB cards will only support one, newer,
// multichannel cards will support more then one.
//
class CWaveOutPlaybackDevice: public CAudioPlaybackDevice
{
public:
    CWaveOutPlaybackDevice( );

    virtual ~CWaveOutPlaybackDevice();

public: // Initialization

    HRESULT Initialize( const GUID &guidDevice, HWND hwndOwner, WAVEFORMATEX *primaryFormat, BOOL fPriorityMode );
    HRESULT CreateBuffer( LPDSBUFFERDESC lpdsBufferDesc, DWORD dwFrameSize, CAudioPlaybackBuffer **lpapBuffer );    

    LPDIRECTSOUND GetPlaybackDevice();        

    HRESULT GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality );
    HRESULT SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality );
        
protected:
    unsigned int    m_waveID;				// WaveOUT device ID managed by this object
    GUID			m_guidDevice;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\woplays.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		woplays.h
 *  Content:	Definition of the CWaveOutPlaybackSubSystem class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 09/21/99		rodtoll	Added define which is defined when waveout is available
 *
 ***************************************************************************/

#ifndef __WAVEOUTPLAYBACKSUBSYSTEM_H
#define __WAVEOUTPLAYBACKSUBSYSTEM_H

#include "aplays.h"
#include <map>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

#include <map>

#define USE_WAVEOUT		1

// CWaveOutPlaybackSubSystem
//
// This class provides an implementation of the CAudioPlaybackSubSystem
// interface for the waveOUT sub-system.
//
// The purpose of this class is to be used as a factory for 
// creation of objects supporting the CAudioPlaybackDevice interface
// for waveOUT devices.  
//
// This class is not usually instantiated directly, usually the user
// queries the CAudioPlaybackDevice for the WaveOUT sub-system
// which returns one of these objects.
//
// When created it enumerates the available waveOUT devices 
// and allows users to ask it for information about those devices.
//
// It is also responsible for mapping from ARDID's to waveOUT
// device IDs.  (They are equivalent).
//
class CWaveOutPlaybackSubSystem: public CAudioPlaybackSubSystem
{
public:
    CWaveOutPlaybackSubSystem();
    ~CWaveOutPlaybackSubSystem();

public:
    bool IsValidDevice( ARDID deviceID );
    CAudioPlaybackDevice *CreateDevice( ARDID deviceID );
    bool GetDeviceInfo( ARDID deviceID, ARDeviceInfo &device );
    unsigned int GetNumDevices();

    const TCHAR *GetSubSystemName();

	// Useful typedefs
    typedef std::map<ARDID,ARDeviceInfo *> DeviceMap;
    typedef DeviceMap::iterator DeviceMapIterator;

protected:
    
    void CleanupDeviceMap();

    DeviceMap m_deviceMap;			// Map ARDID/waveIN ID <--> ARDeviceInfo 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\woplayb.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		woplayb.h
 *  Content:	Definition of the CWaveOutPlaybackBuffer class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/04/99		rodtoll	Updated to take dsound ranges for volume
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects     
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1
 *
 ***************************************************************************/

#ifndef __WAVEOUTPLAYBACKBUFFER_H
#define __WAVEOUTPLAYBACKBUFFER_H

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "ASTypes.h"

class CWaveOutPlaybackBuffer;

#include "woplayd.h"
#include "aplayb.h"

// CWaveOutPlaybackBuffer
//
// This class provides an implementation of the CAudioPlaybackBuffer class
// for waveOUT.  In the abstract sense, it represents a buffer of audio
// which can be played to the sound hardware which consists of multiple,
// equal length subbuffers.  
//
class CWaveOutPlaybackBuffer: public CAudioPlaybackBuffer
{
public:
    CWaveOutPlaybackBuffer( );
    virtual ~CWaveOutPlaybackBuffer();

public: 

    HRESULT Initialize( UINT uDeviceID, LPDSBUFFERDESC lpdsDesc, DWORD dwFrameSize );

public: // Implementation of the buffer params

    HRESULT Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lpvBuffer1, LPDWORD lpdwSize1, LPVOID *lpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags );
    HRESULT UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 );
    HRESULT SetVolume( LONG lVolume );
    HRESULT GetCurrentPosition( LPDWORD lpdwPosition );
    HRESULT SetCurrentPosition( DWORD dwPosition );
    HRESULT Get3DBuffer( LPDIRECTSOUND3DBUFFER *lplpds3dBuffer );    
    HRESULT Play( DWORD dwPriority, DWORD dwFlags );
    HRESULT Stop();
    HRESULT Restore();
 
    DWORD GetStartupLatency();

protected: 

	static void CALLBACK WaveOutHandler( HWAVEOUT hwo, UINT uMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2 );

protected:

	UINT 		m_uDeviceID;
	volatile DWORD m_dwCurrentPosition;
	HWAVEOUT	m_hwoDevice;
	DWORD		m_dwBufferSize;
	DWORD		m_dwNumBuffers;
	DWORD		m_dwFrameSize;
	WAVEHDR		*m_lpWaveHeaders;
	BOOL		m_fPlaying;
	LPBYTE		m_lpbShadowBuffer;
	DWORD		m_dwShadowStart;
	HANDLE		m_hFrameProcessed;
	BOOL		m_fStopping;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\guids\guids.cpp ===
#include <initguid.h>
#include <wtypes.h>
#include <mmsystem.h>
#include "dsoundp.h"
#include "dsprv.h"
#include "dplay8.h"
#include "dvoice.h"
#include "dpvcp.h"
#include "dplay.h"
#include "dplobby.h"
#include "..\dxvhelp\dxvhelp.h"
#include "..\codecs\dpvvox\dpvvox.h"
#include "..\codecs\dpvacm\dpvacm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\inc\dpvcp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvoice.h
 *  Content:    DirectPlayVoice include file
 *  History:
 *	Date   		By  		Reason
 *	=========== =========== ====================
 *	10/27/99	rodtoll		created
 *  12/16/99	rodtoll		Padding for compression structure
 ***************************************************************************/

#ifndef __DPVCP_H
#define __DPVCP_H

#include "dvoice.h"

/////////////////////////////////////////////////////////////////////////////////////
// GUIDS
//

// {B8485451-07C4-4973-A278-C69890D8CF8D}
DEFINE_GUID(IID_IDPVCompressionProvider, 
0xb8485451, 0x7c4, 0x4973, 0xa2, 0x78, 0xc6, 0x98, 0x90, 0xd8, 0xcf, 0x8d);

// {AAA56B61-3B8D-4906-AE58-29C26B8F47B8}
DEFINE_GUID(IID_IDPVConverter, 
0xaaa56b61, 0x3b8d, 0x4906, 0xae, 0x58, 0x29, 0xc2, 0x6b, 0x8f, 0x47, 0xb8);

/////////////////////////////////////////////////////////////////////////////////////
// Interface types
//
typedef struct IDPVCompressionProvider FAR *LPDPVCOMPRESSIONPROVIDER, *PDPVCOMPRESSIONPROVIDER;
typedef struct IDPVCompressor FAR *LPDPVCOMPRESSOR, *PDPVCOMPRESSOR;

/////////////////////////////////////////////////////////////////////////////////////
// Data Types
//

typedef struct 
{
	// DVCOMPRESSIONINFO Structure
	//
    DWORD       	dwSize; 
	GUID			guidType;
   	LPWSTR       	lpszName;
   	LPWSTR     		lpszDescription;
	DWORD			dwFlags;
    DWORD           dwMaxBitsPerSecond;		
    WAVEFORMATEX    *lpwfxFormat;			 
    //
    // DVCOMPRESSIONINFO Structure End
    // Above this point must match the DVCOMPRESSIONINFO structure.
    // 
    DWORD           dwFramesPerBuffer;	
    DWORD           dwTrailFrames;		
    DWORD           dwTimeout;			
    DWORD           dwFrameLength;		 
    DWORD           dwFrame8Khz;		  
    DWORD           dwFrame11Khz;		
    DWORD           dwFrame22Khz;		 
    DWORD           dwFrame44Khz;		
    WORD            wInnerQueueSize;	
    WORD            wMaxHighWaterMark;
    BYTE            bMaxQueueSize;
    BYTE			bMinConnectType;	
    BYTE			bPadding1;	// For alignment
    BYTE			bPadding2;	// For alignment
} DVFULLCOMPRESSIONINFO, *LPDVFULLCOMPRESSIONINFO, *PDVFULLCOMPRESSIONINFO;

/////////////////////////////////////////////////////////////////////////////////////
// Interface definitions
//

#undef INTERFACE
#define INTERFACE IDPVCompressionProvider
//
// IDPVCompressionProvider
//
// This interface is exported by each DLL which provides compression services.
// It is used to enumerate the compression types available with a DLL and/or
// create a compressor/decompressor for a specified type.
//
// I propose there will be two providers:
//
// DPVACM.DLL - Provides these services for ACM based drivers.  It will read
//              the types it supports from the registry and can therefore be
// 				extended with new types as ACM drivers become available
//				CLSID_DPVACM
// 
// DPVVOX.DLL - Provides these services for Voxware. 
//
DECLARE_INTERFACE_( IDPVCompressionProvider, IUnknown )
{
    
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, PVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDPVCompressionProvider methods ***/
    
    // EnumCompressionTypes
    //
    // Enumerates compression types supported by this DLL.  Returns an array
    // of DVFULLCOMPRESSIONINFO structures describing the supported types.
    //
    STDMETHOD_(HRESULT, EnumCompressionTypes)( THIS_ PVOID, PDWORD, PDWORD, DWORD ) PURE;

    // IsCompressionSupported
    //
    // Quick query function for determing if the DLL supports a specified
    // compression type.
    //
    STDMETHOD_(HRESULT, IsCompressionSupported)( THIS_ GUID ) PURE;

    // CreateCompressor
    //
    // Create a IDPVConverter object which converts from the specified uncompressed
    // format to the specified compression format.
    //
    STDMETHOD_(HRESULT, CreateCompressor)( THIS_ LPWAVEFORMATEX, GUID, PDPVCOMPRESSOR *, DWORD ) PURE;

    // CreateDeCompressor
    //
    // Creates a IDPVConveter object which converts from the specified format to 
    // the specified uncompressed format.
    //
    STDMETHOD_(HRESULT, CreateDeCompressor)( THIS_ GUID, LPWAVEFORMATEX, PDPVCOMPRESSOR *, DWORD ) PURE;    

    // GetCompressionInfo
    //
    // Retrieves the DVFULLCOMPRESSIONINFO structure for the specified compression
    // type.
    //
    STDMETHOD_(HRESULT, GetCompressionInfo)( THIS_ GUID, PVOID, PDWORD ) PURE;
};

#undef INTERFACE
#define INTERFACE IDPVCompressor
//
// IDPVCompressor
//
// This interface does the actual work of performing conversions for 
// DirectPlayVoice.  This can be instantiated on it's own and Initialized,
// ot created using the CreateCompressor/CreateDecompressor above.
//
DECLARE_INTERFACE_( IDPVCompressor, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, PVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDPVCompressor methods ***/
	// Initialize
	//
	// Initialize this object as a decompressor.
	//
    STDMETHOD_(HRESULT, InitDeCompress)( THIS_ GUID, LPWAVEFORMATEX ) PURE;

	// Initialize
	//
	// Initialize this object as a compressor
    STDMETHOD_(HRESULT, InitCompress)( THIS_ LPWAVEFORMATEX, GUID ) PURE;    

	// IsValid
	//
	// Returns TRUE in the LPBOOL param if this compression type is
	// available.
    STDMETHOD_(HRESULT, IsValid)( THIS_ LPBOOL ) PURE;

	// GetXXXXXX
	//
	// Functions used by the engine for sizing.
    STDMETHOD_(HRESULT, GetUnCompressedFrameSize)( THIS_ LPDWORD ) PURE;
    STDMETHOD_(HRESULT, GetCompressedFrameSize)( THIS_ LPDWORD ) PURE;
    STDMETHOD_(HRESULT, GetNumFramesPerBuffer)( THIS_ LPDWORD ) PURE;

	// Convert
	//
	// Perform actual conversion
	STDMETHOD_(HRESULT, Convert)( THIS_ LPVOID, DWORD, LPVOID, LPDWORD, BOOL ) PURE;  
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\old\woplays.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		woplays.cpp
 *  Content:
 *		This module contains the implementation of the CWaveOutPlaybackSubSystem  
 *		class.
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 09/20/99		rodtoll	Updated to check for out of memory conditions
 *
 ***************************************************************************/

#include "stdafx.h"
#include "woplays.h"
#include "woplayd.h"
#include "dndbg.h"
#include "wiutils.h"
#include "OSInd.h"

#define MODULE_ID WAVEOUTPLAYBACKSUBSYSTEM

// CWaveOutPlaybackSubSystem Constructor
//
// This is the constructor for the CWaveOutPlaybackSubSystem class.  It is 
// responisible for determining if the waveOUT subsystem is valid and if
// it is building a list of devices which are available through it.  It
// is also responsible for mapping between ARDID <--> waveOUT device IDs.
// (They are equivalent).
//
// Once this constructor has completed, you can check to see if the waveOUT
// subsystem is valid by checking the valid flag.  The waveOUT subsystem
// is considered invalid if it is not available or has 0 devices available.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CWaveOutPlaybackSubSystem::CWaveOutPlaybackSubSystem(): CAudioPlaybackSubSystem()
{
    unsigned int numDevices;
    WAVEOUTCAPS waveCaps;
    ARDeviceInfo *info;
	TCHAR tmpID[10];

	// Retrieve the # of waveOut devices
    numDevices = waveOutGetNumDevs();

	// Enumerate the waveOUT devices
    for( unsigned int deviceID = 0; deviceID < numDevices; deviceID++ )
    {
		// Check each deviceID, if it's valid, create an entry in the map
		// for it
        try
        {
            WAVEINCHECK( waveOutGetDevCaps( deviceID, &waveCaps, sizeof( WAVEOUTCAPS ) ) );
    
            info = new ARDeviceInfo;

            if( info == NULL )
            {
            	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to allocate device struct" );
            	continue;
            }

            info->m_deviceName = waveCaps.szPname ;
            info->m_emulated   = false;

			_ltot( deviceID, tmpID, 10 );

            DPFX(DPFPREP,  DVF_INFOLEVEL, "WOPS: Device %u valid", tmpID );

            m_deviceMap[(ARDID) deviceID] = info;
        }
        catch( WaveInException &wie )
        {
            DPFX(DPFPREP,  DVF_INFOLEVEL, wie.what() );
            DPFX(DPFPREP,  DVF_INFOLEVEL, "WOPS: Device %u INVALID", tmpID );
        }
    }

	// If there are no available devices, mark the subsystem as 
	// invalid.
    if( GetNumDevices() == 0 )
    {
        m_valid = false;
        return;
    }

    m_valid = true;
}

// CleanupDeviceMap
//
// This function cleans up the memory allocated by the
// the device map within the object.  This should not
// be called directly by the user only by the class
// itself.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
void CWaveOutPlaybackSubSystem::CleanupDeviceMap()
{
    DeviceMapIterator deviceIterator;

    deviceIterator = m_deviceMap.begin();

    while( deviceIterator != m_deviceMap.end() )
    {
        delete (*deviceIterator).second;
        deviceIterator++;
    }
}

// CWaveOutPlaybackSubSystem Destructor 
//
// This is the destructor for the CWaveOutPlaybackSubSystem class.
// It is responsible for cleaning up the maps and memory allocated
// by the object.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CWaveOutPlaybackSubSystem::~CWaveOutPlaybackSubSystem()
{
    CleanupDeviceMap();
}

// IsValidDevice
//
// This function checks to see if the specified ARDID is valid
// for this subsystem. 
//
// Parameters:
// ARDID deviceID -
//		The ARDID for the device we wish to check.
//
// Returns:
// bool - 
//		Returns true if the specified ARDID is valid for
//		this subsystem, false otherwise.
//
bool CWaveOutPlaybackSubSystem::IsValidDevice( ARDID deviceID )
{
    DeviceMapIterator deviceIterator;

    deviceIterator = m_deviceMap.begin();

    if( deviceIterator != m_deviceMap.end() )
    {
        return true;
    }
    else
    {
        return false;
    }
}

// CreateDevice
//
// This function creates a new CWaveOutPlaybackDevice object attached
// to the specified ARDID (if valid) and returns a CAudioPlaybackDevice
// pointer to the new object.
//
// The newly created object is owned by the caller and must be freed
// by them.
//
// Parameters:
// ARDID deviceID -
//		The ARDID of the device which you wish to create an object
//		to manage.
//
// Returns:
// CAudioPlaybackDevice * -
//		A CAudioPLaybackDevice pointer to a newly created CAudioPlaybackDevice
//      object or NULL if the specified deviceID is invalid.
//
CAudioPlaybackDevice *CWaveOutPlaybackSubSystem::CreateDevice( ARDID deviceID )
{
	// Check to see if the device is valid, if it is, create
	// the object, otherwise return NULL.
    if( IsValidDevice( deviceID ) )
    {
        DeviceMapIterator deviceIterator;

        deviceIterator = m_deviceMap.find( deviceID );

        BFC_ASSERT( deviceIterator != m_deviceMap.end() );

        return new CWaveOutPlaybackDevice( deviceID, deviceID, this );
    }
    else
    {
        return NULL;
    }
}

// GetDeviceInfo
//
// This function retrieves information about a specified ARDID in this 
// subsystem. (If available). 
//
// Parameters:
// ARDID deviceID -
//		The ARDID for the device we wish to retrieve information about.
// ARDeviceInfo &device -
//		Reference to a structure where information about the requested 
//		devices will be placed.  This structure will not be touched if
//		the ARDID is not valid for this subsystem.
//
// Returns:
// bool - 
//		Returns true if the specified ARDID is valid for this subsystem
//		and device has been filled with information about it.  
//		false otherwise.
//
bool CWaveOutPlaybackSubSystem::GetDeviceInfo( ARDID deviceID, ARDeviceInfo &device )
{
    DeviceMapIterator deviceIterator;

    deviceIterator = m_deviceMap.find(deviceID);

    if( deviceIterator != m_deviceMap.end() )
    {
        device = *((*deviceIterator).second);
        return true;
    }
    else
    {
        return false;
    }
}

// GetNumDevices
//
// This function returns the number of valid devices detected in the
// waveOUT subsystem.
//
// Parameters:
// N/A
//
// Returns:
// unsigned int -
//		The number of devices available through this subsystem
//
unsigned int CWaveOutPlaybackSubSystem::GetNumDevices()
{
    return m_deviceMap.size();
}

// GetSubSystemName
//
// This function returns a pointer to a string identifying the
// type of playback subsystem being managed by this object.
//
// Parameters:
// N/A
//
// Returns:
// const TCHAR * -
//		Returns pointer to a string containing "WAVEOUT".
const TCHAR *CWaveOutPlaybackSubSystem::GetSubSystemName()
{
    return _T("WaveOut");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\misc\dpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:	debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-jan-95	craige	initial implementation
 *   03-mar-95	craige	added dprintf2
 *   31-mar-95	craige	add DPFInit to read WIN.INI for [DirectDraw] section;
 *			added dprintf3
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	made stand-alone
 *   18-jun-95	craige	use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed dprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
    #include "newdpf.c"
#else   //use old debug:

    #undef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
    #include "dpf.h"
    #include <stdarg.h>

    //#ifdef WINNT
    //int abs(int x)
    //{
    //    return x>=0?x:-x;
    //}
    //#endif

    #ifdef DEBUG

    #define USE_DDASSERT

    #ifndef START_STR
        #define START_STR	"DDRAW: "
    #endif
    #ifndef PROF_SECT
        #define PROF_SECT	"DirectDraw"
    #endif

    #define END_STR		"\r\n"

    HWND		hWndListBox;
    LONG		lDebugLevel = 0;

    /*
     * dumpStr
     */
    static void dumpStr( LPSTR str )
    {
        OutputDebugString( str );

        #ifdef DPF_HWND
	    if( hWndListBox != NULL )
	    {
	        if( !IsWindow( hWndListBox ) )
	        {
		    hWndListBox = NULL;
	        }
	    }
	    if( hWndListBox != NULL )
	    {
	        UINT	sel;
	        int	len;
	        len = strlen( str );
	        if( len > 0 )
	        {
		    if( str[len-1] == '\r' || str[len-1] == '\n' )
		    {
		        str[len-1] = 0;
		    }
		    if( len > 1 )
		    {
		        if( str[len-2] == '\r' || str[len-2] == '\n' )
		        {
			    str[len-2] = 0;
		        }
		    }
	        }
	        SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
	        sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
	        if( sel != LB_ERR )
	        {
		    SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
	        }
	    }
        #endif

    } /* dumpStr */

    /*
     * dprintf
     */
    void cdecl dprintf( UINT lvl, LPSTR szFormat, ...)
    {
        char 	str[256];
        //char 	str2[256];

        BOOL	allow = FALSE;
        va_list ap;
        va_start(ap,szFormat);


        if( lDebugLevel < 0 )
        {
	    if(  (UINT) -lDebugLevel == lvl )
	    {
	        allow = TRUE;
	    }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
	    allow = TRUE;
        }

        if( allow )
        {
	    wsprintf( (LPSTR) str, START_STR );
            //GetModuleFileName(NULL,str2,256);
            //if (strrchr(str2,'\\'))
            //    wsprintf(str+strlen(str),"%12s",strrchr(str2,'\\')+1);
            //strcat(str,":");
	    wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

	    lstrcat( (LPSTR) str, END_STR );
	    dumpStr( str );
        }

        va_end(ap);
    } /* dprintf */

    /*
     * DPFInit
     */
    void DPFInit( void )
    {
        lDebugLevel = GetProfileInt( PROF_SECT, "debug", 0 );

    } /* DPFInit */

    #ifdef USE_DDASSERT

    /*
     * NOTE: I don't want to get into error checking for buffer overflows when
     * trying to issue an assertion failure message. So instead I just allocate
     * a buffer that is "bug enough" (I know, I know...)
     */
    #define ASSERT_BUFFER_SIZE   512
    #define ASSERT_BANNER_STRING "************************************************************"
    #define ASSERT_BREAK_SECTION "BreakOnAssert"
    #define ASSERT_BREAK_DEFAULT FALSE
    #define ASSERT_MESSAGE_LEVEL 0

    void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
    {
        char buffer[ASSERT_BUFFER_SIZE];

        /*
         * Build the debug stream message.
         */
        wsprintf( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

        /*
         * Actually issue the message. These messages are considered error level
         * so they all go out at error level priority.
         */
        dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
        dprintf( ASSERT_MESSAGE_LEVEL, buffer );
        dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

        /*
         * Should we drop into the debugger?
         */
        if( GetProfileInt( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
        {
	    /*
	     * Into the debugger we go...
	     */
	    DEBUG_BREAK();
        }
    }

    #endif /* USE_DDASSERT */

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\inc\dvoice.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvoice.h
 *  Content:    DirectPlayVoice include file
//@@BEGIN_MSINTERNAL
 *  History:
 *  Date        By          Reason
 *  =====       =======     ==================================================
 *  07/01/99    rodtoll     created
 *  07/22/99    rodtoll     Added new error messages for server object
 *  08/25/99    rodtoll     Updated to use new GUID based compression selection
 *  08/26/99    rodtoll     Updated C/C++ macros.
 *  08/30/99    rodtoll     Added timeout error code
 *                          Added host migration message ID
 *  09/02/99    pnewson     Added IDirectPlayVoiceSetup interface
 *  09/07/99    rodtoll     Fixed C macros and added IDirectPlayVoicePlugin interface
 *              rodtoll     Moved settarget message id to public header, added
 *                          new 3d-related error codes.
 *  09/08/99    rodtoll     Updated for new compression structure
 *  09/10/99    rodtoll     Redefined hosting error codes to be unique
 *  09/13/99    rodtoll     Added GUIDs for default capture/playback devices
 *  09/20/99    rodtoll     New error messages, DVNOTIFYPERIOD_MAXPERIOD
 *  09/29/99    rodtoll     Added new flags/members for voice suppression
 *  10/15/99    rodtoll     Mapped default system devices to NULL
 *  10/19/99    rodtoll     Renamed to dpvoice.h
 *  10/20/99    rodtoll     Fix: Bug #114218 : Added new error code
 *  10/25/99    rodtoll     Fix: Bug #114682 : Removing password member of session desc
 *              rodtoll     Start of move from LPs to Ps for pointers
 *  10/27/99    pnewson     Added DVCLIENTCONFIG_AUTOVOLUMERESET flag for Bug #113936
 *              rodtoll     Fix: Bug #113745: Updated facility code
 *  10/28/99    pnewson     Bug #114176 updated DVSOUNDDEVICECONFIG struct
 *  11/12/99    rodtoll     Added new flags for echo suppression and waveIN/waveOut
 *                          usage control.
 *  11/17/99    rodtoll     Fix: Bug #116440 - Remove unused flags
 *              rodtoll     Fix: Bug #119584 - Rename FACDN to FACDPV
 *  11/23/99    rodtoll     Updated w/better error codes for transport errors
 *  12/06/99    rodtoll     Fix: Bug #121054 Integration of new dsound 7.1 bits
 *                          Added flags to control capture focus behaviour
 *  12/16/99    rodtoll     Removed voice suppression code
 *              rodtoll     Fix: Bug #119584 Renamed run setup error
 *              rodtoll     Fix: Bug #117405 3D Sound APIs misleading
 *              rodtoll     Fix: Bug #122629 Added flag to control host migration
 *  12/01/99    pnewson     removed our default device guids, since dsound now has them
 *                          added DVINPUTLEVEL_MIN, DVINPUTLEVEL_MAX
 *  01/13/00    aarono      added SendSpeechEx to IDirectPlayVoiceTransport
 *  01/14/2000  rodtoll     Removed DVID_NOTARGET
 *              rodtoll     Removed DVMSGID_STARTSESSIONRESULT / DVMSGID_STOPSESSIONRESULT
 *                          (Collapsed other message IDs)
 *              rodtoll     Updated callback function prototype for new callback format
 *              rodtoll     Renamed Get/SetTransmitTarget --> Get/SetTransmitTargets and
 *                          updated parameter list to match new format
 *              rodtoll     Added GetSoundDeviceConfig function to client interface
 *              rodtoll     Added DVMSG_ structures for callback messages.
 *  01/20/2000  rodtoll     Removed dplay.h from header
 *              rodtoll     Added new members to the Transport interface
 *  01/21/2000  pnewson     Added DVSOUNDCONFIG_TESTMODE
 *                          Added DVRECORDVOLUME_LAST
 *                          Fixed conflicted error code for DVERR_CHILDPROCESSFAILED
 *  01/25/2000  pnewson     Added DVFLAGS_WAVEIDS
 *                          Fixed IDirectPlayVoiceSetup_CheckAudioSetup macro
 *  01/25/2000  rodtoll     Exposed DVCLIENTCONFIG_ECHOSUPPRESSION
 *              rodtoll     Fixed C macros for member calls
 *              rodtoll     Fixed NotifyEvent call to add LPVOID to call
 *  01/27/2000  rodtoll     Bug #129934 - Added DSBUFFERDESCs to calls
 *  01/31/2000  pnewson     changed sensitivity range to match input level range
 *  02/08/2000  rodtoll     Bug #131496 - Selecting DVTHRESHOLD_DEFAULT results in voice
 *                          never being detected
 *  03/29/2000	rodtoll		Bug #30957 - Added new flag to control conv quality -- DVSOUNDCONFIG_SETCONVERSIONQUALITY
 *				rodtoll		Bug #30819 - Restored DX8 CLSID to match DX7.1's, but changed IIDs for Client/Server.
 *				rodtoll		Bug #31000 - Fixed incorrect # of params to C macros for interface
 *  03/29/2000	pnewson		Added DVFLAGS_ALLOWBACK
 *  04/05/2000  rodtoll     Updated to allow pointers through notify.
 *              rodtoll     Added DVEVENT_BUFFERRETURN event type for notification interface
 *              rodtoll     Updated Advise to have interface specify if it's a client or server when advising/unadvising
 *                          Bug #32179 - Registering more then one server/and/or/client
 *  04/11/2000  rodtoll     Moved DPVCTGUID_DEFAULT out of msinternal
 *  05/03/2000  rodtoll     Bug #33640 - CheckAudioSetup takes GUID * instead of const GUID * 
 *  06/07/2000	rodtoll		Bug #34383 Must provide CLSID for each IID to fix issues with Whistler
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 *  06/15/2000  rodtoll     Bug #36590 - Renamed macros to match new interface name
 *  06/21/2000	rodtoll		Bug #35767 - Implemented ability to use effects on voice buffers
 *							Replaced DSBUFFERDESC with DIRECTSOUNDBUFFERS
 *							Added DVERR_INVALIDBUFFER return code.
 *  06/23/2000	rodtoll		Bug #37556 - Hexify the DPVERR codes
 *  08/21/2000	rodtoll		Bug #42786 - Obsolete interface names in dvoice.h
 *  08/31/2000 	rodtoll	Bug #43804 - DVOICE: dwSensitivity structure member is confusing - should be dwThreshold 
 *  01/22/2001	rodtoll	WINBUG #288437 - IA64 Pointer misalignment due to wire packets 
 *  03/17/2001	rmt		WINBUG #342420 - Commented out create functions  
 * 	04/06/2001	kareemc	Added Voice Defense
 *
 //@@END_MSINTERNAL
 ***************************************************************************/

#ifndef __DVOICE__
#define __DVOICE__

#include <ole2.h>			// for DECLARE_INTERFACE and HRESULT
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "dsound.h"

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************
 *
 * DirectPlayVoice CLSIDs
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
// Provided for compatibility with stand-alone and Millenium.
//
// Only VoiceClient/VoiceSetup and VoiceServer can be created from this CLSID.
// {948CE83B-C4A2-44b3-99BF-279ED8DA7DF5}
DEFINE_GUID(CLSID_DirectPlayVoice, 
0x948ce83b, 0xc4a2, 0x44b3, 0x99, 0xbf, 0x27, 0x9e, 0xd8, 0xda, 0x7d, 0xf5);

#define CLSID_DIRECTPLAYVOICE           CLSID_DirectPlayVoice
 //@@END_MSINTERNAL

// {B9F3EB85-B781-4ac1-8D90-93A05EE37D7D}
DEFINE_GUID(CLSID_DirectPlayVoiceClient, 
0xb9f3eb85, 0xb781, 0x4ac1, 0x8d, 0x90, 0x93, 0xa0, 0x5e, 0xe3, 0x7d, 0x7d);

// {D3F5B8E6-9B78-4a4c-94EA-CA2397B663D3}
DEFINE_GUID(CLSID_DirectPlayVoiceServer, 
0xd3f5b8e6, 0x9b78, 0x4a4c, 0x94, 0xea, 0xca, 0x23, 0x97, 0xb6, 0x63, 0xd3);

// {0F0F094B-B01C-4091-A14D-DD0CD807711A}
DEFINE_GUID(CLSID_DirectPlayVoiceTest, 
0xf0f094b, 0xb01c, 0x4091, 0xa1, 0x4d, 0xdd, 0xc, 0xd8, 0x7, 0x71, 0x1a);

/****************************************************************************
 *
 * DirectPlayVoice Interface IIDs
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL

// {660CECA7-1A48-42f1-BAF3-04C183DF87DB}
DEFINE_GUID(IID_IDirectPlayVoiceNotify, 
0x660ceca7, 0x1a48, 0x42f1, 0xba, 0xf3, 0x4, 0xc1, 0x83, 0xdf, 0x87, 0xdb);

// {D7852974-BBB9-49cb-9162-6A66CDED8EC7}
DEFINE_GUID(IID_IDirectPlayVoiceTransport, 
0xd7852974, 0xbbb9, 0x49cb, 0x91, 0x62, 0x6a, 0x66, 0xcd, 0xed, 0x8e, 0xc7);

//@@END_MSINTERNAL

// {1DFDC8EA-BCF7-41d6-B295-AB64B3B23306}
DEFINE_GUID(IID_IDirectPlayVoiceClient, 
0x1dfdc8ea, 0xbcf7, 0x41d6, 0xb2, 0x95, 0xab, 0x64, 0xb3, 0xb2, 0x33, 0x6);

// {FAA1C173-0468-43b6-8A2A-EA8A4F2076C9}
DEFINE_GUID(IID_IDirectPlayVoiceServer, 
0xfaa1c173, 0x468, 0x43b6, 0x8a, 0x2a, 0xea, 0x8a, 0x4f, 0x20, 0x76, 0xc9);

// {D26AF734-208B-41da-8224-E0CE79810BE1}
DEFINE_GUID(IID_IDirectPlayVoiceTest,
0xd26af734, 0x208b, 0x41da, 0x82, 0x24, 0xe0, 0xce, 0x79, 0x81, 0xb, 0xe1);

/****************************************************************************
 *
 * DirectPlayVoice Compression Type GUIDs
 *
 ****************************************************************************/

// MS-ADPCM 32.8 kbit/s
//
// {699B52C1-A885-46a8-A308-97172419ADC7}
DEFINE_GUID(DPVCTGUID_ADPCM,
0x699b52c1, 0xa885, 0x46a8, 0xa3, 0x8, 0x97, 0x17, 0x24, 0x19, 0xad, 0xc7);

// Microsoft GSM 6.10 13 kbit/s
//
// {24768C60-5A0D-11d3-9BE4-525400D985E7}
DEFINE_GUID(DPVCTGUID_GSM,
0x24768c60, 0x5a0d, 0x11d3, 0x9b, 0xe4, 0x52, 0x54, 0x0, 0xd9, 0x85, 0xe7);

// MS-PCM 64 kbit/s
// 
// {8DE12FD4-7CB3-48ce-A7E8-9C47A22E8AC5}
DEFINE_GUID(DPVCTGUID_NONE,
0x8de12fd4, 0x7cb3, 0x48ce, 0xa7, 0xe8, 0x9c, 0x47, 0xa2, 0x2e, 0x8a, 0xc5);

// Voxware SC03 3.2kbit/s
//
// {7D82A29B-2242-4f82-8F39-5D1153DF3E41}
DEFINE_GUID(DPVCTGUID_SC03,
0x7d82a29b, 0x2242, 0x4f82, 0x8f, 0x39, 0x5d, 0x11, 0x53, 0xdf, 0x3e, 0x41);

// Voxware SC06 6.4kbit/s
//
// {53DEF900-7168-4633-B47F-D143916A13C7}
DEFINE_GUID(DPVCTGUID_SC06,
0x53def900, 0x7168, 0x4633, 0xb4, 0x7f, 0xd1, 0x43, 0x91, 0x6a, 0x13, 0xc7);

// TrueSpeech(TM) 8.6 kbit/s
//
// {D7954361-5A0B-11d3-9BE4-525400D985E7}
DEFINE_GUID(DPVCTGUID_TRUESPEECH,
0xd7954361, 0x5a0b, 0x11d3, 0x9b, 0xe4, 0x52, 0x54, 0x0, 0xd9, 0x85, 0xe7);

// Voxware VR12 1.4kbit/s
//
// {FE44A9FE-8ED4-48bf-9D66-1B1ADFF9FF6D}
DEFINE_GUID(DPVCTGUID_VR12,
0xfe44a9fe, 0x8ed4, 0x48bf, 0x9d, 0x66, 0x1b, 0x1a, 0xdf, 0xf9, 0xff, 0x6d);

// Define the default compression type
#define DPVCTGUID_DEFAULT	DPVCTGUID_SC03

/****************************************************************************
 *
 * DirectPlayVoice Interface Pointer definitions
 *
 ****************************************************************************/

typedef struct IDirectPlayVoiceClient FAR *LPDIRECTPLAYVOICECLIENT, *PDIRECTPLAYVOICECLIENT;
typedef struct IDirectPlayVoiceServer FAR *LPDIRECTPLAYVOICESERVER, *PDIRECTPLAYVOICESERVER;
typedef struct IDirectPlayVoiceTest FAR *LPDIRECTPLAYVOICETEST, *PDIRECTPLAYVOICETEST;
//@@BEGIN_MSINTERNAL
typedef struct IDirectPlayVoiceNotify FAR *LPDIRECTPLAYVOICENOTIFY, *PDIRECTPLAYVOICENOTIFY;
typedef struct IDirectPlayVoiceTransport FAR *LPDIRECTPLAYVOICETRANSPORT, *PDIRECTPLAYVOICETRANSPORT;
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DirectPlayVoice Callback Functions
 *
 ****************************************************************************/
typedef HRESULT (FAR PASCAL *PDVMESSAGEHANDLER)(
    PVOID   pvUserContext,
    DWORD   dwMessageType,
    LPVOID  lpMessage
);

typedef PDVMESSAGEHANDLER LPDVMESSAGEHANDLER;

/****************************************************************************
 *
 * DirectPlayVoice Datatypes (Non-Structure / Non-Message)
 *
 ****************************************************************************/

typedef DWORD DVID, *LPDVID, *PDVID;

/****************************************************************************
 *
 * DirectPlayVoice Message Types
 *
 ****************************************************************************/

#define DVMSGID_BASE                        0x0000

#define DVMSGID_MINBASE                     (DVMSGID_CREATEVOICEPLAYER)
#define DVMSGID_CREATEVOICEPLAYER           (DVMSGID_BASE+0x0001)
#define DVMSGID_DELETEVOICEPLAYER           (DVMSGID_BASE+0x0002)
#define DVMSGID_SESSIONLOST                 (DVMSGID_BASE+0x0003)
#define DVMSGID_PLAYERVOICESTART            (DVMSGID_BASE+0x0004)
#define DVMSGID_PLAYERVOICESTOP             (DVMSGID_BASE+0x0005)
#define DVMSGID_RECORDSTART                 (DVMSGID_BASE+0x0006)
#define DVMSGID_RECORDSTOP                  (DVMSGID_BASE+0x0007)
#define DVMSGID_CONNECTRESULT               (DVMSGID_BASE+0x0008)
#define DVMSGID_DISCONNECTRESULT            (DVMSGID_BASE+0x0009)
#define DVMSGID_INPUTLEVEL                  (DVMSGID_BASE+0x000A)
#define DVMSGID_OUTPUTLEVEL                 (DVMSGID_BASE+0x000B)
#define DVMSGID_HOSTMIGRATED                (DVMSGID_BASE+0x000C)
#define DVMSGID_SETTARGETS                  (DVMSGID_BASE+0x000D)
#define DVMSGID_PLAYEROUTPUTLEVEL           (DVMSGID_BASE+0x000E)
#define DVMSGID_LOSTFOCUS                   (DVMSGID_BASE+0x0010)
#define DVMSGID_GAINFOCUS                   (DVMSGID_BASE+0x0011)
#define DVMSGID_LOCALHOSTSETUP				(DVMSGID_BASE+0x0012)
#define DVMSGID_MAXBASE                     (DVMSGID_LOCALHOSTSETUP)

/****************************************************************************
 *
 * DirectPlayVoice Constants
 *
 ****************************************************************************/

//
// Buffer Aggresiveness Value Ranges
//
#define DVBUFFERAGGRESSIVENESS_MIN          0x00000001
#define DVBUFFERAGGRESSIVENESS_MAX          0x00000064
#define DVBUFFERAGGRESSIVENESS_DEFAULT      0x00000000

// 
// Buffer Quality Value Ranges
//
#define DVBUFFERQUALITY_MIN                 0x00000001
#define DVBUFFERQUALITY_MAX                 0x00000064
#define DVBUFFERQUALITY_DEFAULT             0x00000000

#define DVID_SYS                0

//
// Used to identify the session host in client/server
//
#define DVID_SERVERPLAYER       1

//
// Used to target all players
//
#define DVID_ALLPLAYERS         0

//
// Used to identify the main buffer
//
#define DVID_REMAINING          0xFFFFFFFF

// 
// Input level range
//
#define DVINPUTLEVEL_MIN                    0x00000000
#define DVINPUTLEVEL_MAX                    0x00000063	// 99 decimal

#define DVNOTIFYPERIOD_MINPERIOD            20


#define DVPLAYBACKVOLUME_DEFAULT            DSBVOLUME_MAX

#define DVRECORDVOLUME_LAST                 0x00000001


//
// Use the default value
//
#define DVTHRESHOLD_DEFAULT               0xFFFFFFFF

//
// Threshold Ranges
//
#define DVTHRESHOLD_MIN                   0x00000000
#define DVTHRESHOLD_MAX                   0x00000063	// 99 decimal

//
// Threshold field is not used 
//
#define DVTHRESHOLD_UNUSED                0xFFFFFFFE

//
// Session Types
//
#define DVSESSIONTYPE_PEER                  0x00000001
#define DVSESSIONTYPE_MIXING                0x00000002
#define DVSESSIONTYPE_FORWARDING            0x00000003
#define DVSESSIONTYPE_ECHO                  0x00000004
//@@BEGIN_MSINTERNAL
#define DVSESSIONTYPE_MAX						0x00000005
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DirectPlayVoice Flags
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
// The flag to disable the config check in Connect
// -- required by the setup program!
#define DVFLAGS_NOQUERY                     0x00000004
#define DVCLIENTCONFIG_AUTOVOLUMERESET      0x00000080
// Used to indicate that waveids are being passed
// to CheckAudioSetup instead of guids. Used by the
// control panel's Voice Test button.
#define DVFLAGS_WAVEIDS                     0x80000000
// The flag to put the recording subsystem into
// test mode. Used by the setup/test program.
#define DVSOUNDCONFIG_TESTMODE              0x80000000
//@@END_MSINTERNAL

// 
// Enable automatic adjustment of the recording volume
//
#define DVCLIENTCONFIG_AUTORECORDVOLUME     0x00000008

//
// Enable automatic voice activation
//
#define DVCLIENTCONFIG_AUTOVOICEACTIVATED   0x00000020

// 
// Enable echo suppression
//
#define DVCLIENTCONFIG_ECHOSUPPRESSION      0x08000000

// 
// Voice Activation manual mode
//
#define DVCLIENTCONFIG_MANUALVOICEACTIVATED 0x00000004

// 
// Only playback voices that have buffers created for them
//
#define DVCLIENTCONFIG_MUTEGLOBAL           0x00000010

// 
// Mute the playback
//
#define DVCLIENTCONFIG_PLAYBACKMUTE         0x00000002

//
// Mute the recording 
//
#define DVCLIENTCONFIG_RECORDMUTE           0x00000001

// 
// Complete the operation before returning
//
#define DVFLAGS_SYNC                        0x00000001

// 
// Just check to see if wizard has been run, and if so what it's results were
//
#define DVFLAGS_QUERYONLY                   0x00000002

//
// Shutdown the voice session without migrating the host
//
#define DVFLAGS_NOHOSTMIGRATE               0x00000008

// 
// Allow the back button to be enabled in the wizard
//
#define DVFLAGS_ALLOWBACK                   0x00000010

//
// Disable host migration in the voice session
//
#define DVSESSION_NOHOSTMIGRATION           0x00000001

// 
// Server controlled targetting
//
#define DVSESSION_SERVERCONTROLTARGET       0x00000002
//@@BEGIN_MSINTERNAL
#define DVSESSION_MAX							0x00000004
//@@END_MSINTERNAL

//
// Use DirectSound Normal Mode instead of priority 
//
#define DVSOUNDCONFIG_NORMALMODE            0x00000001

//
// Automatically select the microphone
//
#define DVSOUNDCONFIG_AUTOSELECT            0x00000002

// 
// Run in half duplex mode
//
#define DVSOUNDCONFIG_HALFDUPLEX            0x00000004

// 
// No volume controls are available for the recording device
//
#define DVSOUNDCONFIG_NORECVOLAVAILABLE     0x00000010

// 
// Disable capture sharing
//
#define DVSOUNDCONFIG_NOFOCUS               0x20000000

// 
// Set system conversion quality to high
//
#define DVSOUNDCONFIG_SETCONVERSIONQUALITY	0x00000008

//
// Enable strict focus mode
// 
#define DVSOUNDCONFIG_STRICTFOCUS           0x40000000

//
// Player is in half duplex mode
//
#define DVPLAYERCAPS_HALFDUPLEX             0x00000001

// 
// Specifies that player is the local player
//
#define DVPLAYERCAPS_LOCAL                  0x00000002
//@@BEGIN_MSINTERNAL
#define DVPLAYERCAPS_MAX                    0x00000004
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DirectPlayVoice Structures (Non-Message)
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL

// DVTRANSPORTINFO
//
typedef struct
{
    // = sizeof( DVTRANSPORTINFO )
    DWORD			dwSize;			
    // Combination of following flags:
    // DVTRANSPORT_MIGRATEHOST, DVTRANSPORT_MULTICAST
    // DVTRANSPORT_LOCALHOST
	DWORD			dwFlags;		
	// Session Type the transport is running.  One of:
	// DVTRANSPORT_SESSION_PEERTOPEER
	// DVTRANSPORT_SESSION_CLIENTSERVER
	DWORD			dwSessionType;	
	// ID of the player (Regular ID, not system) that
	// is the sesion host.
	DVID			dvidSessionHost;
	// ID of the local player (Regular ID, not system)
	DVID			dvidLocalID;	
	// Maximum # of players allowed in the session,
	// 0 = unlimited.
	DWORD			dwMaxPlayers;	
} DVTRANSPORTINFO, *LPDVTRANSPORTINFO, *PDVTRANSPORTINFO;
//@@END_MSINTERNAL

//
// DirectPlayVoice Caps
// (GetCaps / SetCaps)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    DWORD   dwFlags;                // Caps flags
} DVCAPS, *LPDVCAPS, *PDVCAPS;

//
// DirectPlayVoice Client Configuration
// (Connect / GetClientConfig)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    DWORD   dwFlags;                // Flags for client config (DVCLIENTCONFIG_...)
    LONG    lRecordVolume;          // Recording volume 
    LONG    lPlaybackVolume;        // Playback volume
    DWORD   dwThreshold;          // Voice Activation Threshold
    DWORD   dwBufferQuality;        // Buffer quality
    DWORD   dwBufferAggressiveness; // Buffer aggressiveness
    DWORD   dwNotifyPeriod;         // Period of notification messages (ms)
} DVCLIENTCONFIG, *LPDVCLIENTCONFIG, *PDVCLIENTCONFIG;

//
// DirectPlayVoice Compression Type Information
// (GetCompressionTypes)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    GUID    guidType;               // GUID that identifies this compression type
    LPWSTR  lpszName;               // String name of this compression type
    LPWSTR  lpszDescription;        // Description for this compression type
    DWORD   dwFlags;                // Flags for this compression type
    DWORD   dwMaxBitsPerSecond;		// Maximum # of bit/s this compression type uses
} DVCOMPRESSIONINFO, *LPDVCOMPRESSIONINFO, *PDVCOMPRESSIONINFO;

//
// DirectPlayVoice Session Description
// (Host / GetSessionDesc)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    DWORD   dwFlags;                // Session flags (DVSESSION_...)
    DWORD   dwSessionType;          // Session type (DVSESSIONTYPE_...)
    GUID    guidCT;                 // Compression Type to use
    DWORD   dwBufferQuality;        // Buffer quality
    DWORD   dwBufferAggressiveness; // Buffer aggresiveness
} DVSESSIONDESC, *LPDVSESSIONDESC, *PDVSESSIONDESC;

// 
// DirectPlayVoice Client Sound Device Configuration
// (Connect / GetSoundDeviceConfig)
//
typedef struct
{
    DWORD                   dwSize;                 // Size of this structure
    DWORD                   dwFlags;                // Flags for sound config (DVSOUNDCONFIG_...)
    GUID                    guidPlaybackDevice;     // GUID of the playback device to use
    LPDIRECTSOUND           lpdsPlaybackDevice;     // DirectSound Object to use (optional)
    GUID                    guidCaptureDevice;      // GUID of the capture device to use
    LPDIRECTSOUNDCAPTURE    lpdsCaptureDevice;      // DirectSoundCapture Object to use (optional)
    HWND                    hwndAppWindow;          // HWND of your application's top-level window
    LPDIRECTSOUNDBUFFER     lpdsMainBuffer;         // DirectSoundBuffer to use for playback (optional)
    DWORD                   dwMainBufferFlags;      // Flags to pass to Play() on the main buffer
    DWORD                   dwMainBufferPriority;   // Priority to set when calling Play() on the main buffer
} DVSOUNDDEVICECONFIG, *LPDVSOUNDDEVICECONFIG, *PDVSOUNDDEVICECONFIG;

/****************************************************************************
 *
 * DirectPlayVoice message handler call back structures
 *
 ****************************************************************************/

//
// Result of the Connect() call.  (If it wasn't called Async)
// (DVMSGID_CONNECTRESULT)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;                       // Result of the Connect() call
} DVMSG_CONNECTRESULT, *LPDVMSG_CONNECTRESULT, *PDVMSG_CONNECTRESULT;

//
// A new player has entered the voice session
// (DVMSGID_CREATEVOICEPLAYER)
// 
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidPlayer;                     // DVID of the player who joined
    DWORD   dwFlags;                        // Player flags (DVPLAYERCAPS_...)
    PVOID	pvPlayerContext;                // Context value for this player (user set)
} DVMSG_CREATEVOICEPLAYER, *LPDVMSG_CREATEVOICEPLAYER, *PDVMSG_CREATEVOICEPLAYER;

//
// A player has left the voice session
// (DVMSGID_DELETEVOICEPLAYER)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidPlayer;                     // DVID of the player who left
    PVOID	pvPlayerContext;                // Context value for the player
} DVMSG_DELETEVOICEPLAYER, *LPDVMSG_DELETEVOICEPLAYER, *PDVMSG_DELETEVOICEPLAYER;

//
// Result of the Disconnect() call.  (If it wasn't called Async)
// (DVMSGID_DISCONNECTRESULT)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;                       // Result of the Disconnect() call
} DVMSG_DISCONNECTRESULT, *LPDVMSG_DISCONNECTRESULT, *PDVMSG_DISCONNECTRESULT;

// 
// The voice session host has migrated.
// (DVMSGID_HOSTMIGRATED) 
//
typedef struct
{
    DWORD                   dwSize;         // Size of this structure
    DVID                    dvidNewHostID;  // DVID of the player who is now the host
    LPDIRECTPLAYVOICESERVER pdvServerInterface;
                                            // Pointer to the new host object (if local player is now host)
} DVMSG_HOSTMIGRATED, *LPDVMSG_HOSTMIGRATED, *PDVMSG_HOSTMIGRATED;

//
// The current input level / recording volume on the local machine
// (DVMSGID_INPUTLEVEL)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Current peak level of the audio
    LONG    lRecordVolume;                  // Current recording volume
    PVOID	pvLocalPlayerContext;           // Context value for the local player
} DVMSG_INPUTLEVEL, *LPDVMSG_INPUTLEVEL, *PDVMSG_INPUTLEVEL;

//
// The local client is about to become the new host
// (DVMSGID_LOCALHOSTSETUP)
//
typedef struct
{
	DWORD				dwSize;             // Size of this structure
	PVOID				pvContext;			// Context value to be passed to Initialize() of new host object
	PDVMESSAGEHANDLER	pMessageHandler;	// Message handler to be used by new host object
} DVMSG_LOCALHOSTSETUP, *LPDVMSG_LOCALHOSTSETUP, *PDVMSG_LOCALHOSTSETUP;

//
// The current output level for the combined output of all incoming streams.
// (DVMSGID_OUTPUTLEVEL)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Current peak level of the output
    LONG    lOutputVolume;                  // Current playback volume
    PVOID	pvLocalPlayerContext;           // Context value for the local player
} DVMSG_OUTPUTLEVEL, *LPDVMSG_OUTPUTLEVEL, *PDVMSG_OUTPUTLEVEL;

//
// The current peak level of an individual player's incoming audio stream as it is
// being played back.
// (DVMSGID_PLAYEROUTPUTLEVEL)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;                   // DVID of the player
    DWORD   dwPeakLevel;                    // Peak level of the player's stream
    PVOID	pvPlayerContext;                // Context value for the player
} DVMSG_PLAYEROUTPUTLEVEL, *LPDVMSG_PLAYEROUTPUTLEVEL, *PDVMSG_PLAYEROUTPUTLEVEL;

// 
// An audio stream from the specified player has started playing back on the local client.
// (DVMSGID_PLAYERVOICESTART).
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;             // DVID of the Player 
    PVOID	pvPlayerContext;                // Context value for this player
} DVMSG_PLAYERVOICESTART, *LPDVMSG_PLAYERVOICESTART, *PDVMSG_PLAYERVOICESTART;

//
// The audio stream from the specified player has stopped playing back on the local client.
// (DVMSGID_PLAYERVOICESTOP)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;             // DVID of the player
    PVOID	pvPlayerContext;                // Context value for this player
} DVMSG_PLAYERVOICESTOP, *LPDVMSG_PLAYERVOICESTOP, *PDVMSG_PLAYERVOICESTOP;

// 
// Transmission has started on the local machine
// (DVMSGID_RECORDSTART)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Peak level that caused transmission to start
    PVOID	pvLocalPlayerContext;           // Context value for the local player
} DVMSG_RECORDSTART, *LPDVMSG_RECORDSTART, *PDVMSG_RECORDSTART;

// 
// Transmission has stopped on the local machine
// (DVMSGID_RECORDSTOP)
// 
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Peak level that caused transmission to stop
    PVOID	pvLocalPlayerContext;           // Context value for the local player
} DVMSG_RECORDSTOP, *LPDVMSG_RECORDSTOP, *PDVMSG_RECORDSTOP;

// 
// The voice session has been lost
// (DVMSGID_SESSIONLOST)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;	                    // Reason the session was disconnected
} DVMSG_SESSIONLOST, *LPDVMSG_SESSIONLOST, *PDVMSG_SESSIONLOST;

//
// The target list has been updated for the local client
// (DVMSGID_SETTARGETS)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwNumTargets;                   // # of targets 
    PDVID   pdvidTargets;                   // An array of DVIDs specifying the current targets
} DVMSG_SETTARGETS, *LPDVMSG_SETTARGETS, *PDVMSG_SETTARGETS;
 
//@@BEGIN_MSINTERNAL

/****************************************************************************
 *
 * DirectPlayVoice Transport Defines / Types / Constants -- MS INTERNAL
 *
 ****************************************************************************/

// Use waveOUT instead of DS
#define DVSOUNDCONFIG_FORCEWAVEOUT          0x10000000
#define DVSOUNDCONFIG_ALLOWWAVEOUT	 	    0x20000000

// Use waveIN instead of DSC
#define DVSOUNDCONFIG_FORCEWAVEIN		    0x40000000
#define DVSOUNDCONFIG_ALLOWWAVEIN		    0x80000000

// Transport session is peer-to-peer
#define DVTRANSPORT_SESSION_PEERTOPEER	    0x00000001

// Transport session is client/server
#define DVTRANSPORT_SESSION_CLIENTSERVER    0x00000002

// Host can migrate
#define DVTRANSPORT_MIGRATEHOST				0x00000001

// Multicast optimizations are enabled
#define DVTRANSPORT_MULTICAST				0x00000002

// The local player is the host of the session
#define DVTRANSPORT_LOCALHOST				0x00000004

// Send the message guaranteed
#define DVTRANSPORT_SEND_GUARANTEED			0x00000001
#define DVTRANSPORT_SEND_SYNC				0x00000002

#define DVPEFLAGS_FIRSTPLAYER				0x00000001

#define DVTRANSPORT_OBJECTTYPE_SERVER       0x00000001
#define DVTRANSPORT_OBJECTTYPE_CLIENT       0x00000002
#define DVTRANSPORT_OBJECTTYPE_BOTH         (DVTRANSPORT_OBJECTTYPE_SERVER | DVTRANSPORT_OBJECTTYPE_CLIENT)

typedef struct _DVTRANSPORT_BUFFERDESC
{
    DWORD   dwBufferSize;
    PBYTE   pBufferData;
    LONG    lRefCount;
    PVOID   pvContext;
    DWORD   dwObjectType;
    DWORD   dwFlags;
} DVTRANSPORT_BUFFERDESC, *PDVTRANSPORT_BUFFERDESC;

/*
 * DIRECTVOICENOTIFY DEFINES
 *
 * Used to identify the type of notification in calls
 * to IDirectPlayVoiceNotify::NotifyEvent
 */

// No longer used
#define DVEVENT_STARTSESSION				0x00000001

// If the transport session is lost or shutdown
#define DVEVENT_STOPSESSION					0x00000002

// A player was added to the system, 
// Param1 = DVID of new player
// Param2 = Player context (set by handler and then returned)
#define DVEVENT_ADDPLAYER					0x00000003

// A player disconnected.  
// Param1 = DVID of disconnected player
// Param1 = Player context
#define DVEVENT_REMOVEPLAYER				0x00000004

// A group was created.  Param1 = DVID of created group
#define DVEVENT_CREATEGROUP					0x00000005

// A group was deleted.  Param1 = DVID of deleted group
#define DVEVENT_DELETEGROUP					0x00000006

// Player was added to a group.
// Param1 = DVID of group    Param2 = DVID of player
#define DVEVENT_ADDPLAYERTOGROUP			0x00000007

// Player was removed from the group
// Param1 = DVID of group    Param2 = DVID of player
#define DVEVENT_REMOVEPLAYERFROMGROUP		0x00000008

// Called when the host migrates
// Param1 = DVID of new host (player ID, not system ID)
#define DVEVENT_MIGRATEHOST					0x00000009

// Called when a buffer the voice layer has given
// the transport is completed.  
// Param1 = pointer to DVEVENTMSG_SENDCOMPLETE structure
// 
#define DVEVENT_SENDCOMPLETE                0x0000000A

typedef struct _DVEVENTMSG_SENDCOMPLETE
{
    LPVOID                  pvUserContext;
    HRESULT                 hrSendResult;
} DVEVENTMSG_SENDCOMPLETE, *PDVEVENTMSG_SENDCOMPLETE;

//@@END_MSINTERNAL


/****************************************************************************
 *
 * DirectPlayVoice Functions
 *
 ****************************************************************************/

/*
 * 
 * This function is no longer supported.  It is recommended that CoCreateInstance be used to create 
 * DirectPlay voice objects.  
 *
 * extern HRESULT WINAPI DirectPlayVoiceCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown); 
 *
 */

/****************************************************************************
 *
 * DirectPlay8 Application Interfaces
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlayVoiceClient
DECLARE_INTERFACE_( IDirectPlayVoiceClient, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, PVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;
    /*** IDirectPlayVoiceClient methods ***/
    STDMETHOD_(HRESULT, Initialize)   (THIS_ LPUNKNOWN, PDVMESSAGEHANDLER, PVOID, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, Connect)      (THIS_ PDVSOUNDDEVICECONFIG, PDVCLIENTCONFIG, DWORD ) PURE;
    STDMETHOD_(HRESULT, Disconnect)   (THIS_ DWORD ) PURE;
    STDMETHOD_(HRESULT, GetSessionDesc)(THIS_ PDVSESSIONDESC ) PURE;
    STDMETHOD_(HRESULT, GetClientConfig)(THIS_ PDVCLIENTCONFIG ) PURE;
    STDMETHOD_(HRESULT, SetClientConfig)(THIS_ PDVCLIENTCONFIG ) PURE;
    STDMETHOD_(HRESULT, GetCaps) 		(THIS_ PDVCAPS ) PURE;
    STDMETHOD_(HRESULT, GetCompressionTypes)( THIS_ PVOID, PDWORD, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, SetTransmitTargets)( THIS_ PDVID, DWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, GetTransmitTargets)( THIS_ PDVID, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, Create3DSoundBuffer)( THIS_ DVID, LPDIRECTSOUNDBUFFER, DWORD, DWORD, LPDIRECTSOUND3DBUFFER * ) PURE;
    STDMETHOD_(HRESULT, Delete3DSoundBuffer)( THIS_ DVID, LPDIRECTSOUND3DBUFFER * ) PURE;
    STDMETHOD_(HRESULT, SetNotifyMask)( THIS_ PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, GetSoundDeviceConfig)( THIS_ PDVSOUNDDEVICECONFIG, PDWORD ) PURE;
};

//@@BEGIN_MSINTERNAL
#undef INTERFACE
#define INTERFACE IDirectPlayVoiceNotify
DECLARE_INTERFACE_( IDirectPlayVoiceNotify, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, PVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlayVoiceNotify methods ***/

    // Initialize
    //
    // Initializes the DirectPlayVoice interface associated with this
    // interface.  During this call DirectPlayVoice will call
    // GetSessionInfo on the associated Transport interface.
    //
	STDMETHOD_(HRESULT,Initialize)(THIS ) PURE;

	// NotifyEvent
	//
	// Called when an event occurs that DirectPlayVoice needs to be informed
	// of.  See descriptions of DVEVENT_XXXXX for how the parameters are
	// used for each message.
	//
	// DWORD - Type of message (DVEVENT_XXXXXX)
	// DWORD - Param1
	// DWORD - Param2
	//
	STDMETHOD_(HRESULT,NotifyEvent)(THIS_ DWORD, DWORD_PTR, DWORD_PTR) PURE;

	// ReceiveSpeechMessage
	//
	// Called when a message is received by DirectPlay that is for
	// DirectPlayVoice.
	//
	// DVID - Source of the message
	// LPVOID - Pointer to message buffer
	// DWORD - Size of the received message
	//
	STDMETHOD_(HRESULT,ReceiveSpeechMessage)(THIS_ DVID, DVID, PVOID, DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectPlayVoiceTransport
DECLARE_INTERFACE_( IDirectPlayVoiceTransport, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, PVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
	/*** IDirectPlayVoiceTransport methods ***/

	// Advise
	//
	// Advises the transport to call us back via the interface passed in the
	// LLPUNKNOWN parameter.  QueryInterface on the LPUNKNOWN for a
	// IDirectPlayVoiceNotify.  Must call IDirectPlayVoiceNotify::INitialize
	// on the interface before returning.
	//
	// LPUNKNOWN - IUnknown interface for the IDirectPlayVoiceNotify to
	// 			   make notifications on.
	// DWORD - Voice Object Type (DVTRANSPORT_OBJECTTYPE_XXXX)
	//
	STDMETHOD_(HRESULT, Advise)		(THIS_ LPUNKNOWN, DWORD) PURE;

	// UnAdvise
	//
	// Tells the transport that we no longer need to be called back on our
	// notify interface.  The transport should Release the instance of the
	// notify interface that they have.
	//
	// DWORD - Voice Object Type (DVTRANSPORT_OBJECTTYPE_XXXX)
	//
	STDMETHOD_(HRESULT, UnAdvise)		(THIS_ DWORD) PURE;

	// IsGroupMember
	//
	// This function returns DP_OK if the specified user is a member of
	// the specified group.
	//
	// DVID - DVID of the group to check
	// DVID - DVID of the player
	//
	STDMETHOD_(HRESULT, IsGroupMember)(THIS_ DVID, DVID ) PURE;

	// SendSpeech
	//
	// Transmits a message from the specified user ID to the specified user ID.
	// (Speech specific).  Messages sent through this interface are always
	// sent ASYNC and if the DVTRANSPORT_SEND_GUARANTEED flag is specified
	// then the message MUST be sent guaranteed.
	//
	// DVID - ID of the player this will be from.
	// DVID - ID of the player this will be sent to.
	// LPVOID - Pointer to the data to send
	// DWORD - Size of the data to send, in bytes
	// LPVOID - User context for send
	// DWORD - FLags (Combination of DVTRANSPORT_SEND_GUARANTEED).
	//
	STDMETHOD_(HRESULT, SendSpeech)(THIS_ DVID, DVID, PDVTRANSPORT_BUFFERDESC, LPVOID, DWORD ) PURE;

	// GetSessionInfo
	//
	// Fills the passed structure with details on the session that is running
	// on the transport object.  See description of DVTRANSPORTINFO for details.
	//
	STDMETHOD_(HRESULT, GetSessionInfo)(THIS_ PDVTRANSPORTINFO ) PURE;

	// IsValidEntity
	//
	// Checks to see if specified user is valid player or group in session
	// DVID = ID of the entity to check
	// LPBOOL = Pointer to BOOL to place result.  TRUE for Valid Player/
	//          Group, FALSE if it is not.
	//
	// Not needed in Client/Server Mode
	STDMETHOD_(HRESULT, IsValidEntity)(THIS_ DVID, PBOOL ) PURE;

	// SendSpeechEx
	//
	// Transmits a message from the specified user ID to the specified user ID.
	// (Speech specific).  Messages sent through this interface are always
	// sent ASYNC and if the DVTRANSPORT_SEND_GUARANTEED flag is specified
	// then the message MUST be sent guaranteed.
	//
	// DVID - ID of the player this will be from.
	// DWORD - count on entries in (DVID *)[] array
	// LPDVID - Array of send targets
	// LPVOID - Pointer to the data to send
	// DWORD - Size of the data to send, in bytes
	// LPVOID - User context for send
	// DWORD - Flags (Combination of DVTRANSPORT_SEND_GUARANTEED).
	//
	STDMETHOD_(HRESULT, SendSpeechEx)(THIS_ DVID, DWORD, UNALIGNED DVID *, PDVTRANSPORT_BUFFERDESC, LPVOID, DWORD ) PURE;	

	// IsValidGroup
	//
	// Checks to see if the specified ID is a valid Group ID
	//
	// DVID = ID of the entity to check
	//
	STDMETHOD_(HRESULT, IsValidGroup)(THIS_ DVID, PBOOL ) PURE;

	// IsValidPlayer
	//
	// Checks to see if the specified ID is a valid Player ID
	//
	// DVID = ID of the entity to check
	//
	STDMETHOD_(HRESULT, IsValidPlayer)(THIS_ DVID, PBOOL ) PURE;	

};


//@@END_MSINTERNAL

#undef INTERFACE
#define INTERFACE IDirectPlayVoiceServer
DECLARE_INTERFACE_( IDirectPlayVoiceServer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlayVoiceServer methods ***/
    STDMETHOD_(HRESULT, Initialize)   (THIS_ LPUNKNOWN, PDVMESSAGEHANDLER, PVOID, LPDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, StartSession)  (THIS_ PDVSESSIONDESC, DWORD ) PURE;
    STDMETHOD_(HRESULT, StopSession)   (THIS_ DWORD ) PURE;
    STDMETHOD_(HRESULT, GetSessionDesc)(THIS_ PDVSESSIONDESC ) PURE;
    STDMETHOD_(HRESULT, SetSessionDesc)(THIS_ PDVSESSIONDESC ) PURE;
    STDMETHOD_(HRESULT, GetCaps) 		(THIS_ PDVCAPS ) PURE;
    STDMETHOD_(HRESULT, GetCompressionTypes)( THIS_ PVOID, PDWORD, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, SetTransmitTargets)( THIS_ DVID, PDVID, DWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, GetTransmitTargets)( THIS_ DVID, PDVID, PDWORD, DWORD ) PURE;
    STDMETHOD_(HRESULT, SetNotifyMask)( THIS_ PDWORD, DWORD ) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectPlayVoiceTest
DECLARE_INTERFACE_( IDirectPlayVoiceTest, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, PVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlayVoiceTest methods ***/
    STDMETHOD_(HRESULT, CheckAudioSetup) (THIS_ const GUID *,  const GUID * , HWND, DWORD ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlayVoiceClient_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceClient_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceClient_Release(p)                   (p)->lpVtbl->Release(p)

#define IDirectPlayVoiceClient_Initialize(p,a,b,c,d,e)      (p)->lpVtbl->Initialize(p,a,b,c,d,e)
#define IDirectPlayVoiceClient_Connect(p,a,b,c)             (p)->lpVtbl->Connect(p,a,b,c)
#define IDirectPlayVoiceClient_Disconnect(p,a)              (p)->lpVtbl->Disconnect(p,a)
#define IDirectPlayVoiceClient_GetSessionDesc(p,a)          (p)->lpVtbl->GetSessionDesc(p,a)
#define IDirectPlayVoiceClient_GetClientConfig(p,a)         (p)->lpVtbl->GetClientConfig(p,a)
#define IDirectPlayVoiceClient_SetClientConfig(p,a)         (p)->lpVtbl->SetClientConfig(p,a)
#define IDirectPlayVoiceClient_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectPlayVoiceClient_GetCompressionTypes(p,a,b,c,d) (p)->lpVtbl->GetCompressionTypes(p,a,b,c,d)
#define IDirectPlayVoiceClient_SetTransmitTargets(p,a,b,c)  (p)->lpVtbl->SetTransmitTargets(p,a,b,c)
#define IDirectPlayVoiceClient_GetTransmitTargets(p,a,b,c)  (p)->lpVtbl->GetTransmitTargets(p,a,b,c)
#define IDirectPlayVoiceClient_Create3DSoundBuffer(p,a,b,c,d,e)   (p)->lpVtbl->Create3DSoundBuffer(p,a,b,c,d,e)
#define IDirectPlayVoiceClient_Delete3DSoundBuffer(p,a,b)   (p)->lpVtbl->Delete3DSoundBuffer(p,a,b)
#define IDirectPlayVoiceClient_SetNotifyMask(p,a,b)         (p)->lpVtbl->SetNotifyMask(p,a,b)
#define IDirectPlayVoiceClient_GetSoundDeviceConfig(p,a,b)  (p)->lpVtbl->GetSoundDeviceConfig(p,a,b)

#define IDirectPlayVoiceServer_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceServer_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceServer_Release(p)                   (p)->lpVtbl->Release(p)

#define IDirectPlayVoiceServer_Initialize(p,a,b,c,d,e)      (p)->lpVtbl->Initialize(p,a,b,c,d,e)
#define IDirectPlayVoiceServer_StartSession(p,a,b)          (p)->lpVtbl->StartSession(p,a,b)
#define IDirectPlayVoiceServer_StopSession(p,a)             (p)->lpVtbl->StopSession(p,a)
#define IDirectPlayVoiceServer_GetSessionDesc(p,a)          (p)->lpVtbl->GetSessionDesc(p,a)
#define IDirectPlayVoiceServer_SetSessionDesc(p,a)          (p)->lpVtbl->SetSessionDesc(p,a)
#define IDirectPlayVoiceServer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectPlayVoiceServer_GetCompressionTypes(p,a,b,c,d) (p)->lpVtbl->GetCompressionTypes(p,a,b,c,d)
#define IDirectPlayVoiceServer_SetTransmitTargets(p,a,b,c,d)	(p)->lpVtbl->SetTransmitTargets(p,a,b,c,d)
#define IDirectPlayVoiceServer_GetTransmitTargets(p,a,b,c,d)	(p)->lpVtbl->GetTransmitTargets(p,a,b,c,d)
#define IDirectPlayVoiceServer_SetNotifyMask(p,a,b)         (p)->lpVtbl->SetNotifyMask(p,a,b)
#define IDirectPlayVoiceTest_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceTest_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceTest_Release(p)                	    (p)->lpVtbl->Release(p)
#define IDirectPlayVoiceTest_CheckAudioSetup(p,a,b,c,d)     (p)->lpVtbl->CheckAudioSetup(p,a,b,c,d)

//@@BEGIN_MSINTERNAL
#define IDirectPlayVoiceNotify_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceNotify_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceNotify_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectPlayVoiceNotify_Initialize(p)                (p)->lpVtbl->Initialize(p)
#define IDirectPlayVoiceNotify_NotifyEvent(p,a,b,c)         (p)->lpVtbl->NotifyEvent(p,a,b,c)
#define IDirectPlayVoiceNotify_ReceiveSpeechMessage(p,a,b,c,d) (p)->lpVtbl->ReceiveSpeechMessage(p,a,b,c,d)

#define IDirectPlayVoiceTransport_QueryInterface(p,a,b)     (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceTransport_AddRef(p)                 (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceTransport_Release(p)                (p)->lpVtbl->Release(p)
#define IDirectPlayVoiceTransport_Advise(p,a,b)             (p)->lpVtbl->Advise(p,a,b)
#define IDirectPlayVoiceTransport_UnAdvise(p,a)             (p)->lpVtbl->UnAdvise(p,a)
#define IDirectPlayVoiceTransport_IsGroupMember(p,a,b)      (p)->lpVtbl->IsGroupMember(p,a,b)
#define IDirectPlayVoiceTransport_SendSpeech(p,a,b,c,d,e)   (p)->lpVtbl->SendSpeech(p,a,b,c,d,e)
#define IDirectPlayVoiceTransport_GetSessionInfo(p,a)       (p)->lpVtbl->GetSessionInfo(p,a)
#define IDirectPlayVoiceTransport_IsValidEntity(p,a,b)      (p)->lpVtbl->IsValidEntity(p,a,b)
#define IDirectPlayVoiceTransport_SendSpeechEx(p,a,b,c,d,e,f) (p)->lpVtbl->SendSpeechEx(p,a,b,c,d,e,f)
#define IDirectPlayVoiceTransport_IsValidGroup(p,a,b)       (p)->lpVtbl->IsValidGroup(p,a,b)
#define IDirectPlayVoiceTransport_IsValidPlayer(p,a,b)      (p)->lpVtbl->IsValidPlayer(p,a,b)
#define IDirectPlayVoiceTransport_GetPlayerContext(p,a,b,c) (p)->lpVtbl->GetPlayerContext(p,a,b,c)
#define IDirectPlayVoiceTransport_SetPlayerContext(p,a,b,c) (p)->lpVtbl->SetPlayerContext(p,a,b,c)
//@@END_MSINTERNAL

#else /* C++ */

#define IDirectPlayVoiceClient_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectPlayVoiceClient_AddRef(p)                    (p)->AddRef()
#define IDirectPlayVoiceClient_Release(p)               	(p)->Release()

#define IDirectPlayVoiceClient_Initialize(p,a,b,c,d,e)      (p)->Initialize(a,b,c,d,e)
#define IDirectPlayVoiceClient_Connect(p,a,b,c)             (p)->Connect(a,b,c)
#define IDirectPlayVoiceClient_Disconnect(p,a)              (p)->Disconnect(a)
#define IDirectPlayVoiceClient_GetSessionDesc(p,a)          (p)->GetSessionDesc(a)
#define IDirectPlayVoiceClient_GetClientConfig(p,a)         (p)->GetClientConfig(a)
#define IDirectPlayVoiceClient_SetClientConfig(p,a)         (p)->SetClientConfig(a)
#define IDirectPlayVoiceClient_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectPlayVoiceClient_GetCompressionTypes(p,a,b,c,d) (p)->GetCompressionTypes(a,b,c,d)
#define IDirectPlayVoiceClient_SetTransmitTargets(p,a,b,c)  (p)->SetTransmitTargets(a,b,c)
#define IDirectPlayVoiceClient_GetTransmitTargets(p,a,b,c)  (p)->GetTransmitTargets(a,b,c)
#define IDirectPlayVoiceClient_Create3DSoundBuffer(p,a,b,c,d,e)   (p)->Create3DSoundBuffer(a,b,c,d,e)
#define IDirectPlayVoiceClient_Delete3DSoundBuffer(p,a,b)   (p)->Delete3DSoundBuffer(a,b)
#define IDirectPlayVoiceClient_SetNotifyMask(p,a,b)         (p)->SetNotifyMask(a,b)
#define IDirectPlayVoiceClient_GetSoundDeviceConfig(p,a,b)    (p)->GetSoundDeviceConfig(a,b)

#define IDirectPlayVoiceServer_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectPlayVoiceServer_AddRef(p)                    (p)->AddRef()
#define IDirectPlayVoiceServer_Release(p)                   (p)->Release()

#define IDirectPlayVoiceServer_Initialize(p,a,b,c,d,e)      (p)->Initialize(a,b,c,d,e)
#define IDirectPlayVoiceServer_StartSession(p,a,b)          (p)->StartSession(a,b)
#define IDirectPlayVoiceServer_StopSession(p,a)             (p)->StopSession(a)
#define IDirectPlayVoiceServer_GetSessionDesc(p,a)            (p)->GetSessionDesc(a)
#define IDirectPlayVoiceServer_SetSessionDesc(p,a)            (p)->SetSessionDesc(a)
#define IDirectPlayVoiceServer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectPlayVoiceServer_GetCompressionTypes(p,a,b,c,d) (p)->GetCompressionTypes(a,b,c,d)
#define IDirectPlayVoiceServer_SetTransmitTargets(p,a,b,c,d) (p)->SetTransmitTargets(a,b,c,d)
#define IDirectPlayVoiceServer_GetTransmitTargets(p,a,b,c,d) (p)->GetTransmitTargets(a,b,c,d)
#define IDirectPlayVoiceServer_SetNotifyMask(p,a,b)         (p)->SetNotifyMask(a,b)

#define IDirectPlayVoiceTest_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlayVoiceTest_AddRef(p)                      (p)->AddRef()
#define IDirectPlayVoiceTest_Release(p)                     (p)->Release()
#define IDirectPlayVoiceTest_CheckAudioSetup(p,a,b,c,d)     (p)->CheckAudioSetup(a,b,c,d)

//@@BEGIN_MSINTERNAL
#define IDirectPlayVoiceNotify_QueryInterface(p,a,b)		(p)->QueryInterface(a,b)
#define IDirectPlayVoiceNotify_AddRef(p)               		(p)->AddRef()
#define IDirectPlayVoiceNotify_Release(p)              		(p)->Release()
#define IDirectPlayVoiceNotify_Initialize(p)				(p)->Initialize()
#define IDirectPlayVoiceNotify_NotifyEvent(p,a,b,c)			(p)->NotifyEvent(a,b,c)
#define IDirectPlayVoiceNotify_ReceiveSpeechMessage(p,a,b,c,d) (p)->ReceiveSpeechMessage(a,b,c,d)

#define IDirectPlayVoiceTransport_QueryInterface(p,a,b)		(p)->QueryInterface(a,b)
#define IDirectPlayVoiceTransport_AddRef(p)					(p)->AddRef()
#define IDirectPlayVoiceTransport_Release(p)				(p)->Release()
#define IDirectPlayVoiceTransport_Advise(p,a,b)				(p)->Advise(a,b)
#define IDirectPlayVoiceTransport_UnAdvise(p,a)				(p)->UnAdvise(a)
#define IDirectPlayVoiceTransport_IsGroupMember(p,a,b) 		(p)->IsGroupMember(a,b)
#define IDirectPlayVoiceTransport_SendSpeech(p,a,b,c,d,e) 	(p)->SendSpeech(a,b,c,d,e)
#define IDirectPlayVoiceTransport_GetSessionInfo(p,a)  		(p)->GetSessionInfo(a)
#define IDirectPlayVoiceTransport_IsValidEntity(p,a,b)		(p)->IsValidEntity(a,b)
#define IDirectPlayVoiceTransport_SendSpeechEx(p,a,b,c,d,e,f) (p)->SendSpeechEx(a,b,c,d,e,f)
#define IDirectPlayVoiceTransport_IsValidGroup(p,a,b)		(p)->IsValidGroup(a,b)
#define IDirectPlayVoiceTransport_IsValidPlayer(p,a,b)		(p)->IsValidPlayer(a,b)
#define IDirectPlayVoiceTransport_GetPlayerContext(p,a,b,c) (p)->GetPlayerContext(a,b,c)
#define IDirectPlayVoiceTransport_SetPlayerContext(p,a,b,c) (p)->SetPlayerContext(a,b,c)

//@@END_MSINTERNAL

#endif


/****************************************************************************
 *
 * DIRECTPLAYVOICE ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _FACDPV  0x15
#define MAKE_DVHRESULT( code )          MAKE_HRESULT( 1, _FACDPV, code )

#define DV_OK                           S_OK
#define DV_FULLDUPLEX                   MAKE_HRESULT( 0, _FACDPV,  0x0005 )
#define DV_HALFDUPLEX                   MAKE_HRESULT( 0, _FACDPV,  0x000A )
#define DV_PENDING						MAKE_HRESULT( 0, _FACDPV,  0x0010 )

#define DVERR_BUFFERTOOSMALL            MAKE_DVHRESULT(  0x001E )
#define DVERR_EXCEPTION                 MAKE_DVHRESULT(  0x004A )
#define DVERR_GENERIC                   E_FAIL
#define DVERR_INVALIDFLAGS              MAKE_DVHRESULT( 0x0078 )
#define DVERR_INVALIDOBJECT             MAKE_DVHRESULT( 0x0082 )
#define DVERR_INVALIDPARAM              E_INVALIDARG
#define DVERR_INVALIDPLAYER             MAKE_DVHRESULT( 0x0087 )
#define DVERR_INVALIDGROUP              MAKE_DVHRESULT( 0x0091 )
#define DVERR_INVALIDHANDLE             MAKE_DVHRESULT( 0x0096 )
#define DVERR_OUTOFMEMORY               E_OUTOFMEMORY
#define DVERR_PENDING                   DV_PENDING
#define DVERR_NOTSUPPORTED              E_NOTIMPL
#define DVERR_NOINTERFACE               E_NOINTERFACE
#define DVERR_SESSIONLOST               MAKE_DVHRESULT( 0x012C )
#define DVERR_NOVOICESESSION            MAKE_DVHRESULT( 0x012E )
#define DVERR_CONNECTIONLOST            MAKE_DVHRESULT( 0x0168 )
#define DVERR_NOTINITIALIZED            MAKE_DVHRESULT( 0x0169 )
#define DVERR_CONNECTED                 MAKE_DVHRESULT( 0x016A )
#define DVERR_NOTCONNECTED              MAKE_DVHRESULT( 0x016B )
#define DVERR_CONNECTABORTING           MAKE_DVHRESULT( 0x016E )
#define DVERR_NOTALLOWED                MAKE_DVHRESULT( 0x016F )
#define DVERR_INVALIDTARGET             MAKE_DVHRESULT( 0x0170 )
#define DVERR_TRANSPORTNOTHOST          MAKE_DVHRESULT( 0x0171 )
#define DVERR_COMPRESSIONNOTSUPPORTED   MAKE_DVHRESULT( 0x0172 )
#define DVERR_ALREADYPENDING            MAKE_DVHRESULT( 0x0173 )
#define DVERR_SOUNDINITFAILURE          MAKE_DVHRESULT( 0x0174 )
#define DVERR_TIMEOUT                   MAKE_DVHRESULT( 0x0175 )
#define DVERR_CONNECTABORTED            MAKE_DVHRESULT( 0x0176 )
#define DVERR_NO3DSOUND                 MAKE_DVHRESULT( 0x0177 )
#define DVERR_ALREADYBUFFERED	        MAKE_DVHRESULT( 0x0178 )
#define DVERR_NOTBUFFERED               MAKE_DVHRESULT( 0x0179 )
#define DVERR_HOSTING                   MAKE_DVHRESULT( 0x017A )
#define DVERR_NOTHOSTING                MAKE_DVHRESULT( 0x017B )
#define DVERR_INVALIDDEVICE             MAKE_DVHRESULT( 0x017C )
#define DVERR_RECORDSYSTEMERROR         MAKE_DVHRESULT( 0x017D )
#define DVERR_PLAYBACKSYSTEMERROR       MAKE_DVHRESULT( 0x017E )
#define DVERR_SENDERROR                 MAKE_DVHRESULT( 0x017F )
#define DVERR_USERCANCEL                MAKE_DVHRESULT( 0x0180 )
#define DVERR_RUNSETUP                  MAKE_DVHRESULT( 0x0183 )
#define DVERR_INCOMPATIBLEVERSION       MAKE_DVHRESULT( 0x0184 )
#define DVERR_INITIALIZED               MAKE_DVHRESULT( 0x0187 )
#define DVERR_INVALIDPOINTER            E_POINTER
#define DVERR_NOTRANSPORT               MAKE_DVHRESULT( 0x0188 )
#define DVERR_NOCALLBACK                MAKE_DVHRESULT( 0x0189 )
#define DVERR_TRANSPORTNOTINIT          MAKE_DVHRESULT( 0x018A )
#define DVERR_TRANSPORTNOSESSION        MAKE_DVHRESULT( 0x018B )
#define DVERR_TRANSPORTNOPLAYER         MAKE_DVHRESULT( 0x018C )
#define DVERR_USERBACK                  MAKE_DVHRESULT( 0x018D )
#define DVERR_NORECVOLAVAILABLE         MAKE_DVHRESULT( 0x018E )
#define DVERR_INVALIDBUFFER				MAKE_DVHRESULT( 0x018F )
#define DVERR_LOCKEDBUFFER				MAKE_DVHRESULT( 0x0190 )
//@@BEGIN_MSINTERNAL
#define DVERR_CHILDPROCESSFAILED		DVERR_GENERIC
#define DV_EXIT							MAKE_HRESULT( 0, _FACDPV,  0x000F )
#define DVERR_UNKNOWN					DVERR_GENERIC
#define DVERR_PREVIOUSCRASH				MAKE_DVHRESULT( 0x0185 )
#define DVERR_WIN32						DVERR_GENERIC
//@@END_MSINTERNAL


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\misc\dpfa.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:	debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-jan-95	craige	initial implementation
 *   03-mar-95	craige	added dprintf2
 *   31-mar-95	craige	add DPFInit to read WIN.INI for [DirectDraw] section;
 *			added dprintf3
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	made stand-alone
 *   18-jun-95	craige	use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed dprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *	 20-may-96	andyco	forced ansi entry points on all functions
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "dpf.h"
#include <stdarg.h>

//#ifdef WINNT
//int abs(int x)
//{
//    return x>=0?x:-x;
//}
//#endif

#ifdef DEBUG

#define USE_DDASSERT

#ifndef START_STR
    #define START_STR	"DDRAW: "
#endif
#ifndef PROF_SECT
    #define PROF_SECT	"DirectDraw"
#endif

#define END_STR		"\r\n"

HWND		hWndListBox;
LONG		lDebugLevel = 0;

/*
 * dumpStr
 */
static void dumpStr( LPSTR str )
{
    OutputDebugStringA( str );

    #ifdef DPF_HWND
	if( hWndListBox != NULL )
	{
	    if( !IsWindow( hWndListBox ) )
	    {
		hWndListBox = NULL;
	    }
	}
	if( hWndListBox != NULL )
	{
	    UINT	sel;
	    int	len;
	    len = strlen( str );
	    if( len > 0 )
	    {
		if( str[len-1] == '\r' || str[len-1] == '\n' )
		{
		    str[len-1] = 0;
		}
		if( len > 1 )
		{
		    if( str[len-2] == '\r' || str[len-2] == '\n' )
		    {
			str[len-2] = 0;
		    }
		}
	    }
	    SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
	    sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
	    if( sel != LB_ERR )
	    {
		SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
	    }
	}
    #endif

} /* dumpStr */

/*
 * dprintf
 */
void cdecl dprintf( UINT lvl, LPSTR szFormat, ...)
{
    char 	str[256];
    BOOL	allow = FALSE;
    va_list ap;
    va_start(ap,szFormat);


    if( lDebugLevel < 0 )
    {
#ifdef WINNT
	if( (UINT) abs( lDebugLevel ) == lvl )
#else
	if( (UINT) labs( lDebugLevel ) == lvl )
#endif
	{
	    allow = TRUE;
	}
    }
    else if( (UINT) lDebugLevel >= lvl )
    {
	allow = TRUE;
    }

    if( allow )
    {
	wsprintfA( (LPSTR) str, START_STR );
	wvsprintfA( str+lstrlenA( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

	lstrcatA( (LPSTR) str, END_STR );
	dumpStr( str );
    }

    va_end(ap);
} /* dprintf */

/*
 * DPFInit
 */
void DPFInit( void )
{
    lDebugLevel = GetProfileIntA( PROF_SECT, "debug", 0 );

} /* DPFInit */

#ifdef USE_DDASSERT

/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    wsprintfA( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( GetProfileIntA( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}

#endif /* USE_DDASSERT */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\misc\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern UINT_PTR __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\misc\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
#include "newdpf.h"
#else

    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef WINNT
        #undef DEBUG
        #ifdef DBG
	    #define DEBUG
        #endif
    #endif

    extern void cdecl dprintf( UINT lvl, LPSTR szFormat, ...);
    extern void DPFInit( void );
    #ifdef DEBUG
        #define DPFINIT()   DPFInit()
        #define DPF         dprintf
        #define DPF_ERR(a)  dprintf( 0, DPF_MODNAME ": " a );
        extern HWND hWndListBox;
        #if defined( _WIN32 ) && !defined(WINNT)
	    #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
        #else
	    #define DEBUG_BREAK()       DebugBreak()
        #endif
        #define USE_DDASSERT
    #else
        #pragma warning(disable:4002)
        #define DPFINIT()
        #define DPF()
        #define DPF_ERR(a)
        #define DEBUG_BREAK()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
        __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
        __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

        #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
        #define TIMEZERO(t)   t ## T = 0, t ## N = 0
        #define TIMESTART(t)  t ## T -= clock(), t ## N ++
        #define TIMESTOP(t)   t ## T += clock()
        #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
        #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
        #define TIMEVAR(t)
        #define TIMEZERO(t)
        #define TIMESTART(t)
        #define TIMESTOP(t)
        #define TIMEFMT(t)
        #define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\misc\logger.h ===
/*
	logger.h

	Use to write log info to a file.

	Multiple-instance aware. If one instance already owns the output
        file, another will sleep (up to 20s) until the first is done.
	Nicely outputs a header containing user, computer, and driver names,
	date/time and starting display resolution.


        You use it like this:

                CLogfile Log("test.log","your comment here");

                // or CLogfile Log("test.log");
                // for no comment, and overwriting the file.

                // or CLogfile Log("test.log","your comment here",TRUE);
                // to make it append to the file. Default is overwrite.
                
                Log << "\n\n42 decimal is " << 42ul <<" in hex\n";
                Log << "Hi"<<'!'<<'\n' ;
                Log << "The value of 0x2a is " << 0x2al << " in decimal\n";

				CLogfile Faults("faults.log","my test's faults",TRUE);	//append new faults
				Faults << "Encountered a booboo, here's what i did:\n";
				Faults << Log;		//copies contents of test.log to Fault
				Faults << "so now you can diagnose\n";

        The class will then write stuff like this to test.log:


                ----------------------------------------------------------
                EnumSurface test
                Beginning test at 10:38 on 1995/8/14
                User Name:jeffno
                Computer Name:JEFFNO2
                Display driver:S3 Vision864 PCI
                Starting resolution: 640x480x8
                - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
                42 decimal is 0000002a in hex
                Hi!
                The value of 0x2a is 42 in decimal
                ----------- Test ends at 10:38 on 1995/8/14 -------------
                
		And faults.log will get:
				< a header like above>
				Encountered a booboo, here's what i did:
				< a copy of the test.log contents surrounded by
					notes that say this is a snapshot of test.log >
				so now you can diagnose
				< a trailer like above (test ends at etc...)>



        The class can output DWORDS, which it does as an 8-digit hex number,
        LONGs which are output as decimal, chars and strings. As shown
		above you can output one log object to another, which copies 
		everything in the source file from the pos at which the source
		file was opened (if appending to a pre-existing file) up to
		the end.


        But wait! you also get...
                A routine called char * ErrorName(HRESULT) which takes
                a ddraw return value and returns a string describing it.
                Very handy.
                BTW: this header file includes a statically declared array
                full of names, at file level scope. This means you get a 2k
                array in your source wether you want ErrorName or not.
                Go ahead and edit this file if you don't want this array.

        NOTE: this uses WNetGetUser API, so you'll need to add mpr.lib
        to you LIBS line in your makefile.
*/

//#include <stdio.h>
#include <windows.h>
#include <windowsx.h> 


struct {
	char name[100];
	HRESULT errcode;
} ErrorLookup[] = {
				{"DD_OK",DD_OK},
				{"DDERR_ALREADYINITIALIZED",DDERR_ALREADYINITIALIZED},
				{"DDERR_CANNOTATTACHSURFACE",DDERR_CANNOTATTACHSURFACE},
				{"DDERR_CANNOTDETACHSURFACE",DDERR_CANNOTDETACHSURFACE},
				{"DDERR_CURRENTLYNOTAVAIL",DDERR_CURRENTLYNOTAVAIL},
				{"DDERR_EXCEPTION",DDERR_EXCEPTION},
				{"DDERR_GENERIC",DDERR_GENERIC},
				{"DDERR_HEIGHTALIGN",DDERR_HEIGHTALIGN},
				{"DDERR_INCOMPATIBLEPRIMARY",DDERR_INCOMPATIBLEPRIMARY},
				{"DDERR_INVALIDCAPS",DDERR_INVALIDCAPS},
				{"DDERR_INVALIDCLIPLIST",DDERR_INVALIDCLIPLIST},
				{"DDERR_INVALIDMODE",DDERR_INVALIDMODE},
				{"DDERR_INVALIDOBJECT",DDERR_INVALIDOBJECT},
				{"DDERR_INVALIDPARAMS",DDERR_INVALIDPARAMS},
				{"DDERR_INVALIDPIXELFORMAT",DDERR_INVALIDPIXELFORMAT},
				{"DDERR_INVALIDRECT",DDERR_INVALIDRECT},
				{"DDERR_LOCKEDSURFACES",DDERR_LOCKEDSURFACES},
				{"DDERR_NO3D",DDERR_NO3D},
				{"DDERR_NOALPHAHW",DDERR_NOALPHAHW},
				{"DDERR_NOANTITEARHW",DDERR_NOANTITEARHW},
				{"DDERR_NOBLTQUEUEHW",DDERR_NOBLTQUEUEHW},
				{"DDERR_NOCLIPLIST",DDERR_NOCLIPLIST},
				{"DDERR_NOCOLORCONVHW",DDERR_NOCOLORCONVHW},
				{"DDERR_NOCOOPERATIVELEVELSET",DDERR_NOCOOPERATIVELEVELSET},
				{"DDERR_NOCOLORKEY",DDERR_NOCOLORKEY},
				{"DDERR_NOCOLORKEYHW",DDERR_NOCOLORKEYHW},
				{"DDERR_NOEXCLUSIVEMODE",DDERR_NOEXCLUSIVEMODE},
				{"DDERR_NOFLIPHW",DDERR_NOFLIPHW},
				{"DDERR_NOGDI",DDERR_NOGDI},
				{"DDERR_NOMIRRORHW",DDERR_NOMIRRORHW},
				{"DDERR_NOTFOUND",DDERR_NOTFOUND},
				{"DDERR_NOOVERLAYHW",DDERR_NOOVERLAYHW},
				{"DDERR_NORASTEROPHW",DDERR_NORASTEROPHW},
				{"DDERR_NOROTATIONHW",DDERR_NOROTATIONHW},
				{"DDERR_NOSTRETCHHW",DDERR_NOSTRETCHHW},
				{"DDERR_NOT4BITCOLOR",DDERR_NOT4BITCOLOR},
				{"DDERR_NOT4BITCOLORINDEX",DDERR_NOT4BITCOLORINDEX},
				{"DDERR_NOT8BITCOLOR",DDERR_NOT8BITCOLOR},
				{"DDERR_NOTEXTUREHW",DDERR_NOTEXTUREHW},
				{"DDERR_NOVSYNCHW",DDERR_NOVSYNCHW},
				{"DDERR_NOZBUFFERHW",DDERR_NOZBUFFERHW},
				{"DDERR_NOZOVERLAYHW",DDERR_NOZOVERLAYHW},
				{"DDERR_OUTOFCAPS",DDERR_OUTOFCAPS},
				{"DDERR_OUTOFMEMORY",DDERR_OUTOFMEMORY},
				{"DDERR_OUTOFVIDEOMEMORY",DDERR_OUTOFVIDEOMEMORY},
				{"DDERR_OVERLAYCANTCLIP",DDERR_OVERLAYCANTCLIP},
				{"DDERR_OVERLAYCOLORKEYONLYONEACTIVE",DDERR_OVERLAYCOLORKEYONLYONEACTIVE},
				{"DDERR_PALETTEBUSY",DDERR_PALETTEBUSY},
				{"DDERR_COLORKEYNOTSET",DDERR_COLORKEYNOTSET},
				{"DDERR_SURFACEALREADYATTACHED",DDERR_SURFACEALREADYATTACHED},
				{"DDERR_SURFACEALREADYDEPENDENT",DDERR_SURFACEALREADYDEPENDENT},
				{"DDERR_SURFACEBUSY",DDERR_SURFACEBUSY},
				{"DDERR_SURFACEISOBSCURED",DDERR_SURFACEISOBSCURED},
				{"DDERR_SURFACELOST",DDERR_SURFACELOST},
				{"DDERR_SURFACENOTATTACHED",DDERR_SURFACENOTATTACHED},
				{"DDERR_TOOBIGHEIGHT",DDERR_TOOBIGHEIGHT},
				{"DDERR_TOOBIGSIZE",DDERR_TOOBIGSIZE},
				{"DDERR_TOOBIGWIDTH",DDERR_TOOBIGWIDTH},
				{"DDERR_UNSUPPORTED",DDERR_UNSUPPORTED},
				{"DDERR_UNSUPPORTEDFORMAT",DDERR_UNSUPPORTEDFORMAT},
				{"DDERR_UNSUPPORTEDMASK",DDERR_UNSUPPORTEDMASK},
				{"DDERR_VERTICALBLANKINPROGRESS",DDERR_VERTICALBLANKINPROGRESS},
				{"DDERR_WASSTILLDRAWING",DDERR_WASSTILLDRAWING},
				{"DDERR_XALIGN",DDERR_XALIGN},
				{"DDERR_INVALIDDIRECTDRAWGUID",DDERR_INVALIDDIRECTDRAWGUID},
				{"DDERR_DIRECTDRAWALREADYCREATED",DDERR_DIRECTDRAWALREADYCREATED},
				{"DDERR_NODIRECTDRAWHW",DDERR_NODIRECTDRAWHW},
				{"DDERR_PRIMARYSURFACEALREADYEXISTS",DDERR_PRIMARYSURFACEALREADYEXISTS},
				{"DDERR_NOEMULATION",DDERR_NOEMULATION},
				{"DDERR_REGIONTOOSMALL",DDERR_REGIONTOOSMALL},
				{"DDERR_CLIPPERISUSINGHWND",DDERR_CLIPPERISUSINGHWND},
				{"DDERR_NOCLIPPERATTACHED",DDERR_NOCLIPPERATTACHED},
				{"DDERR_NOHWND",DDERR_NOHWND},
				{"DDERR_HWNDSUBCLASSED",DDERR_HWNDSUBCLASSED},
				{"DDERR_HWNDALREADYSET",DDERR_HWNDALREADYSET},
				{"DDERR_NOPALETTEATTACHED",DDERR_NOPALETTEATTACHED},
				{"DDERR_NOPALETTEHW",DDERR_NOPALETTEHW},
				{"DDERR_BLTFASTCANTCLIP",DDERR_BLTFASTCANTCLIP},
				{"DDERR_NOBLTHW",DDERR_NOBLTHW},
				{"DDERR_NODDROPSHW",DDERR_NODDROPSHW},
				{"DDERR_OVERLAYNOTVISIBLE",DDERR_OVERLAYNOTVISIBLE},
				{"DDERR_NOOVERLAYDEST",DDERR_NOOVERLAYDEST},
				{"DDERR_INVALIDPOSITION",DDERR_INVALIDPOSITION},
				{"DDERR_NOTAOVERLAYSURFACE",DDERR_NOTAOVERLAYSURFACE},
				{"DDERR_EXCLUSIVEMODEALREADYSET",DDERR_EXCLUSIVEMODEALREADYSET},
				{"DDERR_NOTFLIPPABLE",DDERR_NOTFLIPPABLE},
				{"DDERR_CANTDUPLICATE",DDERR_CANTDUPLICATE},
				{"DDERR_NOTLOCKED",DDERR_NOTLOCKED},
				{"DDERR_CANTCREATEDC",DDERR_CANTCREATEDC},
				{"DDERR_NODC",DDERR_NODC},
				{"DDERR_WRONGMODE",DDERR_WRONGMODE},
				{"DDERR_IMPLICITLYCREATED",DDERR_IMPLICITLYCREATED},
				{"DDERR_NOTPALETTIZED",DDERR_NOTPALETTIZED},
				{"DDERR_UNSUPPORTEDMODE",DDERR_UNSUPPORTEDMODE},
				{"END",0}
};

inline char * ErrorName(HRESULT err)
{
	int e=0;
	while (strcmp(ErrorLookup[e].name,"END"))
	{
		if (err == ErrorLookup[e].errcode)
			return ErrorLookup[e].name;
		e++;
	};
	return "Unknown Error code";
}	


class CLogfile
{	
	private:
		char smalltemp[10];
		HFILE 	fh;
		OFSTRUCT of;
		BOOL bHeaderWritten;
		char *cComment;
		char line[1000];
		LONG lStartPos;
		char Path[200];
	public:
		CLogfile(char * path, char * comment = 0,BOOL bAppend=FALSE)
		{
			if (path)
				strncpy(Path,path,199);

			fh = HFILE_ERROR;
			bHeaderWritten = FALSE;
			lStartPos = 0;

			//if the file does not exist, create it:
			if (GetFileAttributes(path) == 0xffffffff)
				fh = OpenFile(path,&of,OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE);
			else
				//first attempt to get a lock on the file...
				for (int i=0;i<20 && fh==HFILE_ERROR;i++)
				{
					if (bAppend)
						fh = OpenFile(path,&of, OF_READWRITE|OF_SHARE_DENY_WRITE);
					else
						fh = OpenFile(path,&of, OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE);
					if (fh==HFILE_ERROR)
						Sleep(1000);
				}

			if (fh==HFILE_ERROR)
				return;

			lStartPos = _llseek(fh,0,SEEK_END);

			cComment = comment;
		}

		void OutputHeader(void)
		{
			//now we have the file, write user/computer info:

			//write separator, comment if necessary and date and time:
			SYSTEMTIME st;
			GetLocalTime(&st);
			wsprintf(line,"----------------------------------------------------------\r\n");
			_lwrite(fh,line,strlen(line));
			if (cComment && strlen(cComment))
			{
				wsprintf(line,"%s\r\n",cComment);
				_lwrite(fh,line,strlen(line));
			}
			wsprintf(line,"Beginning test at %d:%02d on %d/%d/%d\r\n",st.wHour,st.wMinute,st.wYear,st.wMonth,st.wDay);
			_lwrite(fh,line,strlen(line));


			//write user's name:
			DWORD length = 100;
			wsprintf(line,"User Name:");

			WNetGetUser(NULL,line+strlen(line),&length);
			_lwrite(fh,line,strlen(line));

			//write computer's name:
			wsprintf(line,"\r\nComputer Name:");
			GetComputerName(line+strlen(line),&length);
			_lwrite(fh,line,strlen(line));

			//write display driver's name:
			wsprintf(line,"\r\nDisplay driver:");
			GetPrivateProfileString("boot.description","display.drv","(Unknown)",line+strlen(line),100,"system.ini");
			_lwrite(fh,line,strlen(line));

			_lwrite(fh,"\r\n",2);

			HDC hdc = GetDC(NULL);
			if (hdc)
			{
				wsprintf(line,"Starting resolution: %dx%dx%d\r\n",
							GetDeviceCaps(hdc,HORZRES)
							,GetDeviceCaps(hdc,VERTRES)
							,GetDeviceCaps(hdc,BITSPIXEL) );
				_lwrite(fh,line,strlen(line));
				ReleaseDC(NULL,hdc);
			}
			wsprintf(line,"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n");
			_lwrite(fh,line,strlen(line));

			bHeaderWritten = TRUE;
		}
		~CLogfile()
		{
			SYSTEMTIME st;
			if(fh != HFILE_ERROR)
			{
				if (bHeaderWritten)
				{
					GetLocalTime(&st);
					wsprintf(line,"----------- Test ends at %d:%02d on %d/%d/%d -------------\r\n",st.wHour,st.wMinute,st.wYear,st.wMonth,st.wDay);
					_lwrite(fh,line,strlen(line));
				}
				_lclose(fh);
			}
		}
		CLogfile & operator << (DWORD dw)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			wsprintf(smalltemp,"%08x",dw);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (LONG dw)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			wsprintf(smalltemp,"%d",dw);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
                CLogfile & operator << (void * p)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
            // 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers and handles.
			wsprintf(smalltemp,"%p",p);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (char * cp)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			while( *cp)
				*this << *cp++;
			return *this;
		}
		CLogfile & operator << (char  c)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			if (c=='\n')
			{
				wsprintf(smalltemp,"\r");
				_lwrite(fh,smalltemp,strlen(smalltemp));
			}
			wsprintf(smalltemp,"%c",c);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (CLogfile & log)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();

			LONG pos = _llseek(log.fh,0,FILE_CURRENT);
			LONG from = _llseek(log.fh,log.lStartPos,FILE_BEGIN);

			char ch;
			*this << "= = = = = = = Snapshot of ";
			if (log.Path)
				*this << log.Path;
			else
				*this << "Unknown file";
			*this << " = = = = = = =\n";

			for (LONG j=0;j<pos-from;j++)
			{
				_lread(log.fh,&ch,1);
				*this << ch;
			}

			*this << "= = = = = = = = = Snapshot ends = = = = = = = = = = =\n";
			return *this;
		}
			
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\misc\dxvalid.h ===
//--------------------------------------------------------------------------;
//
//  File: dxvalid.h
//
//  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//      This header contains common parameter validate macros for DirectX.
//
//  History:
//      02/14/96    angusm    Initial version
//      03/05/96    angusm    added VALIDEX_GUID_PTR
//
//--------------------------------------------------------------------------;


// _________________________________________________________________________
// VALIDEX_xxx 
//     macros are the same for debug and retail


#define VALIDEX_PTR( ptr, size ) \
	(!IsBadReadPtr( ptr, size) )

#define VALIDEX_GUID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( GUID ) ) )

#define VALIDEX_IID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( IID )) )

#define VALIDEX_PTR_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID )) )

#define VALIDEX_CODE_PTR( ptr ) \
	(!IsBadCodePtr( (LPVOID) ptr ) )


// _________________________________________________________________________
// VALID_xxx 
//     macros that check memory allocated and sent as API parameters


#ifndef DEBUG
#define FAST_CHECKING
#endif

#ifndef FAST_CHECKING

#define VALID_BOOL_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( BOOL ) ))
#define VALID_DDCOLORKEY_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( DDCOLORKEY ) ) )
#define VALID_RGNDATA_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( RGNDATA ) ) )
#define VALID_RECT_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( RECT ) ) )
#define VALID_PTR_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID )) )
#define VALID_IID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( IID )) )
#define VALID_HWND_PTR( ptr ) \
	(!IsBadWritePtr( (LPVOID) ptr, sizeof( HWND )) )
#define VALID_VMEM_PTR( ptr ) \
	(!IsBadWritePtr( (LPVOID) ptr, sizeof( VMEM )) )
#define VALID_POINTER_ARRAY( ptr, cnt ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID ) * cnt ) )
#define VALID_HANDLE_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( HANDLE )) )
#define VALID_DWORD_ARRAY( ptr, cnt ) \
	(!IsBadWritePtr( ptr, sizeof( DWORD ) * cnt ) )
#define VALID_GUID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( GUID ) ) )
#define VALID_BYTE_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( BYTE ) * cnt ) )
#define VALID_PTR( ptr, size ) \
	(!IsBadReadPtr( ptr, size) )

#else
#define VALID_PTR( ptr, size ) 		1
#define VALID_DIRECTDRAW_PTR( ptr )	1
#define VALID_DIRECTDRAWSURFACE_PTR( ptr )	1
#define VALID_DIRECTDRAWPALETTE_PTR( ptr )	1
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr )	1
#define VALID_DDSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC ))
#define VALID_BOOL_PTR( ptr )	1
#define VALID_HDC_PTR( ptr )	1
#define VALID_DDPIXELFORMAT_PTR( ptr ) (ptr->dwSize == sizeof( DDPIXELFORMAT ))
#define VALID_DDCOLORKEY_PTR( ptr )	1
#define VALID_RGNDATA_PTR( ptr )	1
#define VALID_RECT_PTR( ptr )	1
#define VALID_DDOVERLAYFX_PTR( ptr ) (ptr->dwSize == sizeof( DDOVERLAYFX ))
#define VALID_DDBLTFX_PTR( ptr ) (ptr->dwSize == sizeof( DDBLTFX ))
#define VALID_DDBLTBATCH_PTR( ptr )	1
#define VALID_DDMASK_PTR( ptr )	1
#define VALID_DDSCAPS_PTR( ptr )	1
#define VALID_PTR_PTR( ptr )	1
#define VALID_IID_PTR( ptr )	1
#define VALID_HWND_PTR( ptr )	1
#define VALID_VMEM_PTR( ptr )	1
#define VALID_POINTER_ARRAY( ptr, cnt ) 1
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt )	1
#define VALID_HANDLE_PTR( ptr )	1
#define VALID_DDCAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDCAPS ))
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt )	1
#define VALID_DWORD_ARRAY( ptr, cnt )	1
#define VALID_GUID_PTR( ptr )	1
#define VALID_BYTE_ARRAY( ptr, cnt ) 1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\misc\lists.h ===
/* Copyright (c) 1997  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef	_LISTS_H
#define	_LISTS_H

#if __cplusplus
extern "C" {
#endif

#define LIST_ROOT(name, type) struct name {struct type *Root;}

#define LIST_MEMBER(type) struct { struct type **Prev; struct type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
	(root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define	LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define	TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   struct type *First;\
    struct type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   struct type *Next;\
    struct type **Prev;	/* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   struct type *Last;\
    struct type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   struct type *Prev;\
    struct type *Next;\
}

#define	CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
	(root)->Last->field.Next = (element);\
    else\
	(root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
	(root)->First->field.Prev = (element);\
    else\
	(root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
	(current_element)->field.Prev->field.Next = (element);\
    else\
	(root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define	CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
	(element)->field.Prev->field.Next = (element)->field.Next;\
    else\
	(root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lists.h"

void TestList(void)
{
    struct Foo
    {
	int a;
	LIST_MEMBER(Foo) ListStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
	int a;
	TAIL_QUEUE_MEMBER(Foo) TQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
	int a;
	CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
	CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
	MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
	MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
	MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    
	switch(WhichInsert)
	{
	case END:
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    WhichInsert = ROOT;
	    break;
	case ROOT:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    WhichInsert = PREVIOUS;
	    break;
	case PREVIOUS:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
	    WhichInsert = DONE;
	    break;
	default:
	    assert(0);
	}

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

	pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
	pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
	assert(pFoo == &MyFoo3);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);
    
        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);
    
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        
        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);
    
        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */

#if __cplusplus
}
#endif

#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\misc\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "dpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = _ReturnAddress(); \
	pmt->dwPid = GetCurrentProcessId(); \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif


#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );

    return lptr;

} /* MemAlloc */

/*
 * MemSize - return size of object
 */
UINT_PTR __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return HeapSize(hHeap, 0, lptr);

} /* MemSize */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

		#ifdef FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

	HeapFree( hHeap, 0, lptr );

    }

} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	pmt->dwSize = size - sizeof( MEMTRACK );

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;

} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    if( hHeap == NULL )
    {
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
    #ifdef DEBUG
	lAllocCount = 0;
	lpHead = NULL;
	lpTail = NULL;
    #endif
    return TRUE;

} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 2, "MemState" );
    if( lAllocCount != 0 )
    {
	DPF( 1, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 1, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    }
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx (pid=%08lx)", pmt, pmt->dwSize, pmt->lpAddr, pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 1, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
	HeapDestroy( hHeap );
	hHeap = NULL;
    }
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\misc\w95help.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95hack.c
 *  Content:	Win95 hack-o-rama code
 *		This is a HACK to handle the fact that Win95 doesn't notify
 *		a DLL when a process is destroyed.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   28-mar-95	craige	initial implementation
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	reworked for new ddhelp
 *   09-may-95	craige	loading any DLL
 *   16-sep-95	craige	bug 1117: must UnmapViewOfFile before closing handle
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *   29-jan-97  colinmc vxd handling stuff is no longer win16 lock specific
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "w95help.h"
#include "dpf.h"

#undef E_FAIL
#define E_FAIL	0x80004005L

//extern DWORD	* pdwHelperPid;
//extern HANDLE	* phModule;	// must be defined
extern DWORD	dwHelperPid;
extern HANDLE	hModule;	// must be defined


/*
 * sendRequest
 *
 * communicate a request to DDHELP
 */
static BOOL sendRequest( LPDDHELPDATA req_phd )
{
    LPDDHELPDATA	phd;
    HANDLE		hmem;
    HANDLE		hmutex;
    HANDLE		hackevent;
    HANDLE		hstartevent;
    BOOL		rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
	return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
	CloseHandle( hstartevent );
	return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
    		PAGE_READWRITE, 0, sizeof( DDHELPDATA ),
		DDHELP_SHARED_NAME );
    if( hmem == NULL )
    {
	DPF( 1, "Could not create file mapping!" );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    phd = (LPDDHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    if( phd == NULL )
    {
	DPF( 1, "Could not create view of file!" );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DDHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
	DPF( 1, "Could not create mutex!" );
	UnmapViewOfFile( phd );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DDHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DDHELPDATA ) );
    phd->req_id = hModule;
    if( SetEvent( hstartevent ) )
    {
	WaitForSingleObject( hackevent, INFINITE );
	memcpy( req_phd, phd, sizeof( DDHELPDATA ) );
	rc = TRUE;
    }
    else
    {
	DPF( 1, "Could not signal event to notify DDHELP" );
	rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    UnmapViewOfFile( phd );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */

/*
 * DoneWithHelperProcess
 */
void DoneWithHelperProcess( void )
{
    DDHELPDATA	hd;

    if( dwHelperPid == 0 )
    {
	return;
    }

    hd.req = DDHELPREQ_FREEDCLIST;
    sendRequest( &hd );

} /* DoneWithHelperProcess */

/*
 * WaitForHelperStartup
 */
BOOL WaitForHelperStartup( void )
{
    HANDLE	hevent;
    DWORD	rc;

    hevent = CreateEvent( NULL, TRUE, FALSE, DDHELP_STARTUP_EVENT_NAME );
    if( hevent == NULL )
    {
	return FALSE;
    }
    DPF( 3, "Wait DDHELP startup event to be triggered" );
    rc = WaitForSingleObject( hevent, INFINITE );
    CloseHandle( hevent );
    return TRUE;

} /* WaitForHelperStartup */

/*
 * HelperLoadDLL
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context )
{
    DDHELPDATA  hd;
    DWORD       rc = 0;

    if( dllname != NULL )
    {
	hd.req = DDHELPREQ_LOADDLL;
	lstrcpy( hd.fname, dllname );
	if( fnname != NULL )
	{
	    strcpy( hd.func, fnname );
	    hd.context = context;
	    DPF( 3, "Context=%08lx", context );
	}
	else
	{
	    hd.func[0] = 0;
	}
	DPF( 3, "Asking DDHELP to load DLL %s", dllname );
        sendRequest( &hd );
        rc = hd.dwReturn;
    }

    return rc;

} /* HelperLoadDLL */


/*
 * HelperCreateThread
 */
void HelperCreateThread( void )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEHELPERTHREAD;
    sendRequest( &hd );

} /* HelperCreateThread */

/*
 * SignalNewProcess
 *
 * Signal DDHELP that a new process has arrived.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA	hd;

    if( pid == dwHelperPid )
    {
	DPF( 3, "Helper connected to DLL - no signal required" );
	return;
    }

    DPF( 3, "Signalling DDHELP that a new process has connected" );
    hd.req = DDHELPREQ_NEWPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */

/*
 * SignalNewDriver
 *
 * Signal DDHELP that a new driver has been loaded.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewDriver( LPSTR fname, BOOL isdisp )
{
    DDHELPDATA	hd;

    DPF( 3, "Signalling DDHELP to create a new DC" );
    hd.req = DDHELPREQ_NEWDC;
    hd.isdisp = isdisp;
    lstrcpy( hd.fname, fname );
    sendRequest( &hd );

} /* SignalNewDriver */

/*
 * CreateHelperProcess
 */
BOOL CreateHelperProcess( LPDWORD ppid )
{
    if( dwHelperPid == 0 )
    {
	STARTUPINFO		si;
	PROCESS_INFORMATION	pi;
	HANDLE			h;

	h = OpenEvent( SYNCHRONIZE, FALSE, DDHELP_STARTUP_EVENT_NAME );
	if( h == NULL )
	{
	    si.cb = sizeof(STARTUPINFO);
	    si.lpReserved = NULL;
	    si.lpDesktop = NULL;
	    si.lpTitle = NULL;
	    si.dwFlags = 0;
	    si.cbReserved2 = 0;
	    si.lpReserved2 = NULL;

	    DPF( 3, "Creating helper process now" );
	    if( !CreateProcess(NULL, "ddhelp.exe",  NULL, NULL, FALSE,
			       NORMAL_PRIORITY_CLASS,
			       NULL, NULL, &si, &pi) )
	    {
		DPF( 2, "Could not create DDHELP.EXE" );
		return FALSE;
	    }
	    dwHelperPid = pi.dwProcessId;
	    DPF( 3, "Helper rocess created" );
	}
	else
	{
	    DDHELPDATA	hd;
	    DPF( 3, "DDHELP already exists, waiting for DDHELP event" );
	    WaitForSingleObject( h, INFINITE );
	    CloseHandle( h );
	    DPF( 3, "Asking for DDHELP pid" );
	    hd.req = DDHELPREQ_RETURNHELPERPID;
	    sendRequest( &hd );
	    dwHelperPid = hd.pid;
	    DPF( 3, "DDHELP pid = %08lx", dwHelperPid );
	}
	*ppid = dwHelperPid;
	return TRUE;
    }
    *ppid = dwHelperPid;
    return FALSE;

} /* CreateHelperProcess */

#ifndef WINNT   //this is Just For Now... dsound will get the help it needs..jeffno 951206
/*
 * HelperWaveOpen
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx )
{
    DDHELPDATA	hd;

    if( (lphwo != NULL) && (pwfx != NULL) )
    {
	hd.req = DDHELPREQ_WAVEOPEN;
	hd.pData1 = lphwo;
	hd.dwData1 = dwDeviceID;
	hd.dwData2 = (DWORD)pwfx;
	DPF( 3, "Asking DDHELP to Open Wave Device %d", dwDeviceID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Open param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveOpen */

/*
 * HelperWaveClose
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveClose( DWORD hwo )
{
    DDHELPDATA	hd;

    if( (hwo != 0) )
    {
	hd.req = DDHELPREQ_WAVECLOSE;
	hd.dwData1 = hwo;
	DPF( 3, "Asking DDHELP to Close Wave Device ");
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveClose */

/*
 * HelperCreateTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperCreateTimer( DWORD dwResolution,
			 LPVOID	pTimerProc,
			 DWORD dwInstanceData )
{
    DDHELPDATA	hd;

    if( (dwResolution != 0) && (pTimerProc != NULL)  )
    {
	hd.req = DDHELPREQ_CREATETIMER;
	hd.pData1 = pTimerProc;
	hd.dwData1 = dwResolution;
	hd.dwData2 = dwInstanceData;
	DPF( 3, "Asking DDHELP to Create Timer" );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperCreateTimer */

/*
 * HelperKillTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperKillTimer( DWORD dwTimerID )
{
    DDHELPDATA	hd;

    if( (dwTimerID != 0) )
    {
	hd.req = DDHELPREQ_KILLTIMER;
	hd.dwData1 = dwTimerID;
	DPF( 3, "Asking DDHELP to KILL Timer %X", dwTimerID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperKillTimer */

/*
 * HelperCreateDSMixerThread
 *
 * get the helper to create a mixer thread.
 */
HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSMIXERTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSMixerThread

/*
 * HelperCreateDSFocusThread
 *
 * get the helper to create a sound focus thread.
 */
HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSFOCUSTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSFocusThread

/*
 * HelperCallDSEmulatorCleanup
 *
 * Call the DirectSound function which cleans up MMSYSTEM handles
 */
void HelperCallDSEmulatorCleanup( LPVOID callback,
                                  LPVOID pDirectSound )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CALLDSCLEANUP;
    hd.pData1 = callback;
    hd.pData2 = pDirectSound;

    sendRequest( &hd );
}

#endif //not winnt -just for now-jeffno

/*
 * HelperCreateModeSetThread
 *
 * get the helper to load a DLL for us.
 */
BOOL HelperCreateModeSetThread(
		LPVOID callback,
		HANDLE *ph,
		LPVOID lpdd,
		DWORD hInstance )
{
    DDHELPDATA	hd;
    HANDLE	h;
    char	str[64];

    hd.req = DDHELPREQ_CREATEMODESETTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_MODESET_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
	DPF( 3, "Could not open modeset event!" );
	*ph = NULL;
	return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateModeSetThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateModeSetThread */

/*
 * HelperKillModeSetThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillModeSetThread( DWORD hInstance )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_KILLMODESETTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillModeSetThread */

/*
 * HelperCreateDOSBoxThread
 *
 * get the helper to create a thread so kernel mode can notify us of DOS box
 * changes.
 */
BOOL HelperCreateDOSBoxThread(
		LPVOID callback,
		HANDLE *ph,
		LPVOID lpdd,
		DWORD hInstance )
{
    DDHELPDATA	hd;
    HANDLE	h;
    char	str[64];

    hd.req = DDHELPREQ_CREATEDOSBOXTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_DOSBOX_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
	DPF( 3, "Could not open DOS box event!" );
	*ph = NULL;
	return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateDOSBoxThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateDOSBoxThread */

/*
 * HelperKillDOSBoxThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillDOSBoxThread( DWORD hInstance )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_KILLDOSBOXTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillDOSBoxThread */

// notify dphelp.c that we have a new server on this system
DWORD HelperAddDPlayServer(DWORD port)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

	memset(&hd, 0, sizeof(DDHELPDATA));
    hd.req = DDHELPREQ_DPLAYADDSERVER;
    hd.pid = pid;
    hd. dwData1 = port;
    if (sendRequest(&hd))
		return (hd.dwReturn);
	else
		return ((DWORD) E_FAIL);
} // HelperAddDPlayServer

// server is going away
BOOL HelperDeleteDPlayServer(void)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

    hd.req = DDHELPREQ_DPLAYDELETESERVER;
    hd.pid = pid;
    return sendRequest(&hd);

} // HelperDeleteDPlayServer

#ifdef WIN95
    /*
     * Get DDHELP to load the DirectSound VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDSVxd( void )
    {
	DDHELPDATA hd;
	hd.req = DDHELPREQ_GETDSVXDHANDLE;
	sendRequest( &hd );
	return (HANDLE) hd.dwReturn;
    } /* HelperGetDSVxd */
#endif /* WIN95 */

/*
 * HelperSetOnDisplayChangeNotify
 *
 * get the helper to call us back if there is DisplayChange
 * message. (This is for multi-mon topology changes.)
 */
void HelperSetOnDisplayChangeNotify( void *pfn )
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_NOTIFYONDISPLAYCHANGE;
    hd.dwData1 = (DWORD)pfn;
    sendRequest( &hd );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\misc\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>

#ifdef __cplusplus
	extern "C" {
#endif
#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && !defined(WINNT)
	#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
	#define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

    /*
     * Debugging output/flow-control calls
     */
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
 
    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}


#else
    #pragma warning(disable:4002)
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()

#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD myclockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD myclock()	 {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= myclock(), t ## N ++
    #define TIMESTOP(t)   t ## T += myclock()
    #define TIMEFMT(t)	  ((DWORD)(t) / myclockrate()), (((DWORD)(t) * 1000 / myclockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#ifdef __cplusplus
}
#endif

#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\guids\guids.cpp ===
#include <initguid.h>
#include "dplay8.h"
#include "dpaddr.h"
#include "dpsp8.h"
#include "dp8sim.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\misc\newdpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.c
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(DBG)

#ifdef IS_16
    #define OUTPUTDEBUGSTRING OutputDebugString
    #define GETPROFILESTRING GetProfileString
    #define GETPROFILEINT GetProfileInt
    #define WSPRINTF wsprintf
    #define WVSPRINTF wvsprintf
    #define LSTRLEN lstrlen
#else
    #define OUTPUTDEBUGSTRING OutputDebugStringA
    #define GETPROFILESTRING GetProfileStringA
    #define GETPROFILEINT GetProfileIntA
    #define WSPRINTF wsprintfA
    #define WVSPRINTF wvsprintfA
    #define LSTRLEN lstrlenA
#endif

#include "dpf.h"

#undef DEBUG_TOPIC
#define DEBUG_TOPIC(flag,name) {#flag,name,TRUE},

static 
    struct {
        char cFlag[4];
        char cName[64];
        BOOL bOn;
} DebugTopics[] = {
    {"","Filler",FALSE},
    {"A","API Usage",TRUE},
#include "DBGTOPIC.H"
    {"","End",FALSE}
};

#ifndef DPF_MODULE_NAME
    #define DPF_MODULE_NAME ""
#endif

static DWORD bDetailOn = 1;

static BOOL bInited=FALSE;
static BOOL bAllowMisc=TRUE;
static bBreakOnAsserts=FALSE;
static bPrintLineNumbers=FALSE;
static bPrintFileNames=FALSE;
static bPrintExecutableName=FALSE;
static bPrintTID=FALSE;
static bPrintPID=FALSE;
static bIndentOnMessageLevel=FALSE;
static bPrintTopicsAndLevels=FALSE;
static bPrintModuleName=TRUE;
static bPrintFunctionName=FALSE;
static bRespectColumns=FALSE;
static bPrintAPIStats=FALSE;
static bPrintAllTopics=TRUE;

static DWORD dwFileLineTID=0;
static char cFile[100];
static char cFnName[100];
static DWORD dwLineNo;
static bMute=FALSE;

static BOOL bLogging=FALSE; // whether to use the logging VxD instead of dumping.


DPF_PROC_STATS ProcStats[MAX_PROC_ORDINAL];
#ifdef cplusplus
	extern "C" {
#endif

void mystrncpy(char * to,char * from,int n)
{
    for(;n;n--)
        *(to++)=*(from++);
}

char * mystrrchr(char * in,char c)
{
    char * last=0;
    while (*in)
    {
        if (*in == c)
            last = in;
        in++;
    }
    return last;
}

char Junk[]="DPF_MODNAME undef'd";
char * DPF_MODNAME = Junk;
 
int DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber, LPSTR szFnName)
{
    if (!(bPrintFileNames||bPrintLineNumbers||bPrintFunctionName))
    {
        return 1;
    }
#ifdef WIN32
    dwFileLineTID = GetCurrentThreadId();
#endif
    mystrncpy (cFile,szFile,sizeof(cFile));
    mystrncpy (cFnName,szFnName,sizeof(cFnName));
    dwLineNo = dwLineNumber;
    return 1;
}

/*
BOOL DeviceIoControl( 
HANDLE hDevice, 			// handle to device of interest 
DWORD dwIoControlCode, 		// control code of operation to perform 
LPVOID lpInBuffer, 			// pointer to buffer to supply input data 
DWORD nInBufferSize, 		// size of input buffer 
LPVOID lpOutBuffer, 		// pointer to buffer to receive output data 
DWORD nOutBufferSize, 		// size of output buffer 
LPDWORD lpBytesReturned, 	// pointer to variable to receive output byte count 
LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation 
); 
*/

#define MAX_STRING       240
#define LOG_SIZE         2000
#define FIRST_DEBUG_PROC 100

#define OPEN_DEBUGLOG 	(FIRST_DEBUG_PROC)
#define WRITE_DEBUGLOG 	(FIRST_DEBUG_PROC+1)

HANDLE hDPLAY_VxD=0;

typedef struct _LOGENTRY {
	CHAR	debuglevel;
	CHAR    str[1];
} LOGENTRY, *PLOGENTRY;

typedef struct {
	UINT	nLogEntries;
	UINT    nCharsPerLine;
} IN_LOGINIT, *PIN_LOGINIT;

typedef struct {
	UINT    hr;
} OUT_LOGINIT, *POUT_LOGINIT;

typedef struct {
	CHAR	debuglevel;
	CHAR    str[1];
} IN_LOGWRITE, *PIN_LOGWRITE;

typedef struct {
	UINT	hr;
} OUT_LOGWRITE, *POUT_LOGWRITE;


static void LogString( LPSTR str )
{
	char logstring[MAX_STRING+sizeof(LOGENTRY)];
	int  i=0;
	PLOGENTRY pLogEntry=(PLOGENTRY)&logstring;
	UINT rc;
	UINT cbRet;

	if(hDPLAY_VxD && str){
		while(str[i])i++;
		pLogEntry->debuglevel=0;
		memcpy(pLogEntry->str,str,i+1);
		DeviceIoControl(hDPLAY_VxD,WRITE_DEBUGLOG,pLogEntry,i+sizeof(LOGENTRY), &rc, sizeof(rc), &cbRet, NULL);
	}
}

static void dumpStr( LPSTR str )
{
    /*
     * Have to warm the string, since OutputDebugString is buried
     * deep enough that it won't page the string in before reading it.
     */
    int i=0;
    if (str)
        while(str[i])
            i++;
	if(bLogging!=2)
	{            
	    OUTPUTDEBUGSTRING( str );
	    OUTPUTDEBUGSTRING("\n");
    }
    if(bLogging)
    {
	    LogString(str);
	}    
    
}
    
void DebugPrintfInit(void)
{
    signed int lDebugLevel;
    int i;
    char cTopics[100];

#ifndef PROF_SECT
    #define PROF_SECT	"DirectDraw"
#endif
    bDetailOn=1;

    for (i=0;i<LAST_TOPIC;i++)
        DebugTopics[i].bOn=FALSE;

    //ZeroMemory(ProcStats,sizeof(ProcStats));

    GETPROFILESTRING( "DirectX", DPF_CONTROL_LINE, "DefaultTopics", cTopics, sizeof(cTopics) );
    if (!strcmp(cTopics,"DefaultTopics"))
    {
        DebugSetTopicsAndLevels("");
        bAllowMisc=TRUE;
        bPrintAllTopics=TRUE;
        lDebugLevel = (signed int) GETPROFILEINT( PROF_SECT, "debug", 0 );
        bLogging    = (signed int) GETPROFILEINT( PROF_SECT, "log" , 0);

        if (lDebugLevel <0)
        {
            if (lDebugLevel < -9)
                lDebugLevel=-9;

            bDetailOn |= (1<<(-lDebugLevel));
        }
        else
        {
            for (i=0;i<= (lDebugLevel<10?lDebugLevel:10);i++)
                bDetailOn |= 1<<i;
        }

        if(bLogging){
        	hDPLAY_VxD = CreateFileA("\\\\.\\DPLAY",0,0,0,0,0,0);
        	if(hDPLAY_VxD){
        		IN_LOGINIT In;
        		OUT_LOGINIT Out;
        		UINT cbRet;
        		In.nCharsPerLine=MAX_STRING;
        		In.nLogEntries=5000;
				DeviceIoControl(hDPLAY_VxD,OPEN_DEBUGLOG,&In,sizeof(In), &Out, sizeof(Out), &cbRet, NULL);
        	}
        }
    }
    else
    {
        DebugSetTopicsAndLevels(cTopics);
        if (!strcmp(cTopics,"?") && !bInited)
        {
            dumpStr("--------------" DPF_MODULE_NAME " Debug Output Control -------------");
            dumpStr("Each character on the control line controls a topic, a detail");
            dumpStr("level or an extra info. E.g. 0-36A@ means print detail levels 0");
            dumpStr("through 3 and 6 for topic A with source file name and line numbers.");
            dumpStr("The extra info control characters are:");
            dumpStr("   !: Break on asserts");
            dumpStr("   ^: Print TID of calling thread");
            dumpStr("   #: Print PID of calling process");
            dumpStr("   >: Indent on message detail levels");
            dumpStr("   &: Print the topic and detail level of each message");
            dumpStr("   =: Print function name");
            dumpStr("   +: Print all topics, including topic-less");
            dumpStr("   / or -: do not allow topic-less messages");
            dumpStr("   @ or $: Print source filename and line number of DPF");
            dumpStr("Topics for this module are:");
            for(i=0;strcmp(DebugTopics[i].cName,"End");i++)
            {
                OUTPUTDEBUGSTRING("   ");
                OUTPUTDEBUGSTRING(DebugTopics[i].cFlag);
                OUTPUTDEBUGSTRING(": ");
                dumpStr(DebugTopics[i].cName);
            }
            dumpStr("Tip: Use 0-3A to get debug info about API calls");
        }
    }
    bInited=TRUE;
}


/*
 *
 * The full output can be:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn) Messagemessagemessage
 * or, if indentation turned on:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn)        Messagemessagemessage
 */
int DebugPrintf(DWORD dwDetail, ...)
{
#define MSGBUFFERSIZE 1000
    char cMsg[MSGBUFFERSIZE];
    char cTopics[20];
    DWORD arg;
    LPSTR szFormat;
    BOOL bAllowed=FALSE;
    BOOL bMiscMessage=TRUE;
    int i;

    va_list ap;


    if (!bInited)
        DebugPrintfInit();

	if(bLogging != 2){
	    //error checking:
	    if (dwDetail >= 10)
	        return 1;

	    if ( (bDetailOn & (1<<dwDetail)) == 0 )
	        return 1;

	    if (bMute)
	        return 1;
	}        
    va_start(ap,dwDetail);
    WSPRINTF(cTopics,"%d",dwDetail);

    while ( (arg = va_arg(ap,DWORD)) <256 )
    {
        if (arg>0 && arg < LAST_TOPIC)
        {
            bMiscMessage=FALSE;
            if (DebugTopics[arg].bOn)
                bAllowed = TRUE;
        }
    }
    if (bMiscMessage)
        if (bAllowMisc || dwDetail == 0)
            bAllowed=TRUE;

    if ( bPrintAllTopics )
        bAllowed=TRUE;

    if (!bAllowed)
        return FALSE;

    szFormat = (LPSTR) arg;

    cMsg[0]=0;
    
    /*
     * Add the module name first
     */

    if (bPrintModuleName)
    {
        WSPRINTF( cMsg+strlen(cMsg),DPF_MODULE_NAME ":" );
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"(");

#ifdef WIN32
#if 0
    /*
     * deleted due to RIP in GetModuleFilename on debug windows when win16 lock held
     */
    if (bPrintExecutableName)
    {
        GetModuleFileName(NULL,str,256);
        if (mystrrchr(str,'\\'))
            WSPRINTF(cMsg+strlen(cMsg),"%12s",mystrrchr(str,'\\')+1);
    }
#endif
    if (bPrintPID)
    {
        if (bPrintExecutableName)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Px%02x",GetCurrentProcessId());
    }

    if (bPrintTID)
    {
        if (bPrintExecutableName || bPrintPID)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Tx%04x",GetCurrentThreadId());
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"):");
#endif

    if (bPrintFunctionName)
    {
        WSPRINTF( cMsg+strlen(cMsg),cFnName);
    }

    if (bPrintFileNames || bPrintLineNumbers)
    {
        if (mystrrchr(cFile,'\\'))
            WSPRINTF( cMsg+strlen(cMsg),":%12s",mystrrchr(cFile,'\\')+1 );
        else
            WSPRINTF( cMsg+strlen(cMsg),":%12s",cFile);
        WSPRINTF( cMsg+strlen(cMsg),"@%d",dwLineNo);
    }

    if (bPrintTopicsAndLevels)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(%3s)",cTopics);
    }

    if (cMsg[strlen(cMsg)-1] != ':')
        WSPRINTF( cMsg+strlen(cMsg),":");

    if (bIndentOnMessageLevel)
    {
        for(i=0;(DWORD)i<dwDetail;i++)
            strcat(cMsg," ");
    }

    WVSPRINTF( cMsg+LSTRLEN( cMsg ), szFormat, ap);

    if (bAllowed)
        dumpStr( cMsg );

    va_end(ap);
    return 1;
    
}

void DebugSetMute(BOOL bMuteFlag)
{
    bMute=bMuteFlag;
}

void DebugEnterAPI(char *pFunctionName , LPDWORD pIface)
{
    // 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers and handles.
	DebugPrintf(2,A,"%p->%s",pIface,pFunctionName);
}

void DebugSetTopicsAndLevels(char * cTopics)
{
    int i;
    int j;
    bAllowMisc=TRUE;
    bBreakOnAsserts=FALSE;
    bPrintLineNumbers=FALSE;
    bPrintFileNames=FALSE;
    bPrintExecutableName=FALSE;
    bPrintTID=FALSE;
    bPrintPID=FALSE;
    bIndentOnMessageLevel=FALSE;
    bPrintTopicsAndLevels=FALSE;
    bPrintFunctionName=FALSE;
    bPrintAPIStats=FALSE;
    bPrintAllTopics=FALSE;
    bDetailOn=1;    /* always print detail level 0*/


    for (i=0;(DWORD)i<strlen(cTopics);i++)
    {
        switch (cTopics[i])
        {
        case '/':
        case '-':
            bAllowMisc=FALSE;
            break;
        case '!':
            bBreakOnAsserts=TRUE;
            break;
        case '@':
            bPrintLineNumbers=TRUE;
            break;
        case '$':
            bPrintFileNames=TRUE;
            break;
#if 0
            /*
             * Currently deleted because GetModuleFilename causes a RIP on debug windows when the win16
             * lock is held.
             */
        case '?':
            bPrintExecutableName=TRUE;
            break;
#endif
        case '^':
            bPrintTID=TRUE;
            break;
        case '#':
            bPrintPID=TRUE;
            break;
        case '>':
            bIndentOnMessageLevel=TRUE;
            break;
        case '&':
            bPrintTopicsAndLevels=TRUE;
            break;
        case '=':
            bPrintFunctionName=TRUE;
            break;
        case '%':
            bPrintAPIStats=TRUE;
            break;
        case '+':
            bPrintAllTopics=TRUE;
            break;
        default:
            if (cTopics[i]>='0' && cTopics[i]<='9')
            {
                if (cTopics[i+1]=='-')
                {
                    if (cTopics[i+2]>='0' && cTopics[i+2]<='9')
                    {
                        for(j=cTopics[i]-'0';j<=cTopics[i+2]-'0';j++)
                            bDetailOn |= 1<<j;
                        i+=2;
                    }
                }
                else
                    bDetailOn |= 1<<(cTopics[i]-'0');
            }
            else
            {
                for(j=0;j<LAST_TOPIC;j++)
                    if (cTopics[i]==DebugTopics[j].cFlag[0])
                        DebugTopics[j].bOn=TRUE;
            }
        } //end switch
    }
}


/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    WSPRINTF( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( bBreakOnAsserts || GETPROFILEINT( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}


#ifdef cplusplus
}
#endif

#endif //defined debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\misc\w95help.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95help.h
 *  Content:	header file for Win95 helper interface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *
 ***************************************************************************/
#ifndef __W95HELP_INCLUDED__
#define __W95HELP_INCLUDED__
#include "ddhelp.h"

#ifdef __cplusplus
extern "C" {
#endif

extern void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void SignalNewDriver( LPSTR fname, BOOL isdisp );

extern BOOL CreateHelperProcess( LPDWORD ppid );

extern void DoneWithHelperProcess( void );

extern BOOL WaitForHelperStartup( void );

extern DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context );

extern void HelperCreateThread( void );

extern DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx );

extern DWORD HelperWaveClose( DWORD hwo );

extern DWORD HelperCreateTimer( DWORD dwResolution,LPVOID pTimerProc,DWORD dwInstanceData );

extern DWORD HelperKillTimer( DWORD dwTimerID );

#ifdef _WIN32
extern HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern void HelperCallDSEmulatorCleanup( LPVOID pCleanupFunc,
                                         LPVOID pDirectSound );

#endif

extern BOOL HelperCreateModeSetThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern BOOL HelperCreateDOSBoxThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern void HelperKillModeSetThread( DWORD hInstance );

extern void HelperKillDOSBoxThread( DWORD hInstance );

extern DWORD HelperAddDPlayServer(DWORD port);
extern BOOL HelperDeleteDPlayServer();

#ifdef WIN95
extern HANDLE HelperGetDSVxd( void );
#endif

extern void HelperSetOnDisplayChangeNotify( void *pfn );

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\inc\dp8sim.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dp8sim.h
 *
 *  Content:	Header for using DP8Sim.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



#ifndef __DP8SIM_H__
#define __DP8SIM_H__



#include <ole2.h>	// for DECLARE_INTERFACE and HRESULT




#ifdef __cplusplus
extern "C" {
#endif





/****************************************************************************
 *
 * DP8Sim control object class ID
 *
 ****************************************************************************/

/*
// {89F5B2E4-1AC5-446a-9F4F-03EDE5775D31}
DEFINE_GUID(CLSID_DP8SP_DP8SIM, 
0x89f5b2e4, 0x1ac5, 0x446a, 0x9f, 0x4f, 0x3, 0xed, 0xe5, 0x77, 0x5d, 0x31);
*/

// {40530071-1A80-4420-9B74-6A73171B0876}
DEFINE_GUID(CLSID_DP8SimControl, 
0x40530071, 0x1a80, 0x4420, 0x9b, 0x74, 0x6a, 0x73, 0x17, 0x1b, 0x8, 0x76);





/****************************************************************************
 *
 * DP8Sim Control interface ID
 *
 ****************************************************************************/

// {CD41D661-BFC0-46fe-A819-6A3CE19BBEB3}
DEFINE_GUID(IID_IDP8SimControl, 
0xcd41d661, 0xbfc0, 0x46fe, 0xa8, 0x19, 0x6a, 0x3c, 0xe1, 0x9b, 0xbe, 0xb3);




/****************************************************************************
 *
 * DP8Sim Control structures
 *
 ****************************************************************************/

typedef struct _DP8SIM_PARAMETERS
{
	DWORD	dwSize;					// size of this structure, must be filled in prior to calling GetAllParameters or SetAllParameters
	DWORD	dwBandwidthBPS;			// bandwidth in bytes per second, or 0 for no limit
	DWORD	dwPacketLossPercent;	// percentage of packets to drop
	DWORD	dwMinLatencyMS;			// minimum artificial latency (on top of any caused by bandwidth settings)
	DWORD	dwMaxLatencyMS;			// maximum artificial latency (on top of any caused by bandwidth settings)
} DP8SIM_PARAMETERS, * PDP8SIM_PARAMETERS;

typedef struct _DP8SIM_STATISTICS
{
	DWORD	dwSize;					// size of this structure, must be filled in prior to calling GetAllStatistics
	DWORD	dwTransmitted;			// number of packets sent/received
	DWORD	dwDropped;				// number of packets intentionally dropped
} DP8SIM_STATISTICS, * PDP8SIM_STATISTICS;





/****************************************************************************
 *
 * DP8Sim Control application interfaces
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDP8SimControl
DECLARE_INTERFACE_(IDP8SimControl, IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)				(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)				(THIS) PURE;
	STDMETHOD_(ULONG,Release)				(THIS) PURE;

	/*** IDP8SimControl methods ***/
	STDMETHOD(Initialize)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(Close)						(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(EnableControlForSP)			(THIS_ const GUID * const pguidSP, const WCHAR * const wszNewFriendlyName, const DWORD dwFlags) PURE;
	STDMETHOD(DisableControlForSP)			(THIS_ const GUID * const pguidSP, const DWORD dwFlags) PURE;
	STDMETHOD(GetControlEnabledForSP)		(THIS_ const GUID * const pguidSP, BOOL * const pfEnabled, const DWORD dwFlags) PURE;
	STDMETHOD(GetAllParameters)				(THIS_ DP8SIM_PARAMETERS * const pdp8spSend, DP8SIM_PARAMETERS * const pdp8spReceive, const DWORD dwFlags) PURE;
	STDMETHOD(SetAllParameters)				(THIS_ const DP8SIM_PARAMETERS * const pdp8spSend, const DP8SIM_PARAMETERS * const pdp8spReceive, const DWORD dwFlags) PURE;
	STDMETHOD(GetAllStatistics)				(THIS_ DP8SIM_STATISTICS * const pdp8ssSend, DP8SIM_STATISTICS * const pdp8ssReceive, const DWORD dwFlags) PURE;
	STDMETHOD(ClearAllStatistics)			(THIS_ const DWORD dwFlags) PURE;
};




/****************************************************************************
 *
 * DP8Sim Control application interface macros
 *
 ****************************************************************************/

#if (! defined(__cplusplus) || defined(CINTERFACE))

#define	IDP8SimControl_QueryInterface(p,a,b)			(p)->lpVtbl->QueryInterface(p,a,b)
#define	IDP8SimControl_AddRef(p)						(p)->lpVtbl->AddRef(p)
#define	IDP8SimControl_Release(p)						(p)->lpVtbl->Release(p)
#define	IDP8SimControl_Initialize(p,a)					(p)->lpVtbl->Initialize(p,a)
#define	IDP8SimControl_Close(p,a)						(p)->lpVtbl->Close(p,a)
#define	IDP8SimControl_EnableControlForSP(p,a,b,c)		(p)->lpVtbl->EnableControlForSP(p,a,b,c)
#define	IDP8SimControl_DisableControlForSP(p,a,b)		(p)->lpVtbl->DisableControlForSP(p,a,b)
#define	IDP8SimControl_GetControlEnabledForSP(p,a,b,c)	(p)->lpVtbl->GetControlEnabledForSP(p,a,b,c)
#define	IDP8SimControl_GetAllParameters(p,a,b,c)		(p)->lpVtbl->GetAllParameters(p,a,b,c)
#define	IDP8SimControl_SetAllParameters(p,a,b,c)		(p)->lpVtbl->SetAllParameters(p,a,b,c)
#define	IDP8SimControl_GetAllStatistics(p,a,b,c)		(p)->lpVtbl->GetAllStatistics(p,a,b,c)
#define	IDP8SimControl_ClearAllStatistics(p,a)			(p)->lpVtbl->ClearAllStatistics(p,a)

#else // C++

#define	IDP8SimControl_QueryInterface(p,a,b)			(p)->QueryInterface(a,b)
#define	IDP8SimControl_AddRef(p)						(p)->AddRef()
#define	IDP8SimControl_Release(p)						(p)->Release()
#define	IDP8SimControl_Initialize(p,a)					(p)->Initialize(a)
#define	IDP8SimControl_Close(p,a)						(p)->Close(a)
#define	IDP8SimControl_EnableControlForSP(p,a,b,c)		(p)->EnableControlForSP(p,a,b,c)
#define	IDP8SimControl_DisableControlForSP(p,a,b)		(p)->DisableControlForSP(p,a,b)
#define	IDP8SimControl_GetControlEnabledForSP(p,a,b,c)	(p)->GetControlEnabledForSP(p,a,b,c)
#define	IDP8SimControl_GetAllParameters(p,a,b,c)		(p)->GetAllParameters(p,a,b,c)
#define	IDP8SimControl_SetAllParameters(p,a,b,c)		(p)->SetAllParameters(p,a,b,c)
#define	IDP8SimControl_GetAllStatistics(p,a,b,c)		(p)->GetAllStatistics(p,a,b,c)
#define	IDP8SimControl_ClearAllStatistics(p,a)			(p)->ClearAllStatistics(p,a)

#endif



/****************************************************************************
 *
 * DP8Sim Control return codes
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _DP8SIMH_FACILITY_CODE				0x015
#define _DP8SIMH_HRESULT_BASE				0xE000

#define MAKE_DP8SIMSUCCESS(code)			MAKE_HRESULT(0, _DP8SIMH_FACILITY_CODE, (code + _DP8SIMH_HRESULT_BASE))
#define MAKE_DP8SIMFAILURE(code)			MAKE_HRESULT(1, _DP8SIMH_FACILITY_CODE, (code + _DP8SIMH_HRESULT_BASE))



#define DP8SIM_OK							S_OK

//#define DP8SIMERR_ALREADYINITIALIZED		MAKE_DP8SIMFAILURE(0x?)
#define DP8SIMERR_ALREADYENABLEDFORSP		MAKE_DP8SIMFAILURE(0x10)
#define DP8SIMERR_GENERIC					E_FAIL
//#define DP8SIMERR_INVALIDFLAGS				MAKE_DP8SIMFAILURE(0x?)
//#define DP8SIMERR_INVALIDOBJECT				MAKE_DP8SIMFAILURE(0x?)
//#define DP8SIMERR_INVALIDPARAM				E_INVALIDARG
//#define DP8SIMERR_INVALIDPOINTER			E_POINTER
#define DP8SIMERR_MISMATCHEDVERSION			MAKE_DP8SIMFAILURE(0x20)
//#define DP8SIMERR_NOTINITIALIZED			MAKE_DP8SIMFAILURE(0x?)
#define DP8SIMERR_NOTENABLEDFORSP			MAKE_DP8SIMFAILURE(0x30)
#define DP8SIMERR_OUTOFMEMORY				E_OUTOFMEMORY




//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * DP8Sim settings registry base
 *
 ****************************************************************************/

#define DN_REG_LOCAL_DP8SIM_ROOT	L"\\DP8Sim"






//@@END_MSINTERNAL
#ifdef __cplusplus
}
#endif

#endif // __DP8SIM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\controlobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		controlobj.cpp
 *
 *  Content:	DP8SIM control interface wrapper object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/24/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::CDP8SimControl"
//=============================================================================
// CDP8SimControl constructor
//-----------------------------------------------------------------------------
//
// Description: Initializes the new CDP8SimControl object.
//
// Arguments: None.
//
// Returns: None (the object).
//=============================================================================
CDP8SimControl::CDP8SimControl(void)
{
	this->m_blList.Initialize();


	this->m_Sig[0]	= 'D';
	this->m_Sig[1]	= 'P';
	this->m_Sig[2]	= '8';
	this->m_Sig[3]	= 'S';

	this->m_lRefCount	= 1; // someone must have a pointer to this object
	this->m_dwFlags		= 0;
} // CDP8SimControl::CDP8SimControl






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::~CDP8SimControl"
//=============================================================================
// CDP8SimControl destructor
//-----------------------------------------------------------------------------
//
// Description: Frees the CDP8SimControl object.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
CDP8SimControl::~CDP8SimControl(void)
{
	DNASSERT(this->m_blList.IsEmpty());


	DNASSERT(this->m_lRefCount == 0);
	DNASSERT(this->m_dwFlags == 0);

	//
	// For grins, change the signature before deleting the object.
	//
	this->m_Sig[3]	= 's';
} // CDP8SimControl::~CDP8SimControl




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::QueryInterface"
//=============================================================================
// CDP8SimControl::QueryInterface
//-----------------------------------------------------------------------------
//
// Description: Retrieves a new reference for an interfaces supported by this
//				CDP8SimControl object.
//
// Arguments:
//	REFIID riid			- Reference to interface ID GUID.
//	LPVOID * ppvObj		- Place to store pointer to object.
//
// Returns: HRESULT
//	S_OK					- Returning a valid interface pointer.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPOINTER	- The destination pointer is invalid.
//	E_NOINTERFACE			- Invalid interface was specified.
//=============================================================================
STDMETHODIMP CDP8SimControl::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	HRESULT		hr = DPN_OK;


	DPFX(DPFPREP, 3, "(0x%p) Parameters: (REFIID, 0x%p)", this, ppvObj);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DP8SimControl object!");
		hr = DPNERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if ((! IsEqualIID(riid, IID_IUnknown)) &&
		(! IsEqualIID(riid, IID_IDP8SimControl)))
	{
		DPFX(DPFPREP, 0, "Unsupported interface!");
		hr = E_NOINTERFACE;
		goto Failure;
	}

	if ((ppvObj == NULL) ||
		(IsBadWritePtr(ppvObj, sizeof(void*))))
	{
		DPFX(DPFPREP, 0, "Invalid interface pointer specified!");
		hr = DPNERR_INVALIDPOINTER;
		goto Failure;
	}


	//
	// Add a reference, and return the interface pointer (which is actually
	// just the object pointer, they line up because CDP8SimControl inherits
	// from the interface declaration).
	//
	this->AddRef();
	(*ppvObj) = this;


Exit:

	DPFX(DPFPREP, 3, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimControl::QueryInterface




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::AddRef"
//=============================================================================
// CDP8SimControl::AddRef
//-----------------------------------------------------------------------------
//
// Description: Adds a reference to this CDP8SimControl object.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CDP8SimControl::AddRef(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());


	//
	// There must be at least 1 reference to this object, since someone is
	// calling AddRef.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedIncrement(&this->m_lRefCount);

	DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);

	return lRefCount;
} // CDP8SimControl::AddRef




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::Release"
//=============================================================================
// CDP8SimControl::Release
//-----------------------------------------------------------------------------
//
// Description: Removes a reference to this CDP8SimControl object.  When the
//				refcount reaches 0, this object is destroyed.
//				You must NULL out your pointer to this object after calling
//				this function.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CDP8SimControl::Release(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());

	//
	// There must be at least 1 reference to this object, since someone is
	// calling Release.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedDecrement(&this->m_lRefCount);

	//
	// Was that the last reference?  If so, we're going to destroy this object.
	//
	if (lRefCount == 0)
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount hit 0, destroying object.", this);

		//
		// First pull it off the global list.
		//
		DNEnterCriticalSection(&g_csGlobalsLock);

		this->m_blList.RemoveFromList();

		DNASSERT(g_lOutstandingInterfaceCount > 0);
		g_lOutstandingInterfaceCount--;	// update count so DLL can unload now works correctly
		
		DNLeaveCriticalSection(&g_csGlobalsLock);


		//
		// Make sure it's closed.
		//
		if (this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED)
		{
			//
			// Assert so that the user can fix his/her broken code!
			//
			DNASSERT(! "DP8SimControl object being released without calling Close first!");

			//
			// Then go ahead and do the right thing.  Ignore error, we can't do
			// much about it.
			//
			this->Close(0);
		}


		//
		// Then uninitialize the object.
		//
		this->UninitializeObject();

		//
		// Finally delete this (!) object.
		//
		delete this;
	}
	else
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);
	}

	return lRefCount;
} // CDP8SimControl::Release




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::Initialize"
//=============================================================================
// CDP8SimControl::Initialize
//-----------------------------------------------------------------------------
//
// Description: Initializes this DP8Sim Control interface.
//
// Arguments:
//	DWORD dwFlags	- Unused, must be zero.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimControl::Initialize(const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	BOOL		fHaveLock = FALSE;
	BOOL		fInitializedIPCObject = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%x)", this, dwFlags);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(dwFlags == 0);


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags == 0);


	//
	// Connect the shared memory.
	//
	hr = this->m_DP8SimIPC.Initialize();
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize IPC object!");
		goto Failure;
	}

	fInitializedIPCObject = TRUE;


	//
	// We're now initialized.
	//
	this->m_dwFlags |= DP8SIMCONTROLOBJ_INITIALIZED;



Exit:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fInitializedIPCObject)
	{
		this->m_DP8SimIPC.Close();
		fInitializedIPCObject = FALSE;
	}

	goto Exit;
} // CDP8SimControl::Initialize






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::Close"
//=============================================================================
// CDP8SimControl::Close
//-----------------------------------------------------------------------------
//
// Description: Closes this DP8Sim Control interface.
//
// Arguments:
//	DWORD dwFlags	- Unused, must be zero.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimControl::Close(const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	//BOOL		fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%x)", this, dwFlags);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(dwFlags == 0);


	DNEnterCriticalSection(&this->m_csLock);
	//fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED);




	//
	// Disconnect the shared memory.
	//
	this->m_DP8SimIPC.Close();



	//
	// Turn off the initialized flags.
	//
	this->m_dwFlags &= ~DP8SIMCONTROLOBJ_INITIALIZED;
	DNASSERT(this->m_dwFlags == 0);


	//
	// Drop the lock, nobody should be touching this object now.
	//
	DNLeaveCriticalSection(&this->m_csLock);
	//fHaveLock = FALSE;


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


/*
Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
*/
} // CDP8SimControl::Close





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::EnableControlForSP"
//=============================================================================
// CDP8SimControl::EnableControlForSP
//-----------------------------------------------------------------------------
//
// Description: Inserts the DP8Sim Control shim in front of the SP with the
//				given GUID.
//
// Arguments:
//	GUID * pguidSP				- Pointer to GUID of SP to intercept.
//	WCHAR * wszNewFriendlyName	- New friendly name for intercepted SP.
//	DWORD dwFlags				- Unused, must be zero.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimControl::EnableControlForSP(const GUID * const pguidSP,
												const WCHAR * const wszNewFriendlyName,
												const DWORD dwFlags)
{
	HRESULT		hr;
	char		szLocalPath[_MAX_PATH];
	WCHAR		wszLocalPath[_MAX_PATH];
	WCHAR		wszInProcServer32[_MAX_PATH];
	CRegistry	RegObjectCOM;
	CRegistry	RegObjectDP8SP;
	CRegistry	RegObjectDP8SPSubkey;
	DWORD		dwMaxLength;
	DWORD		dwLength;
	WCHAR *		pwszTemp = NULL;
	DWORD		dwTemp;
	GUID		guidTemp;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, \"%S\" 0x%x)",
		this, pguidSP, wszNewFriendlyName, dwFlags);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pguidSP != NULL);
	DNASSERT(wszNewFriendlyName != NULL);
	DNASSERT(dwFlags == 0);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED);


	//
	// Drop the lock.
	//
	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Retrieve the location of this DLL.
	//
	dwLength = GetModuleFileNameA(g_hDLLInstance, szLocalPath, _MAX_PATH);
	if (dwLength == 0)
	{
		DPFX(DPFPREP, 0, "Couldn't read local path!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// Include NULL termination.
	//
	dwLength++;


	//
	// Convert it to Unicode.
	//
	hr = STR_AnsiToWide(szLocalPath, dwLength, wszLocalPath, &dwLength);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Could not convert ANSI path to Unicode!");
		goto Failure;
	}



	//
	// Open the SP's COM object information key.
	//

	swprintf(wszInProcServer32, L"CLSID\\{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}\\InProcServer32",
			pguidSP->Data1, pguidSP->Data2, pguidSP->Data3, 
			pguidSP->Data4[0], pguidSP->Data4[1],
			pguidSP->Data4[2], pguidSP->Data4[3],
			pguidSP->Data4[4], pguidSP->Data4[5],
			pguidSP->Data4[6], pguidSP->Data4[7]);	

	if (! RegObjectCOM.Open(HKEY_CLASSES_ROOT, wszInProcServer32, FALSE, FALSE, FALSE))
	{
		DPFX(DPFPREP, 0, "Could not open SP InProcServer32 key!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// Make sure this SP hasn't already been modified.
	//
	dwLength = 0;
	RegObjectCOM.ReadString(DP8SIM_REG_REALSPDLL, NULL, &dwLength);
	if (dwLength > 0)
	{
		DPFX(DPFPREP, 0, "SP has already been redirected!");
		hr = DP8SIMERR_ALREADYENABLEDFORSP;
		goto Failure;
	}


	//
	// Find out the size of the original DLL name.
	//
	dwLength = 0;
	RegObjectCOM.ReadString(L"", NULL, &dwLength);


	dwLength++;
	pwszTemp = (WCHAR*) DNMalloc(dwLength * sizeof(WCHAR));
	if (pwszTemp == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}

	if (! RegObjectCOM.ReadString(L"", pwszTemp, &dwLength))
	{
		DPFX(DPFPREP, 0, "Couldn't read existing SP's DLL location!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// Save it so we can restore it later.
	//
	if (! RegObjectCOM.WriteString(DP8SIM_REG_REALSPDLL, pwszTemp))
	{
		DPFX(DPFPREP, 0, "Couldn't save SP's existing DLL location to value \"%S\"!",
			DP8SIM_REG_REALSPDLL);
		hr = E_FAIL;
		goto Failure;
	}


	DNFree(pwszTemp);
	pwszTemp = NULL;



	//
	// Find the SP key.  First allocate enough memory to hold the name the
	// longest subkey.
	//

	if (! RegObjectDP8SP.Open(HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY, FALSE, FALSE, FALSE))
	{
		DPFX(DPFPREP, 0, "Could not open DirectPlay8 SP key!");
		hr = E_FAIL;
		goto Failure;
	}

	if (! RegObjectDP8SP.GetMaxKeyLen(dwMaxLength))
	{
		DPFX(DPFPREP, 0, "Could not get longest SP key name length!");
		hr = E_FAIL;
		goto Failure;
	}

	dwMaxLength++;
	pwszTemp = (WCHAR*) DNMalloc(dwMaxLength * sizeof(WCHAR));
	if (pwszTemp == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}
	

	//
	// Walk through every key, looking for the right one.
	//
	dwTemp = 0;
	do
	{
		dwLength = dwMaxLength;
		if (! RegObjectDP8SP.EnumKeys(pwszTemp, &dwLength, dwTemp))
		{
			//
			// We couldn't get the next key.  Assume we're done.
			//
			break;
		}


		//
		// Open the subkey.
		//
		if (! RegObjectDP8SPSubkey.Open((HKEY) RegObjectDP8SP, pwszTemp, FALSE, FALSE, FALSE))
		{
			DPFX(DPFPREP, 0, "Could not open DirectPlay8 SP sub key \"%S\"!  Ignoring.", pwszTemp);
		}
		else
		{
			//
			// See if the GUID matches.
			//
			RegObjectDP8SPSubkey.ReadGUID(DPN_REG_KEYNAME_GUID, guidTemp);

			if (guidTemp == (*pguidSP))
			{
				//
				// Found SP.
				//
				DPFX(DPFPREP, 5, "Found SP under sub key \"%S\".", pwszTemp);
				break;
			}

			RegObjectDP8SPSubkey.Close();
		}

		//
		// Got to next subkey.
		//
		dwTemp++;
	}
	while (TRUE);


	//
	// If we didn't find the SP, the subkey will be closed.
	//
	if (! RegObjectDP8SPSubkey.IsOpen())
	{
		DPFX(DPFPREP, 0, "Didn't find DirectPlay8 SP matching given GUID!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// We don't need the main SP key or name buffer anymore.
	//
	RegObjectDP8SP.Close();
	DNFree(pwszTemp);
	pwszTemp = NULL;


	//
	// Find the size of the original SP friendly name.
	//
	dwLength = 0;
	RegObjectDP8SPSubkey.ReadString(DPN_REG_KEYNAME_FRIENDLY_NAME, NULL, &dwLength);


	dwLength++;
	pwszTemp = (WCHAR*) DNMalloc(dwLength * sizeof(WCHAR));
	if (pwszTemp == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}

	if (! RegObjectDP8SPSubkey.ReadString(DPN_REG_KEYNAME_FRIENDLY_NAME, pwszTemp, &dwLength))
	{
		DPFX(DPFPREP, 0, "Couldn't read existing SP's friendly name!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// Save it so we can restore it later.
	//
	if (! RegObjectDP8SPSubkey.WriteString(DP8SIM_REG_REALSPFRIENDLYNAME, pwszTemp))
	{
		DPFX(DPFPREP, 0, "Couldn't save SP's existing friendly name to value \"%S\"!",
			DP8SIM_REG_REALSPFRIENDLYNAME);
		hr = E_FAIL;
		goto Failure;
	}



	//
	// Write our replacement DLL's friendly name.
	//
	if (! RegObjectDP8SPSubkey.WriteString(DPN_REG_KEYNAME_FRIENDLY_NAME, wszNewFriendlyName))
	{
		DPFX(DPFPREP, 0, "Couldn't write our new SP friendly name to registry!");
		hr = E_FAIL;
		goto Failure;
	}


	RegObjectDP8SPSubkey.Close();



	//
	// Finally write our replacement DLL's location.
	//
	if (! RegObjectCOM.WriteString(L"", wszLocalPath))
	{
		DPFX(DPFPREP, 0, "Couldn't write our DLL location to registry!");
		hr = E_FAIL;
		goto Failure;
	}


	RegObjectCOM.Close();



Exit:

	if (pwszTemp != NULL)
	{
		DNFree(pwszTemp);
		pwszTemp = NULL;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	//
	// RegObjectCOM, RegObjectDP8SP, and RegObjectDP8SPSubkey are all
	// implicitly closed by their destructors, if necessary.
	//

	goto Exit;
} // EnableControlForSP





#undef DPF_MODNAME
#define DPF_MODNAME "DisableControlForSP"
//=============================================================================
// CDP8SimControl::DisableControlForSP
//-----------------------------------------------------------------------------
//
// Description: Removes the DP8Sim Control shim from the SP with the given
//				GUID.
//
// Arguments:
//	GUID * pguidSP	- Pointer to GUID of SP that should no longer be
//						intercepted.
//	DWORD dwFlags	- Unused, must be zero.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimControl::DisableControlForSP(const GUID * const pguidSP,
												const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	WCHAR		wszInProcServer32[_MAX_PATH];
	CRegistry	RegObject;
	CRegistry	RegObjectSubkey;
	DWORD		dwMaxLength;
	DWORD		dwLength;
	WCHAR *		pwszTemp = NULL;
	DWORD		dwTemp;
	GUID		guidTemp;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%x)", this, pguidSP, dwFlags);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pguidSP != NULL);
	DNASSERT(dwFlags == 0);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED);


	//
	// Drop the lock.
	//
	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Find the SP key.  First allocate enough memory to hold the name the
	// longest subkey.
	//

	if (! RegObject.Open(HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY, FALSE, FALSE, FALSE))
	{
		DPFX(DPFPREP, 0, "Could not open DirectPlay8 SP key!");
		hr = E_FAIL;
		goto Failure;
	}

	if (! RegObject.GetMaxKeyLen(dwMaxLength))
	{
		DPFX(DPFPREP, 0, "Could not get longest SP key name length!");
		hr = E_FAIL;
		goto Failure;
	}

	dwMaxLength++;
	pwszTemp = (WCHAR*) DNMalloc(dwMaxLength * sizeof(WCHAR));
	if (pwszTemp == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}
	

	//
	// Walk through every key, looking for the right one.
	//
	dwTemp = 0;
	do
	{
		dwLength = dwMaxLength;
		if (! RegObject.EnumKeys(pwszTemp, &dwLength, dwTemp))
		{
			//
			// We couldn't get the next key.  Assume we're done.
			//
			break;
		}


		//
		// Open the subkey.
		//
		if (! RegObjectSubkey.Open((HKEY) RegObject, pwszTemp, FALSE, FALSE, FALSE))
		{
			DPFX(DPFPREP, 0, "Could not open DirectPlay8 SP sub key \"%S\"!  Ignoring.", pwszTemp);
		}
		else
		{
			//
			// See if the GUID matches.
			//
			RegObjectSubkey.ReadGUID(DPN_REG_KEYNAME_GUID, guidTemp);

			if (guidTemp == (*pguidSP))
			{
				//
				// Found SP.
				//
				DPFX(DPFPREP, 5, "Found SP under sub key \"%S\".", pwszTemp);
				break;
			}

			RegObjectSubkey.Close();
		}


		//
		// Got to next subkey.
		//
		dwTemp++;
	}
	while (TRUE);


	//
	// If we didn't find the SP, the subkey will be closed.
	//
	if (! RegObjectSubkey.IsOpen())
	{
		DPFX(DPFPREP, 0, "Didn't find DirectPlay8 SP matching given GUID!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// We don't need the main SP key or name buffer anymore.
	//
	RegObject.Close();
	DNFree(pwszTemp);
	pwszTemp = NULL;


	//
	// Find the size of the original SP friendly name.
	//
	dwLength = 0;
	RegObjectSubkey.ReadString(DP8SIM_REG_REALSPFRIENDLYNAME, NULL, &dwLength);


	dwLength++;
	pwszTemp = (WCHAR*) DNMalloc(dwLength * sizeof(WCHAR));
	if (pwszTemp == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}

	if (! RegObjectSubkey.ReadString(DP8SIM_REG_REALSPFRIENDLYNAME, pwszTemp, &dwLength))
	{
		DPFX(DPFPREP, 0, "Couldn't read SP's original friendly name!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// Restore the value.
	//
	if (! RegObjectSubkey.WriteString(DPN_REG_KEYNAME_FRIENDLY_NAME, pwszTemp))
	{
		DPFX(DPFPREP, 0, "Couldn't restore SP's original friendly name!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// Delete the restoration key.
	//
	if (! RegObjectSubkey.DeleteValue(DP8SIM_REG_REALSPFRIENDLYNAME))
	{
		DPFX(DPFPREP, 0, "Couldn't delete friendly name restoration key \"%S\"!",
			DP8SIM_REG_REALSPDLL);
		hr = E_FAIL;
		goto Failure;
	}


	RegObjectSubkey.Close();

	DNFree(pwszTemp);
	pwszTemp = NULL;



	//
	// Open the SP's COM object information key.
	//

	swprintf(wszInProcServer32, L"CLSID\\{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}\\InProcServer32",
			pguidSP->Data1, pguidSP->Data2, pguidSP->Data3, 
			pguidSP->Data4[0], pguidSP->Data4[1],
			pguidSP->Data4[2], pguidSP->Data4[3],
			pguidSP->Data4[4], pguidSP->Data4[5],
			pguidSP->Data4[6], pguidSP->Data4[7]);	

	if (! RegObject.Open(HKEY_CLASSES_ROOT, wszInProcServer32, FALSE, FALSE, FALSE))
	{
		DPFX(DPFPREP, 0, "Could not open SP InProcServer32 key!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// Read the location of the original DLL.
	//
	dwLength = 0;
	RegObject.ReadString(DP8SIM_REG_REALSPDLL, NULL, &dwLength);


	dwLength++;
	pwszTemp = (WCHAR*) DNMalloc(dwLength * sizeof(WCHAR));
	if (pwszTemp == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}

	if (! RegObject.ReadString(DP8SIM_REG_REALSPDLL, pwszTemp, &dwLength))
	{
		DPFX(DPFPREP, 0, "Couldn't read original SP's DLL location (\"%S\"), assuming DP8Sim was not enabled!",
			DP8SIM_REG_REALSPDLL);
		hr = DP8SIMERR_NOTENABLEDFORSP;
		goto Failure;
	}


	//
	// Restore the value.
	//
	if (! RegObject.WriteString(L"", pwszTemp))
	{
		DPFX(DPFPREP, 0, "Couldn't restore SP's original DLL location!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// Delete the restoration key.
	//
	if (! RegObject.DeleteValue(DP8SIM_REG_REALSPDLL))
	{
		DPFX(DPFPREP, 0, "Couldn't delete restoration key \"%S\"!",
			DP8SIM_REG_REALSPDLL);
		hr = E_FAIL;
		goto Failure;
	}


	RegObject.Close();


	//
	// Since we can't actually unload the wrapper from any processes already
	// using it, those will continue using the current settings
	//



Exit:

	if (pwszTemp != NULL)
	{
		DNFree(pwszTemp);
		pwszTemp = NULL;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	//
	// RegObject, and RegObjectSubkey are implicitly closed by their
	// destructors, if necessary.
	//

	goto Exit;
} // DisableControlForSP





#undef DPF_MODNAME
#define DPF_MODNAME "GetControlEnabledForSP"
//=============================================================================
// CDP8SimControl::GetControlEnabledForSP
//-----------------------------------------------------------------------------
//
// Description: Determines whether the DP8Sim Control shim is enabled for the
//				SP with the given GUID or not.  TRUE is returned in pfEnabled
//				if so, FALSE if not.
//
// Arguments:
//	GUID * pguidSP		- Pointer to GUID of SP that should be checked.
//	BOOL * pfEnabled	- Place to store boolean indicating status.
//	DWORD dwFlags		- Unused, must be zero.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimControl::GetControlEnabledForSP(const GUID * const pguidSP,
													BOOL * const pfEnabled,
													const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	WCHAR		wszInProcServer32[_MAX_PATH];
	CRegistry	RegObject;
	CRegistry	RegObjectSubkey;
	DWORD		dwLength;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%p, 0x%x)",
		this, pguidSP, pfEnabled, dwFlags);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pguidSP != NULL);
	DNASSERT(pfEnabled != NULL);
	DNASSERT(dwFlags == 0);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED);


	//
	// Drop the lock.
	//
	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Open the SP's COM object information key.
	//

	swprintf(wszInProcServer32, L"CLSID\\{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}\\InProcServer32",
			pguidSP->Data1, pguidSP->Data2, pguidSP->Data3, 
			pguidSP->Data4[0], pguidSP->Data4[1],
			pguidSP->Data4[2], pguidSP->Data4[3],
			pguidSP->Data4[4], pguidSP->Data4[5],
			pguidSP->Data4[6], pguidSP->Data4[7]);	

	if (! RegObject.Open(HKEY_CLASSES_ROOT, wszInProcServer32, FALSE, FALSE, FALSE))
	{
		DPFX(DPFPREP, 0, "Could not open SP InProcServer32 key!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// Try reading the location of the original DLL.  dwLength will stay 0 if
	// the registry key could not be opened.
	//
	dwLength = 0;
	RegObject.ReadString(DP8SIM_REG_REALSPDLL, NULL, &dwLength);
	if (dwLength == 0)
	{
		DPFX(DPFPREP, 1, "Couldn't read original SP's DLL location (\"%S\"), assuming DP8Sim was not enabled.",
			DP8SIM_REG_REALSPDLL);
		(*pfEnabled) = FALSE;
	}
	else
	{
		DPFX(DPFPREP, 1, "Retrieved original SP's DLL location value size, assuming DP8Sim was enabled.");
		(*pfEnabled) = TRUE;
	}


	RegObject.Close();



Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	//
	// RegObject, and RegObjectSubkey are implicitly closed by their
	// destructors, if necessary.
	//

	goto Exit;
} // GetControlEnabledForSP






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::GetAllParameters"
//=============================================================================
// CDP8SimControl::GetAllParameters
//-----------------------------------------------------------------------------
//
// Description: Retrieves all of the current DP8Sim settings.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8spSend		- Place to store current send
//											parameters.
//	DP8SIM_PARAMETERS * pdp8spReceive	- Place to store current receive
//											parameters.
//	DWORD dwFlags						- Unused, must be zero.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimControl::GetAllParameters(DP8SIM_PARAMETERS * const pdp8spSend,
											DP8SIM_PARAMETERS * const pdp8spReceive,
											const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	//BOOL		fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%p, 0x%x)",
		this, pdp8spSend, pdp8spReceive, dwFlags);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pdp8spSend != NULL);
	DNASSERT(pdp8spReceive != NULL);
	DNASSERT(dwFlags == 0);


	DNEnterCriticalSection(&this->m_csLock);
	//fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED);


	//
	// Retrieve the settings from the IPC object.
	//
	this->m_DP8SimIPC.GetAllParameters(pdp8spSend, pdp8spReceive);


	//
	// Drop the lock.
	//
	DNLeaveCriticalSection(&this->m_csLock);
	//fHaveLock = FALSE;


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


/*
Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
*/
} // CDP8SimControl::GetAllParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::SetAllParameters"
//=============================================================================
// CDP8SimControl::SetAllParameters
//-----------------------------------------------------------------------------
//
// Description: Modifies the current DP8Sim settings.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8spSend		- Structure containing desired send
//											parameters.
//	DP8SIM_PARAMETERS * pdp8spReceive	- Structure containing desired
//											receive parameters.
//	DWORD dwFlags						- Unused, must be zero.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimControl::SetAllParameters(const DP8SIM_PARAMETERS * const pdp8spSend,
											const DP8SIM_PARAMETERS * const pdp8spReceive,
											const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	//BOOL		fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%p, 0x%x)",
		this, pdp8spSend, pdp8spReceive, dwFlags);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pdp8spSend != NULL);
	DNASSERT(pdp8spSend->dwMinLatencyMS <= pdp8spSend->dwMaxLatencyMS);
	DNASSERT(pdp8spReceive != NULL);
	DNASSERT(pdp8spReceive->dwMinLatencyMS <= pdp8spReceive->dwMaxLatencyMS);
	DNASSERT(dwFlags == 0);


	DNEnterCriticalSection(&this->m_csLock);
	//fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED);


	//
	// Store the settings with the IPC object.
	//
	this->m_DP8SimIPC.SetAllParameters(pdp8spSend, pdp8spReceive);


	//
	// Drop the lock.
	//
	DNLeaveCriticalSection(&this->m_csLock);
	//fHaveLock = FALSE;


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


/*
Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
*/
} // CDP8SimControl::SetAllParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::GetAllStatistics"
//=============================================================================
// CDP8SimControl::GetAllStatistics
//-----------------------------------------------------------------------------
//
// Description: Retrieves all of the current DP8Sim statistics.
//
// Arguments:
//	DP8SIM_STATISTICS * pdp8ssSend		- Place to store current send
//											statistics.
//	DP8SIM_STATISTICS * pdp8ssReceive	- Place to store current receive
//											statistics.
//	DWORD dwFlags						- Unused, must be zero.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimControl::GetAllStatistics(DP8SIM_STATISTICS * const pdp8ssSend,
											DP8SIM_STATISTICS * const pdp8ssReceive,
											const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	//BOOL		fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%p, 0x%x)",
		this, pdp8ssSend, pdp8ssReceive, dwFlags);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pdp8ssSend != NULL);
	DNASSERT(pdp8ssReceive != NULL);
	DNASSERT(dwFlags == 0);


	DNEnterCriticalSection(&this->m_csLock);
	//fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED);


	//
	// Retrieve the stats from the IPC object.
	//
	this->m_DP8SimIPC.GetAllStatistics(pdp8ssSend, pdp8ssReceive);


	//
	// Drop the lock.
	//
	DNLeaveCriticalSection(&this->m_csLock);
	//fHaveLock = FALSE;


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


/*
Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
*/
} // CDP8SimControl::GetAllStatistics






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::ClearAllStatistics"
//=============================================================================
// CDP8SimControl::ClearAllStatistics
//-----------------------------------------------------------------------------
//
// Description: Clears all of the current DP8Sim statistics.
//
// Arguments:
//	DWORD dwFlags	- Unused, must be zero.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimControl::ClearAllStatistics(const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	//BOOL		fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%x)", this, dwFlags);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(dwFlags == 0);


	DNEnterCriticalSection(&this->m_csLock);
	//fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED);


	//
	// Have the IPC object clear the stats.
	//
	this->m_DP8SimIPC.ClearAllStatistics();


	//
	// Drop the lock.
	//
	DNLeaveCriticalSection(&this->m_csLock);
	//fHaveLock = FALSE;


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


/*
Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
*/
} // CDP8SimControl::ClearAllStatistics






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::InitializeObject"
//=============================================================================
// CDP8SimControl::InitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Sets up the object for use like the constructor, but may
//				fail with OUTOFMEMORY.  Should only be called by class factory
//				creation routine.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK			- Initialization was successful.
//	E_OUTOFMEMORY	- There is not enough memory to initialize.
//=============================================================================
HRESULT CDP8SimControl::InitializeObject(void)
{
	HRESULT		hr;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);

	DNASSERT(this->IsValidObject());


	//
	// Create the lock.
	// 
	if (! DNInitializeCriticalSection(&this->m_csLock))
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Don't allow critical section reentry.
	//
	DebugSetCriticalSectionRecursionCount(&this->m_csLock, 0);


	hr = S_OK;

Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimControl::InitializeObject






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::UninitializeObject"
//=============================================================================
// CDP8SimControl::UninitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Cleans up the object like the destructor, mostly to balance
//				InitializeObject.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimControl::UninitializeObject(void)
{
	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	DNASSERT(this->IsValidObject());


	DNDeleteCriticalSection(&this->m_csLock);


	DPFX(DPFPREP, 5, "(0x%p) Returning", this);
} // CDP8SimControl::UninitializeObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\controlobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       controlobj.h
 *
 *  Content:	Header for DP8SIM control interface object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/24/01  VanceO    Created.
 *
 ***************************************************************************/



//=============================================================================
// Macros
//=============================================================================
#ifndef	OFFSETOF
#define OFFSETOF(s,m)					( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)		(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

#define DP8SIMCONTROL_FROM_BILINK(b)	(CONTAINING_OBJECT(b, CDP8SimControl, m_blList))



//=============================================================================
// Object flags
//=============================================================================
#define DP8SIMCONTROLOBJ_INITIALIZED	0x01	// object has been initialized




//=============================================================================
// Control interface object class
//=============================================================================
class CDP8SimControl : public IDP8SimControl
{
	public:
		CDP8SimControl(void);	// constructor
		~CDP8SimControl(void);	// destructor


		STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

		STDMETHODIMP_(ULONG) AddRef(void);

		STDMETHODIMP_(ULONG) Release(void);


		STDMETHODIMP Initialize(const DWORD dwFlags);

		STDMETHODIMP Close(const DWORD dwFlags);

		STDMETHODIMP EnableControlForSP(const GUID * const pguidSP, const WCHAR * const wszNewFriendlyName, const DWORD dwFlags);

		STDMETHODIMP DisableControlForSP(const GUID * const pguidSP, const DWORD dwFlags);

		STDMETHODIMP GetControlEnabledForSP(const GUID * const pguidSP, BOOL * const pfEnabled, const DWORD dwFlags);

		STDMETHODIMP GetAllParameters(DP8SIM_PARAMETERS * const pdp8spSend, DP8SIM_PARAMETERS * const pdp8spReceive, const DWORD dwFlags);

		STDMETHODIMP SetAllParameters(const DP8SIM_PARAMETERS * const pdp8spSend, const DP8SIM_PARAMETERS * const pdp8spReceive, const DWORD dwFlags);

		STDMETHODIMP GetAllStatistics(DP8SIM_STATISTICS * const pdp8ssSend, DP8SIM_STATISTICS * const pdp8ssReceive, const DWORD dwFlags);

		STDMETHODIMP ClearAllStatistics(const DWORD dwFlags);



		HRESULT InitializeObject(void);

		void UninitializeObject(void);



		CBilink					m_blList;	// list of all the DP8SimControl instances in existence


	private:
		BYTE					m_Sig[4];					// debugging signature ('DP8S')
		LONG					m_lRefCount;				// reference count for this object
		DWORD					m_dwFlags;					// flags for this object
		DNCRITICAL_SECTION		m_csLock;					// lock preventing simultaneous usage of globals
		CDP8SimIPC				m_DP8SimIPC;				// object that handles interprocess communication


		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimControl))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x53385044)	// 0x53 0x38 0x50 0x44 = 'S8PD' = 'DP8S' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simclassfac.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1998-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dp8simclassfac.cpp
 *
 *  Content:	a generic class factory.
 *
 *
 *	This is a generic C++ class factory.  All you need to do is implement
 *	a function called DoCreateInstance that will create an instance of
 *	your object.
 *
 *	GP_ stands for "General Purpose"
 *
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Copied from DPNHUPNP.
 *
 ***************************************************************************/


#include "dp8simi.h"



#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// class factory class definition
//
typedef class GPClassFactory:public IClassFactory
{
	public:
		GPClassFactory(const CLSID * pclsid)	{ m_dwRefCnt = 0; memcpy(&m_clsid, pclsid, sizeof(CLSID)); };
		~GPClassFactory(void)				{};


		STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
		STDMETHODIMP_(ULONG) AddRef(void);
		STDMETHODIMP_(ULONG) Release(void);
		STDMETHODIMP CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);
		STDMETHODIMP LockServer(BOOL fLock);


	private:
		DWORD		m_dwRefCnt;
		CLSID		m_clsid;
} GPCLASSFACTORY, *LPGPCLASSFACTORY;


//
// function prototype for CoLockObjectExternal()
//
typedef	HRESULT (WINAPI * PCOLOCKOBJECTEXTERNAL)(LPUNKNOWN, BOOL, BOOL );

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// count of outstanding COM interfaces, defined in dpnathlpdllmain.cpp
//
extern volatile LONG	g_lOutstandingInterfaceCount;



//**********************************************************************
// Function prototypes
//**********************************************************************


//**********************************************************************
// Function definitions
//**********************************************************************




/*
 * GPClassFactory::QueryInterface
 */
STDMETHODIMP GPClassFactory::QueryInterface(
											REFIID riid,
											LPVOID *ppvObj )
{
	HRESULT hr;

    *ppvObj = NULL;


    if( IsEqualIID(riid, IID_IClassFactory) ||
                    IsEqualIID(riid, IID_IUnknown))
    {
        this->m_dwRefCnt++;
        *ppvObj = this;
		hr = S_OK;
    }
    else
    {
		hr = E_NOINTERFACE;
    }


	return hr;

} /* GPClassFactory::QueryInterface */


/*
 * GPClassFactory::AddRef
 */
STDMETHODIMP_(ULONG) GPClassFactory::AddRef( void )
{
    this->m_dwRefCnt++;
    return this->m_dwRefCnt;
} /* GPClassFactory::AddRef */



/*
 * GPClassFactory::Release
 */
STDMETHODIMP_(ULONG) GPClassFactory::Release( void )
{
    this->m_dwRefCnt--;

    if( this->m_dwRefCnt != 0 )
    {
        return this->m_dwRefCnt;
    }

    delete this;
    return 0;

} /* GPClassFactory::Release */




/*
 * GPClassFactory::CreateInstance
 *
 * Creates an instance of the object
 */
STDMETHODIMP GPClassFactory::CreateInstance(
											LPUNKNOWN pUnkOuter,
											REFIID riid,
    										LPVOID *ppvObj
											)
{
    HRESULT					hr = S_OK;

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	*ppvObj = NULL;


    /*
     * create the object by calling DoCreateInstance.  This function
     *	must be implemented specifically for your COM object
     */
	hr = DoCreateInstance(this, pUnkOuter, this->m_clsid, riid, ppvObj);
	if (FAILED(hr))
	{
		*ppvObj = NULL;
		return hr;
	}

    return S_OK;

} /* GPClassFactory::CreateInstance */



/*
 * GPClassFactory::LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP GPClassFactory::LockServer(
                BOOL fLock
				)
{
    HRESULT		hr;
    HINSTANCE	hdll;


    /*
     * call CoLockObjectExternal
     */
    hr = E_UNEXPECTED;
    hdll = LoadLibraryA( "OLE32.DLL" );
    if( hdll != NULL )
    {
        PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;


		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
        if( lpCoLockObjectExternal != NULL )
        {
            hr = lpCoLockObjectExternal( (LPUNKNOWN) this, fLock, TRUE );
        }
        else
        {
        }
    }
    else
    {
    }

	return hr;

} /* GPClassFactory::LockServer */



/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
EXP STDAPI  DllGetClassObject(
                REFCLSID rclsid,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPGPCLASSFACTORY	pcf;
    HRESULT		hr;

    *ppvObj = NULL;

    /*
     * is this our class id?
     */
//	you must implement GetClassID() for your specific COM object
	if (!IsClassImplemented(rclsid))
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    /*
     * only allow IUnknown and IClassFactory
     */
    if( !IsEqualIID( riid, IID_IUnknown ) &&
	    !IsEqualIID( riid, IID_IClassFactory ) )
    {
        return E_NOINTERFACE;
    }

    /*
     * create a class factory object
     */
    pcf = new GPClassFactory(&rclsid);
    if( NULL == pcf)
    {
        return E_OUTOFMEMORY;
    }

    hr = pcf->QueryInterface( riid, ppvObj );
    if( FAILED( hr ) )
    {
        delete pcf;
        *ppvObj = NULL;
    }
    else
    {
    }

    return hr;

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
EXP STDAPI DllCanUnloadNow( void )
{
    HRESULT	hr = S_FALSE;

	
	if ( g_lOutstandingInterfaceCount == 0 )
	{
		hr = S_OK;
	}

    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simendpoint.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simendpoint.h
 *
 *  Content:	Header for endpoint object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  05/08/01  VanceO    Created.
 *
 ***************************************************************************/



//=============================================================================
// Object flags
//=============================================================================
#define DP8SIMENDPOINTOBJ_DISCONNECTING		0x01	// the endpoint is disconnecting





//=============================================================================
// Endpoint object class
//=============================================================================
class CDP8SimEndpoint
{
	public:

		CDP8SimEndpoint(void)	{};
		~CDP8SimEndpoint(void)	{};


		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimEndpoint))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x454d4953)	// 0x45 0x4d 0x49 0x53 = 'EMIS' = 'SIME' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};




		BOOL FPMAlloc(void * const pvContext)
		{
			this->m_Sig[0] = 'S';
			this->m_Sig[1] = 'I';
			this->m_Sig[2] = 'M';
			this->m_Sig[3] = 'e';	// start with lower case so we can tell when it's in the pool or not

			this->m_lRefCount			= 0;

			if (! DNInitializeCriticalSection(&this->m_csLock))
			{
				return FALSE;
			}

			//
			// Don't allow critical section re-entry.
			//
			DebugSetCriticalSectionRecursionCount(&this->m_csLock, 0);

			this->m_dwFlags				= 0;
			this->m_hRealSPEndpoint		= NULL;
			this->m_pvUserContext		= NULL;

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::FPMInitialize"
		BOOL FPMInitialize(void * const pvContext)
		{
			this->m_lRefCount++;	// somebody is getting a pointer to this object
			DNASSERT(this->m_lRefCount == 1);


			//
			// Reset the flags.
			//
			this->m_dwFlags = 0;


			//
			// Save the real SP's endpoint handle.
			//
			this->m_hRealSPEndpoint = (HANDLE) pvContext;


			//
			// Change the signature before handing it out.
			//
			this->m_Sig[3]	= 'E';


			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::FPMRelease"
		void FPMRelease(void * const pvContext)
		{
			DNASSERT(this->m_lRefCount == 0);


			//
			// Change the signature before putting the object back in the pool.
			//
			this->m_Sig[3]	= 'e';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::FPMDealloc"
		void FPMDealloc(void * const pvContext)
		{
			DNASSERT(this->m_lRefCount == 0);

			DNDeleteCriticalSection(&this->m_csLock);
		}




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::AddRef"
		inline void AddRef(void)
		{
			LONG	lResult;


			lResult = InterlockedIncrement(&this->m_lRefCount);
			DNASSERT(lResult > 0);
			DPFX(DPFPREP, 9, "Endpoint 0x%p refcount = %u.", this, lResult);
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::Release"
		inline void Release(void)
		{
			LONG	lResult;


			lResult = InterlockedDecrement(&this->m_lRefCount);
			DNASSERT(lResult >= 0);
			if (lResult == 0)
			{
				DPFX(DPFPREP, 9, "Endpoint 0x%p refcount = 0, returning to pool.", this);

				//
				// Time to return this object to the pool.
				//
				g_pFPOOLEndpoint->Release(this);
			}
			else
			{
				DPFX(DPFPREP, 9, "Endpoint 0x%p refcount = %u.", this, lResult);
			}
		};


		inline void Lock(void)		{ DNEnterCriticalSection(&this->m_csLock); };
		inline void Unlock(void)	{ DNLeaveCriticalSection(&this->m_csLock); };


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::IsDisconnecting"
		inline BOOL IsDisconnecting(void)
		{
			AssertCriticalSectionIsTakenByThisThread(&this->m_csLock, TRUE);
			return ((this->m_dwFlags & DP8SIMENDPOINTOBJ_DISCONNECTING) ? TRUE: FALSE);
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::NoteDisconnecting"
		inline void NoteDisconnecting(void)
		{
			AssertCriticalSectionIsTakenByThisThread(&this->m_csLock, TRUE);
#pragma TODO(vanceo, "Have separate upper/lower layer disconnect flags")
			//DNASSERT(! (this->m_dwFlags & DP8SIMENDPOINTOBJ_DISCONNECTING));
			this->m_dwFlags |= DP8SIMENDPOINTOBJ_DISCONNECTING;
		};


		inline HANDLE GetRealSPEndpoint(void)				{ return this->m_hRealSPEndpoint; };
		inline PVOID GetUserContext(void)					{ return this->m_pvUserContext; };

		inline void SetUserContext(PVOID pvUserContext)		{ this->m_pvUserContext = pvUserContext; };

	
	private:
		BYTE				m_Sig[4];				// debugging signature ('SIME')
		LONG				m_lRefCount;			// number of references for this object
		DNCRITICAL_SECTION	m_csLock;				// lock protecting the endpoint data
		DWORD				m_dwFlags;				// flags for this endpoint
		HANDLE				m_hRealSPEndpoint;		// real service provider's endpoint handle
		PVOID				m_pvUserContext;		// upper layer user context for endpoint
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simcmd.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simcmd.h
 *
 *  Content:	Header for command object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/




//=============================================================================
// Defines
//=============================================================================
#define CMDTYPE_SENDDATA_IMMEDIATE	1	// command represents a send transmitted right away
#define CMDTYPE_SENDDATA_DELAYED	2	// command represents a send that was artificially delayed
#define CMDTYPE_CONNECT				3	// command represents a connect
#define CMDTYPE_DISCONNECT			4	// command represents a disconnect
#define CMDTYPE_LISTEN				5	// command represents a listen
#define CMDTYPE_ENUMQUERY			6	// command represents an enum query
#define CMDTYPE_ENUMRESPOND			7	// command represents an enum respond




//=============================================================================
// Structures
//=============================================================================
typedef struct _DP8SIMCOMMAND_FPMCONTEXT
{
	DWORD	dwType;			// type of command
	PVOID	pvUserContext;	// user context for command
} DP8SIMCOMMAND_FPMCONTEXT, * PDP8SIMCOMMAND_FPMCONTEXT;






//=============================================================================
// Send object class
//=============================================================================
class CDP8SimCommand
{
	public:

		CDP8SimCommand(void)	{};
		~CDP8SimCommand(void)	{};


		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimCommand))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x434d4953)	// 0x43 0x4d 0x49 0x53 = 'CMIS' = 'SIMC' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};




		BOOL FPMAlloc(void * const pvContext)
		{
			this->m_Sig[0] = 'S';
			this->m_Sig[1] = 'I';
			this->m_Sig[2] = 'M';
			this->m_Sig[3] = 'c';	// start with lower case so we can tell when it's in the pool or not

			this->m_lRefCount				= 0;
			this->m_dwType					= 0;
			this->m_pvUserContext			= NULL;
			this->m_hCommand				= NULL;
			this->m_dwCommandDescriptor		= 0;
			this->m_pDP8SimEndpointListen	= NULL;

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::FPMInitialize"
		BOOL FPMInitialize(void * const pvContext)
		{
			DP8SIMCOMMAND_FPMCONTEXT *	pContext = (DP8SIMCOMMAND_FPMCONTEXT*) pvContext;


			this->m_lRefCount++;	// somebody is getting a pointer to this object
			DNASSERT(this->m_lRefCount == 1);


			this->m_dwType			= pContext->dwType;
			this->m_pvUserContext	= pContext->pvUserContext;

			
			//
			// Change the signature before handing it out.
			//
			this->m_Sig[3]	= 'C';

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::FPMRelease"
		void FPMRelease(void * const pvContext)
		{
			DNASSERT(this->m_lRefCount == 0);
			DNASSERT(this->m_pDP8SimEndpointListen == NULL);


			//
			// Change the signature before putting the object back in the pool.
			//
			this->m_Sig[3]	= 'c';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::FPMDealloc"
		void FPMDealloc(void * const pvContext)
		{
			DNASSERT(this->m_lRefCount == 0);
			DNASSERT(this->m_pDP8SimEndpointListen == NULL);
		}




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::AddRef"
		inline void AddRef(void)
		{
			LONG	lResult;


			lResult = InterlockedIncrement(&this->m_lRefCount);
			DNASSERT(lResult > 0);
			DPFX(DPFPREP, 9, "Command 0x%p refcount = %u.", this, lResult);
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::Release"
		inline void Release(void)
		{
			LONG	lResult;


			lResult = InterlockedDecrement(&this->m_lRefCount);
			DNASSERT(lResult >= 0);
			if (lResult == 0)
			{
				DPFX(DPFPREP, 9, "Command 0x%p refcount = 0, returning to pool.", this);

				//
				// Time to return this object to the pool.
				//
				g_pFPOOLCommand->Release(this);
			}
			else
			{
				DPFX(DPFPREP, 9, "Command 0x%p refcount = %u.", this, lResult);
			}
		};


		inline DWORD GetType(void)							{ return this->m_dwType; };
		inline PVOID GetUserContext(void)					{ return this->m_pvUserContext; };
		inline HANDLE GetRealSPCommand(void)				{ return this->m_hCommand; };
		inline DWORD GetRealSPCommandDescriptor(void)		{ return this->m_dwCommandDescriptor; };

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::GetListenEndpoint"
		inline CDP8SimEndpoint * GetListenEndpoint(void)
		{
			DNASSERT(this->m_dwType == CMDTYPE_LISTEN);
			return this->m_pDP8SimEndpointListen;
		};



		inline void SetRealSPCommand(HANDLE hCommand, DWORD dwCommandDescriptor)
		{
			this->m_hCommand				= hCommand;
			this->m_dwCommandDescriptor		= dwCommandDescriptor;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::SetListenEndpoint"
		inline void SetListenEndpoint(CDP8SimEndpoint * const pDP8SimEndpoint)
		{
			DNASSERT(this->m_dwType == CMDTYPE_LISTEN);
			DNASSERT((this->m_pDP8SimEndpointListen == NULL) || (pDP8SimEndpoint == NULL));

			//
			// Note this only sets the pointer, it is the caller's
			// responsibility to add or remove the reference as necessary.
			//
			this->m_pDP8SimEndpointListen = pDP8SimEndpoint;
		};


	
	private:
		BYTE				m_Sig[4];					// debugging signature ('SIMC')
		LONG				m_lRefCount;				// number of references for this object
		DWORD				m_dwType;					// type of command
		PVOID				m_pvUserContext;			// user's context for command
		HANDLE				m_hCommand;					// real SP command handle
		DWORD				m_dwCommandDescriptor;		// real SP descriptor for command
		CDP8SimEndpoint *	m_pDP8SimEndpointListen;	// pointer to listen endpoint, if this is a listen command
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simi.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simi.h
 *
 *  Content:	DP8SIM master internal header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/

#ifndef __DP8SIMI_H__
#define __DP8SIMI_H__


// 
// Public includes
//
#include <windows.h>
#include <ole2.h>
#include <mmsystem.h>	// NT BUILD requires this for timeGetTime
#include <stdio.h>		// for swprintf


// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"
#include "dpsp8.h"


// 
// DirectPlay private includes
//
#include "dndbg.h"
#include "osind.h"
#include "classbilink.h"
#include "creg.h"
#include "createin.h"
#include "comutil.h"
#include "dneterrors.h"
#include "strutils.h"
#include "lockedccfpm.h"


// 
// DP8Sim includes
//
#include "dp8sim.h"


// 
// DP8SimSP private includes
//

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_TOOLS

#include "dp8simlocals.h"
#include "dp8simpools.h"
#include "dp8simipc.h"
#include "spcallbackobj.h"
#include "spwrapper.h"
#include "dp8simendpoint.h"
#include "dp8simcmd.h"
#include "dp8simworkerthread.h"
#include "dp8simsend.h"
#include "dp8simreceive.h"
#include "controlobj.h"
#include "dp8simjob.h"
#include "resource.h"




#endif // __DP8SIMI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simipc.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		spcallbackobj.cpp
 *
 *  Content:	Interprocess communication object object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/25/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"




//=============================================================================
// Defines
//=============================================================================
#define REGKEY_DP8SIM							L"Software\\Microsoft\\DirectPlay\\DP8Sim"
#define REGKEY_VALUE_DEFAULTSENDPARAMETERS		L"DefaultSendParameters"
#define REGKEY_VALUE_DEFAULTRECEIVEPARAMETERS	L"DefaultReceiveParameters"






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::CDP8SimIPC"
//=============================================================================
// CDP8SimIPC constructor
//-----------------------------------------------------------------------------
//
// Description: Initializes the new CDP8SimIPC object.
//
// Arguments: None.
//
// Returns: None (the object).
//=============================================================================
CDP8SimIPC::CDP8SimIPC(void)
{
	this->m_Sig[0]	= 'S';
	this->m_Sig[1]	= 'I';
	this->m_Sig[2]	= 'M';
	this->m_Sig[3]	= 'I';

	this->m_hMutex			= NULL;
	this->m_hFileMapping	= NULL;
	this->m_pdp8ssm			= NULL;
} // CDP8SimIPC::CDP8SimIPC






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::~CDP8SimIPC"
//=============================================================================
// CDP8SimIPC destructor
//-----------------------------------------------------------------------------
//
// Description: Frees the CDP8SimIPC object.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
CDP8SimIPC::~CDP8SimIPC(void)
{
	DNASSERT(this->m_hMutex == NULL);
	DNASSERT(this->m_hFileMapping == NULL);
	DNASSERT(this->m_pdp8ssm == NULL);


	//
	// For grins, change the signature before deleting the object.
	//
	this->m_Sig[3]	= 'c';
} // CDP8SimIPC::~CDP8SimIPC





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::Initialize"
//=============================================================================
// CDP8SimIPC::Initialize
//-----------------------------------------------------------------------------
//
// Description: Establishes the IPC connection.
//
// Arguments: None.
//
// Returns: HRESULT
//=============================================================================
HRESULT CDP8SimIPC::Initialize(void)
{
	HRESULT				hr = DP8SIM_OK;
	DP8SIM_PARAMETERS	dp8spSend;
	DP8SIM_PARAMETERS	dp8spReceive;
	BOOL				fLockedSharedMemory = FALSE;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	DNASSERT(this->m_hMutex == NULL);
	DNASSERT(this->m_hFileMapping == NULL);


	//
	// This defaults to having every option turned off.
	//

	ZeroMemory(&dp8spSend, sizeof(dp8spSend));
	dp8spSend.dwSize = sizeof(dp8spSend);
	//dp8spSend.dwLatencyMS			= 0;
	//dp8spSend.dwPacketLossPercent	= 0;


	ZeroMemory(&dp8spReceive, sizeof(dp8spReceive));
	dp8spReceive.dwSize = sizeof(dp8spReceive);
	//dp8spReceive.dwLatencyMS			= 0;
	//dp8spReceive.dwPacketLossPercent	= 0;


	//
	// Try overriding with registry settings.
	//
	this->LoadDefaultParameters(&dp8spSend, &dp8spReceive);


	//
	// Create/open the IPC mutex.
	//
	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		this->m_hMutex = CreateMutex(DNGetNullDacl(), FALSE, "Global\\" DP8SIM_IPC_MUTEXNAME);
	}
	else
	{
		this->m_hMutex = CreateMutex(DNGetNullDacl(), FALSE, DP8SIM_IPC_MUTEXNAME);
	}
	if (this->m_hMutex == NULL)
	{
		hr = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create shared memory mutex!");
		goto Failure;
	}


	//
	// Create/open the IPC memory mapped file.
	//
	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		this->m_hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE,
												DNGetNullDacl(),
												PAGE_READWRITE,
												0,
												sizeof(DP8SIM_SHAREDMEMORY),
												"Global\\" DP8SIM_IPC_FILEMAPPINGNAME);
	}
	else
	{
		this->m_hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE,
												DNGetNullDacl(),
												PAGE_READWRITE,
												0,
												sizeof(DP8SIM_SHAREDMEMORY),
												DP8SIM_IPC_FILEMAPPINGNAME);
	}
	if (this->m_hFileMapping == NULL)
	{
		hr = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create shared memory mapped file!");
		goto Failure;
	}


	//
	// Create a view of the memory mapped file.
	//
	this->m_pdp8ssm = (DP8SIM_SHAREDMEMORY*) MapViewOfFile(this->m_hFileMapping,
															(FILE_MAP_READ | FILE_MAP_WRITE),
															0,
															0,
															0);
	if (this->m_pdp8ssm == NULL)
	{
		hr = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't map view of shared memory!");
		goto Failure;
	}



	this->LockSharedMemory();
	fLockedSharedMemory = TRUE;

	//
	// Determine whether we need to initialize the shared memory or not.
	//
	if (this->m_pdp8ssm->dwVersion == 0)
	{
		this->m_pdp8ssm->dwVersion = DP8SIM_IPC_VERSION;
		CopyMemory(&(this->m_pdp8ssm->dp8spSend), &dp8spSend, sizeof(dp8spSend));
		CopyMemory(&(this->m_pdp8ssm->dp8spReceive), &dp8spReceive, sizeof(dp8spReceive));

		//ZeroMemory(&(this->m_pdp8ssm->dp8ssSend), sizeof(this->m_pdp8ssm->dp8ssSend));
		this->m_pdp8ssm->dp8ssSend.dwSize = sizeof(this->m_pdp8ssm->dp8ssSend);
		//ZeroMemory(&(this->m_pdp8ssm->dp8ssReceive), sizeof(this->m_pdp8ssm->dp8ssReceive));
		this->m_pdp8ssm->dp8ssReceive.dwSize = sizeof(this->m_pdp8ssm->dp8ssReceive);
	}
	else
	{
		//
		// It's already initialized.  Make sure we know how to play with the
		// format given.
		//
		if (this->m_pdp8ssm->dwVersion != DP8SIM_IPC_VERSION)
		{
			DPFX(DPFPREP, 0, "Shared memory was initialized by a different version!");
			hr = DP8SIMERR_MISMATCHEDVERSION;
			goto Failure;
		}


		DNASSERT(this->m_pdp8ssm->dp8spSend.dwSize = sizeof(DP8SIM_PARAMETERS));
		DNASSERT(this->m_pdp8ssm->dp8spReceive.dwSize = sizeof(DP8SIM_PARAMETERS));
		DNASSERT(this->m_pdp8ssm->dp8ssSend.dwSize = sizeof(DP8SIM_STATISTICS));
		DNASSERT(this->m_pdp8ssm->dp8ssReceive.dwSize = sizeof(DP8SIM_STATISTICS));
	}

	this->UnlockSharedMemory();
	fLockedSharedMemory = FALSE;
	
	
Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fLockedSharedMemory)
	{
		this->UnlockSharedMemory();
		fLockedSharedMemory = FALSE;
	}

	if (this->m_pdp8ssm != NULL)
	{
		UnmapViewOfFile(this->m_pdp8ssm);
		this->m_pdp8ssm = NULL;
	}

	if (this->m_hFileMapping != NULL)
	{
		CloseHandle(this->m_hFileMapping);
		this->m_hFileMapping = NULL;
	}

	if (this->m_hMutex != NULL)
	{
		CloseHandle(this->m_hMutex);
		this->m_hMutex = NULL;
	}

	goto Exit;
} // CDP8SimIPC::Initialize






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::Close"
//=============================================================================
// CDP8SimIPC::Close
//-----------------------------------------------------------------------------
//
// Description: Closes the IPC connection.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::Close(void)
{
	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	if (this->m_pdp8ssm != NULL)
	{
		//
		// Try overriding with registry settings.
		//
		this->SaveDefaultParameters(&(this->m_pdp8ssm->dp8spSend),
									&(this->m_pdp8ssm->dp8spReceive));


		UnmapViewOfFile(this->m_pdp8ssm);
		this->m_pdp8ssm = NULL;
	}

	if (this->m_hFileMapping != NULL)
	{
		CloseHandle(this->m_hFileMapping);
		this->m_hFileMapping = NULL;
	}

	if (this->m_hMutex != NULL)
	{
		CloseHandle(this->m_hMutex);
		this->m_hMutex = NULL;
	}


	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CDP8SimIPC::Close






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::GetAllParameters"
//=============================================================================
// CDP8SimIPC::GetAllParameters
//-----------------------------------------------------------------------------
//
// Description: Retrieves the current send and receive settings.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8spSend		- Place to store send parameters
//											retrieved.
//	DP8SIM_PARAMETERS * pdp8spReceive	- Place to store receive parameters
//											retrieved.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::GetAllParameters(DP8SIM_PARAMETERS * const pdp8spSend,
								DP8SIM_PARAMETERS * const pdp8spReceive)
{
	DNASSERT(pdp8spSend != NULL);
	DNASSERT(pdp8spSend->dwSize == sizeof(DP8SIM_PARAMETERS));
	DNASSERT(pdp8spReceive != NULL);
	DNASSERT(pdp8spReceive->dwSize == sizeof(DP8SIM_PARAMETERS));
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8spSend.dwSize == sizeof(DP8SIM_PARAMETERS));
	CopyMemory(pdp8spSend, &(this->m_pdp8ssm->dp8spSend), sizeof(DP8SIM_PARAMETERS));

	DNASSERT(this->m_pdp8ssm->dp8spReceive.dwSize == sizeof(DP8SIM_PARAMETERS));
	CopyMemory(pdp8spReceive, &(this->m_pdp8ssm->dp8spReceive), sizeof(DP8SIM_PARAMETERS));

	this->UnlockSharedMemory();
} // CDP8SimIPC::GetAllParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::GetAllSendParameters"
//=============================================================================
// CDP8SimIPC::GetAllSendParameters
//-----------------------------------------------------------------------------
//
// Description: Retrieves the current send settings.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8sp	- Place to store parameters retrieved.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::GetAllSendParameters(DP8SIM_PARAMETERS * const pdp8sp)
{
	DNASSERT(pdp8sp != NULL);
	DNASSERT(pdp8sp->dwSize == sizeof(DP8SIM_PARAMETERS));
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8spSend.dwSize == sizeof(DP8SIM_PARAMETERS));
	CopyMemory(pdp8sp, &(this->m_pdp8ssm->dp8spSend), sizeof(DP8SIM_PARAMETERS));

	this->UnlockSharedMemory();
} // CDP8SimIPC::GetAllSendParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::GetAllReceiveParameters"
//=============================================================================
// CDP8SimIPC::GetAllReceiveParameters
//-----------------------------------------------------------------------------
//
// Description: Retrieves the current receive settings.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8sp	- Place to store parameters retrieved.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::GetAllReceiveParameters(DP8SIM_PARAMETERS * const pdp8sp)
{
	DNASSERT(pdp8sp != NULL);
	DNASSERT(pdp8sp->dwSize == sizeof(DP8SIM_PARAMETERS));
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8spReceive.dwSize == sizeof(DP8SIM_PARAMETERS));
	CopyMemory(pdp8sp, &(this->m_pdp8ssm->dp8spReceive), sizeof(DP8SIM_PARAMETERS));

	this->UnlockSharedMemory();
} // CDP8SimIPC::GetAllReceiveParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::SetAllParameters"
//=============================================================================
// CDP8SimIPC::SetAllParameters
//-----------------------------------------------------------------------------
//
// Description: Stores the send and receive settings.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8spSend		- New send parameters.
//	DP8SIM_PARAMETERS * pdp8spReceive	- New receive parameters.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::SetAllParameters(const DP8SIM_PARAMETERS * const pdp8spSend,
								const DP8SIM_PARAMETERS * const pdp8spReceive)
{
	DNASSERT(pdp8spSend != NULL);
	DNASSERT(pdp8spSend->dwSize == sizeof(DP8SIM_PARAMETERS));
	DNASSERT(pdp8spReceive != NULL);
	DNASSERT(pdp8spReceive->dwSize == sizeof(DP8SIM_PARAMETERS));
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8spSend.dwSize == sizeof(DP8SIM_PARAMETERS));
	CopyMemory(&(this->m_pdp8ssm->dp8spSend), pdp8spSend, sizeof(DP8SIM_PARAMETERS));

	DNASSERT(this->m_pdp8ssm->dp8spReceive.dwSize == sizeof(DP8SIM_PARAMETERS));
	CopyMemory(&(this->m_pdp8ssm->dp8spReceive), pdp8spReceive, sizeof(DP8SIM_PARAMETERS));

	this->UnlockSharedMemory();
} // CDP8SimIPC::SetAllParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::GetAllStatistics"
//=============================================================================
// CDP8SimIPC::GetAllStatistics
//-----------------------------------------------------------------------------
//
// Description: Retrieves the current send and receive statistics.
//
// Arguments:
//	DP8SIM_STATISTICS * pdp8ssSend		- Place to store send statistics
//											retrieved.
//	DP8SIM_STATISTICS * pdp8ssReceive	- Place to store receive statistics
//											retrieved.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::GetAllStatistics(DP8SIM_STATISTICS * const pdp8ssSend,
								DP8SIM_STATISTICS * const pdp8ssReceive)
{
	DNASSERT(pdp8ssSend != NULL);
	DNASSERT(pdp8ssSend->dwSize == sizeof(DP8SIM_STATISTICS));
	DNASSERT(pdp8ssReceive != NULL);
	DNASSERT(pdp8ssReceive->dwSize == sizeof(DP8SIM_STATISTICS));
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8ssSend.dwSize == sizeof(DP8SIM_STATISTICS));
	CopyMemory(pdp8ssSend, &(this->m_pdp8ssm->dp8ssSend), sizeof(DP8SIM_STATISTICS));

	DNASSERT(this->m_pdp8ssm->dp8ssReceive.dwSize == sizeof(DP8SIM_STATISTICS));
	CopyMemory(pdp8ssReceive, &(this->m_pdp8ssm->dp8ssReceive), sizeof(DP8SIM_STATISTICS));

	this->UnlockSharedMemory();
} // CDP8SimIPC::GetAllStatistics






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::ClearAllStatistics"
//=============================================================================
// CDP8SimIPC::ClearAllStatistics
//-----------------------------------------------------------------------------
//
// Description: Clears the current send and receive statistics.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::ClearAllStatistics(void)
{
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8ssSend.dwSize == sizeof(DP8SIM_STATISTICS));
	ZeroMemory(&(this->m_pdp8ssm->dp8ssSend), sizeof(DP8SIM_STATISTICS));
	this->m_pdp8ssm->dp8ssSend.dwSize = sizeof(DP8SIM_STATISTICS);

	DNASSERT(this->m_pdp8ssm->dp8ssReceive.dwSize == sizeof(DP8SIM_STATISTICS));
	ZeroMemory(&(this->m_pdp8ssm->dp8ssReceive), sizeof(DP8SIM_STATISTICS));
	this->m_pdp8ssm->dp8ssReceive.dwSize = sizeof(DP8SIM_STATISTICS);

	this->UnlockSharedMemory();
} // CDP8SimIPC::GetAllStatistics






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::IncrementStatSendTransmitted"
//=============================================================================
// CDP8SimIPC::IncrementStatSendTransmitted
//-----------------------------------------------------------------------------
//
// Description: Increments the sends transmitted counter.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::IncrementStatSendTransmitted(void)
{
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8ssSend.dwSize == sizeof(DP8SIM_STATISTICS));
	this->m_pdp8ssm->dp8ssSend.dwTransmitted++;

	this->UnlockSharedMemory();
} // CDP8SimIPC::IncrementStatSendTransmitted






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::IncrementStatSendDropped"
//=============================================================================
// CDP8SimIPC::IncrementStatSendDropped
//-----------------------------------------------------------------------------
//
// Description: Increments the sends dropped counter.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::IncrementStatSendDropped(void)
{
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8ssSend.dwSize == sizeof(DP8SIM_STATISTICS));
	this->m_pdp8ssm->dp8ssSend.dwDropped++;

	this->UnlockSharedMemory();
} // CDP8SimIPC::IncrementStatSendDropped






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::IncrementStatReceiveTransmitted"
//=============================================================================
// CDP8SimIPC::IncrementStatReceiveTransmitted
//-----------------------------------------------------------------------------
//
// Description: Increments the receives indicated counter.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::IncrementStatReceiveTransmitted(void)
{
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8ssReceive.dwSize == sizeof(DP8SIM_STATISTICS));
	this->m_pdp8ssm->dp8ssReceive.dwTransmitted++;

	this->UnlockSharedMemory();
} // CDP8SimIPC::IncrementStatReceiveTransmitted






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::IncrementStatReceiveDropped"
//=============================================================================
// CDP8SimIPC::IncrementStatReceiveDropped
//-----------------------------------------------------------------------------
//
// Description: Increments the receives dropped counter.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::IncrementStatReceiveDropped(void)
{
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8ssReceive.dwSize == sizeof(DP8SIM_STATISTICS));
	this->m_pdp8ssm->dp8ssReceive.dwDropped++;

	this->UnlockSharedMemory();
} // CDP8SimIPC::IncrementStatReceiveDropped






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::LoadDefaultParameters"
//=============================================================================
// CDP8SimIPC::LoadDefaultParameters
//-----------------------------------------------------------------------------
//
// Description: Loads the default send and receive parameters from the registry
//				if possible.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8spSend		- Place to store default send
//											parameters.
//	DP8SIM_PARAMETERS * pdp8spReceive	- Place to store default receive
//											parameters.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::LoadDefaultParameters(DP8SIM_PARAMETERS * const pdp8spSend,
										DP8SIM_PARAMETERS * const pdp8spReceive)
{
	CRegistry			RegObject;
	DP8SIM_PARAMETERS	dp8spTemp;
	DWORD				dwSize;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p)",
		this, pdp8spSend, pdp8spReceive);


	DNASSERT(pdp8spSend != NULL);
	DNASSERT(pdp8spSend->dwSize == sizeof(DP8SIM_PARAMETERS));


	DNASSERT(pdp8spReceive != NULL);
	DNASSERT(pdp8spReceive->dwSize == sizeof(DP8SIM_PARAMETERS));


	if (RegObject.Open(HKEY_CURRENT_USER, REGKEY_DP8SIM, TRUE, FALSE))
	{
		//
		// Try to read the default send parameters
		//
		dwSize = sizeof(dp8spTemp);
		if (RegObject.ReadBlob(REGKEY_VALUE_DEFAULTSENDPARAMETERS, (BYTE*) (&dp8spTemp), &dwSize))
		{
			//
			// Successfully read the parameters.  Make sure they match the
			// expected values.
			//
			if ((dwSize == sizeof(dp8spTemp)) &&
				(dp8spTemp.dwSize == sizeof(dp8spTemp)))
			{
				DPFX(DPFPREP, 2, "Successfully read default send parameters from registry.");
				memcpy(pdp8spSend, &dp8spTemp, sizeof(dp8spTemp));
			}
			else
			{
				//
				// Default send parameters are unusable, leave the values set
				// as they are.
				//
				DPFX(DPFPREP, 0, "Default send parameters stored in registry are invalid!  Ignoring.");
			}
		}
		else
		{
			//
			// Couldn't read the default send parameters, leave the values set
			// as they are.
			//
			DPFX(DPFPREP, 2, "Couldn't read default send parameters from registry, ignoring.");
		}


		//
		// Try to read the default receive parameters
		//
		dwSize = sizeof(dp8spTemp);
		if (RegObject.ReadBlob(REGKEY_VALUE_DEFAULTRECEIVEPARAMETERS, (BYTE*) (&dp8spTemp), &dwSize))
		{
			//
			// Successfully read the parameters.  Make sure they match the
			// expected values.
			//
			if ((dwSize == sizeof(dp8spTemp)) &&
				(dp8spTemp.dwSize == sizeof(dp8spTemp)))
			{
				DPFX(DPFPREP, 2, "Successfully read default receive parameters from registry.");
				memcpy(pdp8spReceive, &dp8spTemp, sizeof(dp8spTemp));
			}
			else
			{
				//
				// Default receive parameters are unusable, leave the values set
				// as they are.
				//
				DPFX(DPFPREP, 0, "Default receive parameters stored in registry are invalid!  Ignoring.");
			}
		}
		else
		{
			//
			// Couldn't read the default send parameters, leave the values set
			// as they are.
			//
			DPFX(DPFPREP, 2, "Couldn't read default send parameters from registry, ignoring.");
		}
	}
	else
	{
		//
		// Couldn't open the registry key, leave the values set as they are.
		//
		DPFX(DPFPREP, 2, "Couldn't open DP8Sim registry key, ignoring.");
	}

	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CDP8SimIPC::LoadDefaultParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::SaveDefaultParameters"
//=============================================================================
// CDP8SimIPC::SaveDefaultParameters
//-----------------------------------------------------------------------------
//
// Description: Writes the given send and receive parameters as the default
//				values in the registry.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8spSend		- New default send parameters.
//	DP8SIM_PARAMETERS * pdp8spReceive	- New default receive parameters.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::SaveDefaultParameters(const DP8SIM_PARAMETERS * const pdp8spSend,
										const DP8SIM_PARAMETERS * const pdp8spReceive)
{
	CRegistry	RegObject;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p)",
		this, pdp8spSend, pdp8spReceive);


	DNASSERT(pdp8spSend != NULL);
	DNASSERT(pdp8spSend->dwSize == sizeof(DP8SIM_PARAMETERS));


	DNASSERT(pdp8spReceive != NULL);
	DNASSERT(pdp8spReceive->dwSize == sizeof(DP8SIM_PARAMETERS));


	if (RegObject.Open(HKEY_CURRENT_USER, REGKEY_DP8SIM, FALSE, TRUE))
	{
		//
		// Write the default send and receive parameters, ignoring failure.
		//

		RegObject.WriteBlob(REGKEY_VALUE_DEFAULTSENDPARAMETERS,
							(BYTE*) pdp8spSend,
							sizeof(*pdp8spSend));

		RegObject.WriteBlob(REGKEY_VALUE_DEFAULTRECEIVEPARAMETERS,
							(BYTE*) pdp8spReceive,
							sizeof(*pdp8spReceive));
	}
	else
	{
		DPFX(DPFPREP, 0, "Couldn't open DP8Sim registry key for writing!");
	}

	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CDP8SimIPC::SaveDefaultParameters
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simdllmain.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dp8simdllmain.cpp
 *
 *  Content:	DP8SIM DLL entry points.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"




//=============================================================================
// External globals
//=============================================================================
volatile LONG		g_lOutstandingInterfaceCount = 0;	// number of outstanding interfaces

HINSTANCE			g_hDLLInstance = NULL;				// handle to this DLL instance

DNCRITICAL_SECTION	g_csGlobalsLock;					// lock protecting all of the following globals
CBilink				g_blDP8SimSPObjs;					// bilink of all the DP8SimSP interface objects
CBilink				g_blDP8SimControlObjs;				// bilink of all the DP8SimControl interface objects

DWORD				g_dwHoldRand;						// current random number sequence





//=============================================================================
// Defines
//=============================================================================
#define MAX_RESOURCE_STRING_LENGTH		_MAX_PATH






//=============================================================================
// Local prototypes
//=============================================================================
BOOL InitializeProcessGlobals(void);
void CleanupProcessGlobals(void);
HRESULT LoadAndAllocString(UINT uiResourceID, WCHAR ** pwszString);







#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"
//=============================================================================
// DllMain
//-----------------------------------------------------------------------------
//
// Description: DLL entry point.
//
// Arguments:
//	HINSTANCE hDllInst	- Handle to this DLL module.
//	DWORD dwReason		- Reason for calling this function.
//	LPVOID lpvReserved	- Reserved.
//
// Returns: TRUE if all goes well, FALSE otherwise.
//=============================================================================
BOOL WINAPI DllMain(HINSTANCE hDllInst,
					DWORD dwReason,
					LPVOID lpvReserved)
{
	BOOL	fResult = TRUE;

	
	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
		{
			DPFX(DPFPREP, 2, "====> ENTER: DLLMAIN(%p): Process Attach: %08lx, tid=%08lx",
				DllMain, GetCurrentProcessId(), GetCurrentThreadId());
			

			DNASSERT(g_hDLLInstance == NULL);
			g_hDLLInstance = hDllInst;

			
			//
			// Attempt to initialize the OS abstraction layer.
			//
			if (DNOSIndirectionInit())
			{
				if (SUCCEEDED(COM_Init()))
				{
					//
					// Attempt to initialize process-global items.
					//
					if (! InitializeProcessGlobals())
					{
						DPFX(DPFPREP, 0, "Failed to initialize globals!");
						
						COM_Free();
						DNOSIndirectionDeinit();
						fResult = FALSE;
					}
				}
				else
				{
					DPFX(DPFPREP, 0, "Failed to initialize COM indirection layer!" );
					fResult = FALSE;

					DNOSIndirectionDeinit();
				}
			}
			else
			{
				DPFX(DPFPREP, 0, "Failed to initialize OS indirection layer!");
				fResult = FALSE;
			}
		
			break;
		}

		case DLL_THREAD_ATTACH:
		{
			//
			// Ignore.
			//
			break;
		}

		case DLL_THREAD_DETACH:
		{
			//
			// Ignore.
			//
			break;
		}

		case DLL_PROCESS_DETACH:
		{
			DPFX(DPFPREP, 2, "====> EXIT: DLLMAIN(%p): Process Detach %08lx, tid=%08lx",
				DllMain, GetCurrentProcessId(), GetCurrentThreadId());


			DNASSERT(g_hDLLInstance != NULL);
			g_hDLLInstance = NULL;


			CleanupProcessGlobals();

			COM_Free();

			DNOSIndirectionDeinit();
			
			break;
		}

		default:
		{
			DNASSERT(FALSE);
			break;
		}
	}

	return fResult;
} // DllMain





#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
//=============================================================================
// DllRegisterServer
//-----------------------------------------------------------------------------
//
// Description: Registers the DP8Sim COM object.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK	- Successfully unregistered DP8Sim.
//	E_FAIL	- Failed unregistering DP8Sim.
//=============================================================================
HRESULT WINAPI DllRegisterServer(void)
{
	CRegistry	RegObject;


	//
	// Register the control COM object CLSID.
	//
	if (! RegObject.Register(L"DP8SimControl.1",
							L"DirectPlay8 Network Simulator Control Object",
							L"dp8sim.dll",
							CLSID_DP8SimControl,
							L"DP8SimControl"))
	{
		DPFX(DPFPREP, 0, "Could not register DP8SimControl object!");
		return E_FAIL;
	}


	return S_OK;
} // DllRegisterServer





#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
//=============================================================================
// DllUnregisterServer
//-----------------------------------------------------------------------------
//
// Description: Unregisters the DP8Sim COM object.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK	- Successfully unregistered DP8Sim.
//	E_FAIL	- Failed unregistering DP8Sim.
//=============================================================================
STDAPI DllUnregisterServer(void)
{
	CRegistry	RegObject;


	//
	// Unregister the control class.
	//
	if (! RegObject.UnRegister(CLSID_DP8SimControl))
	{
		DPFX(DPFPREP, 0, "Failed to unregister DP8Sim control object!");
		return E_FAIL;
	}

	return S_OK;
} // DllUnregisterServer






#undef DPF_MODNAME
#define DPF_MODNAME "InitializeProcessGlobals"
//=============================================================================
// InitializeProcessGlobals
//-----------------------------------------------------------------------------
//
// Description: Initialize global items needed for the DLL to operate.
//
// Arguments: None.
//
// Returns: TRUE if successful, FALSE if an error occurred.
//=============================================================================
BOOL InitializeProcessGlobals(void)
{
	BOOL	fReturn = TRUE;
	BOOL	fInittedGlobalLock = FALSE;


	if (! DNInitializeCriticalSection(&g_csGlobalsLock))
	{
		DPFX(DPFPREP, 0, "Failed to initialize global lock!");
		goto Failure;
	}

	fInittedGlobalLock = TRUE;

	
	//
	// Don't allow critical section reentry.
	//
	DebugSetCriticalSectionRecursionCount(&g_csGlobalsLock, 0);


	if (!InitializePools())
	{
		DPFX(DPFPREP, 0, "Failed initializing pools!");
		goto Failure;
	}


	g_blDP8SimSPObjs.Initialize();
	g_blDP8SimControlObjs.Initialize();


	//
	// Seed the random number generator with the current time.
	//
	InitializeGlobalRand(GETTIMESTAMP());


Exit:

	return fReturn;


Failure:

	if (fInittedGlobalLock)
	{
		DNDeleteCriticalSection(&g_csGlobalsLock);
	}

	fReturn = FALSE;

	goto Exit;
} // InitializeProcessGlobals




#undef DPF_MODNAME
#define DPF_MODNAME "CleanupProcessGlobals"
//=============================================================================
// CleanupProcessGlobals
//-----------------------------------------------------------------------------
//
// Description: Releases global items used by DLL.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CleanupProcessGlobals(void)
{
	CBilink *			pBilink;
	CDP8SimSP *			pDP8SimSP;
	CDP8SimControl *	pDP8SimControl;


	if (! g_blDP8SimSPObjs.IsEmpty())
	{
		DNASSERT(! "DP8Sim DLL unloading without all SP objects having been released!");

		//
		// Force close all the objects still outstanding.
		//
		pBilink = g_blDP8SimSPObjs.GetNext();
		while (pBilink != &g_blDP8SimSPObjs)
		{
			pDP8SimSP = DP8SIMSP_FROM_BILINK(pBilink);
			pBilink = pBilink->GetNext();


			DPFX(DPFPREP, 0, "Forcefully releasing SP object 0x%p!", pDP8SimSP);

			pDP8SimSP->Close(); // ignore error
			

			//
			// Forcefully remove it from the list and delete it instead of
			// using pDP8SimSP->Release().
			//
			pDP8SimSP->m_blList.RemoveFromList();
			pDP8SimSP->UninitializeObject();
			delete pDP8SimSP;
		}
	}


	if (! g_blDP8SimControlObjs.IsEmpty())
	{
		DNASSERT(! "DP8Sim DLL unloading without all Control objects having been released!");

		//
		// Force close all the objects still outstanding.
		//
		pBilink = g_blDP8SimControlObjs.GetNext();
		while (pBilink != &g_blDP8SimControlObjs)
		{
			pDP8SimControl = DP8SIMCONTROL_FROM_BILINK(pBilink);
			pBilink = pBilink->GetNext();


			DPFX(DPFPREP, 0, "Forcefully releasing Control object 0x%p!", pDP8SimControl);

			pDP8SimControl->Close(0); // ignore error
			

			//
			// Forcefully remove it from the list and delete it instead of
			// using pDP8SimControl->Release().
			//
			pDP8SimControl->m_blList.RemoveFromList();
			pDP8SimControl->UninitializeObject();
			delete pDP8SimControl;
		}
	}

	CleanupPools();

	DNDeleteCriticalSection(&g_csGlobalsLock);
} // CleanupProcessGlobals





#undef DPF_MODNAME
#define DPF_MODNAME "LoadAndAllocString"
//=============================================================================
// LoadAndAllocString
//-----------------------------------------------------------------------------
//
// Description: DNMallocs a wide character string from the given resource ID.
//
// Arguments:
//	UINT uiResourceID		- Resource ID to load.
//	WCHAR ** pwszString		- Place to store pointer to allocated string.
//
// Returns: HRESULT
//=============================================================================
HRESULT LoadAndAllocString(UINT uiResourceID, WCHAR ** pwszString)
{
	HRESULT		hr = DPN_OK;
	int			iLength;


	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		WCHAR	wszTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
		

		iLength = LoadStringW(g_hDLLInstance, uiResourceID, wszTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
		if (iLength == 0)
		{
			hr = GetLastError();		
			
			DPFX(DPFPREP, 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr);
			(*pwszString) = NULL;

			goto Exit;
		}


		(*pwszString) = (WCHAR*) DNMalloc((iLength + 1) * sizeof(WCHAR));
		if ((*pwszString) == NULL)
		{
			DPFX(DPFPREP, 0, "Memory allocation failure!");
			hr = DPNERR_OUTOFMEMORY;
			goto Exit;
		}


		wcscpy((*pwszString), wszTmpBuffer);
	}
	else
	{
		char	szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];
		

		iLength = LoadStringA(g_hDLLInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
		if (iLength == 0)
		{
			hr = GetLastError();		
			
			DPFX(DPFPREP, 0, "Unable to load resource ID %u (err =0x%lx)!", uiResourceID, hr);
			(*pwszString) = NULL;

			goto Exit;
		}

		
		(*pwszString) = (WCHAR*) DNMalloc((iLength + 1) * sizeof(WCHAR));
		if ((*pwszString) == NULL)
		{
			DPFX(DPFPREP, 0, "Memory allocation failure!");
			hr = DPNERR_OUTOFMEMORY;
			goto Exit;
		}


		hr = STR_jkAnsiToWide((*pwszString), szTmpBuffer, (iLength + 1));
		if (hr == DPN_OK)
		{
			hr = GetLastError();
			
			DPFX(DPFPREP, 0, "Unable to convert from ANSI to Unicode (err =0x%lx)!", hr);

			goto Exit;
		}
	}


Exit:

	return hr;
} // LoadAndAllocString





#undef DPF_MODNAME
#define DPF_MODNAME "InitializeGlobalRand"
//=============================================================================
// InitializeGlobalRand
//-----------------------------------------------------------------------------
//
// Description:   Initializes the global psuedo-random number generator, using
//				the given seed value.
//
//				  Based completely off of the C run-time source.
//
// Arguments:
//	DWORD dwSeed	- Seed to use.
//
// Returns: None.
//=============================================================================
void InitializeGlobalRand(const DWORD dwSeed)
{
	//
	// We don't need to hold a lock, since this should only be done once,
	// during initialization time.
	//
	g_dwHoldRand = dwSeed;
} // InitializeGlobalRand





#undef DPF_MODNAME
#define DPF_MODNAME "GetGlobalRand"
//=============================================================================
// GetGlobalRand
//-----------------------------------------------------------------------------
//
// Description:   Generates a pseudo-random number, 0 through 32767.
//
//				  Based completely off of the C run-time source.
//
// Arguments: None.
//
// Returns: Pseudo-random number.
//=============================================================================
WORD GetGlobalRand(void)
{
	WORD	wResult;


	DNEnterCriticalSection(&g_csGlobalsLock);

	//
	// This version wasn't generating a sequence to my liking:
	// 
	//	With % to drop set to 01, % kept = 96, % dropped = 3
	//	With % to drop set to 02, % kept = 94, % dropped = 5
	//	With % to drop set to 03, % kept = 94, % dropped = 5
	//	With % to drop set to 04, % kept = 94, % dropped = 5
	//	With % to drop set to 05, % kept = 93, % dropped = 6
	//	With % to drop set to 06, % kept = 93, % dropped = 6
	//	With % to drop set to 07, % kept = 92, % dropped = 7
	//	With % to drop set to 08, % kept = 91, % dropped = 8
	//	With % to drop set to 09, % kept = 90, % dropped = 9
	//	With % to drop set to 10, % kept = 87, % dropped = 12
	//	With % to drop set to 11, % kept = 85, % dropped = 14
	//	With % to drop set to 12, % kept = 85, % dropped = 14
	//	With % to drop set to 13, % kept = 85, % dropped = 14
	//	With % to drop set to 14, % kept = 85, % dropped = 14
	//	With % to drop set to 15, % kept = 85, % dropped = 14
	//	With % to drop set to 16, % kept = 85, % dropped = 14
	//	With % to drop set to 17, % kept = 85, % dropped = 14
	//	With % to drop set to 18, % kept = 82, % dropped = 17
	//	With % to drop set to 19, % kept = 82, % dropped = 17
	//	With % to drop set to 20, % kept = 80, % dropped = 19
	//
	//g_dwHoldRand = ((g_dwHoldRand * 214013L + 2531011L) >> 16) & 0x7fff;
	//wResult = (WORD) g_dwHoldRand;


	//
	// So I use this one instead:
	//
	//	With % to drop set to 01, % kept = 99, % dropped = 00
	//	With % to drop set to 02, % kept = 98, % dropped = 01
	//	With % to drop set to 03, % kept = 97, % dropped = 02
	//	With % to drop set to 04, % kept = 96, % dropped = 03
	//	With % to drop set to 05, % kept = 95, % dropped = 04
	//	With % to drop set to 06, % kept = 94, % dropped = 05
	//	With % to drop set to 07, % kept = 92, % dropped = 07
	//	With % to drop set to 08, % kept = 90, % dropped = 09
	//	With % to drop set to 09, % kept = 87, % dropped = 12
	//	With % to drop set to 10, % kept = 87, % dropped = 12
	//	With % to drop set to 11, % kept = 86, % dropped = 13
	//	With % to drop set to 12, % kept = 85, % dropped = 14
	//	With % to drop set to 13, % kept = 84, % dropped = 15
	//	With % to drop set to 14, % kept = 84, % dropped = 15
	//	With % to drop set to 15, % kept = 84, % dropped = 15
	//	With % to drop set to 16, % kept = 84, % dropped = 15
	//	With % to drop set to 17, % kept = 83, % dropped = 16
	//	With % to drop set to 18, % kept = 82, % dropped = 17
	//	With % to drop set to 19, % kept = 81, % dropped = 18
	//	With % to drop set to 20, % kept = 80, % dropped = 19
	//
	g_dwHoldRand = ((g_dwHoldRand * 1103515245L + 12345L) >> 16) & 0x7fff;
	wResult = (WORD) g_dwHoldRand;


	DNLeaveCriticalSection(&g_csGlobalsLock);

	return wResult;
} // GetGlobalRand





#undef DPF_MODNAME
#define DPF_MODNAME "DoCreateInstance"
//=============================================================================
// DoCreateInstance
//-----------------------------------------------------------------------------
//
// Description: Creates an instance of an interface.  Required by the general
//				purpose class factory functions.
//
// Arguments:
//	LPCLASSFACTORY This		- Pointer to class factory.
//	LPUNKNOWN pUnkOuter		- Pointer to unknown interface.
//	REFCLSID rclsid			- Reference of GUID of desired interface.
//	REFIID riid				- Reference to another GUID?
//	LPVOID * ppvObj			- Pointer to pointer to interface.
//
// Returns: HRESULT
//=============================================================================
HRESULT DoCreateInstance(LPCLASSFACTORY This,
						LPUNKNOWN pUnkOuter,
						REFCLSID rclsid,
						REFIID riid,
						LPVOID * ppvObj)
{
	HRESULT				hr;
	CDP8SimSP *			pDP8SimSP = NULL;
	CDP8SimControl *	pDP8SimControl = NULL;


	DNASSERT(ppvObj != NULL);


	if (! IsEqualCLSID(rclsid, CLSID_DP8SimControl))
	{
		//
		// We play COM registration games, so we could get called with pretty
		// much any service provider's CLSID.
		//

		if ((! IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP)) &&
			(! IsEqualCLSID(rclsid, CLSID_DP8SP_IPX)) &&
			(! IsEqualCLSID(rclsid, CLSID_DP8SP_MODEM)) &&
			(! IsEqualCLSID(rclsid, CLSID_DP8SP_SERIAL)))
		{
			/*
			//
			// Return an error.
			//
			hr = E_UNEXPECTED;
			goto Failure;
			*/

			//
			// Print a warning.
			//
			DPFX(DPFPREP, 0, "Unrecognized service provider class ID, continuing...");
		}
	}


	//
	// See if it's the control object.
	//
	if (IsEqualCLSID(rclsid, CLSID_DP8SimControl))
	{
		//
		// Create the object instance.
		//
		pDP8SimControl = new CDP8SimControl;
		if (pDP8SimControl == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto Failure;
		}


		//
		// Initialize the base object (which might fail).
		//
		hr = pDP8SimControl->InitializeObject();
		if (hr != S_OK)
		{
			delete pDP8SimControl;
			pDP8SimControl = NULL;
			goto Failure;
		}


		//
		// Add it to the global list.
		//
		DNEnterCriticalSection(&g_csGlobalsLock);

		pDP8SimControl->m_blList.InsertBefore(&g_blDP8SimControlObjs);
		
		g_lOutstandingInterfaceCount++;	// update count so DllCanUnloadNow works correctly

		DNLeaveCriticalSection(&g_csGlobalsLock);


		//
		// Get the right interface for the caller and bump the refcount.
		//
		hr = pDP8SimControl->QueryInterface(riid, ppvObj);
		if (hr != S_OK)
		{
			goto Failure;
		}
	}
	else
	{
		//
		// Create the object instance.
		//
		pDP8SimSP = new CDP8SimSP(&rclsid);
		if (pDP8SimSP == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto Failure;
		}

		//
		// Initialize the base object (which might fail).
		//
		hr = pDP8SimSP->InitializeObject();
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't initialize object!");
			delete pDP8SimSP;
			pDP8SimSP = NULL;
			goto Failure;
		}


		//
		// Add it to the global list.
		//
		DNEnterCriticalSection(&g_csGlobalsLock);

		pDP8SimSP->m_blList.InsertBefore(&g_blDP8SimSPObjs);
		
		g_lOutstandingInterfaceCount++;	// update count so DllCanUnloadNow works correctly

		DNLeaveCriticalSection(&g_csGlobalsLock);


		//
		// Get the right interface for the caller and bump the refcount.
		//
		hr = pDP8SimSP->QueryInterface(riid, ppvObj);
		if (hr != S_OK)
		{
			goto Failure;
		}
	}


Exit:

	//
	// Release the local reference to the objec(s)t.  If this function was
	// successful, there's still a reference in ppvObj.
	//

	if (pDP8SimSP != NULL)
	{
		pDP8SimSP->Release();
		pDP8SimSP = NULL;
	}

	if (pDP8SimControl != NULL)
	{
		pDP8SimControl->Release();
		pDP8SimControl = NULL;
	}

	return hr;


Failure:

	//
	// Make sure we don't hand back a pointer.
	//
	(*ppvObj) = NULL;

	goto Exit;
} // DoCreateInstance




#undef DPF_MODNAME
#define DPF_MODNAME "IsClassImplemented"
//=============================================================================
// IsClassImplemented
//-----------------------------------------------------------------------------
//
// Description: Determine if a class is implemented in this DLL.  Required by
//				the general purpose class factory functions.
//
// Arguments:
//	REFCLSID rclsid		- Reference to class GUID.
//
// Returns: BOOL
//	TRUE	 - This DLL implements the class.
//	FALSE	 - This DLL doesn't implement the class.
//=============================================================================
BOOL IsClassImplemented(REFCLSID rclsid)
{
	if (IsEqualCLSID(rclsid, CLSID_DP8SimControl))
	{
		return TRUE;
	}


	//
	// We play COM registration games, so we could get called with pretty
	// much any service provider's CLSID.
	//

	if ((IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP)) ||
		(IsEqualCLSID(rclsid, CLSID_DP8SP_IPX)) ||
		(IsEqualCLSID(rclsid, CLSID_DP8SP_MODEM)) ||
		(IsEqualCLSID(rclsid, CLSID_DP8SP_SERIAL)))
	{
		//
		// One of the usual DPlay8 SPs.
		//
		return TRUE;
	}


	DPFX(DPFPREP, 1, "Got unexpected service provider CLSID, pretending to implement.");

	return TRUE;
} // IsClassImplemented
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simjob.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simjob.h
 *
 *  Content:	Header for job object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  06/09/01  VanceO    Created.
 *
 ***************************************************************************/




//=============================================================================
// Macros
//=============================================================================
#ifndef	OFFSETOF
#define OFFSETOF(s,m)					( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)		(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

#define DP8SIMJOB_FROM_BILINK(b)		(CONTAINING_OBJECT(b, CDP8SimJob, m_blList))






//=============================================================================
// Structures
//=============================================================================
typedef struct _DP8SIMJOB_FPMCONTEXT
{
	DWORD			dwTime;		// time for the job to fire
	DWORD			dwJobType;	// type of job
	PVOID			pvContext;	// context for job
	CDP8SimSP *		pDP8SimSP;	// owning SP object, if any
} DP8SIMJOB_FPMCONTEXT, * PDP8SIMJOB_FPMCONTEXT;






//=============================================================================
// Job object class
//=============================================================================
class CDP8SimJob
{
	public:

		CDP8SimJob(void)	{};
		~CDP8SimJob(void)	{};


		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimJob))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x4a4d4953)	// 0x4a 0x4d 0x49 0x53 = 'JMIS' = 'SIMJ' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};




		BOOL FPMAlloc(void * const pvContext)
		{
			this->m_Sig[0] = 'S';
			this->m_Sig[1] = 'I';
			this->m_Sig[2] = 'M';
			this->m_Sig[3] = 'j';	// start with lower case so we can tell when it's in the pool or not

			this->m_blList.Initialize();

			this->m_dwTime		= 0;
			this->m_dwJobType	= 0;
			this->m_pvContext	= NULL;
			this->m_pDP8SimSP	= NULL;

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimJob::FPMInitialize"
		BOOL FPMInitialize(void * const pvContext)
		{
			DP8SIMJOB_FPMCONTEXT *	pContext = (DP8SIMJOB_FPMCONTEXT*) pvContext;


			this->m_dwTime			= pContext->dwTime;
			this->m_dwJobType		= pContext->dwJobType;
			this->m_pvContext		= pContext->pvContext;

			if (pContext->pDP8SimSP != NULL)
			{
				pContext->pDP8SimSP->AddRef();
				this->m_pDP8SimSP	= pContext->pDP8SimSP;
			}
			else
			{
				DNASSERT(this->m_pDP8SimSP == NULL);
			}

			
			//
			// Change the signature before handing it out.
			//
			this->m_Sig[3]	= 'J';

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimJob::FPMRelease"
		void FPMRelease(void * const pvContext)
		{
			DNASSERT(this->m_blList.IsEmpty());

			if (this->m_pDP8SimSP != NULL)
			{
				this->m_pDP8SimSP->Release();
				this->m_pDP8SimSP = NULL;
			}


			//
			// Change the signature before putting the object back in the pool.
			//
			this->m_Sig[3]	= 'j';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimJob::FPMDealloc"
		void FPMDealloc(void * const pvContext)
		{
			DNASSERT(this->m_blList.IsEmpty());
			DNASSERT(this->m_pDP8SimSP == NULL);
		}


		inline DWORD GetTime(void)						{ return this->m_dwTime; };
		inline DWORD GetJobType(void)					{ return this->m_dwJobType; };
		inline PVOID GetContext(void)					{ return this->m_pvContext; };
		inline CDP8SimSP * GetDP8SimSP(void)			{ return this->m_pDP8SimSP; };

		inline void SetNewTime(const DWORD dwTime)		{ this->m_dwTime = dwTime; };



		CBilink			m_blList;		// list of all the active jobs

	
	private:
		BYTE			m_Sig[4];		// debugging signature ('SIMJ')
		DWORD			m_dwTime;		// time the job must be performed
		DWORD			m_dwJobType;	// ID of job to be performed
		PVOID			m_pvContext;	// context for job
		CDP8SimSP *		m_pDP8SimSP;	// pointer to DP8SimSP object submitting send, or NULL if none
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simpools.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simpools.h
 *
 *  Content:	Header for DP8SIM pools.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  06/09/01  VanceO    Created.
 *
 ***************************************************************************/



//=============================================================================
// Forward typedefs
//=============================================================================
class CDP8SimSend;
class CDP8SimReceive;
class CDP8SimCommand;
class CDP8SimJob;
class CDP8SimEndpoint;




///=============================================================================
// External variable references
//=============================================================================
extern CLockedContextClassFixedPool<CDP8SimSend> *		g_pFPOOLSend;
extern CLockedContextClassFixedPool<CDP8SimReceive> *	g_pFPOOLReceive;
extern CLockedContextClassFixedPool<CDP8SimCommand> *	g_pFPOOLCommand;
extern CLockedContextClassFixedPool<CDP8SimJob> *		g_pFPOOLJob;
extern CLockedContextClassFixedPool<CDP8SimEndpoint> *	g_pFPOOLEndpoint;




///=============================================================================
// External functions
//=============================================================================
BOOL InitializePools(void);
void CleanupPools(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simlocals.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simlocals.h
 *
 *  Content:	Header for DP8SIM global variables and functions found in
 *				dp8simdllmain.cpp.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



//=============================================================================
// Defines
//=============================================================================
#define DP8SIM_REG_REALSPDLL				L"DP8SimRealSPDLL"
#define DP8SIM_REG_REALSPFRIENDLYNAME		L"DP8SimRealSPFriendlyName"



//=============================================================================
// Forward typedefs
//=============================================================================
class CDP8SimCB;
class CDP8SimSP;
class CDP8SimControl;




///=============================================================================
// External variable references
//=============================================================================
extern volatile LONG		g_lOutstandingInterfaceCount;

extern HINSTANCE			g_hDLLInstance;

extern DNCRITICAL_SECTION	g_csGlobalsLock;
extern CBilink				g_blDP8SimSPObjs;
extern CBilink				g_blDP8SimControlObjs;




///=============================================================================
// External functions
//=============================================================================
void InitializeGlobalRand(const DWORD dwSeed);
WORD GetGlobalRand(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simpools.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dp8simpools.cpp
 *
 *  Content:	DP8SIM pool maintainence functions.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  06/09/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"




//=============================================================================
// External globals
//=============================================================================
CLockedContextClassFixedPool<CDP8SimSend> *			g_pFPOOLSend = NULL;
CLockedContextClassFixedPool<CDP8SimReceive> *		g_pFPOOLReceive = NULL;
CLockedContextClassFixedPool<CDP8SimCommand> *		g_pFPOOLCommand = NULL;
CLockedContextClassFixedPool<CDP8SimJob> *			g_pFPOOLJob = NULL;
CLockedContextClassFixedPool<CDP8SimEndpoint> *		g_pFPOOLEndpoint = NULL;





#undef DPF_MODNAME
#define DPF_MODNAME "InitializePools"
//=============================================================================
// InitializePools
//-----------------------------------------------------------------------------
//
// Description: Initialize pools for items used by the DLL.
//
// Arguments: None.
//
// Returns: TRUE if successful, FALSE if an error occurred.
//=============================================================================
BOOL InitializePools(void)
{
	BOOL	fReturn;


	//
	// Build send pool.
	//
	g_pFPOOLSend = new CLockedContextClassFixedPool<CDP8SimSend>;
	if (g_pFPOOLSend == NULL)
	{
		fReturn = FALSE;
		goto Failure;
	}
	
	g_pFPOOLSend->Initialize(CDP8SimSend::FPMAlloc,
							CDP8SimSend::FPMInitialize,
							CDP8SimSend::FPMRelease,
							CDP8SimSend::FPMDealloc);


	//
	// Build receive pool.
	//
	g_pFPOOLReceive = new CLockedContextClassFixedPool<CDP8SimReceive>;
	if (g_pFPOOLReceive == NULL)
	{
		fReturn = FALSE;
		goto Failure;
	}
	
	g_pFPOOLReceive->Initialize(CDP8SimReceive::FPMAlloc,
								CDP8SimReceive::FPMInitialize,
								CDP8SimReceive::FPMRelease,
								CDP8SimReceive::FPMDealloc);


	//
	// Build command pool.
	//
	g_pFPOOLCommand = new CLockedContextClassFixedPool<CDP8SimCommand>;
	if (g_pFPOOLCommand == NULL)
	{
		fReturn = FALSE;
		goto Failure;
	}
	
	g_pFPOOLCommand->Initialize(CDP8SimCommand::FPMAlloc,
								CDP8SimCommand::FPMInitialize,
								CDP8SimCommand::FPMRelease,
								CDP8SimCommand::FPMDealloc);


	//
	// Build job pool.
	//
	g_pFPOOLJob = new CLockedContextClassFixedPool<CDP8SimJob>;
	if (g_pFPOOLJob == NULL)
	{
		fReturn = FALSE;
		goto Failure;
	}
	
	g_pFPOOLJob->Initialize(CDP8SimJob::FPMAlloc,
							CDP8SimJob::FPMInitialize,
							CDP8SimJob::FPMRelease,
							CDP8SimJob::FPMDealloc);


	//
	// Build endpoint pool.
	//
	g_pFPOOLEndpoint = new CLockedContextClassFixedPool<CDP8SimEndpoint>;
	if (g_pFPOOLEndpoint == NULL)
	{
		fReturn = FALSE;
		goto Failure;
	}
	
	g_pFPOOLEndpoint->Initialize(CDP8SimEndpoint::FPMAlloc,
								CDP8SimEndpoint::FPMInitialize,
								CDP8SimEndpoint::FPMRelease,
								CDP8SimEndpoint::FPMDealloc);


	fReturn = TRUE;


Exit:

	return fReturn;


Failure:

	/*
	if (CDP8SimEndpoint != NULL)
	{
		CDP8SimEndpoint->Deinitialize();
		delete CDP8SimEndpoint;
		CDP8SimEndpoint = NULL;
	}
	*/

	if (g_pFPOOLJob != NULL)
	{
		g_pFPOOLJob->Deinitialize();
		delete g_pFPOOLJob;
		g_pFPOOLJob = NULL;
	}

	if (g_pFPOOLCommand != NULL)
	{
		g_pFPOOLCommand->Deinitialize();
		delete g_pFPOOLCommand;
		g_pFPOOLCommand = NULL;
	}

	if (g_pFPOOLReceive != NULL)
	{
		g_pFPOOLReceive->Deinitialize();
		delete g_pFPOOLReceive;
		g_pFPOOLReceive = NULL;
	}

	if (g_pFPOOLSend != NULL)
	{
		g_pFPOOLSend->Deinitialize();
		delete g_pFPOOLSend;
		g_pFPOOLSend = NULL;
	}

	fReturn = FALSE;

	goto Exit;
} // InitializePools




#undef DPF_MODNAME
#define DPF_MODNAME "CleanupPools"
//=============================================================================
// CleanupPools
//-----------------------------------------------------------------------------
//
// Description: Releases pooled items used by DLL.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CleanupPools(void)
{
	g_pFPOOLEndpoint->Deinitialize();
	delete g_pFPOOLEndpoint;
	g_pFPOOLEndpoint = NULL;


	g_pFPOOLJob->Deinitialize();
	delete g_pFPOOLJob;
	g_pFPOOLJob = NULL;


	g_pFPOOLCommand->Deinitialize();
	delete g_pFPOOLCommand;
	g_pFPOOLCommand = NULL;


	g_pFPOOLReceive->Deinitialize();
	delete g_pFPOOLReceive;
	g_pFPOOLReceive = NULL;


	g_pFPOOLSend->Deinitialize();
	delete g_pFPOOLSend;
	g_pFPOOLSend = NULL;
} // CleanupPools
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simipc.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simipc.h
 *
 *  Content:	Header for interprocess communication object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/25/01  VanceO    Created.
 *
 ***************************************************************************/




//=============================================================================
// Defines
//=============================================================================
#define DP8SIM_IPC_VERSION				1

#define DP8SIM_IPC_MUTEXNAME			"DP8Sim IPC Mutex"
#define DP8SIM_IPC_FILEMAPPINGNAME		"DP8Sim IPC File Mapping"




//=============================================================================
// Structures
//=============================================================================
typedef struct _DP8SIM_SHAREDMEMORY
{
	DWORD				dwVersion;		// shared memory version
	DP8SIM_PARAMETERS	dp8spSend;		// current send settings
	DP8SIM_PARAMETERS	dp8spReceive;	// current receive settings
	DP8SIM_STATISTICS	dp8ssSend;		// current send statistics
	DP8SIM_STATISTICS	dp8ssReceive;	// current receive statistics
} DP8SIM_SHAREDMEMORY, * PDP8SIM_SHAREDMEMORY;







//=============================================================================
// Send object class
//=============================================================================
class CDP8SimIPC
{
	public:
		CDP8SimIPC(void);	// constructor
		~CDP8SimIPC(void);	// destructor


		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimIPC))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x494d4953)	// 0x49 0x4d 0x49 0x53 = 'IMIS' = 'SIMI' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};


		HRESULT Initialize(void);

		void Close(void);

		void GetAllParameters(DP8SIM_PARAMETERS * const pdp8spSend,
							DP8SIM_PARAMETERS * const pdp8spReceive);

		void GetAllSendParameters(DP8SIM_PARAMETERS * const pdp8sp);

		void GetAllReceiveParameters(DP8SIM_PARAMETERS * const pdp8sp);

		void SetAllParameters(const DP8SIM_PARAMETERS * const pdp8spSend,
							const DP8SIM_PARAMETERS * const pdp8spReceive);

		void GetAllStatistics(DP8SIM_STATISTICS * const pdp8ssSend,
							DP8SIM_STATISTICS * const pdp8ssReceive);

		void ClearAllStatistics(void);

		void IncrementStatSendTransmitted(void);

		void IncrementStatSendDropped(void);

		void IncrementStatReceiveTransmitted(void);

		void IncrementStatReceiveDropped(void);



	
	private:
		BYTE					m_Sig[4];		// debugging signature ('SIMI')
		HANDLE					m_hMutex;		// handle to mutex protecting shared memory
		HANDLE					m_hFileMapping;	// handle to shared memory
		DP8SIM_SHAREDMEMORY *	m_pdp8ssm;		// pointer to mapped view of shared memory


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::LockSharedMemory"
		inline void LockSharedMemory(void)
		{
			DNASSERT(this->m_hMutex != NULL);
			WaitForSingleObject(this->m_hMutex, INFINITE);
		}

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::UnlockSharedMemory"
		inline void UnlockSharedMemory(void)
		{
			DNASSERT(this->m_hMutex != NULL);
			ReleaseMutex(this->m_hMutex);
		}

		void LoadDefaultParameters(DP8SIM_PARAMETERS * const pdp8spSend,
									DP8SIM_PARAMETERS * const pdp8spReceive);

		void SaveDefaultParameters(const DP8SIM_PARAMETERS * const pdp8spSend,
									const DP8SIM_PARAMETERS * const pdp8spReceive);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simreceive.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simreceive.h
 *
 *  Content:	Header for receive object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  05/05/01  VanceO    Created.
 *
 ***************************************************************************/




//=============================================================================
// Defines
//=============================================================================
#define MAX_DATA_SIZE		1472	// prevent individual messages larger than one Ethernet frame - UDP headers





//=============================================================================
// Receive object class
//=============================================================================
class CDP8SimReceive
{
	public:

		CDP8SimReceive(void)	{};
		~CDP8SimReceive(void)	{};


		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimReceive))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x524d4953)	// 0x52 0x4d 0x49 0x53 = 'RMIS' = 'SIMR' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};




		BOOL FPMAlloc(void * const pvContext)
		{
			this->m_Sig[0] = 'S';
			this->m_Sig[1] = 'I';
			this->m_Sig[2] = 'M';
			this->m_Sig[3] = 'r';	// start with lower case so we can tell when it's in the pool or not

			this->m_lRefCount			= 0;
			this->m_pDP8SimEndpoint		= NULL;
			ZeroMemory(&this->m_data, sizeof(this->m_data));

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimReceive::FPMInitialize"
		BOOL FPMInitialize(void * const pvContext)
		{
			SPIE_DATA *		pData = (SPIE_DATA*) pvContext;


			this->m_lRefCount++;	// somebody is getting a pointer to this object
			DNASSERT(this->m_lRefCount == 1);


			//
			// Get an endpoint reference.
			//
			this->m_pDP8SimEndpoint = (CDP8SimEndpoint*) pData->pEndpointContext;
			DNASSERT(this->m_pDP8SimEndpoint->IsValidObject());
			this->m_pDP8SimEndpoint->AddRef();


			DNASSERT(pData->pReceivedData->pNext == NULL);


			//
			// Copy the receive data block.
			//
			this->m_data.hEndpoint				= (HANDLE) this->m_pDP8SimEndpoint;
			this->m_data.pEndpointContext		= this->m_pDP8SimEndpoint->GetUserContext();
			this->m_data.pReceivedData			= pData->pReceivedData;

			
			//
			// Change the signature before handing it out.
			//
			this->m_Sig[3]	= 'R';

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimReceive::FPMRelease"
		void FPMRelease(void * const pvContext)
		{
			DNASSERT(this->m_lRefCount == 0);

			//
			// Release the endpoint reference.
			//
			DNASSERT(this->m_pDP8SimEndpoint != NULL);

			this->m_pDP8SimEndpoint->Release();
			this->m_pDP8SimEndpoint = NULL;


			//
			// Change the signature before putting the object back in the pool.
			//
			this->m_Sig[3]	= 'r';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimReceive::FPMDealloc"
		void FPMDealloc(void * const pvContext)
		{
			DNASSERT(this->m_lRefCount == 0);
			DNASSERT(this->m_pDP8SimEndpoint == NULL);
		}




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimReceive::AddRef"
		inline void AddRef(void)
		{
			LONG	lResult;


			lResult = InterlockedIncrement(&this->m_lRefCount);
			DNASSERT(lResult > 0);
			DPFX(DPFPREP, 9, "Receive 0x%p refcount = %u.", this, lResult);
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimReceive::Release"
		inline void Release(void)
		{
			LONG	lResult;


			lResult = InterlockedDecrement(&this->m_lRefCount);
			DNASSERT(lResult >= 0);
			if (lResult == 0)
			{
				DPFX(DPFPREP, 9, "Receive 0x%p refcount = 0, returning to pool.", this);

				//
				// Time to return this object to the pool.
				//
				g_pFPOOLReceive->Release(this);
			}
			else
			{
				DPFX(DPFPREP, 9, "Receive 0x%p refcount = %u.", this, lResult);
			}
		};


		inline CDP8SimEndpoint * GetEndpoint(void)			{ return this->m_pDP8SimEndpoint; };
		//inline DWORD GetTotalReceiveSize(void)				{ return this->m_data.pReceivedData->BufferDesc.dwBufferSize; };
		inline SPIE_DATA * GetReceiveDataBlockPtr(void)		{ return (&this->m_data); };
		inline HANDLE GetReceiveDataBlockEndpoint(void)		{ return this->m_data.hEndpoint; };


	
	private:
		BYTE				m_Sig[4];			// debugging signature ('SIMR')
		LONG				m_lRefCount;		// number of references for this object
		CDP8SimEndpoint*	m_pDP8SimEndpoint;	// pointer to source endpoint
		SPIE_DATA			m_data;				// receive data block
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simsend.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simsend.h
 *
 *  Content:	Header for send object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/




//=============================================================================
// Defines
//=============================================================================
#define MAX_DATA_SIZE		1472	// prevent individual messages larger than one Ethernet frame - UDP headers





//=============================================================================
// Send object class
//=============================================================================
class CDP8SimSend
{
	public:

		CDP8SimSend(void)	{};
		~CDP8SimSend(void)	{};


		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimSend))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x534d4953)	// 0x53 0x4d 0x49 0x53 = 'SMIS' = 'SIMS' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};



		BOOL FPMAlloc(void * const pvContext)
		{
			this->m_Sig[0] = 'S';
			this->m_Sig[1] = 'I';
			this->m_Sig[2] = 'M';
			this->m_Sig[3] = 's';	// start with lower case so we can tell when it's in the pool or not

			this->m_lRefCount			= 0;
			this->m_pDP8SimEndpoint		= NULL;
			ZeroMemory(&this->m_adpnbd, sizeof(this->m_adpnbd));
			ZeroMemory(&this->m_spsd, sizeof(this->m_spsd));

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSend::FPMInitialize"
		BOOL FPMInitialize(void * const pvContext)
		{
			SPSENDDATA *	pspsd = (SPSENDDATA*) pvContext;
			BYTE *			pCurrent;
			DWORD			dwTemp;


			this->m_lRefCount++;	// somebody is getting a pointer to this object
			DNASSERT(this->m_lRefCount == 1);


			//
			// Reset the buffer descriptor array.
			//
			ZeroMemory(&this->m_adpnbd, sizeof(this->m_adpnbd));
			//this->m_adpnbd[0].pBufferData	= NULL;
			//this->m_adpnbd[0].dwBufferSize	= 0;
			this->m_adpnbd[1].pBufferData	= this->m_bData;
			//this->m_adpnbd[1].dwBufferSize	= 0;


			//
			// Get an endpoint reference.
			//
			this->m_pDP8SimEndpoint = (CDP8SimEndpoint*) pspsd->hEndpoint;
			DNASSERT(this->m_pDP8SimEndpoint->IsValidObject());
			this->m_pDP8SimEndpoint->AddRef();


			//
			// Copy the send data parameter block, modifying as necessary.
			//
			this->m_spsd.hEndpoint				= this->m_pDP8SimEndpoint->GetRealSPEndpoint();
			this->m_spsd.pBuffers				= &(this->m_adpnbd[1]);	// leave the first buffer desc for the real SP to play with
			this->m_spsd.dwBufferCount			= 1;
			this->m_spsd.dwFlags				= pspsd->dwFlags;
			this->m_spsd.pvContext				= NULL;	// this will be filled in later by SetSendDataBlockContext
			this->m_spsd.hCommand				= NULL;	// this gets filled in by the real SP
			this->m_spsd.dwCommandDescriptor	= 0;	// this gets filled in by the real SP

			
			//
			// Finally, copy the data into our contiguous local buffer.
			//

			pCurrent = this->m_adpnbd[1].pBufferData;

			for(dwTemp = 0; dwTemp < pspsd->dwBufferCount; dwTemp++)
			{
				if ((this->m_adpnbd[1].dwBufferSize + pspsd->pBuffers[dwTemp].dwBufferSize) > MAX_DATA_SIZE)
				{
					DPFX(DPFPREP, 0, "Data too large for single buffer!");
					return FALSE;
				}

				CopyMemory(pCurrent,
							pspsd->pBuffers[dwTemp].pBufferData,
							pspsd->pBuffers[dwTemp].dwBufferSize);

				pCurrent += pspsd->pBuffers[dwTemp].dwBufferSize;

				this->m_adpnbd[1].dwBufferSize += pspsd->pBuffers[dwTemp].dwBufferSize;
			}

			//
			// Change the signature before handing it out.
			//
			this->m_Sig[3]	= 'S';

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSend::FPMRelease"
		void FPMRelease(void * const pvContext)
		{
			DNASSERT(this->m_lRefCount == 0);

			//
			// Release the endpoint reference.
			//
			DNASSERT(this->m_pDP8SimEndpoint != NULL);

			this->m_pDP8SimEndpoint->Release();
			this->m_pDP8SimEndpoint = NULL;


			//
			// Change the signature before putting the object back in the pool.
			//
			this->m_Sig[3]	= 's';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSend::FPMDealloc"
		void FPMDealloc(void * const pvContext)
		{
			DNASSERT(this->m_lRefCount == 0);
			DNASSERT(this->m_pDP8SimEndpoint == NULL);
		}





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSend::AddRef"
		inline void AddRef(void)
		{
			LONG	lResult;


			lResult = InterlockedIncrement(&this->m_lRefCount);
			DNASSERT(lResult > 0);
			DPFX(DPFPREP, 9, "Send 0x%p refcount = %u.", this, lResult);
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSend::Release"
		inline void Release(void)
		{
			LONG	lResult;


			lResult = InterlockedDecrement(&this->m_lRefCount);
			DNASSERT(lResult >= 0);
			if (lResult == 0)
			{
				DPFX(DPFPREP, 9, "Send 0x%p refcount = 0, returning to pool.", this);

				//
				// Time to return this object to the pool.
				//
				g_pFPOOLSend->Release(this);
			}
			else
			{
				DPFX(DPFPREP, 9, "Send 0x%p refcount = %u.", this, lResult);
			}
		};




		inline CDP8SimEndpoint * GetEndpoint(void)				{ return this->m_pDP8SimEndpoint; };
		//inline DWORD GetTotalSendSize(void)						{ return this->m_adpnbd[1].dwBufferSize; };
		inline SPSENDDATA * GetSendDataBlockPtr(void)			{ return (&this->m_spsd); };
		inline HANDLE GetSendDataBlockCommand(void)				{ return this->m_spsd.hCommand; };
		inline DWORD GetSendDataBlockCommandDescriptor(void)	{ return this->m_spsd.dwCommandDescriptor; };

		inline void SetSendDataBlockContext(PVOID pvContext)	{ this->m_spsd.pvContext = pvContext; };


	
	private:
		BYTE				m_Sig[4];					// debugging signature ('SIMS')
		LONG				m_lRefCount;				// number of references for this object
		CDP8SimEndpoint*	m_pDP8SimEndpoint;			// pointer to destination endpoint
		DPN_BUFFER_DESC		m_adpnbd[2];				// data buffer descriptor array, always leave an extra buffer for SP
		SPSENDDATA			m_spsd;						// send data parameter block
		BYTE				m_bData[MAX_DATA_SIZE];		// data buffer
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dp8sim.rc
//
//#define IDS_FRIENDLYNAME_DEFAULT		1



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simworkerthread.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dp8simworkerthread.cpp
 *
 *  Content:	DP8SIM worker thread functions.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"




//=============================================================================
// Globals
//=============================================================================
LONG				g_lWorkerThreadRefCount = 0;	// number of times worker thread has been started
DNCRITICAL_SECTION	g_csJobQueueLock;				// lock protecting the job queue
CBilink				g_blJobQueue;					// list of jobs to be performed
HANDLE				g_hWorkerThreadJobEvent = NULL;	// event to signal when worker thread has a new job
HANDLE				g_hWorkerThread = NULL;			// handle to worker thread







//=============================================================================
// Prototypes
//=============================================================================
DWORD DP8SimWorkerThreadProc(PVOID pvParameter);






#undef DPF_MODNAME
#define DPF_MODNAME "StartGlobalWorkerThread"
//=============================================================================
// StartGlobalWorkerThread
//-----------------------------------------------------------------------------
//
// Description: Starts the global worker thread if it hasn't already been
//				started.  Each successful call to this function must be
//				balanced by a call to StopGlobalWorkerThread.
//
// Arguments: None.
//
// Returns: HRESULT
//=============================================================================
HRESULT StartGlobalWorkerThread(void)
{
	HRESULT		hr = DPN_OK;
	DWORD		dwThreadID;
	BOOL		fInittedCriticalSection = FALSE;


	DPFX(DPFPREP, 5, "Enter");


	DNEnterCriticalSection(&g_csGlobalsLock);

	DNASSERT(g_lWorkerThreadRefCount >= 0);
	if (g_lWorkerThreadRefCount == 0)
	{
		//
		// This is the first worker thread user.
		//


		if (! DNInitializeCriticalSection(&g_csJobQueueLock))
		{
			DPFX(DPFPREP, 0, "Failed initializing job queue critical section!");
			hr = DPNERR_GENERIC;
			goto Failure;
		}

		//
		// Don't allow critical section re-entry.
		//
		DebugSetCriticalSectionRecursionCount(&g_csJobQueueLock, 0);


		fInittedCriticalSection = TRUE;

		g_blJobQueue.Initialize();


		//
		// Create the new job notification event.
		//
		g_hWorkerThreadJobEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (g_hWorkerThreadJobEvent == NULL)
		{
			hr = GetLastError();
			DPFX(DPFPREP, 0, "Failed creating worker thread job event!");
			goto Failure;
		}

		//
		// Create the thread.
		//
		g_hWorkerThread = CreateThread(NULL,
										0,
										DP8SimWorkerThreadProc,
										NULL,
										0,
										&dwThreadID);
		if (g_hWorkerThread == NULL)
		{
			hr = GetLastError();
			DPFX(DPFPREP, 0, "Failed creating worker thread!");
			goto Failure;
		}
	}

	//
	// Bump the refcount for this successful call.
	//
	g_lWorkerThreadRefCount++;



Exit:

	DNLeaveCriticalSection(&g_csGlobalsLock);


	DPFX(DPFPREP, 5, "Returning: [0x%lx]", hr);

	return hr;


Failure:

	if (g_hWorkerThreadJobEvent != NULL)
	{
		CloseHandle(g_hWorkerThreadJobEvent);
		g_hWorkerThreadJobEvent = NULL;
	}

	if (fInittedCriticalSection)
	{
		DNDeleteCriticalSection(&g_csJobQueueLock);
		fInittedCriticalSection = FALSE;
	}

	goto Exit;
} // StartGlobalWorkerThread





#undef DPF_MODNAME
#define DPF_MODNAME "StopGlobalWorkerThread"
//=============================================================================
// StopGlobalWorkerThread
//-----------------------------------------------------------------------------
//
// Description: Stop the global worker thread.  This must balance a successful
//				call to StartGlobalWorkerThread.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void StopGlobalWorkerThread(void)
{
	DPFX(DPFPREP, 5, "Enter");


	DNEnterCriticalSection(&g_csGlobalsLock);


	DNASSERT(g_lWorkerThreadRefCount > 0);
	g_lWorkerThreadRefCount--;
	if (g_lWorkerThreadRefCount == 0)
	{
		//
		// Time to shut down the worker thread.
		//


		//
		// The job queue had better be empty.
		//
		DNASSERT(g_blJobQueue.IsEmpty());

		//
		// Submit a quit job.  Ignore error.
		//
		AddWorkerJob(0, DP8SIMJOBTYPE_QUIT, NULL, NULL, FALSE);


		//
		// Wait for the worker thread to close.
		//
		WaitForSingleObject(g_hWorkerThread, INFINITE);


		//
		// The job queue needs to be empty again.
		//
		DNASSERT(g_blJobQueue.IsEmpty());


		//
		// Close the thread handle.
		//
		CloseHandle(g_hWorkerThread);
		g_hWorkerThread = NULL;


		//
		// Close the event handle.
		//
		CloseHandle(g_hWorkerThreadJobEvent);
		g_hWorkerThreadJobEvent = NULL;


		//
		// Delete the critical section.
		//
		DNDeleteCriticalSection(&g_csJobQueueLock);
	}


	DNLeaveCriticalSection(&g_csGlobalsLock);


	DPFX(DPFPREP, 5, "Leave");
} // StopGlobalWorkerThread






#undef DPF_MODNAME
#define DPF_MODNAME "AddWorkerJob"
//=============================================================================
// AddWorkerJob
//-----------------------------------------------------------------------------
//
// Description:    Submits a new job of the given type to performed dwDelay
//				milliseconds from now.
//
//				   If fDelayFromPreviousJob is TRUE, then if there is a job of
//				the same type already queued, the new job is delayed further so
//				that it occurs dwDelay milliseconds after the last similar job.
//
// Arguments:
//	DWORD dwDelay				- How long to wait before performing job, in
//									milliseconds.
//	DWORD dwJobType				- ID indicating the type of type.
//	PVOID pvContext				- Context for the job.
//	CDP8SimSP * pDP8SimSP		- Pointer to interface submitting job, or NULL
//									for none.
//	BOOL fDelayFromPreviousJob	- Whether to add the delay beyond the last job
//									of the same type or not.
//
// Returns: HRESULT
//=============================================================================
HRESULT AddWorkerJob(const DWORD dwDelay,
					const DWORD dwJobType,
					PVOID const pvContext,
					CDP8SimSP * const pDP8SimSP,
					const BOOL fDelayFromPreviousJob)
{
	HRESULT					hr = DPN_OK;
	DP8SIMJOB_FPMCONTEXT	JobFPMContext;
	CDP8SimJob *			pDP8SimJob;
	CBilink *				pBilinkOriginalFirstItem;
	CBilink *				pBilink;
	CDP8SimJob *			pDP8SimTempJob;


	DPFX(DPFPREP, 5, "Parameters: (%u, %u, 0x%p, 0x%p, %i)",
		dwDelay, dwJobType, pvContext, pDP8SimSP, fDelayFromPreviousJob);



	DNASSERT(g_hWorkerThreadJobEvent != NULL);
	DNASSERT(g_hWorkerThread != NULL);


	//
	// Get a job object from the pool.
	//
	// Assume the job should execute after the appropriate delay.  If
	// fDelayFromPreviousJob is TRUE, we may need to adjust this.
	//

	ZeroMemory(&JobFPMContext, sizeof(JobFPMContext));
	JobFPMContext.dwTime		= timeGetTime() + dwDelay;
	JobFPMContext.dwJobType		= dwJobType;
	JobFPMContext.pvContext		= pvContext;
	JobFPMContext.pDP8SimSP		= pDP8SimSP;

	pDP8SimJob = g_pFPOOLJob->Get(&JobFPMContext);
	if (pDP8SimJob == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Lock the job queue.
	//
	DNEnterCriticalSection(&g_csJobQueueLock);


	//
	// If fDelayFromPreviousJob is TRUE, look for a previous job of the same
	// type.  If found, we need to delay this new job from the end of the last
	// one.
	//
	if (fDelayFromPreviousJob)
	{
		//
		// Work backward through the list.
		//
		pBilink = g_blJobQueue.GetPrev();
		while (pBilink != &g_blJobQueue)
		{
			pDP8SimTempJob = DP8SIMJOB_FROM_BILINK(pBilink);
			DNASSERT(pDP8SimTempJob->IsValidObject());
			if (dwJobType == pDP8SimTempJob->GetJobType())
			{
				//
				// We found a similar job.  Update the new job's time so that
				// the delay is added on top of the previous job.
				//

				DPFX(DPFPREP, 9, "Found similar job 0x%p (job time = %u, type = %u, context 0x%p, interface = 0x%p).",
					pDP8SimTempJob, pDP8SimTempJob->GetTime(), dwJobType, pDP8SimTempJob->GetContext(), pDP8SimSP);

				pDP8SimJob->SetNewTime(pDP8SimTempJob->GetTime() + dwDelay);

				break;
			}

			pBilink = pBilink->GetPrev();
		}
	}

	
	DPFX(DPFPREP, 8, "Adding new job 0x%p (job time = %u, type = %u, context 0x%p, interface = 0x%p).",
		pDP8SimJob, pDP8SimJob->GetTime(), dwJobType, pDP8SimJob->GetContext(), pDP8SimSP);


	//
	// Remember the current first item.
	//
	pBilinkOriginalFirstItem = g_blJobQueue.GetNext();


	//
	// Find the first job that needs to be fired after this one and insert the
	// new job before it.
	//
	pBilink = pBilinkOriginalFirstItem;
	while (pBilink != &g_blJobQueue)
	{
		pDP8SimTempJob = DP8SIMJOB_FROM_BILINK(pBilink);
		DNASSERT(pDP8SimTempJob->IsValidObject());

		if ((int) (pDP8SimJob->GetTime() - pDP8SimTempJob->GetTime()) < 0)
		{
			//
			// Stop looping.
			//
			break;
		}

		pBilink = pBilink->GetNext();
	}


	//
	// If we didn't find a place to insert the job, pBilink will point to the
	// end/beginning of the list.
	//
	pDP8SimJob->m_blList.InsertBefore(pBilink);


	//
	// If the front of the queue changed, alert the worker thread.
	//
	if (g_blJobQueue.GetNext() != pBilinkOriginalFirstItem)
	{
		DPFX(DPFPREP, 9, "Front of job queue changed, alerting worker thread.");

		//
		// Ignore error, there's nothing we can do about it.
		//
		SetEvent(g_hWorkerThreadJobEvent);
	}
	else
	{
		DPFX(DPFPREP, 9, "Front of job queue did not change.");
	}


	DNLeaveCriticalSection(&g_csJobQueueLock);


Exit:


	DPFX(DPFPREP, 5, "Returning: [0x%lx]", hr);

	return hr;


Failure:

	goto Exit;
} // AddWorkerJob





#undef DPF_MODNAME
#define DPF_MODNAME "FlushAllDelayedSendsToEndpoint"
//=============================================================================
// FlushAllDelayedSendsToEndpoint
//-----------------------------------------------------------------------------
//
// Description: Removes all delayed sends intended for the given endpoint that
//				are still queued.  If fDrop is TRUE, the messages are dropped.
//				If fDrop is FALSE, they are all submitted to the real SP.
//
// Arguments:
//	CDP8SimEndpoint * pDP8SimEndpoint	- Endpoint whose sends are to be
//											removed.
//	BOOL fDrop							- Whether to drop the sends or not.
//
// Returns: None.
//=============================================================================
void FlushAllDelayedSendsToEndpoint(CDP8SimEndpoint * const pDP8SimEndpoint,
									BOOL fDrop)
{
	CBilink			blDelayedSendJobs;
	CBilink *		pBilinkOriginalFirstItem;
	CBilink *		pBilink;
	CDP8SimJob *	pDP8SimJob;
	CDP8SimSend *	pDP8SimSend;
	CDP8SimSP *		pDP8SimSP;


	DPFX(DPFPREP, 5, "Parameters: (0x%p, %i)", pDP8SimEndpoint, fDrop);


	DNASSERT(pDP8SimEndpoint->IsValidObject());


	blDelayedSendJobs.Initialize();


	DNEnterCriticalSection(&g_csJobQueueLock);

	pBilinkOriginalFirstItem = g_blJobQueue.GetNext();
	pBilink = pBilinkOriginalFirstItem;
	while (pBilink != &g_blJobQueue)
	{
		pDP8SimJob = DP8SIMJOB_FROM_BILINK(pBilink);
		DNASSERT(pDP8SimJob->IsValidObject());

		pBilink = pBilink->GetNext();

		//
		// See if the job is a delayed send.
		//
		if (pDP8SimJob->GetJobType() == DP8SIMJOBTYPE_DELAYEDSEND)
		{
			pDP8SimSend = (CDP8SimSend*) pDP8SimJob->GetContext();
			DNASSERT(pDP8SimSend->IsValidObject());

			//
			// See if the delayed send is for the right endpoint.
			//
			if (pDP8SimSend->GetEndpoint() == pDP8SimEndpoint)
			{
				//
				// Pull the job out of the queue.
				//
				pDP8SimJob->m_blList.RemoveFromList();


				//
				// Place it on the temporary list.
				//
				pDP8SimJob->m_blList.InsertBefore(&blDelayedSendJobs);
			}
			else
			{
				//
				// Not intended for the given endpoint.
				//
			}
		}
		else
		{
			//
			// Not a delayed send.
			//
		}
	}


	//
	// If the front of the queue changed, alert the worker thread.
	//
	if (g_blJobQueue.GetNext() != pBilinkOriginalFirstItem)
	{
		DPFX(DPFPREP, 9, "Front of job queue changed, alerting worker thread.");
		SetEvent(g_hWorkerThreadJobEvent);
	}
	else
	{
		DPFX(DPFPREP, 9, "Front of job queue did not change.");
	}

	
	DNLeaveCriticalSection(&g_csJobQueueLock);


	//
	// Now actually drop or transmit those messages.
	//
	pBilink = blDelayedSendJobs.GetNext();
	while (pBilink != &blDelayedSendJobs)
	{
		pDP8SimJob = DP8SIMJOB_FROM_BILINK(pBilink);
		DNASSERT(pDP8SimJob->IsValidObject());
		pBilink = pBilink->GetNext();


		//
		// Pull the job out of the temporary list.
		//
		pDP8SimJob->m_blList.RemoveFromList();


		pDP8SimSend = (CDP8SimSend*) pDP8SimJob->GetContext();
		pDP8SimSP = pDP8SimJob->GetDP8SimSP();
		DNASSERT(pDP8SimSP != NULL);

		//
		// Either drop the data on the floor or submit it.
		//
		if (fDrop)
		{
			//
			// Remove the send counter.
			//
			pDP8SimSP->DecSendsPending();

			DPFX(DPFPREP, 7, "Releasing cancelled send 0x%p.", pDP8SimSend);
			pDP8SimSend->Release();
		}
		else
		{
			//
			// Transmit the message.
			//
			pDP8SimSP->PerformDelayedSend(pDP8SimSend);
		}


		//
		// Release the job object.
		//
		DPFX(DPFPREP, 7, "Returning job object 0x%p to pool.", pDP8SimJob);
		g_pFPOOLJob->Release(pDP8SimJob);
	}


	DNASSERT(blDelayedSendJobs.IsEmpty());


	DPFX(DPFPREP, 5, "Leave");
} // FlushAllDelayedSendsToEndpoint





#undef DPF_MODNAME
#define DPF_MODNAME "FlushAllDelayedReceivesFromEndpoint"
//=============================================================================
// FlushAllDelayedReceivesFromEndpoint
//-----------------------------------------------------------------------------
//
// Description: Removes all data received from the given endpoint that has not
//				been indicated yet.  If fDrop is TRUE, the messages are
//				dropped. If fDrop is FALSE, they are all indicated to the
//				upper layer.
//
// Arguments:
//	CDP8SimEndpoint * pDP8SimEndpoint	- Endpoint whose receives are to be
//											removed.
//	BOOL fDrop							- Whether to drop the receives or not.
//
// Returns: None.
//=============================================================================
void FlushAllDelayedReceivesFromEndpoint(CDP8SimEndpoint * const pDP8SimEndpoint,
										BOOL fDrop)
{
	HRESULT				hr;
	CBilink				blDelayedReceiveJobs;
	CBilink *			pBilinkOriginalFirstItem;
	CBilink *			pBilink;
	CDP8SimJob *		pDP8SimJob;
	CDP8SimReceive *	pDP8SimReceive;
	CDP8SimSP *			pDP8SimSP;
	SPIE_DATA *			pData;


	DPFX(DPFPREP, 5, "Parameters: (0x%p, %i)", pDP8SimEndpoint, fDrop);


	DNASSERT(pDP8SimEndpoint->IsValidObject());


	blDelayedReceiveJobs.Initialize();


	DNEnterCriticalSection(&g_csJobQueueLock);

	pBilinkOriginalFirstItem = g_blJobQueue.GetNext();
	pBilink = pBilinkOriginalFirstItem;
	while (pBilink != &g_blJobQueue)
	{
		pDP8SimJob = DP8SIMJOB_FROM_BILINK(pBilink);
		DNASSERT(pDP8SimJob->IsValidObject());

		pBilink = pBilink->GetNext();

		//
		// See if the job is a delayed receive.
		//
		if (pDP8SimJob->GetJobType() == DP8SIMJOBTYPE_DELAYEDRECEIVE)
		{
			pDP8SimReceive = (CDP8SimReceive*) pDP8SimJob->GetContext();
			DNASSERT(pDP8SimReceive->IsValidObject());

			//
			// See if the delayed receive is for the right endpoint.
			//
			if (pDP8SimReceive->GetEndpoint() == pDP8SimEndpoint)
			{
				//
				// Pull the job out of the queue.
				//
				pDP8SimJob->m_blList.RemoveFromList();


				//
				// Place it on the temporary list.
				//
				pDP8SimJob->m_blList.InsertBefore(&blDelayedReceiveJobs);
			}
			else
			{
				//
				// Not intended for the given endpoint.
				//
			}
		}
		else
		{
			//
			// Not a delayed receive.
			//
		}
	}


	//
	// If the front of the queue changed, alert the worker thread.
	//
	if (g_blJobQueue.GetNext() != pBilinkOriginalFirstItem)
	{
		DPFX(DPFPREP, 9, "Front of job queue changed, alerting worker thread.");
		SetEvent(g_hWorkerThreadJobEvent);
	}
	else
	{
		DPFX(DPFPREP, 9, "Front of job queue did not change.");
	}

	
	DNLeaveCriticalSection(&g_csJobQueueLock);


	//
	// Now actually drop or transmit those messages.
	//
	pBilink = blDelayedReceiveJobs.GetNext();
	while (pBilink != &blDelayedReceiveJobs)
	{
		pDP8SimJob = DP8SIMJOB_FROM_BILINK(pBilink);
		DNASSERT(pDP8SimJob->IsValidObject());
		pBilink = pBilink->GetNext();


		//
		// Pull the job out of the temporary list.
		//
		pDP8SimJob->m_blList.RemoveFromList();


		pDP8SimReceive = (CDP8SimReceive*) pDP8SimJob->GetContext();
		pDP8SimSP = pDP8SimJob->GetDP8SimSP();
		DNASSERT(pDP8SimSP != NULL);


		//
		// Either drop the data on the floor or submit it.
		//
		if (fDrop)
		{
			pData = pDP8SimReceive->GetReceiveDataBlockPtr();


			DPFX(DPFPREP, 8, "Returning receive data 0x%p (wrapper object 0x%p).",
				pData->pReceivedData, pDP8SimSP);


			hr = pDP8SimSP->ReturnReceiveBuffers(pData->pReceivedData);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Failed returning receive buffers 0x%p (err = 0x%lx)!  Ignoring.",
					pData->pReceivedData, hr);

				//
				// Ignore failure.
				//
			}


			//
			// Remove the receive counter.
			//
			pDP8SimSP->DecReceivesPending();

			
			DPFX(DPFPREP, 7, "Releasing cancelled receive 0x%p.", pDP8SimReceive);
			pDP8SimReceive->Release();
		}
		else
		{
			//
			// Indicate the message.
			//
			pDP8SimSP->PerformDelayedReceive(pDP8SimReceive);
		}


		//
		// Release the job object.
		//
		DPFX(DPFPREP, 7, "Returning job object 0x%p to pool.", pDP8SimJob);
		g_pFPOOLJob->Release(pDP8SimJob);
	}


	DNASSERT(blDelayedReceiveJobs.IsEmpty());


	DPFX(DPFPREP, 5, "Leave");
} // FlushAllDelayedReceivesFromEndpoint






#undef DPF_MODNAME
#define DPF_MODNAME "DP8SimWorkerThreadProc"
//=============================================================================
// DP8SimWorkerThreadProc
//-----------------------------------------------------------------------------
//
// Description: The global worker thread function.
//
// Arguments:
//	PVOID pvParameter	- Thread parameter.  Ignored.
//
// Returns: 0 if all goes well.
//=============================================================================
DWORD DP8SimWorkerThreadProc(PVOID pvParameter)
{
	DWORD			dwReturn;
	DWORD			dwWaitTimeout = INFINITE;
	BOOL			fRunning = TRUE;
	BOOL			fFoundJob;
	DWORD			dwCurrentTime;
	CBilink *		pBilink;
	CDP8SimJob *	pDP8SimJob;
	CDP8SimSP *		pDP8SimSP;


	DPFX(DPFPREP, 5, "Parameters: (0x%p)", pvParameter);


	//
	// Keep looping until we're told to quit.
	//
	do
	{
		//
		// Wait for the next job.
		//
		dwReturn = WaitForSingleObject(g_hWorkerThreadJobEvent, dwWaitTimeout);
		switch (dwReturn)
		{
			case WAIT_OBJECT_0:
			case WAIT_TIMEOUT:
			{
				//
				// There's a change in the job queue or a timer expired.  See
				// if it's time to execute something.
				//

				//
				// Keep looping while we have jobs to perform now.
				//
				do
				{
					fFoundJob = FALSE;


					//
					// Take the lock while we look at the list.
					//
					DNEnterCriticalSection(&g_csJobQueueLock);


					pBilink = g_blJobQueue.GetNext();
					if (pBilink != &g_blJobQueue)
					{
						pDP8SimJob = DP8SIMJOB_FROM_BILINK(pBilink);
						DNASSERT(pDP8SimJob->IsValidObject());

						dwCurrentTime = timeGetTime();


						//
						// If the timer has expired, pull the job from the list
						// and execute it.
						//
						if ((int) (pDP8SimJob->GetTime() - dwCurrentTime) <= 0)
						{
							pDP8SimJob->m_blList.RemoveFromList();


							//
							// Drop the list lock.
							//
							DNLeaveCriticalSection(&g_csJobQueueLock);
							

							pDP8SimSP = pDP8SimJob->GetDP8SimSP();


							DPFX(DPFPREP, 8, "Job 0x%p has expired (job time = %u, current time = %u, type = %u, context 0x%p, interface = 0x%p).",
								pDP8SimJob, pDP8SimJob->GetTime(), dwCurrentTime,
								pDP8SimJob->GetJobType(), pDP8SimJob->GetContext(),
								pDP8SimSP);


							//
							// Figure out what to do with the job.
							//
							switch (pDP8SimJob->GetJobType())
							{
								case DP8SIMJOBTYPE_DELAYEDSEND:
								{
									//
									// Finally submit the send.
									//
									DNASSERT(pDP8SimSP != NULL);
									pDP8SimSP->PerformDelayedSend(pDP8SimJob->GetContext());
									break;
								}

								case DP8SIMJOBTYPE_DELAYEDRECEIVE:
								{
									//
									// Finally indicate the receive.
									//
									DNASSERT(pDP8SimSP != NULL);
									pDP8SimSP->PerformDelayedReceive(pDP8SimJob->GetContext());
									break;
								}

								case DP8SIMJOBTYPE_QUIT:
								{
									//
									// Stop looping.
									//
									DNASSERT(pDP8SimSP == NULL);
									DPFX(DPFPREP, 2, "Quit job received.");
									fRunning = FALSE;
									break;
								}

								default:
								{
									DPFX(DPFPREP, 0, "Unexpected job type %u!",
										pDP8SimJob->GetJobType());
									DNASSERT(FALSE); 
									fRunning = FALSE;
									break;
								}
							}


							//
							// Release the job object.
							//
							DPFX(DPFPREP, 7, "Returning job object 0x%p to pool.", pDP8SimJob);
							g_pFPOOLJob->Release(pDP8SimJob);


							//
							// Check out the next job (unless we're bailing).
							//
							fFoundJob = fRunning;
						}
						else
						{
							//
							// Not time for job yet.  Figure out when it will
							// be.
							//
							dwWaitTimeout = pDP8SimJob->GetTime() - dwCurrentTime;


							//
							// Drop the list lock.
							//
							DNLeaveCriticalSection(&g_csJobQueueLock);


							DPFX(DPFPREP, 8, "Next job in %u ms.", dwWaitTimeout);
						}
					}
					else
					{
						//
						// Nothing in the job queue.  Drop the list lock.
						//
						DNLeaveCriticalSection(&g_csJobQueueLock);

						//
						// Wait until something gets put into the queue.
						//
						dwWaitTimeout = INFINITE;


						DPFX(DPFPREP, 8, "No more jobs.");
					}
				}
				while (fFoundJob);


				//
				// Go back to waiting.
				//
				break;
			}

			default:
			{
				//
				// Something unusual happened.
				//
				DPFX(DPFPREP, 0, "Got unexpected return value from WaitForSingleObject (%u)!");
				DNASSERT(FALSE);
				fRunning = FALSE;
				break;
			}
		}
	}
	while (fRunning);



	DPFX(DPFPREP, 5, "Returning: [%u]", dwReturn);


	return dwReturn;
} // DP8SimWorkerThreadProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=dp8sim
DLLDEF=..\dp8sim.def
UMTYPE=windows

#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=DYNLINK

!if "$(DPLAY_PCH)" != "off"
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dp8simi.h
PRECOMPILED_PCH=dp8simi.pch
PRECOMPILED_OBJ=dp8simi.obj
!endif

#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#

#
# 04/10/2000 - allows for addition of BoundsChecker, etc
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           ..\..\guids\obj$(BUILD_ALT_DIR)\*\guids.lib \
           ..\..\..\..\dnet\common\obj$(BUILD_ALT_DIR)\*\common.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib \
	   $(BASEDIR)\public\sdk\lib\*\oleaut32.lib \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib


#
# If a debug mode is selected, make sure we include the defines to make the
# logging code operate.
#
!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif


#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=$(DXROOT)\inc;..\..\..\..\dnet\inc;..\..\..\..\dnet\common;..\..\inc;..\


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= ..\dp8sim.rc \
	 ..\dp8simclassfac.cpp \
	 ..\dp8simdllmain.cpp \
	 ..\dp8simpools.cpp \
	 ..\controlobj.cpp \
	 ..\dp8simipc.cpp \
	 ..\dp8simworkerthread.cpp \
	 ..\spcallbackobj.cpp \
	 ..\spwrapper.cpp


#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /D_DLL

USE_NOLIBS=1

DLLENTRY=_DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\dp8simworkerthread.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simworkerthread.h
 *
 *  Content:	Header for DP8SIM worker thread functions.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/


//=============================================================================
// Job types
//=============================================================================
#define DP8SIMJOBTYPE_DELAYEDSEND		1	// submits a send
#define DP8SIMJOBTYPE_DELAYEDRECEIVE	2	// indicates a receive
#define DP8SIMJOBTYPE_QUIT				3	// stops the worker thread




//=============================================================================
// Functions
//=============================================================================
HRESULT StartGlobalWorkerThread(void);

void StopGlobalWorkerThread(void);


HRESULT AddWorkerJob(const DWORD dwDelay,
					const DWORD dwJobType,
					PVOID const pvContext,
					CDP8SimSP * const pDP8SimSP,
					const BOOL fDelayFromPreviousJob);


void FlushAllDelayedSendsToEndpoint(CDP8SimEndpoint * const pDP8SimEndpoint,
									BOOL fDrop);

void FlushAllDelayedReceivesFromEndpoint(CDP8SimEndpoint * const pDP8SimEndpoint,
										BOOL fDrop);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\spcallbackobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       spcallbackobj.h
 *
 *  Content:	Header for DP8SIM callback interface object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/




//=============================================================================
// Macros
//=============================================================================
#ifndef	OFFSETOF
#define OFFSETOF(s,m)								( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)					(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

#define ENUMQUERYEVENTWRAPPER_FROM_SPIEQUERY(p)		(CONTAINING_OBJECT(p, ENUMQUERYDATAWRAPPER, QueryForUser))



//=============================================================================
// Structures
//=============================================================================
typedef struct _ENUMQUERYEVENTWRAPPER
{
	BYTE			m_Sig[4];		// debugging signature ('EQEW')
	SPIE_QUERY		QueryForUser;	// new event indication structure to be passed up to user
	SPIE_QUERY *	pOriginalQuery;	// pointer to real SP's original event indication structure
} ENUMQUERYDATAWRAPPER, * PENUMQUERYDATAWRAPPER;




//=============================================================================
// Callback interface object class
//=============================================================================
class CDP8SimCB : public IDP8SPCallback
{
	public:
		CDP8SimCB(CDP8SimSP * pOwningDP8SimSP, IDP8SPCallback * pDP8SPCB);	// constructor
		~CDP8SimCB(void);													// destructor


		STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

		STDMETHODIMP_(ULONG) AddRef(void);

		STDMETHODIMP_(ULONG) Release(void);


		STDMETHODIMP IndicateEvent(SP_EVENT_TYPE EventType, PVOID pvMessage);

		STDMETHODIMP CommandComplete(HANDLE hCommand, HRESULT hrResult, PVOID pvContext);



		HRESULT InitializeObject(void);

		void UninitializeObject(void);


		inline IDP8SPCallback * GetRealCallbackInterface(void)	{ return this->m_pDP8SPCB; };


	private:
		BYTE				m_Sig[4];			// debugging signature ('SPCB')
		LONG				m_lRefCount;		// reference count for this object
		DNCRITICAL_SECTION	m_csLock;			// lock preventing simultaneous usage of globals
		CDP8SimSP *			m_pOwningDP8SimSP;	// pointer to owing DP8SimSP object
		IDP8SPCallback *	m_pDP8SPCB;			// pointer to real DPlay callback interface



		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimCB))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x42435053)	// 0x42 0x43 0x50 0x53 = 'BCPS' = 'SPCB' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\spcallbackobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		spcallbackobj.cpp
 *
 *  Content:	DP8SIM callback interface object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::CDP8SimCB"
//=============================================================================
// CDP8SimCB constructor
//-----------------------------------------------------------------------------
//
// Description: Initializes the new CDP8SimCB object.
//
// Arguments:
//	CDP8SimSP * pOwningDP8SimSP		- Pointer to owning CDP8SimSP object.
//	IDP8SPCallback * pDP8SPCB		- Pointer to real DPlay callback interface
//										being intercepted.
//
// Returns: None (the object).
//=============================================================================
CDP8SimCB::CDP8SimCB(CDP8SimSP * pOwningDP8SimSP, IDP8SPCallback * pDP8SPCB)
{
	this->m_Sig[0]	= 'S';
	this->m_Sig[1]	= 'P';
	this->m_Sig[2]	= 'C';
	this->m_Sig[3]	= 'B';

	this->m_lRefCount			= 1; // someone must have a pointer to this object

	pOwningDP8SimSP->AddRef();
	this->m_pOwningDP8SimSP		= pOwningDP8SimSP;

	pDP8SPCB->AddRef();
	this->m_pDP8SPCB			= pDP8SPCB;
} // CDP8SimCB::CDP8SimCB






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::~CDP8SimCB"
//=============================================================================
// CDP8SimCB destructor
//-----------------------------------------------------------------------------
//
// Description: Frees the CDP8SimCB object.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
CDP8SimCB::~CDP8SimCB(void)
{
	DNASSERT(this->m_lRefCount == 0);


	this->m_pOwningDP8SimSP->Release();
	this->m_pOwningDP8SimSP = NULL;

	this->m_pDP8SPCB->Release();
	this->m_pDP8SPCB = NULL;


	//
	// For grins, change the signature before deleting the object.
	//
	this->m_Sig[3]	= 'b';
} // CDP8SimCB::~CDP8SimCB




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::QueryInterface"
//=============================================================================
// CDP8SimCB::QueryInterface
//-----------------------------------------------------------------------------
//
// Description: Retrieves a new reference for an interfaces supported by this
//				CDP8SimCB object.
//
// Arguments:
//	REFIID riid			- Reference to interface ID GUID.
//	LPVOID * ppvObj		- Place to store pointer to object.
//
// Returns: HRESULT
//	S_OK					- Returning a valid interface pointer.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPOINTER	- The destination pointer is invalid.
//	E_NOINTERFACE			- Invalid interface was specified.
//=============================================================================
STDMETHODIMP CDP8SimCB::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	HRESULT		hr = DPN_OK;


	DPFX(DPFPREP, 3, "(0x%p) Parameters: (REFIID, 0x%p)", this, ppvObj);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DP8Sim object!");
		hr = DPNERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if ((! IsEqualIID(riid, IID_IUnknown)) &&
		(! IsEqualIID(riid, IID_IDP8SPCallback)))
	{
		DPFX(DPFPREP, 0, "Unsupported interface!");
		hr = E_NOINTERFACE;
		goto Failure;
	}

	if ((ppvObj == NULL) ||
		(IsBadWritePtr(ppvObj, sizeof(void*))))
	{
		DPFX(DPFPREP, 0, "Invalid interface pointer specified!");
		hr = DPNERR_INVALIDPOINTER;
		goto Failure;
	}


	//
	// Add a reference, and return the interface pointer (which is actually
	// just the object pointer, they line up because CDP8SimCB inherits from
	// the interface declaration).
	//
	this->AddRef();
	(*ppvObj) = this;


Exit:

	DPFX(DPFPREP, 3, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimCB::QueryInterface




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::AddRef"
//=============================================================================
// CDP8SimCB::AddRef
//-----------------------------------------------------------------------------
//
// Description: Adds a reference to this CDP8SimCB object.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CDP8SimCB::AddRef(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());


	//
	// There must be at least 1 reference to this object, since someone is
	// calling AddRef.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedIncrement(&this->m_lRefCount);

	DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);

	return lRefCount;
} // CDP8SimCB::AddRef




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::Release"
//=============================================================================
// CDP8SimCB::Release
//-----------------------------------------------------------------------------
//
// Description: Removes a reference to this CDP8SimCB object.  When the
//				refcount reaches 0, this object is destroyed.
//				You must NULL out your pointer to this object after calling
//				this function.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CDP8SimCB::Release(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());

	//
	// There must be at least 1 reference to this object, since someone is
	// calling Release.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedDecrement(&this->m_lRefCount);

	//
	// Was that the last reference?  If so, we're going to destroy this object.
	//
	if (lRefCount == 0)
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount hit 0, destroying object.", this);


		//
		// Uninitialize the object.
		//
		this->UninitializeObject();

		//
		// Finally delete this (!) object.
		//
		delete this;
	}
	else
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);
	}

	return lRefCount;
} // CDP8SimCB::Release




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::IndicateEvent"
//=============================================================================
// CDP8SimCB::IndicateEvent
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	SP_EVENT_TYPE EventType		- Event being indicated.
//	PVOID pvMessage				- Event specific message.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimCB::IndicateEvent(SP_EVENT_TYPE EventType, PVOID pvMessage)
{
	HRESULT				hr;
	CDP8SimEndpoint *	pDP8SimEndpoint;
	CDP8SimCommand *	pDP8SimCommand;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (%u, 0x%p)", this, EventType, pvMessage);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Switch on the type of event being indicated.
	//
	switch (EventType)
	{
		case SPEV_DATA:
		{
			SPIE_DATA *			pData;
			DP8SIM_PARAMETERS	dp8sp;
			SPIE_DATA			DataModified;
			CDP8SimReceive *	pDP8SimReceive;
			DWORD				dwLatency;


			pData = (SPIE_DATA*) pvMessage;


			DNASSERT(pData->pReceivedData->pNext == NULL);


			pDP8SimEndpoint = (CDP8SimEndpoint*) pData->pEndpointContext;
			DNASSERT(pDP8SimEndpoint->IsValidObject());


			//
			// If the endpoint is disconnecting, drop the receive.
			//
			pDP8SimEndpoint->Lock();
			if (pDP8SimEndpoint->IsDisconnecting())
			{
				pDP8SimEndpoint->Unlock();

				DPFX(DPFPREP, 1, "Endpoint 0x%p is disconnecting, dropping receive.",
					pDP8SimEndpoint);

				hr = DPN_OK;
			}
			else
			{
				pDP8SimEndpoint->Unlock();


				//
				// Get the current receive settings.
				//
				ZeroMemory(&dp8sp, sizeof(dp8sp));
				dp8sp.dwSize = sizeof(dp8sp);
				this->m_pOwningDP8SimSP->GetAllReceiveParameters(&dp8sp);


				//
				// Determine if we need to drop this receive.
				//
				if (this->m_pOwningDP8SimSP->ShouldDrop(dp8sp.dwPacketLossPercent))
				{
					DPFX(DPFPREP, 2, "Dropping %u bytes of data from endpoint 0x%p.",
						pData->pReceivedData->BufferDesc.dwBufferSize, pDP8SimEndpoint);


					//
					// Update the statistics.
					//
					this->m_pOwningDP8SimSP->IncrementStatReceiveDropped();


					//
					// Let the SP reclaim the buffer.
					//
					hr = DPN_OK;
				}
				else
				{
					//
					// Figure out how much latency needs to be added based on
					// the bandwidth and random latency settings.
					//
					dwLatency = this->m_pOwningDP8SimSP->GetLatency(dp8sp.dwBandwidthBPS,
																	pData->pReceivedData->BufferDesc.dwBufferSize,
																	dp8sp.dwMinLatencyMS,
																	dp8sp.dwMaxLatencyMS);


					//
					// If we're not supposed to delay the receives, indicate it
					// now.  Otherwise submit a timed job to be performed
					// later.
					//
					if (dwLatency == 0)
					{
						//
						// Modify the message before indicating to the caller.
						//

						ZeroMemory(&DataModified, sizeof(DataModified));
						DataModified.hEndpoint			= (HANDLE) pDP8SimEndpoint;
						DataModified.pEndpointContext	= pDP8SimEndpoint->GetUserContext();
						DataModified.pReceivedData		= pData->pReceivedData;


						//
						// Indicate the event to the real callback interface.
						//

						DPFX(DPFPREP, 2, "Indicating event SPEV_DATA (message = 0x%p, data size = %u) to interface 0x%p.",
							pData, pData->pReceivedData->BufferDesc.dwBufferSize,
							this->m_pDP8SPCB);

						hr = this->m_pDP8SPCB->IndicateEvent(SPEV_DATA, &DataModified);

						DPFX(DPFPREP, 2, "Returning from event SPEV_DATA [0x%lx].", hr);


						//
						// Update the statistics.
						//
						this->m_pOwningDP8SimSP->IncrementStatReceiveTransmitted();
					}
					else
					{
						DPFX(DPFPREP, 6, "Delaying %u byte receive for %u ms.",
							pData->pReceivedData->BufferDesc.dwBufferSize, dwLatency);


						//
						// Get a receive object, duplicating the received data
						// structure given to us by our caller for indication
						// some time in the future.
						//
						pDP8SimReceive = g_pFPOOLReceive->Get(pData);
						if (pDP8SimReceive == NULL)
						{
							hr = DPNERR_OUTOFMEMORY;
						}
						else
						{
							DPFX(DPFPREP, 7, "New delayed receive 0x%p.", pDP8SimReceive);

							
							//
							// Transfer local pDP8SimReceive reference to the
							// job queue.
							//


							//
							// Increment the receive counter.
							//
							this->m_pOwningDP8SimSP->IncReceivesPending();


							//
							// Queue it to be indicated at a later time,
							// depending on the latency value requested.
							//
							hr = AddWorkerJob(dwLatency,
											DP8SIMJOBTYPE_DELAYEDRECEIVE,
											pDP8SimReceive,
											this->m_pOwningDP8SimSP,
											TRUE);
							if (hr != DPN_OK)
							{
								DPFX(DPFPREP, 0, "Couldn't add delayed receive worker job (0x%p)!", 
									pDP8SimReceive);


								//
								// Remove the receive counter.
								//
								this->m_pOwningDP8SimSP->DecReceivesPending();


								//
								// Release the delayed receive reference.
								//
								DPFX(DPFPREP, 7, "Releasing aborted delayed receive 0x%p.", pDP8SimReceive);
								pDP8SimReceive->Release();
								pDP8SimReceive = NULL;
							}
							else
							{
								//
								// Let the real SP know that we're keeping the
								// buffer.
								//
								hr = DPNSUCCESS_PENDING;
							}
						} // end else (successfully got receive object)
					} // end else (delaying receives)
				} // end else (not dropping receive)
			} // end else (endpoint is not disconnecting yet)
			break;
		}

		case SPEV_CONNECT:
		{
			SPIE_CONNECT *	pConnect;
			SPIE_CONNECT	ConnectModified;


			pConnect = (SPIE_CONNECT*) pvMessage;


			pDP8SimCommand = (CDP8SimCommand*) pConnect->pCommandContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT((pDP8SimCommand->GetType() == CMDTYPE_CONNECT) || (pDP8SimCommand->GetType() == CMDTYPE_LISTEN));


			//
			// Get a new endpoint object from the pool.
			//
			pDP8SimEndpoint = g_pFPOOLEndpoint->Get(pConnect->hEndpoint);
			if (pDP8SimEndpoint == NULL)
			{
				hr = DPNERR_OUTOFMEMORY;
			}
			else
			{
				DPFX(DPFPREP, 7, "New %s endpoint 0x%p.",
					((pDP8SimCommand->GetType() == CMDTYPE_CONNECT) ? "outbound" : "inbound"),
					pDP8SimEndpoint);


				//
				// Modify the message before indicating to the caller.
				//

				ZeroMemory(&ConnectModified, sizeof(ConnectModified));
				ConnectModified.hEndpoint			= (HANDLE) pDP8SimEndpoint;
				//ConnectModified.pEndpointContext	= NULL;									// the user fills this in
				ConnectModified.pCommandContext		= pDP8SimCommand->GetUserContext();


				//
				// Indicate the event to the real callback interface.
				//

				DPFX(DPFPREP, 2, "Indicating event SPEV_CONNECT (message = 0x%p) to interface 0x%p.",
					&ConnectModified, this->m_pDP8SPCB);

				hr = this->m_pDP8SPCB->IndicateEvent(SPEV_CONNECT, &ConnectModified);

				DPFX(DPFPREP, 2, "Returning from event SPEV_CONNECT [0x%lx].", hr);


				if (hr == DPN_OK)
				{
					//
					// Update the endpoint context with what the user returned.
					//
					pDP8SimEndpoint->SetUserContext(ConnectModified.pEndpointContext);

					//
					// Return our endpoint context.
					//
					pConnect->pEndpointContext = pDP8SimEndpoint;
				}
				else
				{
					//
					// Release the endpoint reference.
					//
					DPFX(DPFPREP, 7, "Releasing aborted endpoint 0x%p.", pDP8SimEndpoint);
					pDP8SimEndpoint->Release();
					pDP8SimEndpoint = NULL;
				}
			}

			break;
		}

		case SPEV_DISCONNECT:
		{
			SPIE_DISCONNECT *	pDisconnect;
			SPIE_DISCONNECT		DisconnectModified;


			pDisconnect = (SPIE_DISCONNECT*) pvMessage;


			pDP8SimEndpoint = (CDP8SimEndpoint*) pDisconnect->pEndpointContext;
			DNASSERT(pDP8SimEndpoint->IsValidObject());


			//
			// Mark the endpoint as disconnecting to prevent additional sends
			// or receives.
			//
			pDP8SimEndpoint->Lock();
			pDP8SimEndpoint->NoteDisconnecting();
			pDP8SimEndpoint->Unlock();


			//
			// Modify the message before indicating to the caller.
			//

			ZeroMemory(&DisconnectModified, sizeof(DisconnectModified));
			DisconnectModified.hEndpoint			= (HANDLE) pDP8SimEndpoint;
			DisconnectModified.pEndpointContext		= pDP8SimEndpoint->GetUserContext();

	
			//
			// Quickly indicate any delayed receives from this endpoint that
			// are still pending.
			//
			FlushAllDelayedReceivesFromEndpoint(pDP8SimEndpoint, FALSE);

			//
			// Kill off any delayed sends that would have gone to this
			// endpoint.
			//
			FlushAllDelayedSendsToEndpoint(pDP8SimEndpoint, TRUE);


			//
			// Indicate the event to the real callback interface.
			//

			DPFX(DPFPREP, 2, "Indicating event SPEV_DISCONNECT (message = 0x%p) to interface 0x%p.",
				&DisconnectModified, this->m_pDP8SPCB);

			hr = this->m_pDP8SPCB->IndicateEvent(SPEV_DISCONNECT, &DisconnectModified);

			DPFX(DPFPREP, 2, "Returning from event SPEV_DISCONNECT [0x%lx].", hr);


			//
			// Release the endpoint reference.
			//
			DPFX(DPFPREP, 7, "Releasing endpoint 0x%p.", pDP8SimEndpoint);
			pDP8SimEndpoint->Release();
			pDP8SimEndpoint = NULL;

			break;
		}


		case SPEV_LISTENSTATUS:
		{
			SPIE_LISTENSTATUS *		pListenStatus;
			SPIE_LISTENSTATUS		ListenStatusModified;


			pListenStatus = (SPIE_LISTENSTATUS*) pvMessage;


			pDP8SimCommand = (CDP8SimCommand*) pListenStatus->pUserContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_LISTEN);


			//
			// Get a new endpoint object from the pool.
			//
			pDP8SimEndpoint = g_pFPOOLEndpoint->Get(pListenStatus->hEndpoint);
			if (pDP8SimEndpoint == NULL)
			{
				hr = DPNERR_OUTOFMEMORY;
			}
			else
			{
				DPFX(DPFPREP, 7, "New listen endpoint 0x%p, adding reference for listen command.",
					pDP8SimEndpoint);

				//
				// Store an endpoint reference with the command.
				//
				pDP8SimEndpoint->AddRef();
				pDP8SimCommand->SetListenEndpoint(pDP8SimEndpoint);


				//
				// Modify the message before indicating to the caller.
				//

				ZeroMemory(&ListenStatusModified, sizeof(ListenStatusModified));
				ListenStatusModified.ListenAdapter		= pListenStatus->ListenAdapter;
				ListenStatusModified.hResult			= pListenStatus->hResult;
				ListenStatusModified.hCommand			= (HANDLE) pDP8SimCommand;
				ListenStatusModified.pUserContext		= pDP8SimCommand->GetUserContext();
				ListenStatusModified.hEndpoint			= (HANDLE) pDP8SimEndpoint;


				//
				// Indicate the event to the real callback interface.
				//

				DPFX(DPFPREP, 2, "Indicating event SPEV_LISTENSTATUS (message = 0x%p) to interface 0x%p.",
					&ListenStatusModified, this->m_pDP8SPCB);

				hr = this->m_pDP8SPCB->IndicateEvent(SPEV_LISTENSTATUS, &ListenStatusModified);

				DPFX(DPFPREP, 2, "Returning from event SPEV_LISTENSTATUS [0x%lx].", hr);


				//
				// Release the reference we got from new, since we only needed
				// it while we indicated the endpoint up to the user.  The
				// listen command object has the reference it needs.
				//
				DPFX(DPFPREP, 7, "Releasing local listen endpoint 0x%p reference.",
					pDP8SimEndpoint);
				pDP8SimEndpoint->Release();
				pDP8SimEndpoint = NULL;
			}

			break;
		}

		case SPEV_ENUMQUERY:
		{
			SPIE_QUERY *				pQuery;
			ENUMQUERYDATAWRAPPER		QueryWrapper;


			pQuery = (SPIE_QUERY*) pvMessage;

			DNASSERT(pQuery->pAddressSender != NULL);
			DNASSERT(pQuery->pAddressDevice != NULL);


			pDP8SimCommand = (CDP8SimCommand*) pQuery->pUserContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_LISTEN);


			//
			// Modify the message before indicating to the caller.  We need a
			// wrapper so that ProxyEnumQuery can parse back out the original
			// query data pointer.
			//

			ZeroMemory(&QueryWrapper, sizeof(QueryWrapper));
			QueryWrapper.m_Sig[0]	= 'E';
			QueryWrapper.m_Sig[1]	= 'Q';
			QueryWrapper.m_Sig[2]	= 'E';
			QueryWrapper.m_Sig[3]	= 'W';

			QueryWrapper.pOriginalQuery = pQuery;

			/*
			hr = pQuery->pAddressSender->Duplicate(&QueryWrapper.QueryForUser.pAddressSender);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't duplicate enum query sender's address!");
			}
			else
			{
				hr = QueryWrapper.QueryForUser.pAddressSender->SetSP(&CLSID_DP8SP_DP8SIM);
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't change enum query sender's address' SP!");
				}
				else
				{
					hr = pQuery->pAddressDevice->Duplicate(&QueryWrapper.QueryForUser.pAddressDevice);
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't duplicate enum query device address!");
					}
					else
					{
						hr = QueryWrapper.QueryForUser.pAddressDevice->SetSP(&CLSID_DP8SP_DP8SIM);
						if (hr != DPN_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't change enum query device address' SP!");
						}
						else
						{
			*/
			QueryWrapper.QueryForUser.pAddressSender				= pQuery->pAddressSender;
			QueryWrapper.QueryForUser.pAddressDevice				= pQuery->pAddressDevice;
							QueryWrapper.QueryForUser.pReceivedData	= pQuery->pReceivedData;
							QueryWrapper.QueryForUser.pUserContext	= pDP8SimCommand->GetUserContext();


							//
							// Indicate the event to the real callback interface.
							//

							DPFX(DPFPREP, 2, "Indicating SPEV_ENUMQUERY (message = 0x%p) to interface 0x%p.",
								&QueryWrapper.QueryForUser, this->m_pDP8SPCB);

							hr = this->m_pDP8SPCB->IndicateEvent(SPEV_ENUMQUERY, &QueryWrapper.QueryForUser);

							DPFX(DPFPREP, 2, "Returning from SPEV_ENUMQUERY [0x%lx].", hr);
			/*
						}

						QueryWrapper.QueryForUser.pAddressDevice->Release();
						QueryWrapper.QueryForUser.pAddressDevice = NULL;
					}
				}

				QueryWrapper.QueryForUser.pAddressSender->Release();
				QueryWrapper.QueryForUser.pAddressSender = NULL;
			}
			*/
			break;
		}

		case SPEV_QUERYRESPONSE:
		{
			SPIE_QUERYRESPONSE *	pQueryResponse;
			SPIE_QUERYRESPONSE		QueryResponseModified;


			pQueryResponse = (SPIE_QUERYRESPONSE*) pvMessage;

			DNASSERT(pQueryResponse->pAddressSender != NULL);
			DNASSERT(pQueryResponse->pAddressDevice != NULL);


			pDP8SimCommand = (CDP8SimCommand*) pQueryResponse->pUserContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_ENUMQUERY);


			//
			// Modify the message before indicating to the caller.
			//

			ZeroMemory(&QueryResponseModified, sizeof(QueryResponseModified));

			/*
			hr = pQueryResponse->pAddressSender->Duplicate(&QueryResponseModified.pAddressSender);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't duplicate query response sender's address!");
			}
			else
			{
				hr = QueryResponseModified.pAddressSender->SetSP(&CLSID_DP8SP_DP8SIM);
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't change query response sender's address' SP!");
				}
				else
				{
					hr = pQueryResponse->pAddressDevice->Duplicate(&QueryResponseModified.pAddressDevice);
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't duplicate query response device address!");
					}
					else
					{
						hr = QueryResponseModified.pAddressDevice->SetSP(&CLSID_DP8SP_DP8SIM);
						if (hr != DPN_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't change query response device address' SP!");
						}
						else
						{
			*/
			QueryResponseModified.pAddressSender					= pQueryResponse->pAddressSender;
			QueryResponseModified.pAddressDevice					= pQueryResponse->pAddressDevice;
							QueryResponseModified.pReceivedData		= pQueryResponse->pReceivedData;
							QueryResponseModified.dwRoundTripTime	= pQueryResponse->dwRoundTripTime;
							QueryResponseModified.pUserContext		= pDP8SimCommand->GetUserContext();


							//
							// Indicate the event to the real callback interface.
							//

							DPFX(DPFPREP, 2, "Indicating SPEV_QUERYRESPONSE (message = 0x%p) to interface 0x%p.",
								&QueryResponseModified, this->m_pDP8SPCB);

							hr = this->m_pDP8SPCB->IndicateEvent(SPEV_QUERYRESPONSE, &QueryResponseModified);

							DPFX(DPFPREP, 2, "Returning from SPEV_QUERYRESPONSE [0x%lx].", hr);
			/*
						}

						QueryResponseModified.pAddressDevice->Release();
						QueryResponseModified.pAddressDevice = NULL;
					}
				}

				QueryResponseModified.pAddressSender->Release();
				QueryResponseModified.pAddressSender = NULL;
			}
			*/
			break;
		}

		case SPEV_LISTENADDRESSINFO:
		{
			SPIE_LISTENADDRESSINFO *	pListenAddressInfo;
			SPIE_LISTENADDRESSINFO		ListenAddressInfoModified;


			pListenAddressInfo = (SPIE_LISTENADDRESSINFO*) pvMessage;

			DNASSERT(pListenAddressInfo->pDeviceAddress != NULL);


			pDP8SimCommand = (CDP8SimCommand*) pListenAddressInfo->pCommandContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_LISTEN);


			//
			// Modify the message before indicating to the caller.
			//

			ZeroMemory(&ListenAddressInfoModified, sizeof(ListenAddressInfoModified));

			/*
			hr = pListenAddressInfo->pDeviceAddress->Duplicate(&ListenAddressInfoModified.pDeviceAddress);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't duplicate listen address info device address!");
			}
			else
			{
				hr = ListenAddressInfoModified.pDeviceAddress->SetSP(&CLSID_DP8SP_DP8SIM);
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't change listen address info device address' SP!");
				}
				else
				{
			*/
			ListenAddressInfoModified.pDeviceAddress			= pListenAddressInfo->pDeviceAddress;
					ListenAddressInfoModified.hCommandStatus	= pListenAddressInfo->hCommandStatus;
					ListenAddressInfoModified.pCommandContext	= pDP8SimCommand->GetUserContext();


					//
					// Indicate the event to the real callback interface.
					//

					DPFX(DPFPREP, 2, "Indicating SPEV_LISTENADDRESSINFO (message = 0x%p) to interface 0x%p.",
						&ListenAddressInfoModified, this->m_pDP8SPCB);

					hr = this->m_pDP8SPCB->IndicateEvent(SPEV_LISTENADDRESSINFO, &ListenAddressInfoModified);

					DPFX(DPFPREP, 2, "Returning from SPEV_LISTENADDRESSINFO [0x%lx].", hr);
			/*
				}

				ListenAddressInfoModified.pDeviceAddress->Release();
				ListenAddressInfoModified.pDeviceAddress = NULL;
			}
			*/
			break;
		}

		case SPEV_ENUMADDRESSINFO:
		{
			SPIE_ENUMADDRESSINFO *	pEnumAddressInfo;
			SPIE_ENUMADDRESSINFO	EnumAddressInfoModified;


			pEnumAddressInfo = (SPIE_ENUMADDRESSINFO*) pvMessage;

			DNASSERT(pEnumAddressInfo->pHostAddress != NULL);
			DNASSERT(pEnumAddressInfo->pDeviceAddress != NULL);


			pDP8SimCommand = (CDP8SimCommand*) pEnumAddressInfo->pCommandContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_ENUMQUERY);


			//
			// Modify the message before indicating to the caller.
			//

			ZeroMemory(&EnumAddressInfoModified, sizeof(EnumAddressInfoModified));

			/*
			hr = pEnumAddressInfo->pHostAddress->Duplicate(&EnumAddressInfoModified.pHostAddress);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't duplicate enum address info host's address!");
			}
			else
			{
				hr = EnumAddressInfoModified.pHostAddress->SetSP(&CLSID_DP8SP_DP8SIM);
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't change enum address info host's address' SP!");
				}
				else
				{
					hr = pEnumAddressInfo->pDeviceAddress->Duplicate(&EnumAddressInfoModified.pDeviceAddress);
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't duplicate enum address info device address!");
					}
					else
					{
						hr = EnumAddressInfoModified.pDeviceAddress->SetSP(&CLSID_DP8SP_DP8SIM);
						if (hr != DPN_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't change enum address info device address' SP!");
						}
						else
						{
			*/
			EnumAddressInfoModified.pHostAddress					= pEnumAddressInfo->pHostAddress;
			EnumAddressInfoModified.pDeviceAddress					= pEnumAddressInfo->pDeviceAddress;
							EnumAddressInfoModified.hCommandStatus	= pEnumAddressInfo->hCommandStatus;
							EnumAddressInfoModified.pCommandContext	= pDP8SimCommand->GetUserContext();


							//
							// Indicate the event to the real callback interface.
							//

							DPFX(DPFPREP, 2, "Indicating SPEV_ENUMADDRESSINFO (message = 0x%p) to interface 0x%p.",
								&EnumAddressInfoModified, this->m_pDP8SPCB);

							hr = this->m_pDP8SPCB->IndicateEvent(SPEV_ENUMADDRESSINFO, &EnumAddressInfoModified);

							DPFX(DPFPREP, 2, "Returning from SPEV_ENUMADDRESSINFO [0x%lx].", hr);
			/*
						}

						EnumAddressInfoModified.pDeviceAddress->Release();
						EnumAddressInfoModified.pDeviceAddress = NULL;
					}
				}

				EnumAddressInfoModified.pHostAddress->Release();
				EnumAddressInfoModified.pHostAddress = NULL;
			}
			*/
			break;
		}

		case SPEV_CONNECTADDRESSINFO:
		{
			SPIE_CONNECTADDRESSINFO *	pConnectAddressInfo;
			SPIE_CONNECTADDRESSINFO		ConnectAddressInfoModified;


			pConnectAddressInfo = (SPIE_CONNECTADDRESSINFO*) pvMessage;

			DNASSERT(pConnectAddressInfo->pHostAddress != NULL);
			DNASSERT(pConnectAddressInfo->pDeviceAddress != NULL);


			pDP8SimCommand = (CDP8SimCommand*) pConnectAddressInfo->pCommandContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_CONNECT);


			//
			// Modify the message before indicating to the caller.
			//

			ZeroMemory(&ConnectAddressInfoModified, sizeof(ConnectAddressInfoModified));

			/*
			hr = pConnectAddressInfo->pHostAddress->Duplicate(&ConnectAddressInfoModified.pHostAddress);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't duplicate connect address info host's address!");
			}
			else
			{
				hr = ConnectAddressInfoModified.pHostAddress->SetSP(&CLSID_DP8SP_DP8SIM);
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't change connect address info host's address' SP!");
				}
				else
				{
					hr = pConnectAddressInfo->pDeviceAddress->Duplicate(&ConnectAddressInfoModified.pDeviceAddress);
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't duplicate connect address info device address!");
					}
					else
					{
						hr = ConnectAddressInfoModified.pDeviceAddress->SetSP(&CLSID_DP8SP_DP8SIM);
						if (hr != DPN_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't change connect address info device address' SP!");
						}
						else
						{
			*/
			ConnectAddressInfoModified.pHostAddress						= pConnectAddressInfo->pHostAddress;
			ConnectAddressInfoModified.pDeviceAddress					= pConnectAddressInfo->pDeviceAddress;
							ConnectAddressInfoModified.hCommandStatus	= pConnectAddressInfo->hCommandStatus;
							ConnectAddressInfoModified.pCommandContext	= pDP8SimCommand->GetUserContext();


							//
							// Indicate the event to the real callback interface.
							//

							DPFX(DPFPREP, 2, "Indicating SPEV_CONNECTADDRESSINFO (message = 0x%p) to interface 0x%p.",
								&ConnectAddressInfoModified, this->m_pDP8SPCB);

							hr = this->m_pDP8SPCB->IndicateEvent(SPEV_CONNECTADDRESSINFO, &ConnectAddressInfoModified);

							DPFX(DPFPREP, 2, "Returning from SPEV_CONNECTADDRESSINFO [0x%lx].", hr);
			/*
						}

						ConnectAddressInfoModified.pDeviceAddress->Release();
						ConnectAddressInfoModified.pDeviceAddress = NULL;
					}
				}

				ConnectAddressInfoModified.pHostAddress->Release();
				ConnectAddressInfoModified.pHostAddress = NULL;
			}
			*/
			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Unrecognized event type %u!", EventType);
			DNASSERT(FALSE);
			hr = E_NOTIMPL;
			break;
		}
	}


	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;
} // CDP8SimCB::IndicateEvent





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::CommandComplete"
//=============================================================================
// CDP8SimCB::CommandComplete
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	HANDLE hCommand		- Handle of command that's completing.
//	HRESULT hrResult	- Result code for completing operation.
//	PVOID pvContext		- Pointer to user context for command.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimCB::CommandComplete(HANDLE hCommand, HRESULT hrResult, PVOID pvContext)
{
	HRESULT				hr;
	CDP8SimCommand *	pDP8SimCommand = (CDP8SimCommand*) pvContext;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx, 0x%p)",
		this, hCommand, hrResult, pvContext);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(hCommand != NULL);
	DNASSERT(pDP8SimCommand->IsValidObject());



	//
	// Switch on the command type.
	//
	switch (pDP8SimCommand->GetType())
	{
		case CMDTYPE_SENDDATA_IMMEDIATE:
		{
			//
			// Update the statistics.
			//
			this->m_pOwningDP8SimSP->IncrementStatSendTransmitted();


			//
			// Indicate the completion to the real callback interface.
			//
			DPFX(DPFPREP, 2, "Indicating immediate send command 0x%p complete (result = 0x%lx, context = 0x%p) to interface 0x%p.",
				pDP8SimCommand, hrResult,
				pDP8SimCommand->GetUserContext(),
				this->m_pDP8SPCB);

			hr = this->m_pDP8SPCB->CommandComplete(pDP8SimCommand,
													hrResult,
													pDP8SimCommand->GetUserContext());

			DPFX(DPFPREP, 2, "Returning from command complete [0x%lx].", hr);


			//
			// Remove the send counter.
			//
			this->m_pOwningDP8SimSP->DecSendsPending();

			break;
		}

		case CMDTYPE_SENDDATA_DELAYED:
		{
			CDP8SimSend *	pDP8SimSend;


			//
			// Update the statistics.
			//
			this->m_pOwningDP8SimSP->IncrementStatSendTransmitted();


			//
			// Handle the completion.  It never gets indicated to the user
			// though.
			//

			pDP8SimSend = (CDP8SimSend*) pDP8SimCommand->GetUserContext();
			DNASSERT(pDP8SimSend->IsValidObject());
			
			DPFX(DPFPREP, 5, "Send 0x%p (command 0x%p) completed.",
				pDP8SimSend, pDP8SimCommand);


			//
			// Remove the send counter.
			//
			this->m_pOwningDP8SimSP->DecSendsPending();


			pDP8SimSend->Release();
			pDP8SimSend = NULL;

			hr = DPN_OK;

			break;
		}

		case CMDTYPE_CONNECT:
		case CMDTYPE_DISCONNECT:
		case CMDTYPE_LISTEN:
		case CMDTYPE_ENUMQUERY:
		case CMDTYPE_ENUMRESPOND:
		{
			//
			// Indicate the completion to the real callback interface.
			//
			DPFX(DPFPREP, 2, "Indicating command 0x%p complete (type = %u, result = 0x%lx, context = 0x%p) to interface 0x%p.",
				pDP8SimCommand, pDP8SimCommand->GetType(), hrResult,
				pDP8SimCommand->GetUserContext(), this->m_pDP8SPCB);

			hr = this->m_pDP8SPCB->CommandComplete(pDP8SimCommand,
													hrResult,
													pDP8SimCommand->GetUserContext());

			DPFX(DPFPREP, 2, "Returning from command complete [0x%lx].", hr);


			//
			// If this was a listen, we need to kill the listen endpoint.
			//
			if (pDP8SimCommand->GetType() == CMDTYPE_LISTEN)
			{
				CDP8SimEndpoint *	pDP8SimEndpoint;


				pDP8SimEndpoint = pDP8SimCommand->GetListenEndpoint();
				DNASSERT(pDP8SimEndpoint != NULL);

				pDP8SimCommand->SetListenEndpoint(NULL);

				DPFX(DPFPREP, 7, "Releasing listen endpoint 0x%p.",
					pDP8SimEndpoint);

				pDP8SimEndpoint->Release();
				pDP8SimEndpoint = NULL;
			}
			break;
		}
		
		default:
		{
			DPFX(DPFPREP, 0, "Unrecognized command type %u!", pDP8SimCommand->GetType());
			DNASSERT(FALSE);
			hr = E_NOTIMPL;
			break;
		}
	}


	//
	// Destroy the object.
	//
	DPFX(DPFPREP, 7, "Releasing completed command 0x%p.", pDP8SimCommand);
	pDP8SimCommand->Release();
	pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;
} // CDP8SimCB::CommandComplete






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::InitializeObject"
//=============================================================================
// CDP8SimCB::InitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Sets up the object for use like the constructor, but may
//				fail with OUTOFMEMORY.  Should only be called by class factory
//				creation routine.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK			- Initialization was successful.
//	E_OUTOFMEMORY	- There is not enough memory to initialize.
//=============================================================================
HRESULT CDP8SimCB::InitializeObject(void)
{
	HRESULT		hr;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);

	DNASSERT(this->IsValidObject());


	//
	// Create the lock.
	// 

	if (! DNInitializeCriticalSection(&this->m_csLock))
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Don't allow critical section reentry.
	//
	DebugSetCriticalSectionRecursionCount(&this->m_csLock, 0);


	hr = S_OK;

Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimCB::InitializeObject






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::UninitializeObject"
//=============================================================================
// CDP8SimCB::UninitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Cleans up the object like the destructor, mostly to balance
//				InitializeObject.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimCB::UninitializeObject(void)
{
	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	DNASSERT(this->IsValidObject());


	DNDeleteCriticalSection(&this->m_csLock);


	DPFX(DPFPREP, 5, "(0x%p) Returning", this);
} // CDP8SimCB::UninitializeObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\ui\dp8simuii.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simuii.h
 *
 *  Content:	DP8SIMUI master internal header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/25/01  VanceO    Created.
 *
 ***************************************************************************/

#ifndef __DP8SIMUII_H__
#define __DP8SIMUII_H__


// 
// Public includes
//
#include <windows.h>
#include <ole2.h>
#include <mmsystem.h>	// NT BUILD requires this for timeGetTime


// 
// DirectPlay public includes
//
#include "dplay8.h"
//#include "dpaddr.h"
//#include "dpsp8.h"


// 
// DirectPlay private includes
//
#include "dndbg.h"
#include "osind.h"
//#include "classbilink.h"
//#include "creg.h"
//#include "createin.h"
#include "comutil.h"
//#include "dneterrors.h"
#include "strutils.h"


// 
// DP8Sim includes
//
#include "dp8sim.h"


// 
// DP8SimUI private includes
//

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_TOOLS

#include "resource.h"




#endif // __DP8SIMUII_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\spwrapper.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		spwrapper.cpp
 *
 *  Content:	DP8SIM main SP interface wrapper object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"




//=============================================================================
// Dynamically loaded function prototypes
//=============================================================================
typedef HRESULT (WINAPI * PFN_DLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID *);


 



#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::CDP8SimSP"
//=============================================================================
// CDP8SimSP constructor
//-----------------------------------------------------------------------------
//
// Description: Initializes the new CDP8SimSP object.
//
// Arguments:
//	GUID * pguidRealSP	- Pointer to guid of real SP being wrapped.
//
// Returns: None (the object).
//=============================================================================
CDP8SimSP::CDP8SimSP(const GUID * const pguidRealSP)
{
	this->m_blList.Initialize();


	this->m_Sig[0]	= 'S';
	this->m_Sig[1]	= 'P';
	this->m_Sig[2]	= 'W';
	this->m_Sig[3]	= 'P';

	this->m_lRefCount					= 1; // someone must have a pointer to this object
	this->m_dwFlags						= 0;
	CopyMemory(&this->m_guidSP, pguidRealSP, sizeof(GUID));
	this->m_pDP8SimCB					= NULL;
	this->m_pDP8SP						= NULL;
	this->m_dwSendsPending				= 0;
	this->m_hLastPendingSendEvent		= NULL;
	this->m_dwReceivesPending			= 0;
	//this->m_hLastPendingReceiveEvent	= NULL;
} // CDP8SimSP::CDP8SimSP






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::~CDP8SimSP"
//=============================================================================
// CDP8SimSP destructor
//-----------------------------------------------------------------------------
//
// Description: Frees the CDP8SimSP object.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
CDP8SimSP::~CDP8SimSP(void)
{
	DNASSERT(this->m_blList.IsEmpty());


	DNASSERT(this->m_lRefCount == 0);
	DNASSERT(this->m_dwFlags == 0);
	DNASSERT(this->m_pDP8SimCB == NULL);
	DNASSERT(this->m_pDP8SP == NULL);
	DNASSERT(this->m_dwSendsPending == 0);
	DNASSERT(this->m_hLastPendingSendEvent == NULL);
	DNASSERT(this->m_dwReceivesPending == 0);
	//DNASSERT(this->m_hLastPendingReceiveEvent == NULL);

	//
	// For grins, change the signature before deleting the object.
	//
	this->m_Sig[3]	= 'p';
} // CDP8SimSP::~CDP8SimSP




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::QueryInterface"
//=============================================================================
// CDP8SimSP::QueryInterface
//-----------------------------------------------------------------------------
//
// Description: Retrieves a new reference for an interfaces supported by this
//				CDP8SimSP object.
//
// Arguments:
//	REFIID riid			- Reference to interface ID GUID.
//	LPVOID * ppvObj		- Place to store pointer to object.
//
// Returns: HRESULT
//	S_OK					- Returning a valid interface pointer.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPOINTER	- The destination pointer is invalid.
//	E_NOINTERFACE			- Invalid interface was specified.
//=============================================================================
STDMETHODIMP CDP8SimSP::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	HRESULT		hr = DPN_OK;


	DPFX(DPFPREP, 3, "(0x%p) Parameters: (REFIID, 0x%p)", this, ppvObj);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DP8Sim object!");
		hr = DPNERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if ((! IsEqualIID(riid, IID_IUnknown)) &&
		(! IsEqualIID(riid, IID_IDP8ServiceProvider)))
	{
		DPFX(DPFPREP, 0, "Unsupported interface!");
		hr = E_NOINTERFACE;
		goto Failure;
	}

	if ((ppvObj == NULL) ||
		(IsBadWritePtr(ppvObj, sizeof(void*))))
	{
		DPFX(DPFPREP, 0, "Invalid interface pointer specified!");
		hr = DPNERR_INVALIDPOINTER;
		goto Failure;
	}


	//
	// Add a reference, and return the interface pointer (which is actually
	// just the object pointer, they line up because CDP8SimSP inherits from
	// the interface declaration).
	//
	this->AddRef();
	(*ppvObj) = this;


Exit:

	DPFX(DPFPREP, 3, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimSP::QueryInterface




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::AddRef"
//=============================================================================
// CDP8SimSP::AddRef
//-----------------------------------------------------------------------------
//
// Description: Adds a reference to this CDP8SimSP object.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CDP8SimSP::AddRef(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());


	//
	// There must be at least 1 reference to this object, since someone is
	// calling AddRef.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedIncrement(&this->m_lRefCount);

	DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);

	return lRefCount;
} // CDP8SimSP::AddRef




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::Release"
//=============================================================================
// CDP8SimSP::Release
//-----------------------------------------------------------------------------
//
// Description: Removes a reference to this CDP8SimSP object.  When the
//				refcount reaches 0, this object is destroyed.
//				You must NULL out your pointer to this object after calling
//				this function.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CDP8SimSP::Release(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());

	//
	// There must be at least 1 reference to this object, since someone is
	// calling Release.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedDecrement(&this->m_lRefCount);

	//
	// Was that the last reference?  If so, we're going to destroy this object.
	//
	if (lRefCount == 0)
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount hit 0, destroying object.", this);

		//
		// First pull it off the global list.
		//
		DNEnterCriticalSection(&g_csGlobalsLock);

		this->m_blList.RemoveFromList();

		DNASSERT(g_lOutstandingInterfaceCount > 0);
		g_lOutstandingInterfaceCount--;	// update count so DLL can unload now works correctly
		
		DNLeaveCriticalSection(&g_csGlobalsLock);


		//
		// Make sure it's closed.
		//
		if (this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED)
		{
			//
			// Assert so that the user can fix his/her broken code!
			//
			DNASSERT(! "DP8SimSP object being released without calling Close first!");

			//
			// Then go ahead and do the right thing.  Ignore error, we can't do
			// much about it.
			//
			this->Close();
		}


		//
		// Then uninitialize the object.
		//
		this->UninitializeObject();

		//
		// Finally delete this (!) object.
		//
		delete this;
	}
	else
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);
	}

	return lRefCount;
} // CDP8SimSP::Release




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::Initialize"
//=============================================================================
// CDP8SimSP::Initialize
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPINITIALIZEDATA pspid		- Pointer to parameter block to use when
//									initializing.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::Initialize(PSPINITIALIZEDATA pspid)
{
	HRESULT				hr;
	BOOL				fHaveLock = FALSE;
	BOOL				fInitializedIPCObject = FALSE;
	SPINITIALIZEDATA	spidModified;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspid);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspid != NULL);


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags == 0);


	//
	// Connect the shared memory.
	//
	hr = this->m_DP8SimIPC.Initialize();
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize IPC object!");
		goto Failure;
	}

	fInitializedIPCObject = TRUE;


	//
	// Create a wrapper for the callback interface.
	//
	this->m_pDP8SimCB = new CDP8SimCB(this, pspid->pIDP);
	if (this->m_pDP8SimCB == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Initialize the callback interface wrapper object.
	//
	hr = this->m_pDP8SimCB->InitializeObject();
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize callback interface wrapper object!");

		delete this->m_pDP8SimCB;
		this->m_pDP8SimCB = NULL;

		goto Failure;
	}


	//
	// Instantiate the real SP.
	//
	hr = this->CoCreateInstanceRedirected(this->m_guidSP,
										IID_IDP8ServiceProvider,
										(PVOID*) (&this->m_pDP8SP),
										&this->m_hSPDLL);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't instantiate real SP object (pointer = 0x%p)!",
			this->m_pDP8SP);
		goto Failure;
	}


	DPFX(DPFPREP, 1, "Object 0x%p wrapping real SP 0x%p (in DLL 0x%p), inserting callback interface 0x%p before 0x%p.",
		this, this->m_pDP8SP, this->m_hSPDLL, this->m_pDP8SimCB, pspid->pIDP);



	//
	// Initialize the real SP.
	//

	ZeroMemory(&spidModified, sizeof(spidModified));
	spidModified.pIDP		= this->m_pDP8SimCB;
	spidModified.dwFlags	= pspid->dwFlags;

	hr = this->m_pDP8SP->Initialize(&spidModified);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed initializing real SP object (0x%p)!",
			this->m_pDP8SP);
		goto Failure;
	}


	//
	// We're now initialized.
	//
	this->m_dwFlags |= DP8SIMSPOBJ_INITIALIZED;



Exit:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (this->m_pDP8SP != NULL)
	{
		this->m_pDP8SP->Release();
		this->m_pDP8SP = NULL;
	}

	if (this->m_hSPDLL != NULL)
	{
		FreeLibrary(this->m_hSPDLL);
		this->m_hSPDLL;
	}

	if (this->m_pDP8SimCB != NULL)
	{
		this->m_pDP8SimCB->Release();
		this->m_pDP8SimCB = NULL;
	}

	if (fInitializedIPCObject)
	{
		this->m_DP8SimIPC.Close();
		fInitializedIPCObject = FALSE;
	}

	goto Exit;
} // CDP8SimSP::Initialize






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::Close"
//=============================================================================
// CDP8SimSP::Close
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments: None.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::Close(void)
{
	HRESULT		hr;
	//BOOL		fHaveLock = FALSE;
	BOOL		fWait = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Enter", this);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	DNEnterCriticalSection(&this->m_csLock);
	//fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);


	//
	// Figure out if we need to wait for all sends to complete.
	//
	if (this->m_dwSendsPending > 0)
	{
		DNASSERT(this->m_hLastPendingSendEvent == NULL);

		this->m_hLastPendingSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (this->m_hLastPendingSendEvent == NULL)
		{
			hr = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't create last send pending event (err = %u)!", hr);
		}
		else
		{
			fWait = TRUE;
		}
	}

	this->m_dwFlags |= DP8SIMSPOBJ_CLOSING;

	//
	// Drop the lock, nobody should be touching this object now.
	//
	DNLeaveCriticalSection(&this->m_csLock);
	//fHaveLock = FALSE;


	if (fWait)
	{
		DPFX(DPFPREP, 1, "Waiting for ~%u pending sends to complete.",
			this->m_dwSendsPending);


		//
		// Wait for all the sends to complete.  Nobody should touch
		// m_hLastPendingSendEvent except the thread triggering it, so
		// referring to it without the lock should be safe.
		// Ignore any errors.
		//
		WaitForSingleObject(this->m_hLastPendingSendEvent, INFINITE);


		//
		// Take the lock while removing the handle, to be paranoid.
		//
		DNEnterCriticalSection(&this->m_csLock);

		//
		// Remove the handle.
		//
		CloseHandle(this->m_hLastPendingSendEvent);
		this->m_hLastPendingSendEvent = NULL;


		//
		// Drop the lock again.
		//
		DNLeaveCriticalSection(&this->m_csLock);
	}


	//
	// Shutdown the global worker thread if we launched it.
	//
	if (this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD)
	{
		StopGlobalWorkerThread();

		this->m_dwFlags &= ~DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD;
	}


	//
	// Close the real SP.
	//
	hr = this->m_pDP8SP->Close();
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed closing real SP object (0x%p)!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}


	//
	// Release the real SP object.
	//
	this->m_pDP8SP->Release();
	this->m_pDP8SP = NULL;


	//
	// Free the SP DLL.
	//
	FreeLibrary(this->m_hSPDLL);
	this->m_hSPDLL;


	//
	// Release the callback interceptor object.
	//
	this->m_pDP8SimCB->Release();
	this->m_pDP8SimCB = NULL;


	//
	// Disconnect the shared memory.
	//
	this->m_DP8SimIPC.Close();


	//
	// Turn off the initialized and closing flags.
	//
	this->m_dwFlags &= ~(DP8SIMSPOBJ_INITIALIZED | DP8SIMSPOBJ_CLOSING);
	DNASSERT(this->m_dwFlags == 0);


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


/*
Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
*/
} // CDP8SimSP::Close




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::Connect"
//=============================================================================
// CDP8SimSP::Connect
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPCONNECTDATA pspcd	- Pointer to parameter block to use when
//								connecting.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::Connect(PSPCONNECTDATA pspcd)
{
	HRESULT						hr;
	BOOL						fHaveLock = FALSE;
	SPCONNECTDATA				spcdModified;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspcd);


	ZeroMemory(&spcdModified, sizeof(spcdModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspcd != NULL);
	DNASSERT(pspcd->pAddressHost != NULL);
	DNASSERT(pspcd->pAddressDeviceInfo != NULL);


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;

	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	//
	// Fire up the global worker thread, if it hasn't been already.
	//
	if (! (this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD))
	{
		hr = StartGlobalWorkerThread();
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Failed starting global worker thread!");
			goto Failure;
		}

		this->m_dwFlags |= DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD;
	}

	DNLeaveCriticalSection(&this->m_csLock);
	fHaveLock = FALSE;

	
	//
	// Prepare a command object.
	//

	ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
	CommandFPMContext.dwType			= CMDTYPE_CONNECT;
	CommandFPMContext.pvUserContext		= pspcd->pvContext;

	pDP8SimCommand = g_pFPOOLCommand->Get(&CommandFPMContext);
	if (pDP8SimCommand == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);



	//
	// Copy the parameter block, modifying as necessary.
	//

	/*
	//
	// Duplicate the host address.
	//
	hr = pspcd->pAddressHost->Duplicate(&spcdModified.pAddressHost);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate host address!");
		goto Failure;
	}


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = spcdModified.pAddressHost->SetSP(&this->m_guidSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change host address' SP!");
		goto Failure;
	}


	//
	// Duplicate the host address.
	//
	hr = pspcd->pAddressDeviceInfo->Duplicate(&spcdModified.pAddressDeviceInfo);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate device info address!");
		goto Failure;
	}


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = spcdModified.pAddressDeviceInfo->SetSP(&this->m_guidSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change device info address' SP!");
		goto Failure;
	}
	*/
	spcdModified.pAddressHost			= pspcd->pAddressHost;
	spcdModified.pAddressDeviceInfo		= pspcd->pAddressDeviceInfo;


	//
	// Add a reference for the connect command.
	//
	pDP8SimCommand->AddRef();

	DNASSERT(pspcd->dwReserved == 0);
	//spcdModified.dwReserved				= pspcd->dwReserved;
	spcdModified.dwFlags				= pspcd->dwFlags;
	spcdModified.pvContext				= pDP8SimCommand;
	//spcdModified.hCommand				= pspcd->hCommand;				// filled in by real SP
	//spcdModified.dwCommandDescriptor	= pspcd->dwCommandDescriptor;	// filled in by real SP



	//
	// Start connecting with the real service provider.
	//
	hr = this->m_pDP8SP->Connect(&spcdModified);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed starting to connect with real SP object (0x%p)!",
			this->m_pDP8SP);


		DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
		pDP8SimCommand->Release();

		goto Failure;
	}

	
#pragma BUGBUG(vanceo, "Handle DPN_OK and investigate command completing before this function returns")
	DNASSERT(spcdModified.hCommand != NULL);


	//
	// Save the output parameters.
	//
	pDP8SimCommand->SetRealSPCommand(spcdModified.hCommand,
									spcdModified.dwCommandDescriptor);


	//
	// Generate the output parameters for the caller.
	//
	pspcd->hCommand				= (HANDLE) pDP8SimCommand;
	pspcd->dwCommandDescriptor	= 0;


Exit:

	//
	// Give up local reference.
	//
	if (pDP8SimCommand != NULL)
	{
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;
	}

	/*
	if (spcdModified.pAddressDeviceInfo != NULL)
	{
		spcdModified.pAddressDeviceInfo->Release();
		spcdModified.pAddressDeviceInfo = NULL;
	}

	if (spcdModified.pAddressHost != NULL)
	{
		spcdModified.pAddressHost->Release();
		spcdModified.pAddressHost = NULL;
	}
	*/

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
} // CDP8SimSP::Connect





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::Disconnect"
//=============================================================================
// CDP8SimSP::Disconnect
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPDISCONNECTDATA pspdd	- Pointer to parameter block to use when
//								disconnecting.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::Disconnect(PSPDISCONNECTDATA pspdd)
{
	HRESULT						hr;
	BOOL						fHaveLock = FALSE;
	CDP8SimEndpoint *			pDP8SimEndpoint;
	SPDISCONNECTDATA			spddModified;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspdd);


	ZeroMemory(&spddModified, sizeof(spddModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspdd != NULL);


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;

	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
	fHaveLock = FALSE;


	pDP8SimEndpoint = (CDP8SimEndpoint*) pspdd->hEndpoint;
	DNASSERT(pDP8SimEndpoint->IsValidObject());

	//
	// Mark the endpoint as disconnecting to prevent additional sends/receives.
	//
	pDP8SimEndpoint->Lock();
	pDP8SimEndpoint->NoteDisconnecting();
	pDP8SimEndpoint->Unlock();


	//
	// Flush any delayed sends that were already going to this endpoint to make
	// sure they hit the wire.
	//
	FlushAllDelayedSendsToEndpoint(pDP8SimEndpoint, FALSE);


	//
	// Drop any delayed receives from this endpoint, the upper layer doesn't
	// want to receive anything else after disconnecting.
	//
	FlushAllDelayedReceivesFromEndpoint(pDP8SimEndpoint, TRUE);


	//
	// Prepare a command object.
	//

	ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
	CommandFPMContext.dwType			= CMDTYPE_DISCONNECT;
	CommandFPMContext.pvUserContext		= pspdd->pvContext;

	pDP8SimCommand = g_pFPOOLCommand->Get(&CommandFPMContext);
	if (pDP8SimCommand == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);



	//
	// Add a reference for the disconnect command.
	//
	pDP8SimCommand->AddRef();


	//
	// Copy the parameter block, modifying as necessary.
	//
	spddModified.hEndpoint				= pDP8SimEndpoint->GetRealSPEndpoint();
	spddModified.dwFlags				= pspdd->dwFlags;
	spddModified.pvContext				= pDP8SimCommand;
	//spddModified.hCommand				= pspdd->hCommand;				// filled in by real SP
	//spddModified.dwCommandDescriptor	= pspdd->dwCommandDescriptor;	// filled in by real SP



	//
	// Tell the real service provider to disconnect.
	//
	hr = this->m_pDP8SP->Disconnect(&spddModified);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed having real SP object (0x%p) disconnect!",
			this->m_pDP8SP);


		DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
		pDP8SimCommand->Release();

		goto Failure;
	}

	
	if (hr == DPNSUCCESS_PENDING)
	{
		DNASSERT(spddModified.hCommand != NULL);


		//
		// Save the output parameters.
		//
		pDP8SimCommand->SetRealSPCommand(spddModified.hCommand,
										spddModified.dwCommandDescriptor);


		//
		// Generate the output parameters for the caller.
		//
		pspdd->hCommand				= (HANDLE) pDP8SimCommand;
		pspdd->dwCommandDescriptor	= 0;
	}
	else
	{
		DNASSERT(spddModified.hCommand == NULL);

		DPFX(DPFPREP, 7, "Releasing completed command 0x%p.", pDP8SimCommand);
		pDP8SimCommand->Release();
	}


Exit:

	//
	// Give up local reference.
	//
	if (pDP8SimCommand != NULL)
	{
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
} // CDP8SimSP::Disconnect





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::Listen"
//=============================================================================
// CDP8SimSP::Listen
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPLISTENDATA pspld		- Pointer to parameter block to use when listening.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::Listen(PSPLISTENDATA pspld)
{
	HRESULT						hr;
	BOOL						fHaveLock = FALSE;
	SPLISTENDATA				spldModified;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspld);


	ZeroMemory(&spldModified, sizeof(spldModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspld != NULL);
	DNASSERT(pspld->pAddressDeviceInfo != NULL);


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	//
	// Fire up the global worker thread, if it hasn't been already.
	//
	if (! (this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD))
	{
		hr = StartGlobalWorkerThread();
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Failed starting global worker thread!");
			goto Failure;
		}

		this->m_dwFlags |= DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD;
	}

	DNLeaveCriticalSection(&this->m_csLock);
	fHaveLock = FALSE;



	//
	// Prepare a command object.
	//

	ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
	CommandFPMContext.dwType			= CMDTYPE_LISTEN;
	CommandFPMContext.pvUserContext		= pspld->pvContext;

	pDP8SimCommand = g_pFPOOLCommand->Get(&CommandFPMContext);
	if (pDP8SimCommand == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);



	//
	// Copy the parameter block, modifying as necessary.
	//

	/*
	//
	// Duplicate the host address.
	//
	hr = pspld->pAddressDeviceInfo->Duplicate(&spldModified.pAddressDeviceInfo);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate device info address!");
		goto Failure;
	}


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = spldModified.pAddressDeviceInfo->SetSP(&this->m_guidSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change device info address' SP!");
		goto Failure;
	}
	*/
	spldModified.pAddressDeviceInfo		= pspld->pAddressDeviceInfo;


	//
	// Add a reference for the listen command.
	//
	pDP8SimCommand->AddRef();


	spldModified.dwFlags				= pspld->dwFlags;
	spldModified.pvContext				= pDP8SimCommand;
	//spldModified.hCommand				= pspld->hCommand;				// filled in by real SP
	//spldModified.dwCommandDescriptor	= pspld->dwCommandDescriptor;	// filled in by real SP



	//
	// Start listening with the real service provider.
	//
	hr = this->m_pDP8SP->Listen(&spldModified);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed to start listening with the real SP object (0x%p)!",
			this->m_pDP8SP);


		DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
		pDP8SimCommand->Release();

		goto Failure;
	}

	
	DNASSERT(spldModified.hCommand != NULL);


	//
	// Save the output parameters.
	//
	pDP8SimCommand->SetRealSPCommand(spldModified.hCommand,
									spldModified.dwCommandDescriptor);


	//
	// Generate the output parameters for the caller.
	//
	pspld->hCommand				= (HANDLE) pDP8SimCommand;
	pspld->dwCommandDescriptor	= 0;


Exit:

	//
	// Give up local reference.
	//
	if (pDP8SimCommand != NULL)
	{
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;
	}

	/*
	if (spldModified.pAddressDeviceInfo != NULL)
	{
		spldModified.pAddressDeviceInfo->Release();
		spldModified.pAddressDeviceInfo = NULL;
	}
	*/

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
} // CDP8SimSP::Listen





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::SendData"
//=============================================================================
// CDP8SimSP::SendData
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPSENDDATA pspsd	- Pointer to parameter block to use when sending.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::SendData(PSPSENDDATA pspsd)
{
	HRESULT						hr;
	DP8SIM_PARAMETERS			dp8sp;
	CDP8SimEndpoint *			pDP8SimEndpoint;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;
	SPSENDDATA					spsdModified;
	CDP8SimSend *				pDP8SimSend = NULL;
	IDP8SPCallback *			pDP8SPCB;
	DWORD						dwMsgSize;
	DWORD						dwTemp;
	DWORD						dwLatency;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspsd);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspsd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Get the current send settings.
	//
	ZeroMemory(&dp8sp, sizeof(dp8sp));
	dp8sp.dwSize = sizeof(dp8sp);
	this->m_DP8SimIPC.GetAllSendParameters(&dp8sp);


	//
	// Determine if we need to drop this send.
	//
	if (this->ShouldDrop(dp8sp.dwPacketLossPercent))
	{
		//
		// Update the statistics.
		//
		this->m_DP8SimIPC.IncrementStatSendDropped();


		//
		// Indicate send completion (with a bogus handle) immediately.
		//

		pDP8SPCB = this->m_pDP8SimCB->GetRealCallbackInterface();

		DPFX(DPFPREP, 2, "Indicating successful send completion (dropped, context = 0x%p) to interface 0x%p.",
			pspsd->pvContext, pDP8SPCB);

		hr = pDP8SPCB->CommandComplete(NULL, DPN_OK, pspsd->pvContext);

		DPFX(DPFPREP, 2, "Returning from command complete [0x%lx].", hr);


		//
		// Ignore any error and return DPNSUCCESS_PENDING, even though we've
		// completed the send already.
		//
		hr = DPNSUCCESS_PENDING;


		//
		// Return bogus output parameters for the caller, it's already complete
		// from their perspective.
		//
		pspsd->hCommand				= NULL;
		pspsd->dwCommandDescriptor	= 0;


		//
		// We're done here.
		//
		goto Exit;
	}


	//
	// Determine the total size of the message.
	//
	dwMsgSize = 0;
	for(dwTemp = 0; dwTemp < pspsd->dwBufferCount; dwTemp++)
	{
		DNASSERT((pspsd->pBuffers[dwTemp].pBufferData != NULL) && (pspsd->pBuffers[dwTemp].dwBufferSize > 0));
		dwMsgSize += pspsd->pBuffers[dwTemp].dwBufferSize;
	}


	//
	// Figure out how much latency needs to be added based on the bandwidth
	// and random latency settings.
	//
	dwLatency = this->GetLatency(dp8sp.dwBandwidthBPS,
								dwMsgSize,
								dp8sp.dwMinLatencyMS,
								dp8sp.dwMaxLatencyMS);


	//
	// If we're not supposed to delay the sends, fire it off right away.
	// Otherwise submit a timed job to be performed later.
	//
	if (dwLatency == 0)
	{
		pDP8SimEndpoint = (CDP8SimEndpoint*) pspsd->hEndpoint;
		DNASSERT(pDP8SimEndpoint->IsValidObject());


		//
		// If the endpoint is disconnecting, don't try to send.
		//
		pDP8SimEndpoint->Lock();
		if (pDP8SimEndpoint->IsDisconnecting())
		{
			pDP8SimEndpoint->Unlock();

			DPFX(DPFPREP, 0, "Endpoint 0x%p is disconnecting, can't send!",
				pDP8SimEndpoint);

			hr = DPNERR_NOCONNECTION;
			goto Failure;
		}
		pDP8SimEndpoint->Unlock();



		DPFX(DPFPREP, 6, "Sending %u bytes of data immmediately.", dwMsgSize);


		//
		// Prepare a command object.
		//

		ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
		CommandFPMContext.dwType			= CMDTYPE_SENDDATA_IMMEDIATE;
		CommandFPMContext.pvUserContext		= pspsd->pvContext;

		pDP8SimCommand = g_pFPOOLCommand->Get(&CommandFPMContext);
		if (pDP8SimCommand == NULL)
		{
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}


		DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);


		//
		// Copy the parameter block, modifying as necessary.
		//
		ZeroMemory(&spsdModified, sizeof(spsdModified));
		spsdModified.hEndpoint				= pDP8SimEndpoint->GetRealSPEndpoint();
		spsdModified.pBuffers				= pspsd->pBuffers;
		spsdModified.dwBufferCount			= pspsd->dwBufferCount;
		spsdModified.dwFlags				= pspsd->dwFlags;
		spsdModified.pvContext				= pDP8SimCommand;
		//spsdModified.hCommand				= NULL;	// filled in by real SP
		//spsdModified.dwCommandDescriptor	= 0;	// filled in by real SP


		//
		// Add a reference for the send command.
		//
		pDP8SimCommand->AddRef();


		//
		// Increase the pending sends counter.
		//
		this->IncSendsPending();

		

		//
		// Issue the send to the real SP.
		//
		hr = this->m_pDP8SP->SendData(&spsdModified);
		if (FAILED(hr))
		{
			DPFX(DPFPREP, 0, "Failed sending immediate data (err = 0x%lx)!", hr);


			//
			// Remove the send counter.
			//
			this->DecSendsPending();


			DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
			pDP8SimCommand->Release();


			//
			// Continue.
			//
		}
		else
		{
			DNASSERT(hr == DPNSUCCESS_PENDING);


			//
			// Save the output parameters returned by the SP.
			//
			pDP8SimCommand->SetRealSPCommand(spsdModified.hCommand,
											spsdModified.dwCommandDescriptor);
		}


		//
		// Give up local reference.
		//
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;


		//
		// We're done here.
		//
		goto Exit;
	}


	//
	// If we're here, we must be delaying the send.
	//
	
	DPFX(DPFPREP, 6, "Delaying %u byte send for %u ms.", dwMsgSize, dwLatency);


	//
	// Get a send object, duplicating the send data given to us by our caller
	// for submission some time in the future.
	//
	pDP8SimSend = g_pFPOOLSend->Get(pspsd);
	if (pDP8SimSend == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "New send 0x%p.", pDP8SimSend);


	//
	// Transfer local pDP8SimSend reference to the job queue.
	//


	//
	// Increment the send counter.
	//
	this->IncSendsPending();


	//
	// Queue it to be sent at a later time, depending on the latency value
	// requested.
	//
	hr = AddWorkerJob(dwLatency,
					DP8SIMJOBTYPE_DELAYEDSEND,
					pDP8SimSend,
					this,
					TRUE);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't add delayed send worker job (0x%p)!", 
			pDP8SimSend);


		//
		// Remove the send counter.
		//
		this->DecSendsPending();


		goto Failure;
	}


	//
	// Indicate send completion (with a bogus handle) immediately.
	//

	pDP8SPCB = this->m_pDP8SimCB->GetRealCallbackInterface();

	DPFX(DPFPREP, 2, "Indicating successful send completion (delayed, context = 0x%p) to interface 0x%p.",
		pspsd->pvContext, pDP8SPCB);

	hr = pDP8SPCB->CommandComplete(NULL, DPN_OK, pspsd->pvContext);

	DPFX(DPFPREP, 2, "Returning from command complete [0x%lx].", hr);


	//
	// Ignore any error and return DPNSUCCESS_PENDING, even though we've
	// completed the send already.
	//
	hr = DPNSUCCESS_PENDING;


	//
	// Return bogus output parameters for the caller, it's already complete
	// from their perspective.
	//
	pspsd->hCommand				= NULL;
	pspsd->dwCommandDescriptor	= 0;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pDP8SimSend != NULL)
	{
		pDP8SimSend->Release();
		pDP8SimSend = NULL;
	}

	goto Exit;
} // CDP8SimSP::SendData





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::EnumQuery"
//=============================================================================
// CDP8SimSP::EnumQuery
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPENUMQUERYDATA pspeqd		- Pointer to parameter block to use when
//									enumerating.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::EnumQuery(PSPENUMQUERYDATA pspeqd)
{
	HRESULT						hr;
	BOOL						fHaveLock = FALSE;
	SPENUMQUERYDATA				speqdModified;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspeqd);


	ZeroMemory(&speqdModified, sizeof(speqdModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspeqd != NULL);
	DNASSERT(pspeqd->pAddressHost != NULL);
	DNASSERT(pspeqd->pAddressDeviceInfo != NULL);


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	//
	// Fire up the global worker thread, if it hasn't been already.
	//
	if (! (this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD))
	{
		hr = StartGlobalWorkerThread();
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Failed starting global worker thread!");
			goto Failure;
		}

		this->m_dwFlags |= DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD;
	}

	DNLeaveCriticalSection(&this->m_csLock);
	fHaveLock = FALSE;



	//
	// Prepare a command object.
	//

	ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
	CommandFPMContext.dwType			= CMDTYPE_ENUMQUERY;
	CommandFPMContext.pvUserContext		= pspeqd->pvContext;

	pDP8SimCommand = g_pFPOOLCommand->Get(&CommandFPMContext);
	if (pDP8SimCommand == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);



	//
	// Copy the parameter block, modifying as necessary.
	//

	/*
	//
	// Duplicate the host address.
	//
	hr = pspeqd->pAddressHost->Duplicate(&speqdModified.pAddressHost);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate host address!");
		goto Failure;
	}


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = speqdModified.pAddressHost->SetSP(&this->m_guidSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change host address' SP!");
		goto Failure;
	}

	
	//
	// Duplicate the host address.
	//
	hr = pspeqd->pAddressDeviceInfo->Duplicate(&speqdModified.pAddressDeviceInfo);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate device info address!");
		goto Failure;
	}


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = speqdModified.pAddressDeviceInfo->SetSP(&this->m_guidSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change device info address' SP!");
		goto Failure;
	}
	*/
	speqdModified.pAddressHost			= pspeqd->pAddressHost;
	speqdModified.pAddressDeviceInfo	= pspeqd->pAddressDeviceInfo;


	//
	// Add a reference for the enum query command.
	//
	pDP8SimCommand->AddRef();


	speqdModified.pBuffers				= pspeqd->pBuffers;
	speqdModified.dwBufferCount			= pspeqd->dwBufferCount;
	speqdModified.dwTimeout				= pspeqd->dwTimeout;
	speqdModified.dwRetryCount			= pspeqd->dwRetryCount;
	speqdModified.dwRetryInterval		= pspeqd->dwRetryInterval;
	speqdModified.dwFlags				= pspeqd->dwFlags;
	speqdModified.pvContext				= pDP8SimCommand;
	//speqdModified.hCommand				= pspeqd->hCommand;				// filled in by real SP
	//speqdModified.dwCommandDescriptor	= pspeqd->dwCommandDescriptor;	// filled in by real SP


	//
	// Start the enumeration via the real service provider.
	//
	hr = this->m_pDP8SP->EnumQuery(&speqdModified);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed starting the enumeration via the real SP object (0x%p)!",
			this->m_pDP8SP);


		DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
		pDP8SimCommand->Release();

		goto Failure;
	}

	
	DNASSERT(speqdModified.hCommand != NULL);


	//
	// Save the output parameters.
	//
	pDP8SimCommand->SetRealSPCommand(speqdModified.hCommand,
									speqdModified.dwCommandDescriptor);


	//
	// Generate the output parameters for the caller.
	//
	pspeqd->hCommand			= (HANDLE) pDP8SimCommand;
	pspeqd->dwCommandDescriptor	= 0;


Exit:

	//
	// Give up local reference.
	//
	if (pDP8SimCommand != NULL)
	{
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;
	}

	/*
	if (speqdModified.pAddressDeviceInfo != NULL)
	{
		speqdModified.pAddressDeviceInfo->Release();
		speqdModified.pAddressDeviceInfo = NULL;
	}

	if (speqdModified.pAddressHost != NULL)
	{
		speqdModified.pAddressHost->Release();
		speqdModified.pAddressHost = NULL;
	}
	*/

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
} // CDP8SimSP::EnumQuery





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::EnumRespond"
//=============================================================================
// CDP8SimSP::EnumRespond
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPENUMRESPONDDATA psperd	- Pointer to parameter block to use when
//									responding.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::EnumRespond(PSPENUMRESPONDDATA psperd)
{
	HRESULT						hr;
	SPENUMRESPONDDATA			sperdModified;
	ENUMQUERYDATAWRAPPER *		pEnumQueryDataWrapper;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, psperd);


	ZeroMemory(&sperdModified, sizeof(sperdModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(psperd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG



	//
	// Prepare a command object.
	//

	ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
	CommandFPMContext.dwType			= CMDTYPE_ENUMRESPOND;
	CommandFPMContext.pvUserContext		= psperd->pvContext;

	pDP8SimCommand = g_pFPOOLCommand->Get(&CommandFPMContext);
	if (pDP8SimCommand == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);



	//
	// Copy the parameter block, modifying as necessary.
	//

	//
	// We wrapped the enum query data structure, get the original object.
	//
	pEnumQueryDataWrapper = ENUMQUERYEVENTWRAPPER_FROM_SPIEQUERY(psperd->pQuery);

	DNASSERT(*((DWORD*) (&pEnumQueryDataWrapper->m_Sig)) == 0x57455145);	// 0x57 0x45 0x51 0x45 = 'WEQE' = 'EQEW' in Intel order

	sperdModified.pQuery = pEnumQueryDataWrapper->pOriginalQuery;


	//
	// Add a reference for the enum respond command.
	//
	pDP8SimCommand->AddRef();


	sperdModified.pBuffers				= psperd->pBuffers;
	sperdModified.dwBufferCount			= psperd->dwBufferCount;
	sperdModified.dwFlags				= psperd->dwFlags;
	sperdModified.pvContext				= pDP8SimCommand;
	//sperdModified.hCommand				= psperd->hCommand;				// filled in by real SP
	//sperdModified.dwCommandDescriptor	= psperd->dwCommandDescriptor;	// filled in by real SP


	//
	// Respond to the enumeration via the real service provider.
	//
	hr = this->m_pDP8SP->EnumRespond(&sperdModified);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed responding to enumeration via the real SP object (0x%p)!",
			this->m_pDP8SP);


		DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
		pDP8SimCommand->Release();

		goto Failure;
	}

	
	DNASSERT(sperdModified.hCommand != NULL);


	//
	// Save the output parameters.
	//
	pDP8SimCommand->SetRealSPCommand(sperdModified.hCommand,
									sperdModified.dwCommandDescriptor);


	//
	// Generate the output parameters for the caller.
	//
	psperd->hCommand			= (HANDLE) pDP8SimCommand;
	psperd->dwCommandDescriptor	= 0;


Exit:

	//
	// Give up local reference.
	//
	if (pDP8SimCommand != NULL)
	{
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimSP::EnumRespond





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::CancelCommand"
//=============================================================================
// CDP8SimSP::CancelCommand
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	HANDLE hCommand				- Handle to command to cancel.
//	DWORD dwCommandDescriptor	- Unique descriptor of command to cancel.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::CancelCommand(HANDLE hCommand, DWORD dwCommandDescriptor)
{
	HRESULT				hr;
	CDP8SimCommand *	pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, %u)",
		this, hCommand, dwCommandDescriptor);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(hCommand != NULL);
	DNASSERT(dwCommandDescriptor == 0);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	pDP8SimCommand = (CDP8SimCommand*) hCommand;
	DNASSERT(pDP8SimCommand->IsValidObject());


	//
	// Cancel the real service provider's command.
	//
	hr = this->m_pDP8SP->CancelCommand(pDP8SimCommand->GetRealSPCommand(),
										pDP8SimCommand->GetRealSPCommandDescriptor());
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed cancelling real SP object (0x%p)'s command!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}



//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::CancelCommand





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::CreateGroup"
//=============================================================================
// CDP8SimSP::CreateGroup
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPCREATEGROUPDATA pspcgd	- Pointer to parameter block to use when
//									creating the group.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::CreateGroup(PSPCREATEGROUPDATA pspcgd)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspcgd);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspcgd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	DNASSERT(! "The CreateGroup function should never be called!");
	hr = E_NOTIMPL;



//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::CreateGroup





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::DeleteGroup"
//=============================================================================
// CDP8SimSP::DeleteGroup
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPDELETEGROUPDATA pspdgd	- Pointer to parameter block to use when
//									deleting the group.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::DeleteGroup(PSPDELETEGROUPDATA pspdgd)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspdgd);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspdgd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	DNASSERT(! "The DeleteGroup function should never be called!");
	hr = E_NOTIMPL;



//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::DeleteGroup





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::AddToGroup"
//=============================================================================
// CDP8SimSP::AddToGroup
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPADDTOGROUPDATA pspatgd	- Pointer to parameter block to use when adding
//									to the group.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::AddToGroup(PSPADDTOGROUPDATA pspatgd)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspatgd);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspatgd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	DNASSERT(! "The AddToGroup function should never be called!");
	hr = E_NOTIMPL;



//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::AddToGroup





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::RemoveFromGroup"
//=============================================================================
// CDP8SimSP::RemoveFromGroup
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPREMOVEFROMGROUPDATA psprfgd	- Pointer to parameter block to use when
//										removing from the group.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::RemoveFromGroup(PSPREMOVEFROMGROUPDATA psprfgd)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, psprfgd);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(psprfgd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	DNASSERT(! "The RemoveGroup function should never be called!");
	hr = E_NOTIMPL;



//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::RemoveFromGroup





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::GetCaps"
//=============================================================================
// CDP8SimSP::GetCaps
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPGETCAPSDATA pspgcd	- Pointer to parameter block to use when retrieving
//								the capabilities.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::GetCaps(PSPGETCAPSDATA pspgcd)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspgcd);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspgcd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Retrieve the capabilities of the real service provider.
	//
	hr = this->m_pDP8SP->GetCaps(pspgcd);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed getting caps on real SP object (0x%p)!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::GetCaps





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::SetCaps"
//=============================================================================
// CDP8SimSP::SetCaps
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPSETCAPSDATA pspscd	- Pointer to parameter block to use when setting
//								the capabilities.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::SetCaps(PSPSETCAPSDATA pspscd)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspscd);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspscd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Store the capabilities of the real service provider.
	//
	hr = this->m_pDP8SP->SetCaps(pspscd);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed setting caps on real SP object (0x%p)!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::SetCaps





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::ReturnReceiveBuffers"
//=============================================================================
// CDP8SimSP::ReturnReceiveBuffers
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPRECEIVEDBUFFER psprb		- Array of receive buffers to return.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::ReturnReceiveBuffers(PSPRECEIVEDBUFFER psprb)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, psprb);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(psprb != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Return the receive buffers to the real service provider.
	//
	hr = this->m_pDP8SP->ReturnReceiveBuffers(psprb);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed returning receive buffers to real SP object (0x%p)!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}



//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::ReturnReceiveBuffers





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::GetAddressInfo"
//=============================================================================
// CDP8SimSP::GetAddressInfo
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPGETADDRESSINFODATA pspgaid	- Pointer to parameter block to use when
//										getting address info.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::GetAddressInfo(PSPGETADDRESSINFODATA pspgaid)
{
	HRESULT					hr;
	CDP8SimEndpoint *		pDP8SimEndpoint;
	SPGETADDRESSINFODATA	spgaidModified;
	//IDirectPlay8Address *	pDP8AddressModified = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspgaid);


	ZeroMemory(&spgaidModified, sizeof(spgaidModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspgaid != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	pDP8SimEndpoint = (CDP8SimEndpoint*) pspgaid->hEndpoint;
	DNASSERT(pDP8SimEndpoint->IsValidObject());



	//
	// Initialize return value to NULL.
	//
	pspgaid->pAddress = NULL;


	//
	// If the endpoint is disconnecting, don't try to get the address info.
	//
	pDP8SimEndpoint->Lock();
	if (pDP8SimEndpoint->IsDisconnecting())
	{
		pDP8SimEndpoint->Unlock();

		DPFX(DPFPREP, 0, "Endpoint 0x%p is disconnecting, can't get address info!",
			pDP8SimEndpoint);

		hr = DPNERR_NOCONNECTION;
		goto Failure;
	}
	pDP8SimEndpoint->Unlock();



	//
	// Copy the parameter block, modifying as necessary.
	//
	spgaidModified.hEndpoint	= pDP8SimEndpoint->GetRealSPEndpoint();
	spgaidModified.pAddress		= NULL;										// filled in by real SP
	spgaidModified.Flags		= pspgaid->Flags;



	//
	// Get real service provider address info.
	//
	hr = this->m_pDP8SP->GetAddressInfo(&spgaidModified);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed getting real SP object (0x%p) address info!",
			this->m_pDP8SP);
		goto Failure;
	}



	/*
	//
	// Duplicate the address.
	//
	hr = pspgaid->pAddress->Duplicate(&pDP8AddressModified);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate address!");
		goto Failure;
	}


	//
	// Modify it so that the SP uses our GUID.
	//
	hr = pDP8AddressModified->SetSP(&CLSID_DP8SP_DP8SIM);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change address' SP!");
		goto Failure;
	}


	//
	// Return the modified SP to the user.
	//
	pspgaid->pAddress->Release();
	pspgaid->pAddress = pDP8AddressModified;
	pDP8AddressModified = NULL;
	*/

	//
	// Return the address directly to the user.
	//
	pspgaid->pAddress = spgaidModified.pAddress;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	/*
	if (pDP8AddressModified != NULL)
	{
		pDP8AddressModified->Release();
		pDP8AddressModified = NULL;
	}
	*/

	if (pspgaid->pAddress != NULL)
	{
		pspgaid->pAddress->Release();
		pspgaid->pAddress = NULL;
	}

	goto Exit;
} // CDP8SimSP::GetAddressInfo





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::IsApplicationSupported"
//=============================================================================
// CDP8SimSP::IsApplicationSupported
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPISAPPLICATIONSUPPORTEDDATA pspiasd	- Pointer to parameter block to use
//												when checking application
//												support.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::IsApplicationSupported(PSPISAPPLICATIONSUPPORTEDDATA pspiasd)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspiasd);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspiasd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Check availability with the real service provider.
	//
	hr = this->m_pDP8SP->IsApplicationSupported(pspiasd);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed checking if application is supported by real SP object (0x%p)!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::IsApplicationSupported





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::EnumAdapters"
//=============================================================================
// CDP8SimSP::EnumAdapters
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPENUMADAPTERSDATA pspead	- Pointer to parameter block to use when
//									enumerating the adapters.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::EnumAdapters(PSPENUMADAPTERSDATA pspead)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspead);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspead != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Enumerate the adapters available to the real service provider.
	//
	hr = this->m_pDP8SP->EnumAdapters(pspead);
	if (hr != DPN_OK)
	{
		if (hr != DPNERR_BUFFERTOOSMALL)
		{
			DPFX(DPFPREP, 0, "Failed enumerating adapters on real SP object (0x%p)!",
				this->m_pDP8SP);
		}

		//
		// Continue...
		//
	}


	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;
} // CDP8SimSP::EnumAdapters





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::ProxyEnumQuery"
//=============================================================================
// CDP8SimSP::ProxyEnumQuery
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPPROXYENUMQUERYDATA psppeqd	- Pointer to parameter block to use when
//										proxying the enum query.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::ProxyEnumQuery(PSPPROXYENUMQUERYDATA psppeqd)
{
	HRESULT					hr;
	SPPROXYENUMQUERYDATA	sppeqdModified;
	ENUMQUERYDATAWRAPPER *	pEnumQueryDataWrapper;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, psppeqd);


	ZeroMemory(&sppeqdModified, sizeof(sppeqdModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(psppeqd != NULL);
	DNASSERT(psppeqd->pDestinationAdapter != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG



	//
	// Copy the parameter block, modifying as necessary.
	//

	/*
	//
	// Duplicate the host address.
	//
	hr = psppeqd->pDestinationAdapter->Duplicate(&sppeqdModified.pDestinationAdapter);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate destination adapter address!");
		goto Failure;
	}


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = sppeqdModified.pDestinationAdapter->SetSP(&this->m_guidSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change destination adapter address' SP!");
		goto Failure;
	}
	*/
	sppeqdModified.pDestinationAdapter	= psppeqd->pDestinationAdapter;


	//
	// We wrapped the enum query data structure, get the original object.
	//
	pEnumQueryDataWrapper = ENUMQUERYEVENTWRAPPER_FROM_SPIEQUERY(psppeqd->pIncomingQueryData);

	DNASSERT(*((DWORD*) (&pEnumQueryDataWrapper->m_Sig)) == 0x57455145);	// 0x57 0x45 0x51 0x45 = 'WEQE' = 'EQEW' in Intel order

	sppeqdModified.pIncomingQueryData	= pEnumQueryDataWrapper->pOriginalQuery;


	sppeqdModified.dwFlags				= psppeqd->dwFlags;


	//
	// Proxy the enum query through the real service provider.
	//
	hr = this->m_pDP8SP->ProxyEnumQuery(&sppeqdModified);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed proxying enum query through real SP object (0x%p)!",
			this->m_pDP8SP);
		goto Failure;
	}



Exit:

	/*
	if (sppeqdModified.pDestinationAdapter != NULL)
	{
		sppeqdModified.pDestinationAdapter->Release();
		sppeqdModified.pDestinationAdapter = NULL;
	}
	*/

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimSP::ProxyEnumQuery






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::InitializeObject"
//=============================================================================
// CDP8SimSP::InitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Sets up the object for use like the constructor, but may
//				fail with OUTOFMEMORY.  Should only be called by class factory
//				creation routine.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK			- Initialization was successful.
//	E_OUTOFMEMORY	- There is not enough memory to initialize.
//=============================================================================
HRESULT CDP8SimSP::InitializeObject(void)
{
	HRESULT		hr;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);

	DNASSERT(this->IsValidObject());


	//
	// Create the lock.
	// 

	if (! DNInitializeCriticalSection(&this->m_csLock))
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Don't allow critical section reentry.
	//
	DebugSetCriticalSectionRecursionCount(&this->m_csLock, 0);


	hr = S_OK;

Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimSP::InitializeObject






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::UninitializeObject"
//=============================================================================
// CDP8SimSP::UninitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Cleans up the object like the destructor, mostly to balance
//				InitializeObject.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::UninitializeObject(void)
{
	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	DNASSERT(this->IsValidObject());


	DNDeleteCriticalSection(&this->m_csLock);


	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CDP8SimSP::UninitializeObject






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::PerformDelayedSend"
//=============================================================================
// CDP8SimSP::PerformDelayedSend
//-----------------------------------------------------------------------------
//
// Description: Performs a delayed send.
//
// Arguments:
//	PVOID pvContext		- Pointer to context to use when performing delayed
//							send.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::PerformDelayedSend(PVOID const pvContext)
{
	HRESULT						hr;
	CDP8SimSend *				pDP8SimSend = (CDP8SimSend*) pvContext;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p)", this, pvContext);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pvContext != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG



	//
	// Prepare a command object.
	//

	ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
	CommandFPMContext.dwType			= CMDTYPE_SENDDATA_DELAYED;
	CommandFPMContext.pvUserContext		= pDP8SimSend;

	pDP8SimCommand = g_pFPOOLCommand->Get(&CommandFPMContext);
	if (pDP8SimCommand == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't allocate memory for new command object!");
	}
	else
	{
		DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);


		//
		// Add a reference for the send command.
		//
		pDP8SimCommand->AddRef();

		pDP8SimSend->SetSendDataBlockContext(pDP8SimCommand);


		//
		// Issue the send to the real SP.  Essentially ignore the return value
		// since we already indicated completion to the upper layer.
		//
		hr = this->m_pDP8SP->SendData(pDP8SimSend->GetSendDataBlockPtr());
		if (FAILED(hr))
		{
			DPFX(DPFPREP, 0, "Failed sending delayed data (err = 0x%lx)!", hr);


			DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
			pDP8SimCommand->Release();


			//
			// Remove the send counter.
			//
			this->DecSendsPending();


			DPFX(DPFPREP, 7, "Releasing aborted send 0x%p.", pDP8SimSend);
			pDP8SimSend->Release();


			//
			// Continue.
			//
		}
		else
		{
			DNASSERT(hr == DPNSUCCESS_PENDING);


			//
			// Save the output parameters returned by the SP.
			//
			pDP8SimCommand->SetRealSPCommand(pDP8SimSend->GetSendDataBlockCommand(),
											pDP8SimSend->GetSendDataBlockCommandDescriptor());
		}


		//
		// Give up local reference.
		//
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;
	}


	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CDP8SimSP::PerformDelayedSend






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::PerformDelayedReceive"
//=============================================================================
// CDP8SimSP::PerformDelayedReceive
//-----------------------------------------------------------------------------
//
// Description: Performs a delayed receive.
//
// Arguments:
//	PVOID pvContext		- Pointer to context to use when performing delayed
//							receive.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::PerformDelayedReceive(PVOID const pvContext)
{
	HRESULT				hr;
	CDP8SimReceive *	pDP8SimReceive = (CDP8SimReceive*) pvContext;
	IDP8SPCallback *	pDP8SPCallback;
	SPIE_DATA *			pData;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p)", this, pvContext);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pvContext != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	pDP8SPCallback = this->m_pDP8SimCB->GetRealCallbackInterface();
	pData = pDP8SimReceive->GetReceiveDataBlockPtr();


	//
	// Indicate the event to the real callback interface.
	//

	DPFX(DPFPREP, 2, "Indicating event SPEV_DATA (message = 0x%p) to interface 0x%p.",
		pData, pDP8SPCallback);

	hr = pDP8SPCallback->IndicateEvent(SPEV_DATA, pData);

	DPFX(DPFPREP, 2, "Returning from event SPEV_DATA [0x%lx].", hr);


	//
	// Update the statistics.
	//
	this->m_DP8SimIPC.IncrementStatReceiveTransmitted();


	//
	// Return the buffers to the real SP unless the user wanted to keep them.
	//
	if (hr != DPNSUCCESS_PENDING)
	{
		DPFX(DPFPREP, 8, "Returning receive data 0x%p to real SP 0x%p.",
			pData->pReceivedData, this->m_pDP8SP);


		hr = this->m_pDP8SP->ReturnReceiveBuffers(pData->pReceivedData);
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Failed returning receive buffers 0x%p (err = 0x%lx)!  Ignoring.",
				pData->pReceivedData, hr);

			//
			// Ignore failure.
			//
		}
	}
	else
	{
		DPFX(DPFPREP, 8, "Callback interface 0x%p keeping receive data 0x%p.",
			pDP8SPCallback, pData->pReceivedData);

		//
		// Our user needs to return the buffers at some point.
		//
	}


	//
	// Remove the receive counter.
	//
	this->DecReceivesPending();


	//
	// Release the delayed receive reference.
	//
	DPFX(DPFPREP, 7, "Releasing receive 0x%p.", pDP8SimReceive);
	pDP8SimReceive->Release();
	pDP8SimReceive = NULL;


	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CDP8SimSP::PerformDelayedReceive





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::IncSendsPending"
//=============================================================================
// CDP8SimSP::IncSendsPending
//-----------------------------------------------------------------------------
//
// Description: Increments the counter tracking the number of sends pending.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::IncSendsPending(void)
{
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);

	//
	// Increment the counters.
	//
	this->m_dwSendsPending++;

	DPFX(DPFPREP, 5, "(0x%p) Sends now pending = %u.",
		this, this->m_dwSendsPending);


	DNLeaveCriticalSection(&this->m_csLock);
} // CDP8SimSP::IncSendsPending





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::DecSendsPending"
//=============================================================================
// CDP8SimSP::DecSendsPending
//-----------------------------------------------------------------------------
//
// Description: Decrements the counter tracking the number of sends pending.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::DecSendsPending(void)
{
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);

	//
	// Decrement the counters.
	//
	DNASSERT(this->m_dwSendsPending > 0);
	this->m_dwSendsPending--;


	DPFX(DPFPREP, 5, "(0x%p) Sends now pending = %u.",
		this, this->m_dwSendsPending);

	//
	// If that was the last send pending and someone is waiting for all of them
	// to complete, notify him.
	//
	if ((this->m_dwSendsPending == 0) &&
		(this->m_hLastPendingSendEvent != NULL))
	{
		DPFX(DPFPREP, 1, "Last pending send, notifying waiting thread.");

		SetEvent(this->m_hLastPendingSendEvent);
	}


	DNLeaveCriticalSection(&this->m_csLock);
} // CDP8SimSP::DecSendsPending





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::IncReceivesPending"
//=============================================================================
// CDP8SimSP::IncReceivesPending
//-----------------------------------------------------------------------------
//
// Description: Increments the counter tracking the number of receives pending.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::IncReceivesPending(void)
{
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);

	//
	// Increment the counters.
	//
	this->m_dwReceivesPending++;

	DPFX(DPFPREP, 5, "(0x%p) Receives now pending = %u.",
		this, this->m_dwReceivesPending);


	DNLeaveCriticalSection(&this->m_csLock);
} // CDP8SimSP::IncReceivesPending





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::DecReceivesPending"
//=============================================================================
// CDP8SimSP::DecReceivesPending
//-----------------------------------------------------------------------------
//
// Description: Decrements the counter tracking the number of receives pending.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::DecReceivesPending(void)
{
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);

	//
	// Decrement the counters.
	//
	DNASSERT(this->m_dwReceivesPending > 0);
	this->m_dwReceivesPending--;


	DPFX(DPFPREP, 5, "(0x%p) Receives now pending = %u.",
		this, this->m_dwReceivesPending);

	/*
	//
	// If that was the last receive pending and someone is waiting for all of
	// them to complete, notify him.
	//
	if ((this->m_dwReceivesPending == 0) &&
		(this->m_hLastPendingReceiveEvent != NULL))
	{
		DPFX(DPFPREP, 1, "Last pending receive, notifying waiting thread.");

		SetEvent(this->m_hLastPendingReceiveEvent);
	}
	*/


	DNLeaveCriticalSection(&this->m_csLock);
} // CDP8SimSP::DecReceivesPending





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::GetLatency"
//=============================================================================
// CDP8SimSP::GetLatency
//-----------------------------------------------------------------------------
//
// Description: Retrieves a latency vlaue based on the given bandwidth, data
//				size, and random latency values.
//
// Arguments:
//	DWORD dwBandwidthBPS	- Bandwidth settings.
//	DWORD dwDataSize		- Size of packet being sent/received.
//	DWORD dwMinRandMS		- Minimum random latency value.
//	DWORD dwMaxRandMS		- Maximum random latency value.
//
// Returns: DWORD
//=============================================================================
DWORD CDP8SimSP::GetLatency(const DWORD dwBandwidthBPS,
							const DWORD dwDataSize,
							const DWORD dwMinRandMS,
							const DWORD dwMaxRandMS)
{
	DWORD	dwLatency;
	double	dTransferTime;


	//
	// Generate a random latency value.
	//
	dwLatency = dwMinRandMS;
	if (dwMinRandMS != dwMaxRandMS)
	{
		dwLatency += GetGlobalRand() % (dwMaxRandMS - dwMinRandMS);
	}
	

	//
	// If there's a bandwidth limit, find out how many seconds it will take to
	// transfer the data and add it to the random latency.
	//
	if (dwBandwidthBPS != 0)
	{
		dTransferTime = dwDataSize;
		dTransferTime /= dwBandwidthBPS;
		dTransferTime *= 1000;


		//
		// Round the value down to an even number of milliseconds.
		//
		dwLatency += (DWORD) dTransferTime;
	}


	return dwLatency;
} // CDP8SimSP::GetLatency




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::CoCreateInstanceRedirected"
//=============================================================================
// CDP8SimSP::CoCreateInstanceRedirected
//-----------------------------------------------------------------------------
//
// Description: Decrements the counter of the number of sends pending.
//
// Arguments:
//	REFCLSID rclsid			- Class identifier (CLSID) of the object.
//	REFIID riid				- Reference to the identifier of the interface.
//	PVOID * ppv				- Address of output variable that receives the
//								interface pointer requested in riid.
//	HMODULE * phInstance	- Place to store module handle for instance's
//								owning DLL.
//
// Returns: HRESULT
//=============================================================================
HRESULT CDP8SimSP::CoCreateInstanceRedirected(REFCLSID rclsid,
											REFIID riid,
											PVOID * ppv,
											HMODULE * phInstance)
{
	HRESULT					hr;
	WCHAR					wszInProcServer32[_MAX_PATH];
	CRegistry				RegObject;
	WCHAR					wszRealPath[_MAX_PATH];
	char					szRealPath[_MAX_PATH];
	DWORD					dwLength;
	PFN_DLLGETCLASSOBJECT	pfnDllGetClassObject;
	IClassFactory *			pClassFactory = NULL;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, 0x%p)",
		this, rclsid, riid, ppv, phInstance);


	//
	// NULL out the pointers in case we fail.
	//
	(*ppv) = NULL;
	(*phInstance) = NULL;


	//
	// Open the SP's COM object information key.
	//

	swprintf(wszInProcServer32, L"CLSID\\{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}\\InProcServer32",
			this->m_guidSP.Data1, this->m_guidSP.Data2, this->m_guidSP.Data3, 
			this->m_guidSP.Data4[0], this->m_guidSP.Data4[1],
			this->m_guidSP.Data4[2], this->m_guidSP.Data4[3],
			this->m_guidSP.Data4[4], this->m_guidSP.Data4[5],
			this->m_guidSP.Data4[6], this->m_guidSP.Data4[7]);	

	if (! RegObject.Open(HKEY_CLASSES_ROOT, wszInProcServer32, FALSE, FALSE, FALSE))
	{
		DPFX(DPFPREP, 0, "Could not open SP InProcServer32 key!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// Read the location of the original DLL.
	//
	dwLength = _MAX_PATH;
	if (! RegObject.ReadString(DP8SIM_REG_REALSPDLL, wszRealPath, &dwLength))
	{
		DPFX(DPFPREP, 0, "Couldn't read real SP's DLL location (\"%S\", assuming DP8Sim was not enabled)!",
			DP8SIM_REG_REALSPDLL);
		hr = DP8SIMERR_NOTENABLEDFORSP;
		goto Failure;
	}


	RegObject.Close();


	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		(*phInstance) = LoadLibraryW(wszRealPath);
		if ((*phInstance) == NULL)
		{
			hr = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't load real SP's DLL \"%S\"!", wszRealPath);
			goto Failure;
		}
	}
	else
	{
		dwLength = _MAX_PATH;
		hr = STR_WideToAnsi(wszRealPath, -1, szRealPath, &dwLength);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't convert real SP's DLL path (\"%S\") from Unicode to ANSI!",
				wszRealPath);
			goto Failure;
		}

		(*phInstance) = LoadLibraryA(szRealPath);
		if ((*phInstance) == NULL)
		{
			hr = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't load real SP's DLL \"%s\"!", szRealPath);
			goto Failure;
		}
	}

	pfnDllGetClassObject = (PFN_DLLGETCLASSOBJECT) GetProcAddress((*phInstance),
																"DllGetClassObject");
	if (pfnDllGetClassObject == NULL)
	{
		hr = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't load real SP's DLL \"%s\"!");
		goto Failure;
	}


	//
	// Call the COM entry point to retrieve the class factory object.
	//
	hr = pfnDllGetClassObject(rclsid,
							IID_IClassFactory,
							(PVOID*) (&pClassFactory));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't get real SP's class factory object!");
		goto Failure;
	}


	//
	// Create the real object instance.
	//
	hr = pClassFactory->CreateInstance(NULL, riid, ppv);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't get real SP's interface!");
		goto Failure;
	}


Exit:

	if (pClassFactory != NULL)
	{
		pClassFactory->Release();
		pClassFactory = NULL;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning [0x%lx]", this, hr);

	return hr;


Failure:

	if ((*phInstance) != NULL)
	{
		FreeLibrary((*phInstance));
		(*phInstance);
	}

	//
	// RegObject is automatically closed by it's destructor, if necessary.
	//

	goto Exit;
} // CDP8SimSP::CoCreateInstanceRedirected
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\ui\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=dp8simui


#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=PROGRAM
UMENTRY=winmain
UMTYPE=windows


!if "$(DPLAY_PCH)" != "off"
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dp8simuii.h
PRECOMPILED_PCH=dp8simuii.pch
PRECOMPILED_OBJ=dp8simuii.obj
!endif

#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#

#
# 04/10/2000 - allows for addition of BoundsChecker, etc
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           ..\..\guids\obj$(BUILD_ALT_DIR)\*\guids.lib \
           ..\..\..\..\dnet\common\obj$(BUILD_ALT_DIR)\*\common.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib \
	   $(BASEDIR)\public\sdk\lib\*\oleaut32.lib \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib


#
# If a debug mode is selected, make sure we include the defines to make the
# logging code operate.
#
!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif


#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=$(DXROOT)\inc;..\..\..\..\dnet\inc;..\..\..\..\dnet\common;..\..\inc;..\


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= ..\dp8simui.rc \
	 ..\dp8simuimain.cpp


#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /D_DLL

USE_NOLIBS=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\ui\dp8simuimain.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dp8simuimain.cpp
 *
 *  Content:	DP8SIM UI executable entry point.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simuii.h"



//=============================================================================
// Defines
//=============================================================================
#define MAX_RESOURCE_STRING_LENGTH			_MAX_PATH

#define IDS_PROMPTCAPTION_ENABLE_DEFAULT	IDS_PROMPTCAPTION_ENABLE_TCPIPREPLACEMENT
#define IDS_PROMPTCAPTION_DISABLE_DEFAULT	IDS_PROMPTCAPTION_DISABLE_TCPIPREPLACEMENT
#define IDS_PROMPTTEXT_ENABLE_DEFAULT		IDS_PROMPTTEXT_ENABLE_TCPIPREPLACEMENT
#define IDS_PROMPTTEXT_DISABLE_DEFAULT		IDS_PROMPTTEXT_DISABLE_TCPIPREPLACEMENT
#define IDS_FRIENDLYNAME_DEFAULT			IDS_FRIENDLYNAME_TCPIPREPLACEMENT
#define DEFAULT_DP8SP_CLSID					CLSID_DP8SP_TCPIP



//=============================================================================
// Structures
//=============================================================================
typedef struct _BUILTINSETTING
{
	UINT				uiNameStringResourceID;	// resource ID of name string
	WCHAR *				pwszName;				// pointer to name string
	DP8SIM_PARAMETERS	dp8spSend;				// send DP8Sim settings
	DP8SIM_PARAMETERS	dp8spReceive;			// receive DP8Sim settings
} BUILTINSETTING, * PBUILTINSETTING;



//=============================================================================
// Dynamically loaded function prototypes
//=============================================================================
typedef HRESULT (WINAPI * PFN_DLLREGISTERSERVER)(void);




//=============================================================================
// Prototypes
//=============================================================================
HRESULT InitializeApplication(const HINSTANCE hInstance,
							const LPSTR lpszCmdLine,
							const int iShowCmd);

HRESULT CleanupApplication(const HINSTANCE hInstance);

HRESULT PromptUserToEnableControl(const HINSTANCE hInstance,
								const BOOL fEnable,
								BOOL * const pfUserResponse);

HRESULT InitializeUserInterface(const HINSTANCE hInstance,
								const int iShowCmd);

HRESULT CleanupUserInterface(void);

void DoErrorBox(const HINSTANCE hInstance,
				const UINT uiCaptionStringRsrcID,
				const UINT uiTextStringRsrcID);



LPARAM CALLBACK MainWindowDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


HRESULT LoadAndAllocString(HINSTANCE hInstance, UINT uiResourceID, WCHAR ** pwszString);





//=============================================================================
// Globals
//=============================================================================
HWND				g_hWndMainWindow = NULL;
IDP8SimControl *	g_pDP8SimControl = NULL;
BOOL				g_fEnabledControlForDefaultSP = FALSE;

BUILTINSETTING		g_BuiltInSettings[] = 
{
	{ IDS_SETTING_NONE, NULL,					// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwBandwidthBPS
			0,									// dp8spSend.dwPacketLossPercent
			0,									// dp8spSend.dwMinLatencyMS
			0									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwBandwidthBPS
			0,									// dp8spReceive.dwPacketLossPercent
			0,									// dp8spReceive.dwMinLatencyMS
			0									// dp8spReceive.dwMaxLatencyMS
		}
	},

	{ IDS_SETTING_336MODEM, NULL,				// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			4000,								// dp8spSend.dwBandwidthBPS
			2,									// dp8spSend.dwPacketLossPercent
			50,									// dp8spSend.dwMinLatencyMS
			70									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			4000,								// dp8spReceive.dwBandwidthBPS
			2,									// dp8spReceive.dwPacketLossPercent
			50,									// dp8spReceive.dwMinLatencyMS
			70									// dp8spReceive.dwMaxLatencyMS
		}
	},

	{ IDS_SETTING_56KMODEM, NULL,				// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			4000,								// dp8spSend.dwBandwidthBPS
			2,									// dp8spSend.dwPacketLossPercent
			50,									// dp8spSend.dwMinLatencyMS
			70									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			7000,								// dp8spReceive.dwBandwidthBPS
			2,									// dp8spReceive.dwPacketLossPercent
			50,									// dp8spReceive.dwMinLatencyMS
			70									// dp8spReceive.dwMaxLatencyMS
		}
	},

	{ IDS_SETTING_256KBPSDSL, NULL,				// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			32000,								// dp8spSend.dwBandwidthBPS
			1,									// dp8spSend.dwPacketLossPercent
			30,									// dp8spSend.dwMinLatencyMS
			35									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			32000,								// dp8spReceive.dwBandwidthBPS
			1,									// dp8spReceive.dwPacketLossPercent
			30,									// dp8spReceive.dwMinLatencyMS
			35									// dp8spReceive.dwMaxLatencyMS
		}
	},

	{ IDS_SETTING_HIGHPACKETLOSS, NULL,			// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwBandwidthBPS
			10,									// dp8spSend.dwPacketLossPercent
			0,									// dp8spSend.dwMinLatencyMS
			0									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwBandwidthBPS
			10,									// dp8spReceive.dwPacketLossPercent
			0,									// dp8spReceive.dwMinLatencyMS
			0									// dp8spReceive.dwMaxLatencyMS
		}
	},

	{ IDS_SETTING_HIGHLATENCYVARIANCE, NULL,	// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwBandwidthBPS
			0,									// dp8spSend.dwPacketLossPercent
			100,								// dp8spSend.dwMinLatencyMS
			400									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwBandwidthBPS
			0,									// dp8spReceive.dwPacketLossPercent
			100,								// dp8spReceive.dwMinLatencyMS
			400									// dp8spReceive.dwMaxLatencyMS
		}
	},

	//
	// Custom must always be the last item.
	//
	{ IDS_SETTING_CUSTOM, NULL,					// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwBandwidthBPS
			0,									// dp8spSend.dwPacketLossPercent
			0,									// dp8spSend.dwMinLatencyMS
			0									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwBandwidthBPS
			0,									// dp8spReceive.dwPacketLossPercent
			0,									// dp8spReceive.dwMinLatencyMS
			0									// dp8spReceive.dwMaxLatencyMS
		}
	}
};






#undef DPF_MODNAME
#define DPF_MODNAME "WinMain"
//=============================================================================
// WinMain
//-----------------------------------------------------------------------------
//
// Description: Executable entry point.
//
// Arguments:
//	HINSTANCE hInstance		- Handle to current application instance.
//	HINSTANCE hPrevInstance	- Handle to previous application instance.
//	LPSTR lpszCmdLine		- Command line string for application.
//	int iShowCmd			- Show state of window.
//
// Returns: HRESULT
//=============================================================================
int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int iShowCmd)
{
	HRESULT		hr;
	HRESULT		hrTemp;
	MSG			msg;


	DPFX(DPFPREP, 2, "===> Parameters: (0x%p, 0x%p, \"%s\", %i)",
		hInstance, hPrevInstance, lpszCmdLine, iShowCmd);
	

	//
	// Initialize the application
	//
	hr = InitializeApplication(hInstance, lpszCmdLine, iShowCmd);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize the application!");
		goto Exit;
	}


	//
	// Do the Windows message loop until we're told to quit.
	//
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	//
	// Retrieve the result code for the window closing.
	//
	hr = (HRESULT) msg.wParam;
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Window closed with failure (err = 0x%lx)!", hr);
	} // end if (failure)



	//
	// Cleanup the application
	//
	hrTemp = CleanupApplication(hInstance);
	if (hrTemp != S_OK)
	{
		DPFX(DPFPREP, 0, "Failed cleaning up the application (err = 0x%lx)!", hrTemp);

		if (hr == S_OK)
		{
			hr = hrTemp;
		}

		//
		// Continue.
		//
	}


Exit:


	DPFX(DPFPREP, 2, "<=== Returning [0x%lx]", hr);

	return hr;
} // WinMain





#undef DPF_MODNAME
#define DPF_MODNAME "InitializeApplication"
//=============================================================================
// InitializeApplication
//-----------------------------------------------------------------------------
//
// Description: Initializes the application.
//
// Arguments:
//	HINSTANCE hInstance		- Handle to current application instance.
//	LPSTR lpszCmdLine		- Command line string for application.
//	int iShowCmd			- Show state of window.
//
// Returns: HRESULT
//=============================================================================
HRESULT InitializeApplication(const HINSTANCE hInstance,
							const LPSTR lpszCmdLine,
							const int iShowCmd)
{
	HRESULT					hr = S_OK;
	BOOL					fOSIndirectionInitted = FALSE;
	BOOL					fCOMInitted = FALSE;
	HMODULE					hDP8SIM = NULL;
	PFN_DLLREGISTERSERVER	pfnDllRegisterServer;
	WCHAR *					pwszFriendlyName = NULL;
	BOOL					fEnabledControlForSP = FALSE;


	DPFX(DPFPREP, 5, "Parameters: (0x%p, \"%s\", %i)",
		hInstance, lpszCmdLine, iShowCmd);
	

	//
	// Attempt to initialize the OS abstraction layer.
	//
	if (! DNOSIndirectionInit())
	{
		DPFX(DPFPREP, 0, "Failed to initialize OS indirection layer!");
		hr = E_FAIL;
		goto Failure;
	}

	fOSIndirectionInitted = TRUE;


	//
	// Attempt to initialize COM.
	//
	hr = CoInitialize(NULL);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Failed to initialize COM!");
		goto Failure;
	}

	fCOMInitted = TRUE;


	//
	// Attempt to create a DP8Sim control object.
	//
	hr = CoCreateInstance(CLSID_DP8SimControl,
						NULL,
						CLSCTX_INPROC_SERVER,
						IID_IDP8SimControl,
						(LPVOID*) (&g_pDP8SimControl));

	if (hr == REGDB_E_CLASSNOTREG)
	{
		//
		// The object wasn't registered.  Attempt to load the DLL and manually
		// register it.
		//

		hDP8SIM = LoadLibrary("dp8sim.dll");
		if (hDP8SIM == NULL)
		{
			hr = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't load \"dp8sim.dll\"!");
			goto Failure;
		}


		pfnDllRegisterServer = (PFN_DLLREGISTERSERVER) GetProcAddress(hDP8SIM,
																	"DllRegisterServer");
		if (pfnDllRegisterServer == NULL)
		{
			hr = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't get \"DllRegisterServer\" function from DP8Sim DLL!");
			goto Failure;
		}


		//
		// Register the DLL.
		//
		hr = pfnDllRegisterServer();
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't register DP8Sim DLL!");
			goto Failure;
		}


		FreeLibrary(hDP8SIM);
		hDP8SIM = NULL;


		//
		// Try to create the DP8Sim control object again.
		//
		hr = CoCreateInstance(CLSID_DP8SimControl,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_IDP8SimControl,
							(LPVOID*) (&g_pDP8SimControl));
	}

	if (hr != S_OK)
	{
		//
		// Some error prevented creation of the object.
		//
		DPFX(DPFPREP, 0, "Failed creating DP8Sim Control object (err = 0x%lx)!", hr);

		DoErrorBox(hInstance,
					IDS_ERROR_CAPTION_COULDNTCREATEDP8SIMCONTROL,
					IDS_ERROR_TEXT_COULDNTCREATEDP8SIMCONTROL);

		goto Failure;
	}


	//
	// If we're here, we successfully created the object.
	//
	DPFX(DPFPREP, 1, "Successfully created DP8Sim Control object 0x%p.",
		&g_pDP8SimControl);


	//
	// Initialize the control object.
	//
	hr = g_pDP8SimControl->Initialize(0);
	if (hr != DP8SIM_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize DP8Sim Control object!");

		g_pDP8SimControl->Release();
		g_pDP8SimControl = NULL;

		goto Failure;
	}


	//
	// Check whether control has already been enabled or not.
	//
	hr = g_pDP8SimControl->GetControlEnabledForSP(&DEFAULT_DP8SP_CLSID,
												&g_fEnabledControlForDefaultSP,
												0);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't check if control is enabled for default SP (err = 0x%lx)!",
			hr);
		goto Failure;
	}


	//
	// If control has not been enabled yet, see if we can enable it.
	//
	if (! g_fEnabledControlForDefaultSP)
	{
		//
		// Prompt the user to see if we're allowed to enable it.
		//
		hr = PromptUserToEnableControl(hInstance, TRUE, &g_fEnabledControlForDefaultSP);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't prompt user to enable control of default SP (err = 0x%lx)!",
				hr);
			goto Failure;
		}


		//
		// If we are now allowed, enable it.
		//
		if (g_fEnabledControlForDefaultSP)
		{
			//
			// Load the replacement friendly name for the service provider.
			//
			hr = LoadAndAllocString(hInstance,
									IDS_FRIENDLYNAME_DEFAULT,
									&pwszFriendlyName);
			if (FAILED(hr))
			{
				DPFX(DPFPREP, 0, "Couldn't load default SP replacement friendly name (err = 0x%lx)!", hr);
				goto Failure;
			}


			//
			// Enable control of the default service provider.
			//
			hr = g_pDP8SimControl->EnableControlForSP(&DEFAULT_DP8SP_CLSID,
													pwszFriendlyName,
													0);
			if (hr != DP8SIM_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't enable DP8Sim Control of default SP!");
				goto Failure;
			}

			fEnabledControlForSP = TRUE;


			DNFree(pwszFriendlyName);
			pwszFriendlyName = NULL;
		}
		else
		{
			//
			// We're still not allowed to enable SP.
			//
			// Note: if you change this behavior to allow the UI to be
			// displayed even when control is not enabled, you'll hit an assert
			// (see MainWindowDlgProc).
			//
			DPFX(DPFPREP, 0, "Not allowed to enable control for default SP, exiting.");
			hr = DP8SIMERR_NOTENABLEDFORSP;
			goto Failure;
		}
	}
	else
	{
		DPFX(DPFPREP, 1, "Control for default SP already enabled.");
	}



	//
	// Initialize the user interface.
	//
	hr = InitializeUserInterface(hInstance, iShowCmd);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Failed initializing user interface!");
		goto Failure;
	}


Exit:

	DPFX(DPFPREP, 5, "Returning [0x%lx]", hr);

	return hr;


Failure:

	if (hDP8SIM != NULL)
	{
		FreeLibrary(hDP8SIM);
		hDP8SIM = NULL;
	}

	if (pwszFriendlyName != NULL)
	{
		DNFree(pwszFriendlyName);
		pwszFriendlyName = NULL;
	}

	if (g_pDP8SimControl != NULL)
	{
		if (fEnabledControlForSP)
		{
			g_pDP8SimControl->DisableControlForSP(&DEFAULT_DP8SP_CLSID, 0);
			fEnabledControlForSP = FALSE;
		}

		g_pDP8SimControl->Close(0);	// ignore error

		g_pDP8SimControl->Release();
		g_pDP8SimControl = NULL;
	}

	if (fCOMInitted)
	{
		CoUninitialize();
		fCOMInitted = FALSE;
	}

	if (fOSIndirectionInitted)
	{
		DNOSIndirectionDeinit();
		fOSIndirectionInitted = FALSE;
	}

	goto Exit;
} // InitializeApplication





#undef DPF_MODNAME
#define DPF_MODNAME "CleanupApplication"
//=============================================================================
// CleanupApplication
//-----------------------------------------------------------------------------
//
// Description: Cleans up the application.
//
// Arguments:
//	HINSTANCE hInstance		- Handle to current application instance.
//
// Returns: HRESULT
//=============================================================================
HRESULT CleanupApplication(const HINSTANCE hInstance)
{
	HRESULT		hr = S_OK;
	HRESULT		temphr;


	DPFX(DPFPREP, 5, "Enter");


	//
	// If control is still enabled, ask if the user wants to disable it.
	//
	if (g_fEnabledControlForDefaultSP)
	{
		//
		// Prompt the user to see if we're allowed to enable it.
		//
		temphr = PromptUserToEnableControl(hInstance, FALSE, &g_fEnabledControlForDefaultSP);
		if (temphr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't prompt user to disable control of default SP (err = 0x%lx)!",
				temphr);

			if (hr != S_OK)
			{
				hr = temphr;
			}

			//
			// Continue...
			//
		}
		else
		{
			//
			// Disable control of the default SP, if allowed.
			//
			if (! g_fEnabledControlForDefaultSP)
			{
				temphr = g_pDP8SimControl->DisableControlForSP(&DEFAULT_DP8SP_CLSID, 0);
				if (temphr != DP8SIM_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't disable DP8Sim control of default SP (err = 0x%lx)!",
						temphr);

					if (hr != S_OK)
					{
						hr = temphr;
					}

					//
					// Continue...
					//
				}
			}
		}
	}


	//
	// Free the control object interface.
	//
	temphr = g_pDP8SimControl->Close(0);
	if (temphr != DP8SIM_OK)
	{
		DPFX(DPFPREP, 0, "Failed closing DP8Sim Control object (err = 0x%lx)!",
			temphr);

		if (hr != S_OK)
		{
			hr = temphr;
		}

		//
		// Continue...
		//
	}

	g_pDP8SimControl->Release();
	g_pDP8SimControl = NULL;
	

	//
	// Cleanup the user interface.
	//
	temphr = CleanupUserInterface();
	if (temphr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't cleanup user interface (err = 0x%lx)!", temphr);

		if (hr != S_OK)
		{
			hr = temphr;
		}

		//
		// Continue...
		//
	}


	CoUninitialize();

	DNOSIndirectionDeinit();



	DPFX(DPFPREP, 5, "Returning [0x%lx]", hr);

	return hr;
} // CleanupApplication





#undef DPF_MODNAME
#define DPF_MODNAME "PromptUserToEnableControl()"
//=============================================================================
// PromptUserToEnableControl
//-----------------------------------------------------------------------------
//
// Description: Asks the user whether control should be enabled or disabled for
//				the default SP.
//
// Arguments:
//	HINSTANCE hInstance		- Handle to current application instance.
//	BOOL fEnable			- TRUE to prompt to enable, FALSE to prompt to
//								disable.
//	BOOL * pfUserResponse	- Place to store TRUE if user indicated control
//								should be enabled, FALSE if user indicated
//								control should be disabled.
//
// Returns: HRESULT
//=============================================================================
HRESULT PromptUserToEnableControl(const HINSTANCE hInstance,
								const BOOL fEnable,
								BOOL * const pfUserResponse)
{
	HRESULT		hr = S_OK;
	WCHAR *		pwszCaption = NULL;
	WCHAR *		pwszText = NULL;
	DWORD		dwStringLength;
	char *		pszCaption = NULL;
	char *		pszText = NULL;
	int			iReturn;


	DPFX(DPFPREP, 6, "Parameters: (0x%p, %i, 0x%p)",
		hInstance, fEnable, pfUserResponse);


	//
	// Load the dialog caption string.
	//
	hr = LoadAndAllocString(hInstance,
							((fEnable) ? IDS_PROMPTCAPTION_ENABLE_DEFAULT : IDS_PROMPTCAPTION_DISABLE_DEFAULT),
							&pwszCaption);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Couldn't load en/disable-prompt caption (err = 0x%lx)!", hr);
		goto Failure;
	}


	//
	// Load the dialog text string.
	//
	hr = LoadAndAllocString(hInstance,
							((fEnable) ? IDS_PROMPTTEXT_ENABLE_DEFAULT : IDS_PROMPTTEXT_DISABLE_DEFAULT),
							&pwszText);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Couldn't load en/disable-prompt text (err = 0x%lx)!", hr);
		goto Failure;
	}


	//
	// Convert the text to ANSI, if required, otherwise display the Unicode
	// message box.
	//
	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		//
		// Convert caption string to ANSI.
		//

		dwStringLength = wcslen(pwszCaption) + 1;

		pszCaption = (char*) DNMalloc(dwStringLength);
		if (pszCaption == NULL)
		{
			hr = DP8SIMERR_OUTOFMEMORY;
			goto Failure;
		}

		hr = STR_WideToAnsi(pwszCaption, dwStringLength, pszCaption, &dwStringLength);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't convert wide string to ANSI (err = 0x%lx)!", hr);
			goto Failure;
		}


		//
		// Convert caption string to ANSI.
		//

		dwStringLength = wcslen(pwszText) + 1;

		pszText = (char*) DNMalloc(dwStringLength);
		if (pszText == NULL)
		{
			hr = DP8SIMERR_OUTOFMEMORY;
			goto Failure;
		}

		hr = STR_WideToAnsi(pwszText, dwStringLength, pszText, &dwStringLength);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't convert wide string to ANSI (err = 0x%lx)!", hr);
			goto Failure;
		}


		iReturn = MessageBoxA(NULL,
							pszText,
							pszCaption,
							((fEnable) ? (MB_OKCANCEL | MB_ICONEXCLAMATION) : (MB_YESNO | MB_ICONQUESTION)));

		DNFree(pszText);
		pszText = NULL;

		DNFree(pszCaption);
		pszCaption = NULL;
	}
	else
	{
		iReturn = MessageBoxW(NULL,
							pwszText,
							pwszCaption,
							((fEnable) ? (MB_OKCANCEL | MB_ICONEXCLAMATION) : (MB_YESNO | MB_ICONQUESTION)));
	}

	DNFree(pwszText);
	pwszText = NULL;

	DNFree(pwszCaption);
	pwszCaption = NULL;


	switch (iReturn)
	{
		case IDOK:
		case IDYES:
		{
			//
			// User allowed the change.
			//
			DPFX(DPFPREP, 1, "User allowed en/disabling DP8Sim control.");
			(*pfUserResponse) = fEnable;
			break;
		}

		case IDCANCEL:
		case IDNO:
		{
			//
			// User denied the change.
			//
			DPFX(DPFPREP, 1, "User did not want to en/disable DP8Sim control.");
			(*pfUserResponse) = ! fEnable;
			break;
		}

		default:
		{
			//
			// Something bad happened.
			//

			hr = GetLastError();

			DPFX(DPFPREP, 0, "Got unexpected return value %i when displaying message box (err = 0x%lx)!",
				iReturn, hr);

			if (hr == S_OK)
			{
				hr = E_FAIL;
			}

			goto Failure;
			break;
		}
	}
	
	
	//
	// Success.
	//
	hr = S_OK;


Exit:

	DPFX(DPFPREP, 6, "Returning [0x%lx]", hr);

	return hr;


Failure:

	if (pszText != NULL)
	{
		DNFree(pszText);
		pszText = NULL;
	}

	if (pszCaption != NULL)
	{
		DNFree(pszCaption);
		pszCaption = NULL;
	}

	if (pwszText != NULL)
	{
		DNFree(pwszText);
		pwszText = NULL;
	}

	if (pwszCaption != NULL)
	{
		DNFree(pwszCaption);
		pwszCaption = NULL;
	}

	goto Exit;
} // PromptUserToEnableControl





#undef DPF_MODNAME
#define DPF_MODNAME "InitializeUserInterface()"
//=============================================================================
// InitializeUserInterface
//-----------------------------------------------------------------------------
//
// Description: Prepares the user interface.
//
// Arguments:
//	HINSTANCE hInstance		- Handle to current application instance.
//	int iShowCmd			- Show state of window.
//
// Returns: HRESULT
//=============================================================================
HRESULT InitializeUserInterface(HINSTANCE hInstance, int iShowCmd)
{
	HRESULT		hr = S_OK;
	DWORD		dwTemp;
	WNDCLASSEX	wcex;


	DPFX(DPFPREP, 6, "Parameters: (0x%p, %i)", hInstance, iShowCmd);


	//
	// Load the names of all the built-in settings.
	//
	for(dwTemp = 0; dwTemp < (sizeof(g_BuiltInSettings) / sizeof(BUILTINSETTING)); dwTemp++)
	{
		hr = LoadAndAllocString(hInstance,
								g_BuiltInSettings[dwTemp].uiNameStringResourceID,
								&(g_BuiltInSettings[dwTemp].pwszName));
		if (hr != DP8SIM_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't load and allocate built-in setting name #%u!",
				dwTemp);
			goto Failure;
		}
	}


	/*
	//
	// Setup common controls (we need the listview item).
	//
	InitCommonControls();
	*/


	//
	// Register the main window class
	//
	ZeroMemory(&wcex, sizeof (WNDCLASSEX));
	wcex.cbSize = sizeof(wcex);
	GetClassInfoEx(NULL, WC_DIALOG, &wcex);
	wcex.lpfnWndProc = MainWindowDlgProc;
	wcex.hInstance = hInstance;
	wcex.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
	wcex.lpszMenuName = NULL;
	wcex.lpszClassName = WINDOWCLASS_MAIN;
	wcex.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
	if (! RegisterClassEx(&wcex))
	{
		hr = GetLastError();

		DPFX(DPFPREP, 0, "Couldn't register main window class (err = 0x%lx)!", hr);

		if (hr == S_OK)
			hr = E_FAIL;

		goto Failure;
	}


	//
	// Create the main window.
	//
	g_hWndMainWindow = CreateDialog(hInstance,
									MAKEINTRESOURCE(IDD_MAIN),
									NULL,
									(DLGPROC) MainWindowDlgProc);
	if (g_hWndMainWindow == NULL)
	{
		hr = GetLastError();

		DPFX(DPFPREP, 0, "Couldn't create window (err = 0x%lx)!", hr);

		if (hr == S_OK)
			hr = E_FAIL;

		goto Failure;
	}

	
	UpdateWindow(g_hWndMainWindow);
	ShowWindow(g_hWndMainWindow, iShowCmd);


Exit:

	DPFX(DPFPREP, 6, "Returning [0x%lx]", hr);

	return hr;


Failure:


	//
	// Free the names of all the built-in settings that got loaded.
	//
	for(dwTemp = 0; dwTemp < (sizeof(g_BuiltInSettings) / sizeof(BUILTINSETTING)); dwTemp++)
	{
		if (g_BuiltInSettings[dwTemp].pwszName != NULL)
		{
			DNFree(g_BuiltInSettings[dwTemp].pwszName);
			g_BuiltInSettings[dwTemp].pwszName = NULL;
		}
	}

	goto Exit;
} // InitializeUserInterface





#undef DPF_MODNAME
#define DPF_MODNAME "CleanupUserInterface()"
//=============================================================================
// CleanupUserInterface
//-----------------------------------------------------------------------------
//
// Description: Cleans up the user interface.
//
// Arguments: None.
//
// Returns: HRESULT
//=============================================================================
HRESULT CleanupUserInterface(void)
{
	HRESULT		hr = S_OK;
	DWORD		dwTemp;


	DPFX(DPFPREP, 6, "Enter");


	//
	// Free the names of all the built-in settings that got loaded.
	//
	for(dwTemp = 0; dwTemp < (sizeof(g_BuiltInSettings) / sizeof(BUILTINSETTING)); dwTemp++)
	{
		DNFree(g_BuiltInSettings[dwTemp].pwszName);
		g_BuiltInSettings[dwTemp].pwszName = NULL;
	}


	DPFX(DPFPREP, 6, "Returning [0x%lx]", hr);

	return (hr);
} // CleanupUserInterface





#undef DPF_MODNAME
#define DPF_MODNAME "DoErrorBox()"
//=============================================================================
// DoErrorBox
//-----------------------------------------------------------------------------
//
// Description: Loads error strings from the given resources, and displays an
//				error dialog with that text.
//
// Arguments:
//	HINSTANCE hInstance				- Handle to current application instance.
//	UINT uiCaptionStringRsrcID		- ID of caption string resource.
//	UINT uiTextStringRsrcID			- ID of text string resource.
//
// Returns: None.
//=============================================================================
void DoErrorBox(const HINSTANCE hInstance,
				const UINT uiCaptionStringRsrcID,
				const UINT uiTextStringRsrcID)
{
	HRESULT		hr;
	WCHAR *		pwszCaption = NULL;
	WCHAR *		pwszText = NULL;
	DWORD		dwStringLength;
	char *		pszCaption = NULL;
	char *		pszText = NULL;
	int			iReturn;


	DPFX(DPFPREP, 6, "Parameters: (0x%p, %u, %u)",
		hInstance, uiCaptionStringRsrcID, uiTextStringRsrcID);


	//
	// Load the dialog caption string.
	//
	hr = LoadAndAllocString(hInstance, uiCaptionStringRsrcID, &pwszCaption);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Couldn't load caption string (err = 0x%lx)!", hr);
		goto Exit;
	}


	//
	// Load the dialog text string.
	//
	hr = LoadAndAllocString(hInstance, uiTextStringRsrcID, &pwszText);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Couldn't load text string (err = 0x%lx)!", hr);
		goto Exit;
	}


	//
	// Convert the text to ANSI, if required, otherwise display the Unicode
	// message box.
	//
	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		//
		// Convert caption string to ANSI.
		//

		dwStringLength = wcslen(pwszCaption) + 1;

		pszCaption = (char*) DNMalloc(dwStringLength);
		if (pszCaption == NULL)
		{
			DPFX(DPFPREP, 0, "Couldn't allocate memory for caption string!");
			goto Exit;
		}

		hr = STR_WideToAnsi(pwszCaption, dwStringLength, pszCaption, &dwStringLength);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't convert wide string to ANSI (err = 0x%lx)!", hr);
			goto Exit;
		}


		//
		// Convert caption string to ANSI.
		//

		dwStringLength = wcslen(pwszText) + 1;

		pszText = (char*) DNMalloc(dwStringLength);
		if (pszText == NULL)
		{
			DPFX(DPFPREP, 0, "Couldn't allocate memory for text string!");
			goto Exit;
		}

		hr = STR_WideToAnsi(pwszText, dwStringLength, pszText, &dwStringLength);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't convert wide string to ANSI (err = 0x%lx)!", hr);
			goto Exit;
		}


		iReturn = MessageBoxA(NULL,
							pszText,
							pszCaption,
							(MB_OK | MB_ICONERROR));

		DNFree(pszText);
		pszText = NULL;

		DNFree(pszCaption);
		pszCaption = NULL;
	}
	else
	{
		iReturn = MessageBoxW(NULL,
							pwszText,
							pwszCaption,
							(MB_OK | MB_ICONERROR));
	}

	if (iReturn != IDOK)
	{
		//
		// Something bad happened.
		//

		hr = GetLastError();

		DPFX(DPFPREP, 0, "Got unexpected return value %i when displaying message box (err = 0x%lx)!",
			iReturn, hr);
	}
	

Exit:

	if (pszText != NULL)
	{
		DNFree(pszText);
		pszText = NULL;
	}

	if (pszCaption != NULL)
	{
		DNFree(pszCaption);
		pszCaption = NULL;
	}

	if (pwszText != NULL)
	{
		DNFree(pwszText);
		pwszText = NULL;
	}

	if (pwszCaption != NULL)
	{
		DNFree(pwszCaption);
		pwszCaption = NULL;
	}


	DPFX(DPFPREP, 6, "Leave");
} // DoErrorBox





#undef DPF_MODNAME
#define DPF_MODNAME "MainWindowDlgProc()"
//=============================================================================
// MainWindowDlgProc
//-----------------------------------------------------------------------------
//
// Description: Main dialog window message handling.
//
// Arguments:
//	HWND hWnd		Window handle.
//	UINT uMsg		Message identifier.
//	WPARAM wParam	Depends on message.
//	LPARAM lParam	Depends on message.
//
// Returns: Depends on message.
//=============================================================================
LPARAM CALLBACK MainWindowDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	HRESULT				hr;
	//HMENU				hSysMenu;
	HWND				hWndSubItem;
	int					iIndex;
	DP8SIM_PARAMETERS	dp8spSend;
	DP8SIM_PARAMETERS	dp8spReceive;
	DP8SIM_STATISTICS	dp8ssSend;
	DP8SIM_STATISTICS	dp8ssReceive;
	char				szNumber[32];


	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			/*
			LVCOLUMN	lvc;


			//
			// Disable 'maximize' and 'size' on the system menu.
			//
			hSysMenu = GetSystemMenu(hWnd, FALSE);
	
			EnableMenuItem(hSysMenu, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);
			EnableMenuItem(hSysMenu, SC_SIZE, MF_BYCOMMAND | MF_GRAYED);
			*/


			//
			// Fill in the list of built-in settings.
			//
			hWndSubItem = GetDlgItem(hWnd, IDCB_SETTINGS);
			for(iIndex = 0; iIndex < (sizeof(g_BuiltInSettings) / sizeof(BUILTINSETTING)); iIndex++)
			{
				if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
				{
					SendMessageW(hWndSubItem,
								CB_INSERTSTRING,
								(WPARAM) -1,
								(LPARAM) g_BuiltInSettings[iIndex].pwszName);
				}
				else
				{
					char *		pszName;
					DWORD		dwNameSize;
					

					dwNameSize = wcslen(g_BuiltInSettings[iIndex].pwszName) + 1;

					pszName = (char*) DNMalloc(dwNameSize);
					if (pszName != NULL)
					{
						hr = STR_WideToAnsi(g_BuiltInSettings[iIndex].pwszName,
											-1,
											pszName,
											&dwNameSize);
						if (hr == DPN_OK)
						{
							SendMessageA(hWndSubItem,
										CB_INSERTSTRING,
										(WPARAM) -1,
										(LPARAM) pszName);
						}
						else
						{
							SendMessageA(hWndSubItem,
										CB_INSERTSTRING,
										(WPARAM) -1,
										(LPARAM) "???");
						}

						DNFree(pszName);
					}
					else
					{
						SendMessageA(hWndSubItem,
									CB_INSERTSTRING,
									(WPARAM) -1,
									(LPARAM) "???");
					}
				}
			}

			//
			// Select the last item.
			//
			SendMessage(hWndSubItem, CB_SETCURSEL, (WPARAM) (iIndex - 1), 0);


			//
			// Enable the editable items depending on whether control is
			// enabled or not.
			// Currently, this application does not allow you to see the main
			// UI without having it enabled (see InitializeApplication).
			//
			DNASSERT(g_fEnabledControlForDefaultSP);

			EnableWindow(GetDlgItem(hWnd, IDX_SETTINGS), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDCB_SETTINGS), g_fEnabledControlForDefaultSP);

			EnableWindow(GetDlgItem(hWnd, IDX_SETTINGS_SEND), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDS_SETTINGS_SEND_BANDWIDTH), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDE_SETTINGS_SEND_BANDWIDTH), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDS_SETTINGS_SEND_DROP), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDE_SETTINGS_SEND_DROP), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDS_SETTINGS_SEND_MINLATENCY), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MINLATENCY), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDS_SETTINGS_SEND_MAXLATENCY), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MAXLATENCY), g_fEnabledControlForDefaultSP);

			EnableWindow(GetDlgItem(hWnd, IDX_SETTINGS_RECV), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDS_SETTINGS_RECV_BANDWIDTH), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDE_SETTINGS_RECV_BANDWIDTH), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDS_SETTINGS_RECV_DROP), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDE_SETTINGS_RECV_DROP), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDS_SETTINGS_RECV_MINLATENCY), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MINLATENCY), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDS_SETTINGS_RECV_MAXLATENCY), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MAXLATENCY), g_fEnabledControlForDefaultSP);


			EnableWindow(GetDlgItem(hWnd, IDX_STATS), g_fEnabledControlForDefaultSP);
			//EnableWindow(GetDlgItem(hWnd, IDCB_STATS), g_fEnabledControlForDefaultSP);

			EnableWindow(GetDlgItem(hWnd, IDX_STATS_SEND), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDS_STATS_SEND_XMIT), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDT_STATS_SEND_XMIT), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDS_STATS_SEND_DROP), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDT_STATS_SEND_DROP), g_fEnabledControlForDefaultSP);

			EnableWindow(GetDlgItem(hWnd, IDX_STATS_RECV), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDS_STATS_RECV_XMIT), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDT_STATS_RECV_XMIT), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDS_STATS_RECV_DROP), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDT_STATS_RECV_DROP), g_fEnabledControlForDefaultSP);

			EnableWindow(GetDlgItem(hWnd, IDB_REFRESH), g_fEnabledControlForDefaultSP);
			EnableWindow(GetDlgItem(hWnd, IDB_CLEAR), g_fEnabledControlForDefaultSP);


			if (g_fEnabledControlForDefaultSP)
			{
				//
				// Retrieve the current settings.
				//

				ZeroMemory(&dp8spSend, sizeof(dp8spSend));
				dp8spSend.dwSize = sizeof(dp8spSend);

				ZeroMemory(&dp8spReceive, sizeof(dp8spReceive));
				dp8spReceive.dwSize = sizeof(dp8spReceive);

				hr = g_pDP8SimControl->GetAllParameters(&dp8spSend, &dp8spReceive, 0);
				if (hr != DP8SIM_OK)
				{
					DPFX(DPFPREP, 0, "Getting all parameters failed (err = 0x%lx)!", hr);
				}
				else
				{
					//
					// Write the values to the window.
					//

					wsprintf(szNumber, "%u", dp8spSend.dwBandwidthBPS);
					SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_BANDWIDTH), szNumber);

					wsprintf(szNumber, "%u", dp8spSend.dwPacketLossPercent);
					SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_DROP), szNumber);

					wsprintf(szNumber, "%u", dp8spSend.dwMinLatencyMS);
					SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MINLATENCY), szNumber);

					wsprintf(szNumber, "%u", dp8spSend.dwMaxLatencyMS);
					SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MAXLATENCY), szNumber);

					wsprintf(szNumber, "%u", dp8spReceive.dwBandwidthBPS);
					SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_BANDWIDTH), szNumber);

					wsprintf(szNumber, "%u", dp8spReceive.dwPacketLossPercent);
					SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_DROP), szNumber);

					wsprintf(szNumber, "%u", dp8spReceive.dwMinLatencyMS);
					SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MINLATENCY), szNumber);

					wsprintf(szNumber, "%u", dp8spReceive.dwMaxLatencyMS);
					SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MAXLATENCY), szNumber);
				}


				//
				// Retrieve the current statistics.
				//

				ZeroMemory(&dp8ssSend, sizeof(dp8ssSend));
				dp8ssSend.dwSize = sizeof(dp8ssSend);

				ZeroMemory(&dp8ssReceive, sizeof(dp8ssReceive));
				dp8ssReceive.dwSize = sizeof(dp8ssReceive);

				hr = g_pDP8SimControl->GetAllStatistics(&dp8ssSend, &dp8ssReceive, 0);
				if (hr != DP8SIM_OK)
				{
					DPFX(DPFPREP, 0, "Getting all statistics failed (err = 0x%lx)!", hr);
				}
				else
				{
					//
					// Write the values to the window.
					//

					wsprintf(szNumber, "%u", dp8ssSend.dwTransmitted);
					SetWindowText(GetDlgItem(hWnd, IDT_STATS_SEND_XMIT), szNumber);

					wsprintf(szNumber, "%u", dp8ssSend.dwDropped);
					SetWindowText(GetDlgItem(hWnd, IDT_STATS_SEND_DROP), szNumber);

					wsprintf(szNumber, "%u", dp8ssReceive.dwTransmitted);
					SetWindowText(GetDlgItem(hWnd, IDT_STATS_RECV_XMIT), szNumber);

					wsprintf(szNumber, "%u", dp8ssReceive.dwDropped);
					SetWindowText(GetDlgItem(hWnd, IDT_STATS_RECV_DROP), szNumber);
				}
			}
			else
			{
				//
				// Make it even more obvious that functionality is not
				// available.
				//
				SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_BANDWIDTH), "???");
				SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_DROP), "???");
				SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MINLATENCY), "???");
				SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MAXLATENCY), "???");

				SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_BANDWIDTH), "???");
				SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_DROP), "???");
				SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MINLATENCY), "???");
				SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MAXLATENCY), "???");

				SetWindowText(GetDlgItem(hWnd, IDT_STATS_SEND_XMIT), "???");
				SetWindowText(GetDlgItem(hWnd, IDT_STATS_SEND_DROP), "???");
				SetWindowText(GetDlgItem(hWnd, IDT_STATS_RECV_XMIT), "???");
				SetWindowText(GetDlgItem(hWnd, IDT_STATS_RECV_DROP), "???");
			}
			break;
		}

		case WM_SIZE:
		{
			/*
			//
			// Fix a bug in the windows dialog handler.
			//
			if ((wParam == SIZE_RESTORED) || (wParam == SIZE_MINIMIZED))
			{
				hSysMenu = GetSystemMenu(hWnd, FALSE);

				EnableMenuItem(hSysMenu, SC_MINIMIZE, MF_BYCOMMAND | (wParam == SIZE_RESTORED) ? MF_ENABLED : MF_GRAYED);
				EnableMenuItem(hSysMenu, SC_RESTORE, MF_BYCOMMAND | (wParam == SIZE_MINIMIZED) ? MF_ENABLED : MF_GRAYED);
			}
			*/
			break;
		}

		case WM_CLOSE:
		{
			//
			// Save the result code for how we quit.
			//
			hr = (HRESULT) wParam;


			DPFX(DPFPREP, 1, "Closing main window (hresult = 0x%lx).", hr);

			PostQuitMessage(hr);
			break;
		}

		case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
				case IDCB_SETTINGS:
				{
					//
					// If the settings selection has been modified, update the
					// data with the new settings (if control is enabled).
					//
					if ((HIWORD(wParam) == CBN_SELCHANGE) && (g_fEnabledControlForDefaultSP))
					{
						//
						// Find out what is now selected.  Casting is okay,
						// there should not be more than an int's worth of
						// built-in items in 64-bit.
						//
						iIndex = (int) SendMessage(GetDlgItem(hWnd, IDCB_SETTINGS),
													CB_GETCURSEL,
													0,
													0);

						//
						// Only use the index if it's valid.
						//
						if ((iIndex >= 0) && (iIndex < (sizeof(g_BuiltInSettings) / sizeof(BUILTINSETTING))))
						{
							//
							// Copy in the item's settings.
							//
							memcpy(&dp8spSend, &g_BuiltInSettings[iIndex].dp8spSend, sizeof(dp8spSend));
							memcpy(&dp8spReceive, &g_BuiltInSettings[iIndex].dp8spReceive, sizeof(dp8spReceive));


							//
							// If it's the custom item, use the current
							// settings.
							//
							if (iIndex == ((sizeof(g_BuiltInSettings) / sizeof(BUILTINSETTING)) - 1))
							{
								//
								// Retrieve the current settings.
								//

								ZeroMemory(&dp8spSend, sizeof(dp8spSend));
								dp8spSend.dwSize = sizeof(dp8spSend);

								ZeroMemory(&dp8spReceive, sizeof(dp8spReceive));
								dp8spReceive.dwSize = sizeof(dp8spReceive);

								hr = g_pDP8SimControl->GetAllParameters(&dp8spSend,
																		&dp8spReceive,
																		0);
								if (hr != DP8SIM_OK)
								{
									DPFX(DPFPREP, 0, "Getting all parameters failed (err = 0x%lx)!", hr);

									//
									// Oh well, just use whatever we have.
									//
								}
							}


							//
							// Write the values to the window.
							//

							wsprintf(szNumber, "%u", dp8spSend.dwBandwidthBPS);
							SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_BANDWIDTH), szNumber);

							wsprintf(szNumber, "%u", dp8spSend.dwPacketLossPercent);
							SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_DROP), szNumber);

							wsprintf(szNumber, "%u", dp8spSend.dwMinLatencyMS);
							SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MINLATENCY), szNumber);

							wsprintf(szNumber, "%u", dp8spSend.dwMaxLatencyMS);
							SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MAXLATENCY), szNumber);


							wsprintf(szNumber, "%u", dp8spReceive.dwBandwidthBPS);
							SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_BANDWIDTH), szNumber);

							wsprintf(szNumber, "%u", dp8spReceive.dwPacketLossPercent);
							SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_DROP), szNumber);

							wsprintf(szNumber, "%u", dp8spReceive.dwMinLatencyMS);
							SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MINLATENCY), szNumber);

							wsprintf(szNumber, "%u", dp8spReceive.dwMaxLatencyMS);
							SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MAXLATENCY), szNumber);


							//
							// The apply and revert buttons got enabled
							// automatically when we set the edit boxes'
							// values.
							//
							//EnableWindow(GetDlgItem(hWnd, IDB_APPLY), TRUE);
							//EnableWindow(GetDlgItem(hWnd, IDB_REVERT), TRUE);


							//
							// Reselect the item that got us here, since
							// setting the edit boxes' values automatically
							// selected the "Custom" item.
							//
							SendMessage(GetDlgItem(hWnd, IDCB_SETTINGS),
										CB_SETCURSEL,
										(WPARAM) iIndex,
										0);
						}
						else
						{
							DPFX(DPFPREP, 0, "Settings selection is invalid (%i)!",
								iIndex);
						}
					}

					break;
				}

				case IDE_SETTINGS_SEND_BANDWIDTH:
				case IDE_SETTINGS_SEND_DROP:
				case IDE_SETTINGS_SEND_MINLATENCY:
				case IDE_SETTINGS_SEND_MAXLATENCY:

				case IDE_SETTINGS_RECV_BANDWIDTH:
				case IDE_SETTINGS_RECV_DROP:
				case IDE_SETTINGS_RECV_MINLATENCY:
				case IDE_SETTINGS_RECV_MAXLATENCY:
				{
					//
					// If the edit boxes have been modified, enable the Apply
					// and Revert buttons (if control is enabled and the data
					// actually changed).
					//
					if ((HIWORD(wParam) == EN_UPDATE) && (g_fEnabledControlForDefaultSP))
					{
						//
						// Retrieve the current settings.
						//

						ZeroMemory(&dp8spSend, sizeof(dp8spSend));
						dp8spSend.dwSize = sizeof(dp8spSend);

						ZeroMemory(&dp8spReceive, sizeof(dp8spReceive));
						dp8spReceive.dwSize = sizeof(dp8spReceive);

						hr = g_pDP8SimControl->GetAllParameters(&dp8spSend, &dp8spReceive, 0);
						if (hr != DP8SIM_OK)
						{
							DPFX(DPFPREP, 0, "Getting all parameters failed (err = 0x%lx)!", hr);
						}
						else
						{
							BOOL	fModified;
								
							
							ZeroMemory(szNumber, sizeof(szNumber));
							fModified = FALSE;


							//
							// Enable the buttons if any data changed.
							//

							GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_BANDWIDTH), szNumber, 32);
							if (dp8spSend.dwBandwidthBPS != (DWORD) atoi(szNumber))
							{
								fModified = TRUE;
							}

							GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_DROP), szNumber, 32);
							if (dp8spSend.dwPacketLossPercent != (DWORD) atoi(szNumber))
							{
								fModified = TRUE;
							}

							GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MINLATENCY), szNumber, 32);
							if (dp8spSend.dwMinLatencyMS != (DWORD) atoi(szNumber))
							{
								fModified = TRUE;
							}

							GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MAXLATENCY), szNumber, 32);
							if (dp8spSend.dwMaxLatencyMS != (DWORD) atoi(szNumber))
							{
								fModified = TRUE;
							}


							GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_BANDWIDTH), szNumber, 32);
							if (dp8spReceive.dwBandwidthBPS != (DWORD) atoi(szNumber))
							{
								fModified = TRUE;
							}

							GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_DROP), szNumber, 32);
							if (dp8spReceive.dwPacketLossPercent != (DWORD) atoi(szNumber))
							{
								fModified = TRUE;
							}

							GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MINLATENCY), szNumber, 32);
							if (dp8spReceive.dwMinLatencyMS != (DWORD) atoi(szNumber))
							{
								fModified = TRUE;
							}

							GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MAXLATENCY), szNumber, 32);
							if (dp8spReceive.dwMaxLatencyMS != (DWORD) atoi(szNumber))
							{
								fModified = TRUE;
							}


							EnableWindow(GetDlgItem(hWnd, IDB_APPLY), fModified);
							EnableWindow(GetDlgItem(hWnd, IDB_REVERT), fModified);
						}

						//
						// Select the "custom" settings item, which must be the
						// last item.
						//
						SendMessage(GetDlgItem(hWnd, IDCB_SETTINGS),
									CB_SETCURSEL,
									(WPARAM) ((sizeof(g_BuiltInSettings) / sizeof(BUILTINSETTING)) - 1),
									0);
					}

					break;
				}

				case IDB_APPLY:
				{
					ZeroMemory(szNumber, sizeof(szNumber));


					//
					// Retrieve the send settings from the window.
					//

					ZeroMemory(&dp8spSend, sizeof(dp8spSend));
					dp8spSend.dwSize					= sizeof(dp8spSend);

					GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_BANDWIDTH), szNumber, 32);
					dp8spSend.dwBandwidthBPS			= (DWORD) atoi(szNumber);

					GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_DROP), szNumber, 32);
					dp8spSend.dwPacketLossPercent		= (DWORD) atoi(szNumber);
					if (dp8spSend.dwPacketLossPercent > 100)
					{
						dp8spSend.dwPacketLossPercent = 100;
						SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_DROP), "100");
					}

					GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MINLATENCY), szNumber, 32);
					dp8spSend.dwMinLatencyMS			= (DWORD) atoi(szNumber);

					GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MAXLATENCY), szNumber, 32);
					dp8spSend.dwMaxLatencyMS			= (DWORD) atoi(szNumber);
					if (dp8spSend.dwMaxLatencyMS < dp8spSend.dwMinLatencyMS)
					{
						dp8spSend.dwMaxLatencyMS = dp8spSend.dwMinLatencyMS;
						wsprintf(szNumber, "%u", dp8spSend.dwMaxLatencyMS);
						SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MAXLATENCY), szNumber);
					}



					//
					// Retrieve the receive settings from the window.
					//

					ZeroMemory(&dp8spReceive, sizeof(dp8spReceive));
					dp8spReceive.dwSize					= sizeof(dp8spReceive);

					GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_BANDWIDTH), szNumber, 32);
					dp8spReceive.dwBandwidthBPS			= (DWORD) atoi(szNumber);

					GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_DROP), szNumber, 32);
					dp8spReceive.dwPacketLossPercent	= (DWORD) atoi(szNumber);
					if (dp8spReceive.dwPacketLossPercent > 100)
					{
						dp8spReceive.dwPacketLossPercent = 100;
						SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_DROP), "100");
					}

					GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MINLATENCY), szNumber, 32);
					dp8spReceive.dwMinLatencyMS			= (DWORD) atoi(szNumber);

					GetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MAXLATENCY), szNumber, 32);
					dp8spReceive.dwMaxLatencyMS			= (DWORD) atoi(szNumber);
					if (dp8spReceive.dwMaxLatencyMS < dp8spReceive.dwMinLatencyMS)
					{
						dp8spReceive.dwMaxLatencyMS = dp8spReceive.dwMinLatencyMS;
						wsprintf(szNumber, "%u", dp8spReceive.dwMaxLatencyMS);
						SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MAXLATENCY), szNumber);
					}



					//
					// Store those settings.
					//
					hr = g_pDP8SimControl->SetAllParameters(&dp8spSend, &dp8spReceive, 0);
					if (hr != DP8SIM_OK)
					{
						DPFX(DPFPREP, 0, "Setting all parameters failed (err = 0x%lx)!", hr);
					}


					//
					// Disable the Apply and Revert buttons
					//
					EnableWindow(GetDlgItem(hWnd, IDB_APPLY), FALSE);
					EnableWindow(GetDlgItem(hWnd, IDB_REVERT), FALSE);

					break;
				}

				case IDB_REVERT:
				{
					//
					// Retrieve the current settings.
					//

					ZeroMemory(&dp8spSend, sizeof(dp8spSend));
					dp8spSend.dwSize = sizeof(dp8spSend);

					ZeroMemory(&dp8spReceive, sizeof(dp8spReceive));
					dp8spReceive.dwSize = sizeof(dp8spReceive);

					hr = g_pDP8SimControl->GetAllParameters(&dp8spSend, &dp8spReceive, 0);
					if (hr != DP8SIM_OK)
					{
						DPFX(DPFPREP, 0, "Getting all parameters failed (err = 0x%lx)!", hr);
					}
					else
					{
						//
						// Write the values to the window.
						//

						wsprintf(szNumber, "%u", dp8spSend.dwBandwidthBPS);
						SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_BANDWIDTH), szNumber);

						wsprintf(szNumber, "%u", dp8spSend.dwPacketLossPercent);
						SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_DROP), szNumber);

						wsprintf(szNumber, "%u", dp8spSend.dwMinLatencyMS);
						SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MINLATENCY), szNumber);

						wsprintf(szNumber, "%u", dp8spSend.dwMaxLatencyMS);
						SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MAXLATENCY), szNumber);


						wsprintf(szNumber, "%u", dp8spReceive.dwBandwidthBPS);
						SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_BANDWIDTH), szNumber);

						wsprintf(szNumber, "%u", dp8spReceive.dwPacketLossPercent);
						SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_DROP), szNumber);

						wsprintf(szNumber, "%u", dp8spReceive.dwMinLatencyMS);
						SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MINLATENCY), szNumber);

						wsprintf(szNumber, "%u", dp8spReceive.dwMaxLatencyMS);
						SetWindowText(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MAXLATENCY), szNumber);
					}


					//
					// Disable the Apply and Revert buttons
					//
					EnableWindow(GetDlgItem(hWnd, IDB_APPLY), FALSE);
					EnableWindow(GetDlgItem(hWnd, IDB_REVERT), FALSE);

					break;
				}

				case IDB_REFRESH:
				{
					//
					// Retrieve the current statistics.
					//

					ZeroMemory(&dp8ssSend, sizeof(dp8ssSend));
					dp8ssSend.dwSize = sizeof(dp8ssSend);

					ZeroMemory(&dp8ssReceive, sizeof(dp8ssReceive));
					dp8ssReceive.dwSize = sizeof(dp8ssReceive);

					hr = g_pDP8SimControl->GetAllStatistics(&dp8ssSend, &dp8ssReceive, 0);
					if (hr != DP8SIM_OK)
					{
						DPFX(DPFPREP, 0, "Getting all statistics failed (err = 0x%lx)!", hr);
					}
					else
					{
						//
						// Write the values to the window.
						//

						wsprintf(szNumber, "%u", dp8ssSend.dwTransmitted);
						SetWindowText(GetDlgItem(hWnd, IDT_STATS_SEND_XMIT), szNumber);

						wsprintf(szNumber, "%u", dp8ssSend.dwDropped);
						SetWindowText(GetDlgItem(hWnd, IDT_STATS_SEND_DROP), szNumber);

						wsprintf(szNumber, "%u", dp8ssReceive.dwTransmitted);
						SetWindowText(GetDlgItem(hWnd, IDT_STATS_RECV_XMIT), szNumber);

						wsprintf(szNumber, "%u", dp8ssReceive.dwDropped);
						SetWindowText(GetDlgItem(hWnd, IDT_STATS_RECV_DROP), szNumber);
					}

					break;
				}

				case IDB_CLEAR:
				{
					//
					// Clear the statistics.
					//
					hr = g_pDP8SimControl->ClearAllStatistics(0);
					if (hr != DP8SIM_OK)
					{
						DPFX(DPFPREP, 0, "Clearing all statistics failed (err = 0x%lx)!", hr);
					}
					else
					{
						SetWindowText(GetDlgItem(hWnd, IDT_STATS_SEND_XMIT), "0");
						SetWindowText(GetDlgItem(hWnd, IDT_STATS_SEND_DROP), "0");
						SetWindowText(GetDlgItem(hWnd, IDT_STATS_RECV_XMIT), "0");
						SetWindowText(GetDlgItem(hWnd, IDT_STATS_RECV_DROP), "0");
					}
					break;
				}

				case IDOK:
				{
					PostMessage(hWnd, WM_CLOSE, 0, 0);
					break;
				}
			} // end switch (on the button pressed/control changed)

			break;
		}
	} // end switch (on the type of window message)

	return DefWindowProc(hWnd, uMsg, wParam, lParam);
} // MainWindowDlgProc





#undef DPF_MODNAME
#define DPF_MODNAME "LoadAndAllocString"
//=============================================================================
// LoadAndAllocString
//-----------------------------------------------------------------------------
//
// Description: DNMallocs a wide character string from the given resource ID.
//
// Arguments:
//	HINSTANCE hInstance		- Module instance handle.
//	UINT uiResourceID		- Resource ID to load.
//	WCHAR ** pwszString		- Place to store pointer to allocated string.
//
// Returns: HRESULT
//=============================================================================
HRESULT LoadAndAllocString(HINSTANCE hInstance, UINT uiResourceID, WCHAR ** pwszString)
{
	HRESULT		hr = DPN_OK;
	int			iLength;
#ifdef DEBUG
	DWORD		dwError;
#endif // DEBUG


	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		WCHAR	wszTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
		

		iLength = LoadStringW(hInstance, uiResourceID, wszTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
		if (iLength == 0)
		{
#ifdef DEBUG
			dwError = GetLastError();		
			
			DPFX(DPFPREP, 0, "Unable to load resource ID %d (err = %u)", uiResourceID, dwError);
#endif // DEBUG

			(*pwszString) = NULL;
			hr = DPNERR_GENERIC;
			goto Exit;
		}


		(*pwszString) = (WCHAR*) DNMalloc((iLength + 1) * sizeof(WCHAR));
		if ((*pwszString) == NULL)
		{
			DPFX(DPFPREP, 0, "Memory allocation failure!");
			hr = DPNERR_OUTOFMEMORY;
			goto Exit;
		}


		wcscpy((*pwszString), wszTmpBuffer);
	}
	else
	{
		char	szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];
		

		iLength = LoadStringA(hInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
		if (iLength == 0)
		{
#ifdef DEBUG
			dwError = GetLastError();		
			
			DPFX(DPFPREP, 0, "Unable to load resource ID %u (err = %u)!", uiResourceID, dwError);
#endif // DEBUG

			(*pwszString) = NULL;
			hr = DPNERR_GENERIC;
			goto Exit;
		}

		
		(*pwszString) = (WCHAR*) DNMalloc((iLength + 1) * sizeof(WCHAR));
		if ((*pwszString) == NULL)
		{
			DPFX(DPFPREP, 0, "Memory allocation failure!");
			hr = DPNERR_OUTOFMEMORY;
			goto Exit;
		}


		hr = STR_jkAnsiToWide((*pwszString), szTmpBuffer, (iLength + 1));
		if (hr == DPN_OK)
		{
			DPFX(DPFPREP, 0, "Unable to convert from ANSI to Unicode (err =0x%lx)!", hr);
			goto Exit;
		}
	}


Exit:

	return hr;
} // LoadAndAllocString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\sp_ctrl\spwrapper.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       spwrapper.h
 *
 *  Content:	Header for DP8SIM main SP interface wrapper object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



//=============================================================================
// Macros
//=============================================================================
#ifndef	OFFSETOF
#define OFFSETOF(s,m)					( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)		(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

#define DP8SIMSP_FROM_BILINK(b)			(CONTAINING_OBJECT(b, CDP8SimSP, m_blList))



//=============================================================================
// Object flags
//=============================================================================
#define DP8SIMSPOBJ_INITIALIZED					0x01	// object has been initialized
#define DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD	0x02	// the global worker thread was started
#define DP8SIMSPOBJ_CLOSING						0x04	// close is in progress, no new functions are allowed




//=============================================================================
// Service provider interface object class
//=============================================================================
class CDP8SimSP : public IDP8ServiceProvider
{
	public:
		CDP8SimSP(const GUID * const pguidRealSP);	// constructor
		~CDP8SimSP(void);							// destructor


		STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

		STDMETHODIMP_(ULONG) AddRef(void);

		STDMETHODIMP_(ULONG) Release(void);


		STDMETHODIMP Initialize(PSPINITIALIZEDATA pspid);

		STDMETHODIMP Close(void);

		STDMETHODIMP Connect(PSPCONNECTDATA pspcd);

		STDMETHODIMP Disconnect(PSPDISCONNECTDATA pspdd);

		STDMETHODIMP Listen(PSPLISTENDATA pspld);

		STDMETHODIMP SendData(PSPSENDDATA pspsd);

		STDMETHODIMP EnumQuery(PSPENUMQUERYDATA pspeqd);

		STDMETHODIMP EnumRespond(PSPENUMRESPONDDATA psperd);

		STDMETHODIMP CancelCommand(HANDLE hCommand, DWORD dwCommandDescriptor);

		STDMETHODIMP CreateGroup(PSPCREATEGROUPDATA pspcgd);

		STDMETHODIMP DeleteGroup(PSPDELETEGROUPDATA pspdgd);

		STDMETHODIMP AddToGroup(PSPADDTOGROUPDATA pspatgd);

		STDMETHODIMP RemoveFromGroup(PSPREMOVEFROMGROUPDATA psprfgd);

		STDMETHODIMP GetCaps(PSPGETCAPSDATA pspgcd);

		STDMETHODIMP SetCaps(PSPSETCAPSDATA pspscd);

		STDMETHODIMP ReturnReceiveBuffers(PSPRECEIVEDBUFFER psprb);

		STDMETHODIMP GetAddressInfo(PSPGETADDRESSINFODATA pspgaid);

		STDMETHODIMP IsApplicationSupported(PSPISAPPLICATIONSUPPORTEDDATA pspiasd);

		STDMETHODIMP EnumAdapters(PSPENUMADAPTERSDATA pspead);

		STDMETHODIMP ProxyEnumQuery(PSPPROXYENUMQUERYDATA psppeqd);



		HRESULT InitializeObject(void);

		void UninitializeObject(void);

		void PerformDelayedSend(PVOID const pvContext);

		void PerformDelayedReceive(PVOID const pvContext);

		void IncSendsPending(void);

		void DecSendsPending(void);

		void IncReceivesPending(void);

		void DecReceivesPending(void);
		
		DWORD GetLatency(const DWORD dwBandwidthBPS,
						const DWORD dwDataSize,
						const DWORD dwMinRandMS,
						const DWORD dwMaxRandMS);


		inline void GetAllReceiveParameters(DP8SIM_PARAMETERS * const pdp8sp)	{ this->m_DP8SimIPC.GetAllReceiveParameters(pdp8sp); };
		inline void IncrementStatSendTransmitted(void)							{ this->m_DP8SimIPC.IncrementStatSendTransmitted(); };
		inline void IncrementStatReceiveTransmitted(void)						{ this->m_DP8SimIPC.IncrementStatReceiveTransmitted(); };
		inline void IncrementStatReceiveDropped(void)							{ this->m_DP8SimIPC.IncrementStatReceiveDropped(); };

		inline BOOL ShouldDrop(const DWORD dwDropPercentage)					{ return (((GetGlobalRand() % 100) < (WORD) dwDropPercentage) ? TRUE : FALSE); };



		CBilink					m_blList;	// list of all the DP8SimSP instances in existence


	private:
		BYTE					m_Sig[4];					// debugging signature ('SPWP')
		LONG					m_lRefCount;				// reference count for this object
		DWORD					m_dwFlags;					// flags for this object
		DNCRITICAL_SECTION		m_csLock;					// lock preventing simultaneous usage of globals
		GUID					m_guidSP;					// GUID of real SP object
		HMODULE					m_hSPDLL;					// handle to real SP's DLL.
		CDP8SimCB *				m_pDP8SimCB;				// pointer to callback interface wrapper object in use
		IDP8ServiceProvider *	m_pDP8SP;					// pointer to real service provider interface
		DWORD					m_dwSendsPending;			// number of outstanding sends
		HANDLE					m_hLastPendingSendEvent;	// handle to event to set when last send completes
		DWORD					m_dwReceivesPending;		// number of outstanding sends
		//HANDLE					m_hLastPendingReceiveEvent;	// handle to event to set when last send completes
		CDP8SimIPC				m_DP8SimIPC;				// object that handles interprocess communication


		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimSP))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x50575053)	// 0x50 0x57 0x50 0x53 = 'PWPS' = 'SPWP' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};

		HRESULT CoCreateInstanceRedirected(REFCLSID rclsid,
											REFIID riid,
											PVOID * ppv,
											HMODULE * phInstance);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\dp8sim\ui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dp8simui.rc
//

#define WINDOWCLASS_MAIN							"DP8Sim Main Window Class"

#define IDD_MAIN									100

#define IDX_SETTINGS								1000
#define IDCB_SETTINGS								1001

#define IDX_SETTINGS_SEND							1101
#define IDS_SETTINGS_SEND_BANDWIDTH					1102
#define IDE_SETTINGS_SEND_BANDWIDTH					1103
#define IDS_SETTINGS_SEND_DROP						1104
#define IDE_SETTINGS_SEND_DROP						1105
#define IDS_SETTINGS_SEND_MINLATENCY				1106
#define IDE_SETTINGS_SEND_MINLATENCY				1107
#define IDS_SETTINGS_SEND_MAXLATENCY				1108
#define IDE_SETTINGS_SEND_MAXLATENCY				1109

#define IDX_SETTINGS_RECV							1201
#define IDS_SETTINGS_RECV_BANDWIDTH					1202
#define IDE_SETTINGS_RECV_BANDWIDTH					1203
#define IDS_SETTINGS_RECV_DROP						1204
#define IDE_SETTINGS_RECV_DROP						1205
#define IDS_SETTINGS_RECV_MINLATENCY				1206
#define IDE_SETTINGS_RECV_MINLATENCY				1207
#define IDS_SETTINGS_RECV_MAXLATENCY				1208
#define IDE_SETTINGS_RECV_MAXLATENCY				1209

#define IDB_APPLY									1901
#define IDB_REVERT									1902


#define IDX_STATS									2000

#define IDX_STATS_SEND								2101
#define IDS_STATS_SEND_XMIT							2102
#define IDT_STATS_SEND_XMIT							2103
#define IDS_STATS_SEND_DROP							2104
#define IDT_STATS_SEND_DROP							2105

#define IDX_STATS_RECV								2201
#define IDS_STATS_RECV_XMIT							2202
#define IDT_STATS_RECV_XMIT							2203
#define IDS_STATS_RECV_DROP							2204
#define IDT_STATS_RECV_DROP							2205

#define IDB_REFRESH									2901
#define IDB_CLEAR									2902


//#define IDOK										3001



#define IDS_ERROR_CAPTION_COULDNTCREATEDP8SIMCONTROL	1
#define IDS_ERROR_TEXT_COULDNTCREATEDP8SIMCONTROL		2

#define IDS_PROMPTCAPTION_ENABLE_TCPIPREPLACEMENT		3
#define IDS_PROMPTCAPTION_DISABLE_TCPIPREPLACEMENT		4
#define IDS_PROMPTTEXT_ENABLE_TCPIPREPLACEMENT			5
#define IDS_PROMPTTEXT_DISABLE_TCPIPREPLACEMENT			6
#define IDS_FRIENDLYNAME_TCPIPREPLACEMENT				7

#define IDS_SETTING_NONE								8
#define IDS_SETTING_336MODEM							9
#define IDS_SETTING_56KMODEM							10
#define IDS_SETTING_256KBPSDSL							11
#define IDS_SETTING_HIGHPACKETLOSS						12
#define IDS_SETTING_HIGHLATENCYVARIANCE					13
#define IDS_SETTING_CUSTOM								14





// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\parsers\dplay8parser.hpp ===
#ifndef _DPlayParser_H_
#define _DPlayParser_H_

#include <stdlib.h>	// itoa declaration

// NetMon API
#include "netmon.h"

// DPlay Debug library
#include "DnDBG.h"

// This is the standard way of creating macros which make exporting from a DLL simpler.
// All files within this DLL are compiled with the DPLAYPARSER_EXPORTS symbol defined on the command line.
// This symbol should NOT be defined on any other project that uses this DLL. This way any other project
// whose source files include this file see DPLAYPARSER_API functions as being imported from a DLL, whereas
// this DLL sees the symbols defined with this macro as being exported.
#if defined(DPLAYPARSER_EXPORTS)

	#define DPLAYPARSER_API __declspec(dllexport)

#else

	#define DPLAYPARSER_API __declspec(dllimport)

#endif


// DESCRIPTION: Identifies the parser, or parsers that are located in the DLL.
//
// NOTE: ParserAutoInstallInfo should be implemented in all parser DLLs.
//
// ARGUMENTS: NONE
//
// RETURNS: Success: PF_PARSERDLLINFO structure that describes the parsers in the DLL.
//			Failiure: NULL
//
DPLAYPARSER_API PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo( void );


#endif // _DPlayParser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\parsers\dplay8parser.cpp ===
#include "TransportParser.hpp"
#include "SPParser.hpp"
#include "VoiceParser.hpp"
#include "SessionParser.hpp"



// DESCRIPTION: Identifies the parser, or parsers that are located in the DLL.
//
// NOTE: ParserAutoInstallInfo should be implemented in all parser DLLs.
//
// ARGUMENTS: NONE
//
// RETURNS: Success:  PF_PARSERDLLINFO structure that describes the parsers in the DLL.
//			Failiure: NULL
//
DPLAYPARSER_API PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo( void )	// TODO: RIGHT NOW THIS SEEMS TO DO NOTHING!!!
{

	enum
	{
		nNUM_OF_PROTOCOLS = 4
	};

	// Allocate memory for the parser info
	// NetMon will free this with HeapFree
	PPF_PARSERDLLINFO pParserDllInfo =
		reinterpret_cast<PPF_PARSERDLLINFO>( HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                                                       sizeof(PF_PARSERDLLINFO) + nNUM_OF_PROTOCOLS * sizeof(PF_PARSERINFO)) );
    if( pParserDllInfo == NULL)
    {
        return NULL;
    }


	// Number of parsers in the parser DLL. 
    pParserDllInfo->nParsers = nNUM_OF_PROTOCOLS;


	//=============================================//
	// DPlay Service Provider parser specific info //===============================================================
	//=============================================//

	// Defining a synonym reference for simpler access
    PF_PARSERINFO& rSPInfo = pParserDllInfo->ParserInfo[0];

	// Name of the protocol that the parser detects
    strcpy(rSPInfo.szProtocolName, "DPLAYSP");

	// Brief description of the protocol
    strcpy(rSPInfo.szComment, "DPlay v.8.0 - Service Provider protocol");

	// Optional name of the protocol Help file
    strcpy(rSPInfo.szHelpFile, "\0");


	// Specify the preceding protocols 
	enum
	{
		  nNUM_OF_PARSERS_SP_FOLLOWS = 2
	};

	// NetMon will free this with HeapFree
	PPF_FOLLOWSET pSPPrecedeSet =
		  reinterpret_cast<PPF_FOLLOWSET>( HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
													 sizeof(PF_FOLLOWSET) + nNUM_OF_PARSERS_SP_FOLLOWS * sizeof(PF_FOLLOWENTRY)) );
	if( pSPPrecedeSet == NULL )
	{
		return pParserDllInfo;
	}

	// Fill in the follow set for preceding parsers
	pSPPrecedeSet->nEntries = nNUM_OF_PARSERS_SP_FOLLOWS;

	strcpy(pSPPrecedeSet->Entry[0].szProtocol, "UDP");
	strcpy(pSPPrecedeSet->Entry[1].szProtocol, "IPX");

	rSPInfo.pWhoCanPrecedeMe = pSPPrecedeSet;


	
	//==================================//
	// DPlay8 Transport parser specific info //==========================================================================
	//==================================//

	// Defining a synonym reference for simpler access
    PF_PARSERINFO& rTransportInfo = pParserDllInfo->ParserInfo[1];

	// Name of the protocol that the parser detects
    strcpy(rTransportInfo.szProtocolName, "DPLAYTRANSPORT");

	// Brief description of the protocol
    strcpy(rTransportInfo.szComment, "DPlay v.8.0 - Transport protocol");

	// Optional name of the protocol Help file
    strcpy(rTransportInfo.szHelpFile, "\0");



	//==================================//
	// DPlay Voice parser specific info //==========================================================================
	//==================================//

	// Defining a synonym reference for simpler access
    PF_PARSERINFO& rVoiceInfo = pParserDllInfo->ParserInfo[2];

	// Name of the protocol that the parser detects
    strcpy(rVoiceInfo.szProtocolName, "DPLAYVOICE");

	// Brief description of the protocol
    strcpy(rVoiceInfo.szComment, "DPlay v.8.0 - Voice protocol");

	// Optional name of the protocol Help file
    strcpy(rVoiceInfo.szHelpFile, "\0");



	//=================================//
	// DPlay Core parser specific info //===========================================================================
	//=================================//

	// Defining a synonym reference for simpler access
    PF_PARSERINFO& rCoreInfo = pParserDllInfo->ParserInfo[3];

	// Name of the protocol that the parser detects
    strcpy(rCoreInfo.szProtocolName, "DPLAYSESSION");

	// Brief description of the protocol
    strcpy(rCoreInfo.szComment, "DPlay v.8.0 - Session protocol");

	// Optional name of the protocol Help file
    strcpy(rCoreInfo.szHelpFile, "\0");
	

    return pParserDllInfo;

} // ParserAutoInstallInfo




// DESCRIPTION: (Called by the OS) Tell the kernel about our entry points.
//
// ARGUMENTS: i_hInstance - Handle to an instance of the parser.
//			  i_dwCommand - Indicator to determine why the function is called.
//			  i_pReserved - Not used now.
//
// RETURNS: Success = TRUE; Failure = FALSE
//
BOOL WINAPI DllMain( HANDLE i_hInstance, ULONG i_dwCommand, LPVOID i_pReserved )
{
	
	static DWORD dwAttached = 0;

    // Process according to the calling context
    switch( i_dwCommand )
    {
        case DLL_PROCESS_ATTACH:
            // Are we loading for the first time?
            if( dwAttached == 0 )
            {
				// TODO: TEMPORARY: THIS SEEMS TO ADD THE PROTOCOLS TO PARSER.INI
				CreateTransportProtocol();
				CreateSPProtocol();
				CreateVoiceProtocol();
				CreateSessionProtocol();
/*
				if ( !CreateTransportProtocol() || !CreateSPProtocol() || !CreateVoiceProtocol() || !CreateSessionProtocol() )
				{
					// TODO: ADD DEBUGING MESSAGE HERE
					MessageBox(NULL, "Failed to create protocols", "FAILED", MB_OK);
					
					//	return FALSE;	// (?BUG?) NetMon won't update the INI file if DllMain returns FALSE.
				}
*/
            }
			++dwAttached;
            break;

        case DLL_PROCESS_DETACH:
            // Are we detaching our last instance?
            if( --dwAttached == 0 )
            {
                // Last active instance of this parser needs to clean up
                DestroyTransportProtocol();
				DestroySPProtocol();
				DestroyVoiceProtocol();
				DestroySessionProtocol();
            }
            break;
    }

    return TRUE;

} // DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\parsers\spparser.hpp ===
#ifndef _SPParser_H_
#define _SPParser_H_

#include "DPlay8Parser.hpp"


// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hSPProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI SPRegister( HPROTOCOL i_hSPProtocol );


// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hSPProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI SPDeregister( HPROTOCOL i_hProtocol );


// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbSPFrame     - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbSPFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI SPRecognizeFrame( HFRAME        i_hFrame,
											   ULPBYTE        i_upbMacFrame,	
											   ULPBYTE        i_upbSPFrame,
                                   			   DWORD         i_dwMacType,        
                                   			   DWORD         i_dwBytesLeft,      
                                   			   HPROTOCOL     i_hPrevProtocol,  
                                   			   DWORD         i_dwPrevProtOffset,
                                   			   LPDWORD       o_pdwProtocolStatus,
                                   			   LPHPROTOCOL   o_hNextProtocol,
											   PDWORD_PTR    io_pdwptrInstData );


// DESCRIPTION: Maps the properties that exist in a piece of recognized data to specific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbSPFrame        - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbSPFrame.
//
DPLAYPARSER_API LPBYTE BHAPI SPAttachProperties( HFRAME      i_hFrame,
												 ULPBYTE      i_upbMacFrame,
												 ULPBYTE      i_upbSPFrame,
												 DWORD       i_dwMacType,
												 DWORD       i_dwBytesLeft,
												 HPROTOCOL   i_hPrevProtocol,
												 DWORD       i_dwPrevProtOffset,
												 DWORD_PTR   i_dwptrInstData );


// DESCRIPTION: Formats the data that is displayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbCoreFrame		- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbSPFrame.
//
DPLAYPARSER_API DWORD BHAPI SPFormatProperties( HFRAME          i_hFrame,
												ULPBYTE          i_upbMacFrame,
												ULPBYTE          i_upbSPFrame,
												DWORD           i_dwPropertyInsts,
												LPPROPERTYINST  i_pPropInst );

bool CreateSPProtocol( void );
void DestroySPProtocol( void );


#endif // _SPParser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\parsers\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=dp8parse
DLLDEF=..\DPlay8Parser.def
UMTYPE=windows

#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=DYNLINK

#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#

TARGETLIBS=$(TARGETLIBS) \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\nmapi.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcprt.lib


!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=$(DXROOT)\inc;..\..\..\dnet\inc;..\..\..\dnet\common; \
	 ..\..\..\dnet\core;..\..\..\dnet\sp\wsock;..\..\..\dnet\protocol; \
	 ..\..\..\dvoice\dxvoice;..\..\..\dvoice\inc;$(BASEDIR)\public\sdk\inc\atl30


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= DPlay8Parser.cpp\
         SessionParser.cpp\
         SPParser.cpp\
         TransportParser.cpp\
         VoiceParser.cpp\
	 dp8parse.rc

#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /D_DLL /DDPLAYPARSER_EXPORTS

USE_NOLIBS=1

USE_NATIVE_EH=1

DLLENTRY=_DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\parsers\sessionparser.hpp ===
#ifndef _SessionParser_H_
#define _SessionParser_H_

#include "DPlay8Parser.hpp"


// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hSessionProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI SessionRegister( HPROTOCOL i_hSessionProtocol );


// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hSessionProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI SessionDeregister( HPROTOCOL i_hProtocol );


// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbSessionFrame    - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbSessionFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI SessionRecognizeFrame( HFRAME        i_hFrame,
													ULPBYTE        i_upbMacFrame,	
													ULPBYTE        i_upbSessionFrame,
                                   					DWORD         i_dwMacType,        
                                   					DWORD         i_dwBytesLeft,      
                                   					HPROTOCOL     i_hPrevProtocol,  
                                   					DWORD         i_dwPrevProtOffset,
                                   					LPDWORD       o_pdwProtocolStatus,
                                   					LPHPROTOCOL   o_hNextProtocol,
												    PDWORD_PTR    io_pdwptrInstData );


// DESCRIPTION: Maps the properties that exist in a piece of recognized data to Sessionecific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbSessionFrame   - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData       - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbSessionFrame.
//
DPLAYPARSER_API LPBYTE BHAPI SessionAttachProperties( HFRAME      i_hFrame,
													  ULPBYTE      i_upbMacFrame,
													  ULPBYTE      i_upbSessionFrame,
													  DWORD       i_dwMacType,
													  DWORD       i_dwBytesLeft,
													  HPROTOCOL   i_hPrevProtocol,
													  DWORD       i_dwPrevProtOffset,
													  DWORD_PTR   i_dwptrInstData );


// DESCRIPTION: Formats the data that is diSessionlayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbSessionFrame	- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbSessionFrame.
//
DPLAYPARSER_API DWORD BHAPI SessionFormatProperties( HFRAME          i_hFrame,
													 ULPBYTE          i_upbMacFrame,
													 ULPBYTE          i_upbSessionFrame,
													 DWORD           i_dwPropertyInsts,
													 LPPROPERTYINST  i_pPropInst );

bool CreateSessionProtocol( void );
void DestroySessionProtocol( void );


#endif // _SessionParser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\parsers\spparser.cpp ===
//=============================================================================
//  FILE: SPParser.cpp
//
//  Description: DirectPlay Service Provider Parser
//
//
//  Modification History:
//
//  Michael Milirud      08/Aug/2000    Created
//=============================================================================

//#define FRAME_NAMES
//#define FRAME_DROPS

//==================//
// Standard headers //
//==================//
#include <winsock2.h>
#include <wsipx.h>
#include <tchar.h>

//=====================//
// Proprietary headers //
//=====================//

#include "dpaddr.h"	// DPNA_DEFAULT_PORT definition

// Prototypes
#include "SPParser.hpp"

namespace DPlaySP
{

	// SP protocol header
	#include "MessageStructures.h"

} // DPlaySP namespace


namespace
{
	HPROTOCOL  g_hSPProtocol;


	//=============================//
	// Return Address Family field //-----------------------------------------------------------------------------------
	//=============================//
	LABELED_BYTE arr_RetAddrFamilyByteLabels[] = { { AF_IPX,  "IPX protocol" },
												   { AF_INET, "IP protocol"	 } };

	SET LabeledRetAddrFamilyByteSet = { sizeof(arr_RetAddrFamilyByteLabels) / sizeof(LABELED_BYTE), arr_RetAddrFamilyByteLabels };


	
	//================//
	// Data Tag field //------------------------------------------------------------------------------------------------
	//================//
	LABELED_BYTE arr_CommandByteLabels[] = { { ESCAPED_USER_DATA_KIND,	 "DPlay v8 Transport data follows" },
											 { ENUM_DATA_KIND,			 "Enumeration Query"			   },
										     { ENUM_RESPONSE_DATA_KIND,  "Response to Enumeration Query"   },
											 { PROXIED_ENUM_DATA_KIND,	 "Proxied Enumeration Query"	   } };

	SET LabeledCommandByteSet = { sizeof(arr_CommandByteLabels) / sizeof(LABELED_BYTE), arr_CommandByteLabels };


	
	////////////////////////////////
	// Custom Property Formatters //=====================================================================================
	////////////////////////////////

	
	// DESCRIPTION: Custom description formatter for the Service Provider packet summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_SPSummary( LPPROPERTYINST io_pProperyInstance )
	{
		using namespace DPlaySP;

		// Check what SP frame we are dealing with
		PREPEND_BUFFER&	rSPFrame = *reinterpret_cast<PREPEND_BUFFER*>(io_pProperyInstance->lpData);
		//
		switch ( rSPFrame.GenericHeader.bSPCommandByte )
		{
		case ENUM_DATA_KIND:			// Service Provider Query
			{
				strcpy(io_pProperyInstance->szPropertyText, "Enumeration Request");
				break;
			}
		case ENUM_RESPONSE_DATA_KIND:	// Service Provider Response
			{
				strcpy(io_pProperyInstance->szPropertyText, "Enumeration Response");
				break;
			}

		case PROXIED_ENUM_DATA_KIND:	// Service Provider Proxied Query
			{
				strcpy(io_pProperyInstance->szPropertyText, "Proxied Enumeration Request");
				break;
			}

		case ESCAPED_USER_DATA_KIND:	// DPlay v8 Transport protocol frame follows
		default:
			{
				strcpy(io_pProperyInstance->szPropertyText, "User Data");
				break;
			}
		}

	} // FormatPropertyInstance_SPSummary


	//==================//
	// Properties table //-----------------------------------------------------------------------------------------------
	//==================//
	
	PROPERTYINFO g_arr_SPProperties[] = 
	{

		// SP packet summary property (SP_SUMMARY)
	    {
		    0,									// handle placeholder (MBZ)
		    0,									// reserved (MBZ)
		    "",									// label
		    "DPlay Service Provider packet",	// status-bar comment
		    PROP_TYPE_SUMMARY,					// data type
		    PROP_QUAL_NONE,						// data type qualifier
		    NULL,								// labeled bit set 
		    512,								// description's maximum length
		    FormatPropertyInstance_SPSummary	// generic formatter
		},

		// Leading Zero property (SP_LEADZERO)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Leading zero tag",					// label
			"Leading zero tag field",			// status-bar comment
			PROP_TYPE_BYTE,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Data Tag property (SP_COMMAND)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Command",							// label
			"Command field",					// status-bar comment
			PROP_TYPE_BYTE,						// data type
			PROP_QUAL_LABELED_SET,				// data type qualifier.
			&LabeledCommandByteSet,				// labeled byte set 
			512,								// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Enumeration Key property (SP_ENUMPAYLOAD)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Enum Payload",						// label
			"Enumeration Payload field",		// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Enumeration Key property (SP_ENUMKEY)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Enum Key",							// label
			"Enumeration Key field",			// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Enumeration Response Key property (SP_ENUMRESPKEY)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Enum Response Key",				// label
			"Enumeration Response Key",			// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Enumeration Response Key property (SP_RTTINDEX)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"RTT Index",						// label
			"RTT Index field",					// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},
		
		// Size of the return address property (SP_RETADDRSIZE)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Return Address's Size",			// label
			"Size of the return address",		// status-bar comment
			PROP_TYPE_BYTE,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Return Address Socket Family property (SP_RETADDRFAMILY)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Socket Family",					// label
			"Socket Family field",				// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_LABELED_SET,				// data type qualifier.
			&LabeledRetAddrFamilyByteSet,		// labeled byte set 
			512,								// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Return Address Socket Family property (SP_RETADDR_IPX)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"IPX Address",						// label
			"IPX Address field",				// status-bar comment
			PROP_TYPE_IPX_ADDRESS,				// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Return Address Socket (SP_RETADDRSOCKET_IPX)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Socket",							// label
			"Socket field",						// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},
	
		// Return Address Socket Family property (SP_RETADDR_IP)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"IP Address",						// label
			"IP Address field",					// status-bar comment
			PROP_TYPE_IP_ADDRESS,				// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Return Address Socket (SP_RETADDRPORT_IP)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Port",								// label
			"Port field",						// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// User Data (SP_USERDATA)
	    {
		    0,									// handle placeholder (MBZ)
		    0,									// reserved (MBZ)
		    "User Data",						// label
		    "User Data",						// status-bar comment
		    PROP_TYPE_RAW_DATA,					// data type
		    PROP_QUAL_NONE,						// data type qualifier.
		    NULL,								// labeled bit set 
		    64,									// description's maximum length
		    FormatPropertyInstance				// generic formatter
		}

	};

	enum
	{
		nNUM_OF_SP_PROPS = sizeof(g_arr_SPProperties) / sizeof(PROPERTYINFO)
	};


	// Properties' indices
	enum
	{
		SP_SUMMARY = 0,
		SP_LEADZERO,
		SP_COMMAND,
		SP_ENUMPAYLOAD,
		SP_ENUMKEY,
		SP_ENUMRESPKEY,
		SP_RTTINDEX,
		SP_RETADDRSIZE,
		SP_RETADDRFAMILY,
		SP_RETADDR_IPX,
		SP_RETADDRSOCKET_IPX,
		SP_RETADDR_IP,
		SP_RETADDRPORT_IP,
		SP_USERDATA
	};





	// Platform independent memory accessor of big endian words
	inline WORD ReadBigEndianWord( BYTE* i_pbData )
	{
		return (*i_pbData << 8) | *(i_pbData+1);
	}


	// DESCRIPTION: DPlay packet validation predicate.
	//
	// ARGUMENTS: i_hFrame		  - The handle to the frame that contains the data.
	//			  i_hPrevProtocol - Handle of the previous protocol.
	//			  i_pbMacFrame	  - The pointer to the first byte of the frame; the pointer provides a way to view
	//						        the data that the other parsers recognize.
	//
	// RETURNS: DPlay packet = TRUE; NOT a DPlay packet = FALSE
	//
	bool IsDPlayPacket( HFRAME i_hFrame, HPROTOCOL i_hPrevProtocol, LPBYTE i_pbMacFrame )
	{

		LPPROTOCOLINFO pPrevProtocolInfo = GetProtocolInfo(i_hPrevProtocol);
		
		DWORD dwPrevProtocolOffset = GetProtocolStartOffsetHandle(i_hFrame, i_hPrevProtocol);

		WORD wSrcPort, wDstPort;

		if ( strncmp(reinterpret_cast<char*>(pPrevProtocolInfo->ProtocolName), "UDP", sizeof(pPrevProtocolInfo->ProtocolName)) == 0 )
		{
			// Extracting the source and destination ports of the packet from its UDP header
			wSrcPort = ReadBigEndianWord(i_pbMacFrame + dwPrevProtocolOffset);
			wDstPort = ReadBigEndianWord(i_pbMacFrame + dwPrevProtocolOffset + 2);
		}
		else if ( strncmp(reinterpret_cast<char*>(pPrevProtocolInfo->ProtocolName), "IPX", sizeof(pPrevProtocolInfo->ProtocolName)) == 0 )
		{
			// Extracting the source and destination ports of the packet from its IPX header
			wSrcPort = ReadBigEndianWord(i_pbMacFrame + dwPrevProtocolOffset + 16);	// source address socket
			wDstPort = ReadBigEndianWord(i_pbMacFrame + dwPrevProtocolOffset + 28); // destination address socket
		}
		else
		{
			// Should never happen!
			return false;
		}

		
		//===========//
		// Constants //
		//===========//
		//
		static bool bTriedRetrievingUserPorts = false;
		static bool bRetrievedUserPorts = false;

		static DWORD dwMinUserPort, dwMaxUserPort;

		// Retrieval from the registry is attempted only once
		if ( !bTriedRetrievingUserPorts )
		{
			bTriedRetrievingUserPorts = true;
			
			HKEY hKey = NULL;
			if (RegOpenKeyEx(HKEY_CURRENT_USER, _T("Software\\Microsoft\\DirectPlay\\Parsers"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
			{
				DWORD dwType = NULL;
				DWORD dwCount = sizeof(DWORD);
				if (RegQueryValueEx(hKey, _T("MinUserPort"), NULL, &dwType, (LPBYTE)&dwMinUserPort, &dwCount) == ERROR_SUCCESS &&
					RegQueryValueEx(hKey, _T("MaxUserPort"), NULL, &dwType, (LPBYTE)&dwMaxUserPort, &dwCount) == ERROR_SUCCESS )
				{
					bRetrievedUserPorts = true;
				}
				RegCloseKey(hKey);
			}
		}

		if ( bRetrievedUserPorts &&
			((wSrcPort >= dwMinUserPort) && (wSrcPort <= dwMaxUserPort)) &&
		    ((wDstPort >= dwMinUserPort) && (wDstPort <= dwMaxUserPort)) )
		{
			// Is a valid DPlay packet
			return true;
		}


		// Make sure both endpoints are using the SP port range [2302, 2400], or the DPNServer port {6073}, or [MinUsePort, MaxUserPort] (if provided by the user)
		WORD wPort = wSrcPort;
		for ( int nPorts = 0; nPorts < 2; ++nPorts, wPort = wDstPort )
		{
			if (
				 (
				   !bRetrievedUserPorts    ||
				   (wPort < dwMinUserPort) ||
				   (wPort > dwMaxUserPort)
				 )
				 &&
				 (
				   (wPort < BASE_DPLAY8_PORT)  ||
				   (wPort > MAX_DPLAY8_PORT)
				 )
				 &&
				 (
				   wPort != DPNA_DPNSVR_PORT
				 )
			   )
			{
				// Not a valid DPlay packet
				return false;
			}
		}

		// Is a valid DPlay packet
		return true;

	} // IsDPlayPacket

} // anonymous namespace





// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hSPProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI SPRegister( HPROTOCOL i_hSPProtocol ) 
{

	CreatePropertyDatabase(i_hSPProtocol, nNUM_OF_SP_PROPS);

	// Add the properties to the database
	for( int nProp=0; nProp < nNUM_OF_SP_PROPS; ++nProp )
	{
	   AddProperty(i_hSPProtocol, &g_arr_SPProperties[nProp]);
	}

} // SPRegister



// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hSPProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI SPDeregister( HPROTOCOL i_hProtocol )
{

	DestroyPropertyDatabase(i_hProtocol);

} // SPDeregister




namespace
{

	// DESCRIPTION: Parses the SP frame to find its size (in bytes) NOT including the user data
	//
	// ARGUMENTS: i_pbSPFrame - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
	//						    in the middle of a frame because a previous parser has claimed data before this parser.
	//
	// RETURNS: Size of the specified SP frame (in bytes)
	//
	int SPHeaderSize( LPBYTE i_pbSPFrame )
	{
		using namespace DPlaySP;

		// Check what SP frame we are dealing with
		PREPEND_BUFFER&	rSPFrame = *reinterpret_cast<PREPEND_BUFFER*>(i_pbSPFrame);
		//
		switch ( rSPFrame.GenericHeader.bSPCommandByte )
		{
		case ENUM_DATA_KIND:			// Service Provider Query
			{
				return  sizeof(rSPFrame.EnumDataHeader);
			}
		case ENUM_RESPONSE_DATA_KIND:	// Service Provider Response
			{
				return  sizeof(rSPFrame.EnumResponseDataHeader);
			}

		case PROXIED_ENUM_DATA_KIND:	// Service Provider Proxied Query
			{
				return  sizeof(rSPFrame.ProxiedEnumDataHeader);
			}

		case ESCAPED_USER_DATA_KIND:	// user data starting with zero
			{
				return  sizeof(rSPFrame.EscapedUserDataHeader);
			}

		default:	// user data starting with a nonzero byte
			{
				return 0;	// no header
			}
		}

	} // SPHeaderSize

} // Anonymous namespace



// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbSPFrame		  - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbSPFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI SPRecognizeFrame( HFRAME        i_hFrame,
											   ULPBYTE        i_upbMacFrame,	
											   ULPBYTE        i_upbSPFrame,
											   DWORD         i_dwMacType,        
											   DWORD         i_dwBytesLeft,      
											   HPROTOCOL     i_hPrevProtocol,  
											   DWORD         i_dwPrevProtOffset,
											   LPDWORD       o_pdwProtocolStatus,
											   LPHPROTOCOL   o_phNextProtocol,
											   PDWORD_PTR    io_pdwptrInstData )
{
	using namespace DPlaySP;

	// Validate the amount of unclaimed data
	enum
	{
		nMIN_SPHeaderSize = sizeof(PREPEND_BUFFER::_GENERIC_HEADER)
	};

	// Validate the packet as DPlay SP type
	if ( (i_dwBytesLeft < nMIN_SPHeaderSize)					 ||
		 !IsDPlayPacket(i_hFrame, i_hPrevProtocol, i_upbMacFrame) )
	{
		// Assume the unclaimed data is not recognizable
		*o_pdwProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		return i_upbSPFrame;
	}


	//==========================//
	// Get the DPlay frame size //
	//==========================//
	LPPROTOCOLINFO pPrevProtocolInfo = GetProtocolInfo(i_hPrevProtocol);
	WORD wDPlayFrameSize = 0;

	if ( strncmp(reinterpret_cast<char*>(pPrevProtocolInfo->ProtocolName), "UDP", sizeof(pPrevProtocolInfo->ProtocolName)) == 0 )
	{
		// Extracting the UDP frame size
		WORD wUDPFrameSize = ReadBigEndianWord(i_upbMacFrame + i_dwPrevProtOffset + 4);

		enum { nUDP_HEADER_SIZE = 8 };
		wDPlayFrameSize = wUDPFrameSize - nUDP_HEADER_SIZE;
	}
	else if ( strncmp(reinterpret_cast<char*>(pPrevProtocolInfo->ProtocolName), "IPX", sizeof(pPrevProtocolInfo->ProtocolName)) == 0 )
	{
		// Extracting the IPX frame size
		WORD wIPXFrameSize = ReadBigEndianWord(i_upbMacFrame + i_dwPrevProtOffset + 2);	// source address socket

		enum { nIPX_HEADER_SIZE = 30 };
		wDPlayFrameSize = wIPXFrameSize - nIPX_HEADER_SIZE;
	}
	else
	{
		; // TODO: ASSERT HERE
	}

	// Pass along the size of the Transport frame
	DWORD_PTR dwptrTransportFrameSize = wDPlayFrameSize - SPHeaderSize(i_upbSPFrame);
	*io_pdwptrInstData = dwptrTransportFrameSize;

	PREPEND_BUFFER&	rSPFrame = *reinterpret_cast<PREPEND_BUFFER*>(i_upbSPFrame);

	if ( rSPFrame.GenericHeader.bSPLeadByte  ==  SP_HEADER_LEAD_BYTE )	// SP packet
	{
	    *o_pdwProtocolStatus = PROTOCOL_STATUS_RECOGNIZED;
		*o_phNextProtocol	 = NULL;

		if ( rSPFrame.GenericHeader.bSPCommandByte  ==  ESCAPED_USER_DATA_KIND )	// user data starting with zero (non-DPlay v8 Transport packet)
		{
			*o_pdwProtocolStatus = PROTOCOL_STATUS_RECOGNIZED;
			return i_upbSPFrame + sizeof(PREPEND_BUFFER::_ESCAPED_USER_DATA_HEADER);
		}
	}
	else // user data (DPlay v8 Transport packet)
	{
		// Notify NetMon about the handoff protocol
		*o_pdwProtocolStatus = PROTOCOL_STATUS_NEXT_PROTOCOL;
		*o_phNextProtocol	 = GetProtocolFromName("DPLAYTRANSPORT");

		return i_upbSPFrame;
	}
	
	// Claim the rest of the data
	return NULL;		

} // SPRecognizeFrame



// DESCRIPTION: Maps the properties that exist in a piece of recognized data to specific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbSPFrame		 - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: Must return NULL
//
DPLAYPARSER_API LPBYTE BHAPI SPAttachProperties( HFRAME      i_hFrame,
												 ULPBYTE      i_upbMacFrame,
												 ULPBYTE      i_upbSPFrame,
												 DWORD       i_dwMacType,
												 DWORD       i_dwBytesLeft,
												 HPROTOCOL   i_hPrevProtocol,
												 DWORD       i_dwPrevProtOffset,
												 DWORD_PTR   i_dwptrInstData )
{
	using namespace DPlaySP;

    //===================//
    // Attach Properties //
    //===================//

    // Summary line
    AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_SUMMARY].hProperty,
                           i_dwBytesLeft, i_upbSPFrame, 0, 0, 0);

	// Protection against NetMon
	if ( *i_upbSPFrame )
	{
		return NULL;
	}

    // Check what SP frame we are dealing with
	PREPEND_BUFFER&	rSPFrame = *reinterpret_cast<PREPEND_BUFFER*>(i_upbSPFrame);

	// Leading Zero tag field
    AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_LEADZERO].hProperty,
                           sizeof(rSPFrame.GenericHeader.bSPLeadByte), &rSPFrame.GenericHeader.bSPLeadByte, 0, 1, 0);

	// Command field
    AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_COMMAND].hProperty,
                           sizeof(rSPFrame.GenericHeader.bSPCommandByte), &rSPFrame.GenericHeader.bSPCommandByte, 0, 1, 0);
	    
	switch ( rSPFrame.GenericHeader.bSPCommandByte )
	{
	case ESCAPED_USER_DATA_KIND:	// user data starting with zero
		{
			break;
		}

	case ENUM_DATA_KIND:			// Service Provider's Enumeration Request
		{
			// Enum payload field
			AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_ENUMPAYLOAD].hProperty,
								   sizeof(rSPFrame.EnumDataHeader.wEnumPayload), &rSPFrame.EnumDataHeader.wEnumPayload, 0, 1, 0);
			// Enum Key field
			DWORD dwEnumKey = rSPFrame.EnumDataHeader.wEnumPayload & ~ENUM_RTT_MASK;
			AttachPropertyInstanceEx(i_hFrame, g_arr_SPProperties[SP_ENUMKEY].hProperty,
								   sizeof(rSPFrame.EnumDataHeader.wEnumPayload), &rSPFrame.EnumDataHeader.wEnumPayload,
								   sizeof(dwEnumKey), &dwEnumKey,
								   0, 2, 0);
			
			// RTT index field
			BYTE byRTTIndex = rSPFrame.EnumDataHeader.wEnumPayload & ENUM_RTT_MASK;
			AttachPropertyInstanceEx(i_hFrame, g_arr_SPProperties[SP_RTTINDEX].hProperty,
								   sizeof(rSPFrame.EnumDataHeader.wEnumPayload), &rSPFrame.EnumDataHeader.wEnumPayload,
								   sizeof(byRTTIndex), &byRTTIndex,
								   0, 2, 0);
			break;
		}

	case ENUM_RESPONSE_DATA_KIND:	// Service Provider's Enumeration Response
		{
			// Enum payload field
			AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_ENUMPAYLOAD].hProperty,
								   sizeof(rSPFrame.EnumResponseDataHeader.wEnumResponsePayload), &rSPFrame.EnumResponseDataHeader.wEnumResponsePayload, 0, 1, 0);
			
			// Enum Key field
			DWORD dwEnumKey = rSPFrame.EnumResponseDataHeader.wEnumResponsePayload & ~ENUM_RTT_MASK;
			AttachPropertyInstanceEx(i_hFrame, g_arr_SPProperties[SP_ENUMRESPKEY].hProperty,
								   sizeof(rSPFrame.EnumResponseDataHeader.wEnumResponsePayload), &rSPFrame.EnumResponseDataHeader.wEnumResponsePayload,
								   sizeof(dwEnumKey), &dwEnumKey,
								   0, 2, 0);
			
			// RTT index field
			BYTE byRTTIndex = rSPFrame.EnumDataHeader.wEnumPayload & ENUM_RTT_MASK;
			AttachPropertyInstanceEx(i_hFrame, g_arr_SPProperties[SP_RTTINDEX].hProperty,
								   sizeof(rSPFrame.EnumResponseDataHeader.wEnumResponsePayload), &rSPFrame.EnumResponseDataHeader.wEnumResponsePayload,
								   sizeof(byRTTIndex), &byRTTIndex,
								   0, 2, 0);
			break;
		}

	case PROXIED_ENUM_DATA_KIND:	// Service Provider's Proxied Enumeration Query
		{
			// Return Address Size field
			AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_RETADDRSIZE].hProperty,
								   sizeof(rSPFrame.ProxiedEnumDataHeader.ReturnAddress), &rSPFrame.ProxiedEnumDataHeader.ReturnAddress, 0, 1, 0);
			
			// Enum Key field
			AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_ENUMKEY].hProperty,
								   sizeof(rSPFrame.ProxiedEnumDataHeader.wEnumKey), &rSPFrame.ProxiedEnumDataHeader.wEnumKey, 0, 1, 0);


			// Return Address Socket Address Family field
			AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_RETADDRFAMILY].hProperty,
								   sizeof(rSPFrame.ProxiedEnumDataHeader.ReturnAddress.sa_family), &rSPFrame.ProxiedEnumDataHeader.ReturnAddress.sa_family, 0, 1, 0);


			switch ( rSPFrame.ProxiedEnumDataHeader.ReturnAddress.sa_family )
			{				
			case AF_IPX:
				{
					SOCKADDR_IPX& rIPXAddress = *reinterpret_cast<SOCKADDR_IPX*>(&rSPFrame.ProxiedEnumDataHeader.ReturnAddress);

					// Return Address field (IPX Network Number + Node Number)
					AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_RETADDR_IPX].hProperty,
										   sizeof(rIPXAddress.sa_netnum) + sizeof(rIPXAddress.sa_nodenum), &rIPXAddress.sa_netnum, 0, 1, 0);

					// Return Address Socket Address IPX Socket Number field
					AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_RETADDRSOCKET_IPX].hProperty,
										   sizeof(rIPXAddress.sa_socket), &rIPXAddress.sa_socket, 0, 1, 0);

					break;
				}


			case AF_INET:
				{
					SOCKADDR_IN& rIPAddress = *reinterpret_cast<SOCKADDR_IN*>(&rSPFrame.ProxiedEnumDataHeader.ReturnAddress);

					// Return Address field (IP Address)
					AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_RETADDR_IP].hProperty,
										   sizeof(rIPAddress.sin_addr), &rIPAddress.sin_addr, 0, 1, 0);

					// Return Address Port field
					AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_RETADDRPORT_IP].hProperty,
										   sizeof(rIPAddress.sin_port), &rIPAddress.sin_port, 0, 1, 0);

					break;
				}

			default:
				{
					// TODO:	DPF(0, "Unknown socket type!");
					break;
				}
			}

			break;
		}
	}


	size_t sztSPHeaderSize = SPHeaderSize(i_upbSPFrame);
	
	if ( i_dwBytesLeft > sztSPHeaderSize )
	{
		size_t sztUserDataSize = i_dwBytesLeft - sztSPHeaderSize;

		// User data
		AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_USERDATA].hProperty,
							   sztUserDataSize, i_upbSPFrame + sztSPHeaderSize, 0, 1, 0);
	}

	return NULL;

} // SPAttachProperties





// DESCRIPTION: Formats the data that is displayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbCoreFrame		- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbSPFrame.
//
DPLAYPARSER_API DWORD BHAPI SPFormatProperties( HFRAME          i_hFrame,
												ULPBYTE          i_upbMacFrame,
												ULPBYTE          i_upbSPFrame,
												DWORD           i_dwPropertyInsts,
												LPPROPERTYINST  i_pPropInst )
{

    // Loop through the property instances...
    while( i_dwPropertyInsts-- > 0)
    {
        // ...and call the formatter for each
        reinterpret_cast<FORMAT>(i_pPropInst->lpPropertyInfo->InstanceData)(i_pPropInst);
        ++i_pPropInst;
    }

	// TODO: MAKE SURE THIS SHOULD NOT BE TRUE
    return NMERR_SUCCESS;

} // SPFormatProperties




// DESCRIPTION: Notifies Network Monitor that DPlay v8 Transport protocol parser exists.
//
// ARGUMENTS: NONE
//
// RETURNS: TRUE - success, FALSE - failure
//
bool CreateSPProtocol( void )
{

	// The entry points to the export functions that Network Monitor uses to operate the parser
	ENTRYPOINTS SPEntryPoints =
	{
		// SPParser Entry Points
		SPRegister,
		SPDeregister,
		SPRecognizeFrame,
		SPAttachProperties,
		SPFormatProperties
	};

    // The first active instance of this parser needs to register with the kernel
    g_hSPProtocol = CreateProtocol("DPLAYSP", &SPEntryPoints, ENTRYPOINTS_SIZE);
	
	return (g_hSPProtocol ? TRUE : FALSE);

} // CreateSPProtocol



// DESCRIPTION: Removes the DPlay v8 Transport protocol parser from the Network Monitor's database of parsers
//
// ARGUMENTS: NONE
//
// RETURNS: NOTHING
//
void DestroySPProtocol( void )
{

	DestroyProtocol(g_hSPProtocol);

} // DestroySPProtocol
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\parsers\sessionparser.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SessionParser.cpp
 *  Content:    DirectPlay Service Provider Parser
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	08/08/00    micmil	Created
 *	08/11/00	rodtoll	Bug #42171 -- Build break
 *	01/26/01	minara	Removed unused structures
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


//==================//
// Standard headers //
//==================//
#pragma warning(push)
#pragma warning(disable : 4786)	// The identifier string exceeded the maximum allowable length and was truncated
#include <queue>
#pragma warning(pop)

#include <string>
#include <winsock2.h>
#include <wsipx.h>


//=====================//
// Proprietary headers //
//=====================//

// Prototypes
#include "SessionParser.hpp"

// Session protocol headers
#include "DPlay8.h"
#include "Message.h"	 // DN_INTERNAL_MESSAGE_XXX definitions
//#include "AppDesc.h"	 // DPN_APPLICATION_DESC_INFO definition


////////////////////////////////////////////////////////////////////////////////////
// TODO: SHOULD BE MOVED TO DPLAY CORE'S HEADER FILE
////////////////////////////////////////////////////////////////////////////////////
#define	NAMETABLE_ENTRY_FLAG_LOCAL				0x0001
#define	NAMETABLE_ENTRY_FLAG_HOST				0x0002
#define	NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP	0x0004
#define	NAMETABLE_ENTRY_FLAG_GROUP				0x0010
#define	NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST	0x0020
#define	NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT	0x0040
#define	NAMETABLE_ENTRY_FLAG_PEER				0x0100
#define NAMETABLE_ENTRY_FLAG_CLIENT				0x0200
#define	NAMETABLE_ENTRY_FLAG_SERVER				0x0400
#define	NAMETABLE_ENTRY_FLAG_AVAILABLE			0x1000
#define	NAMETABLE_ENTRY_FLAG_CONNECTING			0x2000
#define	NAMETABLE_ENTRY_FLAG_DISCONNECTING		0x4000


enum
{
	NAMETABLE_ENTRY_FLAG_ANY_GROUP = NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP | NAMETABLE_ENTRY_FLAG_GROUP  |
									 NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST   | NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT
};


typedef struct _DN_NAMETABLE_INFO
{
	DPNID	dpnid;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
	DWORD	dwEntryCount;
	DWORD	dwMembershipCount;
} DN_NAMETABLE_INFO;

typedef struct _DN_NAMETABLE_ENTRY_INFO
{
	DPNID	dpnid;
	DPNID	dpnidOwner;
	DWORD	dwFlags;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
	DWORD	dwDNETVersion;
	DWORD	dwNameOffset;
	DWORD	dwNameSize;
	DWORD	dwDataOffset;
	DWORD	dwDataSize;
	DWORD	dwURLOffset;
	DWORD	dwURLSize;
} DN_NAMETABLE_ENTRY_INFO;


typedef struct _DN_NAMETABLE_MEMBERSHIP_INFO
{
	DPNID	dpnidPlayer;
	DPNID	dpnidGroup;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
} DN_NAMETABLE_MEMBERSHIP_INFO, *PDN_NAMETABLE_MEMBERSHIP_INFO;


struct DN_INTERNAL_MESSAGE_ALL
{
	union
	{
		DN_INTERNAL_MESSAGE_CONNECT_INFO					dnConnectInfo;
		DN_INTERNAL_MESSAGE_CONNECT_FAILED					dnConnectFailed;
		DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO				dnPlayerConnectInfo;
		DN_INTERNAL_MESSAGE_REQUEST_FAILED					dnRequestFailed;
		DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID				dnSendPlayerID;
		DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT				dnInstructConnect;
		DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED		dnInstructedConnectFailed;
		DN_INTERNAL_MESSAGE_DESTROY_PLAYER					dnDestroyPlayer;
		DN_INTERNAL_MESSAGE_CREATE_GROUP					dnCreateGroup;
		DN_INTERNAL_MESSAGE_DESTROY_GROUP					dnDestroyGroup;
		DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP				dnAddPlayerToGroup;
		DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP		dnDeletePlayerFromGroup;
		DN_INTERNAL_MESSAGE_UPDATE_INFO						dnUpdateInfo;
		DN_INTERNAL_MESSAGE_HOST_MIGRATE					dnHostMigrate;
		DN_INTERNAL_MESSAGE_NAMETABLE_VERSION				dnNametableVersion;
		DN_INTERNAL_MESSAGE_RESYNC_VERSION					dnResyncVersion;
		DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP				dnReqNametableOp;
		DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP				dnAckNametableOp;
		DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION			dnReqProcessCompletion;
		DN_INTERNAL_MESSAGE_PROCESS_COMPLETION				dnProcessCompletion;
		DN_INTERNAL_MESSAGE_TERMINATE_SESSION				dnTerminateSession;
		DN_INTERNAL_MESSAGE_INTEGRITY_CHECK					dnIntegrityCheck;
		DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE		dnIntegrityCheckResponse;
	
		DPN_APPLICATION_DESC_INFO							dnUpdateAppDescInfo;
		DN_NAMETABLE_ENTRY_INFO								dnAddPlayer;

		struct
		{
			DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION dnReqProcessCompletionHeader;
			union
			{
				DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP					dnReqCreateGroup;
				DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP					dnReqDestroyGroup;
				DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP				dnReqAddPlayerToGroup;
				DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP		dnReqDeletePlayerFromGroup;
				DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO						dnReqUpdateInfo;
				DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK					dnReqIntegrityCheck;
			};
		};

		BYTE												bOffsetBase;	// used as a base for fields' offsets
	};
};


struct DN_INTERNAL_MESSAGE_FULLMSG
{
	DWORD 					  dwMsgType;
	DN_INTERNAL_MESSAGE_ALL  MsgBody;
};
////////////////////////////////////////////////////////////////////////////////////


namespace
{

	HPROTOCOL 	g_hSessionProtocol;
	ULPBYTE		g_upbyPastEndOfFrame;
	
	//====================//
	// Message Type field //---------------------------------------------------------------------------------------------
	//====================//
	LABELED_DWORD g_arr_MessageTypeDWordLabels[] =
		{ { DN_MSG_INTERNAL_PLAYER_CONNECT_INFO,			"Player connection information"									 },										
		  { DN_MSG_INTERNAL_SEND_CONNECT_INFO,				"Session information"											 },										
		  { DN_MSG_INTERNAL_ACK_CONNECT_INFO,				"Session information has been acknowledged"						 },										
		  { DN_MSG_INTERNAL_SEND_PLAYER_DNID,				"Player ID"														 },	
		  { DN_MSG_INTERNAL_CONNECT_FAILED,					"Connection failed"												 },										
		  { DN_MSG_INTERNAL_INSTRUCT_CONNECT,				"Instruction to connect"										 },										
		  { DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED,		"Instruction to connect failed"									 },										
		  { DN_MSG_INTERNAL_NAMETABLE_VERSION,				"Nametable version"												 },										
		  { DN_MSG_INTERNAL_RESYNC_VERSION,					"Resync the version"											 },										
		  { DN_MSG_INTERNAL_REQ_NAMETABLE_OP,				"Reqesting a nametable"											 },										
		  { DN_MSG_INTERNAL_ACK_NAMETABLE_OP,				"Nametable acknowledgement"										 },										
		  { DN_MSG_INTERNAL_HOST_MIGRATE,					"Host migration in process"										 },										
		  { DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE,			"Host migration has been completed"								 },										
		  { DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC,		"Update application description"								 },										
		  { DN_MSG_INTERNAL_ADD_PLAYER,						"Add a player"													 },										
		  { DN_MSG_INTERNAL_DESTROY_PLAYER,					"Destroy a player"												 },										
		  { DN_MSG_INTERNAL_REQ_CREATE_GROUP,				"Requesting a group creation"									 },										
		  { DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP,		"Requesting a player addition to the group"						 },										
		  { DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP,	"Requesting a player deletion from the group"					 },										
		  { DN_MSG_INTERNAL_REQ_DESTROY_GROUP,				"Requesting a group destruction "								 },										
		  { DN_MSG_INTERNAL_REQ_UPDATE_INFO,				"Requesting information update"									 },										
		  { DN_MSG_INTERNAL_CREATE_GROUP,					"Creating a group"												 },										
		  { DN_MSG_INTERNAL_DESTROY_GROUP,					"Destroying a group"											 },										
		  { DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP,			"Adding a player to the group"									 },										
		  { DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP,		"Deleting a player from the group"								 },										
		  { DN_MSG_INTERNAL_UPDATE_INFO,					"Information update"											 },										
		  { DN_MSG_INTERNAL_BUFFER_IN_USE,					"Buffer is in use"												 },										
		  { DN_MSG_INTERNAL_REQUEST_FAILED,					"Request has failed"											 },										
		  { DN_MSG_INTERNAL_TERMINATE_SESSION,				"Terminating session"											 },										
		  { DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION,			"Initiating reliably handled message transmission"				 },										
		  { DN_MSG_INTERNAL_PROCESS_COMPLETION,				"Message has been handled by the message handler"				 },
		  { DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK,			"Requesting a host to check whether another peer is still in the session" },
		  { DN_MSG_INTERNAL_INTEGRITY_CHECK,				"Querying a peer whether it's still in the session"		 		 },										
		  { DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE,    	"Acknowledgement of being still in the session"					 } };										   

	SET g_LabeledMessageTypeDWordSet = { sizeof(g_arr_MessageTypeDWordLabels) / sizeof(LABELED_DWORD), g_arr_MessageTypeDWordLabels };


	//===================//
	// Result Code field //----------------------------------------------------------------------------------------------
	//===================//
	LABELED_DWORD g_arr_ResultCodeDWordLabels[] = { { DPN_OK,							"Success"						},
												    { DPNSUCCESS_EQUAL,               	"Success (equal)"				},
												    { DPNSUCCESS_NOTEQUAL,            	"Success (not equal)"			},
												    { DPNERR_ABORTED,					"Aborted"						},
												    { DPNERR_ADDRESSING,				"Addressing"					},
												    { DPNERR_ALREADYCLOSING,			"Already closing"				},
												    { DPNERR_ALREADYCONNECTED,			"Already connected"				},
												    { DPNERR_ALREADYDISCONNECTING,		"Already disconnecting"			},
												    { DPNERR_ALREADYINITIALIZED,		"Already initialized"			},
												    { DPNERR_BUFFERTOOSMALL,			"Buffer is too small"			},
												    { DPNERR_CANNOTCANCEL,				"Could not cancel"				},
												    { DPNERR_CANTCREATEGROUP,			"Could not create a group"		},
												    { DPNERR_CANTCREATEPLAYER,			"Could not create a player"		},
												    { DPNERR_CANTLAUNCHAPPLICATION,		"Could not launch an application"   },
												    { DPNERR_CONNECTING,				"Connecting"					},
												    { DPNERR_CONNECTIONLOST,			"Connection has been lost"		},
												    { DPNERR_CONVERSION,				"Conversion"					},
												    { DPNERR_DOESNOTEXIST,				"Does not exist"				},
												    { DPNERR_DUPLICATECOMMAND,			"Duplicate command"				},
												    { DPNERR_ENDPOINTNOTRECEIVING,		"Endpoint is not receiving"		},
												    { DPNERR_ENUMQUERYTOOLARGE,			"Enumeration query is too large"    },
												    { DPNERR_ENUMRESPONSETOOLARGE,		"Enumeration response is too large" },
												    { DPNERR_EXCEPTION,					"Exception was thrown"			},
												    { DPNERR_GENERIC,					"Generic error"					},
												    { DPNERR_GROUPNOTEMPTY,				"Group is not empty"			},
												    { DPNERR_HOSTING,                  	"Hosting"						},
												    { DPNERR_HOSTREJECTEDCONNECTION,	"Host has rejected the connection"  },
												    { DPNERR_HOSTTERMINATEDSESSION,		"Host terminated the session"	},
												    { DPNERR_INCOMPLETEADDRESS,			"Incomplete address"			},
												    { DPNERR_INVALIDADDRESSFORMAT,		"Invalid address format"		},
												    { DPNERR_INVALIDAPPLICATION,		"Invalid application"			},
												    { DPNERR_INVALIDCOMMAND,			"Invalid command"				},
												    { DPNERR_INVALIDENDPOINT,			"Invalid endpoint"				},
												    { DPNERR_INVALIDFLAGS,				"Invalid flags"					},
												    { DPNERR_INVALIDGROUP,			 	"Invalid group"					},
												    { DPNERR_INVALIDHANDLE,				"Invalid handle"				},
												    { DPNERR_INVALIDINSTANCE,			"Invalid instance"				},
												    { DPNERR_INVALIDINTERFACE,			"Invalid interface"				},
												    { DPNERR_INVALIDDEVICEADDRESS,		"Invalid device address"		},
												    { DPNERR_INVALIDOBJECT,				"Invalid object"				},
												    { DPNERR_INVALIDPARAM,				"Invalid parameter"				},
												    { DPNERR_INVALIDPASSWORD,			"Invalid password"				},
												    { DPNERR_INVALIDPLAYER,				"Invalid player"				},
												    { DPNERR_INVALIDPOINTER,			"Invalid pointer"				},
												    { DPNERR_INVALIDPRIORITY,			"Invalid priority"				},
												    { DPNERR_INVALIDHOSTADDRESS,		"Invalid host address"			},
												    { DPNERR_INVALIDSTRING,				"Invalid string"				},
												    { DPNERR_INVALIDURL,				"Invalid URL"					},
												    { DPNERR_INVALIDVERSION,			"Invalid version"				},
												    { DPNERR_NOCAPS,					"No CAPs"						},
												    { DPNERR_NOCONNECTION,				"No connection"					},
												    { DPNERR_NOHOSTPLAYER,				"No host player is present"		},
												    { DPNERR_NOINTERFACE,				"No interface"					},
												    { DPNERR_NOMOREADDRESSCOMPONENTS,	"No more address components"	},
													{ DPNERR_NORESPONSE,				"No response"					},
													{ DPNERR_NOTALLOWED,				"Not allowed"					},
													{ DPNERR_NOTHOST,					"Not a host"					},
													{ DPNERR_NOTREADY,					"Not ready"						},
													{ DPNERR_OUTOFMEMORY,				"Out of memory"					},
													{ DPNERR_PENDING,					"Pending"						},
													{ DPNERR_PLAYERLOST,				"Player has been lost"			},
													{ DPNERR_PLAYERNOTREACHABLE,		"Player is not reachable"		},													
													{ DPNERR_SENDTOOLARGE,				"Sent data is too large"		},
													{ DPNERR_SESSIONFULL,				"Session is full"				},
													{ DPNERR_TABLEFULL,					"Table is full"					},
													{ DPNERR_TIMEDOUT,					"Timed out"						},
													{ DPNERR_UNINITIALIZED,				"Uninitialized"					},
													{ DPNERR_UNSUPPORTED,				"Unsupported"					},
													{ DPNERR_USERCANCEL,				"User has canceled"				} };
			
	SET g_LabeledResultCodeDWordSet = { sizeof(g_arr_ResultCodeDWordLabels) / sizeof(LABELED_DWORD), g_arr_ResultCodeDWordLabels };


	//====================//
	// Player Flags field //---------------------------------------------------------------------------------------------
	//====================//
	LABELED_BIT g_arr_FlagsBitLabels[] = { {  0, "Not local",					"Local"				 },		// NAMETABLE_ENTRY_FLAG_LOCAL			
										   {  1, "Not a host",					"Host"				 },		// NAMETABLE_ENTRY_FLAG_HOST			
										   {  2, "Not an All Players group",	"All Players group"     },	// NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP
										   {  4, "Not a group",			 		"Group"				 },		// NAMETABLE_ENTRY_FLAG_GROUP			
										   {  5, "Not a Multicast group",		"Multicast group"	 },		// NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST
										   {  6, "Not an Autodestruct group",	"Autodestruct group"    },	// NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT
										   {  8, "Not a peer",					"Peer"				 },		// NAMETABLE_ENTRY_FLAG_PEER			
										   {  9, "Not a client",				"Client"			 },		// NAMETABLE_ENTRY_FLAG_CLIENT			
										   { 10, "Not a server",				"Server"			 },		// NAMETABLE_ENTRY_FLAG_SERVER			
										   { 12, "Not available",				"Available"			 },		// NAMETABLE_ENTRY_FLAG_AVAILABLE		
										   { 13, "Not connecting",				"Connecting"		 },		// NAMETABLE_ENTRY_FLAG_CONNECTING		
										   { 14, "Not disconnecting",			"Disconnecting"		 } };	// NAMETABLE_ENTRY_FLAG_DISCONNECTING	

	SET g_LabeledFlagsBitSet = { sizeof(g_arr_FlagsBitLabels) / sizeof(LABELED_BIT), g_arr_FlagsBitLabels };


	//===================//
	// Info Flags field  //---------------------------------------------------------------------------------------------
	//===================//
	LABELED_BIT g_arr_InfoFlagsBitLabels[] = { { 0, "No name is included",  "Name is included" },	// DPNINFO_NAME			
											   { 1, "No data is included",  "Data is included" } };	// DPNINFO_DATA


	SET g_LabeledInfoFlagsBitSet = { sizeof(g_arr_InfoFlagsBitLabels) / sizeof(LABELED_BIT), g_arr_InfoFlagsBitLabels };


	//====================//
	// Group Flags field  //---------------------------------------------------------------------------------------------
	//====================//
	LABELED_BIT g_arr_GroupFlagsBitLabels[]  = { { 0, "Not an autodestruct group",  "An autodestruct group" },	// DPNGROUP_AUTODESTRUCT			
											     { 5, "Not a multicast group",	    "A multicast group"	    } };	// DPNGROUP_MULTICAST


	SET g_LabeledGroupFlagsBitSet = { sizeof(g_arr_GroupFlagsBitLabels) / sizeof(LABELED_BIT), g_arr_GroupFlagsBitLabels };


	//===========================//
	// Maximum Number of Players //--------------------------------------------------------------------------------------------
	//===========================//
	LABELED_DWORD g_arr_MaxNumOfPlayersDWordLabels[] = { { 0, "Unlimited" } };

	SET g_LabeledMaxNumOfPlayersDWordSet = { sizeof(g_arr_MaxNumOfPlayersDWordLabels) / sizeof(LABELED_DWORD), g_arr_MaxNumOfPlayersDWordLabels };


	//=================================//
	// Player Destruction Reason field //---------------------------------------------------------------------------------------------
	//=================================//
	LABELED_DWORD g_arr_PlayerDestructionReasonDWordLabels[] = { { DPNDESTROYPLAYERREASON_NORMAL,				"Player self-destructed"	  },
													 			 { DPNDESTROYPLAYERREASON_CONNECTIONLOST,		"Connection lost"			  },
																 { DPNDESTROYPLAYERREASON_SESSIONTERMINATED,	"Session has been terminated" },
																 { DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER,	"Host destroyed the player"	  } };

	SET g_LabeledPlayerDestructionReasonDWordSet = { sizeof(g_arr_PlayerDestructionReasonDWordLabels) / sizeof(LABELED_DWORD), g_arr_PlayerDestructionReasonDWordLabels };
	

	////////////////////////////////
	// Custom Property Formatters   //=====================================================================================
	////////////////////////////////

	// DESCRIPTION: Custom description formatter for the Session packet summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_SessionSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		std::string strSummary;
		char arr_cBuffer[10];
		
		// Check what Session frame we are dealing with
		DN_INTERNAL_MESSAGE_FULLMSG& rBase = *reinterpret_cast<DN_INTERNAL_MESSAGE_FULLMSG*>(io_pPropertyInstance->lpData);
		
		// Message title
		switch ( rBase.dwMsgType )
		{
		case DN_MSG_INTERNAL_PLAYER_CONNECT_INFO:
			{
				if ( rBase.MsgBody.dnPlayerConnectInfo.dwNameSize )
				{
					strSummary = "Player ";
					
					enum { nMAX_PLAYER_NAME = 64 };
					char arr_cPlayerName[nMAX_PLAYER_NAME];

					WideCharToMultiByte(CP_ACP, 0,
										reinterpret_cast<WCHAR*>( &rBase.MsgBody.bOffsetBase + rBase.MsgBody.dnPlayerConnectInfo.dwNameOffset ),
										rBase.MsgBody.dnPlayerConnectInfo.dwNameSize, arr_cPlayerName, sizeof(arr_cPlayerName), NULL, NULL);

					strSummary += arr_cPlayerName;
				}
				else
				{
					strSummary = "Unnamed player";
				}

				strSummary += " is attempting to connect to the session";

				break;
			}

		case DN_MSG_INTERNAL_SEND_CONNECT_INFO:
			{

				DPN_APPLICATION_DESC_INFO&	 rApplicationDescInfo = *reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(&rBase.MsgBody.dnConnectInfo + 1);

				if ( rApplicationDescInfo.dwSessionNameSize )
				{
					strSummary = "Session ";
					
					enum { nMAX_SESSION_NAME = 64 };
					char arr_cSessionName[nMAX_SESSION_NAME];

					WideCharToMultiByte(CP_ACP, 0,
										reinterpret_cast<WCHAR*>( &rBase.MsgBody.bOffsetBase + rApplicationDescInfo.dwSessionNameOffset ),
										rApplicationDescInfo.dwSessionNameSize, arr_cSessionName, sizeof(arr_cSessionName), NULL, NULL);

					strSummary += arr_cSessionName;
				}
				else
				{
					strSummary = "Unnamed session";
				}

				strSummary += " is sending its information";

				break;
			}


		case DN_MSG_INTERNAL_SEND_PLAYER_DNID:
			{
				strSummary  = "Player ID is 0x";
				strSummary += _itoa(rBase.MsgBody.dnSendPlayerID.dpnid, arr_cBuffer, 16);
				break;
			}

		case DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION:
			{
				strSummary  = "Initiating reliably handled message transmission (SyncID=0x";
				strSummary += _itoa(rBase.MsgBody.dnReqProcessCompletion.hCompletionOp, arr_cBuffer, 16);
				strSummary += ")";
				break;
			}

		case DN_MSG_INTERNAL_PROCESS_COMPLETION:
			{
				strSummary  = "Message has been handled by the message handler (SyncID=0x";
				strSummary += _itoa(rBase.MsgBody.dnProcessCompletion.hCompletionOp, arr_cBuffer, 16);
				strSummary += ")";
				break;
			}

		case DN_MSG_INTERNAL_DESTROY_PLAYER:
			{
				strSummary += "Player 0x";
				strSummary += _itoa(rBase.MsgBody.dnDestroyPlayer.dpnidLeaving, arr_cBuffer, 16);
				strSummary += " is leaving the session";
				break;
			}

		case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:
			{
				strSummary  = "Player 0x";
				strSummary += _itoa(rBase.MsgBody.dnDeletePlayerFromGroup.dpnidRequesting, arr_cBuffer, 16);
				strSummary += " is requesting to delete player 0x";
				strSummary += _itoa(rBase.MsgBody.dnDeletePlayerFromGroup.dpnidPlayer, arr_cBuffer, 16);
				strSummary += " from group 0x";
				strSummary += _itoa(rBase.MsgBody.dnDeletePlayerFromGroup.dpnidGroup, arr_cBuffer, 16);
				break;
			}

		case DN_MSG_INTERNAL_NAMETABLE_VERSION:
			{
				strSummary += "Nametable version is ";
				strSummary += _itoa(rBase.MsgBody.dnNametableVersion.dwVersion, arr_cBuffer, 10);
				break;
			}

		default:
			{
				for ( int n = 0; n < sizeof(g_arr_MessageTypeDWordLabels)/sizeof(LABELED_DWORD); ++n )
				{
					if ( g_arr_MessageTypeDWordLabels[n].Value == rBase.dwMsgType )
					{
						strSummary = g_arr_MessageTypeDWordLabels[n].Label;
						break;
					}
				}
				break;
			}
		}

		// Message highlights
		switch ( rBase.dwMsgType )
		{
		case DN_MSG_INTERNAL_HOST_MIGRATE:
			{
				strSummary += " (0x";
				strSummary += _itoa(rBase.MsgBody.dnHostMigrate.dpnidOldHost, arr_cBuffer, 16);
				strSummary += " => 0x";
				strSummary += _itoa(rBase.MsgBody.dnHostMigrate.dpnidNewHost, arr_cBuffer, 16);
				strSummary += ")";
				break;
			}

		}

		strcpy(io_pPropertyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_SessionSummary


	// DESCRIPTION: Custom description formatter for the Application Description summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_AppDescSummary( LPPROPERTYINST io_pProperyInstance )
	{

		std::string strSummary;
		char arr_cBuffer[10];

		DPN_APPLICATION_DESC_INFO&	rApplicationDescInfo = *reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(io_pProperyInstance->lpData);

		if ( rApplicationDescInfo.dwSessionNameSize )
		{
			strSummary = "Session ";
			
			enum { nMAX_SESSION_NAME = 64 };
			char arr_cSessionName[nMAX_SESSION_NAME];

			// TODO: Once NetMon supports passage of pointer types via PROPERTYINSTEX,
			// TODO: remove the less generic reference to size of DN_INTERNAL_MESSAGE_CONNECT_INFO
			WideCharToMultiByte(CP_ACP, 0,
								reinterpret_cast<WCHAR*>( reinterpret_cast<char*>(&rApplicationDescInfo) -
														sizeof(DN_INTERNAL_MESSAGE_CONNECT_INFO) +
														rApplicationDescInfo.dwSessionNameOffset ),
								rApplicationDescInfo.dwSessionNameSize, arr_cSessionName, sizeof(arr_cSessionName), NULL, NULL);

			strSummary += arr_cSessionName;
		}
		else
		{
			strSummary = "Unnamed session";
		}

		strSummary += " is hosting ";
		strSummary += _itoa(rApplicationDescInfo.dwCurrentPlayers, arr_cBuffer, 10);
		strSummary += " out of ";
		strSummary += ( rApplicationDescInfo.dwMaxPlayers == 0 ? "unlimited number of" : _itoa(rApplicationDescInfo.dwMaxPlayers, arr_cBuffer, 10) );
		strSummary += " players";

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_AppDescSummary



	// DESCRIPTION: Custom description formatter for the Name Table's summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_NameTableSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		DN_NAMETABLE_INFO& rNameTableInfo = *reinterpret_cast<DN_NAMETABLE_INFO*>(io_pPropertyInstance->lpData);

		sprintf(io_pPropertyInstance->szPropertyText, "NameTable (ver=%d)", rNameTableInfo.dwVersion);

	} // FormatPropertyInstance_NameTableSummary



	// DESCRIPTION: Custom description formatter for the Application GUID field
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_ApplicationGUID( LPPROPERTYINST io_pPropertyInstance )
	{

		std::string strSummary = "Application GUID = ";

		REFGUID rguid = *reinterpret_cast<GUID*>(io_pPropertyInstance->lpData);

		enum
		{
			nMAX_GUID_STRING = 50	// more than enough characters for a symbolic representation of a GUID
		};

		OLECHAR arr_wcGUID[nMAX_GUID_STRING];
		StringFromGUID2(rguid, arr_wcGUID, nMAX_GUID_STRING);

		char arr_cGUID[nMAX_GUID_STRING];
		WideCharToMultiByte(CP_ACP, 0, arr_wcGUID, -1, arr_cGUID, sizeof(arr_cGUID), NULL, NULL);
		strSummary += arr_cGUID;


		strcpy(io_pPropertyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_ApplicationGUID


	
	// DESCRIPTION: Custom description formatter for the Instance GUID field
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_InstanceGUID( LPPROPERTYINST io_pPropertyInstance )
	{

		std::string strSummary = "Instance GUID = ";

		REFGUID rguid = *reinterpret_cast<GUID*>(io_pPropertyInstance->lpData);

		enum
		{
			nMAX_GUID_STRING = 50	// more than enough characters for a symbolic representation of a GUID
		};

		OLECHAR arr_wcGUID[nMAX_GUID_STRING];
		StringFromGUID2(rguid, arr_wcGUID, nMAX_GUID_STRING);

		char arr_cGUID[nMAX_GUID_STRING];
		WideCharToMultiByte(CP_ACP, 0, arr_wcGUID, -1, arr_cGUID, sizeof(arr_cGUID), NULL, NULL);
		strSummary += arr_cGUID;


		strcpy(io_pPropertyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_InstanceGUID


	namespace
	{
		std::string MapSetFlagsToLabels( LABELED_BIT i_arr_FlagsBitLabels[], int i_nNumOfFlags, DWORD i_dwFlags )
		{
			std::string strString;
			int			nBit	   = 0;
			bool		bNotFirst = false;

			for ( DWORD dwBitMask = 1; dwBitMask != 0x80000000; dwBitMask <<= 1, ++nBit )
			{
				if ( (i_dwFlags & dwBitMask)  ==  dwBitMask )
				{
					for ( int n = 0; n < i_nNumOfFlags; ++n )
					{
						if ( i_arr_FlagsBitLabels[n].BitNumber == nBit)
						{
							if ( bNotFirst )
							{
								strString += ", ";
							}
							bNotFirst = true;

							strString += i_arr_FlagsBitLabels[n].LabelOn;
							break;
						}
					}
				}
			}

			return strString;

		} // MapSetFlagsToLabels

	} // Anonymous namespace



	// DESCRIPTION: Custom description formatter for the Flags summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_FlagsSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		std::string strSummary = "Flags: ";

		DWORD dwFlags = *reinterpret_cast<DWORD*>(io_pPropertyInstance->lpData);

		if ( dwFlags == 0 )
		{
			strSummary += "Must be zero";
		}
		else
		{
			strSummary += MapSetFlagsToLabels(g_arr_FlagsBitLabels, sizeof(g_arr_FlagsBitLabels)/sizeof(LABELED_BIT), dwFlags);
		}
		
		strcpy(io_pPropertyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_FlagsSummary


	// DESCRIPTION: Custom description formatter for the Information Flags summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_InfoFlagsSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		std::string strSummary = "Information Flags: ";

		DWORD dwInfoFlags = *reinterpret_cast<DWORD*>(io_pPropertyInstance->lpData);
		
		if ( dwInfoFlags == 0 )
		{
			strSummary += "Must be zero";
		}
		else
		{
			strSummary += MapSetFlagsToLabels(g_arr_InfoFlagsBitLabels, sizeof(g_arr_InfoFlagsBitLabels)/sizeof(LABELED_BIT), dwInfoFlags);
		}
		
		strcpy(io_pPropertyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_InfoFlagsSummary


	// DESCRIPTION: Custom description formatter for the Group Flags summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_GroupFlagsSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		std::string strSummary = "Group Flags: ";

		DWORD dwGroupFlags = *reinterpret_cast<DWORD*>(io_pPropertyInstance->lpData);
		
		if ( dwGroupFlags == 0 )
		{
			strSummary += "Must be zero";
		}
		else
		{
			strSummary += MapSetFlagsToLabels(g_arr_GroupFlagsBitLabels, sizeof(g_arr_GroupFlagsBitLabels)/sizeof(LABELED_BIT), dwGroupFlags);
		}
		
		strcpy(io_pPropertyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_GroupFlagsSummary



	// DESCRIPTION: Custom description formatter for the Version summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_VersionSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		sprintf(io_pPropertyInstance->szPropertyText, "Version: 0x%08X", *((DWORD*)(io_pPropertyInstance->lpByte)));

	} // FormatPropertyInstance_VersionSummary



	// DESCRIPTION: Custom description formatter for the Player ID property
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_PlayerID( LPPROPERTYINST io_pPropertyInstance )
	{
		
		sprintf(io_pPropertyInstance->szPropertyText, "Player ID = 0x%X", *io_pPropertyInstance->lpDword);

	} // FormatPropertyInstance_PlayerID



	// DESCRIPTION: Custom description formatter for the Old Host ID property
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_OldHostID( LPPROPERTYINST io_pPropertyInstance )
	{
		
		sprintf(io_pPropertyInstance->szPropertyText, "Old Host ID = 0x%X", *io_pPropertyInstance->lpDword);

	} // FormatPropertyInstance_OldHostID

	
	
	// DESCRIPTION: Custom description formatter for the New Host ID property
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_NewHostID( LPPROPERTYINST io_pPropertyInstance )
	{
		
		sprintf(io_pPropertyInstance->szPropertyText, "New Host ID = 0x%X", *io_pPropertyInstance->lpDword);

	} // FormatPropertyInstance_NewHostID


	// DESCRIPTION: Custom description formatter for the Group ID property
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_GroupID( LPPROPERTYINST io_pPropertyInstance )
	{
		
		sprintf(io_pPropertyInstance->szPropertyText, "Group ID = 0x%X", *io_pPropertyInstance->lpDword);

	} // FormatPropertyInstance_GroupID

	

	struct NAMETABLEENTRY_INSTDATA
	{
		DN_INTERNAL_MESSAGE_ALL* pBase;
		DWORD dwEntry;	// if -1, then not printed
	};


	// DESCRIPTION: Custom description formatter for the NameTable Entry summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_NameTableEntrySummary( LPPROPERTYINST io_pPropertyInstance )
	{

		DN_NAMETABLE_ENTRY_INFO& rNameTableEntry = *reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(io_pPropertyInstance->lpPropertyInstEx->lpData);
		
		NAMETABLEENTRY_INSTDATA& rInstData = *reinterpret_cast<NAMETABLEENTRY_INSTDATA*>(io_pPropertyInstance->lpPropertyInstEx->Byte);
		
		enum { nMAX_PLAYER_NAME = 64 };
		char arr_cPlayerName[nMAX_PLAYER_NAME];

		if ( rNameTableEntry.dwNameSize )
		{
			// Convert the UNICODE name into its ANSI equivalent
			WideCharToMultiByte(CP_ACP, 0, reinterpret_cast<WCHAR*>(&rInstData.pBase->bOffsetBase + rNameTableEntry.dwNameOffset),
								rNameTableEntry.dwNameSize, arr_cPlayerName, sizeof(arr_cPlayerName), NULL, NULL);
		}
		else
		{
			strcpy(arr_cPlayerName, "No name");
		}

		if ( rInstData.dwEntry == -1 )
		{
			sprintf(io_pPropertyInstance->szPropertyText, "%s (ID=0x%X) (%s)", arr_cPlayerName, rNameTableEntry.dpnid,
					MapSetFlagsToLabels(g_arr_FlagsBitLabels, sizeof(g_arr_FlagsBitLabels)/sizeof(LABELED_BIT), rNameTableEntry.dwFlags).c_str());
		}
		else
		{
			sprintf(io_pPropertyInstance->szPropertyText, "%d.  %s (ID=0x%X) (%s)", rInstData.dwEntry, arr_cPlayerName, rNameTableEntry.dpnid,
					MapSetFlagsToLabels(g_arr_FlagsBitLabels, sizeof(g_arr_FlagsBitLabels)/sizeof(LABELED_BIT), rNameTableEntry.dwFlags).c_str());
		}
		
	} // FormatPropertyInstance_NameTableEntrySummary


	// DESCRIPTION: Custom description formatter for the NameTable Entry summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_NameTableMembershipSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		DN_NAMETABLE_MEMBERSHIP_INFO& rNameTableMembershipInfo = *reinterpret_cast<DN_NAMETABLE_MEMBERSHIP_INFO*>(io_pPropertyInstance->lpPropertyInstEx->lpData);

		sprintf(io_pPropertyInstance->szPropertyText, "%d. Player 0x%X is in group 0x%X (ver=%d)", io_pPropertyInstance->lpPropertyInstEx->Dword[0],
				rNameTableMembershipInfo.dpnidPlayer, rNameTableMembershipInfo.dpnidGroup, rNameTableMembershipInfo.dwVersion);

	} // FormatPropertyInstance_NameTableMembershipSummary



	//==================//
	// Properties table //-----------------------------------------------------------------------------------------------
	//==================//
	
	PROPERTYINFO g_arr_SessionProperties[] = 
	{

		// Session packet summary property (SESSION_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "DPlay Session packet",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_SessionSummary		// generic formatter
		},

		// Message Type property (SESSION_UNPARSABLEFRAGMENT)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "This is a non-initial part of the fragmented Transport layer message and can not be parsed", // label
		    "Unparsable fragment summary",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Message Type property (SESSION_INCOMPLETEMESSAGE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "The rest of the data needed to parse this message has been sent in a separate fragment and can not be parsed",  // label
		    "Incomplete message summary",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Message Type property (SESSION_INCOMPLETEFIELD)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "The rest of the data needed to parse this field is in a separate fragment. Field value may look corrupted!",  // label
		    "Incomplete field summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    150,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Message Type property (SESSION_MESSAGETYPE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Message Type",								// label
		    "Message Type field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_LABELED_SET,						// data type qualifier.
		    &g_LabeledMessageTypeDWordSet,				// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Player's ID property (SESSION_PLAYERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Player ID",								// label
		    "Player ID field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_PlayerID				// generic formatter
		},

		// Result Code property (SESSION_RESULTCODE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Result Code",								// label
		    "Result Code field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type (HRESULT)
			PROP_QUAL_LABELED_SET,						// data type qualifier.
			&g_LabeledResultCodeDWordSet,				// labeled byte set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		//  DPlay Version property (SESSION_DPLAYVERSION)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "DPlay's version",							// label
		    "DPlay's version field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_VersionSummary		// generic formatter
		},

		//  Build Day property (SESSION_BUILDDAY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Build's Day",								// label
		    "Build's Day field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		//  Build Month property (SESSION_BUILDMONTH)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Build's Month",							// label
		    "Build's Month field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		//  Build Year property (SESSION_BUILDYEAR)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Build's Year (starting from 2000)",		// label
		    "Build's Year field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		//  Flags summary property (SESSION_FLAGS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Flags summary",							// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_FlagsSummary			// generic formatter
		},

		//  Flags property (SESSION_FLAGS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Flags",									// label
		    "Flags field",								// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_FLAGS,							// data type qualifier.
		    &g_LabeledFlagsBitSet,						// labeled bit set 
		    2048,										// description's maximum length
		    FormatPropertyInstance      				// generic formatter
		},

		//  Flags summary property (SESSION_INFOFLAGS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Information Flags summary",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_InfoFlagsSummary		// generic formatter
		},

		//  Flags property (SESSION_INFOFLAGS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Information Flags",						// label
		    "Information Flags field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_FLAGS,							// data type qualifier.
		    &g_LabeledInfoFlagsBitSet,					// labeled bit set 
		    2048,										// description's maximum length
		    FormatPropertyInstance      				// generic formatter
		},

		//  Flags summary property (SESSION_GROUPFLAGS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Group Flags summary",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_GroupFlagsSummary	// generic formatter
		},

		//  Flags property (SESSION_GROUPFLAGS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Group Flags",								// label
		    "Group Flags field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_FLAGS,							// data type qualifier.
		    &g_LabeledGroupFlagsBitSet,					// labeled bit set 
		    2048,										// description's maximum length
		    FormatPropertyInstance      				// generic formatter
		},

		//  Offset property (SESSION_FIELDOFFSET)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Offset",									// label
		    "Offset field",								// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		//  Size property (SESSION_FIELDSIZE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Size",										// label
		    "Size field",								// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Session Name property (SESSION_SESSIONNAME)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Session Name",								// label
		    "Session Name field",						// status-bar comment
		    PROP_TYPE_STRING,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No Session Name summary property (SESSION_NOSESSIONNAME_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Session Name",							// label
		    "No Session Name summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Player Name property (SESSION_PLAYERNAME)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Player name",								// label
		    "Player name field",						// status-bar comment
		    PROP_TYPE_STRING,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No Player Name summary property (SESSION_NOPLAYERNAME_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Player Name",							// label
		    "No Player Name summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Data property (SESSION_DATA)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Data",										// label
		    "Data field",								// status-bar comment
		    PROP_TYPE_VOID,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No Data summary property (SESSION_NODATA_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Data",									// label
		    "No Data summary",							// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Data property (SESSION_REPLY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Reply",									// label
		    "Reply field",								// status-bar comment
		    PROP_TYPE_STRING,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No Data summary property (SESSION_NOREPLY_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Reply",									// label
		    "No Reply summary",							// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Password property (SESSION_PASSWORD)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Password",									// label
		    "Password field",							// status-bar comment
		    PROP_TYPE_STRING,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No Password summary property (SESSION_NOPASSWORD_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Password",								// label
		    "No Password summary",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance                		// generic formatter
		},
		
		// Connection Data property (SESSION_CONNECTIONDATA)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Connection Data",							// label
		    "Connection Data field",					// status-bar comment
		    PROP_TYPE_VOID,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No Connection Data summary property (SESSION_NOCONNECTIONDATA_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Connection Data",						// label
		    "No Connection Data summary",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// URL property (SESSION_URL)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "URL",										// label
		    "URL field",								// status-bar comment
		    PROP_TYPE_STRING,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No URL summary property (SESSION_NOURL_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No URL",									// label
		    "No URL summary",							// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Application GUID property (SESSION_APPGUID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Application GUID",							// label
		    "Application GUID field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_ApplicationGUID		// generic formatter
		},

		// Instance GUID property (SESSION_INSTGUID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Instance GUID",							// label
		    "Instance GUID field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_InstanceGUID			// generic formatter
		},
	
		// Application Description summary property (SESSION_APPDESCINFO_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Application Description summary",			// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance_AppDescSummary		// generic formatter
		},

		// Application Description's Size property (SESSION_APPDESCINFOSIZE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Application Description's Size",			// label
		    "Application Description's Size field",		// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Maximum Number of Players property (SESSION_MAXPLAYERS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Maximum Number of Players",				// label
		    "Maximum Number of Players field",			// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_LABELED_SET,						// data type qualifier.
		    &g_LabeledMaxNumOfPlayersDWordSet,			// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Current Number of Players property (SESSION_CURRENTPLAYERS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Current Number of Players",				// label
		    "Current Number of Players field",			// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Reserved Data property (SESSION_RESERVEDDATA)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Reserved Data",							// label
		    "Reserved Data",							// status-bar comment
		    PROP_TYPE_VOID,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// No Reserved Data summary property (SESSION_NORESERVEDDATA_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Reserved Data",							// label
		    "No Reserved Data summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Application Reserved Data property (SESSION_APPRESERVEDDATA)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Application Reserved Data",				// label
		    "Application Reserved Data",				// status-bar comment
		    PROP_TYPE_VOID,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		    
		// No Application Reserved Data summary property (SESSION_NOAPPRESERVEDDATA_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Application Reserved Data",				// label
		    "No Application Reserved Data summary",		// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// NameTable's summary property (SESSION_NAMETABLEINFO_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "NameTable's summary",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance_NameTableSummary		// generic formatter
		},

		//  Version property (SESSION_VERSION)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Version",									// label
		    "Version field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		//  RESERVED property (SESSION_RESERVED)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "RESERVED",									// label
		    "RESERVED field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
	
		//  Number of Entries in the NameTable property (SESSION_NUMBEROFENTRIES)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Number of Entries",						// label
		    "Number of Entries field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		//  Number of Memberships in the NameTable property (SESSION_NUMBEROFMEMBERSHIPS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Number of Memberships",					// label
		    "Number of Memberships field",				// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// NameTable Entry summary property (SESSION_PLAYERS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Players",									// label
		    "NameTable player entries summary",			// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// NameTable Entry summary property (SESSION_GROUPS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Groups",									// label
		    "NameTable group entries summary",			// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// NameTable Entry summary property (SESSION_NAMETABLEENTRY_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "NameTable Entry summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    256,										// description's maximum length
		    FormatPropertyInstance_NameTableEntrySummary // generic formatter
		},

		// Owner's ID property (SESSION_OWNERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Owner ID",									// label
		    "Owner ID field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// NameTable Memberships summary property (SESSION_NAMETABLEMEMBERSHIPS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Memberships",					 			// label
		    "Memberships summary",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// NameTable Membership Entry summary property (SESSION_NAMETABLEMEMBERSHIPENTRY_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "", 										// label
		    "Membership Entry summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance_NameTableMembershipSummary // generic formatter
		},

		// Group's ID property (SESSION_GROUPID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Group ID",									// label
		    "Group ID field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_GroupID				// generic formatter
		},
		
		// Old Host ID property (SESSION_OLDHOSTID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Old Host ID",								// label
		    "Old Host ID field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_OldHostID			// generic formatter
		},
		
		// New Host ID property (SESSION_NEWHOSTID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "New Host ID",								// label
		    "New Host ID field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_NewHostID			// generic formatter
		},

		// New Host ID property (SESSION_SYNCID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Synchronization ID",						// label
		    "Synchronization ID field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Player's ID property (SESSION_REQUESTINGPLAYERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Requesting Player ID",						// label
		    "Requesting Player ID field",				// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		    
		// Player Destruction Reason property (SESSION_PLAYERDESTRUCTIONREASON)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Reason",									// label
		    "Reason field",								// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_LABELED_SET,						// data type qualifier.
		    &g_LabeledPlayerDestructionReasonDWordSet,	// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Target Peer's ID property (SESSION_TARGETPEERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Target Peer ID",							// label
		    "Target Peer ID field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Requesting Peer's ID property (SESSION_REQUESTINGPEERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Requesting Peer ID",						// label
		    "Requesting Peer ID field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		}
		
	};

	enum
	{
		nNUM_OF_Session_PROPS = sizeof(g_arr_SessionProperties) / sizeof(PROPERTYINFO)
	};


	// Properties' indices
	enum
	{
		SESSION_SUMMARY = 0,
		SESSION_UNPARSABLEFRAGMENT,
		SESSION_INCOMPLETEMESSAGE,
		SESSION_INCOMPLETEFIELD,
			
		SESSION_MESSAGETYPE,
		SESSION_PLAYERID,
		SESSION_RESULTCODE,
	
		SESSION_DPLAYVERSION,
		SESSION_BUILDDAY,
		SESSION_BUILDMONTH,
		SESSION_BUILDYEAR,

		SESSION_FLAGS_SUMMARY,
		SESSION_FLAGS,

		SESSION_INFOFLAGS_SUMMARY,
		SESSION_INFOFLAGS,


		SESSION_GROUPFLAGS_SUMMARY,
		SESSION_GROUPFLAGS,

		SESSION_FIELDOFFSET,
		SESSION_FIELDSIZE,
		
		SESSION_SESSIONNAME,
		SESSION_NOSESSIONNAME_SUMMARY,
		
		SESSION_PLAYERNAME,
		SESSION_NOPLAYERNAME_SUMMARY,
		
		SESSION_DATA,
		SESSION_NODATA_SUMMARY,

		SESSION_REPLY,
		SESSION_NOREPLY_SUMMARY,
		
		SESSION_PASSWORD,
		SESSION_NOPASSWORD_SUMMARY,
		
		SESSION_CONNECTIONDATA,
		SESSION_NOCONNECTIONDATA_SUMMARY,
		
		SESSION_URL,
		SESSION_NOURL_SUMMARY,
		
		SESSION_APPGUID,
		SESSION_INSTGUID,

		SESSION_APPDESCINFO_SUMMARY,
		SESSION_APPDESCINFOSIZE,
		SESSION_MAXPLAYERS,
		SESSION_CURRENTPLAYERS,
		
		SESSION_RESERVEDDATA,
		SESSION_NORESERVEDDATA_SUMMARY,

		SESSION_APPRESERVEDDATA,
		SESSION_NOAPPRESERVEDDATA_SUMMARY,

		SESSION_NAMETABLEINFO_SUMMARY,

		SESSION_VERSION,
		SESSION_RESERVED,
		
		SESSION_NUMBEROFENTRIES,
		SESSION_NUMBEROFMEMBERSHIPS,

		SESSION_PLAYERS_SUMMARY,
		SESSION_GROUPS_SUMMARY,

		SESSION_NAMETABLEENTRY_SUMMARY,
		SESSION_OWNERID,

		SESSION_NAMETABLEMEMBERSHIPS_SUMMARY,
		SESSION_NAMETABLEMEMBERSHIPENTRY_SUMMARY,
		SESSION_GROUPID,

		SESSION_OLDHOSTID,
		SESSION_NEWHOSTID,

		SESSION_SYNCID,
		SESSION_REQUESTINGPLAYERID,
		
		SESSION_PLAYERDESTRUCTIONREASON,

		SESSION_TARGETPEERID,
		SESSION_REQUESTINGPEERID
	};

} // anonymous namespace








// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hSessionProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI SessionRegister( HPROTOCOL i_hSessionProtocol ) 
{

	// TODO: PROCESS THE RETURN VALUE
	CreatePropertyDatabase(i_hSessionProtocol, nNUM_OF_Session_PROPS);

	// Add the properties to the database
	for( int nProp=0; nProp < nNUM_OF_Session_PROPS; ++nProp )
	{
	   // TODO: PROCESS THE RETURN VALUE
	   AddProperty(i_hSessionProtocol, &g_arr_SessionProperties[nProp]);
	}

} // SessionRegister



// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hSessionProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI SessionDeregister( HPROTOCOL i_hProtocol )
{

	// TODO: PROCESS THE RETURN VALUE
	DestroyPropertyDatabase(i_hProtocol);

} // SessionDeregister



namespace
{

	// DESCRIPTION: Parses the Session frame to find its size (in bytes) NOT including the user data
	//
	// ARGUMENTS: i_pbSessionFrame - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
	//						    in the middle of a frame because a previous parser has claimed data before this parser.
	//
	// RETURNS: Size of the Sessionecified Session frame (in bytes)
	//
	int SessionHeaderSize( LPBYTE i_pbSessionFrame )
	{
		DN_INTERNAL_MESSAGE_FULLMSG& rSessionFrame = *reinterpret_cast<DN_INTERNAL_MESSAGE_FULLMSG*>(i_pbSessionFrame);

		DN_INTERNAL_MESSAGE_ALL& rMsgBody = rSessionFrame.MsgBody;

		int nHeaderSize = sizeof(rSessionFrame.dwMsgType);

		switch ( rSessionFrame.dwMsgType )
		{
		case DN_MSG_INTERNAL_PLAYER_CONNECT_INFO:
			{
				nHeaderSize += sizeof(rMsgBody.dnPlayerConnectInfo) + rMsgBody.dnPlayerConnectInfo.dwNameSize + rMsgBody.dnPlayerConnectInfo.dwDataSize +
							   rMsgBody.dnPlayerConnectInfo.dwPasswordSize + rMsgBody.dnPlayerConnectInfo.dwConnectDataSize + rMsgBody.dnPlayerConnectInfo.dwURLSize;
				break;
			}

		case DN_MSG_INTERNAL_SEND_CONNECT_INFO:
			{
				DPN_APPLICATION_DESC_INFO&  rApplicationDescInfo = *reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(&rMsgBody.dnConnectInfo + 1);
				DN_NAMETABLE_INFO&			 rNameTableInfo      = *reinterpret_cast<DN_NAMETABLE_INFO*>(&rApplicationDescInfo + 1);
				DN_NAMETABLE_ENTRY_INFO*	 pNameTableEntryInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(&rNameTableInfo + 1);

				nHeaderSize += sizeof(DN_INTERNAL_MESSAGE_CONNECT_INFO) + rApplicationDescInfo.dwSize + sizeof(DN_NAMETABLE_INFO) +
					   		   rNameTableInfo.dwEntryCount * sizeof(DN_NAMETABLE_ENTRY_INFO) +
					   		   rNameTableInfo.dwMembershipCount * sizeof(DN_NAMETABLE_MEMBERSHIP_INFO);

				for ( size_t sztEntry = 1; sztEntry <= rNameTableInfo.dwEntryCount; ++sztEntry, ++pNameTableEntryInfo )
				{
					nHeaderSize += pNameTableEntryInfo->dwNameSize + pNameTableEntryInfo->dwDataSize + pNameTableEntryInfo->dwURLSize;
				}

				break;
				
			}

		case DN_MSG_INTERNAL_ACK_CONNECT_INFO:
			{
				// No fields
				break;
			}

		case DN_MSG_INTERNAL_SEND_PLAYER_DNID:
			{
				nHeaderSize += sizeof(rMsgBody.dnSendPlayerID);

				break;
			}

		case DN_MSG_INTERNAL_CONNECT_FAILED:
			{
				nHeaderSize += sizeof(rMsgBody.dnConnectFailed);

				break;
			}

		case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
			{
				nHeaderSize += sizeof(rMsgBody.dnInstructConnect);

				break;
			}

		case DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED:
			{
				nHeaderSize += sizeof(rMsgBody.dnInstructedConnectFailed);

				break;
			}

		case DN_MSG_INTERNAL_NAMETABLE_VERSION:
			{
				nHeaderSize += sizeof(rMsgBody.dnNametableVersion);

				break;
			}

		case DN_MSG_INTERNAL_RESYNC_VERSION:
			{
				nHeaderSize += sizeof(rMsgBody.dnResyncVersion);

				break;
			}

		case DN_MSG_INTERNAL_REQ_NAMETABLE_OP:
			{
				nHeaderSize += sizeof(rMsgBody.dnReqNametableOp);

				break;
			}

		case DN_MSG_INTERNAL_ACK_NAMETABLE_OP:
			{
				nHeaderSize += sizeof(rMsgBody.dnAckNametableOp);

				const DN_NAMETABLE_OP_INFO* pOpInfo = reinterpret_cast<DN_NAMETABLE_OP_INFO*>(&rMsgBody.dnAckNametableOp.dwNumEntries + 1);
				for ( size_t sztOp = 0; sztOp < rMsgBody.dnAckNametableOp.dwNumEntries; ++sztOp, ++pOpInfo )
				{
					nHeaderSize += sizeof(*pOpInfo) + pOpInfo->dwOpSize;
				}

				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE:
			{
				nHeaderSize += sizeof(rMsgBody.dnHostMigrate);

				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE:
			{
				// No fields
				break;
			}

		case DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC:
			{
				nHeaderSize += rMsgBody.dnUpdateAppDescInfo.dwSize;
				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER:
			{
				nHeaderSize += sizeof(rMsgBody.dnAddPlayer) + rMsgBody.dnAddPlayer.dwDataSize +
							   rMsgBody.dnAddPlayer.dwNameSize + rMsgBody.dnAddPlayer.dwURLSize;
				break;
			}

		case DN_MSG_INTERNAL_DESTROY_PLAYER:
			{
				nHeaderSize += sizeof(rMsgBody.dnDestroyPlayer);

				break;
			}

		case DN_MSG_INTERNAL_REQ_CREATE_GROUP:
			{
				nHeaderSize += sizeof(rMsgBody.dnReqProcessCompletionHeader) + sizeof(rMsgBody.dnReqCreateGroup) +
							   rMsgBody.dnReqCreateGroup.dwNameSize + rMsgBody.dnReqCreateGroup.dwDataSize;

				break;
			}

		case DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP:
		case DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP:	// same structure as in AddPlayerToGroup
			{
				nHeaderSize += sizeof(rMsgBody.dnReqProcessCompletionHeader) + sizeof(rMsgBody.dnAddPlayerToGroup);

				break;
			}

		case DN_MSG_INTERNAL_REQ_DESTROY_GROUP:
			{
				nHeaderSize += sizeof(rMsgBody.dnReqProcessCompletionHeader) + sizeof(rMsgBody.dnReqDestroyGroup);

				break;
			}

		case DN_MSG_INTERNAL_REQ_UPDATE_INFO:
			{
				nHeaderSize += sizeof(rMsgBody.dnReqProcessCompletionHeader) + sizeof(rMsgBody.dnReqUpdateInfo) +
								rMsgBody.dnReqUpdateInfo.dwNameSize + rMsgBody.dnReqUpdateInfo.dwDataSize;

				break;
			}

		case DN_MSG_INTERNAL_CREATE_GROUP:
			{
				nHeaderSize += sizeof(rMsgBody.dnCreateGroup);

				break;
			}

		case DN_MSG_INTERNAL_DESTROY_GROUP:
			{
				nHeaderSize += sizeof(rMsgBody.dnDestroyGroup);

				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
		case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:		// same structure as AddPlayerToGroup
			{
				nHeaderSize += sizeof(rMsgBody.dnAddPlayerToGroup);

				break;
			}

		case DN_MSG_INTERNAL_UPDATE_INFO:
			{
				nHeaderSize += sizeof(rMsgBody.dnUpdateInfo) + rMsgBody.dnUpdateInfo.dwNameSize + rMsgBody.dnUpdateInfo.dwDataSize;

				break;
			}

		case DN_MSG_INTERNAL_BUFFER_IN_USE:
			{
				// No fields
				break;
			}

		case DN_MSG_INTERNAL_REQUEST_FAILED:
			{
				nHeaderSize += sizeof(rMsgBody.dnRequestFailed);
				break;
			}

		case DN_MSG_INTERNAL_TERMINATE_SESSION:
			{
				nHeaderSize += sizeof(rMsgBody.dnTerminateSession) + rMsgBody.dnTerminateSession.dwTerminateDataSize;
				break;
			}

		case DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION:
			{
				nHeaderSize += sizeof(rMsgBody.dnReqProcessCompletion);

				break;
			}

		case DN_MSG_INTERNAL_PROCESS_COMPLETION	:
			{
				nHeaderSize += sizeof(rMsgBody.dnProcessCompletion);

				break;
			}

		case DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK:
			{
				nHeaderSize += sizeof(rMsgBody.dnReqProcessCompletionHeader) + sizeof(rMsgBody.dnReqIntegrityCheck);

				break;
			}


		case DN_MSG_INTERNAL_INTEGRITY_CHECK:
			{
				nHeaderSize += sizeof(rMsgBody.dnIntegrityCheck);

				break;
			}

		case DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE:
			{
				nHeaderSize += sizeof(rMsgBody.dnIntegrityCheckResponse);

				break;
			}
		default:
			{
				return -1;	 // TODO:		DPF(0, "Unknown Session frame!");
			}
		}

		return nHeaderSize;

	} // SessionHeaderSize

} // Anonymous namespace



// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbSessionFrame    - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbSessionFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI SessionRecognizeFrame( HFRAME        i_hFrame,
													ULPBYTE        i_upbMacFrame,	
													ULPBYTE        i_upbySessionFrame,
													DWORD         i_dwMacType,        
													DWORD         i_dwBytesLeft,      
													HPROTOCOL     i_hPrevProtocol,  
													DWORD         i_dwPrevProtOffset,
													LPDWORD       o_pdwProtocolStatus,
													LPHPROTOCOL   o_phNextProtocol,
													PDWORD_PTR    io_pdwptrInstData )
{

	// Validate the amount of unclaimed data
	enum
	{
		// TODO: CHANGE TO PROPER MIN SIZE
		nMIN_SessionHeaderSize  = sizeof(DWORD),
		nNUMBER_OF_MSG_TYPES = sizeof(g_arr_MessageTypeDWordLabels) / sizeof(LABELED_DWORD)
	};

	for ( int nTypeIndex = 0; nTypeIndex < nNUMBER_OF_MSG_TYPES; ++nTypeIndex )
	{
		if ( g_arr_MessageTypeDWordLabels[nTypeIndex].Value == *i_upbySessionFrame )
		{
			break;
		}
	}

	
	// Validate the packet as DPlay Session type
	if ( ((i_dwBytesLeft >= nMIN_SessionHeaderSize)  &&  (nTypeIndex < nNUMBER_OF_MSG_TYPES))  ||  (*io_pdwptrInstData == 0) )
	{
		// Claim the remaining data
	    *o_pdwProtocolStatus = PROTOCOL_STATUS_CLAIMED;
	    return ( g_upbyPastEndOfFrame = i_upbySessionFrame + SessionHeaderSize(i_upbySessionFrame) );
	}

	// Assume the unclaimed data is not recognizable
	*o_pdwProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
	return i_upbySessionFrame;

} // SessionRecognizeFrame


namespace
{

	// DESCRIPTION: 
	//
	// ARGUMENTS: i_hFrame        - Handle of the frame that is being parsed.
	//			   i_nProperty	   -
	//			   i_pSessionFrame  -
	//			   i_pdwOffset	   -
	//			   i_pdwSize	   -
	//			   i_dwFlags	   -
	//			   i_nLevel		   -
	//
	// RETURNS: NOTHING
	//
	void AttachValueOffsetSizeProperties( HFRAME i_hFrame, int i_nProperty, DN_INTERNAL_MESSAGE_ALL* i_pBase,
									  	  DWORD* i_pdwOffset, DWORD* i_pdwSize, DWORD i_dwFlags, int i_nLevel )
	{
	
		if ( *i_pdwSize )
		{
			// Value field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[i_nProperty].hProperty,
								   *i_pdwSize, &i_pBase->bOffsetBase + *i_pdwOffset, 0, i_nLevel, i_dwFlags);

			// If the field's value is outside the frame, let the user know it will show up incomplete or corrupted
			if ( &i_pBase->bOffsetBase + *i_pdwOffset + *i_pdwSize >= g_upbyPastEndOfFrame )
			{
		    	AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INCOMPLETEFIELD].hProperty,
		    						*i_pdwSize, &i_pBase->bOffsetBase + *i_pdwOffset, 0, i_nLevel+1, 0);
			}
			
			// Value's Offset field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FIELDOFFSET].hProperty,
							  	   sizeof(*i_pdwOffset), i_pdwOffset, 0, i_nLevel + 1, 0);
			// Value's Size field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FIELDSIZE].hProperty,
								   sizeof(*i_pdwSize), i_pdwSize, 0, i_nLevel + 1, 0);
		}
		else
		{
			// No field summary
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[i_nProperty + 1].hProperty,
								   sizeof(*i_pdwOffset) + sizeof(*i_pdwSize), i_pdwOffset, 0, i_nLevel, 0);
		}
		
	}// AttachValueOffsetSizeProperties



	// DESCRIPTION: Attaches the properties to the nametable entry
	//
	// ARGUMENTS: i_hFrame 		        -  Handle of the frame that is being parsed
	//			   i_pNameTableEntryInfo  -  Pointer to the beginning of nametable's entry
	//			   i_dwEntry		    -  Ordinal number of the entry (if -1, then not printed)
	//			   i_pSessionFrame	    -  Pointer to the beginning of the protocol data in a frame.
	//
	// RETURNS: NOTHING
	//
	void AttachNameTableEntry(HFRAME i_hFrame, DN_NAMETABLE_ENTRY_INFO* i_pNameTableEntryInfo, DWORD i_dwEntry,
							DN_INTERNAL_MESSAGE_ALL* i_pBase )
	{

		NAMETABLEENTRY_INSTDATA  rInstData = { i_pBase, i_dwEntry };

		// NameTable entry summary
		AttachPropertyInstanceEx(i_hFrame, g_arr_SessionProperties[SESSION_NAMETABLEENTRY_SUMMARY].hProperty,
								 sizeof(*i_pNameTableEntryInfo), i_pNameTableEntryInfo,
								 sizeof(rInstData), &rInstData, 0, 3, 0);

		if ( i_pNameTableEntryInfo->dwFlags & NAMETABLE_ENTRY_FLAG_ANY_GROUP )
		{

			// Player ID field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
								sizeof(i_pNameTableEntryInfo->dpnid), &i_pNameTableEntryInfo->dpnid, 0, 4, 0);
		}
		else
		{
			// Group ID field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPID].hProperty,
								sizeof(i_pNameTableEntryInfo->dpnid), &i_pNameTableEntryInfo->dpnid, 0, 4, 0);
		}

		
		// Owner ID field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_OWNERID].hProperty,
							sizeof(i_pNameTableEntryInfo->dpnidOwner), &i_pNameTableEntryInfo->dpnidOwner, 0, 4, 0);

		// Flags summary
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FLAGS_SUMMARY].hProperty,
							sizeof(i_pNameTableEntryInfo->dwFlags), &i_pNameTableEntryInfo->dwFlags, 0, 4, 0);

		// Flags field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FLAGS].hProperty,
							sizeof(i_pNameTableEntryInfo->dwFlags), &i_pNameTableEntryInfo->dwFlags, 0, 5, 0);

		// Version field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
							sizeof(i_pNameTableEntryInfo->dwVersion), &i_pNameTableEntryInfo->dwVersion, 0, 4, 0);

		// RESERVED field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
							sizeof(i_pNameTableEntryInfo->dwVersionNotUsed), &i_pNameTableEntryInfo->dwVersionNotUsed, 0, 4, 0);
		
		// DPlay Version field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_DPLAYVERSION].hProperty,
							sizeof(i_pNameTableEntryInfo->dwDNETVersion), &i_pNameTableEntryInfo->dwDNETVersion, 0, 4, 0);


		// Player Name field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_PLAYERNAME, i_pBase,
								   &i_pNameTableEntryInfo->dwNameOffset, &i_pNameTableEntryInfo->dwNameSize, IFLAG_UNICODE, 4);

		// Data field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_DATA, i_pBase,
								   &i_pNameTableEntryInfo->dwDataOffset, &i_pNameTableEntryInfo->dwDataSize, NULL, 4);

		// URL field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_URL, i_pBase,
								   &i_pNameTableEntryInfo->dwURLOffset, &i_pNameTableEntryInfo->dwURLSize, NULL, 4);

	} // AttachNameTableEntry


	
	// DESCRIPTION: Attaches the properties to the Application Description structure
	//
	// ARGUMENTS: i_hFrame 		   	   - Handle of the frame that is being parsed.
	//			   i_pbSessionFrame	   - Pointer to the beginning of the protocol data in a frame.
	//			   i_pApplicationDescInfo - Pointer to the beginning of the application description.
	//
	// RETURNS: NOTHING
	//
	void AttachApplicationDescriptionProperties( HFRAME i_hFrame, DN_INTERNAL_MESSAGE_ALL* i_pBase,
										  DPN_APPLICATION_DESC_INFO* i_pApplicationDescInfo )
	{
	
		// Application Description summary
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_APPDESCINFO_SUMMARY].hProperty,
							sizeof(*i_pApplicationDescInfo), i_pApplicationDescInfo, 0, 1, 0);
		
		// Application Description's Size field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_APPDESCINFOSIZE].hProperty,
							sizeof(i_pApplicationDescInfo->dwSize), &i_pApplicationDescInfo->dwSize, 0, 2, 0);

		// Flags summary
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FLAGS_SUMMARY].hProperty,
							sizeof(i_pApplicationDescInfo->dwFlags), &i_pApplicationDescInfo->dwFlags, 0, 2, 0);
		// Flags field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FLAGS].hProperty,
							sizeof(i_pApplicationDescInfo->dwFlags), &i_pApplicationDescInfo->dwFlags, 0, 3, 0);

		// Maximum Number of Players field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_MAXPLAYERS].hProperty,
							sizeof(i_pApplicationDescInfo->dwMaxPlayers), &i_pApplicationDescInfo->dwMaxPlayers, 0, 2, 0);
		
		// Current Number of Players field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_CURRENTPLAYERS].hProperty,
							sizeof(i_pApplicationDescInfo->dwCurrentPlayers), &i_pApplicationDescInfo->dwCurrentPlayers, 0, 2, 0);

		
		// Session Name field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_SESSIONNAME, i_pBase,
								   &i_pApplicationDescInfo->dwSessionNameOffset, &i_pApplicationDescInfo->dwSessionNameSize, IFLAG_UNICODE, 2);

		// Password field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_PASSWORD, i_pBase,
								   &i_pApplicationDescInfo->dwPasswordOffset, &i_pApplicationDescInfo->dwPasswordSize, IFLAG_UNICODE, 2);

		// Reserved Data field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_RESERVEDDATA, i_pBase,
								   &i_pApplicationDescInfo->dwReservedDataOffset, &i_pApplicationDescInfo->dwReservedDataSize, NULL, 2);

		// Application Reserved Data field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_APPRESERVEDDATA, i_pBase,
								   &i_pApplicationDescInfo->dwApplicationReservedDataOffset, &i_pApplicationDescInfo->dwApplicationReservedDataSize, NULL, 2);


		// Instance GUID field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INSTGUID].hProperty,
							sizeof(i_pApplicationDescInfo->guidInstance), &i_pApplicationDescInfo->guidInstance, 0, 2, 0);
		
		// Application GUID field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_APPGUID].hProperty,
							sizeof(i_pApplicationDescInfo->guidApplication), &i_pApplicationDescInfo->guidApplication, 0, 2, 0);

	} // AttachApplicationDescriptionProperties

	
	
	// DESCRIPTION: Attaches the properties to the Session Information packet
	//
	// ARGUMENTS: i_hFrame 		   - Handle of the frame that is being parsed.
	//			  i_pbSessionFrame - Pointer to the beginning of the protocol data in a frame.
	//
	// RETURNS: NOTHING
	//
	void AttachSessionInformationProperties( HFRAME i_hFrame, DN_INTERNAL_MESSAGE_ALL* i_pBase )
	{
	
		// Reply field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_REPLY, i_pBase,
								   &i_pBase->dnConnectInfo.dwReplyOffset, &i_pBase->dnConnectInfo.dwReplySize, NULL, 1);

		DPN_APPLICATION_DESC_INFO& rApplicationDescInfo = *reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(&i_pBase->dnConnectInfo + 1);
		
		AttachApplicationDescriptionProperties(i_hFrame, i_pBase, &rApplicationDescInfo);
		
		DN_NAMETABLE_INFO& rNameTableInfo = *reinterpret_cast<DN_NAMETABLE_INFO*>(&rApplicationDescInfo + 1);
		DN_NAMETABLE_ENTRY_INFO*	pNameTableEntryInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(&rNameTableInfo + 1);

		// Calculating the size of the nametable
		size_t sztNameTableSize = sizeof(DN_NAMETABLE_INFO) + 
			   					  rNameTableInfo.dwEntryCount * sizeof(DN_NAMETABLE_ENTRY_INFO) +
			   					  rNameTableInfo.dwMembershipCount * sizeof(DN_NAMETABLE_MEMBERSHIP_INFO);
		//
		for ( size_t sztEntry = 1; sztEntry <= rNameTableInfo.dwEntryCount; ++sztEntry, ++pNameTableEntryInfo )
		{
			sztNameTableSize += pNameTableEntryInfo->dwNameSize + pNameTableEntryInfo->dwDataSize + pNameTableEntryInfo->dwURLSize;
		}

		// Nametable's summary
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_NAMETABLEINFO_SUMMARY].hProperty,
							sztNameTableSize, &rNameTableInfo, 0, 1, 0);
		
		// Player ID field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
							sizeof(rNameTableInfo.dpnid), &rNameTableInfo.dpnid, 0, 2, 0);
		
		// Version field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
							sizeof(rNameTableInfo.dwVersion), &rNameTableInfo.dwVersion, 0, 2, 0);
		
		// RESERVED field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
							sizeof(rNameTableInfo.dwVersionNotUsed), &rNameTableInfo.dwVersionNotUsed, 0, 2, 0);

		// Number of NameTable Entries field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_NUMBEROFENTRIES].hProperty,
							sizeof(rNameTableInfo.dwEntryCount), &rNameTableInfo.dwEntryCount, 0, 2, 0);

		// Number of NameTable Memberships field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_NUMBEROFMEMBERSHIPS].hProperty,
							sizeof(rNameTableInfo.dwMembershipCount), &rNameTableInfo.dwMembershipCount, 0, 2, 0);



		pNameTableEntryInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(&rNameTableInfo + 1);

		// NameTable Player entries summary
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERS_SUMMARY].hProperty,
							rNameTableInfo.dwEntryCount * sizeof(*pNameTableEntryInfo), pNameTableEntryInfo, 0, 2, 0);
		
		std::queue<DN_NAMETABLE_ENTRY_INFO*> queGroups;

		// Process player entries
		int nPlayerEntry = 1;
		for ( sztEntry = 1; sztEntry <= rNameTableInfo.dwEntryCount; ++sztEntry, ++pNameTableEntryInfo )
		{
			// If the entry contains group information, enqueue it for later processing
			if ( pNameTableEntryInfo->dwFlags & NAMETABLE_ENTRY_FLAG_ANY_GROUP )
			{
				queGroups.push(pNameTableEntryInfo);
			}
			else
			{
				AttachNameTableEntry(i_hFrame, pNameTableEntryInfo, nPlayerEntry, i_pBase);
				++nPlayerEntry;
			}
		}

		DN_NAMETABLE_MEMBERSHIP_INFO* pNameTableMembershipInfo = reinterpret_cast<DN_NAMETABLE_MEMBERSHIP_INFO*>(pNameTableEntryInfo);

		// Process group entries
		if ( !queGroups.empty() )
		{
			pNameTableEntryInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(&rNameTableInfo + 1);

			// NameTable Group entries summary
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPS_SUMMARY].hProperty,
								   rNameTableInfo.dwEntryCount * sizeof(*pNameTableEntryInfo), pNameTableEntryInfo, 0, 2, 0);

			
			for ( nPlayerEntry = 1; !queGroups.empty(); queGroups.pop(), ++nPlayerEntry )
			{
				AttachNameTableEntry(i_hFrame, queGroups.front(), nPlayerEntry, i_pBase);
			}
		}


		// NameTable's Memberships summary
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_NAMETABLEMEMBERSHIPS_SUMMARY].hProperty,
							   rNameTableInfo.dwMembershipCount * sizeof(*pNameTableMembershipInfo), pNameTableMembershipInfo, 0, 2, 0);
		
		for ( sztEntry = 1; sztEntry <= rNameTableInfo.dwMembershipCount; ++sztEntry, ++pNameTableMembershipInfo )
		{
			// NameTable's Membership Entry summary
			AttachPropertyInstanceEx(i_hFrame, g_arr_SessionProperties[SESSION_NAMETABLEMEMBERSHIPENTRY_SUMMARY].hProperty,
									 sizeof(*pNameTableMembershipInfo), pNameTableMembershipInfo,
									 sizeof(sztEntry), &sztEntry, 0, 3, 0);
			
			// Player ID field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
							   	   sizeof(pNameTableMembershipInfo->dpnidPlayer), &pNameTableMembershipInfo->dpnidPlayer, 0, 4, 0);
			// Group ID field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPID].hProperty,
								   sizeof(pNameTableMembershipInfo->dpnidGroup), &pNameTableMembershipInfo->dpnidGroup, 0, 4, 0);
			
			// Version field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
								   sizeof(pNameTableMembershipInfo->dwVersion), &pNameTableMembershipInfo->dwVersion, 0, 4, 0);
			// RESERVED field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
								   sizeof(pNameTableMembershipInfo->dwVersionNotUsed), &pNameTableMembershipInfo->dwVersionNotUsed, 0, 4, 0);
		}
		
	} // AttachSessionInformationProperties



	// DESCRIPTION: Attaches the properties to the Session Information packet
	//
	// ARGUMENTS: i_hFrame 		       - Handle of the frame that is being parsed.
	//			   i_pPlayerConnectionInfo  - Pointer to the connecting player's information.
	//
	// RETURNS: NOTHING
	//
	void AttachPlayerInformationProperties( HFRAME i_hFrame, DN_INTERNAL_MESSAGE_ALL* i_pBase )
	{

			// Synonym declaration (to make code more readable)
			DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO& rPlayerConnectInfo = i_pBase->dnPlayerConnectInfo;
			
			// Flags summary
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FLAGS_SUMMARY].hProperty,
								   sizeof(rPlayerConnectInfo.dwFlags), &rPlayerConnectInfo.dwFlags, 0, 1, 0);
			// Flags field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FLAGS].hProperty,
								   sizeof(rPlayerConnectInfo.dwFlags), &rPlayerConnectInfo.dwFlags, 0, 2, 0);

			
			// DPlay Version field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_DPLAYVERSION].hProperty,
								   sizeof(rPlayerConnectInfo.dwDNETVersion), &rPlayerConnectInfo.dwDNETVersion, 0, 1, 0);
			// DPlay Version Day subfield
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_BUILDDAY].hProperty,
								   sizeof(BYTE), reinterpret_cast<LPBYTE>(&rPlayerConnectInfo.dwDNETVersion) + 2, 0, 2, 0);
			// DPlay Version Month subfield
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_BUILDMONTH].hProperty,
								   sizeof(BYTE), reinterpret_cast<LPBYTE>(&rPlayerConnectInfo.dwDNETVersion) + 1, 0, 2, 0);
			// DPlay Version Year subfield
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_BUILDYEAR].hProperty,
								   sizeof(BYTE), &rPlayerConnectInfo.dwDNETVersion, 0, 2, 0);



			// Player Name field
			AttachValueOffsetSizeProperties(i_hFrame, SESSION_PLAYERNAME, i_pBase,
									      &rPlayerConnectInfo.dwNameOffset, &rPlayerConnectInfo.dwNameSize, IFLAG_UNICODE, 1);
			
			// Data field
			AttachValueOffsetSizeProperties(i_hFrame, SESSION_DATA, i_pBase,
									      &rPlayerConnectInfo.dwDataOffset, &rPlayerConnectInfo.dwDataSize, NULL, 1);

			// Password field
			AttachValueOffsetSizeProperties(i_hFrame, SESSION_PASSWORD, i_pBase,
									      &rPlayerConnectInfo.dwPasswordOffset, &rPlayerConnectInfo.dwPasswordSize, IFLAG_UNICODE, 1);
		
			// Connection Data field
			AttachValueOffsetSizeProperties(i_hFrame, SESSION_CONNECTIONDATA, i_pBase,
									      &rPlayerConnectInfo.dwConnectDataOffset, &rPlayerConnectInfo.dwConnectDataSize, NULL, 1);

			// URL field
			AttachValueOffsetSizeProperties(i_hFrame, SESSION_URL, i_pBase,
									      &rPlayerConnectInfo.dwURLOffset, &rPlayerConnectInfo.dwURLSize, NULL, 1);

			
	
			// Instance GUID field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INSTGUID].hProperty,
								   sizeof(rPlayerConnectInfo.guidInstance), &rPlayerConnectInfo.guidInstance, 0, 1, 0);

			
			// Application GUID field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_APPGUID].hProperty,
								   sizeof(rPlayerConnectInfo.guidApplication), &rPlayerConnectInfo.guidApplication, 0, 1, 0);

	} // AttachPlayerInformationProperties



	// DESCRIPTION: Attaches the properties to a Session message packet or delegates to appropriate function
	//
	// ARGUMENTS: i_dwMsgType	   - Message ID
	//			   i_hFrame 	   - Handle of the frame that is being parsed.
	//			   i_pSessionFrame  - Pointer to the start of the recognized data.
	//
	// RETURNS: NOTHING
	//
	void AttachMessageProperties( const DWORD i_dwMsgType, const HFRAME i_hFrame, DN_INTERNAL_MESSAGE_ALL *const i_pBase )
	{
	
		switch ( i_dwMsgType )
		{
		case DN_MSG_INTERNAL_PLAYER_CONNECT_INFO:
			{
				AttachPlayerInformationProperties(i_hFrame, i_pBase);
				break;
			}

		case DN_MSG_INTERNAL_SEND_CONNECT_INFO:
			{

				AttachSessionInformationProperties(i_hFrame, i_pBase);
				break;
			}

		case DN_MSG_INTERNAL_ACK_CONNECT_INFO:
			{
				// No fields
				break;
			}

		case DN_MSG_INTERNAL_SEND_PLAYER_DNID:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnSendPlayerID.dpnid), &i_pBase->dnSendPlayerID.dpnid, 0, 1, 0);

				break;
			}
		
		case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnInstructConnect.dpnid), &i_pBase->dnInstructConnect.dpnid, 0, 1, 0);

				// Version field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
									sizeof(i_pBase->dnInstructConnect.dwVersion), &i_pBase->dnInstructConnect.dwVersion, 0, 1, 0);
				
				// RESERVED field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
									sizeof(i_pBase->dnInstructConnect.dwVersionNotUsed), &i_pBase->dnInstructConnect.dwVersionNotUsed, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_CONNECT_FAILED:
			{

				// Result Code field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESULTCODE].hProperty,
									   sizeof(i_pBase->dnConnectFailed.hResultCode), &i_pBase->dnConnectFailed.hResultCode, 0, 1, 0);

				// Reply field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_REPLY, i_pBase,
										   &i_pBase->dnConnectFailed.dwReplyOffset, &i_pBase->dnConnectFailed.dwReplySize, NULL, 1);
				
				break;
			}

		case DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnInstructedConnectFailed.dpnid), &i_pBase->dnInstructedConnectFailed.dpnid, 0, 1, 0);
				
				break;
			}

		case DN_MSG_INTERNAL_ACK_NAMETABLE_OP:
			{
				// Number of Entries field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_NUMBEROFENTRIES].hProperty,
									   sizeof(i_pBase->dnAckNametableOp.dwNumEntries), &i_pBase->dnAckNametableOp.dwNumEntries, 0, 1, 0);

				const DN_NAMETABLE_OP_INFO* pOpInfo = reinterpret_cast<DN_NAMETABLE_OP_INFO*>(&i_pBase->dnAckNametableOp.dwNumEntries + 1);
				for ( size_t sztOp = 0; sztOp < i_pBase->dnAckNametableOp.dwNumEntries; ++sztOp, ++pOpInfo )
				{
					AttachMessageProperties(pOpInfo->dwMsgId, i_hFrame, reinterpret_cast<DN_INTERNAL_MESSAGE_ALL*>(reinterpret_cast<BYTE*>(i_pBase) + pOpInfo->dwOpOffset));
				}

				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE:
			{
				// Old Host ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_OLDHOSTID].hProperty,
									sizeof(i_pBase->dnHostMigrate.dpnidOldHost), &i_pBase->dnHostMigrate.dpnidOldHost, 0, 1, 0);
				// New Host ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_NEWHOSTID].hProperty,
									sizeof(i_pBase->dnHostMigrate.dpnidNewHost), &i_pBase->dnHostMigrate.dpnidNewHost, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_NAMETABLE_VERSION:
		case DN_MSG_INTERNAL_REQ_NAMETABLE_OP:		// same structure as in NameTableVersion
		case DN_MSG_INTERNAL_RESYNC_VERSION:		// same structure as in NameTableVersion
			{
				// Version field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
									sizeof(i_pBase->dnNametableVersion.dwVersion), &i_pBase->dnNametableVersion.dwVersion, 0, 1, 0);
				
				// RESERVED field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
									sizeof(i_pBase->dnNametableVersion.dwVersionNotUsed), &i_pBase->dnNametableVersion.dwVersionNotUsed, 0, 1, 0);
				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE:
			{
				// No fields
				break;
			}

		case DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC:
			{
				AttachApplicationDescriptionProperties(i_hFrame, i_pBase, &i_pBase->dnUpdateAppDescInfo);

				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER:
			{
				AttachNameTableEntry(i_hFrame, &i_pBase->dnAddPlayer, -1, i_pBase);
				
				break;
			}

		case DN_MSG_INTERNAL_DESTROY_PLAYER:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnDestroyPlayer.dpnidLeaving), &i_pBase->dnDestroyPlayer.dpnidLeaving, 0, 1, 0);
				
				// Version field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
									sizeof(i_pBase->dnDestroyPlayer.dwVersion), &i_pBase->dnDestroyPlayer.dwVersion, 0, 1, 0);
				
				// RESERVED field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
									sizeof(i_pBase->dnDestroyPlayer.dwVersionNotUsed), &i_pBase->dnDestroyPlayer.dwVersionNotUsed, 0, 1, 0);

				// Player Destruction Reason field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERDESTRUCTIONREASON].hProperty,
									sizeof(i_pBase->dnDestroyPlayer.dwDestroyReason), &i_pBase->dnDestroyPlayer.dwDestroyReason, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_REQ_CREATE_GROUP:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnReqProcessCompletionHeader.hCompletionOp), &i_pBase->dnReqProcessCompletionHeader.hCompletionOp, 0, 1, 0);

				// Group flags summary
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPFLAGS_SUMMARY].hProperty,
									sizeof(i_pBase->dnReqCreateGroup.dwGroupFlags), &i_pBase->dnReqCreateGroup.dwGroupFlags, 0, 1, 0);
				// Group field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPFLAGS].hProperty,
									sizeof(i_pBase->dnReqCreateGroup.dwGroupFlags), &i_pBase->dnReqCreateGroup.dwGroupFlags, 0, 2, 0);


				// Info flags summary
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INFOFLAGS_SUMMARY].hProperty,
									sizeof(i_pBase->dnReqCreateGroup.dwInfoFlags), &i_pBase->dnReqCreateGroup.dwInfoFlags, 0, 1, 0);
				// Info flags field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INFOFLAGS].hProperty,
									sizeof(i_pBase->dnReqCreateGroup.dwInfoFlags), &i_pBase->dnReqCreateGroup.dwInfoFlags, 0, 2, 0);


				// Player Name field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_PLAYERNAME, i_pBase,
										   &i_pBase->dnReqCreateGroup.dwNameOffset, &i_pBase->dnReqCreateGroup.dwNameSize, IFLAG_UNICODE, 1);

				// Data field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_DATA, i_pBase,
										   &i_pBase->dnReqCreateGroup.dwDataOffset, &i_pBase->dnReqCreateGroup.dwDataSize, NULL, 1);

				break;
			}

		case DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP:
		case DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP:	// same structure as in AddPlayerToGroup
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnReqProcessCompletionHeader.hCompletionOp), &i_pBase->dnReqProcessCompletionHeader.hCompletionOp, 0, 1, 0);

				// Group ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPID].hProperty,
									sizeof(i_pBase->dnReqAddPlayerToGroup.dpnidGroup), &i_pBase->dnReqAddPlayerToGroup.dpnidGroup, 0, 1, 0);

				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnReqAddPlayerToGroup.dpnidPlayer), &i_pBase->dnReqAddPlayerToGroup.dpnidPlayer, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_REQ_DESTROY_GROUP:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnReqProcessCompletionHeader.hCompletionOp), &i_pBase->dnReqProcessCompletionHeader.hCompletionOp, 0, 1, 0);

				// Group ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPID].hProperty,
									sizeof(i_pBase->dnReqDestroyGroup.dpnidGroup), &i_pBase->dnReqDestroyGroup.dpnidGroup, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_REQ_UPDATE_INFO:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnReqProcessCompletionHeader.hCompletionOp), &i_pBase->dnReqProcessCompletionHeader.hCompletionOp, 0, 1, 0);

				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnReqUpdateInfo.dpnid), &i_pBase->dnReqUpdateInfo.dpnid, 0, 1, 0);


				// Info flags summary
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INFOFLAGS_SUMMARY].hProperty,
									sizeof(i_pBase->dnReqUpdateInfo.dwInfoFlags), &i_pBase->dnReqUpdateInfo.dwInfoFlags, 0, 1, 0);
				// Info flags field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INFOFLAGS].hProperty,
									sizeof(i_pBase->dnReqUpdateInfo.dwInfoFlags), &i_pBase->dnReqUpdateInfo.dwInfoFlags, 0, 2, 0);


				// Player Name field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_PLAYERNAME, i_pBase,
										   &i_pBase->dnReqUpdateInfo.dwNameOffset, &i_pBase->dnReqUpdateInfo.dwNameSize, IFLAG_UNICODE, 1);

				// Data field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_DATA, i_pBase,
										   &i_pBase->dnReqUpdateInfo.dwDataOffset, &i_pBase->dnReqUpdateInfo.dwDataSize, NULL, 1);
				break;
			}

		case DN_MSG_INTERNAL_CREATE_GROUP:
			{
				// Requesting Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_REQUESTINGPLAYERID].hProperty,
									sizeof(i_pBase->dnCreateGroup.dpnidRequesting), &i_pBase->dnCreateGroup.dpnidRequesting, 0, 1, 0);
			
				// Synchronization ID
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnCreateGroup.hCompletionOp), &i_pBase->dnCreateGroup.hCompletionOp, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_DESTROY_GROUP:
			{
				// Group ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPID].hProperty,
									sizeof(i_pBase->dnDestroyGroup.dpnidGroup), &i_pBase->dnDestroyGroup.dpnidGroup, 0, 1, 0);

				// Requesting Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_REQUESTINGPLAYERID].hProperty,
									sizeof(i_pBase->dnDestroyGroup.dpnidRequesting), &i_pBase->dnDestroyGroup.dpnidRequesting, 0, 1, 0);

				// Version field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
									sizeof(i_pBase->dnDestroyGroup.dwVersion), &i_pBase->dnDestroyGroup.dwVersion, 0, 1, 0);
				
				// RESERVED field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
									sizeof(i_pBase->dnDestroyGroup.dwVersionNotUsed), &i_pBase->dnDestroyGroup.dwVersionNotUsed, 0, 1, 0);

				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnDestroyGroup.hCompletionOp), &i_pBase->dnDestroyGroup.hCompletionOp, 0, 1, 0);
				
				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
		case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:	// same structure as AddPlayerToGroup
			{
				// Group ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPID].hProperty,
									sizeof(i_pBase->dnAddPlayerToGroup.dpnidGroup), &i_pBase->dnAddPlayerToGroup.dpnidGroup, 0, 1, 0);

				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnAddPlayerToGroup.dpnidPlayer), &i_pBase->dnAddPlayerToGroup.dpnidPlayer, 0, 1, 0);

				// Version field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
									sizeof(i_pBase->dnAddPlayerToGroup.dwVersion), &i_pBase->dnAddPlayerToGroup.dwVersion, 0, 1, 0);
				
				// RESERVED field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
									sizeof(i_pBase->dnAddPlayerToGroup.dwVersionNotUsed), &i_pBase->dnAddPlayerToGroup.dwVersionNotUsed, 0, 1, 0);

				// Requesting Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_REQUESTINGPLAYERID].hProperty,
									sizeof(i_pBase->dnAddPlayerToGroup.dpnidRequesting), &i_pBase->dnAddPlayerToGroup.dpnidRequesting, 0, 1, 0);

				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnAddPlayerToGroup.hCompletionOp), &i_pBase->dnAddPlayerToGroup.hCompletionOp, 0, 1, 0);
				break;
			}

		case DN_MSG_INTERNAL_UPDATE_INFO:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnUpdateInfo.dpnid), &i_pBase->dnUpdateInfo.dpnid, 0, 1, 0);
				
				// Version field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
									sizeof(i_pBase->dnUpdateInfo.dwVersion), &i_pBase->dnUpdateInfo.dwVersion, 0, 1, 0);
				
				// RESERVED field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
									sizeof(i_pBase->dnUpdateInfo.dwVersionNotUsed), &i_pBase->dnUpdateInfo.dwVersionNotUsed, 0, 1, 0);


				// Flags summary
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INFOFLAGS_SUMMARY].hProperty,
									sizeof(i_pBase->dnUpdateInfo.dwInfoFlags), &i_pBase->dnUpdateInfo.dwInfoFlags, 0, 1, 0);
				// Flags field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INFOFLAGS].hProperty,
									sizeof(i_pBase->dnUpdateInfo.dwInfoFlags), &i_pBase->dnUpdateInfo.dwInfoFlags, 0, 2, 0);


				// Player Name field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_PLAYERNAME, i_pBase,
										   &i_pBase->dnUpdateInfo.dwNameOffset, &i_pBase->dnUpdateInfo.dwNameSize, IFLAG_UNICODE, 1);

				// Data field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_DATA, i_pBase,
										   &i_pBase->dnUpdateInfo.dwDataOffset, &i_pBase->dnUpdateInfo.dwDataSize, NULL, 1);


				// Requesting Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_REQUESTINGPLAYERID].hProperty,
									sizeof(i_pBase->dnUpdateInfo.dpnidRequesting), &i_pBase->dnUpdateInfo.dpnidRequesting, 0, 1, 0);

				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnUpdateInfo.hCompletionOp), &i_pBase->dnUpdateInfo.hCompletionOp, 0, 1, 0);
			
				break;
			}

		case DN_MSG_INTERNAL_BUFFER_IN_USE:
			{
				// No fields
				break;
			}

		case DN_MSG_INTERNAL_REQUEST_FAILED:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnRequestFailed.hCompletionOp), &i_pBase->dnRequestFailed.hCompletionOp, 0, 1, 0);
				
				// Result Code field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESULTCODE].hProperty,
									   sizeof(i_pBase->dnRequestFailed.hResultCode), &i_pBase->dnRequestFailed.hResultCode, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_TERMINATE_SESSION:
			{
				// Data field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_DATA, i_pBase,
										   &i_pBase->dnTerminateSession.dwTerminateDataOffset, &i_pBase->dnTerminateSession.dwTerminateDataSize, NULL, 1);
				
				break;
			}

		case DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnReqProcessCompletion.hCompletionOp), &i_pBase->dnReqProcessCompletion.hCompletionOp, 0, 1, 0);

				// TODO: AttachPropertyInstance(REST OF THE FRAME IS USER DATA)
				break;
			}

		case DN_MSG_INTERNAL_PROCESS_COMPLETION	:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnProcessCompletion.hCompletionOp), &i_pBase->dnProcessCompletion.hCompletionOp, 0, 1, 0);
				
				break;
			}

		case DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnReqProcessCompletionHeader.hCompletionOp), &i_pBase->dnReqProcessCompletionHeader.hCompletionOp, 0, 1, 0);
				
				// Target Peer ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_TARGETPEERID].hProperty,
									sizeof(i_pBase->dnReqIntegrityCheck.dpnidTarget), &i_pBase->dnReqIntegrityCheck.dpnidTarget, 0, 1, 0);
				
				break;
			}


		case DN_MSG_INTERNAL_INTEGRITY_CHECK:
			{
				// Requesting Peer ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_TARGETPEERID].hProperty,
									sizeof(i_pBase->dnIntegrityCheck.dpnidRequesting), &i_pBase->dnIntegrityCheck.dpnidRequesting, 0, 1, 0);
				
				break;
			}

		case DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE:
			{
				// Requesting Peer ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_TARGETPEERID].hProperty,
									sizeof(i_pBase->dnIntegrityCheckResponse.dpnidRequesting), &i_pBase->dnIntegrityCheckResponse.dpnidRequesting, 0, 1, 0);

				break;
			}
		

		default:
			{
				break; // TODO:		DPF(0, "Unknown Session frame!");
			}
		}
		
	} // AttachMessageProperties 

} // Anonymous namespace



// DESCRIPTION: Maps the properties that exist in a piece of recognized data to Sessionecific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbSessionFrame   - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: Must return NULL
//
DPLAYPARSER_API LPBYTE BHAPI SessionAttachProperties( HFRAME      i_hFrame,
													  ULPBYTE      i_upbMacFrame,
													  ULPBYTE      i_upbySessionFrame,
													  DWORD       i_dwMacType,
													  DWORD       i_dwBytesLeft,
													  HPROTOCOL   i_hPrevProtocol,
													  DWORD       i_dwPrevProtOffset,
													  DWORD_PTR   i_dwptrInstData )
{

    //===================//
    // Attach Properties //
    //===================//

    if ( i_dwptrInstData == 0 )
    {
    	AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_UNPARSABLEFRAGMENT].hProperty,
    						i_dwBytesLeft, i_upbySessionFrame, 0, 0, 0);
    	return NULL;
    }
    
    // Summary line
    AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SUMMARY].hProperty,
                           SessionHeaderSize(i_upbySessionFrame), i_upbySessionFrame, 0, 0, 0);

	// Check what Session frame we are dealing with
	DN_INTERNAL_MESSAGE_FULLMSG& rSessionFrame = *reinterpret_cast<DN_INTERNAL_MESSAGE_FULLMSG*>(i_upbySessionFrame);

	// Message type field
	AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_MESSAGETYPE].hProperty,
						   sizeof(rSessionFrame.dwMsgType), &rSessionFrame.dwMsgType, 0, 1, 0);

	__try
	{
		// Attach the properties appropriate to the message type
		AttachMessageProperties(rSessionFrame.dwMsgType, i_hFrame, &rSessionFrame.MsgBody);
	}
	__except ( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )
	{
    	AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INCOMPLETEMESSAGE].hProperty,
    						i_dwBytesLeft, i_upbySessionFrame, 0, 1, 0);
	}

	return NULL;

} // SessionAttachProperties





// DESCRIPTION: Formats the data that is diSessionlayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbSessionFrame	- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbSessionFrame.
//
DPLAYPARSER_API DWORD BHAPI SessionFormatProperties( HFRAME          i_hFrame,
													 ULPBYTE          i_upbMacFrame,
													 ULPBYTE          i_upbySessionFrame,
													 DWORD           i_dwPropertyInsts,
													 LPPROPERTYINST  i_pPropInst )
{

    // Loop through the property instances...
    while( i_dwPropertyInsts-- > 0)
    {
        // ...and call the formatter for each
        reinterpret_cast<FORMAT>(i_pPropInst->lpPropertyInfo->InstanceData)(i_pPropInst);
        ++i_pPropInst;
    }

	// TODO: MAKE SURE THIS SHOULD NOT BE TRUE
    return NMERR_SUCCESS;

} // SessionFormatProperties




// DESCRIPTION: Notifies Network Monitor that DNET protocol parser exists.
//
// ARGUMENTS: NONE
//
// RETURNS: TRUE - success, FALSE - failure
//
bool CreateSessionProtocol( void )
{

	// The entry points to the export functions that Network Monitor uses to operate the parser
	ENTRYPOINTS SessionEntryPoints =
	{
		// SessionParser Entry Points
		SessionRegister,
		SessionDeregister,
		SessionRecognizeFrame,
		SessionAttachProperties,
		SessionFormatProperties
	};

    // The first active instance of this parser needs to register with the kernel
    g_hSessionProtocol = CreateProtocol("DPLAYSESSION", &SessionEntryPoints, ENTRYPOINTS_SIZE);
	
	return (g_hSessionProtocol ? TRUE : FALSE);

} // CreateSessionProtocol



// DESCRIPTION: Removes the DNET protocol parser from the Network Monitor's database of parsers
//
// ARGUMENTS: NONE
//
// RETURNS: NOTHING
//
void DestroySessionProtocol( void )
{

	DestroyProtocol(g_hSessionProtocol);

} // DestroySessionProtocol
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\parsers\transportparser.cpp ===
//=============================================================================
//  FILE: TransportParser.cpp
//
//  Description: DPlay v8 Transport protocol parser
//
//
//  Modification History:
//
//  Michael Milirud      08/Aug/2000    Created
//=============================================================================

// uncomment to enable full parsing of DPlay Transport layer
//#define PARSE_DPLAY_TRANSPORT 

//==================//
// Standard headers //
//==================//
#include <string>


//=====================//
// Proprietary headers //
//=====================//

// Prototypes
#include "TransportParser.hpp"

// SP protocol header
#include "WinSock2.h"  // needed by MessageStructures.h
#include "MessageStructures.h"

// Transport protocol header
#include "Frames.h"

namespace
{
	HPROTOCOL		g_hTransportProtocol;

	typedef __int64 QWORD;


	//================//
	// DCommand field //-------------------------------------------------------------------------------------------------
	//================//
	LABELED_BIT g_arr_DCommandBitLabels[] =
		{ { 0, "INVALID",	          					"Dataframe"                     },		// PACKET_COMMAND_DATA
		  { 1, "Unreliable",         				    "Reliable"                      },		// PACKET_COMMAND_RELIABLE
		  { 2, "Nonsequenced",     					    "Sequenced"                     },		// PACKET_COMMAND_SEQUENTIAL
		  { 3, "ACK can be delayed",				    "ACK now"						},		// PACKET_COMMAND_POLL
		  { 4, "Not the first fragment of the message", "First fragment of the message" },		// PACKET_COMMAND_NEW_MSG
		  { 5, "Not the last fragment of the message",  "Last fragment of the message"  },		// PACKET_COMMAND_END_MSG
		  { 6, "User packet",							"DirectPlay packet"		        },		// PACKET_COMMAND_USER_1
		  { 7, "Data packet",							"Voice packet"			        } };	// PACKET_COMMAND_USER_2

	SET g_LabeledDCommandBitSet = { sizeof(g_arr_DCommandBitLabels) / sizeof(LABELED_BIT), g_arr_DCommandBitLabels };



	//===============//
	// Control field //--------------------------------------------------------------------------------------------------
	//===============//

	LABELED_BIT g_arr_ControlBitLabels[] =
		{ { 0, "Original (not a retry)",					"Retry"					       				   },	// PACKET_CONTROL_RETRY
		  { 1, "Don't correlate",							"Correlate"									   },	// PACKET_CONTROL_CORRELATE
		  { 2, "Not a correlation response",				"Correlation response"					       },	// PACKET_CONTROL_RESPONSE
		  { 3, "Not the last packet in the stream",			"Last packet in the stream"				       },	// PACKET_CONTROL_END_STREAM
		  { 4, "Low DWORD of the RCVD mask is zero",		"Low DWORD of the RCVD mask is nonzero"	       },	// PACKET_CONTROL_SACK_MASK1
		  { 5, "High DWORD of the RCVD mask is zero",		"High DWORD of the RCVD mask is nonzero"	   },	// PACKET_CONTROL_SACK_MASK2
		  { 6, "Low DWORD of the DON'T CARE mask is zero",	"Low DWORD of the DON'T CARE mask is nonzero"  },	// PACKET_CONTROL_SEND_MASK1
		  { 7, "High DWORD of the DON'T CARE mask is zero",	"High DWORD of the DON'T CARE mask is nonzero" } }; // PACKET_CONTROL_SEND_MASK2

	SET g_LabeledControlBitSet = { sizeof(g_arr_ControlBitLabels) / sizeof(LABELED_BIT), g_arr_ControlBitLabels };



	//================//
	// CCommand field //-------------------------------------------------------------------------------------------------
	//================//
	LABELED_BIT g_arr_CCommandBitLabels[] =
		{ { 0, "Command Frame (1/2)", "INVALID"				},	// PACKET_COMMAND_DATA
		  { 1, "Unreliable",		  "Reliable"			},	// PACKET_COMMAND_RELIABLE
		  { 2, "Nonsequenced",     	  "Sequenced"			},	// PACKET_COMMAND_SEQUENTIAL
		  { 3, "ACK can be delayed",  "ACK now" 			},  // PACKET_COMMAND_POLL
		  { 4, "RESERVED",			  "RESERVED"			},	
		  { 5, "RESERVED",			  "RESERVED"			},  	
		  { 6, "RESERVED",			  "RESERVED"			},  	
		  { 7, "INVALID",			  "Command Frame (2/2)"	} };

	SET g_LabeledCCommandBitSet = { sizeof(g_arr_CCommandBitLabels) / sizeof(LABELED_BIT), g_arr_CCommandBitLabels };



	//=======================//
	// Extended Opcode field //------------------------------------------------------------------------------------------
	//=======================//
	LABELED_BYTE g_arr_ExOpcodeByteLabels[] = { 
										        { FRAME_EXOPCODE_CONNECT,	   "Establish a connection"				  },
										        { FRAME_EXOPCODE_CONNECTED,	   "Connection request has been accepted" },
										        { FRAME_EXOPCODE_DISCONNECTED, "Connection has been disconnected"     },
										        { FRAME_EXOPCODE_SACK,		   "Selective Acknowledgement"			  } };

	SET g_LabeledExOpcodeByteSet = { sizeof(g_arr_ExOpcodeByteLabels) / sizeof(LABELED_BYTE), g_arr_ExOpcodeByteLabels };


	
	//==================//
	// SACK flags field //-----------------------------------------------------------------------------------------------
	//==================//
	LABELED_BIT g_arr_SACKFlagsBitLabels[] =
		{ { 0, "Retry and/or Timestamp fields are invalid",		   "Retry and Timestamp fields are valid"	      },   // SACK_FLAGS_RESPONSE
		  { 1, "Low DWORD of the RCVD mask is not present",	   	   "Low DWORD of the RCVD mask is present"        },   // SACK_FLAGS_SACK_MASK1
		  { 2, "High DWORD of the RCVD mask is not present",	   "High DWORD of the RCVD mask is present"       },   // SACK_FLAGS_SACK_MASK2
		  { 3, "Low DWORD of the DON'T CARE mask is not present",  "Low DWORD of the DON'T CARE mask is present"  },   // SACK_FLAGS_SEND_MASK1
		  { 4, "High DWORD of the DON'T CARE mask is not present", "High DWORD of the DON'T CARE mask is present" } }; // SACK_FLAGS_SEND_MASK2

	SET g_LabeledSACKFlagsBitSet = { sizeof(g_arr_SACKFlagsBitLabels) / sizeof(LABELED_BIT), g_arr_SACKFlagsBitLabels };


	
	//==================//
	// Helper functions //===========================================================================
	//==================//

	enum BitmaskPart { LOW = 0, HIGH, ENTIRE };
	enum BitmaskType { RCVD, DONTCARE };
	
	std::string InterpretRCVDBitmask( BitmaskPart i_Part, BYTE i_byBase, UNALIGNED DWORD* i_pdwBitmask )
	{
		std::string strSummary = "Received Seq=";

		// [i_bBase+1 .. i_bBase+1+LENGTH]
		// RCVD bitmask doesn't include the base value, since receiver can't claim it didn't receive the next dataframe to be received (NRcv);
		if ( i_Part == HIGH )
		{
			// NOTE: +1 is needed to cross from MSB of the first DWORD TO LSB of the second
			i_byBase += 8*sizeof(DWORD)+1; // shift to LSB of the second DWORD
		}
		else
		{
			++i_byBase;
		}

		QWORD qwBitMask = *i_pdwBitmask;
		if ( i_Part == ENTIRE )
		{
			qwBitMask |= *(i_pdwBitmask+1);
		}

		strSummary += "{";

		
		bool bFirst = true;
		// Processing from LSB to MSB
		for ( ; qwBitMask; qwBitMask >>= 1, ++i_byBase )
		{
			if ( qwBitMask & 1 )  
			{
				if ( bFirst )
				{
					bFirst = false;
				}
				else
				{
					strSummary += ", ";
				}
				
				char arr_cBuffer[10];
				strSummary += _itoa(i_byBase, arr_cBuffer, 16);
			}
		}
		
		strSummary += "}";
		
		return strSummary;
		
	}// InterpretRCVDBitmask


	std::string InterpretDONTCAREBitmask( BitmaskPart i_Part, BYTE i_byBase, UNALIGNED DWORD* i_pdwBitmask )
	{
		std::string strSummary = "Cancelling Seq=";

		// [i_bBase-1-LENGTH .. i_bBase-1]
		// DON'T CARE doesn't include the base value, since transmitter can't resend/refuse resending a dataframe which is about to be sent next (NSeq).
		if ( i_Part == LOW )
		{
			i_byBase -= 8*sizeof(DWORD); // shift to MSB of the first DWORD
		}
		else
		{
			i_byBase -= 8*sizeof(QWORD); // shift to MSB of the second DWORD
		}

		QWORD qwBitMask = *i_pdwBitmask;
		if ( i_Part == ENTIRE )
		{
			qwBitMask |= *(i_pdwBitmask+1);
		}
		else
		{
			// QWORD.High = QWORD.Low; QWORD.Low = 0;
			qwBitMask <<= 8*sizeof(DWORD);
		}

		strSummary += "{";
		
		bool bFirst = true;
		// Processing from MSB to LSB
		for ( ; qwBitMask; ++i_byBase, qwBitMask <<= 1 )
		{
			if ( qwBitMask & 0x8000000000000000 )  
			{
				if ( bFirst )
				{
					bFirst = false;
				}
				else
				{
					strSummary += ", ";
				}
				
				char arr_cBuffer[10];
				strSummary += _itoa(i_byBase, arr_cBuffer, 16);
			}
		}
		
		strSummary += "}";
		
		return strSummary;
		
	}// InterpretDONTCAREBitmask



	////////////////////////////////
	// Custom Property Formatters //======================================================================================
	////////////////////////////////

	// DESCRIPTION: Custom description formatter for the Transport packet summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_TransportSummary( LPPROPERTYINST io_pProperyInstance )
	{
		std::string strSummary;
		char arr_cBuffer[10];

		DFBIG&	rDBigFrame	= *reinterpret_cast<DFBIG*>(io_pProperyInstance->lpPropertyInstEx->lpData);

		if ( (rDBigFrame.bCommand & PACKET_COMMAND_DATA)  ==  PACKET_COMMAND_DATA )	// DFrame
		{
			if ( *reinterpret_cast<BOOL*>(io_pProperyInstance->lpPropertyInstEx->Dword) )
			{
				strSummary  = "KeepAlive";
			}
			else if ( (rDBigFrame.bCommand & PACKET_COMMAND_USER_2) == PACKET_COMMAND_USER_2 )
			{
				strSummary  = "Voice";
			}
			else
			{
				strSummary  = "User data";
			}


			#if defined(PARSE_DPLAY_TRANSPORT)
			
				strSummary += " : Seq=";
				strSummary += _itoa(rDBigFrame.bSeq, arr_cBuffer, 16);
				strSummary += ", NRcv=";
				strSummary += _itoa(rDBigFrame.bNRcv, arr_cBuffer, 16);
				
			#endif  // PARSE_DPLAY_TRANSPORT

			
			if ( (rDBigFrame.bCommand & PACKET_COMMAND_NEW_MSG) == PACKET_COMMAND_NEW_MSG )
			{
				if ( (rDBigFrame.bCommand & PACKET_COMMAND_END_MSG) != PACKET_COMMAND_END_MSG )
				{
					strSummary += ", First fragment";
				}
			}
			else if ( (rDBigFrame.bCommand & PACKET_COMMAND_END_MSG) == PACKET_COMMAND_END_MSG )
			{
				strSummary += ", Last fragment";
			}
		
			if ( (rDBigFrame.bControl & PACKET_CONTROL_END_STREAM)  ==  PACKET_CONTROL_END_STREAM )
			{
				strSummary += ", End of Stream";
			}

			if ( (rDBigFrame.bCommand & PACKET_COMMAND_POLL) == PACKET_COMMAND_POLL )
			{
				strSummary += ", ACK now";
			}

			if ( (rDBigFrame.bControl & PACKET_CONTROL_RETRY) == PACKET_CONTROL_RETRY )
			{
				strSummary += ", Retry";
			}	

			if ( (rDBigFrame.bControl & PACKET_CONTROL_CORRELATE) == PACKET_CONTROL_CORRELATE )
			{
				strSummary += ", Correlate";
			}

			if ( (rDBigFrame.bControl & PACKET_CONTROL_RESPONSE) == PACKET_CONTROL_RESPONSE )
			{
				strSummary += ", Correlatation response";
			}

			int nBitMaskIndex = 0;
			
			if ( (rDBigFrame.bControl & PACKET_CONTROL_SACK_MASK1)  ==  PACKET_CONTROL_SACK_MASK1 )
			{
				strSummary += ", ";
				if ( (rDBigFrame.bControl & PACKET_CONTROL_SACK_MASK2)  ==  PACKET_CONTROL_SACK_MASK2 )	 // Entire QWORD
 				{
 					strSummary += InterpretRCVDBitmask(ENTIRE, rDBigFrame.bNRcv, &rDBigFrame.rgMask[nBitMaskIndex]);
					nBitMaskIndex += 2;
				}
 				else // Low DWORD only
 				{
	 				strSummary += InterpretRCVDBitmask(LOW, rDBigFrame.bNRcv, &rDBigFrame.rgMask[nBitMaskIndex]);
					++nBitMaskIndex;
 				}
			}
			else if ( (rDBigFrame.bControl & PACKET_CONTROL_SACK_MASK2)  ==  PACKET_CONTROL_SACK_MASK2 )	 // High DWORD only
 			{
 				strSummary += ", " + InterpretRCVDBitmask(HIGH, rDBigFrame.bNRcv, &rDBigFrame.rgMask[nBitMaskIndex]);
				++nBitMaskIndex; 					
			}
				
			if ( (rDBigFrame.bControl & PACKET_CONTROL_SEND_MASK1)  ==  PACKET_CONTROL_SEND_MASK1 )
			{
				strSummary += ", ";
				if ( (rDBigFrame.bControl & PACKET_CONTROL_SEND_MASK2)  ==  PACKET_CONTROL_SEND_MASK2 ) // Entire QWORD
 				{
 					strSummary += InterpretDONTCAREBitmask(ENTIRE, rDBigFrame.bSeq, &rDBigFrame.rgMask[nBitMaskIndex]);
				}
 				else // Low DWORD only
 				{
	 				strSummary += InterpretDONTCAREBitmask(LOW, rDBigFrame.bSeq, &rDBigFrame.rgMask[nBitMaskIndex]);
 				}
			}
			else if ( (rDBigFrame.bControl & PACKET_CONTROL_SEND_MASK2)  ==  PACKET_CONTROL_SEND_MASK2 )	 // High DWORD only
 			{
 				strSummary += ", " + InterpretDONTCAREBitmask(HIGH, rDBigFrame.bSeq, &rDBigFrame.rgMask[nBitMaskIndex]);
			}

		}
		else
		{
			CFRAME& rCFrame	= *reinterpret_cast<CFRAME*>(io_pProperyInstance->lpPropertyInstEx->lpData);

			if ( rCFrame.bExtOpcode == FRAME_EXOPCODE_SACK )	// SACK CFrame
			{
				SFBIG8* pSBigFrame = reinterpret_cast<SFBIG8*>(&rCFrame);

				enum { SACK_FLAGS_ALL_MASKS = SACK_FLAGS_SACK_MASK1 | SACK_FLAGS_SACK_MASK2 |
											  SACK_FLAGS_SEND_MASK1 | SACK_FLAGS_SEND_MASK2 };
				
				if ( pSBigFrame->bFlags & SACK_FLAGS_ALL_MASKS ) // at least one bitmask field is present
				{
					strSummary = "Selective Acknowledgement";
				}
				else // if not a single bitmask is present
				{
					strSummary = "Acknowledgement";
				}


				#if defined(PARSE_DPLAY_TRANSPORT)

					strSummary += " : NSeq=";
					strSummary += _itoa(pSBigFrame->bNSeq, arr_cBuffer, 16);
					strSummary += ", NRcv=";
					strSummary += _itoa(pSBigFrame->bNRcv, arr_cBuffer, 16);

				#endif // PARSE_DPLAY_TRANSPORT
				

				if ( (pSBigFrame->bCommand & PACKET_COMMAND_POLL) == PACKET_COMMAND_POLL )
				{
					strSummary += ", ACK now";
				}

				if ( ((pSBigFrame->bFlags & SACK_FLAGS_RESPONSE) == SACK_FLAGS_RESPONSE)  &&  pSBigFrame->bRetry )
				{
					strSummary += ", Retry";
				}


				int nBitMaskIndex = 0;
				UNALIGNED ULONG* pulMasks = 0;

				// This is a Protocol version 1.0 frame
				pulMasks = pSBigFrame->rgMask;

				if ( (pSBigFrame->bFlags & SACK_FLAGS_SACK_MASK1)  ==  SACK_FLAGS_SACK_MASK1 )
				{
					strSummary += ", ";
 					if ( (pSBigFrame->bFlags & SACK_FLAGS_SACK_MASK2)  ==  SACK_FLAGS_SACK_MASK2 )	// Entire QWORD
 					{
 						strSummary += InterpretRCVDBitmask(ENTIRE, pSBigFrame->bNRcv, &pulMasks[nBitMaskIndex]);
						nBitMaskIndex += 2;
					}
 					else // Low DWORD only
 					{
	 					strSummary += InterpretRCVDBitmask(LOW, pSBigFrame->bNRcv, &pulMasks[nBitMaskIndex]);
						++nBitMaskIndex;
 					}
				}
				else if ( (pSBigFrame->bFlags & SACK_FLAGS_SACK_MASK2)  ==  SACK_FLAGS_SACK_MASK2 )	// High DWORD only
 				{
 					strSummary += ", " + InterpretRCVDBitmask(HIGH, pSBigFrame->bNRcv, &pulMasks[nBitMaskIndex]);
					++nBitMaskIndex; 					
				}

				if ( (pSBigFrame->bFlags & SACK_FLAGS_SEND_MASK1)  ==  SACK_FLAGS_SEND_MASK1 )
				{
					strSummary += ", ";
 					if ( (pSBigFrame->bFlags & SACK_FLAGS_SEND_MASK2)  ==  SACK_FLAGS_SEND_MASK2 ) // Entire QWORD
 					{
 						strSummary += InterpretDONTCAREBitmask(ENTIRE, pSBigFrame->bNSeq, &pulMasks[nBitMaskIndex]);
					}
 					else // Low DWORD only
 					{
	 					strSummary += InterpretDONTCAREBitmask(LOW, pSBigFrame->bNSeq, &pulMasks[nBitMaskIndex]);
 					}
				}
				else if ( (pSBigFrame->bFlags & SACK_FLAGS_SEND_MASK2)  ==  SACK_FLAGS_SEND_MASK2 ) // High DWORD only
 				{
					strSummary += ", " + InterpretDONTCAREBitmask(HIGH, pSBigFrame->bNSeq, &pulMasks[nBitMaskIndex]);
				}
				
			}
			else	// Connection Control CFrame
			{
				strSummary = "Connection Control - ";

				for ( int n = 0; n < sizeof(g_arr_ExOpcodeByteLabels) / sizeof(LABELED_BYTE); ++ n )
				{
					if ( g_arr_ExOpcodeByteLabels[n].Value == rCFrame.bExtOpcode )
					{
						strSummary += g_arr_ExOpcodeByteLabels[n].Label;
						break;
					}
				}

				if ( (rCFrame.bCommand & PACKET_COMMAND_POLL) == PACKET_COMMAND_POLL )
				{
					strSummary += " : ACK now";
				}
			}
		}

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());
	
	} // FormatPropertyInstance_TransportSummary



	// DESCRIPTION: Custom description formatter for the dataframe's Command field summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_DCommandSummary( LPPROPERTYINST io_pProperyInstance )
	{
		BYTE bCommand = *reinterpret_cast<BYTE*>(io_pProperyInstance->lpData);

		std::string strSummary = "Command: ";

		strSummary += ( (bCommand & PACKET_COMMAND_RELIABLE)   == PACKET_COMMAND_RELIABLE   ) ? "Reliable"					   : "Unreliable";
		strSummary += ( (bCommand & PACKET_COMMAND_SEQUENTIAL) == PACKET_COMMAND_SEQUENTIAL ) ? ", Sequenced"				   : ", Nonsequenced";
		strSummary += ( (bCommand & PACKET_COMMAND_POLL)	   == PACKET_COMMAND_POLL		) ? ", Must be ACK'ed immediately" : ", ACK can be delayed";

		if ( (bCommand & PACKET_COMMAND_NEW_MSG) == PACKET_COMMAND_NEW_MSG )
		{
			if ( (bCommand & PACKET_COMMAND_END_MSG) != PACKET_COMMAND_END_MSG )
			{
				strSummary += ", First fragment of the message";
			}
		}
		else if ( (bCommand & PACKET_COMMAND_END_MSG) == PACKET_COMMAND_END_MSG )
		{
			strSummary += ", Last fragment of the message";
		}

		strSummary += ( (bCommand & PACKET_COMMAND_USER_1) == PACKET_COMMAND_USER_1 ) ? ", DirectPlay packet" : ", User packet";
		strSummary += ( (bCommand & PACKET_COMMAND_USER_2) == PACKET_COMMAND_USER_2 ) ? ", Voice packet" : ", Data packet";

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_DCommandSummary



	// DESCRIPTION: Custom description formatter for the Command Frame's Command field summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_CCommandSummary( LPPROPERTYINST io_pProperyInstance )
	{

		BYTE bCommand = *reinterpret_cast<BYTE*>(io_pProperyInstance->lpData);

		std::string strSummary = "Command: ";

		strSummary += ( (bCommand & PACKET_COMMAND_RELIABLE)   == PACKET_COMMAND_RELIABLE   ) ? "Reliable"					   : "Unreliable";
		strSummary += ( (bCommand & PACKET_COMMAND_SEQUENTIAL) == PACKET_COMMAND_SEQUENTIAL ) ? ", Sequenced"				   : ", Nonsequenced";
		strSummary += ( (bCommand & PACKET_COMMAND_POLL)	   == PACKET_COMMAND_POLL		) ? ", Must be ACK'ed immediately" : ", ACK can be delayed";
				
		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_CCommandSummary


	
	// DESCRIPTION: Custom description formatter for the dataframe's Control field summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_ControlSummary( LPPROPERTYINST io_pProperyInstance )
	{

		BYTE bControl = *reinterpret_cast<BYTE*>(io_pProperyInstance->lpData);

		std::string strSummary = "Control: ";
		

		if ( (bControl & PACKET_CONTROL_RETRY) == PACKET_CONTROL_RETRY )
		{
			strSummary += "Retry";
		}
		else
		{
			strSummary += "Original";
		}


		if ( (bControl & PACKET_CONTROL_CORRELATE) == PACKET_CONTROL_CORRELATE )
		{
			strSummary += ", Correlate";
		}
		

		if ( (bControl & PACKET_CONTROL_RESPONSE) == PACKET_CONTROL_RESPONSE )
		{
			strSummary += ", Correlatation response";
		}

		
		if ( (bControl & PACKET_CONTROL_END_STREAM) == PACKET_CONTROL_END_STREAM )
		{
			strSummary += ", Last packet in the stream";
		}


		if ( ( (bControl & PACKET_CONTROL_SACK_MASK1) == PACKET_CONTROL_SACK_MASK1 ) ||
			 ( (bControl & PACKET_CONTROL_SACK_MASK2) == PACKET_CONTROL_SACK_MASK2 ) )
		{
			strSummary += "RCVD bitmask is nonzero";
		}


		if ( ( (bControl & PACKET_CONTROL_SEND_MASK1) == PACKET_CONTROL_SEND_MASK1 ) ||
			 ( (bControl & PACKET_CONTROL_SEND_MASK2) == PACKET_CONTROL_SEND_MASK2 ) )
		{
			strSummary += ", DON'T CARE bitmask is nonzero";
		}
		
		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_ControlSummary



	// DESCRIPTION: Custom description formatter for the Command Frame's SACK Flags field summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_SACKFlagsSummary( LPPROPERTYINST io_pProperyInstance )
	{

		BYTE bSACKFlags = *reinterpret_cast<BYTE*>(io_pProperyInstance->lpData);

		std::string strSummary = "SACK Flags: ";
		
		strSummary += ( (bSACKFlags & SACK_FLAGS_RESPONSE) == SACK_FLAGS_RESPONSE ) ? "Retry and Timestamp fields are valid" :
																					  "Retry and/or Timestamp fields are invalid";

		if ( ( (bSACKFlags & SACK_FLAGS_SACK_MASK1) == SACK_FLAGS_SACK_MASK1 ) ||
			 ( (bSACKFlags & SACK_FLAGS_SACK_MASK2) == SACK_FLAGS_SACK_MASK2 ) )
		{
			strSummary += ", RCVD bitmask is nonzero";
		}
		else
		{
			strSummary += ", no RCVD bitmask";
		}

		if ( ( (bSACKFlags & SACK_FLAGS_SEND_MASK1) == SACK_FLAGS_SEND_MASK1 ) ||
			 ( (bSACKFlags & SACK_FLAGS_SEND_MASK2) == SACK_FLAGS_SEND_MASK2 ) )
		{
			strSummary += ", DON'T CARE bitmask is nonzero";
		}
		else
		{
			strSummary += ", no DON'T CARE bitmask";
		}


		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_SACKFlagsSummary


	struct SSACKBitmaskContext
	{
		BYTE         byBase;
		BitmaskPart  Part;
		BitmaskType  Type;
		BYTE		byBit;
	};

	// DESCRIPTION: Custom description formatter for the Selective Acknowledgement Frame's RCVD bitmask's low/high DWORD summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_SACKBitmaskDWORDSummary( LPPROPERTYINST io_pProperyInstance )
	{
	
		DWORD dwBitmask = *reinterpret_cast<DWORD*>(io_pProperyInstance->lpPropertyInstEx->lpData);

		SSACKBitmaskContext& rBitmaskContext = *reinterpret_cast<SSACKBitmaskContext*>(io_pProperyInstance->lpPropertyInstEx->Byte);

		std::string strSummary  = ( rBitmaskContext.Part == LOW ? "Low" : "High" );
		strSummary += " DWORD of ";
		strSummary += ( rBitmaskContext.Type == RCVD ? "RCVD" : "DON'T CARE" );
		strSummary += " bitmask: ";

		strSummary += ( ( rBitmaskContext.Type == RCVD ) ? InterpretRCVDBitmask(rBitmaskContext.Part, rBitmaskContext.byBase, &dwBitmask) :
 										    			   InterpretDONTCAREBitmask(rBitmaskContext.Part, rBitmaskContext.byBase, &dwBitmask) );

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_SACKBitmaskDWORDSummary


	// DESCRIPTION: Custom description formatter for the bitmask's low/high DWORD summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_DWORDBitmaskEntry( LPPROPERTYINST io_pProperyInstance )
	{
	
		DWORD dwBitmask = *reinterpret_cast<DWORD*>(io_pProperyInstance->lpPropertyInstEx->lpData);

		SSACKBitmaskContext& rBitmaskContext = *reinterpret_cast<SSACKBitmaskContext*>(io_pProperyInstance->lpPropertyInstEx->Byte);

		BYTE byBase = rBitmaskContext.byBase;
		BYTE byBit = rBitmaskContext.byBit;
		switch ( rBitmaskContext.Type )
		{
		case RCVD:
			{
				// [i_bBase+1 .. i_bBase+1+LENGTH]
				// RCVD bitmask doesn't include the base value, since receiver can't claim it didn't receive the next dataframe to be received (NRcv);
				if ( rBitmaskContext.Part == HIGH )
				{
					// NOTE: +1 is needed to cross from MSB of the first DWORD TO LSB of the second
					byBase += 8*sizeof(DWORD)+1; // shift to LSB of the second DWORD
				}
				else
				{
					++byBase;
				}

				byBase += byBit;
				
				break;
			}

		case DONTCARE:
			{
				// [i_bBase-1-LENGTH .. i_bBase-1]
				// DON'T CARE doesn't include the base value, since transmitter can't resend/refuse resending a dataframe which is about to be sent next (NSeq).
				if ( rBitmaskContext.Part == HIGH )
				{
					byBase -= 8*sizeof(DWORD); // shift to MSB of the first DWORD
				}
				else
				{
					--byBase;
				}

				byBase -= byBit;
				
				break;
			}

		default:
			// TODO: ASSERT HERE (SHOULD NEVER HAPPEN)
			break;
		}


		static DWORD arr_dwFlags[] = { 0x00000001, 0x00000002, 0x00000004, 0x00000008,
									  0x00000010, 0x00000020, 0x00000040, 0x00000080,
									  0x00000100, 0x00000200, 0x00000400, 0x00000800,
									  0x00001000, 0x00002000, 0x00004000, 0x00008000,
									  0x00010000, 0x00020000, 0x00040000, 0x00080000,
									  0x00100000, 0x00200000, 0x00400000, 0x00800000,
									  0x01000000, 0x02000000, 0x04000000, 0x08000000,
									  0x10000000, 0x20000000, 0x40000000, 0x80000000 };
		char arr_cBuffer[100];
		char arr_cTemplate[] = "................................ = %s %d (%d%c%d)";

		arr_cTemplate[31-byBit] = ( (dwBitmask & arr_dwFlags[byBit]) ? '1' : '0' );
			
		switch ( rBitmaskContext.Type )
		{
		case RCVD:
			{
				sprintf(arr_cBuffer, arr_cTemplate, ((dwBitmask & arr_dwFlags[byBit]) ? "Received" : "Did not receive"), byBase, rBitmaskContext.byBase, '+', byBit+1);
				++byBase;
				break;
			}

		case DONTCARE:
			{
				sprintf(arr_cBuffer, arr_cTemplate, ((dwBitmask & arr_dwFlags[byBit]) ? "Cancelling" : "Successfully transmitted"), byBase, rBitmaskContext.byBase, '-', byBit+1);
				--byBase;
				break;
			}
		}

		strcpy(io_pProperyInstance->szPropertyText, arr_cBuffer);

	} // FormatPropertyInstance_DWORDBitmaskEntry

	
	//==================//
	// Properties table //-----------------------------------------------------------------------------------------------
	//==================//
	
	PROPERTYINFO g_arr_TransportProperties[] = 
	{

		// Transport packet summary property (TRANSPORT_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "DPlay Direct Network packet",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_TransportSummary			// generic formatter
		},


		// DCommand field summary property (TRANSPORT_DCOMMAND_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Command field summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_DCommandSummary		// generic formatter
		},

		// DCommand field property (TRANSPORT_DCOMMAND)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Command field",							// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_FLAGS,							// data type qualifier.
		    &g_LabeledDCommandBitSet,					// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Control field summary property (TRANSPORT_CONTROL_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Control field summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_ControlSummary		// generic formatter
		},										

		// Control field property (TRANSPORT_CONTROL)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"Control",									// label
			"Control field",							// status-bar comment
			PROP_TYPE_BYTE,								// data type
			PROP_QUAL_FLAGS,							// data type qualifier.
			&g_LabeledControlBitSet,					// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance						// generic formatter
		},

		// Packet sequence number property (TRANSPORT_SEQNUM)
		//
		// INFO: This number is incremented for each _new_ packet sent. If an endpoint retransmits
		//	     a packet, it uses the same sequence number it did the first time it sent it (base value for the DON'T CARE bitmask).
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Seq: Highest dataframe # sent (base value for the DON'T CARE bitmask)",	// label
		    "Highest dataframe # sent field",			// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Next receive number property (TRANSPORT_NEXTRECVNUM)
		//
		// INFO: Acknowledges every packet with a sequence number up to but not including this number (base value for the RCVD bitmask)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
			"NRcv: Next dataframe # to be received (base value for the RCVD bitmask)",	// label
		    "Next dataframe # to be received field",	// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

	    // CCommand field property (TRANSPORT_CCOMMAND_SUMMARY)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"Command field summary",					// status-bar comment
			PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled bit set 
			512,										// description's maximum length
			FormatPropertyInstance_CCommandSummary		// generic formatter
		},

		// CCommand field property (TRANSPORT_CCOMMAND)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"Command field",							// status-bar comment
			PROP_TYPE_BYTE,								// data type
			PROP_QUAL_FLAGS,							// data type qualifier.
			&g_LabeledCCommandBitSet,					// labeled bit set 
			512,										// description's maximum length
			FormatPropertyInstance						// generic formatter
		},												

	    // Extended opcode field property (TRANSPORT_EXOPCODE)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"Extended opcode",							// label
			"Extended opcode field",					// status-bar comment
			PROP_TYPE_BYTE,								// data type
			PROP_QUAL_LABELED_SET,						// data type qualifier.
			&g_LabeledExOpcodeByteSet,					// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance						// generic formatter
		},

		// Message ID field property (TRANSPORT_MSGID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Message ID",								// label
		    "Message ID field",							// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Response ID field propery (TRANSPORT_RSPID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Response ID",								// label
		    "Response ID field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Protocol version field property (TRANSPORT_VERSION)
		//
		// INFO: Makes sure both endpoints use the same version of the protocol.
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Version",									// label
		    "Version field",							// status-bar comment
		    PROP_TYPE_DWORD,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Session ID field property (TRANSPORT_SESSIONID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Session ID",								// label
		    "Session ID field",							// status-bar comment
		    PROP_TYPE_DWORD,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Time stamp field property (TRANSPORT_TIMESTAMP)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Time stamp",								// label
		    "Time stamp field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},


	    // SACK flags field property (TRANSPORT_SACKFIELDS_SUMMARY)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"SACK flags summary",						// status-bar comment
			PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance_SACKFlagsSummary		// generic formatter
		},

		// SACK flags field property (TRANSPORT_SACKFIELDS)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"SACK flags field",							// status-bar comment
			PROP_TYPE_BYTE,								// data type
			PROP_QUAL_FLAGS,							// data type qualifier.
			&g_LabeledSACKFlagsBitSet,					// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance						// generic formatter
		},

		// Retry field property (TRANSPORT_RETRY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Retry",									// label
		    "Retry field",								// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Next sequence number field property (TRANSPORT_NEXTSEQNUM)
		//
		// INFO: Sequence number of the next DFrame to be sent (base value for the DON'T CARE bitmask)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "NSeq: Next dataframe # to be sent (base value for the DON'T CARE bitmask)",	// label
		    "Next dataframe # to be sent field",		// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

	    // Low DWORD of the Selective-ACK RCVD Mask summary (TRANSPORT_RCVDMASK1_SUMMARY)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"Low DWORD of the RCVD mask summary",		// status-bar comment
			PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance_SACKBitmaskDWORDSummary	// generic formatter
		},

		// Low DWORD of the Selective-ACK RCVD Mask property (TRANSPORT_RCVDMASK1)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Low DWORD of the RCVD mask",				// label
		    "Low DWORD of the RCVD mask field",			// status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    3072,										// description's maximum length
		    FormatPropertyInstance_DWORDBitmaskEntry		// generic formatter
		},											

	    // High DWORD of the Selective-ACK RCVD Mask summary (TRANSPORT_RCVDMASK2_SUMMARY)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"High DWORD of the RCVD mask summary",		// status-bar comment
			PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance_SACKBitmaskDWORDSummary	// generic formatter
		},

		// High DWORD of Selective-ACK RCVD Mask property (TRANSPORT_RCVDMASK2)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "High DWORD of the RCVD mask",				// label
		    "High DWORD of the RCVD mask field",		// status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    3072,										// description's maximum length
		    FormatPropertyInstance_DWORDBitmaskEntry		// generic formatter
		},

	    // Low DWORD of the Selective-ACK DON'T CARE Mask summary (TRANSPORT_DONTCAREMASK1_SUMMARY)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"Low DWORD of the DON'T CARE mask summary",		// status-bar comment
			PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance_SACKBitmaskDWORDSummary	// generic formatter
		},

		// Low DWORD of the Selective-ACK DON'T CARE Mask property (TRANSPORT_DONTCAREMASK1)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Low DWORD of the DON'T CARE mask",			// label
		    "Low DWORD of the DON'T CARE mask field",	// status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    3072,										// description's maximum length
		    FormatPropertyInstance_DWORDBitmaskEntry		// generic formatter
		},

	    // High DWORD of the Selective-ACK DON'T CARE Mask summary (TRANSPORT_DONTCAREMASK2_SUMMARY)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"High DWORD of the DON'T CARE mask summary",	// status-bar comment
			PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance_SACKBitmaskDWORDSummary	// generic formatter
		},

		// High DWORD of the Selective-ACK DON'T CARE Mask property (TRANSPORT_DONTCAREMASK2)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "High DWORD of the DON'T CARE mask",		// label
		    "High DWORD of the DON'T CARE mask field",   // status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    3072,										// description's maximum length
		    FormatPropertyInstance_DWORDBitmaskEntry		// generic formatter
		},

		// Compression Type property (VOICE_USERDATA)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "User Data",								// label
		    "User Data",								// status-bar comment
		    PROP_TYPE_RAW_DATA,							// data type (GUID)
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		}

	};

	enum
	{
		nNUM_OF_TRANSPORT_PROPS = sizeof(g_arr_TransportProperties) / sizeof(PROPERTYINFO)
	};


	// Properties' indices
	enum
	{
		TRANSPORT_SUMMARY = 0,
		TRANSPORT_DCOMMAND_SUMMARY,
		TRANSPORT_DCOMMAND,
		TRANSPORT_CONTROL_SUMMARY,
		TRANSPORT_CONTROL,
		TRANSPORT_SEQNUM,
		TRANSPORT_NEXTRECVNUM,
		TRANSPORT_CCOMMAND_SUMMARY,
		TRANSPORT_CCOMMAND,
		TRANSPORT_EXOPCODE,
		TRANSPORT_MSGID,
		TRANSPORT_RSPID,
		TRANSPORT_VERSION,
		TRANSPORT_SESSIONID,
		TRANSPORT_TIMESTAMP,
		TRANSPORT_SACKFIELDS_SUMMARY,
		TRANSPORT_SACKFIELDS,
		TRANSPORT_RETRY,
		TRANSPORT_NEXTSEQNUM,
		TRANSPORT_RCVDMASK1_SUMMARY,
		TRANSPORT_RCVDMASK1,
		TRANSPORT_RCVDMASK2_SUMMARY,
		TRANSPORT_RCVDMASK2,
		TRANSPORT_DONTCAREMASK1_SUMMARY,
		TRANSPORT_DONTCAREMASK1,
		TRANSPORT_DONTCAREMASK2_SUMMARY,
		TRANSPORT_DONTCAREMASK2,
		TRANSPORT_USERDATA
	};

} // anonymous namespace




// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hTransportProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI TransportRegister( HPROTOCOL i_hTransportProtocol ) 
{

	CreatePropertyDatabase(i_hTransportProtocol, nNUM_OF_TRANSPORT_PROPS);

	// Add the properties to the database
	for( int nProp=0; nProp < nNUM_OF_TRANSPORT_PROPS; ++nProp )
	{
	   AddProperty(i_hTransportProtocol, &g_arr_TransportProperties[nProp]);
	}

} // TransportRegister



// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hTransportProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI TransportDeregister( HPROTOCOL i_hProtocol )
{

	DestroyPropertyDatabase(i_hProtocol);

} // TransportDeregister




namespace
{

	// DESCRIPTION: Parses the Transport frame to find its size (in bytes) NOT including the user data
	//
	// ARGUMENTS: i_pbTransportFrame - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
	//							  in the middle of a frame because a previous parser has claimed data before this parser.
	//
	// RETURNS: Size of the specified Transport frame (in bytes)
	//
	int TransportHeaderSize( BYTE* i_pbTransportFrame )
	{

		int arr_nNumOfBits[] = { /*00 = 0x0000*/ 0, /*01 = 0x0001*/ 1, /*02 = 0x0010*/ 1, /*03 = 0x0011*/ 2,
								 /*04 = 0x0100*/ 1, /*05 = 0x0101*/ 2, /*06 = 0x0110*/ 2, /*07 = 0x0111*/ 3,
								 /*08 = 0x1000*/ 1, /*09 = 0x1001*/ 2, /*10 = 0x1010*/ 2, /*11 = 0x1011*/ 3,
								 /*12 = 0x1100*/ 2, /*13 = 0x1101*/ 3, /*14 = 0x1110*/ 3, /*15 = 0x1111*/ 4 };
		
		DFRAME&	rDFrame	= *reinterpret_cast<DFRAME*>(i_pbTransportFrame);

		if ( (rDFrame.bCommand & PACKET_COMMAND_DATA)  ==  PACKET_COMMAND_DATA )	// DFrame
		{
			return  sizeof(rDFrame) + sizeof(DWORD)*arr_nNumOfBits[rDFrame.bControl >> 4];
		}
		else
		{
			CFRAME&	rCFrame	= *reinterpret_cast<CFRAME*>(i_pbTransportFrame);

			if ( rCFrame.bExtOpcode == FRAME_EXOPCODE_SACK )	// SACK CFrame
			{
				SFBIG8* pSFrame = reinterpret_cast<SFBIG8*>(i_pbTransportFrame);
				ULONG ulMaskSize = sizeof(DWORD)*arr_nNumOfBits[(pSFrame->bFlags >> 1) & 0x0F];

				// This is a Protocol version 1.0 frame
				return sizeof(SACKFRAME8) + ulMaskSize;
			}
			else	// Connection Control CFrame
			{
				return  sizeof(rCFrame);
			}
		}

	} // TransportHeaderSize

} // Anonymous namespace



// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbTransportFrame       - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbTransportFrame parameter.
//
DPLAYPARSER_API BYTE* BHAPI TransportRecognizeFrame( HFRAME        i_hFrame,
													  ULPBYTE        i_upbMacFrame,	
													  ULPBYTE        i_upbTransportFrame,
													  DWORD         i_dwMacType,        
													  DWORD         i_dwBytesLeft,      
													  HPROTOCOL     i_hPrevProtocol,  
													  DWORD         i_dwPrevProtOffset,
													  LPDWORD       o_pdwProtocolStatus,
													  LPHPROTOCOL   o_phNextProtocol,
												      PDWORD_PTR    io_pdwptrInstData )
{

	// Validate the amount of unclaimed data
	enum
	{
		nMIN_TransportHeaderSize = min(min(sizeof(DFRAME), sizeof(CFRAME)), sizeof(SACKFRAME8))
	};


	// Validate the packet as DPlay Transport type
	if ( i_dwBytesLeft < nMIN_TransportHeaderSize )
	{
		// Assume the unclaimed data is not recognizable
		*o_pdwProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		return i_upbTransportFrame;
	}


	// Check if we are dealing with a DPlay Voice packet
	enum
	{
		PACKET_COMMAND_SESSION  = PACKET_COMMAND_DATA | PACKET_COMMAND_USER_1,
		PACKET_COMMAND_VOICE = PACKET_COMMAND_DATA | PACKET_COMMAND_USER_1 | PACKET_COMMAND_USER_2
	};

	DFRAME&	rDFrame	= *reinterpret_cast<DFRAME*>(i_upbTransportFrame);

	*o_pdwProtocolStatus = PROTOCOL_STATUS_NEXT_PROTOCOL;

	// Let upper protocol's parser know if the message is a non-initial fragment of a fragmented message
	*io_pdwptrInstData = ((rDFrame.bCommand & PACKET_COMMAND_NEW_MSG)  ==  PACKET_COMMAND_NEW_MSG);


	if ( (rDFrame.bCommand & PACKET_COMMAND_VOICE)  ==  PACKET_COMMAND_VOICE )
	{
		// Notify NetMon about the handoff protocol
		*o_phNextProtocol	 = GetProtocolFromName("DPLAYVOICE");
	}
	else if ( (rDFrame.bCommand & PACKET_COMMAND_SESSION)  ==  PACKET_COMMAND_SESSION )
	{
		// Notify NetMon about the handoff protocol
		*o_phNextProtocol	 = GetProtocolFromName("DPLAYSESSION");
	}
	else
	{
		*o_pdwProtocolStatus = PROTOCOL_STATUS_RECOGNIZED;
		*o_phNextProtocol	 = NULL;
	}

    return i_upbTransportFrame + TransportHeaderSize(i_upbTransportFrame);

} // TransportRecognizeFrame



//=======================================//
// Attaching properties helper functions //
//=======================================//
namespace
{



	// DESCRIPTION: Maps the DWORD bitmask properties on a per-bit basis.
	//
	// ARGUMENTS: i_hFrame     - Handle of the frame that is being parsed.
	//			  i_nPropertyIndex - Index of the property in the global properties table.
	//			  i_pdwBitmask - Pointer to the value to which the property is being attached.
	//			  i_byBase - Base value from which the entry value is calculated.
	//			  i_Part - LOW or HIGH part of the QWORD bitmask.
	//			  i_Type - RCVD or DONTCARE type of the bitmask.
	//			  i_byLevel - Level in the detail pane tree.
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV AttachBitmaskDWORDProperties( HFRAME i_hFrame, int i_nPropertyIndex, UNALIGNED DWORD* i_pdwBitmask, BYTE i_byBase,
											  BitmaskPart i_Part, BitmaskType i_Type, BYTE i_byLevel )
	{
		for ( BYTE byBit = 0; byBit < 32; ++byBit )
		{
			SSACKBitmaskContext  BitmaskContext = { i_byBase, i_Part, i_Type, byBit };

			AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[i_nPropertyIndex].hProperty,
								   sizeof(*i_pdwBitmask), i_pdwBitmask,
								   sizeof(BitmaskContext), &BitmaskContext,
								   0, i_byLevel, 0);
		}
	
	} // AttachBitmaskDWORDProperties



	// DESCRIPTION: Maps the Data-Frame properties that exist in a piece of recognized data to specific locations.
	//
	// ARGUMENTS: i_hFrame     - Handle of the frame that is being parsed.
	//			  i_pbDFrame   - Pointer to the start of the recognized data.
	//
	// RETURNS: NOTHING
	//
	void AttachDFRAMEProperties( HFRAME  i_hFrame,
								 BYTE*  i_pbDFrame )
	{

		//=======================================//
		// Processing the core dataframe fields //
		//=======================================//
		//
		DFRAME&	 rDFrame = *reinterpret_cast<DFRAME*>(i_pbDFrame);
		
		// DCommand summary
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_DCOMMAND_SUMMARY].hProperty,
		                       sizeof(rDFrame.bCommand), &rDFrame.bCommand, 0, 1, 0);
	    
	    // DCommand field
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_DCOMMAND].hProperty,
		                       sizeof(rDFrame.bCommand), &rDFrame.bCommand, 0, 2, 0);

		// Control summary
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_CONTROL_SUMMARY].hProperty,
		                       sizeof(rDFrame.bControl), &rDFrame.bControl, 0, 1, 0);
	    // Control field
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_CONTROL].hProperty,
		                       sizeof(rDFrame.bControl), &rDFrame.bControl, 0, 2, 0);

	    // Sequence number field
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_SEQNUM].hProperty,
		                       sizeof(rDFrame.bSeq), &rDFrame.bSeq, 0, 1, 0);

		// Next receive number field
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_NEXTRECVNUM].hProperty,
		                       sizeof(rDFrame.bNRcv), &rDFrame.bNRcv, 0, 1, 0);


		//==================================================//
		// Processing the optional dataframe bitmask fields //
		//==================================================//
		//
		UNALIGNED DFBIG&  rDBigFrame = *reinterpret_cast<UNALIGNED DFBIG *>(i_pbDFrame);
		int nBitMaskIndex = 0;

		if ( (rDFrame.bControl & PACKET_CONTROL_SACK_MASK1)  ==  PACKET_CONTROL_SACK_MASK1 )
		{
			SSACKBitmaskContext  LowRCVDContext = { rDBigFrame.bNRcv, LOW, RCVD, NULL };
			
			// Low DWORD of Selective-ACK RCVD Mask summary (TRANSPORT_RCVDMASK1_SUMMARY)
			AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_RCVDMASK1_SUMMARY].hProperty,
								   sizeof(rDBigFrame.rgMask[nBitMaskIndex]), &rDBigFrame.rgMask[nBitMaskIndex],
								   sizeof(LowRCVDContext), &LowRCVDContext,
								   0, 1, 0);


			// Low DWORD of Selective-ACK RCVD Mask field (TRANSPORT_RCVDMASK1)
			AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK1, &rDBigFrame.rgMask[nBitMaskIndex], rDBigFrame.bNRcv, LOW, RCVD, 2);

			++nBitMaskIndex;
		}

		if ( (rDFrame.bControl & PACKET_CONTROL_SACK_MASK2)  ==  PACKET_CONTROL_SACK_MASK2 )
		{
			SSACKBitmaskContext  HighRCVDContext = { rDBigFrame.bNRcv, HIGH, RCVD, NULL };
			
			// High DWORD of Selective-ACK RCVD Mask summary (TRANSPORT_RCVDMASK2_SUMMARY)
			AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_RCVDMASK2_SUMMARY].hProperty,
								  sizeof(rDBigFrame.rgMask[nBitMaskIndex]), &rDBigFrame.rgMask[nBitMaskIndex],
								  sizeof(HighRCVDContext), &HighRCVDContext,
								  0, 1, 0);

			// High DWORD of Selective-ACK RCVD Mask field (TRANSPORT_RCVDMASK2)
			AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK2, &rDBigFrame.rgMask[nBitMaskIndex], rDBigFrame.bNRcv, HIGH, RCVD, 2);

			++nBitMaskIndex;
		}

		if ( (rDFrame.bControl & PACKET_CONTROL_SEND_MASK1)  ==  PACKET_CONTROL_SEND_MASK1 )
		{
			SSACKBitmaskContext  LowDONTCAREContext = { rDBigFrame.bSeq, LOW, DONTCARE, NULL };

			// Low DWORD of Selective-ACK DON'T CARE Mask summary (TRANSPORT_DONTCAREMASK1_SUMMARY)
			AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_DONTCAREMASK1_SUMMARY].hProperty,
								  sizeof(rDBigFrame.rgMask[nBitMaskIndex]), &rDBigFrame.rgMask[nBitMaskIndex],
								  sizeof(LowDONTCAREContext), &LowDONTCAREContext,
								  0, 1, 0);

			// Low DWORD of Selective-ACK RCVD Mask field (TRANSPORT_DONTCAREMASK1)
			AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK1, &rDBigFrame.rgMask[nBitMaskIndex], rDBigFrame.bSeq, LOW, DONTCARE, 2);

			++nBitMaskIndex;
		}

		if ( (rDFrame.bControl & PACKET_CONTROL_SEND_MASK2)  ==  PACKET_CONTROL_SEND_MASK2 )
		{
			SSACKBitmaskContext  HighDONTCAREContext = { rDBigFrame.bSeq, HIGH, DONTCARE, NULL };
			
			// High DWORD of Selective-ACK DON'T CARE Mask summary (TRANSPORT_DONTCAREMASK2_SUMMARY)
			AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_DONTCAREMASK2_SUMMARY].hProperty,
								   sizeof(rDBigFrame.rgMask[nBitMaskIndex]), &rDBigFrame.rgMask[nBitMaskIndex],
								   sizeof(HighDONTCAREContext), &HighDONTCAREContext,
								   0, 1, 0);

			// High DWORD of Selective-ACK RCVD Mask field (TRANSPORT_DONTCAREMASK2)
			AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK2, &rDBigFrame.rgMask[nBitMaskIndex], rDBigFrame.bSeq, HIGH, DONTCARE, 2);

		}

	} // AttachDFRAMEProperties



	// DESCRIPTION: Maps the Command-Frame properties that exist in a piece of recognized data to specific locations.
	//
	// ARGUMENTS: i_hFrame   - Handle of the frame that is being parsed.
	//			  i_pbCFrame - Pointer to the start of the recognized data.
	//
	// RETURNS: NOTHING
	//
	void AttachCFRAMEProperties( HFRAME  i_hFrame,
								 BYTE*  i_pbCFrame)
	{

		// Processing the core command frame fields
		//
		CFRAME&  rCFrame = *reinterpret_cast<CFRAME*>(i_pbCFrame);

	    // CCommand summary
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_CCOMMAND_SUMMARY].hProperty,
		                       sizeof(rCFrame.bCommand), &rCFrame.bCommand, 0, 1, 0);
	    // CCommand field
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_CCOMMAND].hProperty,
		                       sizeof(rCFrame.bCommand), &rCFrame.bCommand, 0, 2, 0);

		// ExtOpcode field
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_EXOPCODE].hProperty,
		                       sizeof(rCFrame.bExtOpcode), &rCFrame.bExtOpcode, 0, 1, 0);

		if ( rCFrame.bExtOpcode == FRAME_EXOPCODE_SACK )
		{
			//=======================================================//
			// Processing the Selective Acknowledgement Command frame fields //
			//=======================================================//
			//
			SFBIG8*  pSFrame	= reinterpret_cast<SFBIG8*>(i_pbCFrame);

			// SACK flags summary
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_SACKFIELDS_SUMMARY].hProperty,
								   sizeof(pSFrame->bFlags), &pSFrame->bFlags, 0, 1, 0);
			// SACK flags field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_SACKFIELDS].hProperty,
								   sizeof(pSFrame->bFlags), &pSFrame->bFlags, 0, 2, 0);

			// Retry field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_RETRY].hProperty,
								   sizeof(pSFrame->bRetry), &pSFrame->bRetry, 0, 1, 0);

			// Next sequence number field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_NEXTSEQNUM].hProperty,
								   sizeof(pSFrame->bNSeq), &pSFrame->bNSeq, 0, 1, 0);
			
			// Next receive number field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_NEXTRECVNUM].hProperty,
								   sizeof(pSFrame->bNRcv), &pSFrame->bNRcv, 0, 1, 0);

			UNALIGNED ULONG* pulMasks = 0;

			// This is a Protocol version 1.0 frame

			// Timestamp field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_TIMESTAMP].hProperty,
						   sizeof(pSFrame->tTimestamp), &pSFrame->tTimestamp, 0, 1, 0);
			pulMasks = pSFrame->rgMask;

			//================================================================================//
			// Processing the optional Selective Acknowledgement Command frame bitmask fields //
			//================================================================================//
			//

			int nBitMaskIndex = 0;

			if ( (pSFrame->bFlags & SACK_FLAGS_SACK_MASK1)  ==  SACK_FLAGS_SACK_MASK1 )
			{
				SSACKBitmaskContext  LowRCVDContext = { pSFrame->bNRcv, LOW, RCVD, NULL };
				
				// Low DWORD of Selective-ACK RCVD Mask summary (TRANSPORT_RCVDMASK1_SUMMARY)
				AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_RCVDMASK1_SUMMARY].hProperty,
									   sizeof(pulMasks[nBitMaskIndex]), &pulMasks[nBitMaskIndex],
									   sizeof(LowRCVDContext), &LowRCVDContext,
									   0, 1, 0);

				// Low DWORD of Selective-ACK RCVD Mask field (TRANSPORT_RCVDMASK1)
				AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK1, &pulMasks[nBitMaskIndex], pSFrame->bNRcv, LOW, RCVD, 2);
				
				++nBitMaskIndex;
			}

			if ( (pSFrame->bFlags & SACK_FLAGS_SACK_MASK2)  ==  SACK_FLAGS_SACK_MASK2 )
			{
				SSACKBitmaskContext  HighRCVDContext = { pSFrame->bNRcv, HIGH, RCVD, NULL };
				
				// High DWORD of Selective-ACK RCVD Mask summary (TRANSPORT_RCVDMASK2_SUMMARY)
				AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_RCVDMASK2_SUMMARY].hProperty,
									   sizeof(pulMasks[nBitMaskIndex]), &pulMasks[nBitMaskIndex],
									   sizeof(HighRCVDContext), &HighRCVDContext,
									   0, 1, 0);

				// High DWORD of Selective-ACK RCVD Mask field (TRANSPORT_RCVDMASK2)
				AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK2, &pulMasks[nBitMaskIndex], pSFrame->bNRcv, HIGH, RCVD, 2);

				++nBitMaskIndex;
			}

			if ( (pSFrame->bFlags & SACK_FLAGS_SEND_MASK1)  ==  SACK_FLAGS_SEND_MASK1 )
			{
				SSACKBitmaskContext  LowDONTCAREContext = { pSFrame->bNSeq, LOW, DONTCARE, NULL };
				
				// Low DWORD of Selective-ACK DON'T CARE Mask summary (TRANSPORT_DONTCAREMASK1_SUMMARY)
				AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_DONTCAREMASK1_SUMMARY].hProperty,
									   sizeof(pulMasks[nBitMaskIndex]), &pulMasks[nBitMaskIndex],
	 								   sizeof(LowDONTCAREContext), &LowDONTCAREContext,
									   0, 1, 0);

				// Low DWORD of Selective-ACK RCVD Mask field (TRANSPORT_DONTCAREMASK1)
				AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK1, &pulMasks[nBitMaskIndex], pSFrame->bNSeq, LOW, DONTCARE, 2);
				
				++nBitMaskIndex;
			}

			if ( (pSFrame->bFlags & SACK_FLAGS_SEND_MASK2)  ==  SACK_FLAGS_SEND_MASK2 )
			{
				SSACKBitmaskContext  HighDONTCAREContext = { pSFrame->bNSeq, HIGH, DONTCARE, NULL };
				
				// High DWORD of Selective-ACK DON'T CARE Mask summary (TRANSPORT_DONTCAREMASK2_SUMMARY)
				AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_DONTCAREMASK2_SUMMARY].hProperty,
									   sizeof(pulMasks[nBitMaskIndex]), &pulMasks[nBitMaskIndex],
									   sizeof(HighDONTCAREContext), &HighDONTCAREContext,
									   0, 1, 0);

				// High DWORD of Selective-ACK RCVD Mask field (TRANSPORT_DONTCAREMASK2)
				AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK2, &pulMasks[nBitMaskIndex], pSFrame->bNSeq, HIGH, DONTCARE, 2);
				
				++nBitMaskIndex;
			}
		}
		else
		{
			//========================================================//
			// Processing the Connection Control Command frame fields //
			//========================================================//

			// Message ID field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_MSGID].hProperty,
								   sizeof(rCFrame.bMsgID), &rCFrame.bMsgID, 0, 1, 0);

			// Response ID field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_RSPID].hProperty,
								   sizeof(rCFrame.bRspID), &rCFrame.bRspID, 0, 1, 0);

			// Version number field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_VERSION].hProperty,
								   sizeof(rCFrame.dwVersion), &rCFrame.dwVersion, 0, 1, 0);

			// Session ID field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_SESSIONID].hProperty,
								   sizeof(rCFrame.dwSessID), &rCFrame.dwSessID, 0, 1, 0);
		
			// Timestamp field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_TIMESTAMP].hProperty,
								   sizeof(rCFrame.tTimestamp), &rCFrame.tTimestamp, 0, 1, 0);
		}

	} // AttachCFRAMEProperties


	// Platform independent memory accessor of big endian words
	inline WORD ReadBigEndianWord( BYTE* i_pbData )
	{
		return (*i_pbData << 8) | *(i_pbData+1);
	}

}	// Anonymous namespace



// DESCRIPTION: Maps the properties that exist in a piece of recognized data to specific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbTransportFrame - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: Must return NULL
//
DPLAYPARSER_API BYTE* BHAPI TransportAttachProperties( HFRAME      i_hFrame,
														ULPBYTE      i_upbMacFrame,
														ULPBYTE      i_upbTransportFrame,
														DWORD       i_dwMacType,
														DWORD       i_dwBytesLeft,
														HPROTOCOL   i_hPrevProtocol,
														DWORD       i_dwPrevProtOffset,
														DWORD_PTR   i_dwptrInstData )
{
	// TODO: Use HelpID in AttachPropertyInstance

	// Check if the packet is a KeepAlive
	const size_t  sztTransportHeaderSize = TransportHeaderSize(i_upbTransportFrame);
	const DFRAME& rDFrame = *reinterpret_cast<DFRAME*>(i_upbTransportFrame);


	size_t sztTransportFrameSize = i_dwptrInstData;
	// If an empty dataframe and not the last packet in the stream, than it's a KeepAlive
	BOOL bKeepAlive = ( (sztTransportHeaderSize  ==  sztTransportFrameSize) &&
						((rDFrame.bControl & PACKET_CONTROL_END_STREAM)  !=  PACKET_CONTROL_END_STREAM) );


    //===================//
    // Attach Properties //
    //===================//
	//
    // Transport summary line
    AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_SUMMARY].hProperty,
							 sztTransportHeaderSize, i_upbTransportFrame,
							 sizeof(BOOL), &bKeepAlive,
							 0, 0, 0);

	#if defined(PARSE_DPLAY_TRANSPORT)
	
		if ( (rDFrame.bCommand & PACKET_COMMAND_DATA)  ==  PACKET_COMMAND_DATA )
		{
			AttachDFRAMEProperties(i_hFrame, i_upbTransportFrame);

			enum
			{
				USERDATA_BITMASK = ~(PACKET_COMMAND_USER_1 | PACKET_COMMAND_USER_2)
			};

			if ( (rDFrame.bCommand | USERDATA_BITMASK) == USERDATA_BITMASK )
			{
				// User data (TRANSPORT_USERDATA)
				AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_USERDATA].hProperty,
									   sztTransportFrameSize - sztTransportHeaderSize, i_upbTransportFrame + sztTransportHeaderSize, 0, 1, 0);
			}
		}
		else
		{
			AttachCFRAMEProperties(i_hFrame, i_upbTransportFrame);
		}

	#endif // PARSE_DPLAY_TRANSPORT

	return NULL;

} // TransportAttachProperties





// DESCRIPTION: Formats the data that is displayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbCoreFrame		- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbTransportFrame.
//
DPLAYPARSER_API DWORD BHAPI TransportFormatProperties( HFRAME          i_hFrame,
													   ULPBYTE          i_upbMacFrame,
													   ULPBYTE          i_upbTransportFrame,
													   DWORD           i_dwPropertyInsts,
													   LPPROPERTYINST  i_pPropInst )
{
    // Loop through the property instances...
    while( i_dwPropertyInsts-- > 0)
    {
        // ...and call the formatter for each
		reinterpret_cast<FORMAT>(i_pPropInst->lpPropertyInfo->InstanceData)(i_pPropInst);
        ++i_pPropInst;
    }

    return NMERR_SUCCESS;
}




// DESCRIPTION: Notifies Network Monitor that Transport protocol parser exists.
//
// ARGUMENTS: NONE
//
// RETURNS: TRUE - success, FALSE - failure
//
bool CreateTransportProtocol( void )
{
	
	// The entry points to the export functions that Network Monitor uses to operate the parser
	ENTRYPOINTS TransportEntryPoints =
	{
		// TransportParser Entry Points
		TransportRegister,
		TransportDeregister,
		TransportRecognizeFrame,
		TransportAttachProperties,
		TransportFormatProperties
	};
	
	// The first active instance of this parser needs to register with the kernel
	g_hTransportProtocol = CreateProtocol("DPLAYTRANSPORT", &TransportEntryPoints, ENTRYPOINTS_SIZE);

	return (g_hTransportProtocol ? TRUE : FALSE);

} // CreateTransportProtocol



// DESCRIPTION: Removes the Transport protocol parser from the Network Monitor's database of parsers
//
// ARGUMENTS: NONE
//
// RETURNS: NOTHING
//
void DestroyTransportProtocol( void )
{

	DestroyProtocol(g_hTransportProtocol);

} // DestroyTransportProtocol
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\parsers\voiceparser.cpp ===
//=============================================================================
//  FILE: VoiceParser.cpp
//
//  Description: DirectPlay Service Provider Parser
//
//
//  Modification History:
//
//  Michael Milirud      08/Aug/2000    Created
//=============================================================================


//==================//
// Standard headers //
//==================//
#include <string>
#include <winsock2.h>
#include <wsipx.h>

// DVoice.h, included by DVProt.h, will _define_ the Compression Type GUIDs.
#include <initguid.h>


//=====================//
// Proprietary headers //
//=====================//

// Prototypes
#include "VoiceParser.hpp"

// Voice protocol header
#include "DVoice.h"
#include "DVProt.h"


namespace
{
	HPROTOCOL  g_hVoiceProtocol;

	
	//====================//
	// Message Type field //---------------------------------------------------------------------------------------------
	//====================//
	LABELED_BYTE g_arr_MessageTypeByteLabels[] = { { DVMSGID_CONNECTREQUEST,	  "Establishing connection"						   },
												   { DVMSGID_CONNECTREFUSE,		  "Connection request rejected"					   },
										           { DVMSGID_CONNECTACCEPT,		  "Connection request granted"					   },
										           { DVMSGID_SETTINGSCONFIRM,     "Confirming support for the connection settings" },
										           { DVMSGID_PLAYERLIST,		  "List of players in the session"				   },
										           { DVMSGID_SPEECH,			  "Audio data"									   },
										           { DVMSGID_SPEECHWITHTARGET,	  "Targeted audio data"							   },
										           { DVMSGID_SPEECHWITHFROM,	  "Proxied audio data"							   },
										           { DVMSGID_SETTARGETS,		  "Setting client's target"			 		       },
										           { DVMSGID_CREATEVOICEPLAYER,	  "New player joined the session"			       },
										           { DVMSGID_DELETEVOICEPLAYER,	  "Player left the session"						   },
										           { DVMSGID_SESSIONLOST,		  "Session is lost"								   },
										           { DVMSGID_DISCONNECTCONFIRM,	  "Disconnection notification acknowledged"	       },
										           { DVMSGID_DISCONNECT,		  "Disconnecting"								   },
												   { DVMSGID_PLAYERLIST,		  "Players list"								   } };

	SET g_LabeledMessageTypeByteSet = { sizeof(g_arr_MessageTypeByteLabels) / sizeof(LABELED_BYTE), g_arr_MessageTypeByteLabels };



	//===================//
	// Result Code field //----------------------------------------------------------------------------------------------
	//===================//
	LABELED_DWORD g_arr_ResultCodeDWordLabels[] = { { DVERR_BUFFERTOOSMALL,				"Buffer is too small"										},
												    { DVERR_EXCEPTION,					"Exception was thrown"										},
												    { DVERR_GENERIC,					"Generic error"												},
												    { DVERR_INVALIDFLAGS,				"Invalid flags"												},
												    { DVERR_INVALIDOBJECT,				"Invalid object"											},
												    { DVERR_INVALIDPARAM,				"Invalid parameter(s)"										},
												    { DVERR_INVALIDPLAYER,				"Invalid player"											},
												    { DVERR_INVALIDGROUP,				"Invalid group"												},
												    { DVERR_INVALIDHANDLE,				"Invalid handle"											},
												    { DVERR_INVALIDPOINTER,				"Invalid pointer"											},
												    { DVERR_OUTOFMEMORY,				"Out of memory"												},
												    { DVERR_CONNECTABORTING,			"Aborting connection"										},
												    { DVERR_CONNECTIONLOST,				"Connection lost"											},
												    { DVERR_CONNECTABORTED,				"Connection aborted"										},
												    { DVERR_CONNECTED,					"Connected"													},
												    { DVERR_NOTCONNECTED,				"Not connected"												},
												    { DVERR_NOTINITIALIZED,				"Not initialized"											},
												    { DVERR_NOVOICESESSION,				"No voice session"											},
												    { DVERR_NOTALLOWED,					"Not allowed"												},
												    { DVERR_NOTHOSTING,					"Not hosting"												},
												    { DVERR_NOTSUPPORTED,				"Not supported"												},
												    { DVERR_NOINTERFACE,				"No interface"												},
												    { DVERR_NOTBUFFERED,				"Not buffered"												},
												    { DVERR_NOTRANSPORT,				"No transport"												},
												    { DVERR_NOCALLBACK,					"No callback"												},
												    { DVERR_NO3DSOUND,					"No 3D sound"												},
												    { DVERR_NORECVOLAVAILABLE,			"No recording volume available"								},
												    { DVERR_SESSIONLOST,				"Session lost"												},
												    { DVERR_PENDING,					"Pending"													},
												    { DVERR_INVALIDTARGET,				"Invalid target"											},
												    { DVERR_TRANSPORTNOTHOST,			"Transport is not hosting"									},
												    { DVERR_COMPRESSIONNOTSUPPORTED,	"Compression is not supported"								},
												    { DVERR_ALREADYPENDING,				"Already pending"											},
												    { DVERR_SOUNDINITFAILURE,			"Sound initialization failed"								},
												    { DVERR_TIMEOUT,					"Timeout"													},
												    { DVERR_ALREADYBUFFERED,			"Already buffered"											},
												    { DVERR_HOSTING,					"Hosting"													},
												    { DVERR_INVALIDDEVICE,				"Invalid device"											},
												    { DVERR_RECORDSYSTEMERROR,			"Record system error"										},
												    { DVERR_PLAYBACKSYSTEMERROR,		"Playback system error"										},
												    { DVERR_SENDERROR,					"Send error"												},
												    { DVERR_USERCANCEL,					"Cancelled by user"											},
												    { DVERR_RUNSETUP,					"Run setup"													},
												    { DVERR_INCOMPATIBLEVERSION,		"Incompatible version"										},
												    { DVERR_INITIALIZED,				"Initialized"												},
												    { DVERR_TRANSPORTNOTINIT,			"Transport not initialized"									},
												    { DVERR_TRANSPORTNOSESSION,			"Transport is not hosting or connecting"					},
												    { DVERR_TRANSPORTNOPLAYER,			"Legacy DirectPlay local player has not yet been created"	},
												    { DVERR_USERBACK,					"Back button was used improperly in the wizard"				},
												    { DVERR_INVALIDBUFFER,				"Invalid buffer"											},
													{ DV_OK,							"Success"													} };

	SET g_LabeledResultCodeDWordSet = { sizeof(g_arr_ResultCodeDWordLabels) / sizeof(LABELED_DWORD), g_arr_ResultCodeDWordLabels };


	//====================//
	// Session Type field //---------------------------------------------------------------------------------------------
	//====================//
	LABELED_DWORD g_arr_SessionTypeDWordLabels[] = { { DVSESSIONTYPE_PEER,			"Peer to peer"	  },
													 { DVSESSIONTYPE_MIXING,		"Mixing server"	  },
													 { DVSESSIONTYPE_FORWARDING,  "Forwarding server" },
													 { DVSESSIONTYPE_ECHO,			"Loopback"		  } };

	SET g_LabeledSessionTypeDWordSet = { sizeof(g_arr_SessionTypeDWordLabels) / sizeof(LABELED_DWORD), g_arr_SessionTypeDWordLabels };


	//====================//
	// Session Flags field //--------------------------------------------------------------------------------------------
	//====================//
	LABELED_BIT g_arr_SessionFlagsBitLabels[] = { { 1, "Host Migration enabled",	    "No Host Migration"		     },	    // DVSESSION_NOHOSTMIGRATION
												  { 2, "No Server Control Target mode", "Server Control Target mode" } };	// DVSESSION_SERVERCONTROLTARGET

	SET g_LabeledSessionFlagsBitSet = { sizeof(g_arr_SessionFlagsBitLabels) / sizeof(LABELED_BIT), g_arr_SessionFlagsBitLabels };


	//====================//
	// Player Flags field //---------------------------------------------------------------------------------------------
	//====================//
	LABELED_BIT g_arr_PlayerFlagsBitLabels[] = { { 1, "Player supports full-duplex connection", "Player only supports half-duplex connection" } }; // DVPLAYERCAPS_HALFDUPLEX

	SET g_LabeledPlayerFlagsBitSet = { sizeof(g_arr_PlayerFlagsBitLabels) / sizeof(LABELED_BIT), g_arr_PlayerFlagsBitLabels };


	//=====================//
	// Host Order ID field //--------------------------------------------------------------------------------------------
	//=====================//
	LABELED_DWORD g_arr_HostOrderDWordLabels[] = { { -1, "Hasn't been assigned by the host yet"	} };

	SET g_LabeledHostOrderIDDWordSet = { sizeof(g_arr_HostOrderDWordLabels) / sizeof(LABELED_DWORD), g_arr_HostOrderDWordLabels };


	////////////////////////////////
	// Custom Property Formatters //=====================================================================================
	////////////////////////////////

	// DESCRIPTION: Custom description formatter for the Voice packet summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_VoiceSummary( LPPROPERTYINST io_pProperyInstance )
	{
		std::string strSummary;
		char arr_cBuffer[10];

		DVPROTOCOLMSG_FULLMESSAGE&	rVoiceFrame = *reinterpret_cast<DVPROTOCOLMSG_FULLMESSAGE*>(io_pProperyInstance->lpData);

		DWORD dwType = rVoiceFrame.dvGeneric.dwType;


		// Message classification
		switch ( dwType )
		{
		case DVMSGID_CONNECTREQUEST:
		case DVMSGID_CONNECTREFUSE:
		case DVMSGID_CONNECTACCEPT:
		case DVMSGID_DISCONNECT:
		case DVMSGID_DISCONNECTCONFIRM:
		case DVMSGID_SETTINGSCONFIRM:
			{
				strSummary = "Connection Control : ";
				break;
			}

		case DVMSGID_SPEECH:
		case DVMSGID_SPEECHWITHTARGET:
		case DVMSGID_SPEECHWITHFROM:
			{
				strSummary = "Speech : ";
				break;
			}

		case DVMSGID_PLAYERLIST:
		case DVMSGID_SETTARGETS:
		case DVMSGID_CREATEVOICEPLAYER:
		case DVMSGID_DELETEVOICEPLAYER:
		case DVMSGID_SESSIONLOST:
			{
				strSummary = "Session Control : ";
				break;
			}

		default:
			{
				strSummary = "INVALID";
				break;
			}
		}


		// Message title
		switch ( dwType )
		{
		case DVMSGID_CREATEVOICEPLAYER:
			{
				strSummary += "Player ";
				strSummary += _itoa(rVoiceFrame.dvPlayerJoin.dvidID, arr_cBuffer, 16);
				strSummary += " joined the session";
				break;
			}

		default:
			{
				for ( int n = 0; n < sizeof(g_arr_MessageTypeByteLabels) / sizeof(LABELED_BYTE); ++n )
				{
					if ( g_arr_MessageTypeByteLabels[n].Value == dwType )
					{
						strSummary += g_arr_MessageTypeByteLabels[n].Label;
						break;
					}
				}

				break;
			}
		}

		// Message highlights
		switch ( dwType )
		{
		case DVMSGID_PLAYERLIST:
			{
				strSummary += " (";
				strSummary += _itoa(rVoiceFrame.dvPlayerList.dwNumEntries, arr_cBuffer, 10);
				strSummary += " players)";
				break;
			}

		case DVMSGID_CONNECTACCEPT:
			{
				strSummary += " (";
				for ( int n = 0; n < sizeof(g_arr_SessionTypeDWordLabels)/sizeof(LABELED_DWORD); ++n )
				{
					if ( g_arr_SessionTypeDWordLabels[n].Value == rVoiceFrame.dvConnectAccept.dwSessionType )
					{
						strSummary += g_arr_SessionTypeDWordLabels[n].Label;
						break;
					}
				}
				strSummary += ")";
				break;
			}

		case DVMSGID_SPEECH:
		case DVMSGID_SPEECHWITHTARGET:
		case DVMSGID_SPEECHWITHFROM:
			{
				strSummary += " [";
				strSummary += _itoa(rVoiceFrame.dvSpeech.bMsgNum, arr_cBuffer, 10);
				strSummary += ".";
				strSummary += _itoa(rVoiceFrame.dvSpeech.bSeqNum, arr_cBuffer, 10);
				strSummary += "]";
				break;
			}
		}

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_VoiceSummary



	// DESCRIPTION: Custom description formatter for the Compression Type field
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_CompressionType( LPPROPERTYINST io_pProperyInstance )
	{

		std::string strSummary = "Compression Type = ";

		// Check what Voice frame we are dealing with
		REFGUID rguidCompressionType = *reinterpret_cast<GUID*>(io_pProperyInstance->lpData);

		if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_TRUESPEECH) )
		{
			strSummary += "TrueSpeech(TM) (8.6kbps) ";
		}
		else if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_GSM) )
		{
			strSummary += "Microsoft GSM 6.10 (13kbps) ";
		}
		else if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_NONE) )
		{
			strSummary += "None ";
		}
		else if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_ADPCM) )
		{
			strSummary += "Microsoft ADPCM (32.8kbps) ";
		}
		else if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_SC03) )
		{
			strSummary += "Voxware SC03 (3.2kbps) ";
		}
		else if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_SC06) )
		{
			strSummary += "Voxware SC06 (6.4kbps) ";
		}
		else if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_VR12) )
		{
			strSummary += "Voxware VR12 (1.4kbps) ";
		}
		else
		{
			strSummary += "Uknown";
		}


		enum
		{
			nMAX_GUID_STRING = 50	// more than enough characters for a symbolic representation of a GUID
		};

		OLECHAR arr_wcGUID[nMAX_GUID_STRING];
		StringFromGUID2(rguidCompressionType, arr_wcGUID, sizeof(arr_wcGUID)/sizeof(TCHAR));

		char arr_cGUID[nMAX_GUID_STRING];
		WideCharToMultiByte(CP_ACP, 0, arr_wcGUID, -1, arr_cGUID, sizeof(arr_cGUID), NULL, NULL);
		strSummary += arr_cGUID;


		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_CompressionType



	// DESCRIPTION: Custom description formatter for the Players List summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_PlayersListSummary( LPPROPERTYINST io_pProperyInstance )
	{

		sprintf(io_pProperyInstance->szPropertyText, "List of %d players in the session", io_pProperyInstance->lpPropertyInstEx->Dword[0]);

	} // FormatPropertyInstance_PlayersListSummary



	// DESCRIPTION: Custom description formatter for the Player's Entry summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_PlayerEntrySummary( LPPROPERTYINST io_pProperyInstance )
	{

		DWORD* pdwData = io_pProperyInstance->lpPropertyInstEx->Dword;
		sprintf(io_pProperyInstance->szPropertyText, "Player %d out of %d", pdwData[0], pdwData[1]);

	} // FormatPropertyInstance_PlayerEntrySummary



	// DESCRIPTION: Custom description formatter for the Session Flags summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_SessionFlagsSummary( LPPROPERTYINST io_pProperyInstance )
	{

		std::string strSummary;

		if ( (*io_pProperyInstance->lpDword & DVSESSION_NOHOSTMIGRATION) == DVSESSION_NOHOSTMIGRATION )
		{
			strSummary = g_arr_SessionFlagsBitLabels[0].LabelOn;
		}
		else
		{
			strSummary = g_arr_SessionFlagsBitLabels[0].LabelOff;
		}


		strSummary += ", ";

		if ( (*io_pProperyInstance->lpDword & DVSESSION_SERVERCONTROLTARGET) == DVSESSION_SERVERCONTROLTARGET )
		{
			strSummary += g_arr_SessionFlagsBitLabels[1].LabelOn;
		}
		else
		{
			strSummary += g_arr_SessionFlagsBitLabels[1].LabelOff;
		}

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_SessionFlagsSummary


	// DESCRIPTION: Custom description formatter for the Player's Entry summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_PlayerFlagsSummary( LPPROPERTYINST io_pProperyInstance )
	{

		std::string strSummary;

		if ( (*io_pProperyInstance->lpDword & DVSESSION_NOHOSTMIGRATION) == DVSESSION_NOHOSTMIGRATION )
		{
			strSummary = g_arr_PlayerFlagsBitLabels[0].LabelOn;
		}
		else
		{
			strSummary = g_arr_PlayerFlagsBitLabels[0].LabelOff;
		}

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_PlayerFlagsSummary

	
	//==================//
	// Properties table //-----------------------------------------------------------------------------------------------
	//==================//
	
	PROPERTYINFO g_arr_VoiceProperties[] = 
	{

		// VOICE packet summary property (VOICE_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "DPlay Voice packet",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_VoiceSummary			// generic formatter
		},

		// Message Type property (VOICE_UNPARSABLEFRAGMENT)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "This is a non-initial part of the fragmented Transport layer message and can not be parsed", // label
		    "Unparsable fragment summary",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Message Type property ((VOICE_INCOMPLETEMESSAGE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "The rest of the data needed to parse this message has been sent in a separate fragment and can not be parsed",  // label
		    "Incomplete message summary",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Message Type property (VOICE_MESSAGETYPE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Message Type",								// label
		    "Message Type field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_LABELED_SET,						// data type qualifier.
		    &g_LabeledMessageTypeByteSet,				// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Major Version property (VOICE_MAJORVERSION)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Major Version",							// label
		    "Major Version field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Minor Version property (VOICE_MINORVERSION)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Minor Version",							// label
		    "Minor Version field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Build Version property (VOICE_BUILDVERSION)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Build Version",							// label
		    "Build Version field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Result Code property (VOICE_RESULTCODE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Result Code",								// label
		    "Result Code field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type (HRESULT)
			PROP_QUAL_LABELED_SET,						// data type qualifier.
			&g_LabeledResultCodeDWordSet,				// labeled byte set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Session Type property (VOICE_SESSIONTYPE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Session Type",								// label
		    "Session Type field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_LABELED_SET,						// data type qualifier.
			&g_LabeledSessionTypeDWordSet,				// labeled byte set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Session Flags property (VOICE_SESSIONFLAGS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Session Flags summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
		    64,											// description's maximum length
		    FormatPropertyInstance_SessionFlagsSummary	// generic formatter
		},

		// Session Flags property (VOICE_SESSIONFLAGS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Session Flags",							// label
		    "Session Flags field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_FLAGS,							// data type qualifier.
			&g_LabeledSessionFlagsBitSet,				// labeled byte set 
		    512,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Session Flags property (VOICE_PLAYERFLAGS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Player Flags summary",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
		    64,											// description's maximum length
		    FormatPropertyInstance_PlayerFlagsSummary	// generic formatter
		},

		// Session Flags property (VOICE_PLAYERFLAGS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Player Flags",								// label
		    "Player Flags field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_FLAGS,							// data type qualifier.
			&g_LabeledPlayerFlagsBitSet,				// labeled byte set 
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Number of Targets property (VOICE_NUMBEROFTARGETS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Number of Targets",						// label
		    "Number of Targets field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Compression Type property (VOICE_COMPRESSIONTYPE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Compression Type",							// label
		    "Compression Type field",					// status-bar comment
		    PROP_TYPE_RAW_DATA,							// data type (GUID)
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_CompressionType		// generic formatter
		},

		// Host Migration Sequence Number property (VOICE_HOSTORDERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Host Migration Sequence Number",			// label
		    "Host Migration Sequence Number field",		// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_LABELED_SET,						// data type qualifier.
		    &g_LabeledHostOrderIDDWordSet,				// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Number of Players property (VOICE_NUMBEROFPLAYERS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Number of Players",						// label
		    "Number of Players field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Player's summary property (VOICE_PLAYERLISTSUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Player's list summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_PlayersListSummary	// generic formatter
		},

		// Player's summary property (VOICE_PLAYERSUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Player's summary",							// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_PlayerEntrySummary	// generic formatter
		},

		// Player's ID property (VOICE_PLAYERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Player ID",								// label
		    "Player ID field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Player's ID property (VOICE_TARGETID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Target ID",								// label
		    "Target ID field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Message Number property (VOICE_MESSAGENUMBER)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Message #",							// label
		    "Message Number field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Fragment Number property (VOICE_FRAGMENTNUMBER)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Fragment #",							// label
		    "Fragment Number field",					// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Audio Data (VOICE_AUDIODATA)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Audio Data",								// label
		    "Audio Data",								// status-bar comment
		    PROP_TYPE_RAW_DATA,							// data type (GUID)
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		}
	};

	enum
	{
		nNUM_OF_VOICE_PROPS = sizeof(g_arr_VoiceProperties) / sizeof(PROPERTYINFO)
	};


	// Properties' indices
	enum
	{
		VOICE_SUMMARY = 0,
		VOICE_UNPARSABLEFRAGMENT,
		VOICE_INCOMPLETEMESSAGE,

		VOICE_MESSAGETYPE,
		VOICE_MAJORVERSION,
		VOICE_MINORVERSION,
		VOICE_BUILDVERSION,
		
		VOICE_RESULTCODE,
		VOICE_SESSIONTYPE,
		
		VOICE_SESSIONFLAGS_SUMMARY,
		VOICE_SESSIONFLAGS,
		
		VOICE_PLAYERFLAGS_SUMMARY,
		VOICE_PLAYERFLAGS,
		
		VOICE_NUMBEROFTARGETS,
		VOICE_COMPRESSIONTYPE,
		VOICE_HOSTORDERID,
		VOICE_NUMBEROFPLAYERS,
		
		VOICE_PLAYERLIST_SUMMARY,
		VOICE_PLAYERSUMMARY,
		
		VOICE_PLAYERID,
		VOICE_TARGETID,
		
		VOICE_MESSAGENUMBER,
		VOICE_FRAGMENTNUMBER,
		
		VOICE_AUDIODATA
	};

} // anonymous namespace








// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hVoiceProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI VoiceRegister( HPROTOCOL i_hVoiceProtocol ) 
{

	CreatePropertyDatabase(i_hVoiceProtocol, nNUM_OF_VOICE_PROPS);

	// Add the properties to the database
	for( int nProp=0; nProp < nNUM_OF_VOICE_PROPS; ++nProp )
	{
	   AddProperty(i_hVoiceProtocol, &g_arr_VoiceProperties[nProp]);
	}

} // VoiceRegister



// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hVoiceProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI VoiceDeregister( HPROTOCOL i_hProtocol )
{

	DestroyPropertyDatabase(i_hProtocol);

} // VoiceDeregister




namespace
{

	// DESCRIPTION: Parses the Voice frame to find its size (in bytes) NOT including the user data
	//
	// ARGUMENTS: i_pbVoiceFrame - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
	//						    in the middle of a frame because a previous parser has claimed data before this parser.
	//
	// RETURNS: Size of the Voiceecified Voice frame (in bytes)
	//
	int VoiceHeaderSize( LPBYTE i_pbVoiceFrame )
	{

		// Check what Voice frame we are dealing with
		DVPROTOCOLMSG_FULLMESSAGE&	rVoiceFrame = *reinterpret_cast<DVPROTOCOLMSG_FULLMESSAGE*>(i_pbVoiceFrame);

		switch ( rVoiceFrame.dvGeneric.dwType )
		{
		case DVMSGID_CONNECTREQUEST:
			{
				return sizeof(rVoiceFrame.dvConnectRequest);
			}

		case DVMSGID_CONNECTREFUSE:
			{
				return sizeof(rVoiceFrame.dvConnectRefuse);
			}

		case DVMSGID_CONNECTACCEPT:
			{
				return sizeof(rVoiceFrame.dvConnectAccept);
			}

		case DVMSGID_SETTINGSCONFIRM:
			{
				return sizeof(rVoiceFrame.dvSettingsConfirm);
			}

		case DVMSGID_PLAYERLIST:
			{
				return sizeof(rVoiceFrame.dvPlayerList);
			}

		case DVMSGID_SPEECH:
			{
				return sizeof(rVoiceFrame.dvSpeech);
			}

		case DVMSGID_SPEECHWITHTARGET:
			{
				return sizeof(rVoiceFrame.dvSpeechWithTarget);
			}

		case DVMSGID_SPEECHWITHFROM:
			{
				return sizeof(rVoiceFrame.dvSpeechWithFrom);
			}

		case DVMSGID_SETTARGETS:
			{
				return sizeof(rVoiceFrame.dvSetTarget);
			}

		case DVMSGID_CREATEVOICEPLAYER:
			{
				return sizeof(rVoiceFrame.dvPlayerJoin);
			}

		case DVMSGID_DELETEVOICEPLAYER:
			{
				return sizeof(rVoiceFrame.dvPlayerQuit);
			}

		case DVMSGID_SESSIONLOST:
			{
				return sizeof(rVoiceFrame.dvSessionLost);
			}

		case DVMSGID_DISCONNECTCONFIRM:
		case DVMSGID_DISCONNECT:
			{
				return sizeof(rVoiceFrame.dvDisconnect);
			}

		default:
			{
				return -1;	 // TODO:		DPF(0, "Unknown voice frame!");
			}
		}

	} // VoiceHeaderSize

} // Anonymous namespace



// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbVoiceFrame      - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbVoiceFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI VoiceRecognizeFrame( HFRAME        i_hFrame,
												  ULPBYTE        i_upbMacFrame,	
												  ULPBYTE        i_upbyVoiceFrame,
												  DWORD         i_dwMacType,        
												  DWORD         i_dwBytesLeft,      
												  HPROTOCOL     i_hPrevProtocol,  
												  DWORD         i_dwPrevProtOffset,
												  LPDWORD       o_pdwProtocolStatus,
												  LPHPROTOCOL   o_phNextProtocol,
												  PDWORD_PTR    io_pdwptrInstData )
{

	// Validate the amount of unclaimed data
	enum
	{
		// TODO: CHANGE TO PROPER MIN SIZE
		nMIN_VoiceHeaderSize = sizeof(_DVPROTOCOLMSG_GENERIC),
		nNUMBER_OF_MSG_TYPES = sizeof(g_arr_MessageTypeByteLabels) / sizeof(LABELED_BYTE)
	};

	for ( int nTypeIndex = 0; nTypeIndex < nNUMBER_OF_MSG_TYPES; ++nTypeIndex )
	{
		if ( g_arr_MessageTypeByteLabels[nTypeIndex].Value == *i_upbyVoiceFrame )
		{
			break;
		}
	}

	
	// Validate the packet as DPlay Session type
	if ( ((i_dwBytesLeft >= nMIN_VoiceHeaderSize)  &&  (nTypeIndex < nNUMBER_OF_MSG_TYPES))  ||  (*io_pdwptrInstData == 0) )
	{
		// Claim the remaining data
	    *o_pdwProtocolStatus = PROTOCOL_STATUS_CLAIMED;
	    return NULL;
	}

	// Assume the unclaimed data is not recognizable
	*o_pdwProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
	return i_upbyVoiceFrame;

} // VoiceRecognizeFrame



// DESCRIPTION: Maps the properties that exist in a piece of recognized data to Voiceecific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbVoiceFrame     - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: Must return NULL
//
DPLAYPARSER_API LPBYTE BHAPI VoiceAttachProperties( HFRAME      i_hFrame,
													ULPBYTE      i_upbyMacFrame,
													ULPBYTE      i_upbyVoiceFrame,
													DWORD       i_dwMacType,
													DWORD       i_dwBytesLeft,
													HPROTOCOL   i_hPrevProtocol,
													DWORD       i_dwPrevProtOffset,
												    DWORD_PTR   i_dwptrInstData )
{
    //===================//
    // Attach Properties //
    //===================//

    if ( i_dwptrInstData == 0 )
    {
    	AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_UNPARSABLEFRAGMENT].hProperty,
    						i_dwBytesLeft, i_upbyVoiceFrame, 0, 0, 0);
    	return NULL;
    }
    
    // Summary line
    AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_SUMMARY].hProperty,
                           VoiceHeaderSize(i_upbyVoiceFrame), i_upbyVoiceFrame, 0, 0, 0);

    // Check what Voice frame we are dealing with
	DVPROTOCOLMSG_FULLMESSAGE&	rVoiceFrame = *reinterpret_cast<DVPROTOCOLMSG_FULLMESSAGE*>(i_upbyVoiceFrame);

	// Message type field
	AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MESSAGETYPE].hProperty,
						   sizeof(rVoiceFrame.dvGeneric.dwType), &rVoiceFrame.dvGeneric.dwType, 0, 1, 0);

	__try
	{

		switch ( rVoiceFrame.dvGeneric.dwType )
		{
		case DVMSGID_CONNECTREQUEST:
			{
				// Major Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MAJORVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectRequest.ucVersionMajor), &rVoiceFrame.dvConnectRequest.ucVersionMajor, 0, 1, 0);

				// Minor Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MINORVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectRequest.ucVersionMinor), &rVoiceFrame.dvConnectRequest.ucVersionMinor, 0, 1, 0);

				// Build Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_BUILDVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectRequest.dwVersionBuild), &rVoiceFrame.dvConnectRequest.dwVersionBuild, 0, 1, 0);

				break;
			}

		case DVMSGID_CONNECTREFUSE:
			{
				// Result Code field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_RESULTCODE].hProperty,
									   sizeof(rVoiceFrame.dvConnectRefuse.hresResult), &rVoiceFrame.dvConnectRefuse.hresResult, 0, 1, 0);

				// Major Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MAJORVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectRefuse.ucVersionMajor), &rVoiceFrame.dvConnectRefuse.ucVersionMajor, 0, 1, 0);

				// Minor Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MINORVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectRefuse.ucVersionMinor), &rVoiceFrame.dvConnectRefuse.ucVersionMinor, 0, 1, 0);

				// Build Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_BUILDVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectRefuse.dwVersionBuild), &rVoiceFrame.dvConnectRefuse.dwVersionBuild, 0, 1, 0);

				break;
			}

		case DVMSGID_CONNECTACCEPT:
			{
				// Session Type field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_SESSIONTYPE].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.dwSessionType), &rVoiceFrame.dvConnectAccept.dwSessionType, 0, 1, 0);

				// Major Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MAJORVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.ucVersionMajor), &rVoiceFrame.dvConnectAccept.ucVersionMajor, 0, 1, 0);

				// Minor Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MINORVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.ucVersionMinor), &rVoiceFrame.dvConnectAccept.ucVersionMinor, 0, 1, 0);

				// Build Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_BUILDVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.dwVersionBuild), &rVoiceFrame.dvConnectAccept.dwVersionBuild, 0, 1, 0);

				// Session Flags summary
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_SESSIONFLAGS_SUMMARY].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.dwSessionFlags), &rVoiceFrame.dvConnectAccept.dwSessionFlags, 0, 1, 0);

				// Session Flags field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_SESSIONFLAGS].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.dwSessionFlags), &rVoiceFrame.dvConnectAccept.dwSessionFlags, 0, 2, 0);

				// Compression Type field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_COMPRESSIONTYPE].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.guidCT), &rVoiceFrame.dvConnectAccept.guidCT, 0, 1, 0);

				break;
			}

		case DVMSGID_SETTINGSCONFIRM:
			{
				// Player's Flags summary
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERFLAGS_SUMMARY].hProperty,
									   sizeof(rVoiceFrame.dvSettingsConfirm.dwFlags), &rVoiceFrame.dvSettingsConfirm.dwFlags, 0, 1, 0);

				// Client Flags field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERFLAGS].hProperty,
									   sizeof(rVoiceFrame.dvSettingsConfirm.dwFlags), &rVoiceFrame.dvSettingsConfirm.dwFlags, 0, 2, 0);

				// Host Migration Sequence Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_HOSTORDERID].hProperty,
									   sizeof(rVoiceFrame.dvSettingsConfirm.dwHostOrderID), &rVoiceFrame.dvSettingsConfirm.dwHostOrderID, 0, 1, 0);

				break;
			}

		case DVMSGID_PLAYERLIST:
			{
				// Host Order ID field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_HOSTORDERID].hProperty,
									   sizeof(rVoiceFrame.dvPlayerList.dwHostOrderID), &rVoiceFrame.dvPlayerList.dwHostOrderID, 0, 1, 0);

				// Number of Players field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_NUMBEROFPLAYERS].hProperty,
									   sizeof(rVoiceFrame.dvPlayerList.dwNumEntries), &rVoiceFrame.dvPlayerList.dwNumEntries, 0, 1, 0);


				// Player entries are following after the header
				DVPROTOCOLMSG_PLAYERLIST_ENTRY* pPlayerEntry =
					reinterpret_cast<DVPROTOCOLMSG_PLAYERLIST_ENTRY*>(&rVoiceFrame.dvPlayerList + 1);

				// Make sure the list doesn't overflow the boundaries of the frame
				DWORD dwNumEntries = rVoiceFrame.dvPlayerList.dwNumEntries;
				if ( reinterpret_cast<LPBYTE>(pPlayerEntry + dwNumEntries) - i_upbyVoiceFrame  >  static_cast<int>(i_dwBytesLeft) )
				{
					break;
				}

				// Player list summary
				AttachPropertyInstanceEx(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERLIST_SUMMARY].hProperty,
									     dwNumEntries * sizeof(*pPlayerEntry), pPlayerEntry,
									     sizeof(DWORD), &dwNumEntries,
									     0, 1, 0);

				// For every player entry in the list
				for ( int nEntry = 1; nEntry <= dwNumEntries; ++nEntry, ++pPlayerEntry )
				{
					// Player's summary
					struct
					{
						DWORD dwPlayerNum;
						DWORD dwTotalPlayer;
					}
					PlayerEntryData = { nEntry, dwNumEntries };

					AttachPropertyInstanceEx(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERSUMMARY].hProperty,
											 sizeof(*pPlayerEntry), pPlayerEntry,
											 sizeof(PlayerEntryData), &PlayerEntryData,
											 0, 2, 0);

					// Player's ID field
					AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERID].hProperty,
										   sizeof(pPlayerEntry->dvidID), &pPlayerEntry->dvidID, 0, 3, 0);

					// Player's Flags summary
					AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERFLAGS_SUMMARY].hProperty,
										   sizeof(pPlayerEntry->dwPlayerFlags), &pPlayerEntry->dwPlayerFlags, 0, 3, 0);

					// Player's Flags field
					AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERFLAGS].hProperty,
										   sizeof(pPlayerEntry->dwPlayerFlags), &pPlayerEntry->dwPlayerFlags, 0, 4, 0);

					// Host Migration Sequence Number field
					AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_HOSTORDERID].hProperty,
										   sizeof(pPlayerEntry->dwHostOrderID), &pPlayerEntry->dwHostOrderID, 0, 3, 0);
				}

				break;
			}

		case DVMSGID_SPEECH:
			{
				// Message Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MESSAGENUMBER].hProperty,
									   sizeof(rVoiceFrame.dvSpeech.bMsgNum), &rVoiceFrame.dvSpeech.bMsgNum, 0, 1, 0);

				// Sequence Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_FRAGMENTNUMBER].hProperty,
									   sizeof(rVoiceFrame.dvSpeech.bSeqNum), &rVoiceFrame.dvSpeech.bSeqNum, 0, 1, 0);

				// Audio Data
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_AUDIODATA].hProperty,
									   i_dwBytesLeft-sizeof(rVoiceFrame.dvSpeech), &rVoiceFrame.dvSpeech + 1, 0, 1, 0);

				break;
			}

		case DVMSGID_SPEECHWITHTARGET:
			{
				// Message Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MESSAGENUMBER].hProperty,
									   sizeof(rVoiceFrame.dvSpeechWithTarget.dvHeader.bMsgNum), &rVoiceFrame.dvSpeechWithTarget.dvHeader.bMsgNum, 0, 1, 0);

				// Sequence Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_FRAGMENTNUMBER].hProperty,
									   sizeof(rVoiceFrame.dvSpeechWithTarget.dvHeader.bSeqNum), &rVoiceFrame.dvSpeechWithTarget.dvHeader.bSeqNum, 0, 1, 0);

				// Number of Targets field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_NUMBEROFTARGETS].hProperty,
									   sizeof(rVoiceFrame.dvSpeechWithTarget.dwNumTargets), &rVoiceFrame.dvSpeechWithTarget.dwNumTargets, 0, 1, 0);


				// Target ID entries are following after the header
				DVID* pTargetID = reinterpret_cast<DVID*>(&rVoiceFrame.dvSpeechWithTarget + 1);

				// Make sure the list doesn't overflow the boundaries of the frame
				int nNumTargets = rVoiceFrame.dvSpeechWithTarget.dwNumTargets;
				if ( reinterpret_cast<LPBYTE>(pTargetID + nNumTargets) - i_upbyVoiceFrame  >  static_cast<int>(i_dwBytesLeft) )
				{
					break;
				}

				// For every target ID entry in the list...
				for ( ; nNumTargets; --nNumTargets, ++pTargetID )
				{
					// Target's ID field
					AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_TARGETID].hProperty,
										   sizeof(*pTargetID), pTargetID, 0, 1, 0);
				}

				// Audio Data
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_AUDIODATA].hProperty,
									   i_dwBytesLeft-sizeof(rVoiceFrame.dvSpeechWithTarget), &rVoiceFrame.dvSpeechWithTarget + 1, 0, 1, 0);
				
				break;
			}

		case DVMSGID_SPEECHWITHFROM:
			{
				// Message Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MESSAGENUMBER].hProperty,
									   sizeof(rVoiceFrame.dvSpeechWithFrom.dvHeader.bMsgNum), &rVoiceFrame.dvSpeechWithFrom.dvHeader.bMsgNum, 0, 1, 0);

				// Sequence Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_FRAGMENTNUMBER].hProperty,
									   sizeof(rVoiceFrame.dvSpeechWithFrom.dvHeader.bSeqNum), &rVoiceFrame.dvSpeechWithFrom.dvHeader.bSeqNum, 0, 1, 0);

				// Speaking Player's ID field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERID].hProperty,
									   sizeof(rVoiceFrame.dvSpeechWithFrom.dvidFrom), &rVoiceFrame.dvSpeechWithFrom.dvidFrom, 0, 1, 0);

				// Audio Data
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_AUDIODATA].hProperty,
									   i_dwBytesLeft-sizeof(rVoiceFrame.dvSpeechWithFrom),
									   &rVoiceFrame.dvSpeechWithFrom + 1, 0, 1, 0);
				
				break;
			}

		case DVMSGID_SETTARGETS:
			{
				// Number of Targets field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_NUMBEROFTARGETS].hProperty,
									   sizeof(rVoiceFrame.dvSetTarget.dwNumTargets), &rVoiceFrame.dvSetTarget.dwNumTargets, 0, 1, 0);

				break;
			}

		case DVMSGID_CREATEVOICEPLAYER:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERID].hProperty,
									   sizeof(rVoiceFrame.dvPlayerJoin.dvidID), &rVoiceFrame.dvPlayerJoin.dvidID, 0, 1, 0);

				// Player's Flags summary
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERFLAGS_SUMMARY].hProperty,
									   sizeof(rVoiceFrame.dvPlayerJoin.dwFlags), &rVoiceFrame.dvPlayerJoin.dwFlags, 0, 1, 0);

				// Player's Flags field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERFLAGS].hProperty,
									   sizeof(rVoiceFrame.dvPlayerJoin.dwFlags), &rVoiceFrame.dvPlayerJoin.dwFlags, 0, 2, 0);

				// Host Order ID field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_HOSTORDERID].hProperty,
									   sizeof(rVoiceFrame.dvPlayerJoin.dwHostOrderID), &rVoiceFrame.dvPlayerJoin.dwHostOrderID, 0, 1, 0);

				break;
			}

		case DVMSGID_DELETEVOICEPLAYER:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERID].hProperty,
									   sizeof(rVoiceFrame.dvPlayerJoin.dvidID), &rVoiceFrame.dvPlayerJoin.dvidID, 0, 1, 0);

				break;
			}

		case DVMSGID_SESSIONLOST:
			{
				// Result Code field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_RESULTCODE].hProperty,
									   sizeof(rVoiceFrame.dvSessionLost.hresReason), &rVoiceFrame.dvSessionLost.hresReason, 0, 1, 0);

				break;
			}

		case DVMSGID_DISCONNECTCONFIRM:
		case DVMSGID_DISCONNECT:
			{
				// Result Code field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_RESULTCODE].hProperty,
									   sizeof(rVoiceFrame.dvDisconnect.hresDisconnect), &rVoiceFrame.dvDisconnect.hresDisconnect, 0, 1, 0);

				break;
			}

		default:
			{
				break; // TODO:		DPF(0, "Unknown voice frame!");
			}
		}

	}
	__except ( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )
	{
    	AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_INCOMPLETEMESSAGE].hProperty,
    						i_dwBytesLeft, i_upbyVoiceFrame, 0, 1, 0);
	}
	

	return NULL;

} // VoiceAttachProperties





// DESCRIPTION: Formats the data that is diVoicelayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbCoreFrame		- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_upbyVoiceFrame.
//
DPLAYPARSER_API DWORD BHAPI VoiceFormatProperties( HFRAME          i_hFrame,
												   ULPBYTE          i_upbyMacFrame,
												   ULPBYTE          i_upbyVoiceFrame,
												   DWORD           i_dwPropertyInsts,
												   LPPROPERTYINST  i_pPropInst )
{

    // Loop through the property instances...
    while( i_dwPropertyInsts-- > 0)
    {
        // ...and call the formatter for each
        reinterpret_cast<FORMAT>(i_pPropInst->lpPropertyInfo->InstanceData)(i_pPropInst);
        ++i_pPropInst;
    }

	// TODO: MAKE SURE THIS SHOULD NOT BE TRUE
    return NMERR_SUCCESS;

} // VoiceFormatProperties




// DESCRIPTION: Notifies Network Monitor that DNET protocol parser exists.
//
// ARGUMENTS: NONE
//
// RETURNS: TRUE - success, FALSE - failure
//
bool CreateVoiceProtocol( void )
{

	// The entry points to the export functions that Network Monitor uses to operate the parser
	ENTRYPOINTS VoiceEntryPoints =
	{
		// VoiceParser Entry Points
		VoiceRegister,
		VoiceDeregister,
		VoiceRecognizeFrame,
		VoiceAttachProperties,
		VoiceFormatProperties
	};

    // The first active instance of this parser needs to register with the kernel
    g_hVoiceProtocol = CreateProtocol("DPLAYVOICE", &VoiceEntryPoints, ENTRYPOINTS_SIZE);
	
	return (g_hVoiceProtocol ? TRUE : FALSE);

} // CreateVoiceProtocol



// DESCRIPTION: Removes the DNET protocol parser from the Network Monitor's database of parsers
//
// ARGUMENTS: NONE
//
// RETURNS: NOTHING
//
void DestroyVoiceProtocol( void )
{

	DestroyProtocol(g_hVoiceProtocol);

} // DestroyVoiceProtocol
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\parsers\transportparser.hpp ===
#ifndef _TransportParser_H_
#define _TransportParser_H_

#include "DPlay8Parser.hpp"


// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hTransportProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI TransportRegister( HPROTOCOL i_hTransportProtocol );


// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hTransportProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI TransportDeregister( HPROTOCOL i_hProtocol );


// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbTransportFrame  - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbTransportFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI TransportRecognizeFrame( HFRAME        i_hFrame,
													  ULPBYTE        i_upbMacFrame,	
													  ULPBYTE        i_upbTransportFrame,
                                   					  DWORD         i_dwMacType,        
                                   					  DWORD         i_dwBytesLeft,      
                                   					  HPROTOCOL     i_hPrevProtocol,  
                                   					  DWORD         i_dwPrevProtOffset,
                                   					  LPDWORD       o_pdwProtocolStatus,
                                   					  LPHPROTOCOL   o_hNextProtocol,
													  PDWORD_PTR    io_pdwptrInstData );

// DESCRIPTION: Maps the properties that exist in a piece of recognized data to specific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbTransportFrame - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbTransportFrame.
//
DPLAYPARSER_API LPBYTE BHAPI TransportAttachProperties( HFRAME      i_hFrame,
													    ULPBYTE      i_upbMacFrame,
														ULPBYTE      i_upbTransportFrame,
														DWORD       i_dwMacType,
														DWORD       i_dwBytesLeft,
														HPROTOCOL   i_hPrevProtocol,
														DWORD       i_dwPrevProtOffset,
													    DWORD_PTR   i_dwptrInstData );


// DESCRIPTION: Formats the data that is displayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbCoreFrame		- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbTransportFrame.
//
DPLAYPARSER_API DWORD BHAPI TransportFormatProperties( HFRAME          i_hFrame,
													   ULPBYTE          i_upbMacFrame,
													   ULPBYTE          i_upbTransportFrame,
												  	   DWORD           i_dwPropertyInsts,
													   LPPROPERTYINST  i_pPropInst );


bool CreateTransportProtocol( void );
void DestroyTransportProtocol( void );

#endif // _TransportParser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\buildmode.inc ===
# buildmode.inc: included by several makefiles in the dsound directory tree
# to get the BuildMode variable.  This variable only affects debug builds;
# retail builds are identical in both modes.  BuildMode can take two values:
#
# internal:
#   DEBUG (and RDEBUG) preprocessor constants are #defined
#   DPF (and RPF) debug output messages are enabled
#   Debug messages contain file, function and line number info
#   ASSERT and BREAK macros are enabled
#   Internal heap consistency checks in dsound.dll are enabled
#
# external:
#   Only the RDEBUG preprocessor constant is #defined
#   Only RPF debug output messages are enabled
#   ASSERTs and BREAKs are enabled

# The default build mode is "external", and we only change it
# to "internal" if we determine that we're in pre-release mode.

BuildMode = external

#!if (NT build)

# FIXME: We should !include some VBL6-specific file here
# that defines PRERELEASE properly for us (bug 344974).

# In NT builds, we can key off the PRERELEASE flag:
!if defined(PRERELEASE)
!if $(PRERELEASE)
BuildMode = internal
!endif
!endif

#!else (DX build)

# In DX builds, some combination of DX_FINAL_RELEASE, FINAL and OFFICIAL
# could be used, but being careful about weekly Web releases and the like.

#!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\tools\parsers\voiceparser.hpp ===
#ifndef _VoiceParser_H_
#define _VoiceParser_H_

#include "DPlay8Parser.hpp"


// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hVoiceProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI VoiceRegister( HPROTOCOL i_hVoiceProtocol );


// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hVoiceProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI VoiceDeregister( HPROTOCOL i_hProtocol );


// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbVoiceFrame      - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbVoiceFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI VoiceRecognizeFrame( HFRAME        i_hFrame,
												  ULPBYTE        i_upbMacFrame,	
												  ULPBYTE        i_upbVoiceFrame,
                                   				  DWORD         i_dwMacType,        
                                   				  DWORD         i_dwBytesLeft,      
                                   				  HPROTOCOL     i_hPrevProtocol,  
                                   				  DWORD         i_dwPrevProtOffset,
                                   				  LPDWORD       o_pdwProtocolStatus,
                                   				  LPHPROTOCOL   o_hNextProtocol,
												  PDWORD_PTR    io_pdwptrInstData );


// DESCRIPTION: Maps the properties that exist in a piece of recognized data to Voiceecific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbVoiceFrame     - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbVoiceFrame.
//
DPLAYPARSER_API LPBYTE BHAPI VoiceAttachProperties( HFRAME      i_hFrame,
													ULPBYTE      i_upbMacFrame,
													ULPBYTE      i_upbVoiceFrame,
													DWORD       i_dwMacType,
													DWORD       i_dwBytesLeft,
													HPROTOCOL   i_hPrevProtocol,
													DWORD       i_dwPrevProtOffset,
												    DWORD_PTR   i_dwptrInstData );


// DESCRIPTION: Formats the data that is diVoicelayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbCoreFrame		- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbVoiceFrame.
//
DPLAYPARSER_API DWORD BHAPI VoiceFormatProperties( HFRAME          i_hFrame,
												   ULPBYTE          i_upbMacFrame,
												   ULPBYTE          i_upbVoiceFrame,
												   DWORD           i_dwPropertyInsts,
												   LPPROPERTYINST  i_pPropInst );

bool CreateVoiceProtocol( void );
void DestroyVoiceProtocol( void );


#endif // _VoiceParser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\aecdbgprop.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       aecdbgprop.h
 *  Content:    AEC Debug stuff
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/16/2000  dandinu Created.
 *
 ***************************************************************************/
 
//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus


#include <objbase.h>


#if !defined(_AECDMODBGPROP_)
#define _AECDMODBGPROP_

//
// IDirectSoundCaptureFXMsAecPrivate
//

DEFINE_GUID(IID_IDirectSoundCaptureFXMsAecPrivate, 0x2cf79924, 0x9ceb, 0x4482, 0x9b, 0x45, 0x1c, 0xdc, 0x23, 0x88, 0xb1, 0xf3);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXMsAecPrivate

DECLARE_INTERFACE_(IDirectSoundCaptureFXMsAecPrivate, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXMsAecPrivate methods
    //STDMETHOD(SetAllParameters)   (THIS_ LPCDSCFXMsAecPrivate pDscFxMsAecPrivate) PURE;
    STDMETHOD(GetSynchStreamFlag)   (THIS_ PBOOL) PURE;
    STDMETHOD(GetNoiseMagnitude)    (THIS_ PVOID, ULONG, PULONG) PURE;
};

#define IDirectSoundCaptureFXMsAecPrivate_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXMsAecPrivate_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXMsAecPrivate_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
//#define IDirectSoundCaptureFXMsAecPrivate_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXMsAecPrivate_GetSynchStreamFlag(p,a,)    (p)->lpVtbl->GetSynchStreamFlag(p,a)
#define IDirectSoundCaptureFXMsAecPrivate_GetNoiseMagnitude(p,a,b,c)  (p)->lpVtbl->GetNoiseMagnitude(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
//#define IDirectSoundCaptureFXMsAecPrivate_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXMsAecPrivate_GetSynchStreamFlag(p,a)     (p)->GetSynchStreamFlag(a)
#define IDirectSoundCaptureFXMsAecPrivate_GetNoiseMagnituge(p,a,b,c)  (p)->GetNoiseMagnitude(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//#ifdef __cplusplus
//};
//#endif // __cplusplus
#endif // !defined(_AECDMODBGPROP_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\aec.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       aec.cpp
 *  Content:    Acoustic Echo Cancellation DMO implementation.
 *
 ***************************************************************************/

#include <windows.h>
#include "aecp.h"
#include "kshlp.h"
#include "clone.h"
#include "ksdbgprop.h"

STD_CAPTURE_CREATE(Aec)


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::NDQueryInterface
//
STDMETHODIMP CDirectSoundCaptureAecDMO::NDQueryInterface
(
    REFIID riid,
    LPVOID *ppv
)
{
    IMP_DSDMO_QI(riid, ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundCaptureFXAec)
    {
        return GetInterface((IDirectSoundCaptureFXAec*)this, ppv);
    }
    else if (riid == IID_IDirectSoundCaptureFXMsAecPrivate)
    {
        return GetInterface((IDirectSoundCaptureFXMsAecPrivate*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
    {
        return CComBase::NDQueryInterface(riid, ppv);
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO constructor
//
CDirectSoundCaptureAecDMO::CDirectSoundCaptureAecDMO(IUnknown *pUnk, HRESULT *phr) :
    CComBase(pUnk, phr),
    m_bInitialized(FALSE),
    m_fEnable(TRUE),
    m_fNfEnable(FALSE),
    m_dwMode(DSCFX_AEC_MODE_FULL_DUPLEX),
    m_fDirty(FALSE)
{
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO destructor
//
CDirectSoundCaptureAecDMO::~CDirectSoundCaptureAecDMO()
{
}


const MP_CAPS g_AecCapsAll = 0;
static ParamInfo g_params[] =
{
//  index           type        caps            min,    max,    neutral,    unit text,  label,  pwchText??
    AECP_Enable,    MPT_BOOL,   g_AecCapsAll,   0,      1,      1,          L"",        L"",    L"",
    AECP_NoiseFill, MPT_BOOL,   g_AecCapsAll,   0,      1,      0,          L"",        L"",    L"",
    AECP_Mode,      MPT_INT,    g_AecCapsAll,   0,      1,      0,          L"",        L"",    L"",
};


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::InitOnCreation
//
HRESULT CDirectSoundCaptureAecDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof g_params / sizeof *g_params, g_params);
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::Init
//
HRESULT CDirectSoundCaptureAecDMO::Init()
{
    m_bInitialized = TRUE;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::Clone
//
STDMETHODIMP CDirectSoundCaptureAecDMO::Clone(IMediaObjectInPlace **pp)
{
    return StandardDMOClone<CDirectSoundCaptureAecDMO, DSCFXAec>(this, pp);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::Discontinuity
//
HRESULT CDirectSoundCaptureAecDMO::Discontinuity()
{
    return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::FBRProcess
//
HRESULT CDirectSoundCaptureAecDMO::FBRProcess
(
    DWORD cSamples,
    BYTE *pIn,
    BYTE *pOut
)
{
   if (!m_bInitialized)
      return DMO_E_TYPE_NOT_SET;

   return NOERROR;
}


// ==============Implementation of the private IAec interface ==========
// ==================== needed to support the property page ===============


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundCaptureAecDMO::SetAllParameters(LPCDSCFXAec pParm)
{
    if (pParm == NULL)
    {
        Trace(1, "ERROR: pParm is NULL\n");
        return E_POINTER;
    }

    HRESULT hr = SetParam(AECP_Enable, static_cast<MP_DATA>(pParm->fEnable));
    if (SUCCEEDED(hr))
    {
        m_fDirty = true;
        hr = SetParam(AECP_NoiseFill, static_cast<MP_DATA>(pParm->fNoiseFill));
    }
    if (SUCCEEDED(hr))
    {
        hr = SetParam(AECP_Mode, static_cast<MP_DATA>(pParm->dwMode));
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundCaptureAecDMO::GetAllParameters(LPDSCFXAec pParm)
{
    if (pParm == NULL)
    {
        return E_POINTER;
    }

    MP_DATA var;

    HRESULT hr = GetParam(AECP_Enable, &var);
    if (SUCCEEDED(hr))
    {
        pParm->fEnable = (BOOL)var;
        hr = GetParam(AECP_NoiseFill, &var);
    }
    if (SUCCEEDED(hr))
    {
        pParm->fNoiseFill = (BOOL)var;
        hr = GetParam(AECP_Mode, &var);
    }
    if (SUCCEEDED(hr))
    {
        pParm->dwMode = (DWORD)var;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::GetStatus
//
STDMETHODIMP CDirectSoundCaptureAecDMO::GetStatus(PDWORD pdwStatus)
{
    DWORD dwStatus;
    ULONG cBytes;
    HRESULT hr;

    if (pdwStatus == NULL)
    {
        return E_POINTER;
    }

    hr = KsGetNodeProperty
         (
             m_hPin,
             KSPROPSETID_Acoustic_Echo_Cancel,
             KSPROPERTY_AEC_STATUS,
             m_ulNodeId,
             &dwStatus,
             sizeof dwStatus,
             &cBytes
         );

    if (SUCCEEDED(hr))
    {
        *pdwStatus = dwStatus;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::Reset
//
STDMETHODIMP CDirectSoundCaptureAecDMO::Reset()
{
    return KsTopologyNodeReset(m_hPin, m_ulNodeId, true);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::SetParam
//
STDMETHODIMP CDirectSoundCaptureAecDMO::SetParam
(
    DWORD dwParamIndex,
    MP_DATA value,
    bool fSkipPasssingToParamManager
)
{
    HRESULT hr = S_OK;

    switch (dwParamIndex)
    {
        case AECP_Enable:
            if ((BOOL)value != m_fEnable)
            {
                hr = KsSetTopologyNodeEnable(m_hPin, m_ulNodeId, (BOOL)value);
                if (SUCCEEDED(hr)) m_fEnable = (BOOL)value;
            }
            break;

        case AECP_NoiseFill:
            if ((BOOL)value != m_fNfEnable)
            {
                hr = KsSetNodeProperty(m_hPin, KSPROPSETID_Acoustic_Echo_Cancel, KSPROPERTY_AEC_NOISE_FILL_ENABLE, m_ulNodeId, &value, sizeof value);
                if (SUCCEEDED(hr)) m_fNfEnable = (BOOL)value;
            }
            break;

        case AECP_Mode:
            if ((DWORD)value != m_dwMode)
            {
                hr = KsSetNodeProperty(m_hPin, KSPROPSETID_Acoustic_Echo_Cancel, KSPROPERTY_AEC_MODE, m_ulNodeId, &value, sizeof value);
                if (SUCCEEDED(hr)) m_dwMode = (DWORD)value;
            }
            break;
    }

    if (SUCCEEDED(hr))
    {
        Init();  // FIXME - temp hack (sets m_bInitialized flag)
    }

    // Let the base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're
    // calling the function internally using values that came from the base class --
    // thus there's no need to tell it values it already knows.
    return (FAILED(hr) || fSkipPasssingToParamManager) ? hr : CParamsManager::SetParam(dwParamIndex, value);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::GetParam
//
STDMETHODIMP CDirectSoundCaptureAecDMO::GetParam
(
    DWORD dwParamIndex,
    MP_DATA* value
)
{
    HRESULT hr = S_OK;
    BOOL fTemp;
    DWORD dwTemp;
    ULONG cBytes;

    switch (dwParamIndex)
    {
        case AECP_Enable:
            hr = KsGetTopologyNodeEnable(m_hPin, m_ulNodeId, &fTemp);
            if (SUCCEEDED(hr))
            {
                m_fEnable = fTemp;
                *value = (MP_DATA)fTemp;
            }
            break;

        case AECP_NoiseFill:
            hr = KsGetNodeProperty(m_hPin, KSPROPSETID_Acoustic_Echo_Cancel, KSPROPERTY_AEC_NOISE_FILL_ENABLE, m_ulNodeId, &fTemp, sizeof fTemp, &cBytes);
            if (SUCCEEDED(hr))
            {
                m_fNfEnable = fTemp;
                *value = (MP_DATA)fTemp;
            }
            break;

        case AECP_Mode:
            hr = KsGetNodeProperty(m_hPin, KSPROPSETID_Acoustic_Echo_Cancel, KSPROPERTY_AEC_MODE, m_ulNodeId, &dwTemp, sizeof dwTemp, &cBytes);
            if (SUCCEEDED(hr))
            {
                m_dwMode = dwTemp;
                *value = (MP_DATA)dwTemp;
            }
            break;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::ProcessInPlace
//
HRESULT CDirectSoundCaptureAecDMO::ProcessInPlace
(
    ULONG ulQuanta,
    LPBYTE pcbData,
    REFERENCE_TIME rtStart,
    DWORD dwFlags
)
{
    // Update parameter values from any curves that may be in effect.
    // Do this in the same order as SetAllParameters in case there are any interdependencies.

    return FBRProcess(ulQuanta, pcbData, pcbData);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::GetSynchStreamFlag
//
STDMETHODIMP
CDirectSoundCaptureAecDMO::GetSynchStreamFlag
(
    PBOOL pfSynchStreamFlag
)
{
    HRESULT hr = DS_OK;
    ULONG   cbDataReturned = 0;


    if (!pfSynchStreamFlag)
        return E_INVALIDARG;

    *pfSynchStreamFlag = 0;

    hr = KsGetNodeProperty
         (
             m_hPin,
             KSPROPSETID_DebugAecValue,
             KSPROPERTY_DEBUGAECVALUE_SYNCHSTREAM,
             m_ulNodeId,
             pfSynchStreamFlag,
             sizeof BOOL,
             &cbDataReturned
         );

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::GetNoiseMagnitude
//
STDMETHODIMP
CDirectSoundCaptureAecDMO::GetNoiseMagnitude
(
    PVOID   pvData,
    ULONG   cbData,
    PULONG  pcbDataReturned
)
{
    HRESULT hr = DS_OK;

    if ((cbData && !pvData) || !pcbDataReturned || (cbData % sizeof FLOAT))
        return E_INVALIDARG;

    *pcbDataReturned = 0;

    hr = KsGetNodeProperty
         (
             m_hPin,
             KSPROPSETID_DebugAecValue,
             KSPROPERTY_DEBUGAECARRAY_NOISEMAGNITUDE,
             m_ulNodeId,
             pvData,
             cbData,
             pcbDataReturned
         );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\aecp.h ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       aecp.h
 *  Content:    Acoustic Echo Cancellation DMO declarations.
 *
 ***************************************************************************/

#ifndef _Aecp_
#define _Aecp_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"
#include "aecdbgprop.h"

class CDirectSoundCaptureAecDMO :
    public CDirectSoundDMO,
    public CParamsManager,
    public IDirectSoundCaptureFXAec,
    public IDirectSoundCaptureFXMsAecPrivate,
    public CComBase
{
public:
    CDirectSoundCaptureAecDMO(IUnknown *pUnk, HRESULT *phr);
    ~CDirectSoundCaptureAecDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // The Init function is an override from the CPCMDMO base class and it provides initialization
    // for the effect's actual audio processing.  Note that InputType must have been set before this
    // occurs in order for this to work.
    HRESULT Init();

    STDMETHOD(Clone)                        (THIS_ IMediaObjectInPlace **);

    // IDirectSoundCaptureFXAec methods
    STDMETHOD(SetAllParameters)             (THIS_ LPCDSCFXAec);
    STDMETHOD(GetAllParameters)             (THIS_ LPDSCFXAec);
    STDMETHOD(GetStatus)                    (THIS_ PDWORD pdwStatus);
    STDMETHOD(Reset)                        (THIS);

    // IMediaParams methods
    STDMETHOD(SetParam)                     (THIS_ DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager = false);
    STDMETHOD(GetParam)                     (THIS_ DWORD dwParamIndex, MP_DATA* value);

    // All of these methods are called by the base class
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT Discontinuity();
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);

    // IDirectSoundCaptureFXMsAecPrivate methods
    //STDMETHOD(SetAllParameters)             (THIS_ LPCDSCFXMsAecPrivate);
    STDMETHOD(GetSynchStreamFlag)           (THIS_ PBOOL);
    STDMETHOD(GetNoiseMagnitude)            (THIS_ PVOID, ULONG, PULONG);

private:
    BOOL m_fDirty;
    BOOL m_bInitialized;
    BOOL m_fEnable;
    BOOL m_fNfEnable;
    DWORD m_dwMode;
};

EXT_STD_CAPTURE_CREATE(Aec);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\chorusp.h ===
//
//
//
#ifndef _CHORUSP_
#define _CHORUSP_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

#define cALLPASS		((float).61803398875)	// 1-x^2=x.
#define RVB_LP_COEF		((float).1)
#define MAXALLPASS		cALLPASS
#define DelayLineSize		(DefineDelayLineSize(40))

class CDirectSoundChorusDMO : 
    public CDirectSoundDMO, 
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXChorus,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundChorusDMO( IUnknown * pUnk, HRESULT *phr );
    ~CDirectSoundChorusDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // Note that an Init function also exists in the CPCMDMO base class and it can be overridden
    // to provide initialization for the effect's actual audio processing.
    HRESULT Init();

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);

    /* IFilter */
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXChorus);
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXChorus);

    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropChorus, pPages); }

    // IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );


    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXChorus(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXChorus(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXChorus); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);
    
    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();

    bool m_fDirty;

protected:
	HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
	
private:
// { EAX
	__forceinline void DoOneSample(int *l, int *r);

#define DECLARE_EAX_VARS(type, var) \
	type m_Eax ## var;

	DECLARE_EAX_VARS(float, Depth);

	DECLARE_EAX_VARS(float, WetLevel);			// Ratio of original and mixed.
	DECLARE_EAX_VARS(float, DepthCoef);		// Delay distance.
	DECLARE_EAX_VARS(float, LfoCoef);
	DECLARE_EAX_VARS(float, FbCoef);		// User-set feed-back coef.
	DECLARE_EAX_VARS(float, Frequency);		// User-set.
	DECLARE_EAX_VARS(float, Delay);
	DECLARE_EAX_VARS(float, DelayCoef);		// User-set chorus delay.
	DECLARE_EAX_VARS(long,  Waveform);
	DECLARE_EAX_VARS(long,  Phase);
#define m_EaxSamplesPerSec m_ulSamplingRate

	DelayBuffer2<float, DelayLineSize, 3>	m_DelayLine;

	__forceinline int Saturate(float f) {
								int i;
#ifdef DONTUSEi386
								_asm {
									fld f
									fistp i
								}
#else
								i = (int)f;
#endif 
								if (i > 32767)
									i =  32767;
								else if ( i < -32768)
									i = -32768;
								return(i);
							}


	__forceinline float Interpolate(float a, float b, float percent)
	{
		percent = a + (b - a) * percent;

		return(percent);
	}

	float			m_LfoState[2];

	DWORD			m_DelayFixedPtr;
	DWORD			m_DelayL;
	DWORD			m_DelayL1;
	DWORD			m_DelayR;
	DWORD			m_DelayR1;

// } EAX
};

EXT_STD_CREATE(Chorus);

#endif//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\agcp.h ===
//
//
//
#ifndef _Agcp_
#define _Agcp_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

class CDirectSoundCaptureAgcDMO :
    public CDirectSoundDMO,
    public CParamsManager,
    public IDirectSoundCaptureFXAgc,
    public CComBase
{
public:
    CDirectSoundCaptureAgcDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundCaptureAgcDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // The Init function is an override from the CPCMDMO base class and it provides initialization
    // for the effect's actual audio processing.  Note that InputType must have been set before this
    // occurs in order for this to work.
    HRESULT Init();

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);

    /* IFilter */
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAgc);
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAgc);

    // IMediaParams overrides
    STDMETHOD(SetParam)                     (THIS_ DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager = false);
    STDMETHOD(GetParam)                     (THIS_ DWORD dwParamIndex, MP_DATA* value);
    
    // All of these methods are called by the base class
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT Discontinuity();
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    
    BOOL m_fDirty;

private:
    BOOL m_fEnable;
    BOOL m_fReset;
    BOOL m_bInitialized;
};

EXT_STD_CAPTURE_CREATE(Agc);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\agc.cpp ===
#include <windows.h>
#include "agcp.h"
#include "kshlp.h"
#include "clone.h"

STD_CAPTURE_CREATE(Agc)

STDMETHODIMP CDirectSoundCaptureAgcDMO::NDQueryInterface
(
    REFIID riid, 
    LPVOID *ppv
)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundCaptureFXAgc)
    {
        return GetInterface((IDirectSoundCaptureFXAgc*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

CDirectSoundCaptureAgcDMO::CDirectSoundCaptureAgcDMO( IUnknown *pUnk, HRESULT *phr ) :
    CComBase( pUnk, phr ),
    m_fEnable(FALSE),
    m_fReset(FALSE),
    m_fDirty(FALSE),
    m_bInitialized(FALSE)
{
}

CDirectSoundCaptureAgcDMO::~CDirectSoundCaptureAgcDMO()
{
}

const MP_CAPS g_AgcCapsAll = 0;
static ParamInfo g_params[] =
{
//  index           type        caps           min,                        max,                        neutral,                    unit text,  label,          pwchText??
    AGCP_Enable,    MPT_BOOL,    g_AgcCapsAll,  0,                          1,                          0,                          L"",        L"",            L"",
    AGCP_Reset,     MPT_BOOL,    g_AgcCapsAll,  0,                          1,                          0,                          L"",        L"",            L""
};

HRESULT CDirectSoundCaptureAgcDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

HRESULT CDirectSoundCaptureAgcDMO::Init()
{
    m_bInitialized = TRUE;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAgcDMO::Clone
//
STDMETHODIMP CDirectSoundCaptureAgcDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundCaptureAgcDMO, DSCFXAgc>(this, pp);
}

HRESULT CDirectSoundCaptureAgcDMO::Discontinuity() {
   return NOERROR;
}

HRESULT CDirectSoundCaptureAgcDMO::FBRProcess
(
    DWORD cSamples, 
    BYTE *pIn, 
    BYTE *pOut
) 
{
   if (!m_bInitialized)
      return DMO_E_TYPE_NOT_SET;

   return NOERROR;
}

// ==============Implementation of the private IAgc interface ==========
// ==================== needed to support the property page ===============

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAgcDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundCaptureAgcDMO::SetAllParameters(LPCDSCFXAgc pParm)
{
    HRESULT hr = S_OK;
	
	// Check that the pointer is not NULL
    if (pParm == NULL)
    {
        Trace(1,"ERROR: pParm is NULL\n");
        hr = E_POINTER;
    }
    

	// Set the parameters
	if (SUCCEEDED(hr)) hr = SetParam(AGCP_Enable, static_cast<MP_DATA>(pParm->fEnable));
	if (SUCCEEDED(hr)) hr = SetParam(AGCP_Reset, static_cast<MP_DATA>(pParm->fReset));
            
    m_fDirty = true;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAgcDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundCaptureAgcDMO::GetAllParameters(LPDSCFXAgc pParm)
{
    if (pParm == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    MP_DATA var;

    GetParam(AGCP_Enable, &var);
    pParm->fEnable = (BOOL)var;
    
    GetParam(AGCP_Reset, &var);
    pParm->fReset = (BOOL)var;
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAgcDMO::SetParam
//
STDMETHODIMP CDirectSoundCaptureAgcDMO::SetParam
(
    DWORD dwParamIndex, 
    MP_DATA value, 
    bool fSkipPasssingToParamManager
)
{
    HRESULT hr = S_OK;
    BOOL fEnable = (BOOL)value;
    BOOL fReset = (BOOL)value;

    switch (dwParamIndex)
    {
    case AGCP_Enable:
        if (fEnable != m_fEnable)
        {
            hr = KsSetTopologyNodeEnable(m_hPin, m_ulNodeId, fEnable);
            if(SUCCEEDED(hr)) m_fEnable = fEnable;        
        }
        break;
    case AGCP_Reset:
        if (fReset)
        {
            hr = KsTopologyNodeReset(m_hPin, m_ulNodeId, fReset);
            if(SUCCEEDED(hr)) m_fReset = fReset;
        }
        break;
    }

    if (SUCCEEDED(hr))
    {
        Init();  // FIXME - temp hack (sets m_bInitialized flag)
    }


    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return (FAILED(hr) || fSkipPasssingToParamManager) ? hr : CParamsManager::SetParam(dwParamIndex, value);

}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAgcDMO::GetParam
//
STDMETHODIMP CDirectSoundCaptureAgcDMO::GetParam
(
    DWORD dwParamIndex, 
    MP_DATA* value
)
{
    HRESULT hr = S_OK;
    BOOL fTemp;

    switch (dwParamIndex)
    {
    case AGCP_Enable:
        hr = KsGetTopologyNodeEnable(m_hPin, m_ulNodeId, &fTemp);
        if(SUCCEEDED(hr)) 
        {
            m_fEnable = fTemp;
            *value = (MP_DATA)fTemp;
        }
        break;
    case AGCP_Reset:
        *value = (MP_DATA)m_fReset;
        break;
    }

    return hr;

}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAgcDMO::ProcessInPlace
//
HRESULT CDirectSoundCaptureAgcDMO::ProcessInPlace
(
    ULONG ulQuanta, 
    LPBYTE pcbData, 
    REFERENCE_TIME rtStart, 
    DWORD dwFlags
)
{
    // Update parameter values from any curves that may be in effect.
    // Do this in the same order as SetAllParameters in case there are any interdependencies.

    return FBRProcess(ulQuanta, pcbData, pcbData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\clone.h ===
// helper function for implementing the Clone method on DMOs

#pragma once

#include "dsdmobse.h"

template<class TypeOf_CDirectSoundDMO, class TypeOf_ParamsStruct>
HRESULT StandardDMOClone(TypeOf_CDirectSoundDMO *pThis, IMediaObjectInPlace **ppCloned);

// implementation...

// The end of StandardDMOClone is the same for all types.  Implement it outside the template
// so that the code isn't duplicated.  Copies the input and output types, does the QI for IMediaObjectInPlace,
// and returns with the correct ref count.
HRESULT StandardDMOClone_Ending(IMediaObject *pThis, IMediaObject *pCloned, IMediaObjectInPlace **ppCloned);

template<class TypeOf_CDirectSoundDMO, class TypeOf_ParamsStruct>
HRESULT StandardDMOClone(TypeOf_CDirectSoundDMO *pThis, IMediaObjectInPlace **ppCloned)
{
	if (!ppCloned)
		return E_POINTER;

    HRESULT hr = S_OK;
    TypeOf_CDirectSoundDMO *pCloned = NULL;
    IUnknown *pUnk = NULL;
    IMediaObject * pClonedMediaObject = NULL;

	try 
	{
		pCloned = new TypeOf_CDirectSoundDMO( NULL, &hr );
        if( SUCCEEDED( hr ) )
       {
            hr = pCloned->NDQueryInterface( IID_IUnknown, (void **) &pUnk );
            if( SUCCEEDED(hr ) )
            {
                hr = pUnk->QueryInterface( IID_IMediaObject, (void **) &pClonedMediaObject );
                pUnk->Release();
            }
        }
	} catch(...) {}

	if (pCloned == NULL) 
	{
		return hr;
	}

	// Copy parameter control information
	if (SUCCEEDED(hr))
		hr = pCloned->CopyParamsFromSource(pThis);

	// Copy current parameter values
	TypeOf_ParamsStruct params;
	if (SUCCEEDED(hr))
		hr = pThis->GetAllParameters(&params);
	if (SUCCEEDED(hr))
		hr = pCloned->SetAllParameters(&params);

	if (SUCCEEDED(hr))
		hr = StandardDMOClone_Ending(pThis, pClonedMediaObject, ppCloned);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include <windows.h>
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

//////////////////////////////////////////////////////////////////////
// AListItem::Remove

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
    if (pItem==NULL) 
        return this;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}


void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}


void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    Cat(Temp.GetHead());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\alist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.h
//
#ifndef __ALIST_H__
#define __ALIST_H__

class AListItem
{
public:
    AListItem() { m_pNext=NULL; };
    AListItem *GetNext() const {return m_pNext;};
    void SetNext(AListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    AListItem* Cat(AListItem* pItem);
    AListItem* AddTail(AListItem* pItem) {return Cat(pItem);};
    AListItem* Remove(AListItem* pItem);
    AListItem* GetPrev(AListItem *pItem) const;
    AListItem* GetItem(LONG index);

private:
    AListItem *m_pNext;
};

class AList
{
public:
    AList() {m_pHead=NULL;};
    AListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    AListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(AListItem *pItem,AListItem *pInsert);
    void Cat(AListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(AList *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(AListItem *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(AListItem *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(AListItem *pItem) {m_pHead=m_pHead->Remove(pItem);};
    AListItem *GetPrev(AListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    AListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    AListItem *RemoveHead(void)
        {
            AListItem *li;
            li=m_pHead;
            if(m_pHead)
                m_pHead=m_pHead->GetNext();
//            li->SetNext(NULL);
            return li;
        }
    void Reverse();

protected:
    AListItem *m_pHead;
};

#endif // __ALIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\chorus.cpp ===
#include <windows.h>
#include "chorusp.h"
#include "Debug.h"
#include "clone.h"

STD_CREATE(Chorus)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::QueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
HRESULT CDirectSoundChorusDMO::NDQueryInterface(REFIID riid, void **ppv) {

    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXChorus)
    {
        return GetInterface((IDirectSoundFXChorus*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::CDirectSoundChorusDMO
//
CDirectSoundChorusDMO::CDirectSoundChorusDMO( IUnknown *pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr ),
    m_fDirty(false)
// { EAX: put init data here if any (otherwise use Discontinuity).
// } EAX
{
    m_EaxSamplesPerSec = 22050;
    m_DelayLine.Init(0);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::Init()
//
HRESULT CDirectSoundChorusDMO::Init()
{
    DSFXChorus chorus;
    HRESULT hr;

    // Force recalc of all internal parameters
    //
    hr = GetAllParameters(&chorus);
    if (SUCCEEDED(hr)) hr = SetAllParameters(&chorus);
    
    if (SUCCEEDED(hr)) hr = m_DelayLine.Init(m_EaxSamplesPerSec);
    if (SUCCEEDED(hr)) hr = Discontinuity();
    return hr;
}

const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                        max,                        neutral,                unit text,  label,          pwchText
    CFP_Wetdrymix,  MPT_FLOAT,  g_capsAll,  DSFXCHORUS_WETDRYMIX_MIN,   DSFXCHORUS_WETDRYMIX_MAX,   50,                     L"%",       L"WetDryMix",   L"",
    CFP_Depth,      MPT_FLOAT,  g_capsAll,  DSFXCHORUS_DEPTH_MIN,       DSFXCHORUS_DEPTH_MAX,       10,                     L"",        L"Depth",       L"",
    CFP_Frequency,  MPT_FLOAT,  g_capsAll,  DSFXCHORUS_FREQUENCY_MIN,   DSFXCHORUS_FREQUENCY_MAX,   (float)1.1,             L"Hz",      L"Frequency",   L"",
    CFP_Waveform,   MPT_ENUM,   g_capsAll,  DSFXCHORUS_WAVE_TRIANGLE,   DSFXCHORUS_WAVE_SIN,        DSFXCHORUS_WAVE_SIN,    L"",        L"WaveShape",   L"Triangle,Sine",
    CFP_Phase,      MPT_INT,    g_capsAll,  DSFXCHORUS_PHASE_MIN,       DSFXCHORUS_PHASE_MAX,       3,                      L"",        L"Phase",       L"",
    CFP_Feedback,   MPT_FLOAT,  g_capsAll,  DSFXCHORUS_FEEDBACK_MIN,    DSFXCHORUS_FEEDBACK_MAX,    25,                     L"",        L"Feedback",    L"",
    CFP_Delay,      MPT_FLOAT,  g_capsAll,  DSFXCHORUS_DELAY_MIN,       DSFXCHORUS_DELAY_MAX,       16,                     L"",        L"Delay",       L"",
};

HRESULT CDirectSoundChorusDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::~CDirectSoundChorusDMO
//
CDirectSoundChorusDMO::~CDirectSoundChorusDMO() 
{
    m_DelayLine.Init(-1);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::Clone
//
STDMETHODIMP CDirectSoundChorusDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundChorusDMO, DSFXChorus>(this, pp);
}

HRESULT CDirectSoundChorusDMO::Discontinuity() 
{
    if (!m_EaxWaveform) {
        m_LfoState[0] = (float)0.0;
        m_LfoState[1] = (float)0.5;
    }
    else {
        m_LfoState[0] = (float)0.0;
        m_LfoState[1] = (float)0.99999999999;
    }

    m_DelayLine.ZeroBuffer();

    m_DelayFixedPtr = (int)m_EaxDelayCoef;
    m_DelayL        = m_DelayFixedPtr;
    m_DelayL1       = m_DelayFixedPtr;
    m_DelayR        = m_DelayFixedPtr;
    m_DelayR1       = m_DelayFixedPtr;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

static int   LMul  [5] = {  1,  1, 1, 1, -1};
static int   RMul  [5] = { -1, -1, 1, 1,  1};
static int   RPhase[5] = {  0,  1, 0, 1,  0};

__forceinline void CDirectSoundChorusDMO::DoOneSample(int *l, int *r)
{
    float inPortL, inPortR;
    float TempVar;
    float XWave[2];
//    float sinwave, coswave;
#define sinwave XWave[0]
#define coswave XWave[1]

    int    Pos0, Pos1;
    int DelayFixedPtr = m_DelayLine.Pos(m_DelayFixedPtr);

    Pos0 = m_DelayLine.Pos(0);

    TempVar  = m_DelayLine[DelayFixedPtr] * m_EaxFbCoef;

    inPortL = (float)*l;
    inPortR = (float)*r;

    m_DelayLine[Pos0] = TempVar + (inPortL + inPortR) / 2;

    if (!m_EaxWaveform) {

        m_LfoState[0] = m_LfoState[0] + m_EaxLfoCoef;

        if (m_LfoState[0] > 1) m_LfoState[0] -= 2;

        m_LfoState[1] = m_LfoState[1] + m_EaxLfoCoef;

        if (m_LfoState[1] > 1) m_LfoState[1] -= 2;

        sinwave       = (float)fabs(m_LfoState[0]);
        coswave       = (float)fabs(m_LfoState[1]);
        sinwave       = -1 + 2 * sinwave;
        coswave       = -1 + 2 * coswave;
    }
    else {
        m_LfoState[0] = m_LfoState[0] + m_EaxLfoCoef * m_LfoState[1];
        m_LfoState[1] = m_LfoState[1] - m_EaxLfoCoef * m_LfoState[0];
        sinwave       = m_LfoState[0];
        coswave       = m_LfoState[1];
    }

    Pos0 = m_DelayLine.Pos(m_DelayL);
    Pos1 = m_DelayLine.Pos(m_DelayL1);

    TempVar  = (float)(m_DelayL & FractMask);
    TempVar /= (float)FractMultiplier;

    TempVar = Interpolate(m_DelayLine[Pos0], m_DelayLine[Pos1], TempVar);
    inPortL = Interpolate(inPortL, TempVar, m_EaxWetLevel);

//    m_DelayL  = m_DelayFixedPtr + (int)(sinwave * m_EaxDepthCoef);
#if 0
    switch (m_EaxPhase) {
        case 0: 
        case 1: 
        case 2:
        case 3: m_DelayL =   (int)(sinwave * m_EaxDepthCoef); break;
        case 4: m_DelayL = - (int)(sinwave * m_EaxDepthCoef); break;
    }
#else
#ifdef DONTUSEi386
    {
    int x;
    float f = (sinwave * m_EaxDepthCoef);

    _asm {
        fld f
        fistp x
    }
    
    m_DelayL  = LMul[m_EaxPhase] * x;
    }
#else
    m_DelayL  = LMul[m_EaxPhase] * (int)(sinwave * m_EaxDepthCoef);
#endif
#endif
    m_DelayL += m_DelayFixedPtr;
    m_DelayL1 = m_DelayL + FractMultiplier;

    *l = Saturate(inPortL);

    Pos0 = m_DelayLine.Pos(m_DelayR);
    Pos1 = m_DelayLine.Pos(m_DelayR1);

    TempVar  = (float)(m_DelayR & FractMask);
    TempVar /= (float)FractMultiplier;

    TempVar = Interpolate(m_DelayLine[Pos0], m_DelayLine[Pos1], TempVar);
    inPortR = Interpolate(inPortR, TempVar, m_EaxWetLevel);

//    m_DelayR  = m_DelayFixedPtr + (int)(coswave * m_EaxDepthCoef);
#if 0
    switch (m_EaxPhase) {
        case 0: m_DelayR = - (int)(sinwave * m_EaxDepthCoef); break;
        case 1: m_DelayR = - (int)(coswave * m_EaxDepthCoef); break;
        case 3: m_DelayR =   (int)(coswave * m_EaxDepthCoef); break;
        case 2:
        case 4: m_DelayR =   (int)(sinwave * m_EaxDepthCoef); break;
    }
#else
    Pos0      = RPhase[m_EaxPhase];
#ifdef DONTUSEi386
    {
    int x;
    float f = (XWave[Pos0] * m_EaxDepthCoef);

    _asm {
        fld f
        fistp x
    }
    m_DelayR  = RMul  [m_EaxPhase] * x;
    }
#else
    m_DelayR  = RMul  [m_EaxPhase] * (int)(XWave[Pos0] * m_EaxDepthCoef);
#endif
#endif
    m_DelayR += m_DelayFixedPtr;
    m_DelayR1 = m_DelayR + FractMultiplier;

    *r = Saturate(inPortR);

    m_DelayLine.Bump();
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::FBRProcess
//
HRESULT CDirectSoundChorusDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut)
{
#define cb cSamples
#define pin pIn
#define pout pOut

    if (m_cChannels == 1) {
        if (m_b8bit) {
            for (;cb > 0; --cb) {
                int i, j;

                i = *(pin+0)-128;
                i *=256;
                j  = i;

                DoOneSample(&i, &j);
                
                i += j;
                i /= 2;
                
                i /= 256;

                *(pout+0) = (unsigned char)(i + 128);
            
                pin  += sizeof(unsigned char);
                pout += sizeof(unsigned char);
            }
        }
        else if (!m_b8bit) {
            for (;cb > 0; --cb) { // for (;cb > 0; cb -= sizeof(short)) {
                   short int *psi = (short int *)pin;
                   short int *pso = (short int *)pout;
                int i, j;

                i = *psi;
                j =  i;

                DoOneSample(&i, &j);
                
                i += j;
                i /= 2;
                
                   *pso = (short)i;
            
                pin  += sizeof(short);
                pout += sizeof(short);
            }
        }
    }
    else if (m_cChannels == 2) {
        if (m_b8bit) {
            for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(unsigned char)) {
                int i, j;

                i = *(pin+0)-128;
                j = *(pin+1)-128;

                i *=256; j *=256;

                DoOneSample(&i, &j);
                
                i /= 256; j /= 256;
                
                *(pout+0) = (unsigned char)(i + 128);
                *(pout+1) = (unsigned char)(j + 128);
            
                pin  += 2 * sizeof(unsigned char);
                pout += 2 * sizeof(unsigned char);
            }
        }
        else if (!m_b8bit) {
            for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(short)) {
                   short int *psi = (short int *)pin;
                   short int *pso = (short int *)pout;
                int i, j;

                i = *(psi+0);
                j = *(psi+1);

                DoOneSample(&i, &j);
                
                   *(pso+0) = (short)i;
                   *(pso+1) = (short)j;
            
                pin  += 2 * sizeof(short);
                pout += 2 * sizeof(short);
            }
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::ProcessInPlace
//
HRESULT CDirectSoundChorusDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    return FBRProcess(ulQuanta, pcbData, pcbData);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::SetParamInternal
//
HRESULT CDirectSoundChorusDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
    long l;

    if (!m_EaxSamplesPerSec) return DMO_E_TYPE_NOT_ACCEPTED;    // NO TYPE!

    switch (dwParamIndex)
    {
// { EAX
    case CFP_Wetdrymix :
        CHECK_PARAM(DSFXCHORUS_WETDRYMIX_MIN, DSFXCHORUS_WETDRYMIX_MAX);

        PUT_EAX_VALUE(WetLevel, value / 100);

        break;

    case CFP_Depth : {
        CHECK_PARAM(DSFXCHORUS_DEPTH_MIN, DSFXCHORUS_DEPTH_MAX);

        PUT_EAX_VALUE(Depth, value / 100);

        double midpoint = m_EaxDelay * m_EaxSamplesPerSec/1000;

        INTERPOLATE(DepthCoef, (float)((m_EaxDepth * midpoint) / 2) * FractMultiplier);
        break;
    }
    case CFP_Delay : {
        CHECK_PARAM(DSFXCHORUS_DELAY_MIN, DSFXCHORUS_DELAY_MAX);
    
        PUT_EAX_VALUE(Delay, value);

        double midpoint    = m_EaxDelay * m_EaxSamplesPerSec/1000;

        m_EaxDepthCoef = (float)(((m_EaxDepth * midpoint) / 2) * FractMultiplier);
        m_EaxDelayCoef = (float)((midpoint + 2) * FractMultiplier);

        break;
    }
    case CFP_Frequency : {
        CHECK_PARAM(DSFXCHORUS_FREQUENCY_MIN, DSFXCHORUS_FREQUENCY_MAX);

        PUT_EAX_VALUE(Frequency, value);
x:
        if (!m_EaxWaveform) {
            INTERPOLATE
                (
                LfoCoef, 
                TOFRACTION(2.0 * (m_EaxFrequency/m_EaxSamplesPerSec) * 1.0)
                );
        }
        else
        {
            INTERPOLATE
                (
                LfoCoef, 
                TOFRACTION(2.0*sin(PI*m_EaxFrequency/m_EaxSamplesPerSec))
                );
        }
        break;
    }
    case CFP_Waveform :
        CHECK_PARAM(DSFXCHORUS_WAVE_TRIANGLE, DSFXCHORUS_WAVE_SIN);

        l = m_EaxWaveform;

        PUT_EAX_VALUE(Waveform, (long)value);

        if (l != m_EaxWaveform) {
            if (!m_EaxWaveform) {
                m_LfoState[0] = (float)0.0;
                m_LfoState[1] = (float)0.5;
            }
            else {
                m_LfoState[0] = (float)0.0;
                m_LfoState[1] = (float)0.99999999999;
            }
        }
        goto x;

    case CFP_Phase :
        CHECK_PARAM(DSFXCHORUS_PHASE_MIN, DSFXCHORUS_PHASE_MAX);

        PUT_EAX_VALUE(Phase, (long)value);
        break;

    case CFP_Feedback :
        CHECK_PARAM(DSFXCHORUS_FEEDBACK_MIN,  DSFXCHORUS_FEEDBACK_MAX);

        PUT_EAX_VALUE(FbCoef, value / 100);

//        m_EaxFbCoef = TOFRACTION(m_EaxFbCoef);
        break;

// } EAX
    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundChorusDMO::SetAllParameters(LPCDSFXChorus pChorus)
{
    HRESULT hr = S_OK;
    
    // Check that the pointer is not NULL
    if (pChorus == NULL)
    {
        Trace(1,"ERROR: pChorus is NULL\n");
        hr = E_POINTER;
    }

    // Set the parameters
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Wetdrymix, pChorus->fWetDryMix);
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Depth, pChorus->fDepth);
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Frequency, pChorus->fFrequency);
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Waveform, (float)pChorus->lWaveform);
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Phase, (float)pChorus->lPhase);
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Feedback, pChorus->fFeedback);
    if (SUCCEEDED(hr)) hr = SetParam(CFP_Delay, pChorus->fDelay);

    m_fDirty = true;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundChorusDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundChorusDMO::GetAllParameters(LPDSFXChorus pChorus)
{
    HRESULT hr = S_OK;
    MP_DATA mpd;
    
    if (pChorus == NULL)
    {
        return E_POINTER;
    }
    
#define GET_PARAM(x,y) \
    if (SUCCEEDED(hr)) { \
        hr = GetParam(x, &mpd); \
        if (SUCCEEDED(hr)) pChorus->y = mpd; \
    }

#define GET_PARAM_LONG(x,y) \
    if (SUCCEEDED(hr)) { \
        hr = GetParam(x, &mpd); \
        if (SUCCEEDED(hr)) pChorus->y = (long)mpd; \
    }
    GET_PARAM(CFP_Wetdrymix, fWetDryMix);
    GET_PARAM(CFP_Delay, fDelay);
    GET_PARAM(CFP_Depth, fDepth);
    GET_PARAM(CFP_Frequency, fFrequency);
    GET_PARAM_LONG(CFP_Waveform, lWaveform);
    GET_PARAM_LONG(CFP_Phase, lPhase);
    GET_PARAM(CFP_Feedback, fFeedback);

    return hr;
}

// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundChorusDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_CHORUS;
    return NOERROR;

} // GetClassID

HRESULT CDirectSoundChorusDMO::CheckInputType(const DMO_MEDIA_TYPE *pmt) 
{
    HRESULT hr = CPCMDMO::CheckInputType(pmt);
    if (FAILED(hr)) return hr;

    WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
    if (pWave->wFormatTag      != WAVE_FORMAT_PCM ||
        (pWave->wBitsPerSample != 8 && pWave->wBitsPerSample != 16) ||
        (pWave->nChannels      != 1 && pWave->nChannels != 2)) {
        return DMO_E_TYPE_NOT_ACCEPTED;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\clone.cpp ===
#include "clone.h"

HRESULT StandardDMOClone_Ending(IMediaObject *pThis, IMediaObject *pCloned, IMediaObjectInPlace **ppCloned)
{
	HRESULT hr = S_OK;

	// Copy the input and output types
	DMO_MEDIA_TYPE mt;
	DWORD cInputStreams = 0;
	DWORD cOutputStreams = 0;
	pThis->GetStreamCount(&cInputStreams, &cOutputStreams);

	for (DWORD i = 0; i < cInputStreams && SUCCEEDED(hr); ++i)
	{
		hr = pThis->GetInputCurrentType(i, &mt);
		if (hr == DMO_E_TYPE_NOT_SET)
		{
			hr = S_OK; // great, don't need to set the cloned DMO
		}
		else if (SUCCEEDED(hr))
		{
			hr = pCloned->SetInputType(i, &mt, 0);
		}
	}

	for (i = 0; i < cOutputStreams && SUCCEEDED(hr); ++i)
	{
		hr = pThis->GetOutputCurrentType(i, &mt);
		if (hr == DMO_E_TYPE_NOT_SET)
		{
			hr = S_OK; // great, don't need to set the cloned DMO
		}
		else if (SUCCEEDED(hr))
		{
			hr = pCloned->SetOutputType(i, &mt, 0);
		}
	}

	if (SUCCEEDED(hr))
		hr = pCloned->QueryInterface(IID_IMediaObjectInPlace, (void**)ppCloned);

	// Release the object's original ref.  If clone succeeded (made it through QI) then returned pointer
	// has one ref.  If we failed, refs drop to zero, freeing the object.
	pCloned->Release();
    return hr;                               
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\common.cpp ===
#include <windows.h>
#include "dsdmo.h"

double LogNorm[32] =
{
	1, 1, 1.5, 1, 1.75, 1.4, 1.17, 1, 1.88, 1.76, 1.5, 1.36, 1.25, 1.15, 1.07,
	1, 1.94, 1.82, 1.72, 1.63, 1.55, 1.48, 1.41, 1.35, 1.29, 1.24, 1.19, 1.15,
	1.11, 1.07, 1.03, 1
};

float mylog( float finput, unsigned long maxexponent)
{
	
	unsigned long mantissa, exponent, exponentwidth ;
	long input, output, sign;

#ifdef DONTUSEi386
	_asm {
		fld finput
		fistp input
	}
#else
	input = (int)finput;
#endif

	/*
	* Separate the sign bit
	*/
	sign = input & 0x80000000L ; /* Preserve sign */            
	
	/* 
	* Separate mantissa bits from the sign and
	* complement them if original input was negative
	*/
	mantissa = sign ? -input : input;
	
	/*
	* Attempt to normalize the input to form the mantissa and
	* thereby calculate the actual exponent.
	*/
	exponent = maxexponent ;
	while( (mantissa < 0x80000000) && (exponent > 0) ) {
	   mantissa = mantissa << 1 ;
	   exponent-- ;
	}
	
	/*
	* If normalization was successful, mask off the MSB (since it
	* will be implied by a non-zero exponent) and adjust the exponent value
	*/
	if( mantissa >= 0x80000000 ) {
		mantissa = mantissa & 0x7FFFFFFF ;
	   exponent++ ;
	}
	
	/*
	* Find the width of the exponent field required to represent
	* maxeponent and assemble the sign, exponent and mantissa fields
	* based on that width.
	*/
	if( maxexponent > 15 )
	   exponentwidth = 5 ;
	else if( maxexponent > 7 )
	   exponentwidth = 4 ;
	else if( maxexponent > 3 )
	   exponentwidth = 3 ;
	else 
	   exponentwidth = 2 ;
	
if (sign == 0x80000000L) 
	output = sign  |  ~((exponent << (31-exponentwidth)) | (mantissa >> exponentwidth)) ;
else
	output = sign  |  ((exponent << (31-exponentwidth)) | (mantissa >> exponentwidth)) ;

	float	x = (float)output;

	return(x);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\compress.cpp ===
#include <windows.h>

#include "compressp.h"
#include "clone.h"

STD_CREATE(Compressor)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::QueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
STDMETHODIMP CDirectSoundCompressorDMO::NDQueryInterface(THIS_ REFIID riid, LPVOID *ppv)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXCompressor)
    {
        return GetInterface((IDirectSoundFXCompressor*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::CDirectSoundCompressorDMO
//
CDirectSoundCompressorDMO::CDirectSoundCompressorDMO( IUnknown *pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr),
    m_fDirty(false)
// { EAX: put init data here if any (otherwise use Discontinuity).
// } EAX
{
	m_EaxSamplesPerSec = 22050;
	m_LeftDelay. Init(0);
	m_RightDelay.Init(0);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::Init()
//
HRESULT CDirectSoundCompressorDMO::Init()
{
    DSFXCompressor compress;
    HRESULT hr;

    // Force recalc of all internal parameters
    //
    hr = GetAllParameters(&compress);
    if (SUCCEEDED(hr)) hr = SetAllParameters(&compress);

    if (SUCCEEDED(hr)) hr = m_LeftDelay. Init(m_EaxSamplesPerSec);
	if (SUCCEEDED(hr) && m_cChannels == 2) {
		hr = m_RightDelay.Init(m_EaxSamplesPerSec);
	}

    if (SUCCEEDED(hr)) hr = Discontinuity();
    return hr;
}

const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index                   type        caps        min,                                max,                                neutral,                unit text,  label,              pwchText
    CPFP_Gain,              MPT_FLOAT,  g_capsAll,  DSFXCOMPRESSOR_GAIN_MIN,            DSFXCOMPRESSOR_GAIN_MAX,            0,                      L"",        L"Gain",            L"",
    CPFP_Attack,            MPT_FLOAT,  g_capsAll,  DSFXCOMPRESSOR_ATTACK_MIN,          DSFXCOMPRESSOR_ATTACK_MAX,          10,                     L"",        L"Attack",          L"",
    CPFP_Release,           MPT_FLOAT,  g_capsAll,  DSFXCOMPRESSOR_RELEASE_MIN,         DSFXCOMPRESSOR_RELEASE_MAX,         200,                    L"",        L"Release",         L"",
    CPFP_Threshold,         MPT_FLOAT,  g_capsAll,  DSFXCOMPRESSOR_THRESHOLD_MIN,       DSFXCOMPRESSOR_THRESHOLD_MAX,       -20,                    L"",        L"Threshold",       L"",
    CPFP_Ratio,             MPT_FLOAT,  g_capsAll,  DSFXCOMPRESSOR_RATIO_MIN,           DSFXCOMPRESSOR_RATIO_MAX,           3,                      L"",        L"Ratio",           L"",
    CPFP_Predelay,          MPT_FLOAT,  g_capsAll,  DSFXCOMPRESSOR_PREDELAY_MIN,        DSFXCOMPRESSOR_PREDELAY_MAX,        4,                      L"",        L"Predelay",        L"",
    };

HRESULT CDirectSoundCompressorDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::~CDirectSoundCompressorDMO
//
CDirectSoundCompressorDMO::~CDirectSoundCompressorDMO() 
{
	m_LeftDelay. Init(-1);
	m_RightDelay.Init(-1);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::Clone
//
STDMETHODIMP CDirectSoundCompressorDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundCompressorDMO, DSFXCompressor>(this, pp);
}

//
//	Bump - bump the delay pointers.
//
void CDirectSoundCompressorDMO::Bump(void)
{
// EAX {
	m_LeftDelay.Bump();
	m_RightDelay.Bump();
// }
}


HRESULT CDirectSoundCompressorDMO::Discontinuity() 
{
// { EAX

	m_LeftDelay.ZeroBuffer();
	if (m_cChannels == 2) {
		m_RightDelay.ZeroBuffer();
	}

	m_Envelope = m_CompGain = 0;

// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////


float myexp( float finput, unsigned long maxexponent)
{
	
	unsigned long mantissa, exponent, exponentwidth ;
	long sign;
	long input;
	

#ifdef DONTUSEi386
	_asm {
		fld finput
		fistp input
	}
#else
	input    = (int)(finput);
#endif
	mantissa = input & 0x7FFFFFFFL ;
	sign     = input & 0x80000000L ; /* Preserve sign */            
	
	exponentwidth = 5;

	if ((0x80000000L & input) != 0) { /* Take absolute value of input */
		input = -input ;
	}
	
	/* Left-justify the mantissa and right-justify the exponent to separate */

	mantissa = input <<      exponentwidth ;
	exponent = input >> ( 31-exponentwidth ) ;
	
	/* 
	* Insert the implied '1' at the mantissa MSB if not a zero exponent and
	* adjust it.
	*/
	if( exponent != 0 ) {
		mantissa = mantissa | 0x80000000L ;
		exponent-- ;
	}
	
	mantissa = mantissa >> ( maxexponent-exponent ) ; 
	
	if( sign != 0  ) 
		  mantissa = ~mantissa ;
	
	float x = (float)mantissa;

	return(x);
} 

__forceinline void CDirectSoundCompressorDMO::DoOneSampleMono(int *l)
{
	int		Pos0, PosX;
	float	inPortL = (float)*l;
	float	outPortL;
	float	temp1, temp2;

	temp1			= inPortL;

//	left_delay[]	= temp1;

	Pos0 = m_LeftDelay.Pos(0);
	m_LeftDelay[Pos0] = temp1;

	temp1			= (float)fabs(temp1);

	// Take the log
#define LOG(x,y) mylog(x,y)
	temp1			= (float)fabs(LOG(temp1 * 0x8000,31));
	temp1                  /= 0x80000000;
	// Sidechain level meter
#ifndef MAX
#define MAX(x,y)	((x > y) ? x : y)
#endif

	m_EaxCompInputPeak	= MAX(temp1, m_EaxCompInputPeak);

	// Envelope follower

	temp2			= temp1 >= m_Envelope ? m_EaxAttackCoef : -m_EaxAttackCoef;
	temp2			= temp2 <= 0 ? m_EaxReleaseCoef : temp2;

//	m_Envelope		= temp2 : temp1 < m_Envelope;

	m_Envelope      = Interpolate(temp1, m_Envelope, temp2);

	m_CompGain		= MAX(m_Envelope, m_EaxCompThresh);

	// Log Difference between signal level and threshold level

	m_CompGain		= m_EaxCompThresh - m_CompGain;

#define cPOSFSCALE (float)0.9999999
	m_CompGain		= cPOSFSCALE + m_CompGain * m_EaxCompressionRatio;

	// Compressor gain reduction meter

#ifndef MIN
#define MIN(x,y)	((x < y) ? x : y)
#endif

#define EXP(x,y)	myexp(x,y)
	m_EaxCompGainMin= MIN(m_CompGain, m_EaxCompGainMin);
	m_CompGain		= (float)EXP(m_CompGain * 0x80000000, 31);
	m_CompGain	       /= 0x80000000;

//	outPortL		= left_point[@] * compGain;

	PosX     = m_LeftDelay.LastPos((int)m_EaxLeftPoint);
	outPortL = m_LeftDelay[PosX] * m_CompGain;

	temp1			= outPortL * m_EaxGainBiasIP;
	outPortL		= temp1 + outPortL * m_EaxGainBiasFP;

	*l = Saturate(outPortL);

	//Bump();
	m_LeftDelay.Bump();
}
__forceinline void CDirectSoundCompressorDMO::DoOneSample(int *l, int *r)
{
	int		Pos0, PosX;
	float	inPortL = (float)*l;
	float	inPortR = (float)*r;
	float	outPortL, outPortR;
	float	temp1, temp2;

	temp1			= inPortL;
	temp2			= inPortR;

//	left_delay[]	= temp1;

	Pos0 = m_LeftDelay.Pos(0);
	m_LeftDelay[Pos0] = temp1;

//	right_delay[]	= temp2;

	Pos0 = m_RightDelay.Pos(0);
	m_RightDelay[Pos0] = temp2;

	//Take the magnitude

	temp1			= (float)fabs(temp1);
	temp2			= (float)fabs(temp2);

	// Take the average 

//	temp1			= 0.5 : temp1 < temp2;

	temp1			= (temp1 + temp2) / 2;

	// Take the log
#define LOG(x,y) mylog(x,y)
	temp1			= (float)fabs(LOG(temp1 * 0x8000,31));
	temp1                  /= 0x80000000;
	// Sidechain level meter
#ifndef MAX
#define MAX(x,y)	((x > y) ? x : y)
#endif

	m_EaxCompInputPeak	= MAX(temp1, m_EaxCompInputPeak);

	// Envelope follower

	temp2			= temp1 >= m_Envelope ? m_EaxAttackCoef : -m_EaxAttackCoef;
	temp2			= temp2 <= 0 ? m_EaxReleaseCoef : temp2;

//	m_Envelope		= temp2 : temp1 < m_Envelope;

	m_Envelope      = Interpolate(temp1, m_Envelope, temp2);

	m_CompGain		= MAX(m_Envelope, m_EaxCompThresh);

	// Log Difference between signal level and threshold level

	m_CompGain		= m_EaxCompThresh - m_CompGain;

#define cPOSFSCALE (float)0.9999999
	m_CompGain		= cPOSFSCALE + m_CompGain * m_EaxCompressionRatio;

	// Compressor gain reduction meter

#ifndef MIN
#define MIN(x,y)	((x < y) ? x : y)
#endif

#define EXP(x,y)	myexp(x,y)
	m_EaxCompGainMin= MIN(m_CompGain, m_EaxCompGainMin);
	m_CompGain		= (float)EXP(m_CompGain * 0x80000000, 31);
	m_CompGain	       /= 0x80000000;

//	outPortL		= left_point[@] * compGain;

	PosX     = m_LeftDelay.LastPos((int)m_EaxLeftPoint);
	outPortL = m_LeftDelay[PosX] * m_CompGain;

//	outPortR		= right_point[@] * compGain;

	PosX     = m_RightDelay.LastPos((int)m_EaxRightPoint);
	outPortR = m_RightDelay[PosX] * m_CompGain;

	temp1			= outPortL * m_EaxGainBiasIP;
	outPortL		= temp1 + outPortL * m_EaxGainBiasFP;

	temp1			= outPortR * m_EaxGainBiasIP;
	outPortR		= temp1 + outPortR * m_EaxGainBiasFP;

	*l = Saturate(outPortL);
	*r = Saturate(outPortR);

	Bump();
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::FBRProcess
//
HRESULT CDirectSoundCompressorDMO::FBRProcess(DWORD cCompressors, BYTE *pIn, BYTE *pOut)
{
// { EAX
#define cb cCompressors
#define pin pIn
#define pout pOut

	if (m_cChannels == 1) {
		if (m_b8bit) {
			for (;cb > 0; --cb) {
				int i, j;

				i = *(pin+0)-128;
				i *=256;
//				j  = i;

				DoOneSampleMono(&i);
				
//				i += j;
//				i /= 2;
				
				i /= 256;

				*(pout+0) = (unsigned char)(i + 128);
			
				pin  += sizeof(unsigned char);
				pout += sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *psi;
//				j =  i;

				DoOneSampleMono(&i);
				
//				i += j;
//				i /= 2;
				
               	*pso = (short)i;
			
				pin  += sizeof(short);
				pout += sizeof(short);
			}
		}
	}
	else if (m_cChannels == 2) {
		if (m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(unsigned char)) {
				int i, j;

				i = *(pin+0)-128;
				j = *(pin+1)-128;

				i *=256; j *=256;

				DoOneSample(&i, &j);
				
				i /= 256; j /= 256;
				
				*(pout+0) = (unsigned char)(i + 128);
				*(pout+1) = (unsigned char)(j + 128);
			
				pin  += 2 * sizeof(unsigned char);
				pout += 2 * sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *(psi+0);
				j = *(psi+1);

				DoOneSample(&i, &j);
				
               	*(pso+0) = (short)i;
               	*(pso+1) = (short)j;
			
				pin  += 2 * sizeof(short);
				pout += 2 * sizeof(short);
			}
		}
	}
// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::ProcessInPlace
//
HRESULT CDirectSoundCompressorDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    return FBRProcess(ulQuanta, pcbData, pcbData);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::SetParam
//
// { EAX
// }

HRESULT CDirectSoundCompressorDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
	float	fVal;

	if (!m_EaxSamplesPerSec) return DMO_E_TYPE_NOT_ACCEPTED;	// NO TYPE!

    switch (dwParamIndex)
    {
// { EAX
	case CPFP_Gain : {
		CHECK_PARAM(DSFXCOMPRESSOR_GAIN_MIN, DSFXCOMPRESSOR_GAIN_MAX);

		fVal = (float)pow(10, value/20);	//Convert from dB to linear

		float _gainBiasIP, _gainBiasFP;
		double d;

		_gainBiasFP = (float)modf((double)fVal, &d);
		_gainBiasIP = (float)d;

		INTERPOLATE (GainBiasFP, TOFRACTION(_gainBiasFP));
		PUT_EAX_FVAL(GainBiasIP, TOFRACTION(_gainBiasIP));
		break;
	}
	case CPFP_Attack :
		CHECK_PARAM(DSFXCOMPRESSOR_ATTACK_MIN, DSFXCOMPRESSOR_ATTACK_MAX);

		m_EaxAttackCoef = (float)pow(10, -1/(value*m_EaxSamplesPerSec/1000));

		PUT_EAX_FVAL(AttackCoef, TOFRACTION(m_EaxAttackCoef));
		break;

	case CPFP_Release :
		CHECK_PARAM(DSFXCOMPRESSOR_RELEASE_MIN, DSFXCOMPRESSOR_RELEASE_MAX);

		m_EaxReleaseCoef = (float)pow(10, -1/(value*m_EaxSamplesPerSec/1000));
		break;

	case CPFP_Threshold : {
		CHECK_PARAM(DSFXCOMPRESSOR_THRESHOLD_MIN, DSFXCOMPRESSOR_THRESHOLD_MAX);

		fVal = (float)pow(10, value/20);	//Convert from dB to linear

		float _compThresh;
		float a, b;

		a = (float)(pow(2, 26) * log(fVal * pow(2, 31))/log(2) + pow(2, 26));
		b = (float)(pow(2, 31) - 1.0);
		_compThresh = a < b ? a : b;

		_compThresh /= (float)0x80000000;

		PUT_EAX_FVAL(CompThresh, _compThresh);
		break;
	}
	case CPFP_Ratio :
		CHECK_PARAM(DSFXCOMPRESSOR_RATIO_MIN, DSFXCOMPRESSOR_RATIO_MAX);

		m_EaxCompressionRatio = (float)(1.0 - 1.0/value);

		PUT_EAX_FVAL(CompressionRatio, TOFRACTION(m_EaxCompressionRatio));
		break;

	case CPFP_Predelay : {
		CHECK_PARAM(DSFXCOMPRESSOR_PREDELAY_MIN, DSFXCOMPRESSOR_PREDELAY_MAX);

		float _length = (float)(value * m_EaxSamplesPerSec/1000.0);

		PUT_EAX_LVAL(LeftPoint,  _length + 2);
		PUT_EAX_LVAL(RightPoint, _length + 2);
		break;
	}
	/*
	** Removed from PropertySet, Processing code left behind so we can resurrect later
	**
	case CPFP_CompMeterReset : {
		CHECK_PARAM(DSFXCOMPRESSOR_COMPMETERRESET_MIN, DSFXCOMPRESSOR_COMPMETERRESET_MAX);

		if(!value)
			break; // return E_FAIL;


		float InputPeak = m_EaxCompInputPeak;
		float GainMin   = m_EaxCompGainMin;

		PUT_EAX_FVAL(CompInputPeak, 0);
		PUT_EAX_FVAL(CompGainMin,   0.999999999);

		InputPeak =   (float)(186.0 * (InputPeak - 0.999999999)/0.999999999);
		GainMin   = - (float)(186.0 * (GainMin   - 0.999999999)/0.999999999);

		CParamsManager::SetParam(CPFP_CompMeterReset , 0);

		if (!fSkipPasssingToParamManager)
			CParamsManager::SetParam(CPFP_CompInputMeter , InputPeak);

		if (!fSkipPasssingToParamManager)
			CParamsManager::SetParam(CPFP_CompGainMeter , GainMin);

		break;
	}
	*/
	
	/*	These values can't be set, only queried.
	 */

	/*
	case CPFP_CompInputMeter :
		CHECK_PARAM(DSFXCOMPRESSOR_COMPINPUTMETER_MIN, DSFXCOMPRESSOR_COMPINPUTMETER_MAX);
		return E_FAIL;

	case CPFP_CompGainMeter :
		CHECK_PARAM(DSFXCOMPRESSOR_COMPGAINMETER_MIN, DSFXCOMPRESSOR_COMPGAINMETER_MAX);
		return E_FAIL;
// } EAX
    */
    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundCompressorDMO::SetAllParameters(LPCDSFXCompressor pComp)
{
    HRESULT hr = S_OK;
	
	// Check that the pointer is not NULL
    if (pComp == NULL)
    {
        Trace(1,"ERROR: pComp is NULL\n");
        hr = E_POINTER;
    }

	// Set the parameters
    if (SUCCEEDED(hr)) hr = SetParam(CPFP_Gain, pComp->fGain);
    if (SUCCEEDED(hr)) hr = SetParam(CPFP_Attack, pComp->fAttack);   
    if (SUCCEEDED(hr)) hr = SetParam(CPFP_Release, pComp->fRelease);
    if (SUCCEEDED(hr)) hr = SetParam(CPFP_Threshold, pComp->fThreshold);
    if (SUCCEEDED(hr)) hr = SetParam(CPFP_Ratio, pComp->fRatio);
    if (SUCCEEDED(hr)) hr = SetParam(CPFP_Predelay, pComp->fPredelay);
    
	/*	These values can only be queried, not set.  CPFP_CompMeterReset fills
	 *	the values.
	 */
//	if (SUCCEEDED(hr)) hr = SetParam(CPFP_CompInputMeter, pComp->fCompInputMeter);
//	if (SUCCEEDED(hr)) hr = SetParam(CPFP_CompGainMeter, pComp->fCompGainMeter);

    m_fDirty = true;
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCompressorDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundCompressorDMO::GetAllParameters(LPDSFXCompressor pCompressor)
{
    HRESULT hr = S_OK;
	MP_DATA mpd;

	if (pCompressor == NULL) return E_POINTER;
	
#define GET_PARAM(x,y) \
	if (SUCCEEDED(hr)) { \
		hr = GetParam(x, &mpd);	\
		if (SUCCEEDED(hr)) pCompressor->y = mpd; \
	}

    GET_PARAM(CPFP_Attack, fAttack);   
    GET_PARAM(CPFP_Release, fRelease);
    GET_PARAM(CPFP_Threshold, fThreshold);
    GET_PARAM(CPFP_Ratio, fRatio);
    GET_PARAM(CPFP_Gain, fGain);
    GET_PARAM(CPFP_Predelay, fPredelay);
    
	return hr;
}

// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundCompressorDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_COMPRESSOR;
    return NOERROR;

} // GetClassID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\distort.cpp ===
#include <windows.h>

#include "distortp.h"
#include "debug.h"
#include "clone.h"

STD_CREATE(Distortion)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortDMO::NDQueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
STDMETHODIMP CDirectSoundDistortionDMO::NDQueryInterface(THIS_ REFIID riid, LPVOID *ppv)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXDistortion)
    {
        return GetInterface((IDirectSoundFXDistortion*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::CDirectSoundDistortionDMO
//
CDirectSoundDistortionDMO::CDirectSoundDistortionDMO( IUnknown *pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr ),
    m_fDirty(false)
// { EAX: put init data here if any (otherwise use Discontinuity).
// } EAX
{
	m_EaxSamplesPerSec = 44010;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::Init()
//
HRESULT CDirectSoundDistortionDMO::Init()
{
    DSFXDistortion distort;

    // Force recalc of all internal parameters
    //
    GetAllParameters(&distort);
    SetAllParameters(&distort);

    return Discontinuity();
}

const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                                        max,                                        neutral,    unit text,  label,                      pwchText
    DFP_Gain,       MPT_FLOAT,  g_capsAll,  DSFXDISTORTION_GAIN_MIN,                    DSFXDISTORTION_GAIN_MAX,                    -18,        L"",        L"Gain",                    L"",
    DFP_Edge,       MPT_FLOAT,  g_capsAll,  DSFXDISTORTION_EDGE_MIN,                    DSFXDISTORTION_EDGE_MAX,                    15,         L"",        L"Edge",                    L"",
    DFP_LpCutoff,   MPT_FLOAT,  g_capsAll,  DSFXDISTORTION_PRELOWPASSCUTOFF_MIN,        DSFXDISTORTION_PRELOWPASSCUTOFF_MAX,        8000,       L"",        L"PreLowpassCutoff",        L"",
    DFP_EqCenter,   MPT_FLOAT,  g_capsAll,  DSFXDISTORTION_POSTEQCENTERFREQUENCY_MIN,   DSFXDISTORTION_POSTEQCENTERFREQUENCY_MAX,   2400,       L"",        L"PostEQCenterFrequency",   L"",
    DFP_EqWidth,    MPT_FLOAT,  g_capsAll,  DSFXDISTORTION_POSTEQBANDWIDTH_MIN,         DSFXDISTORTION_POSTEQBANDWIDTH_MAX,         2400,       L"",        L"PostEQBandwidth",         L"",
};

HRESULT CDirectSoundDistortionDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::~CDirectSoundDistortionDMO
//
CDirectSoundDistortionDMO::~CDirectSoundDistortionDMO() 
{
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::Clone
//
STDMETHODIMP CDirectSoundDistortionDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundDistortionDMO, DSFXDistortion>(this, pp);
}

//
//	Bump - bump the delay pointers.
//
void CDirectSoundDistortionDMO::Bump(void)
{
// EAX {
// }
}


HRESULT CDirectSoundDistortionDMO::Discontinuity() 
{
// { EAX

	m_delayL1 = m_delayL2 = m_delayR1 = m_delayR2 = 0;
	m_ls0     = m_rs0     = 0.0;


// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

__forceinline void CDirectSoundDistortionDMO::DoOneSampleMono(int *l)
{
	float	inPortL = (float)*l;
	
	float	outPortL, tempvar;

	// One-pole lowpass filter
	outPortL	= inPortL * m_EaxLpff;
	m_ls0		= outPortL + m_ls0 * m_EaxLpfb;
	////////////////////////////////////////

	////////////////////////////////////////
	// Non-linear gain
#define LOG(x,y)	mylog(x,y)
	outPortL	= (float)LOG(m_ls0 * 0x8000, m_EaxExp_range);

	outPortL 	/= 0x8000;

	////////////////////////////////////////

	////////////////////////////////////////
	// Bandpass
	outPortL	= outPortL * m_EaxInScale;
	tempvar		= outPortL - m_delayL1 * m_EaxK2;
	tempvar		= tempvar - m_delayL2 * m_EaxK1;
	m_delayL1	= m_delayL2 + tempvar * m_EaxK1;
	m_delayL2	= tempvar;
	outPortL	= tempvar;

	////////////////////////////////////////

#ifdef GOOD_CODE_GEN
	*l = Saturate(outPortL);
#else
	int i;

#ifdef i386
	_asm {
		fld outPortL
		fistp i
	}
#else
	i = (int)outPortL;
#endif 
	if (i > 32767)
		i =  32767;
	else if ( i < -32768)
		i = -32768;

	*l = i;
#endif

//	Bump();
}

//////////////////////////////////////////////////////////////////////////////

__forceinline void CDirectSoundDistortionDMO::DoOneSample(int *l, int *r)
{
	float	inPortL = (float)*l;
	float	inPortR = (float)*r;
	
	float	outPortL, outPortR, tempvar;

	// One-pole lowpass filter
	outPortL	= inPortL * m_EaxLpff;
	outPortR	= inPortR * m_EaxLpff;
	m_ls0		= outPortL + m_ls0 * m_EaxLpfb;
	m_rs0		= outPortR + m_rs0 * m_EaxLpfb;
	////////////////////////////////////////

	////////////////////////////////////////
	// Non-linear gain
#define LOG(x,y)	mylog(x,y)
	outPortL	= (float)LOG(m_ls0 * 0x8000, m_EaxExp_range);
	outPortR	= (float)LOG(m_rs0 * 0x8000, m_EaxExp_range);

	outPortL 	/= 0x8000;
	outPortR 	/= 0x8000;

	////////////////////////////////////////

	////////////////////////////////////////
	// Bandpass
	outPortL	= outPortL * m_EaxInScale;
	tempvar		= outPortL - m_delayL1 * m_EaxK2;
	tempvar		= tempvar - m_delayL2 * m_EaxK1;
	m_delayL1	= m_delayL2 + tempvar * m_EaxK1;
	m_delayL2	= tempvar;
	outPortL	= tempvar;

	outPortR	= outPortR * m_EaxInScale;
	tempvar		= outPortR - m_delayR1 * m_EaxK2;
	tempvar		= tempvar - m_delayR2 * m_EaxK1;
	m_delayR1	= m_delayR2 + tempvar * m_EaxK1;
	m_delayR2	= tempvar;
	outPortR	= tempvar;
	////////////////////////////////////////

	*l = Saturate(outPortL);
	*r = Saturate(outPortR);

//	Bump();
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::FBRProcess
//
HRESULT CDirectSoundDistortionDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut)
{
// { EAX
#define cb cSamples
#define pin pIn
#define pout pOut

	if (m_cChannels == 1) {
		if (m_b8bit) {
			for (;cb > 0; --cb) {
				int i, j;

				i = *(pin+0)-128;
				i *=256;
//				j  = i;

				DoOneSampleMono(&i);
				
//				i += j;
//				i /= 2;
				
				i /= 256;

				*(pout+0) = (unsigned char)(i + 128);
			
				pin  += sizeof(unsigned char);
				pout += sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *psi;
//				j =  i;

				DoOneSampleMono(&i);
				
//				i += j;
//				i /= 2;
				
               	*pso = (short)i;
			
				pin  += sizeof(short);
				pout += sizeof(short);
			}
		}
	}
	else if (m_cChannels == 2) {
		if (m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(unsigned char)) {
				int i, j;

				i = *(pin+0)-128;
				j = *(pin+1)-128;

				i *=256; j *=256;

				DoOneSample(&i, &j);
				
				i /= 256; j /= 256;
				
				*(pout+0) = (unsigned char)(i + 128);
				*(pout+1) = (unsigned char)(j + 128);
			
				pin  += 2 * sizeof(unsigned char);
				pout += 2 * sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *(psi+0);
				j = *(psi+1);

				DoOneSample(&i, &j);
				
               	*(pso+0) = (short)i;
               	*(pso+1) = (short)j;
			
				pin  += 2 * sizeof(short);
				pout += 2 * sizeof(short);
			}
		}
	}
// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::ProcessInPlace
//
HRESULT CDirectSoundDistortionDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    return FBRProcess(ulQuanta, pcbData, pcbData);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::SetParam
//
// { EAX
// }

HRESULT CDirectSoundDistortionDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
    HRESULT hr = S_OK;
    HRESULT hr2 = S_OK;

	//if (!m_EaxSamplesPerSec) return DMO_E_TYPE_NOT_ACCEPTED;	// NO TYPE!

    switch (dwParamIndex)
    {
// { EAX
	case DFP_Gain : {
		CHECK_PARAM(DSFXDISTORTION_GAIN_MIN, DSFXDISTORTION_GAIN_MAX);

		PUT_EAX_VALUE(Gain, value);

		m_EaxGain = (float)pow(10, m_EaxGain/20);

		INTERPOLATE(InScale, TOFRACTION(m_EaxScale*m_EaxGain));
		break;

	case DFP_Edge:
		CHECK_PARAM(DSFXDISTORTION_EDGE_MIN, DSFXDISTORTION_EDGE_MAX);

		PUT_EAX_VALUE(Edge, value);

		m_EaxEdge = (m_EaxEdge/100 * 29) + 2;

		PUT_EAX_VALUE(Exp_range, (DWORD) m_EaxEdge);

		SetParamInternal(DFP_EqCenter, m_EaxCenter, true);
		SetParamInternal(DFP_EqWidth,  m_EaxBandwidth, true);
		break;

	case DFP_LpCutoff:
		CHECK_PARAM(DSFXDISTORTION_PRELOWPASSCUTOFF_MIN, DSFXDISTORTION_PRELOWPASSCUTOFF_MAX);

		//Clamp at Fs/3;
        if (value > (MP_DATA)(m_EaxSamplesPerSec / 3))
        {
            value = (MP_DATA)(m_EaxSamplesPerSec / 3);
            hr = S_FALSE;
        }

		m_EaxLpfb = (float)sqrt((2*cos(2*PI*value/m_EaxSamplesPerSec)+3)/5);
		m_EaxLpff = (float)sqrt(1-m_EaxLpfb*m_EaxLpfb);
		break;

	case DFP_EqCenter: {
		CHECK_PARAM(DSFXDISTORTION_POSTEQCENTERFREQUENCY_MIN, DSFXDISTORTION_POSTEQCENTERFREQUENCY_MAX);

        //Clamp at Fs/3;
        if (value > (MP_DATA)(m_EaxSamplesPerSec / 3))
        {
            value = (MP_DATA)(m_EaxSamplesPerSec / 3);
            hr = S_FALSE;
        }

        PUT_EAX_VALUE(Center, value);

       

		double _k1, _k2, _omega;

		_omega = 2*PI*m_EaxBandwidth/m_EaxSamplesPerSec;
		_k1 = -cos(2*PI*value/m_EaxSamplesPerSec);
		_k2 = (1 - tan(_omega/2)) / (1 + tan(_omega/2));

		m_EaxScale = (float)(sqrt(1 - _k1*_k1) * sqrt(1 - _k2*_k2));
		m_EaxScale = (float)(m_EaxScale * LogNorm[(int)m_EaxEdge]);

		INTERPOLATE(K1,      TOFRACTION(_k1));
		INTERPOLATE(InScale, TOFRACTION(m_EaxScale*m_EaxGain));
		break;
	}
	case DFP_EqWidth: {
		CHECK_PARAM(DSFXDISTORTION_POSTEQBANDWIDTH_MIN, DSFXDISTORTION_POSTEQBANDWIDTH_MAX);

		//Clamp at Fs/3;
        if (value > (MP_DATA)(m_EaxSamplesPerSec / 3))
        {
            value = (MP_DATA)(m_EaxSamplesPerSec / 3);
            hr = S_FALSE;
        }

        PUT_EAX_VALUE(Bandwidth, value);

		double _k1, _k2, _omega;

		_omega = 2*PI*value/m_EaxSamplesPerSec;
		_k1 = (float)(-cos(2*PI*m_EaxCenter/m_EaxSamplesPerSec));
		_k2 = (float)((1 - tan(_omega/2)) / (1 + tan(_omega/2)));

		m_EaxScale = (float)(sqrt(1 - _k1*_k1) * sqrt(1 - _k2*_k2));
		m_EaxScale = (float)(m_EaxScale * LogNorm[(int)m_EaxEdge]);

		INTERPOLATE(K2,      TOFRACTION(_k2));
		INTERPOLATE(InScale, TOFRACTION(m_EaxScale*m_EaxGain));
		break;
	}
	}
// } EAX
    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.

    hr2 = fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);

    //Preserve the S_FALSE if there is one
    if (FAILED(hr2))
        hr = hr2;

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundDistortionDMO::SetAllParameters(LPCDSFXDistortion pDistort)
{
    HRESULT hr = S_OK;
    HRESULT hr2[5];

    ZeroMemory(hr2,sizeof(hr2));
	
	// Check that the pointer is not NULL
    if (pDistort == NULL)
    {
        Trace(1,"ERROR: pDistort is NULL\n");
        hr = E_POINTER;
    }

    // Set the parameters
    if (SUCCEEDED(hr)) hr = hr2[0] = SetParam(DFP_Gain, pDistort->fGain);
    if (SUCCEEDED(hr)) hr = hr2[1] = SetParam(DFP_Edge, pDistort->fEdge);   
    if (SUCCEEDED(hr)) hr = hr2[2] = SetParam(DFP_LpCutoff, pDistort->fPreLowpassCutoff);
    if (SUCCEEDED(hr)) hr = hr2[3] = SetParam(DFP_EqCenter, pDistort->fPostEQCenterFrequency);
    if (SUCCEEDED(hr)) hr = hr2[4] = SetParam(DFP_EqWidth, pDistort->fPostEQBandwidth);

    m_fDirty = true;

    // if we have any alternate success codes, grab the first one and return it.
    if(SUCCEEDED(hr))
    {
        for (int i = 0;i < 5; i++)
        {
            if (hr2[i] != S_OK)
            {
                hr = hr2[i];
                break;
            }
        }
    }
    
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDistortionDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundDistortionDMO::GetAllParameters(LPDSFXDistortion pDistort)
{
    HRESULT hr = S_OK;
	MP_DATA mpd;

	if (pDistort == NULL)
	{
		return E_POINTER;
	}
			
#define GET_PARAM(x,y) \
	if (SUCCEEDED(hr)) { \
		hr = GetParam(x, &mpd);	\
		if (SUCCEEDED(hr)) pDistort->y = mpd; \
	}

    GET_PARAM(DFP_Edge, fEdge);
    GET_PARAM(DFP_Gain, fGain);
    GET_PARAM(DFP_LpCutoff, fPreLowpassCutoff);
    GET_PARAM(DFP_EqCenter, fPostEQCenterFrequency);
    GET_PARAM(DFP_EqWidth, fPostEQBandwidth);

	return hr;
}

// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundDistortionDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_DISTORTION;
    return NOERROR;

} // GetClassID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DSDMO"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);

    // Nepotism at its finest
    DebugTrace(1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\compressp.h ===
//
//
//
#ifndef _COMPRESSP_
#define _COMPRESSP_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

#define cALLPASS    ((float).61803398875)    // 1-x^2=x.
#define RVB_LP_COEF ((float).1)
#define MAXALLPASS  cALLPASS
#define Delay_len   DefineDelayLineSize(8)

class CDirectSoundCompressorDMO : 
    public CDirectSoundDMO, 
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXCompressor,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundCompressorDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundCompressorDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();
    HRESULT Init();

    // Note that an Init function also exists in the CPCMDMO base class and it can be overridden
    // to provide initialization for the effect's actual audio processing.

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
        
    /* IFilter */
    STDMETHOD(SetAllParameters)             (THIS_ LPCDSFXCompressor);
    STDMETHOD(GetAllParameters)             (THIS_ LPDSFXCompressor);
    
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropCompressor, pPages); }

    // IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXCompressor(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXCompressor(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXCompressor); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();
    
    bool m_fDirty;

protected:
    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
        HRESULT hr = CPCMDMO::CheckInputType(pmt);
        if (FAILED(hr)) return hr;

        WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
        if (pWave->wFormatTag      != WAVE_FORMAT_PCM ||
            (pWave->wBitsPerSample != 8 && pWave->wBitsPerSample != 16) ||
            (pWave->nChannels      != 1 && pWave->nChannels != 2)) {
            return DMO_E_TYPE_NOT_ACCEPTED;
        }

        return S_OK;
       }

private:
// { EAX
    __forceinline void DoOneSample(int *l, int *r);
    __forceinline void DoOneSampleMono(int *l);

// Declare internal variables.

#define DECLARE_EAX_VARS(type, var) \
    type m_Eax ## var;


    DECLARE_EAX_VARS(float, AttackCoef);
    DECLARE_EAX_VARS(float, ReleaseCoef);
    DECLARE_EAX_VARS(float, CompThresh);
    DECLARE_EAX_VARS(float, CompressionRatio);
    DECLARE_EAX_VARS(float, GainBiasIP);
    DECLARE_EAX_VARS(float, GainBiasFP);
    DECLARE_EAX_VARS(float, CompInputPeak);
    DECLARE_EAX_VARS(float, CompGainMin);
    DECLARE_EAX_VARS(long , LeftPoint);
    DECLARE_EAX_VARS(long , RightPoint);
//    DECLARE_EAX_VARS(SamplesPerSec);

    float    m_Envelope;
    float    m_CompGain;

#define m_EaxSamplesPerSec m_ulSamplingRate

    __forceinline int Saturate(float f) {
                                int i;
#ifdef DONTUSEi386
                                _asm {
                                    fld f
                                    fistp i
                                }
#else
                                i = (int)f;
#endif 
                                if (i > 32767)
                                    i =  32767;
                                else if ( i < -32768)
                                    i = -32768;
                                return(i);
                            }


    __forceinline float Interpolate(float a, float b, float percent)
    {
        percent = a + (b - a) * percent;

        return(percent);
    }

    void Bump(void);

    DelayBuffer2<float, 200, 0> m_LeftDelay;
    DelayBuffer2<float, 200, 0> m_RightDelay;

// } EAX
};

EXT_STD_CREATE(Compressor);

#endif//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\distortp.h ===
//
//
//
#ifndef _DirectSoundSampleDMO_p_
#define _DirectSoundSampleDMO_p_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

#define cALLPASS		((float).61803398875)	// 1-x^2=x.
#define RVB_LP_COEF		((float).1)
#define MAXALLPASS		cALLPASS

class CDirectSoundDistortionDMO : 
    public CDirectSoundDMO, 
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXDistortion,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundDistortionDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundDistortionDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);
    
    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();
    
    // Init is called by the DMO base class when both input and output media
    // types have been set up.
    //
    HRESULT Init();  
  

    // Note that an Init function also exists in the CPCMDMO base class and it can be overridden
    // to provide initialization for the effect's actual audio processing.

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
        
    /* IFilter */
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXDistortion);
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXDistortion);

    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropDistortion, pPages); }

    // IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );


    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXDistortion(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXDistortion(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXDistortion); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();
    
    DWORD ParamCount();

    bool m_fDirty;

protected:
	HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
		HRESULT hr = CPCMDMO::CheckInputType(pmt);
		if (FAILED(hr)) return hr;

		WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
		if (pWave->wFormatTag      != WAVE_FORMAT_PCM ||
			(pWave->wBitsPerSample != 8 && pWave->wBitsPerSample != 16) ||
			(pWave->nChannels      != 1 && pWave->nChannels != 2)) {
			return DMO_E_TYPE_NOT_ACCEPTED;
		}

		return S_OK;
   	}

private:
// { EAX
	__forceinline void DoOneSample(int *l, int *r);
	__forceinline void DoOneSampleMono(int *l);

// Declare internal variables.

#define DECLARE_EAX_VARS(type, var) \
	type m_Eax ## var;

	DECLARE_EAX_VARS(long,  Exp_range);
	DECLARE_EAX_VARS(float, InScale);
	DECLARE_EAX_VARS(float, Lpfb);
	DECLARE_EAX_VARS(float, Lpff);
	DECLARE_EAX_VARS(float, K1);
	DECLARE_EAX_VARS(float, K2);
	DECLARE_EAX_VARS(float, Edge);
	DECLARE_EAX_VARS(float, Gain);
	DECLARE_EAX_VARS(float, Scale);
	DECLARE_EAX_VARS(float, Center);
	DECLARE_EAX_VARS(float, Bandwidth);

//	DECLARE_EAX_VARS(float, SamplesPerSec);
#define m_EaxSamplesPerSec m_ulSamplingRate

	__forceinline int Saturate(float f) {
								int i;
#ifdef DONTUSEi386
								_asm {
									fld f
									fistp i
								}
#else
								i = (int)f;
#endif 
								if (i > 32767)
									i =  32767;
								else if ( i < -32768)
									i = -32768;
								return(i);
							}


	__forceinline float Interpolate(float a, float b, float percent)
	{
		percent = a + (b - a) * percent;

		return(percent);
	}

	void Bump(void);

	float			m_ls0;
	float			m_rs0;
	float			m_delayL1;
	float			m_delayL2;
	float			m_delayR1;
	float			m_delayR2;

// } EAX
};

EXT_STD_CREATE(Distortion);

#endif//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\dllmain.cpp ===
//
// dllmain.cpp
//
// Copyright (c) 1997-2001 Microsoft Corporation
//

#pragma warning(disable:4530)

#include <objbase.h>
#include "debug.h"
#include "oledll.h"
#include "dsdmo.h"
#include "chorusp.h"
#include "compressp.h"
#include "distortp.h"
#include "echop.h"
#include "flangerp.h"
#include "parameqp.h"
#include "garglep.h"
#include "sverbp.h"
#include "map.h"
#include "aecp.h"
#include "nsp.h"
#include "agcp.h"
#include "reghlp.h"


// These are linked in
class CDirectSoundI3DL2ReverbDMO;
EXT_STD_CREATE(I3DL2Reverb);
//class CDirectSoundI3DL2SourceDMO;
//EXT_STD_CREATE(I3DL2Source);

DWORD g_amPlatform;
int g_cActiveObjects = 0;

//
// this is a temporary place holder only! the dmocom.cpp base class requires this global to be defined
// so we're putting something in it for now. Class factory templates aren't used currently, but eventually
// we should use the template structure to create all dmo objects.
//
struct CComClassTemplate g_ComClassTemplates[] =
{
    {&GUID_DSFX_STANDARD_GARGLE, CreateCDirectSoundGargleDMO}
};

int g_cComClassTemplates = 0;


#define DefineClassFactory(x)                                               \
class x ## Factory : public IClassFactory                                   \
{                                                                           \
public:                                                                     \
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);        \
    virtual STDMETHODIMP_(ULONG) AddRef();                                  \
    virtual STDMETHODIMP_(ULONG) Release();                                 \
                                                                            \
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter,            \
        const IID& iid, void** ppv);                                        \
    virtual STDMETHODIMP LockServer(BOOL bLock);                            \
                                                                            \
     x ## Factory() : m_cRef(1) {}                                          \
                                                                            \
    ~ x ## Factory() {}                                                     \
                                                                            \
private:                                                                    \
    long m_cRef;                                                            \
};                                                                          \
STDMETHODIMP x ## Factory::QueryInterface(                                  \
    const IID &iid, void **ppv)                                             \
{                                                                           \
    if(iid == IID_IUnknown || iid == IID_IClassFactory)                     \
    {                                                                       \
        *ppv = static_cast<IClassFactory*>(this);                           \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *ppv = NULL;                                                        \
        return E_NOINTERFACE;                                               \
    }                                                                       \
                                                                            \
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();                            \
                                                                            \
    return S_OK;                                                            \
}                                                                           \
STDMETHODIMP_(ULONG) x ## Factory::AddRef()                                 \
{                                                                           \
    return InterlockedIncrement(&m_cRef);                                   \
}                                                                           \
                                                                            \
STDMETHODIMP_(ULONG) x ## Factory::Release()                                \
{                                                                           \
    if(!InterlockedDecrement(&m_cRef))                                      \
    {                                                                       \
        delete this;                                                        \
        return 0;                                                           \
    }                                                                       \
                                                                            \
    return m_cRef;                                                          \
}                                                                           \
                                                                            \
STDMETHODIMP x ## Factory::CreateInstance(                                  \
    IUnknown* pUnknownOuter,  const IID& riid, void** ppv)                  \
{                                                                           \
    Trace(DM_DEBUG_STATUS, "Create " #x "\n");                              \
    if (ppv == NULL)                                                        \
    {                                                                       \
        return E_POINTER;                                                   \
    }                                                                       \
                                                                            \
    if (pUnknownOuter != NULL) {                                            \
        if (IsEqualIID(riid,IID_IUnknown) == FALSE) {                       \
            return ResultFromScode(E_NOINTERFACE);                          \
        }                                                                   \
    }                                                                       \
                                                                            \
    HRESULT hr = S_OK;                                                      \
    CComBase *p = Create ## x(pUnknownOuter, &hr);                          \
    if (SUCCEEDED(hr))                                                      \
    {                                                                       \
        p->NDAddRef();                                                      \
        hr = p->NDQueryInterface(riid, ppv);                                \
        p->NDRelease();                                                     \
    }                                                                       \
                                                                            \
    return hr;                                                              \
}                                                                           \
STDMETHODIMP x ## Factory::LockServer(BOOL bLock)                           \
{                                                                           \
    if(bLock)                                                               \
    {                                                                       \
        InterlockedIncrement(&g_cLock);                                     \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        InterlockedDecrement(&g_cLock);                                     \
    }                                                                       \
                                                                            \
    return S_OK;                                                            \
}


#define DefineDMOClassFactory(x) DefineClassFactory(CDirectSound ## x ## DMO)
#define DefineDMOCaptureClassFactory(x) DefineClassFactory(CDirectSoundCapture ## x ## DMO)

//////////////////////////////////////////////////////////////////////
// Globals
//

// Registry Info
//
#define DefineNames(x)                                                              \
TCHAR g_sz## x ##FriendlyName[]    = TEXT("DirectSound" #x "DMO");                  \
TCHAR g_sz## x ##VerIndProgID[]    = TEXT("Microsoft.DirectSound" #x "DMO");        \
TCHAR g_sz## x ##ProgID[]          = TEXT("Microsoft.DirectSound" #x "DMO.1");      \

#define DefineCaptureNames(x)                                                              \
TCHAR g_sz## x ##FriendlyName[]    = TEXT("DirectSoundCapture" #x "DMO");                  \
TCHAR g_sz## x ##VerIndProgID[]    = TEXT("Microsoft.DirectSoundCapture" #x "DMO");        \
TCHAR g_sz## x ##ProgID[]          = TEXT("Microsoft.DirectSoundCapture" #x "DMO.1");      \

DefineNames(Chorus)
DefineNames(Compressor)
DefineNames(Distortion)
DefineNames(Echo)
DefineNames(Flanger)
DefineNames(ParamEq)
DefineNames(Gargle)
DefineNames(WavesReverb)
DefineNames(I3DL2Reverb)
//DefineNames(I3DL2Source)
//DefineCaptureNames(MicArray)
DefineCaptureNames(Aec)
DefineCaptureNames(NoiseSuppress)
DefineCaptureNames(Agc)

// Dll's hModule
HMODULE g_hModule = NULL;

// Count of class factory server locks
long g_cLock = 0;

DefineDMOClassFactory(Chorus)
DefineDMOClassFactory(Compressor)
DefineDMOClassFactory(Distortion)
DefineDMOClassFactory(Echo)
DefineDMOClassFactory(Flanger)
DefineDMOClassFactory(ParamEq)
DefineDMOClassFactory(I3DL2Reverb)
//DefineDMOClassFactory(I3DL2Source)
DefineDMOClassFactory(Gargle)
DefineDMOClassFactory(WavesReverb)

// Capture FXs
//DefineDMOCaptureClassFactory(MicArray)
DefineDMOCaptureClassFactory(Aec)
DefineDMOCaptureClassFactory(NoiseSuppress)
DefineDMOCaptureClassFactory(Agc)

//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cActiveObjects || g_cLock)
    {
        return S_FALSE;
    }
    return S_OK;
}

// Hack to make these macros continue to work:
#define GUID_DSFX_STANDARD_Chorus       GUID_DSFX_STANDARD_CHORUS
#define GUID_DSFX_STANDARD_Compressor   GUID_DSFX_STANDARD_COMPRESSOR
#define GUID_DSFX_STANDARD_Distortion   GUID_DSFX_STANDARD_DISTORTION
#define GUID_DSFX_STANDARD_Echo         GUID_DSFX_STANDARD_ECHO
#define GUID_DSFX_STANDARD_Flanger      GUID_DSFX_STANDARD_FLANGER
#define GUID_DSFX_STANDARD_ParamEq      GUID_DSFX_STANDARD_PARAMEQ
#define GUID_DSFX_STANDARD_Gargle       GUID_DSFX_STANDARD_GARGLE
#define GUID_DSFX_STANDARD_WavesReverb  GUID_DSFX_WAVES_REVERB
#define GUID_DSFX_STANDARD_I3DL2Reverb  GUID_DSFX_STANDARD_I3DL2REVERB
#define GUID_DSFX_STANDARD_I3DL2Source  GUID_DSFX_STANDARD_I3DL2SOURCE

// Capture
#define GUID_DSCFX_MS_Aec               GUID_DSCFX_MS_AEC
#define GUID_DSCFX_MS_NoiseSuppress     GUID_DSCFX_MS_NS
#define GUID_DSCFX_MS_Agc               GUID_DSCFX_MS_AGC

#define GUID_DSCFX_SYSTEM_MicArray      GUID_DSCFX_SYSTEM_MA
#define GUID_DSCFX_SYSTEM_Aec           GUID_DSCFX_SYSTEM_AEC
#define GUID_DSCFX_SYSTEM_NoiseSuppress GUID_DSCFX_SYSTEM_NS
#define GUID_DSCFX_SYSTEM_Agc           GUID_DSCFX_SYSTEM_AGC

#define GetClassObjectCase(x,t) \
    if (clsid == x) { \
        p = static_cast<IUnknown*> ((IClassFactory*) (new t)); \
    } else

#define GetClassObjectCaseEnd \
    { return CLASS_E_CLASSNOTAVAILABLE; }

#define GetClassObjectCaseFX(x) \
    GetClassObjectCase(GUID_DSFX_STANDARD_ ## x, CDirectSound ## x ## DMOFactory)

#define GetClassObjectCaseCaptureFX(w,x) \
    GetClassObjectCase(GUID_DSCFX_## w ##_ ## x, CDirectSoundCapture ## x ## DMOFactory)

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    if (ppv == NULL)
    {
        return E_POINTER;
    }

    IUnknown* p = NULL;

    // Render FX
    GetClassObjectCaseFX(Chorus)
    GetClassObjectCaseFX(Compressor)
    GetClassObjectCaseFX(Distortion)
    GetClassObjectCaseFX(Echo)
    GetClassObjectCaseFX(Flanger)
    GetClassObjectCaseFX(ParamEq)
    GetClassObjectCaseFX(I3DL2Reverb)
//    GetClassObjectCaseFX(I3DL2Source)
    GetClassObjectCaseFX(Gargle)
    GetClassObjectCaseFX(WavesReverb)

    // Capture FX
    GetClassObjectCaseCaptureFX(MS, Aec)
    GetClassObjectCaseCaptureFX(MS, NoiseSuppress)
    GetClassObjectCaseCaptureFX(MS, Agc)

//    GetClassObjectCaseCaptureFX(SYSTEM, MicArray)
    GetClassObjectCaseCaptureFX(SYSTEM, Aec)
    GetClassObjectCaseCaptureFX(SYSTEM, NoiseSuppress)
    GetClassObjectCaseCaptureFX(SYSTEM, Agc)


    GetClassObjectCaseEnd

    if(!p)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = p->QueryInterface(iid, ppv);
    p->Release();

    return hr;
}

#define DoUnregister(x)                                                 \
         UnregisterServer(GUID_DSFX_STANDARD_ ## x,                     \
                          g_sz ## x ## FriendlyName,                    \
                          g_sz ## x ## VerIndProgID,                    \
                          g_sz ## x ## ProgID)

#define DoRegister(x)                                                   \
         RegisterServer(g_hModule,                                      \
                        GUID_DSFX_STANDARD_ ## x,                       \
                        g_sz ## x ## FriendlyName,                      \
                        g_sz ## x ## VerIndProgID,                      \
                        g_sz ## x ## ProgID)

#define DoDMORegister(x)                                                \
         DMORegister(L#x,                                               \
         GUID_DSFX_STANDARD_ ## x,                                      \
         DMOCATEGORY_AUDIO_EFFECT,                                      \
         0, 1, &mt, 1, &mt)

#define DoDMOUnregister(x)                                              \
         DMOUnregister(GUID_DSFX_STANDARD_ ## x,                        \
         DMOCATEGORY_AUDIO_EFFECT)

#define Unregister(x)                                                   \
    if (SUCCEEDED(hr)) hr = DoDMOUnregister(x);                         \
    if (SUCCEEDED(hr)) hr = DoUnregister(x);

#define Register(x)                                                     \
    if (SUCCEEDED(hr)) hr = DoRegister(x);                              \
    if (SUCCEEDED(hr)) hr = DoDMORegister(x);

// Capture Defines
#define DoCaptureUnregister(w,x)                                        \
         UnregisterServer(GUID_DSCFX_## w ##_ ## x,                     \
                          g_sz ## x ## FriendlyName,                    \
                          g_sz ## x ## VerIndProgID,                    \
                          g_sz ## x ## ProgID)

#define DoCaptureRegister(w,x)                                          \
         RegisterServer(g_hModule,                                      \
                        GUID_DSCFX_## w ##_ ## x,                       \
                        g_sz ## x ## FriendlyName,                      \
                        g_sz ## x ## VerIndProgID,                      \
                        g_sz ## x ## ProgID)

#define DoDMOCaptureRegister(t,w,x,y)                                       \
         DMORegister(L#t,                                               \
         GUID_DSCFX_## w ##_ ## x,                                      \
         y,                                      \
         0, 1, &mt, 1, &mt)

#define DoDMOCaptureRegisterCpuResources(w,x,z)                       \
         DMORegisterCpuResources(                                              \
         GUID_DSCFX_## w ##_ ## x,                                      \
         z)

#define DoDMOCaptureUnregister(w,x,y)                                     \
         DMOUnregister(GUID_DSCFX_## w ##_ ## x,                        \
         y)

#define CaptureUnregister(w,x,y)                                          \
    if (SUCCEEDED(hr)) hr = DoDMOCaptureUnregister(w,x,y);                \
    if (SUCCEEDED(hr)) hr = DoCaptureUnregister(w,x);

#define CaptureRegister(t,w,x,y,z)                                            \
    if (SUCCEEDED(hr)) hr = DoCaptureRegister(w,x);                     \
    if (SUCCEEDED(hr)) hr = DoDMOCaptureRegister(t,w,x,y);              \
    if (SUCCEEDED(hr)) hr = DoDMOCaptureRegisterCpuResources(w,x,z);


//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    HRESULT hr = S_OK;

    Unregister(Chorus);
    Unregister(Compressor);
    Unregister(Distortion);
    Unregister(Echo);
    Unregister(Flanger);
    Unregister(ParamEq);
    Unregister(I3DL2Reverb);
//    Unregister(I3DL2Source);
    Unregister(Gargle);
    Unregister(WavesReverb);

    // Capture FXs
    CaptureUnregister(MS,Aec,DMOCATEGORY_ACOUSTIC_ECHO_CANCEL);
    CaptureUnregister(MS,NoiseSuppress,DMOCATEGORY_AUDIO_NOISE_SUPPRESS);
    CaptureUnregister(MS,Agc,DMOCATEGORY_AGC);

//    CaptureUnregister(SYSTEM,MicArray,DMOCATEGORY_MICROPHONE_ARRAY_PROCESSOR);
    CaptureUnregister(SYSTEM,Aec,DMOCATEGORY_ACOUSTIC_ECHO_CANCEL);
    CaptureUnregister(SYSTEM,NoiseSuppress,DMOCATEGORY_AUDIO_NOISE_SUPPRESS);
    CaptureUnregister(SYSTEM,Agc,DMOCATEGORY_AGC);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
    HRESULT hr = S_OK;

    DMO_PARTIAL_MEDIATYPE mt;
    mt.type = MEDIATYPE_Audio;
    mt.subtype = MEDIASUBTYPE_PCM;

    Register(Chorus);
    Register(Compressor);
    Register(Distortion);
    Register(Echo);
    Register(Flanger);
    Register(ParamEq);
    Register(I3DL2Reverb);
//    Register(I3DL2Source);
    Register(Gargle);
    Register(WavesReverb);

    // Capture FXs
    CaptureRegister(Microsoft AEC,MS,Aec,DMOCATEGORY_ACOUSTIC_ECHO_CANCEL,DS_SYSTEM_RESOURCES_ALL_HOST_RESOURCES);
    CaptureRegister(Microsoft Noise Suppression,MS,NoiseSuppress,DMOCATEGORY_AUDIO_NOISE_SUPPRESS,DS_SYSTEM_RESOURCES_ALL_HOST_RESOURCES);
    CaptureRegister(Microsoft AGC,MS,Agc,DMOCATEGORY_AGC,DS_SYSTEM_RESOURCES_ALL_HOST_RESOURCES);

//    CaptureRegister(System Microphone Array,SYSTEM,MicArray,DMOCATEGORY_MICROPHONE_ARRAY_PROCESSOR,DS_SYSTEM_RESOURCES_UNDEFINED);
    CaptureRegister(System AEC,SYSTEM,Aec,DMOCATEGORY_ACOUSTIC_ECHO_CANCEL,DS_SYSTEM_RESOURCES_UNDEFINED);
    CaptureRegister(System Noise Suppression,SYSTEM,NoiseSuppress,DMOCATEGORY_AUDIO_NOISE_SUPPRESS,DS_SYSTEM_RESOURCES_UNDEFINED);
    CaptureRegister(System AGC,SYSTEM,Agc,DMOCATEGORY_AGC,DS_SYSTEM_RESOURCES_UNDEFINED);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
#ifdef DBG
    if(dwReason < nReasons)
    {
        Trace(DM_DEBUG_STATUS, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        Trace(DM_DEBUG_STATUS, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if(++g_cActiveObjects == 1)
            {
            #ifdef DBG
                DebugInit();
            #endif

                if(!DisableThreadLibraryCalls(hModule))
                {
                    Trace(DM_DEBUG_STATUS, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;

                g_amPlatform = VER_PLATFORM_WIN32_WINDOWS; // win95 assumed in case GetVersionEx fails

                OSVERSIONINFO osInfo;
                osInfo.dwOSVersionInfoSize = sizeof(osInfo);
                if (GetVersionEx(&osInfo))
                {
                    g_amPlatform = osInfo.dwPlatformId;
                }
            }
            break;

        case DLL_PROCESS_DETACH:
            if(--g_cActiveObjects == 0)
            {
                Trace(DM_DEBUG_STATUS, "Unloading\n");
            }
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\dmocom.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for creating COM objects, December 1994

#include "dmocom.h"
#include <crtdbg.h>


#pragma warning( disable : 4514 )   // Disable warnings re unused inline functions



/* Constructor */

// We know we use "this" in the initialization list, we also know we don't modify *phr.
#pragma warning( disable : 4355 4100 )
CComBase::CComBase(IUnknown* pUnk)
: 
/* Start the object with a reference count of zero - when the      */
/* object is queried for it's first interface this may be          */
/* incremented depending on whether or not this object is          */
/* currently being aggregated upon                                 */
  m_cRef(0)
/* Set our pointer to our IUnknown interface.                      */
/* If we have an outer, use its, otherwise use ours.               */
/* This pointer effectivly points to the owner of                  */
/* this object and can be accessed by the GetOwner() method.       */
, m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<IUnknown*>( static_cast<INDUnknown*>(this) ) )
 /* Why the double cast?  Well, the inner cast is a type-safe cast */
 /* to pointer to a type from which we inherit.  The second is     */
 /* type-unsafe but works because INDUnknown "behaves   */
 /* like" IUnknown. (Only the names on the methods change.)        */
{
    // Everything we need to do has been done in the initializer list
}

// This does the same as above except it has a useless HRESULT argument
// use the previous constructor, this is just left for compatibility...
CComBase::CComBase(IUnknown* pUnk,HRESULT *phr) :
    m_cRef(0),
    m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<IUnknown*>( static_cast<INDUnknown*>(this) ) )
{
}

#pragma warning( default : 4355 4100 )

/* QueryInterface */

STDMETHODIMP CComBase::NDQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);
    //ValidateReadWritePtr(ppv,sizeof(PVOID));

    /* We know only about IUnknown */

    if (riid == IID_IUnknown) {
        GetInterface((IUnknown*) (INDUnknown*) this, ppv);
        return NOERROR;
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

/* We have to ensure that we DON'T use a max macro, since these will typically   */
/* lead to one of the parameters being evaluated twice.  Since we are worried    */
/* about concurrency, we can't afford to access the m_cRef twice since we can't  */
/* afford to run the risk that its value having changed between accesses.        */
#ifdef max
    #undef max
#endif

template<class T> inline static T max( const T & a, const T & b )
{
    return a > b ? a : b;
}

/* AddRef */

STDMETHODIMP_(ULONG) CComBase::NDAddRef()
{
    LONG lRef = InterlockedIncrement( &m_cRef );
    _ASSERTE(lRef > 0);
/*
    DbgLog((LOG_MEMORY,3,TEXT("    Obj %d ref++ = %d"),
           m_dwCookie, m_cRef));
*/
    return max(ULONG(m_cRef), 1ul);
}


/* Release */

STDMETHODIMP_(ULONG) CComBase::NDRelease()
{
    /* If the reference count drops to zero delete ourselves */

    LONG lRef = InterlockedDecrement( &m_cRef );
    _ASSERTE(lRef >= 0);

/*
    DbgLog((LOG_MEMORY,3,TEXT("    Object %d ref-- = %d"),
	    m_dwCookie, m_cRef));
*/
    if (lRef == 0) {

        // COM rules say we must protect against re-entrancy.
        // If we are an aggregator and we hold our own interfaces
        // on the aggregatee, the QI for these interfaces will
        // addref ourselves. So after doing the QI we must release
        // a ref count on ourselves. Then, before releasing the
        // private interface, we must addref ourselves. When we do
        // this from the destructor here it will result in the ref
        // count going to 1 and then back to 0 causing us to
        // re-enter the destructor. Hence we add an extra refcount here
        // once we know we will delete the object.
        // for an example aggregator see filgraph\distrib.cpp.

        m_cRef++;

        delete this;
        return ULONG(0);
    } else {
        return max(ULONG(m_cRef), 1ul);
    }
}


/* Return an interface pointer to a requesting client
   performing a thread safe AddRef as necessary */

STDAPI GetInterface(IUnknown* pUnk, void **ppv)
{
    CheckPointer(ppv, E_POINTER);
    *ppv = pUnk;
    pUnk->AddRef();
    return NOERROR;
}


/* Compares two interfaces and returns TRUE if they are on the same object */

BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond)
{
    /*  Different objects can't have the same interface pointer for
        any interface
    */
    if (pFirst == pSecond) {
        return TRUE;
    }
    /*  OK - do it the hard way - check if they have the same
        IUnknown pointers - a single object can only have one of these
    */
    IUnknown* pUnknown1;     // Retrieve the IUnknown interface
    IUnknown* pUnknown2;     // Retrieve the other IUnknown interface
    HRESULT hr;              // General OLE return code

    _ASSERTE(pFirst);
    _ASSERTE(pSecond);

    /* See if the IUnknown pointers match */

    hr = pFirst->QueryInterface(IID_IUnknown,(void **) &pUnknown1);
    _ASSERTE(SUCCEEDED(hr));
    _ASSERTE(pUnknown1);

    hr = pSecond->QueryInterface(IID_IUnknown,(void **) &pUnknown2);
    _ASSERTE(SUCCEEDED(hr));
    _ASSERTE(pUnknown2);

    /* Release the extra interfaces we hold */

    pUnknown1->Release();
    pUnknown2->Release();
    return (pUnknown1 == pUnknown2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\dmoutils.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __DMOUTILS_H__
#define __DMOUTILS_H__

#include <wchar.h>

// convert guid to string
STDAPI_(void) DMOGuidToStrA(char *szStr, REFGUID guid);
STDAPI_(void) DMOGuidToStrW(WCHAR *szStr, REFGUID guid);

// convert string to guid
STDAPI_(BOOL) DMOStrToGuidA(char *szStr, GUID *pguid);
STDAPI_(BOOL) DMOStrToGuidW(WCHAR *szStr, GUID *pguid);

#ifdef UNICODE
#define DMOStrToGuid DMOStrToGuidW
#define DMOGuidToStr DMOGuidToStrW
#else
#define DMOStrToGuid DMOStrToGuidA
#define DMOGuidToStr DMOGuidToStrA
#endif

#endif __DMOUTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\dmoutils.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <windows.h>
#include <stdio.h>
#include "dmoutils.h"

// convert guid to string
void DMOGuidToStrA(char *szStr, REFGUID guid) {
   sprintf(szStr, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
           guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1],
           guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5],
           guid.Data4[6], guid.Data4[7]);
}
void DMOGuidToStrW(WCHAR *szStr, REFGUID guid) {
   swprintf(szStr, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
           guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1],
           guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5],
           guid.Data4[6], guid.Data4[7]);
}

// convert string to guid
BOOL DMOStrToGuidA(char *szStr, GUID *pguid) {
   DWORD temp[8];
   if (sscanf(szStr, "%08x-%04hx-%04hx-%02x%02x-%02x%02x%02x%02x%02x%02x",
           &pguid->Data1, &pguid->Data2, &pguid->Data3,
           &temp[0], &temp[1], &temp[2], &temp[3],
           &temp[4], &temp[5], &temp[6], &temp[7]) == 11) {
      for (DWORD c = 0; c < 8; c++)
         pguid->Data4[c] = (unsigned char)temp[c];
      return TRUE;
   }
   else
      return FALSE;
}
BOOL DMOStrToGuidW(WCHAR *szStr, GUID *pguid) {
   char szSrc[80];
   WideCharToMultiByte(0,0,szStr,-1,szSrc,80,NULL,NULL);
   return DMOStrToGuidA(szSrc, pguid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\dmocom.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for creating COM objects, December 1994

/*

a. Derive your COM object from CComBase

b. Make a static CreateInstance function that takes an IUnknown* and an
   HRESULT*. The IUnknown* defines the object to delegate IUnknown calls
   to. The HRESULT * allows error codes to be passed around constructors.

   It is important that constructors only change the HRESULT * if they have
   to set an ERROR code, if it was successful then leave it alone or you may
   overwrite an error code from an object previously created.

c. Have a constructor for your object that passes the IUnknown* and HRESULT*
   to the CComBase constructor. You can set the HRESULT if you have an error,
   or just simply pass it through to the constructor.

   The object creation will fail in the class factory if the HRESULT indicates
   an error (ie FAILED(HRESULT) == TRUE)

d. Create a CComClassTemplate with your object's class id and CreateInstance
   function.

Then (for each interface) either

Multiple inheritance

1. Also derive it from ISomeInterface
2. Include DECLARE_IUNKNOWN in your class definition to declare
   implementations of QueryInterface, AddRef and Release that
   call the outer unknown
3. Override NDQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CComBase::NDQueryInterface(riid, ppv);
     }

4. Declare and implement the member functions of ISomeInterface.

or: Nested interfaces

1. Declare a class derived from CComBase
2. Include DECLARE_IUNKNOWN in your class definition
3. Override NDQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CComBase::NDQueryInterface(riid, ppv);
     }

4. Implement the member functions of ISomeInterface. Use \() to
   access the COM object class.

And in your COM object class:

5. Make the nested class a friend of the COM object class, and declare
   an instance of the nested class as a member of the COM object class.

   NOTE that because you must always pass the outer unknown and an hResult
   to the CComBase constructor you cannot use a default constructor, in
   other words you will have to make the member variable a pointer to the
   class and make a NEW call in your constructor to actually create it.

6. override the NDQueryInterface with code like this:

     if (riid == IID_ISomeInterface) {
         return m_pImplFilter->
            NDQueryInterface(IID_ISomeInterface, ppv);
     } else {
         return CComBase::NDQueryInterface(riid, ppv);
     }

You can have mixed classes which support some interfaces via multiple
inheritance and some via nested classes

*/

#ifndef __COMBASE__
#define __COMBASE__

#include <windows.h>
#include <basetyps.h>
#include <unknwn.h>

extern int g_cActiveObjects;

STDAPI CreateCLSIDRegKey(REFCLSID clsid, const char *szName);

STDAPI RemoveCLSIDRegKey(REFCLSID clsid);

#ifdef DEBUG
    // We chose a common name for our ASSERT macro, MFC also uses this name
    // So long as the implementation evaluates the condition and handles it
    // then we will be ok. Rather than override the behaviour expected we
    // will leave whatever first defines ASSERT as the handler (i.e. MFC)
    #ifndef ASSERT
        #define ASSERT(_x_) if (!(_x_))         \
            DebugAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)
    #endif
    #define EXECUTE_ASSERT(_x_) ASSERT(_x_)

    #define ValidateReadPtr(p,cb) \
        {if(IsBadReadPtr((PVOID)p,cb) == TRUE) \
            DebugBreak("Invalid read pointer");}

    #define ValidateWritePtr(p,cb) \
        {if(IsBadWritePtr((PVOID)p,cb) == TRUE) \
            DebugBreak("Invalid write pointer");}

    #define ValidateReadWritePtr(p,cb) \
        {ValidateReadPtr(p,cb) ValidateWritePtr(p,cb)}
#else
    #ifndef ASSERT
       #define ASSERT(_x_) ((void)0)
    #endif
    #define EXECUTE_ASSERT(_x_) ((void)(_x_))

    #define ValidateReadPtr(p,cb) 0
    #define ValidateWritePtr(p,cb) 0
    #define ValidateReadWritePtr(p,cb) 0
#endif

/* The DLLENTRY module initialises the module handle on loading */

extern HINSTANCE g_hInst;

/* On DLL load remember which platform we are running on */

/* Version of IUnknown that is renamed to allow a class to support both
   non delegating and delegating IUnknowns in the same COM object */

#ifndef INDUNKNOWN_DEFINED
DECLARE_INTERFACE(INDUnknown)
{
    STDMETHOD(NDQueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG, NDAddRef)(THIS) PURE;
    STDMETHOD_(ULONG, NDRelease)(THIS) PURE;
};
#define INDUNKNOWN_DEFINED
#endif

class CBaseObject {
public:
   CBaseObject() {g_cActiveObjects++;}
   ~CBaseObject() {g_cActiveObjects--;}
};

/* An object that supports one or more COM interfaces will be based on
   this class. It supports counting of total objects for DLLCanUnloadNow
   support, and an implementation of the core non delegating IUnknown */

class CComBase : public INDUnknown,
                 CBaseObject
{
private:
    IUnknown* m_pUnknown; /* Owner of this object */

protected:                      /* So we can override NDRelease() */
    volatile LONG m_cRef;       /* Number of reference counts */

public:

    CComBase(IUnknown* pUnk);
    virtual ~CComBase() {};

    // This is redundant, just use the other constructor
    //   as we never touch the HRESULT in this anyway
    CComBase(IUnknown* pUnk,HRESULT *phr);

    /* Return the owner of this object */

    IUnknown* GetOwner() const {
        return m_pUnknown;
    };

    /* Called from the class factory to create a new instance, it is
       pure virtual so it must be overriden in your derived class */

    /* static CComBase *CreateInstance(IUnknown*, HRESULT *) */

    /* Non delegating unknown implementation */

    STDMETHODIMP NDQueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) NDAddRef();
    STDMETHODIMP_(ULONG) NDRelease();
};

/* Return an interface pointer to a requesting client
   performing a thread safe AddRef as necessary */

STDAPI GetInterface(IUnknown* pUnk, void **ppv);

/* A function that can create a new COM object */

typedef CComBase *(CALLBACK *LPFNNewCOMObject)(IUnknown* pUnkOuter, HRESULT *phr);

/*  A function (can be NULL) which is called from the DLL entrypoint
    routine for each factory template:

    bLoading - TRUE on DLL load, FALSE on DLL unload
    rclsid   - the m_ClsID of the entry
*/
typedef void (CALLBACK *LPFNInitRoutine)(BOOL bLoading, const CLSID *rclsid);

#define CheckPointer(p,ret) {if((p)==NULL) return (ret);}

/* Create one of these per object class in an array so that
   the default class factory code can create new instances */

struct CComClassTemplate {
    const CLSID *              m_ClsID;
    LPFNNewCOMObject           m_lpfnNew;
};


/* You must override the (pure virtual) NDQueryInterface to return
   interface pointers (using GetInterface) to the interfaces your derived
   class supports (the default implementation only supports IUnknown) */

#define DECLARE_IUNKNOWN                                        \
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) {      \
        return GetOwner()->QueryInterface(riid,ppv);            \
    };                                                          \
    STDMETHODIMP_(ULONG) AddRef() {                             \
        return GetOwner()->AddRef();                            \
    };                                                          \
    STDMETHODIMP_(ULONG) Release() {                            \
        return GetOwner()->Release();                           \
    };



HINSTANCE	LoadOLEAut32();


#endif /* __COMBASE__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\dsdmo.h ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsdmo.h
 *  Content:    Global declarations for dsdmo.dll.
 *
 ***************************************************************************/

#ifndef _DSDMO_H_
#define _DSDMO_H_

#include <mmsystem.h>
#include <dsoundp.h>  // For effect IID and ClassID declarations
#include "debug.h"

extern double LogNorm[32];
extern float mylog( float finput, unsigned long maxexponent);
extern DWORD g_amPlatform;
extern long g_cComponent;
extern HMODULE g_hModule;

#define EXT_STD_CREATE(x) \
    extern CComBase * WINAPI CreateCDirectSound ## x ## DMO(IUnknown *punkOuter, HRESULT *phr);

#define EXT_STD_CAPTURE_CREATE(x) \
    extern CComBase * WINAPI CreateCDirectSoundCapture ## x ## DMO(IUnknown *punkOuter, HRESULT *phr);

// Disable exception warnings
#pragma warning(disable:4530)

#define STD_CREATE(x) \
CComBase* WINAPI CreateCDirectSound ## x ## DMO(IUnknown *punkOuter, HRESULT *phr) \
    {                                                                   \
        *phr = E_OUTOFMEMORY;                                           \
        CDirectSound ## x ## DMO *p = NULL;                             \
        try {                                                           \
            p = new CDirectSound ## x ## DMO(punkOuter, phr);           \
        } catch (...) {};                                               \
        if (p) {                                                        \
            *phr = p->InitOnCreation();                                 \
            if (FAILED(*phr))                                           \
            {                                                           \
                p->Release();                                           \
                p = NULL;                                               \
            }                                                           \
        }                                                               \
        else                                                            \
        {                                                               \
            Trace(1,"ERROR: Out of memory\n");                          \
        }                                                               \
        return p;                                                       \
    }

#define STD_CAPTURE_CREATE(x) \
CComBase* WINAPI CreateCDirectSoundCapture ## x ## DMO(IUnknown *punkOuter, HRESULT *phr) \
    {                                                                   \
        HRESULT hr = E_OUTOFMEMORY;                                     \
        CDirectSoundCapture ## x ## DMO *p = NULL;                      \
        try {                                                           \
            p = new CDirectSoundCapture ## x ## DMO(punkOuter, phr);    \
        } catch (...) {};                                               \
        if (p) {                                                        \
            *phr = p->InitOnCreation();                                 \
            if (FAILED(*phr))                                           \
            {                                                           \
                p->Release();                                           \
                p = NULL;                                               \
            }                                                           \
        }                                                               \
        else                                                            \
        {                                                               \
            Trace(1,"ERROR: Out of memory\n");                          \
        }                                                               \
        return p;                                                       \
    }


// Common #define's and templates for all filters
//
#define MaxSamplesPerSec        96000
#define PI                      3.1415926535
#define DefineMsecSize(y, x)    ((int)(((x) * (y)) / 1000))
#define DefineDelayLineSize(x)  DefineMsecSize(MaxSamplesPerSec, x)
//#define GetMsecPos(x)         (DefineDelayLineSize(x))
#define GetMsecPos(x)           (DefineMsecSize(m_EaxSamplesPerSec, x))
#define FractMask               0xfff
#define FractMultiplier         0x1000

template <int BufferSize> class DelayBuffer
{
#define DYNAMIC_ARRAYS 1
#if DYNAMIC_ARRAYS
    int *Buffer;
#else
    int Buffer[BufferSize];
#endif
    int BufferPos;

public:
    inline void Init(int SamplesPerSec)
    {
#if DYNAMIC_ARRAYS
        if (SamplesPerSec <= 0) {
            if (!SamplesPerSec) Buffer = 0;
            else if (Buffer) delete Buffer;

            return;
        }

        if (Buffer) delete Buffer;

        Buffer = new int[BufferSize];
#else
        if (SamplesPerSec <= 0) return;
#endif
        BufferPos = 0;
        memset(Buffer, 0, BufferSize * sizeof(int));
    }

    __forceinline int Pos(int x)
    {
        x += BufferPos;
        while (x < 0)
            x += BufferSize * FractMultiplier;
        x /= FractMultiplier;
        while (x >= BufferSize)
            x -= BufferSize;

        return(x);
    }

    __forceinline void Bump(void)
    {
        if (BufferPos == 0)
            BufferPos += BufferSize * FractMultiplier;
        if (BufferPos < 0)
            BufferPos += BufferSize * FractMultiplier;
        BufferPos -= FractMultiplier;
    }

    __forceinline int& operator[] (int i)
    {
        return (Buffer[i]);
    }
};

template <class type, float Msec, int AdditionalPositions> class DelayBuffer2
{
#if DYNAMIC_ARRAYS
    type *Buffer;
#else
    union {
        type Buffer[DefineDelayLineSize(Msec) + AdditionalPositions];
        type BufferDisplay[DefineDelayLineSize(Msec/10) + AdditionalPositions];
    };
#endif
    int BufferPos;
    int BufferSize;

public:
    inline HRESULT Init(int SamplesPerSec)
    {
        HRESULT hr = S_OK;
        BufferSize = DefineMsecSize(Msec, SamplesPerSec) + AdditionalPositions;
#if DYNAMIC_ARRAYS
        if (SamplesPerSec <= 0) {
            if (!SamplesPerSec) Buffer = 0;
            else if (Buffer) delete Buffer;

            return hr;
        }

        if (Buffer) delete Buffer;

        Buffer = new type[BufferSize];
#else
        if (SamplesPerSec <= 0) return;
#endif

        BufferPos = 0;

        if (Buffer != NULL)
        {
            memset(Buffer, 0, BufferSize * sizeof(type));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        return hr;
    }


    __forceinline int FractPos(int x)
    {
        x *= FractMultiplier;
        x += BufferPos;
        while (x < 0)
            x += BufferSize * FractMultiplier;
        x /= FractMultiplier;
        while (x >= BufferSize)
            x -= BufferSize;

        return(x);
    }

    __forceinline int Pos(int x)
    {
        x += BufferPos;
        while (x < 0)
            x += BufferSize * FractMultiplier;
        x /= FractMultiplier;
        while (x >= BufferSize)
            x -= BufferSize;

        return(x);
    }

    __forceinline int LastPos(int x)
    {
        x = Pos(x + BufferSize - 1);

        return(x);
    }

    __forceinline void Bump(void)
    {
        if (BufferPos == 0)
            BufferPos += BufferSize * FractMultiplier;
        if (BufferPos < 0)
            BufferPos += BufferSize * FractMultiplier;
        BufferPos -= FractMultiplier;
    }

    __forceinline type& operator[] (int i)
    {
        return (Buffer[i]);
    }

    __forceinline void ZeroBuffer(void)
    {
        if (Buffer != NULL)
            ZeroMemory(Buffer,BufferSize * sizeof(type));
    }

};

//
//
//
// { EAX
#ifndef _EAXDMO_
#define _EAXDMO_

#define CHECK_PARAM(lo, hi) \
    if (value < lo || value > hi) {return DSERR_INVALIDPARAM;} else;

#define PUT_EAX_VALUE(var, val) \
    m_Eax ## var = val

#define PUT_EAX_FVAL(var, val) \
    m_Eax ## var = (float)(val)

#define PUT_EAX_LVAL(var, val) \
    m_Eax ## var = (long)(val)

#define TOFRACTION(x)       ((float)x)
#define INTERPOLATE(x, y)   PUT_EAX_FVAL(x, (y))    // ??? Smooth it out...

#define SET_MPV_FLOAT(var) \
    MP_DATA mpv; \
    mpv = (MP_DATA)var;

#define SET_MPV_LONG SET_MPV_FLOAT

enum ChorusFilterParams
{
    CFP_Wetdrymix = 0,
    CFP_Depth,
    CFP_Frequency,
    CFP_Waveform,
    CFP_Phase,
    CFP_Feedback,
    CFP_Delay,
    CFP_MAX
};

enum CompressorFilterParams
{
    CPFP_Gain = 0,
    CPFP_Attack,
    CPFP_Release,
    CPFP_Threshold,
    CPFP_Ratio,
    CPFP_Predelay,
    CPFP_MAX
};

enum DistortionFilterParams
{
    DFP_Gain = 0,
    DFP_Edge,
    DFP_LpCutoff,
    DFP_EqCenter,
    DFP_EqWidth,
    DFP_MAX
};

enum EchoFilterParams
{
    EFP_Wetdrymix = 0,
    EFP_Feedback,
    EFP_DelayLeft,
    EFP_DelayRight,
    EFP_PanDelay,
    EFP_MAX
};

enum FilterParams
{
    FFP_Wetdrymix = 0,
    FFP_Waveform,
    FFP_Frequency,
    FFP_Depth,
    FFP_Phase,
    FFP_Feedback,
    FFP_Delay,
    FFP_MAX
};

enum ParamEqFilterParams
{
    PFP_Center = 0,
    PFP_Bandwidth,
    PFP_Gain,
    PFP_MAX
};

enum GargleFilterParams
{
    GFP_Rate = 0,
    GFP_Shape,
    GFP_MAX
};

enum SVerbParams
{
    SVP_Gain = 0,
    SVP_Mix,
    SVP_ReverbTime,
    SVP_Ratio,
    SVP_MAX
};

enum MicArrayParams
{
    MAP_Enable = 0,
    MAP_Reset,
    MAP_MAX
};

enum AecParams
{
    AECP_Enable = 0,
    AECP_NoiseFill,
    AECP_Mode,
    AECP_MAX
};

enum NoiseSuppressParams
{
    NSP_Enable = 0,
    NSP_MAX
};

enum AgcParams
{
    AGCP_Enable = 0,
    AGCP_Reset,
    AGCP_MAX
};

#define GET_PUT(x, type) \
    STDMETHOD(get_Eax ## x) \
        ( THIS_ \
        type *Eax ## x \
        ) PURE; \
    STDMETHOD(put_Eax ## x) \
        ( THIS_ \
        type Eax ## x \
        ) PURE

interface IChorus : public IUnknown
{
public:
    GET_PUT(Wetdrymix,  float);
    GET_PUT(Depth,      float);
    GET_PUT(Frequency,  float);
    GET_PUT(Waveform,   long);
    GET_PUT(Phase,      long);
    GET_PUT(Feedback,   float);
    GET_PUT(Delay,      float);

};

interface ICompressor : public IUnknown
{
public:
    GET_PUT(Gain,       float);
    GET_PUT(Attack,     float);
    GET_PUT(Release,    float);
    GET_PUT(Threshold,  float);
    GET_PUT(Ratio,      float);
    GET_PUT(Predelay,   float);
};

interface IDistortion : public IUnknown
{
public:
    GET_PUT(Gain,       float);
    GET_PUT(Edge,       float);
    GET_PUT(LpCutoff,   float);
    GET_PUT(EqCenter,   float);
    GET_PUT(EqWidth,    float);
};

interface IEcho : public IUnknown
{
public:
    GET_PUT(Wetdrymix,  float);
    GET_PUT(Feedback,   float);
    GET_PUT(DelayLeft,  float);
    GET_PUT(DelayRight, float);
    GET_PUT(PanDelay,   long);
};

interface IFlanger : public IUnknown
{
public:
    GET_PUT(Wetdrymix,  float);
    GET_PUT(Waveform,   long);
    GET_PUT(Frequency,  float);
    GET_PUT(Depth,      float);
    GET_PUT(Phase,      long);
    GET_PUT(Feedback,   float);
    GET_PUT(Delay,      float);
};

interface IParamEq : public IUnknown
{
public:
    GET_PUT(Center,     float);
    GET_PUT(Bandwidth,  float);
    GET_PUT(Gain,       float);
};

#undef GET_PUT

DEFINE_GUID(CLSID_DirectSoundPropGargle,0x794885CC,0x5EB7,0x46E3,0xA9,0x37,0xAD,0x89,0x0A,0x6C,0x66,0x77);
DEFINE_GUID(CLSID_DirectSoundPropChorus,0x60129CFD,0x2E9B,0x4098,0xAA,0x4B,0xD6,0xCF,0xAD,0xA2,0x65,0xC3);
DEFINE_GUID(CLSID_DirectSoundPropFlanger,0x22AF00DF,0x46B4,0x4F51,0xA3,0x63,0x68,0x54,0xD5,0x2E,0x13,0xA0);
DEFINE_GUID(CLSID_DirectSoundPropDistortion,0x5858107D,0x11EA,0x47B1,0x96,0x94,0x3F,0x29,0xF7,0x68,0x0F,0xB8);
DEFINE_GUID(CLSID_DirectSoundPropEcho,0xD45CF2C7,0x48CF,0x4234,0x86,0xE2,0x45,0x59,0xC3,0x2F,0xAD,0x1A);
DEFINE_GUID(CLSID_DirectSoundPropCompressor,0xED3DC730,0x31E5,0x4108,0xAD,0x8A,0x39,0x62,0xC9,0x30,0x42,0x5E);
DEFINE_GUID(CLSID_DirectSoundPropParamEq,0xAE86C36D,0x808E,0x4B07,0xB7,0x99,0x56,0xD7,0x36,0x1C,0x38,0x35);
DEFINE_GUID(CLSID_DirectSoundPropWavesReverb,0x6A879859,0x3858,0x4322,0x97,0x1A,0xB7,0x05,0xF3,0x49,0xF1,0x24);
DEFINE_GUID(CLSID_DirectSoundPropI3DL2Reverb,0xD3952B77,0x2D22,0x4B72,0x8D,0xF4,0xBA,0x26,0x7A,0x9C,0x12,0xD0);
DEFINE_GUID(CLSID_DirectSoundPropI3DL2Source,0x3DC26D0C,0xBEFF,0x406C,0x89,0xB0,0xCA,0x13,0xE2,0xBD,0x91,0x72);

// } EAX

#endif

#endif // _DSDMO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\dsdmobse.cpp ===
/*
 * DirectSound DirectMediaObject base classes 
 *
 * Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.  
 */

#include "DsDmoBse.h"
#include "debug.h"

#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>

struct KSMEDIAPARAM
{
    KSNODEPROPERTY  ksnp;
    ULONG           ulIndex;            // Instance data is index of parameter
};

static BOOL SyncIoctl(
    IN      HANDLE  handle,
    IN      ULONG   ulIoctl,
    IN      PVOID   pvInBuffer  OPTIONAL,
    IN      ULONG   ulInSize,
    OUT     PVOID   pvOutBuffer OPTIONAL,
    IN      ULONG   ulOutSize,
    OUT     PULONG  pulBytesReturned);

// XXX C1in1out calls InitializeCriticalSection in a constructor with
// no handler.
//

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::CDirectSoundDMO
//
CDirectSoundDMO::CDirectSoundDMO()
{
    m_mpvCache = NULL;
    m_fInHardware = false;
    m_pKsPropertySet = NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::~CDirectSoundDMO
//
CDirectSoundDMO::~CDirectSoundDMO() 
{
    delete[] m_mpvCache;
    m_mpvCache = NULL;
    m_fInHardware = false;
    RELEASE(m_pKsPropertySet);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::GetClassID
//
// This should always return E_NOTIMPL
//
STDMETHODIMP CDirectSoundDMO::GetClassID(THIS_ CLSID *pClassID)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::IsDirty
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::IsDirty(THIS)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::Load
//
// Override if doing something other than just standard load.
//
STDMETHODIMP CDirectSoundDMO::Load(THIS_ IStream *pStm) 
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::Save
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::Save(THIS_ IStream *pStm, BOOL fClearDirty)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::GetSizeMax
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::GetSizeMax(THIS_ ULARGE_INTEGER *pcbSize)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::Process
//
STDMETHODIMP CDirectSoundDMO::Process(THIS_ ULONG ulSize, BYTE *pData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    DMO_MEDIA_TYPE *pmt = InputType();
    if (pmt == NULL)
        return E_FAIL;

    assert(pmt->formattype == FORMAT_WaveFormatEx);
    ulSize /= LPWAVEFORMATEX(pmt->pbFormat)->nBlockAlign;
    return ProcessInPlace(ulSize, pData, rtStart, dwFlags);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::GetLatency
//
STDMETHODIMP CDirectSoundDMO::GetLatency(THIS_ REFERENCE_TIME *prt)
{
    *prt = 0;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::AcquireResources
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::AcquireResources(THIS_ IKsPropertySet *pKsPropertySet)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::ReleaseResources
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::ReleaseResources(THIS_)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::InitializeNode
//
// Override if doing something other than just standard save.
//
STDMETHODIMP CDirectSoundDMO::InitializeNode(THIS_ HANDLE hPin, ULONG ulNodeId)
{
    m_hPin = hPin;
    m_ulNodeId = ulNodeId;
    return S_OK;
}





#if 0
// FIXME: no longer in medparam.idl

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::GetParams
//
STDMETHODIMP CDirectSoundDMO::GetParams(THIS_ DWORD dwParamIndexStart, DWORD *pdwNumParams, MP_DATA **ppValues)
{
    HRESULT hr;

    if (dwParamIndexStart >= ParamCount())
    {
        // XXX Real error code
        //
        return E_FAIL;
    }

    DWORD dw;
    DWORD dwParamIndexEnd = dwParamIndexStart + *pdwNumParams;
   
    for (dw = dwParamIndexStart; dw < dwParamIndexEnd; dw++) 
    {
        if (dw >= ParamCount())
        {
            *pdwNumParams = dw - dwParamIndexStart;
            return S_FALSE;
        }

        hr = GetParam(dw, ppValues[dw]);
        if (FAILED(hr))
        {
            *pdwNumParams = dw - dwParamIndexStart;
            return hr;
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::SetParams
//
STDMETHODIMP CDirectSoundDMO::SetParams(THIS_ DWORD dwParamIndexStart, DWORD *pdwNumParams, MP_DATA __RPC_FAR *pValues)
{
    HRESULT hr;

    if (dwParamIndexStart >= ParamCount())
    {
        // XXX Real error code
        //
        return E_FAIL;
    }

    DWORD dw;
    DWORD dwParamIndexEnd = dwParamIndexStart + *pdwNumParams;
   
    for (dw = dwParamIndexStart; dw < dwParamIndexEnd; dw++) 
    {
        if (dw >= ParamCount())
        {
            *pdwNumParams = dw - dwParamIndexStart;
            return S_FALSE;
        }

        hr = SetParam(dw, pValues[dw]);
        if (FAILED(hr))
        {
            *pdwNumParams = dw - dwParamIndexStart;
            return hr;
        }
    }

    return S_OK;
}

#endif

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundDMO::ProxySetParam
//
HRESULT CDirectSoundDMO::ProxySetParam(DWORD dwParamIndex, MP_DATA value)
{
    assert(m_pKsPropertySet);

    return m_pKsPropertySet->Set(
        IID_IMediaParams, 0,                    // Set, item
        &dwParamIndex, sizeof(dwParamIndex),    // Instance data
        &value, sizeof(value));                 // Property data
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\dsdmobse.h ===
/*
 * DirectSound DirectMediaObject base classes 
 *
 * Copyright (c) 1999 - 2000 Microsoft Corporation.  All Rights Reserved.  
 */
#ifndef _DsDmoBase_
#define _DsDmoBase_

#define DMO_NOATL

#include <objbase.h>
#include <dmobase.h>
#include <medparam.h>
#include <mmsystem.h>
#include <dsoundp.h>

#ifndef RELEASE
#define RELEASE(x) { if (x) (x)->Release(); x = NULL; }
#endif

// Macro to handle QueryInterface in the derived class for interfaces
// implemented by this base class.
//
#define IMP_DSDMO_QI(iid, ppv)      \
{                                                   \
    *ppv = NULL;                                    \
         if (iid == IID_IPersistStream)       *ppv = (void**)static_cast<IPersistStream*>(this); \
    else if (iid == IID_IMediaObjectInPlace)  *ppv = (void**)static_cast<IMediaObjectInPlace*>(this); \
    else if (iid == IID_IDirectSoundDMOProxy) *ppv = (void**)static_cast<IDirectSoundDMOProxy*>(this); \
    if (*ppv) \
    { \
        AddRef(); \
        return S_OK; \
    } \
}

class CDirectSoundDMO :
      public CPCMDMO,
      public IPersistStream,
      public IMediaObjectInPlace,
      public IDirectSoundDMOProxy
{
public:
    CDirectSoundDMO();
    virtual ~CDirectSoundDMO();

    /* IPersist */
    STDMETHODIMP GetClassID                 (THIS_ CLSID *pClassID);
    
    /* IPersistStream */
    STDMETHODIMP IsDirty                    (THIS);
    STDMETHODIMP Load                       (THIS_ IStream *pStm); 
    STDMETHODIMP Save                       (THIS_ IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax                 (THIS_ ULARGE_INTEGER *pcbSize);

    /* IMediaObjectInPlace */
    STDMETHODIMP Process                    (THIS_ ULONG ulSize, BYTE *pData, REFERENCE_TIME rtStart, DWORD dwFlags);
    STDMETHODIMP GetLatency                 (THIS_ REFERENCE_TIME *prt);

    /* IDirectSoundDMOProxy */
    STDMETHODIMP AcquireResources           (THIS_ IKsPropertySet *pKsPropertySet);
    STDMETHODIMP ReleaseResources           (THIS);
    STDMETHODIMP InitializeNode             (THIS_ HANDLE hPin, ULONG ulNodeId);

protected:
    // Information about each parameter. This is only needed by the
    // author time object.
    //

    // Process in place
    //
    virtual HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags) = 0;

    // Send a parameter to the hardware. Called by the base class on SetParam if
    // hardware is connected. This is virtual so a DMO can use the base class but
    // override the way it talks to hardware.
    //
    virtual HRESULT ProxySetParam(DWORD dwParamIndex, MP_DATA value);

    // Derived class can use this to determine if hardware is turned on.
    //
    inline bool IsInHardware()
    { return m_fInHardware; }

protected:
    HANDLE                  m_hPin;
    ULONG                   m_ulNodeId;

private:
    MP_DATA                *m_mpvCache;
    IKsPropertySet         *m_pKsPropertySet;
    bool                    m_fInHardware;

};  

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\flanger.cpp ===
#include <windows.h>

#include "flangerp.h"
#include "clone.h"

STD_CREATE(Flanger)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::NDQueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
STDMETHODIMP CDirectSoundFlangerDMO::NDQueryInterface(THIS_ REFIID riid, LPVOID *ppv)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXFlanger)
    {
        return GetInterface((IDirectSoundFXFlanger*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::CDirectSoundFlangerDMO
//
CDirectSoundFlangerDMO::CDirectSoundFlangerDMO( IUnknown *pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr ),
    m_fDirty(false)
// { EAX: put init data here if any (otherwise use Discontinuity).
// } EAX
{
    m_EaxSamplesPerSec = 22050;

    m_DelayL   .Init(0);
    m_DelayR   .Init(0);
    m_DryDelayL.Init(0);
    m_DryDelayR.Init(0);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::Init()
//
HRESULT CDirectSoundFlangerDMO::Init()
{
    DSFXFlanger flanger;
    HRESULT hr; 
    // Force recalc of all internal parameters
    //
    hr = GetAllParameters(&flanger);
    if (SUCCEEDED(hr)) hr = SetAllParameters(&flanger);

    if (SUCCEEDED(hr)) hr = m_DelayL   .Init(m_EaxSamplesPerSec);
    if (SUCCEEDED(hr)) hr = m_DelayR   .Init(m_EaxSamplesPerSec);
    if (SUCCEEDED(hr)) hr = m_DryDelayL.Init(m_EaxSamplesPerSec);
    if (SUCCEEDED(hr)) hr = m_DryDelayR.Init(m_EaxSamplesPerSec);
    if (SUCCEEDED(hr)) hr = Discontinuity();

    return hr;
}

//  bugbug on dsdmo.h: FilterParams should be FlangerFilterParams and need DSFXFLANGER_WAVE_TRIANGLE/DSFXFLANGER_WAVE_SIN
const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                        max,                        neutral,                unit text,  label,          pwchText
    FFP_Wetdrymix,  MPT_FLOAT,  g_capsAll,  DSFXFLANGER_WETDRYMIX_MIN,  DSFXFLANGER_WETDRYMIX_MAX,  50,                     L"%",       L"WetDryMix",   L"",
    FFP_Depth,      MPT_FLOAT,  g_capsAll,  DSFXFLANGER_DEPTH_MIN,      DSFXFLANGER_DEPTH_MAX,      100,                    L"",        L"Depth",       L"",
    FFP_Frequency,  MPT_FLOAT,  g_capsAll,  DSFXFLANGER_FREQUENCY_MIN,  DSFXFLANGER_FREQUENCY_MAX,  (float).25,             L"Hz",      L"Frequency",   L"",
    FFP_Waveform,   MPT_ENUM,   g_capsAll,  DSFXCHORUS_WAVE_TRIANGLE,   DSFXCHORUS_WAVE_SIN,        DSFXCHORUS_WAVE_SIN,    L"",        L"WaveShape",   L"Triangle,Sine",
    FFP_Phase,      MPT_INT,    g_capsAll,  DSFXFLANGER_PHASE_MIN,      DSFXFLANGER_PHASE_MAX,      2,                      L"",        L"Phase",       L"",
    FFP_Feedback,   MPT_FLOAT,  g_capsAll,  DSFXFLANGER_FEEDBACK_MIN,   DSFXFLANGER_FEEDBACK_MAX,   -50,                    L"",        L"Feedback",    L"",
    FFP_Delay,      MPT_FLOAT,  g_capsAll,  DSFXFLANGER_DELAY_MIN,      DSFXFLANGER_DELAY_MAX,      2,                      L"",        L"Delay",       L"",
};

HRESULT CDirectSoundFlangerDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);

    m_ModdelayL = m_ModdelayR = 0;
    m_ModdelayL1 = m_ModdelayR1 = 0x800;

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::~CDirectSoundFlangerDMO
//
CDirectSoundFlangerDMO::~CDirectSoundFlangerDMO() 
{
    m_DelayL   .Init(-1);
    m_DelayR   .Init(-1);
    m_DryDelayL.Init(-1);
    m_DryDelayR.Init(-1);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::Clone
//
STDMETHODIMP CDirectSoundFlangerDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundFlangerDMO, DSFXFlanger>(this, pp);
}

//
//    Bump - bump the delay pointers.
//
void CDirectSoundFlangerDMO::Bump(void)
{
// EAX {
    m_DelayL.Bump();
    m_DelayR.Bump();
    m_DryDelayL.Bump();
    m_DryDelayR.Bump();
// }
}


HRESULT CDirectSoundFlangerDMO::Discontinuity() 
{
// { EAX


    m_DelayL   .ZeroBuffer();
    m_DelayR   .ZeroBuffer();
    m_DryDelayL.ZeroBuffer();
    m_DryDelayR.ZeroBuffer();

    // These values have defined initial values.

//    m_FixedptrL = m_DelayL.LastPos(0) * FractMultiplier;
    m_DelayptrL = m_ModdelayL1 = m_ModdelayL = (int)m_EaxFixedptrL;

//    m_FixedptrR = m_DelayR.LastPos(0) * FractMultiplier;
    m_DelayptrR = m_ModdelayR1 = m_ModdelayR = (int)m_EaxFixedptrR;

    if (!m_EaxWaveform) {
        m_LfoState[0] = (float)0.0;
        m_LfoState[1] = (float)0.5;
    }
    else {
        m_LfoState[0] = (float)0.0;
        m_LfoState[1] = (float)0.99999999999;
    }

// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

static int   LMul  [5] = {  1,  1, 1, 1, -1};
static int   RMul  [5] = { -1, -1, 1, 1,  1};
static int   RPhase[5] = {  0,  1, 0, 1,  0};


__forceinline void CDirectSoundFlangerDMO::DoOneSample(int *l, int *r)
{
    float    inPortL = (float)*l;
    float    inPortR = (float)*r;
    float    XWave[2];
#define sinwave    XWave[0]
#define coswave    XWave[1]

    int Pos0, PosX, tempvar;
    float val;

//     dryDelayL[]    = inPortL;

    Pos0              = m_DryDelayL.Pos(0);
    m_DryDelayL[Pos0] = inPortL;

    
//    delayL[] = ACC + delayL[fixedptrL] * fbcoef;

    Pos0           = m_DelayL.Pos(0);
    PosX           = m_DelayL.Pos(m_EaxFixedptrL);
    m_DelayL[Pos0] = inPortL + m_DelayL[PosX] * m_EaxFbCoef;
    
//    dryDelayR[]    = inPortR;

    Pos0              = m_DryDelayR.Pos(0);
    m_DryDelayR[Pos0] = inPortR;

//    delayR[]    = ACC + delayR[fixedptrR] * fbcoef;

    Pos0           = m_DelayR.Pos(0);
    PosX           = m_DelayR.Pos(m_EaxFixedptrR);
    m_DelayR[Pos0] = inPortR + m_DelayR[PosX] * m_EaxFbCoef;
    
// Sinusoid : lfocoef = 2*sin(PI*f/FS)    // ??? Update this when form changes.

    if (!m_EaxWaveform) {

        m_LfoState[0] = m_LfoState[0] + m_EaxLfoCoef;

        if (m_LfoState[0] > 1) m_LfoState[0] -= 2;

        m_LfoState[1] = m_LfoState[1] + m_EaxLfoCoef;

        if (m_LfoState[1] > 1) m_LfoState[1] -= 2;

        sinwave       = (float)fabs(m_LfoState[0]);
        coswave       = (float)fabs(m_LfoState[1]);
        sinwave       = -1 + 2 * sinwave;
        coswave       = -1 + 2 * coswave;
    }
    else {

        m_LfoState[0] = m_LfoState[0] + m_EaxLfoCoef * m_LfoState[1];
        m_LfoState[1] = m_LfoState[1] - m_EaxLfoCoef * m_LfoState[0];

        sinwave       = m_LfoState[0];
        coswave       = m_LfoState[1];
    }

//     Left Out
//    tempvar            ^= delayptrL << 20;

    tempvar = m_DelayptrL & FractMask;

//    tempvar        = tempvar : delayL[moddelayL] < delayL[moddelayL1];

    Pos0 = m_DelayL.Pos(m_ModdelayL);
    PosX = m_DelayL.Pos(m_ModdelayL1);

    val = ((float)tempvar) / FractMultiplier;
    val = Interpolate(m_DelayL[Pos0], m_DelayL[PosX], val);
    
//    outPortL    = wetlevel : dryDelayL[2] < tempvar;
    
    Pos0 = m_DryDelayL.FractPos(2);
    val  = Interpolate(m_DryDelayL[Pos0], val, m_EaxWetlevel);

    *l = Saturate(val);

//     Right Out
//    tempvar            ^= delayptrR << 20;

    tempvar = m_DelayptrR & FractMask;

//    tempvar        = tempvar : delayR[moddelayR] < delayR[moddelayR1];

    Pos0 = m_DelayR.Pos(m_ModdelayR);
    PosX = m_DelayR.Pos(m_ModdelayR1);

    val = ((float)tempvar) / FractMultiplier;
    val = Interpolate(m_DelayR[Pos0], m_DelayR[PosX], val);
    
//    outPortR    = wetlevel : dryDelayR[2] < tempvar;
    
    Pos0 = m_DryDelayR.FractPos(2);
    val  = Interpolate(m_DryDelayR[Pos0], val, m_EaxWetlevel);

    *r = Saturate(val);

//    Left Delay Address Calculation
//     Same as efx...

//    m_DelayptrL     = (int)(m_EaxFixedptrL + (sinwave * m_EaxDepthCoef));
#if 0
    switch (m_EaxPhase) {
        case 0: 
        case 1: 
        case 2:
        case 3: m_DelayptrL =   (int)(sinwave * m_EaxDepthCoef); break;
        case 4: m_DelayptrL = - (int)(sinwave * m_EaxDepthCoef); break;
    }
#else
#ifdef DONTUSEi386
    {
    int x;
    float f = (sinwave * m_EaxDepthCoef);

    _asm { 
        fld f
        fistp x
    }
    m_DelayptrL  = LMul[m_EaxPhase] * x;
    }
#else
    m_DelayptrL  = LMul[m_EaxPhase] * (int)(sinwave * m_EaxDepthCoef);
#endif
#endif

    m_DelayptrL += m_EaxFixedptrL;
    m_ModdelayL     = m_DelayptrL;
    m_ModdelayL1 = m_DelayptrL + FractMultiplier;

//    Right Delay Address Calculation

//    m_DelayptrR     = (int)(m_EaxFixedptrR + (coswave * m_EaxDepthCoef));
#if 0
    switch (m_EaxPhase) {
        case 0: m_DelayptrR = - (int)(sinwave * m_EaxDepthCoef); break;
        case 1: m_DelayptrR = - (int)(coswave * m_EaxDepthCoef); break;
        case 3: m_DelayptrR =   (int)(coswave * m_EaxDepthCoef); break;
        case 2:
        case 4: m_DelayptrR =   (int)(sinwave * m_EaxDepthCoef); break;
    }
#else
    Pos0        = RPhase[m_EaxPhase];
#ifdef DONTUSEi386
    {
    int x;
    float f = (XWave[Pos0] * m_EaxDepthCoef);

    _asm { 
        fld f
        fistp x
    }
    m_DelayptrR = RMul  [m_EaxPhase] * x;
    }
#else
    m_DelayptrR = RMul  [m_EaxPhase] * (int)(XWave[Pos0] * m_EaxDepthCoef);
#endif
#endif
    m_DelayptrR += m_EaxFixedptrR;
    m_ModdelayR     = m_DelayptrR;
    m_ModdelayR1 = m_DelayptrR + FractMultiplier;

    Bump();
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::FBRProcess
//
HRESULT CDirectSoundFlangerDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut)
{
// { EAX
#define cb cSamples
#define pin pIn
#define pout pOut

    if (m_cChannels == 1) {
        if (m_b8bit) {
            for (;cb > 0; --cb) {
                int i, j;

                i = *(pin+0)-128;
                i *=256;
                j  = i;

                DoOneSample(&i, &j);
                
                i += j;
                i /= 2;
                
                i /= 256;

                *(pout+0) = (unsigned char)(i + 128);
            
                pin  += sizeof(unsigned char);
                pout += sizeof(unsigned char);
            }
        }
        else if (!m_b8bit) {
            for (;cb > 0; --cb) { // for (;cb > 0; cb -= sizeof(short)) {
                   short int *psi = (short int *)pin;
                   short int *pso = (short int *)pout;
                int i, j;

                i = *psi;
                j =  i;

                DoOneSample(&i, &j);
                
                i += j;
                i /= 2;
                
                   *pso = (short)i;
            
                pin  += sizeof(short);
                pout += sizeof(short);
            }
        }
    }
    else if (m_cChannels == 2) {
        if (m_b8bit) {
            for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(unsigned char)) {
                int i, j;

                i = *(pin+0)-128;
                j = *(pin+1)-128;

                i *=256; j *=256;

                DoOneSample(&i, &j);
                
                i /= 256; j /= 256;
                
                *(pout+0) = (unsigned char)(i + 128);
                *(pout+1) = (unsigned char)(j + 128);
            
                pin  += 2 * sizeof(unsigned char);
                pout += 2 * sizeof(unsigned char);
            }
        }
        else if (!m_b8bit) {
            for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(short)) {
                   short int *psi = (short int *)pin;
                   short int *pso = (short int *)pout;
                int i, j;

                i = *(psi+0);
                j = *(psi+1);

                DoOneSample(&i, &j);
                
                   *(pso+0) = (short)i;
                   *(pso+1) = (short)j;
            
                pin  += 2 * sizeof(short);
                pout += 2 * sizeof(short);
            }
        }
    }
// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::ProcessInPlace
//
HRESULT CDirectSoundFlangerDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    return FBRProcess(ulQuanta, pcbData, pcbData);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::SetParam
//
// { EAX
// }

HRESULT CDirectSoundFlangerDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
    long l;

    if (!m_EaxSamplesPerSec) return DMO_E_TYPE_NOT_ACCEPTED;    // NO TYPE!

    switch (dwParamIndex)
    {
    case FFP_Wetdrymix :
        CHECK_PARAM(DSFXFLANGER_WETDRYMIX_MIN, DSFXFLANGER_WETDRYMIX_MAX);

        PUT_EAX_VALUE(Wetlevel, value / 100);
        break;
    
    case FFP_Waveform :
        CHECK_PARAM(DSFXFLANGER_WAVE_TRIANGLE, DSFXFLANGER_WAVE_SIN);

        l = m_EaxWaveform;

        PUT_EAX_VALUE(Waveform, (long)value);

        if (l != m_EaxWaveform) {
            if (!m_EaxWaveform) {
                m_LfoState[0] = (float)0.0;
                m_LfoState[1] = (float)0.5;
            }
            else {
                m_LfoState[0] = (float)0.0;
                m_LfoState[1] = (float)0.99999999999;
            }
        }
        goto x;
//        break;

    case FFP_Frequency :
        CHECK_PARAM(DSFXFLANGER_FREQUENCY_MIN, DSFXFLANGER_FREQUENCY_MAX);

        PUT_EAX_VALUE(Frequency, value);
x:
        if (!m_EaxWaveform) {                // Triangle.
            INTERPOLATE
                (
                LfoCoef, 
                TOFRACTION(2.0 * (m_EaxFrequency/m_EaxSamplesPerSec) * 1.0)
                );
        }
        else                                 // Sine/Cosine.
        {
            INTERPOLATE
                (
                LfoCoef, 
                TOFRACTION(2.0*sin(PI*m_EaxFrequency/m_EaxSamplesPerSec))
                );
        }
        break;

    case FFP_Depth : {
        CHECK_PARAM(DSFXFLANGER_DEPTH_MIN, DSFXFLANGER_DEPTH_MAX);

        PUT_EAX_VALUE(Depth, value / 100);

        double midpoint    = m_EaxDelay * m_EaxSamplesPerSec/1000;

        INTERPOLATE(DepthCoef, ((m_EaxDepth * midpoint) / 2) * FractMultiplier);
        break;
    }
    case FFP_Phase :
        CHECK_PARAM(DSFXFLANGER_PHASE_MIN, DSFXFLANGER_PHASE_MAX);

        PUT_EAX_VALUE(Phase, (long)value);
        break;

    case FFP_Feedback :
        CHECK_PARAM(DSFXFLANGER_FEEDBACK_MIN, DSFXFLANGER_FEEDBACK_MAX);

        PUT_EAX_FVAL(FbCoef, TOFRACTION(value/100));
        break;

    case FFP_Delay : {
        CHECK_PARAM(DSFXFLANGER_DELAY_MIN, DSFXFLANGER_DELAY_MAX);

        PUT_EAX_VALUE(Delay, value);

        double midpoint    = m_EaxDelay * m_EaxSamplesPerSec/1000;

        PUT_EAX_FVAL(DepthCoef, ((m_EaxDepth * midpoint) / 2) * FractMultiplier);
        PUT_EAX_LVAL(FixedptrL, (midpoint + 2) * FractMultiplier);
        PUT_EAX_LVAL(FixedptrR, (midpoint + 2) * FractMultiplier);
        break;
    }
// } EAX
    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundFlangerDMO::SetAllParameters(LPCDSFXFlanger pFlanger)
{
    HRESULT hr = S_OK;
    
    // Check that the pointer is not NULL
    if (pFlanger == NULL)
    {
        Trace(1,"ERROR: pFlanger is NULL\n");
        hr = E_POINTER;
    }
    // Set the parameters
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Wetdrymix, pFlanger->fWetDryMix);
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Waveform, (float)pFlanger->lWaveform);
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Frequency, pFlanger->fFrequency);
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Depth, pFlanger->fDepth);
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Phase, (float)pFlanger->lPhase);
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Feedback, pFlanger->fFeedback);
    if (SUCCEEDED(hr)) hr = SetParam(FFP_Delay, pFlanger->fDelay);

    m_fDirty = true;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundFlangerDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundFlangerDMO::GetAllParameters(LPDSFXFlanger pFlanger)
{
    HRESULT hr = S_OK;
    MP_DATA mpd;

    if (pFlanger == NULL) return E_POINTER;
    
#define GET_PARAM(x,y) \
    if (SUCCEEDED(hr)) { \
        hr = GetParam(x, &mpd);    \
        if (SUCCEEDED(hr)) pFlanger->y = mpd; \
    }

#define GET_PARAM_LONG(x,y) \
    if (SUCCEEDED(hr)) { \
        hr = GetParam(x, &mpd);    \
        if (SUCCEEDED(hr)) pFlanger->y = (long)mpd; \
    }
    GET_PARAM(FFP_Wetdrymix, fWetDryMix);
    GET_PARAM(FFP_Delay, fDelay);
    GET_PARAM(FFP_Depth, fDepth);
    GET_PARAM(FFP_Frequency, fFrequency);
    GET_PARAM_LONG(FFP_Waveform, lWaveform);
    GET_PARAM_LONG(FFP_Phase, lPhase);
    GET_PARAM(FFP_Feedback, fFeedback);

    return hr;
}

// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundFlangerDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_FLANGER;
    return NOERROR;

} // GetClassID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\echo.cpp ===
#include <windows.h>

#include "echop.h"
#include "clone.h"

STD_CREATE(Echo)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::NDQueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
STDMETHODIMP CDirectSoundEchoDMO::NDQueryInterface(THIS_ REFIID riid, LPVOID *ppv)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXEcho)
    {
        return GetInterface((IDirectSoundFXEcho*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::CDirectSoundEchoDMO
//
CDirectSoundEchoDMO::CDirectSoundEchoDMO( IUnknown *pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr) ,
    m_fDirty(true)
// { EAX: put init data here if any (otherwise use Discontinuity).
// } EAX
{
	m_EaxSamplesPerSec = 22050;

	m_DelayL.Init(0);
	m_DelayR.Init(0);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::Init()
//
HRESULT CDirectSoundEchoDMO::Init()
{
    DSFXEcho echo;
    HRESULT hr;

    // Force recalc of all internal parameters
    hr = GetAllParameters(&echo);
    if (SUCCEEDED(hr)) hr = SetAllParameters(&echo);

    if (SUCCEEDED(hr)) hr = m_DelayL.Init(m_EaxSamplesPerSec);
	if (SUCCEEDED(hr)) hr = m_DelayR.Init(m_EaxSamplesPerSec);
    if (SUCCEEDED(hr)) hr = Discontinuity();
    return hr;
}


const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                        max,                        neutral,                unit text,  label,          pwchText
    EFP_Wetdrymix,  MPT_FLOAT,  g_capsAll,  DSFXECHO_WETDRYMIX_MIN,     DSFXECHO_WETDRYMIX_MAX,     50,                     L"",        L"WetDryMix",   L"",
    EFP_Feedback,   MPT_FLOAT,  g_capsAll,  DSFXECHO_FEEDBACK_MIN,      DSFXECHO_FEEDBACK_MAX,      50,                     L"",        L"Feedback",    L"",
    EFP_DelayLeft,  MPT_FLOAT,  g_capsAll,  DSFXECHO_LEFTDELAY_MIN,     DSFXECHO_LEFTDELAY_MAX,     500,                    L"",        L"LeftDelay",   L"",
    EFP_DelayRight, MPT_FLOAT,  g_capsAll,  DSFXECHO_RIGHTDELAY_MIN,    DSFXECHO_RIGHTDELAY_MAX,    500,                    L"",        L"RightDelay",  L"",
    EFP_PanDelay,   MPT_BOOL,   g_capsAll,  DSFXECHO_PANDELAY_MIN,      DSFXECHO_PANDELAY_MAX,      0,                      L"",        L"PanDelay",    L"",
};

HRESULT CDirectSoundEchoDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::~CDirectSoundEchoDMO
//
CDirectSoundEchoDMO::~CDirectSoundEchoDMO() 
{
	m_DelayL.Init(-1);
	m_DelayR.Init(-1);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::Clone
//
STDMETHODIMP CDirectSoundEchoDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundEchoDMO, DSFXEcho>(this, pp);
}

//
//	Bump - bump the delay pointers.
//
void CDirectSoundEchoDMO::Bump(void)
{
// EAX {

	m_DelayL.Bump();		// Bump delay array pointers.
	m_DelayR.Bump();		// Bump delay array pointers.
// }
}


HRESULT CDirectSoundEchoDMO::Discontinuity() 
{
// { EAX

	m_EaxPan = 0;

	m_StateL = m_StateR = 0;

	m_DelayL.ZeroBuffer();
	m_DelayR.ZeroBuffer();

//	These values are set to be the defaults when the property page is activated.

//	m_EaxDelayLRead = m_DelayL.LastPos(-16);
//	m_EaxDelayRRead = m_DelayR.LastPos(-16);

	// These values have defined initial values.
// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////


__forceinline void CDirectSoundEchoDMO::DoOneSample(int *l, int *r)
{
	float	inPortL = (float)*l;
	float	inPortR = (float)*r;

	float	outPortL, outPortR;
	
	int		pos;
	float	tempvar, temp2;

//LeftDelayRead:
//	tempvar = delayL[@-16] + 0 * 0;
//	tempvar = delayRread + 0 * 0;

	if (m_EaxPan) {
		pos     = m_DelayR.Pos((int)m_EaxDelayRRead);
		tempvar = m_DelayR[pos];
	}
	else {
		pos     = m_DelayL.Pos((int)m_EaxDelayLRead);
		tempvar = m_DelayL[pos];
	}

	temp2	= m_StateL + tempvar * m_EaxLpfb;

//	delayL[] = ACC + inPortL[0] * lpff;

	pos           = m_DelayL.Pos(0);
	m_DelayL[pos] = temp2 + inPortL * m_EaxLpff;

	m_StateL	  = tempvar * m_EaxLpfb;

//	outPortL = wetlevel : inPortL[1] < tempvar;

	outPortL = Interpolate(inPortL, tempvar, m_EaxWetlevel);

//RightDelayRead:
//	tempvar = delayR[@-16] + 0 * 0;
//	tempvar = delayRread + 0 * 0;

	if (m_EaxPan) {
		pos     = m_DelayL.Pos((int)m_EaxDelayLRead);
		tempvar = m_DelayL[pos];
	}
	else {
		pos     = m_DelayR.Pos((int)m_EaxDelayRRead);
		tempvar = m_DelayR[pos];
	}

	temp2	= m_StateR + tempvar * m_EaxLpfb;

//	delayR[]= ACC + inPortR[0] * lpff;

	pos           = m_DelayR.Pos(0);
	m_DelayR[pos] = temp2 + inPortR * m_EaxLpff;

	m_StateR = tempvar * m_EaxLpfb;

//	outPortR = wetlevel : inPortR[1] < tempvar;

	outPortR = Interpolate(inPortR, tempvar, m_EaxWetlevel);

	*l = Saturate(outPortL);
	*r = Saturate(outPortR);

	Bump();
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::FBRProcess
//
HRESULT CDirectSoundEchoDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut)
{
// { EAX
#define cb cSamples
#define pin pIn
#define pout pOut

	if (m_cChannels == 1) {
		if (m_b8bit) {
			for (;cb > 0; --cb) {
				int i, j;

				i = *(pin+0)-128;
				i *=256;
				j  = i;

				DoOneSample(&i, &j);
				
				i += j;
				i /= 2;
				
				i /= 256;

				*(pout+0) = (unsigned char)(i + 128);
			
				pin  += sizeof(unsigned char);
				pout += sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *psi;
				j =  i;

				DoOneSample(&i, &j);
				
				i += j;
				i /= 2;
				
               	*pso = (short)i;
			
				pin  += sizeof(short);
				pout += sizeof(short);
			}
		}
	}
	else if (m_cChannels == 2) {
		if (m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(unsigned char)) {
				int i, j;

				i = *(pin+0)-128;
				j = *(pin+1)-128;

				i *=256; j *=256;

				DoOneSample(&i, &j);
				
				i /= 256; j /= 256;
				
				*(pout+0) = (unsigned char)(i + 128);
				*(pout+1) = (unsigned char)(j + 128);
			
				pin  += 2 * sizeof(unsigned char);
				pout += 2 * sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *(psi+0);
				j = *(psi+1);

				DoOneSample(&i, &j);
				
               	*(pso+0) = (short)i;
               	*(pso+1) = (short)j;
			
				pin  += 2 * sizeof(short);
				pout += 2 * sizeof(short);
			}
		}
	}
// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::ProcessInPlace
//
HRESULT CDirectSoundEchoDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    return FBRProcess(ulQuanta, pcbData, pcbData);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::SetParam
//

HRESULT CDirectSoundEchoDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
	if (!m_EaxSamplesPerSec) return DMO_E_TYPE_NOT_ACCEPTED;	// NO TYPE!

    switch (dwParamIndex)
    {
// { EAX
	case EFP_Wetdrymix :
		CHECK_PARAM(DSFXECHO_WETDRYMIX_MIN, DSFXECHO_WETDRYMIX_MAX);

		PUT_EAX_VALUE(Wetlevel, value / 100);
		break;

	case EFP_Feedback : {
		CHECK_PARAM(DSFXECHO_FEEDBACK_MIN,  DSFXECHO_FEEDBACK_MAX);

		MP_DATA valueFeedbackFactor = value / 100; // ratio out of one instead of 100

		PUT_EAX_VALUE(Lpfb, TOFRACTION(valueFeedbackFactor/2));
		PUT_EAX_VALUE(Lpff, TOFRACTION(sqrt(1.0 - valueFeedbackFactor*valueFeedbackFactor)));
		break;
	}
	case EFP_DelayLeft : {
		CHECK_PARAM(DSFXECHO_LEFTDELAY_MIN, DSFXECHO_LEFTDELAY_MAX);

		PUT_EAX_LVAL(DelayLRead, (value * FractMultiplier) /1000 * m_EaxSamplesPerSec);
		break;
	}
	case EFP_DelayRight : {
		CHECK_PARAM(DSFXECHO_RIGHTDELAY_MIN, DSFXECHO_RIGHTDELAY_MAX);

		PUT_EAX_LVAL(DelayRRead, (value * FractMultiplier) /1000 * m_EaxSamplesPerSec);
		break;

	case EFP_PanDelay : {

		CHECK_PARAM(DSFXECHO_PANDELAY_MIN, DSFXECHO_PANDELAY_MAX);
		
		PUT_EAX_LVAL(Pan, value);
#if 0
		if(value)
		{
			//Panned Delay
			float fval      = m_EaxDelayRRead;
			m_EaxDelayRRead = m_EaxDelayLRead;
			m_EaxDelayLRead = fval;
		}
		else
		{
			//Unpanned Delay
		}
#endif
		break;
	}
	}
// } EAX
    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundEchoDMO::SetAllParameters(LPCDSFXEcho pEcho)
{
	HRESULT hr = S_OK;
	
	// Check that the pointer is not NULL
    if (pEcho == NULL)
    {
        Trace(1,"ERROR: pEcho is NULL\n");
        hr = E_POINTER;
    }

	// Set the parameters
	if (SUCCEEDED(hr)) hr = SetParam(EFP_Wetdrymix, pEcho->fWetDryMix);
    if (SUCCEEDED(hr)) hr = SetParam(EFP_Feedback, pEcho->fFeedback);
    if (SUCCEEDED(hr)) hr = SetParam(EFP_DelayLeft, pEcho->fLeftDelay);
    if (SUCCEEDED(hr)) hr = SetParam(EFP_DelayRight, pEcho->fRightDelay);
    if (SUCCEEDED(hr)) hr = SetParam(EFP_PanDelay, (float)pEcho->lPanDelay);

    m_fDirty = true;
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundEchoDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundEchoDMO::GetAllParameters(LPDSFXEcho pEcho)
{
    HRESULT hr = S_OK;
	MP_DATA mpd;

	if (pEcho == NULL)
	{
		return E_POINTER;
	}
	
#define GET_PARAM(x,y) \
	if (SUCCEEDED(hr)) { \
		hr = GetParam(x, &mpd);	\
		if (SUCCEEDED(hr)) pEcho->y = mpd; \
	}

#define GET_PARAM_LONG(x,y) \
	if (SUCCEEDED(hr)) { \
		hr = GetParam(x, &mpd);	\
		if (SUCCEEDED(hr)) pEcho->y = (long)mpd; \
	}
    GET_PARAM(EFP_Wetdrymix, fWetDryMix);
    GET_PARAM(EFP_Feedback, fFeedback);
    GET_PARAM(EFP_DelayLeft, fLeftDelay);
    GET_PARAM(EFP_DelayRight, fRightDelay);
    GET_PARAM_LONG(EFP_PanDelay, lPanDelay);

	return hr;
}

// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundEchoDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_ECHO;
    return NOERROR;

} // GetClassID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\echop.h ===
//
//
//
#ifndef _Echop_
#define _Echop_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

#define cALLPASS		((float).61803398875)	// 1-x^2=x.
#define RVB_LP_COEF		((float).1)
#define MAXALLPASS		cALLPASS

class CDirectSoundEchoDMO : 
    public CDirectSoundDMO, 
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXEcho,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundEchoDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundEchoDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // Note that an Init function also exists in the CPCMDMO base class and it can be overridden
    // to provide initialization for the effect's actual audio processing.

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
    
	HRESULT Init();

    /* IFilter */
    STDMETHOD(SetAllParameters)             (THIS_ LPCDSFXEcho);
    STDMETHOD(GetAllParameters)             (THIS_ LPDSFXEcho);
    
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropEcho, pPages); }

    // IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXEcho(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXEcho(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXEcho); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();
    
    bool m_fDirty;

protected:
	HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
		HRESULT hr = CPCMDMO::CheckInputType(pmt);
		if (FAILED(hr)) return hr;

		WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
		if (pWave->wFormatTag      != WAVE_FORMAT_PCM ||
			(pWave->wBitsPerSample != 8 && pWave->wBitsPerSample != 16) ||
			(pWave->nChannels      != 1 && pWave->nChannels != 2)) {
			return DMO_E_TYPE_NOT_ACCEPTED;
		}

		return S_OK;
   	}

private:
// { EAX
	__forceinline void DoOneSample(int *l, int *r);

// Declare internal variables.

#define DECLARE_EAX_VARS(type, var) \
	type m_Eax ## var;

	DECLARE_EAX_VARS(long, DelayLRead);
	DECLARE_EAX_VARS(long, DelayRRead);


#define m_EaxSamplesPerSec m_ulSamplingRate

	__forceinline int Saturate(float f) {
								int i;
#ifdef DONTUSEi386
								_asm {
									fld f
									fistp i
								}
#else
								i = (int)f;
#endif 
								if (i > 32767)
									i =  32767;
								else if ( i < -32768)
									i = -32768;
								return(i);
							}


	float		m_StateL, m_StateR;

	__forceinline float Interpolate(float a, float b, float percent)
	{
		percent = a + (b - a) * percent;

		return(percent);
	}


	DECLARE_EAX_VARS(float, Lpfb);
	DECLARE_EAX_VARS(float, Lpff);
	DECLARE_EAX_VARS(float, Wetlevel);
	DECLARE_EAX_VARS(long,  Pan);

	void Bump(void);

	DelayBuffer2<float, 2000, 16> m_DelayL;
	DelayBuffer2<float, 2000, 16> m_DelayR;

// } EAX
};

EXT_STD_CREATE(Echo);

#endif//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\garglep.h ===
//
//
//
#ifndef _Garglep_
#define _Garglep_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

class CDirectSoundGargleDMO : 
    public CDirectSoundDMO,
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXGargle,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundGargleDMO( IUnknown *pUnk, HRESULT *phr);
    ~CDirectSoundGargleDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // The Init function is an override from the  CPCMDMO base class and it provides initialization
    // for the effect's actual audio processing.  Note that InputType must have been set before this
    // occurs in order for this to work.
    HRESULT Init();

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
        
    // IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );

    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropGargle, pPages); }

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXGargle(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXGargle(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXGargle); return S_OK; }

    // IDirectSoundFXGargle
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXGargle);
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXGargle);
    
    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // All of these methods are called by the base class
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT Discontinuity();
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    
    bool m_fDirty;

private:
   // gargle params
   ULONG m_ulShape;
   ULONG m_ulGargleFreqHz;

   // gargle state
   ULONG m_ulPeriod;
   ULONG m_ulPhase;

   BOOL m_bInitialized;
};

EXT_STD_CREATE(Gargle);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\guid.cpp ===
#include <objbase.h>
#include <initguid.h>
#include <mmsystem.h>
#include "dsdmo.h"
#include <medparam.h>
#include <uuids.h>
#include "aecdbgprop.h"

// FIXME: this includes a lot more GUIDs than it needs to (do "strings dsdmo.dll")
//        Maybe it shouldn't need to include medparam.h.  Should that come from dmoguids.lib?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\flangerp.h ===
//
//
//
#ifndef _Flangerp_
#define _Flangerp_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

#define cALLPASS		((float).61803398875)	// 1-x^2=x.
#define RVB_LP_COEF		((float).1)
#define MAXALLPASS		cALLPASS
#define Delay_len       DefineDelayLineSize(8)

class CDirectSoundFlangerDMO : 
    public CDirectSoundDMO, 
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXFlanger,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundFlangerDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundFlangerDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();
    HRESULT Init();

    // Note that an Init function also exists in the CPCMDMO base class and it can be overridden
    // to provide initialization for the effect's actual audio processing.

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
        
    /* IFilter */
    STDMETHOD(SetAllParameters)             (THIS_ LPCDSFXFlanger);
    STDMETHOD(GetAllParameters)             (THIS_ LPDSFXFlanger);
    
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropFlanger, pPages); }

	// IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXFlanger(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXFlanger(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXFlanger); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();
    
    bool m_fDirty;

protected:
	HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
		HRESULT hr = CPCMDMO::CheckInputType(pmt);
		if (FAILED(hr)) return hr;

		WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
		if (pWave->wFormatTag      != WAVE_FORMAT_PCM ||
			(pWave->wBitsPerSample != 8 && pWave->wBitsPerSample != 16) ||
			(pWave->nChannels      != 1 && pWave->nChannels != 2)) {
			return DMO_E_TYPE_NOT_ACCEPTED;
		}

		return S_OK;
   	}

private:
// { EAX
	__forceinline void DoOneSample(int *l, int *r);

// Declare internal variables.

#define DECLARE_EAX_VARS(type, var) \
	type m_Eax ## var;

	DECLARE_EAX_VARS(float, LfoCoef);
	DECLARE_EAX_VARS(float, Wetlevel);
	DECLARE_EAX_VARS(float, FbCoef);
	DECLARE_EAX_VARS(float, DepthCoef);
	DECLARE_EAX_VARS(long,  FixedptrL);
	DECLARE_EAX_VARS(long,  FixedptrR);
	DECLARE_EAX_VARS(float, Depth);
	DECLARE_EAX_VARS(long,  Phase);
	DECLARE_EAX_VARS(float, Delay);
	DECLARE_EAX_VARS(float, Frequency);
	DECLARE_EAX_VARS(long,  Waveform);
//	DECLARE_EAX_VARS(SamplesPerSec);
#define m_EaxSamplesPerSec m_ulSamplingRate

	__forceinline int Saturate(float f) {
								int i;
#ifdef DONTUSEi386
								_asm {
									fld f
									fistp i
								}
#else
								i = (int)f;
#endif 
								if (i > 32767)
									i =  32767;
								else if ( i < -32768)
									i = -32768;
								return(i);
							}


	float		m_StateL, m_StateR;

	__forceinline float Interpolate(float a, float b, float percent)
	{
		percent = a + (b - a) * percent;

		return(percent);
	}

	void Bump(void);

	DWORD			m_ModdelayL1;
	DWORD			m_ModdelayL;
	DWORD			m_DelayptrL;

	DWORD			m_ModdelayR1;
	DWORD			m_ModdelayR;
	DWORD			m_DelayptrR;

	float			m_LfoState[2];

	DelayBuffer2<float, Delay_len, 3> m_DelayL;
	DelayBuffer2<float, Delay_len, 3> m_DelayR;
	DelayBuffer2<float, 0, 3> m_DryDelayL;
	DelayBuffer2<float, 0, 3> m_DryDelayR;

// } EAX
};

EXT_STD_CREATE(Flanger);

#endif//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\gargle.cpp ===
#include <windows.h>
#include "garglep.h"
#include "clone.h"

STD_CREATE(Gargle)

#define DEFAULT_GARGLE_RATE 20

CDirectSoundGargleDMO::CDirectSoundGargleDMO( IUnknown *pUnk, HRESULT *phr ) 
    :CComBase( pUnk,  phr ),
    m_ulShape(0),
    m_ulGargleFreqHz(DEFAULT_GARGLE_RATE),
    m_fDirty(true),
    m_bInitialized(FALSE)
{
    
}

HRESULT CDirectSoundGargleDMO::NDQueryInterface(REFIID riid, void **ppv) {

    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXGargle)
    {
        return GetInterface((IDirectSoundFXGargle*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

CDirectSoundGargleDMO::~CDirectSoundGargleDMO()
{
}

const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                        max,                        neutral,                    unit text,  label,          pwchText??
    GFP_Rate,       MPT_INT,    g_capsAll,  DSFXGARGLE_RATEHZ_MIN,      DSFXGARGLE_RATEHZ_MAX,      20,                         L"Hz",      L"Rate",        L"",
    GFP_Shape,      MPT_ENUM,   g_capsAll,  DSFXCHORUS_WAVE_TRIANGLE,   DSFXGARGLE_WAVE_SQUARE,     DSFXGARGLE_WAVE_TRIANGLE,   L"",        L"WaveShape",   L"Triangle,Square",
};

HRESULT CDirectSoundGargleDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

HRESULT CDirectSoundGargleDMO::Init()
{
    // compute the period
    m_ulPeriod = m_ulSamplingRate / m_ulGargleFreqHz;
    m_bInitialized = TRUE;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundGargleDMO::Clone
//
STDMETHODIMP CDirectSoundGargleDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundGargleDMO, DSFXGargle>(this, pp);
}

HRESULT CDirectSoundGargleDMO::Discontinuity() {
   m_ulPhase = 0;
   return NOERROR;
}

HRESULT CDirectSoundGargleDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut) {
   if (!m_bInitialized)
      return DMO_E_TYPE_NOT_SET;
   
   // test code
   //memcpy(pOut, pIn, cSamples * m_cChannels * (m_b8bit ? 1 : 2));
   //return NOERROR;

   DWORD cSample, cChannel;
   for (cSample = 0; cSample < cSamples; cSample++) {
      // If m_Shape is 0 (triangle) then we multiply by a triangular waveform
      // that runs 0..Period/2..0..Period/2..0... else by a square one that
      // is either 0 or Period/2 (same maximum as the triangle) or zero.
      //
      // m_Phase is the number of samples from the start of the period.
      // We keep this running from one call to the next,
      // but if the period changes so as to make this more
      // than Period then we reset to 0 with a bang.  This may cause
      // an audible click or pop (but, hey! it's only a sample!)
      //
      ++m_ulPhase;
      if (m_ulPhase > m_ulPeriod)
         m_ulPhase = 0;

      ULONG ulM = m_ulPhase;      // m is what we modulate with

      if (m_ulShape == 0) {   // Triangle
          if (ulM > m_ulPeriod / 2)
              ulM = m_ulPeriod - ulM;  // handle downslope
      } else {             // Square wave
          if (ulM <= m_ulPeriod / 2)
             ulM = m_ulPeriod / 2;
          else
             ulM = 0;
      }

      for (cChannel = 0; cChannel < m_cChannels; cChannel++) {
         if (m_b8bit) {
             // sound sample, zero based
             int i = pIn[cSample * m_cChannels + cChannel] - 128;
             // modulate
             i = (i * (signed)ulM * 2) / (signed)m_ulPeriod;
             // 8 bit sound uses 0..255 representing -128..127
             // Any overflow, even by 1, would sound very bad.
             // so we clip paranoically after modulating.
             // I think it should never clip by more than 1
             //
             if (i > 127)
                i = 127;
             if (i < -128)
                i = -128;
             // reset zero offset to 128
             pOut[cSample * m_cChannels + cChannel] = (unsigned char)(i + 128);
   
         } else {
             // 16 bit sound uses 16 bits properly (0 means 0)
             // We still clip paranoically
             //
             int i = ((short*)pIn)[cSample * m_cChannels + cChannel];
             // modulate
             i = (i * (signed)ulM * 2) / (signed)m_ulPeriod;
             // clip
             if (i > 32767)
                i = 32767;
             if (i < -32768)
                i = -32768;
             ((short*)pOut)[cSample * m_cChannels + cChannel] = (short)i;
         }
      }
   }
   return NOERROR;
}


// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// a gargle in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundGargleDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_GARGLE;
    return NOERROR;

} // GetClassID


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundGargleDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundGargleDMO::SetAllParameters(THIS_ LPCDSFXGargle pParm)
{
	HRESULT hr = S_OK;
	
	// Check that the pointer is not NULL
    if (pParm == NULL)
    {
        Trace(1,"ERROR: pParm is NULL\n");
        hr = E_POINTER;
    }

	// Set the parameters
	if (SUCCEEDED(hr)) hr = SetParam(GFP_Rate, static_cast<MP_DATA>(pParm->dwRateHz));
    if (SUCCEEDED(hr)) hr = SetParam(GFP_Shape, static_cast<MP_DATA>(pParm->dwWaveShape));
            
    m_fDirty = true;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundGargleDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundGargleDMO::GetAllParameters(THIS_ LPDSFXGargle pParm)
{	
    HRESULT hr = S_OK;
    MP_DATA var;

    if (pParm == NULL)
    {
    	return E_POINTER;
    }

#define GET_PARAM_DWORD(x,y) \
	if (SUCCEEDED(hr)) { \
		hr = GetParam(x, &var);	\
		if (SUCCEEDED(hr)) pParm->y = (DWORD)var; \
	}

	
    GET_PARAM_DWORD(GFP_Rate, dwRateHz);
    GET_PARAM_DWORD(GFP_Shape, dwWaveShape);
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundGargleDMO::SetParam
//
HRESULT CDirectSoundGargleDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
    switch (dwParamIndex)
    {
    case GFP_Rate:
        CHECK_PARAM(DSFXGARGLE_RATEHZ_MIN,DSFXGARGLE_RATEHZ_MAX);
        m_ulGargleFreqHz = (unsigned)value;
        if (m_ulGargleFreqHz < 1) m_ulGargleFreqHz = 1;
        if (m_ulGargleFreqHz > 1000) m_ulGargleFreqHz = 1000;
        Init();  // FIXME - temp hack (sets m_bInitialized flag)
        break;

    case GFP_Shape:
        CHECK_PARAM(DSFXGARGLE_WAVE_TRIANGLE,DSFXGARGLE_WAVE_SQUARE);
        m_ulShape = (unsigned)value;
        break;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundGargleDMO::ProcessInPlace
//
HRESULT CDirectSoundGargleDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    return FBRProcess(ulQuanta, pcbData, pcbData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\ksdbgprop.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ksdbgprop.h
 *  Content:    AEC KS Debug stuff
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/16/2000  dandinu Created.
 *
 ***************************************************************************/

/*
#if !defined(_KSMEDIA_)
#error KSMEDIA.H must be included before DBGPROP.H
#endif // !defined(_KS_)
*/
#if !defined(_KSDBGPROP_)
#define _KSDBGPROP_
/*
typedef struct {
    KSNODEPROPERTY  NodeProperty;
    ULONG           DebugId;
    ULONG           Reserved;
} KSDEBUGNODEPROPERTY, *PKSDEBUGNODEPROPERTY;
*/

//===========================================================================
//===========================================================================

// KSPROPSETID_DebugAecValue : {24366808-DB14-40c8-883E-5B45DD597774}

#define STATIC_KSPROPSETID_DebugAecValue\
    0x24366808, 0xdb14, 0x40c8, 0x88, 0x3e, 0x5b, 0x45, 0xdd, 0x59, 0x77, 0x74
DEFINE_GUIDSTRUCT("24366808-DB14-40c8-883E-5B45DD597774",KSPROPSETID_DebugAecValue);
#define KSPROPSETID_DebugAecValue DEFINE_GUIDNAMED(KSPROPSETID_DebugAecValue)

typedef enum {
    KSPROPERTY_DEBUGAECVALUE_ALL,
    KSPROPERTY_DEBUGAECVALUE_SYNCHSTREAM,
    KSPROPERTY_DEBUGAECVALUE_NUMBANDS,
    KSPROPERTY_DEBUGAECARRAY_NOISEMAGNITUDE
} KSPROPERTY_DEBUGAECVALUE;


//===========================================================================
//===========================================================================

// KSPROPSETID_DebugAecArray: {CF8A9F7D-950E-46d5-93E5-C04C77DC866B}

#define STATIC_KSPROPSETID_DebugAecArray\
    0xcf8a9f7d, 0x950e, 0x46d5, 0x93, 0xe5, 0xc0, 0x4c, 0x77, 0xdc, 0x86, 0x6b
DEFINE_GUIDSTRUCT("CF8A9F7D-950E-46d5-93E5-C04C77DC866B",KSPROPSETID_DebugAecArray);
#define KSPROPSETID_DebugAecArray DEFINE_GUIDNAMED(KSPROPSETID_DebugAecArray)



#endif // !defined(_KSDBGPROP_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\kshlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       kshlp.h
 *  Content:    WDM/CSA helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/16/2000  jstokes Created.
 *
 ***************************************************************************/

#ifndef __KSHLP_H__
#define __KSHLP_H__

#include <windows.h>
#include <ks.h>
#include <ksmedia.h>

#define KSPIN_DATAFLOW_CAPTURE  KSPIN_DATAFLOW_OUT
#define KSPIN_DATAFLOW_RENDER   KSPIN_DATAFLOW_IN

// Device-specific DirectSound property sets
typedef struct tagKSDSPROPERTY
{
    GUID    PropertySet;
    ULONG   PropertyId;
    ULONG   NodeId;
    ULONG   AccessFlags;
} KSDSPROPERTY, *PKSDSPROPERTY;

// KS stream data
typedef struct tagKSSTREAMIO
{
    KSSTREAM_HEADER Header;
    OVERLAPPED      Overlapped;
    BOOL            fPendingIrp;
} KSSTREAMIO, *PKSSTREAMIO;

// System audio device properties
typedef struct tagKSSADPROPERTY
{
    KSPROPERTY  Property;
    ULONG       DeviceId;
    ULONG       Reserved;
} KSSADPROPERTY, *PKSSADPROPERTY;

// Topology node information
typedef struct tagKSNODE
{
    ULONG   NodeId;
    ULONG   CpuResources;
} KSNODE, *PKSNODE;

typedef struct tagKSVOLUMENODE
{
    KSNODE                      Node;
    KSPROPERTY_STEPPING_LONG    VolumeRange;
} KSVOLUMENODE, *PKSVOLUMENODE;

// Our own version of NTSTATUS
typedef LONG NTSTATUS;

#define NT_SUCCESS(s)       ((NTSTATUS)(s) >= 0)
#define NT_INFORMATION(s)   ((ULONG)(s) >> 30 == 1)
#define NT_WARNING(s)       ((ULONG)(s) >> 30 == 2)
#define NT_ERROR(s)         ((ULONG)(s) >> 30 == 3)

// Reserved node identifiers
#define NODE_UNINITIALIZED  0xFFFFFFFF
#define NODE_WILDCARD       0xFFFFFFFE

#define NODE_PIN_UNINITIALIZED  0xFFFFFFFF

#define IS_VALID_NODE(nodeid) \
            (NODE_UNINITIALIZED != (nodeid))

// Node implementation
#define KSAUDIO_CPU_RESOURCES_UNINITIALIZED 'ENON'

#define IS_HARDWARE_NODE(impl) \
            (KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU == (impl))

#define IS_SOFTWARE_NODE(impl) \
            (KSAUDIO_CPU_RESOURCES_HOST_CPU == (impl))

#ifdef __cplusplus

HRESULT 
PostDevIoctl
(
    HANDLE                  hDevice, 
    DWORD                   dwControlCode, 
    LPVOID                  pvIn            = NULL,
    DWORD                   cbIn            = 0,
    LPVOID                  pvOut           = NULL,
    DWORD                   cbOut           = 0,
    LPDWORD                 pcbReturned     = NULL,
    LPOVERLAPPED            pOverlapped     = NULL
);

HRESULT 
KsGetProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned     = NULL
);

HRESULT 
KsSetProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    LPVOID                  pvData, 
    ULONG                   cbData
);

HRESULT 
KsGetPinProperty
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    ULONG                   ulPinId, 
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned = NULL
);

HRESULT 
KsSetPinProperty
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    ULONG                   ulPinId, 
    LPVOID                  pvData, 
    ULONG                   cbData
);

HRESULT 
KsGetNodeProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    ULONG                   ulNodeId, 
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned     = NULL
);

HRESULT 
KsSetNodeProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    ULONG                   ulNodeId, 
    LPVOID                  pvData, 
    ULONG                   cbData
);

HRESULT 
KsGetMultiplePinProperties
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    ULONG                   ulPinId, 
    PKSMULTIPLE_ITEM *      ppKsMultipleItem
);

HRESULT 
KsGetMultipleTopologyProperties
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    PKSMULTIPLE_ITEM *      ppKsMultipleItem
);


HRESULT
KsSetTopologyNodeEnable
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    BOOL                    fEnable
);

HRESULT
KsGetTopologyNodeEnable
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    PBOOL                   pfEnable
);

HRESULT
KsTopologyNodeReset
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    BOOL                    fReset
);

#endif // __cplusplus

#endif // __KSHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\map.h ===
//
//
//
#ifndef _MicArrayp_
#define _MicArrayp_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

class CDirectSoundCaptureMicArrayDMO :
    public CDirectSoundDMO,
    public CParamsManager,
    public IDirectSoundCaptureFXMicArray,
    public CComBase
{
public:
    CDirectSoundCaptureMicArrayDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundCaptureMicArrayDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);
   
    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // The Init function is an override from the CPCMDMO base class and it provides initialization
    // for the effect's actual audio processing.  Note that InputType must have been set before this
    // occurs in order for this to work.
    HRESULT Init();

    STDMETHOD(Clone)                        (THIS_ IMediaObjectInPlace **);

    /* IFilter */
    STDMETHOD(SetAllParameters)             (THIS_ LPCDSCFXMicArray);
    STDMETHOD(GetAllParameters)             (THIS_ LPDSCFXMicArray);

    // IMediaParams overrides
    STDMETHOD(SetParam)                     (THIS_ DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager = false);
    STDMETHOD(GetParam)                     (THIS_ DWORD dwParamIndex, MP_DATA* value);
   
    // All of these methods are called by the base class
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT Discontinuity();
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    
    BOOL m_fDirty;

private:
    BOOL m_fEnable;
    BOOL m_fReset;
    BOOL m_bInitialized;
};

EXT_STD_CAPTURE_CREATE(MicArray);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\oledll.h ===
//
// OleDLL.h
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\ma.cpp ===
#include <windows.h>
#include "map.h"
#include "kshlp.h"
#include "clone.h"

STD_CAPTURE_CREATE(MicArray)

STDMETHODIMP CDirectSoundCaptureMicArrayDMO::NDQueryInterface
(
    REFIID riid, 
    LPVOID *ppv
)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundCaptureFXMicArray)
    {
        return GetInterface((IDirectSoundCaptureFXMicArray*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

CDirectSoundCaptureMicArrayDMO::CDirectSoundCaptureMicArrayDMO( IUnknown *pUnk, HRESULT *phr ) :
    CComBase( pUnk, phr ),
    m_fEnable(FALSE),
    m_fReset(FALSE),
    m_fDirty(FALSE),
    m_bInitialized(FALSE)
{
}

CDirectSoundCaptureMicArrayDMO::~CDirectSoundCaptureMicArrayDMO()
{
}

const MP_CAPS g_MicArrayCapsAll = 0;
static ParamInfo g_params[] =
{
//  index           type        caps           min,                        max,                        neutral,                    unit text,  label,          pwchText??
    MAP_Enable,    MPT_BOOL,   g_MicArrayCapsAll,  0,                          1,                          0,                          L"",        L"",            L"",
    MAP_Reset,     MPT_BOOL,   g_MicArrayCapsAll,  0,                          1,                          0,                          L"",        L"",            L""
};

HRESULT CDirectSoundCaptureMicArrayDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

HRESULT CDirectSoundCaptureMicArrayDMO::Init()
{
    m_bInitialized = TRUE;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureMicArrayDMO::Clone
//
STDMETHODIMP CDirectSoundCaptureMicArrayDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundCaptureMicArrayDMO, DSCFXMicArray>(this, pp);
}

HRESULT CDirectSoundCaptureMicArrayDMO::Discontinuity() {
   return NOERROR;
}

HRESULT CDirectSoundCaptureMicArrayDMO::FBRProcess
(
    DWORD cSamples, 
    BYTE *pIn, 
    BYTE *pOut
) 
{
   if (!m_bInitialized)
      return DMO_E_TYPE_NOT_SET;

   return NOERROR;
}

// ==============Implementation of the private IMicArray interface ==========
// ==================== needed to support the property page ===============

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureMicArrayDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundCaptureMicArrayDMO::SetAllParameters(LPCDSCFXMicArray pParm)
{
    HRESULT hr = S_OK;
	
	// Check that the pointer is not NULL
    if (pParm == NULL)
    {
        Trace(1,"ERROR: pParm is NULL\n");
        hr = E_POINTER;
    }

	// Set the parameters
	if (SUCCEEDED(hr)) hr = SetParam(MAP_Enable, static_cast<MP_DATA>(pParm->fEnable));
	if (SUCCEEDED(hr)) hr = SetParam(MAP_Reset, static_cast<MP_DATA>(pParm->fReset));
            
    m_fDirty = true;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureMicArrayDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundCaptureMicArrayDMO::GetAllParameters(LPDSCFXMicArray pParm)
{
    if (pParm == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    MP_DATA var;

    GetParam(MAP_Enable, &var);
    pParm->fEnable = (BOOL)var;
    
    GetParam(MAP_Reset, &var);
    pParm->fReset = (BOOL)var;
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureMicArrayDMO::SetParam
//
STDMETHODIMP CDirectSoundCaptureMicArrayDMO::SetParam
(
    DWORD dwParamIndex, 
    MP_DATA value, 
    bool fSkipPasssingToParamManager
)
{
    HRESULT hr = S_OK;
    BOOL fEnable = (BOOL)value;
    BOOL fReset = (BOOL)value;

    switch (dwParamIndex)
    {
    case MAP_Enable:
        if (fEnable)
        {
            hr = KsSetTopologyNodeEnable(m_hPin, m_ulNodeId, fEnable);
            if(SUCCEEDED(hr)) m_fEnable = fEnable;
        }
        break;
    case MAP_Reset:
        if (fReset)
        {
            hr = KsTopologyNodeReset(m_hPin, m_ulNodeId, fReset);
            if(SUCCEEDED(hr)) m_fReset = fReset;
        }
        break;
    }

    if (SUCCEEDED(hr))
    {
        Init();  // FIXME - temp hack (sets m_bInitialized flag)
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    return (FAILED(hr) || fSkipPasssingToParamManager) ? hr : CParamsManager::SetParam(dwParamIndex, value);

}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureAecDMO::GetParam
//
STDMETHODIMP CDirectSoundCaptureMicArrayDMO::GetParam
(
    DWORD dwParamIndex, 
    MP_DATA* value
)
{
    HRESULT hr = S_OK;
    BOOL fTemp;

    switch (dwParamIndex)
    {
    case MAP_Enable:
        hr = KsGetTopologyNodeEnable(m_hPin, m_ulNodeId, &fTemp);
        if(SUCCEEDED(hr)) 
        {
            m_fEnable = fTemp;
            *value = (MP_DATA)fTemp;
        }
        break;
    case MAP_Reset:
        *value = (MP_DATA)m_fReset;
        break;
    }

    return hr;

}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureMicArrayDMO::ProcessInPlace
//
HRESULT CDirectSoundCaptureMicArrayDMO::ProcessInPlace
(
    ULONG ulQuanta, 
    LPBYTE pcbData, 
    REFERENCE_TIME rtStart, 
    DWORD dwFlags
)
{
    // Update parameter values from any curves that may be in effect.
    // Do this in the same order as SetAllParameters in case there are any interdependencies.

    return FBRProcess(ulQuanta, pcbData, pcbData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\kshlp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       kshlp.cpp
 *  Content:    WDM/CSA helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/16/2000  jstokes Created.
 *  03/09/2001  duganp  Fixed return code mistranslation.
 *
 ***************************************************************************/

#include <windows.h>
#include <ks.h>
#include <ksmedia.h>
#include "ksdbgprop.h"
#include "kshlp.h"

#include <devioctl.h>
#include "runtime.h"


/***************************************************************************
 *
 * SyncIoctl
 *
 ***************************************************************************/

static BOOL SyncIoctl
(
    IN      HANDLE  handle,
    IN      ULONG   ulIoctl,
    IN      PVOID   pvInBuffer  OPTIONAL,
    IN      ULONG   ulInSize,
    OUT     PVOID   pvOutBuffer OPTIONAL,
    IN      ULONG   ulOutSize,
    OUT     PULONG  pulBytesReturned
)
{
    OVERLAPPED overlapped;
    memset(&overlapped, 0, sizeof overlapped);
    overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!overlapped.hEvent)
    {
        return FALSE;
    }

    BOOL fResult = DeviceIoControl(handle,
                                   ulIoctl,
                                   pvInBuffer,
                                   ulInSize,
                                   pvOutBuffer,
                                   ulOutSize,
                                   pulBytesReturned,
                                   &overlapped);

    DWORD dwError = GetLastError();

    if (!fResult && dwError == ERROR_IO_PENDING)
    {
        if (WaitForSingleObject(overlapped.hEvent, INFINITE) != WAIT_FAILED)
        {
            fResult = TRUE;
        }
    }
    else if (!fResult)
    {
        if  (   (ulIoctl == IOCTL_KS_PROPERTY)
            &&  (ulOutSize == 0)
            &&  (dwError == ERROR_MORE_DATA)
            )
        {
            fResult = TRUE;
        }
        else
        {
            *pulBytesReturned = 0;
        }
    }

    CloseHandle(overlapped.hEvent);

    return fResult;
}


/***************************************************************************
 *
 *  KsGetProperty
 *
 *  Description:
 *      Retrieves a particular property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      DWORD [in]: property id.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetProperty"

HRESULT
KsGetProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSPROPERTY              Property;
    HRESULT                 hr;

    Property.Set = guidPropertySet;
    Property.Id = ulPropertyId;
    Property.Flags = KSPROPERTY_TYPE_GET;

    if (SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &Property, sizeof Property, pvData, cbData, pcbDataReturned))
    {
        hr = cbData ? S_OK : S_FALSE;
    }
    else
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


/***************************************************************************
 *
 *  KsSetProperty
 *
 *  Description:
 *      Sets a particular property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      DWORD [in]: property id.
 *      LPVOID [in]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetProperty"

HRESULT
KsSetProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSPROPERTY              Property;
    HRESULT                 hr;
    ULONG                   ulBytesReturned;

    Property.Set = guidPropertySet;
    Property.Id = ulPropertyId;
    Property.Flags = KSPROPERTY_TYPE_SET;

    if (SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &Property, sizeof Property, pvData, cbData, &ulBytesReturned))
    {
        hr = cbData ? S_OK : S_FALSE;
    }
    else
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


/***************************************************************************
 *
 *  KsGetPinProperty
 *
 *  Description:
 *      Retrieves a particular property on a pin.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: property id.
 *      DWORD [in]: pin id.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetPinProperty"

HRESULT
KsGetPinProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulPinId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSP_PIN                 Pin;
    HRESULT                 hr;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = ulPropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;

    Pin.PinId = ulPinId;
    Pin.Reserved = 0;

    if (SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &Pin, sizeof Pin, pvData, cbData, pcbDataReturned))
    {
        hr = cbData ? S_OK : S_FALSE;
    }
    else
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


/***************************************************************************
 *
 *  KsSetPinProperty
 *
 *  Description:
 *      Sets a particular property on a pin.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: property id.
 *      DWORD [in]: pin id.
 *      LPVOID [out]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetPinProperty"

HRESULT
KsSetPinProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulPinId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSP_PIN                 Pin;
    HRESULT                 hr;
    ULONG                   ulBytesReturned;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = ulPropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_SET;

    Pin.PinId = ulPinId;
    Pin.Reserved = 0;

    if (SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &Pin, sizeof Pin, pvData, cbData, &ulBytesReturned))
    {
        hr = cbData ? S_OK : S_FALSE;
    }
    else
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


/***************************************************************************
 *
 *  KsGetNodeProperty
 *
 *  Description:
 *      Retrieves a particular property on a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      ULONG [in]: flags.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetNodeProperty"

HRESULT
KsGetNodeProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSNODEPROPERTY          NodeProperty;
    HRESULT                 hr;

    NodeProperty.Property.Set = guidPropertySet;
    NodeProperty.Property.Id = ulPropertyId;
    NodeProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    NodeProperty.NodeId = ulNodeId;
    NodeProperty.Reserved = 0;

    if (SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &NodeProperty, sizeof(NodeProperty), pvData, cbData, pcbDataReturned))
    {
        hr = cbData ? S_OK : S_FALSE;
    }
    else
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


/***************************************************************************
 *
 *  KsSetNodeProperty
 *
 *  Description:
 *      Sets a particular property on a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      ULONG [in]: flags.
 *      LPVOID [in]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetNodeProperty"

HRESULT
KsSetNodeProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSNODEPROPERTY          NodeProperty;
    HRESULT                 hr;
    ULONG                   ulBytesReturned;

    NodeProperty.Property.Set = guidPropertySet;
    NodeProperty.Property.Id = ulPropertyId;
    NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    NodeProperty.NodeId = ulNodeId;
    NodeProperty.Reserved = 0;

    if (SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &NodeProperty, sizeof NodeProperty, pvData, cbData, &ulBytesReturned))
    {
        hr = cbData ? S_OK : S_FALSE;
    }
    else
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


/***************************************************************************
 *
 *  KsGetDebugNodeProperty
 *
 *  Description:
 *      Retrieves a particular property on a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      ULONG [in]: flags.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/
/*
#undef DPF_FNAME
#define DPF_FNAME "KsGetDebugNodeProperty"

HRESULT
KsGetDebugNodeProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    ULONG                   ulDebugId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSDEBUGNODEPROPERTY     DebugNodeProperty;
    HRESULT                 hr;

    DebugNodeProperty.NodeProperty.Property.Set = guidPropertySet;
    DebugNodeProperty.NodeProperty.Property.Id = ulPropertyId;
    DebugNodeProperty.NodeProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    DebugNodeProperty.NodeProperty.NodeId = ulNodeId;
    DebugNodeProperty.NodeProperty.Reserved = 0;

    DebugNodeProperty.DebugId = ulDebugId;
    DebugNodeProperty.Reserved = 0;

    hr = SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &DebugNodeProperty, sizeof DebugNodeProperty, pvData, cbData, pcbDataReturned);

    return hr;
}
*/

/***************************************************************************
 *
 *  KsSetDebugNodeProperty
 *
 *  Description:
 *      Sets a particular property on a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      ULONG [in]: flags.
 *      LPVOID [in]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/
/*
#undef DPF_FNAME
#define DPF_FNAME "KsSetDebugNodeProperty"

HRESULT
KsSetDebugNodeProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    ULONG                   ulDebugId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSDEBUGNODEPROPERTY     DebugNodeProperty;
    HRESULT                 hr;
    ULONG                   ulBytesReturned;

    DebugNodeProperty.NodeProperty.Property.Set = guidPropertySet;
    DebugNodeProperty.NodeProperty.Property.Id = ulPropertyId;
    DebugNodeProperty.NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    DebugNodeProperty.NodeProperty.NodeId = ulNodeId;
    DebugNodeProperty.NodeProperty.Reserved = 0;

    DebugNodeProperty.DebugId = ulDebugId;
    DebugNodeProperty.Reserved = 0;

    hr = SyncIoctl(hDevice, IOCTL_KS_PROPERTY, &DebugNodeProperty, sizeof DebugNodeProperty, pvData, cbData, &ulBytesReturned);

    return hr;
}
*/

/***************************************************************************
 *
 *  KsSetTopologyNodeEnable
 *
 *  Description:
 *      Enables or disables a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: node id.
 *      BOOL [in]: enable value.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetTopologyNodeEnable"

HRESULT
KsSetTopologyNodeEnable
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    BOOL                    fEnable
)
{
    return KsSetNodeProperty(hDevice, KSPROPSETID_TopologyNode, KSPROPERTY_TOPOLOGYNODE_ENABLE, ulNodeId, &fEnable, sizeof fEnable);
}


/***************************************************************************
 *
 *  KsGetTopologyNodeEnable
 *
 *  Description:
 *      Gets the value for the topology node's enable flag.
 *
 *  Arguments:
 *      HANDLE [in]: pin id.
 *      ULONG [in]: node id.
 *      PBOOL [out]: receives enable flag.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetTopologyNodeEnable"

HRESULT
KsGetTopologyNodeEnable
(
    HANDLE                      hDevice,
    ULONG                       ulNodeId,
    PBOOL                       pEnable
)
{
    return KsGetNodeProperty(hDevice, KSPROPSETID_TopologyNode, KSPROPERTY_TOPOLOGYNODE_ENABLE, ulNodeId, pEnable, sizeof BOOL);
}


/***************************************************************************
 *
 *  KsTopologyNodeReset
 *
 *  Description:
 *      Resets a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: node id.
 *      BOOL [in]: enable value.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsTopologyNodeReset"

HRESULT
KsTopologyNodeReset
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    BOOL                    fReset
)
{
    return KsSetNodeProperty(hDevice, KSPROPSETID_TopologyNode, KSPROPERTY_TOPOLOGYNODE_RESET, ulNodeId, &fReset, sizeof fReset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\ns.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ns.cpp
 *  Content:    Noise Suppression DMO implementation.
 *
 ***************************************************************************/

#include <windows.h>
#include "nsp.h"
#include "kshlp.h"
#include "clone.h"

STD_CAPTURE_CREATE(NoiseSuppress)


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::NDQueryInterface
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::NDQueryInterface
(
    REFIID riid,
    LPVOID *ppv
)
{
    IMP_DSDMO_QI(riid, ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundCaptureFXNoiseSuppress)
    {
        return GetInterface((IDirectSoundCaptureFXNoiseSuppress*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
    {
        return CComBase::NDQueryInterface(riid, ppv);
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO constructor
//
CDirectSoundCaptureNoiseSuppressDMO::CDirectSoundCaptureNoiseSuppressDMO(IUnknown *pUnk, HRESULT *phr)
    : CComBase(pUnk, phr),
    m_fEnable(FALSE),
    m_fDirty(FALSE),
    m_bInitialized(FALSE)
{
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO destructor
//
CDirectSoundCaptureNoiseSuppressDMO::~CDirectSoundCaptureNoiseSuppressDMO()
{
}


const MP_CAPS g_NsCapsAll = 0;
static ParamInfo g_params[] =
{
//  index           type        caps            min,    max,    neutral,    unit text,  label,  pwchText??
    NSP_Enable,     MPT_BOOL,   g_NsCapsAll,    0,      1,      0,          L"",        L"",    L"",
};


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::InitOnCreation
//
HRESULT CDirectSoundCaptureNoiseSuppressDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof g_params / sizeof *g_params, g_params);
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::Init
//
HRESULT CDirectSoundCaptureNoiseSuppressDMO::Init()
{
    m_bInitialized = TRUE;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::Clone
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::Clone(IMediaObjectInPlace **pp)
{
    return StandardDMOClone<CDirectSoundCaptureNoiseSuppressDMO, DSCFXNoiseSuppress>(this, pp);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::Discontinuity
//
HRESULT CDirectSoundCaptureNoiseSuppressDMO::Discontinuity()
{
    return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::FBRProcess
//
HRESULT CDirectSoundCaptureNoiseSuppressDMO::FBRProcess
(
    DWORD cSamples,
    BYTE *pIn,
    BYTE *pOut
)
{
   if (!m_bInitialized)
      return DMO_E_TYPE_NOT_SET;

   return NOERROR;
}


// ==============Implementation of the private INoiseSuppress interface ==========
// ==================== needed to support the property page ===============


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::SetAllParameters(LPCDSCFXNoiseSuppress pParm)
{
    if (pParm == NULL)
    {
        Trace(1, "ERROR: pParm is NULL\n");
        return E_POINTER;
    }

    HRESULT hr = SetParam(NSP_Enable, static_cast<MP_DATA>(pParm->fEnable));
    if (SUCCEEDED(hr))
    {
        m_fDirty = true;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::GetAllParameters(LPDSCFXNoiseSuppress pParm)
{
    if (pParm == NULL)
    {
        return E_POINTER;
    }

    MP_DATA var;
    HRESULT hr = GetParam(NSP_Enable, &var);
    if (SUCCEEDED(hr))
    {
        pParm->fEnable = (BOOL)var;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::Reset
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::Reset()
{
    return KsTopologyNodeReset(m_hPin, m_ulNodeId, true);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::SetParam
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::SetParam
(
    DWORD dwParamIndex,
    MP_DATA value,
    bool fSkipPasssingToParamManager
)
{
    HRESULT hr = S_OK;

    switch (dwParamIndex)
    {
        case NSP_Enable:
            if ((BOOL)value != m_fEnable)
            {
                hr = KsSetTopologyNodeEnable(m_hPin, m_ulNodeId, (BOOL)value);
                if (SUCCEEDED(hr)) m_fEnable = (BOOL)value;
            }
            break;
    }

    if (SUCCEEDED(hr))
    {
        Init();  // FIXME - temp hack (sets m_bInitialized flag)
    }

    // Let the base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're
    // calling the function internally using values that came from the base class --
    // thus there's no need to tell it values it already knows.
    return (FAILED(hr) || fSkipPasssingToParamManager) ? hr : CParamsManager::SetParam(dwParamIndex, value);
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::GetParam
//
STDMETHODIMP CDirectSoundCaptureNoiseSuppressDMO::GetParam
(
    DWORD dwParamIndex,
    MP_DATA* value
)
{
    HRESULT hr = S_OK;
    BOOL fTemp;

    switch (dwParamIndex)
    {
    case NSP_Enable:
        hr = KsGetTopologyNodeEnable(m_hPin, m_ulNodeId, &fTemp);
        if (SUCCEEDED(hr))
        {
            m_fEnable = fTemp;
            *value = (MP_DATA)fTemp;
        }
        break;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundCaptureNoiseSuppressDMO::ProcessInPlace
//
HRESULT CDirectSoundCaptureNoiseSuppressDMO::ProcessInPlace
(
    ULONG ulQuanta,
    LPBYTE pcbData,
    REFERENCE_TIME rtStart,
    DWORD dwFlags
)
{
    // Update parameter values from any curves that may be in effect.
    // Do this in the same order as SetAllParameters in case there are any interdependencies.

    return FBRProcess(ulQuanta, pcbData, pcbData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\nsp.h ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       nsp.h
 *  Content:    Noise Suppression DMO declarations.
 *
 ***************************************************************************/

#ifndef _NoiseSuppressp_
#define _NoiseSuppressp_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

class CDirectSoundCaptureNoiseSuppressDMO :
    public CDirectSoundDMO,
    public CParamsManager,
    public IDirectSoundCaptureFXNoiseSuppress,
    public CComBase
{
public:
    CDirectSoundCaptureNoiseSuppressDMO(IUnknown *pUnk, HRESULT *phr);
    ~CDirectSoundCaptureNoiseSuppressDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // The Init function is an override from the CPCMDMO base class and it provides initialization
    // for the effect's actual audio processing.  Note that InputType must have been set before this
    // occurs in order for this to work.
    HRESULT Init();

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);

    // IDirectSoundCaptureFXNoiseSuppress methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXNoiseSuppress);
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXNoiseSuppress);
    STDMETHOD(Reset)                (THIS);

    // IMediaParams methods
    STDMETHOD(SetParam)             (THIS_ DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager = false);
    STDMETHOD(GetParam)             (THIS_ DWORD dwParamIndex, MP_DATA* value);

    // All of these methods are called by the base class
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT Discontinuity();
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);

private:
    BOOL m_fDirty;
    BOOL m_fEnable;
    BOOL m_bInitialized;
};

EXT_STD_CAPTURE_CREATE(NoiseSuppress);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\oledll.cpp ===
// oledll.cpp
//
// Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved.
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	 = TEXT("ThreadingModel");
static const TCHAR g_szBoth[]            = TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\propertyhelp.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Helpers for implementation of ISpecifyPropertyPages and IPersistStream
//

#include "PropertyHelp.h"

HRESULT PropertyHelp::GetPages(const CLSID &rclsidPropertyPage, CAUUID * pPages)
{
    pPages->cElems = 1;
    pPages->pElems = static_cast<GUID *>(CoTaskMemAlloc(sizeof(GUID)));
    if (pPages->pElems == NULL)
        return E_OUTOFMEMORY;

    *(pPages->pElems) = rclsidPropertyPage;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\parameq.cpp ===
#include <windows.h>

#include "parameqp.h"
#include "clone.h"

STD_CREATE(ParamEq)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::QueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
STDMETHODIMP CDirectSoundParamEqDMO::NDQueryInterface(THIS_ REFIID riid, LPVOID *ppv)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXParamEq)
    {
        return GetInterface((IDirectSoundFXParamEq*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::CDirectSoundParamEqDMO
//
CDirectSoundParamEqDMO::CDirectSoundParamEqDMO( IUnknown * pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr ),
    m_fDirty(TRUE)
// { EAX: put init data here if any (otherwise use Discontinuity).
// } EAX
{
	m_EaxSamplesPerSec = 48000;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::Init()
//
HRESULT CDirectSoundParamEqDMO::Init()
{
    DSFXParamEq param;

    // Force recalc of all internal parameters
    //
    GetAllParameters(&param);
    SetAllParameters(&param);

    return Discontinuity();
}

const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                        max,                        neutral,                unit text,  label,          pwchText
    PFP_Center,     MPT_FLOAT,  g_capsAll,  DSFXPARAMEQ_CENTER_MIN,     DSFXPARAMEQ_CENTER_MAX,     8000,                   L"",        L"Center",      L"",
    PFP_Bandwidth,  MPT_FLOAT,  g_capsAll,  DSFXPARAMEQ_BANDWIDTH_MIN,  DSFXPARAMEQ_BANDWIDTH_MAX,  12,                     L"",        L"Bandwidth",   L"",
    PFP_Gain,       MPT_FLOAT,  g_capsAll,  DSFXPARAMEQ_GAIN_MIN,       DSFXPARAMEQ_GAIN_MAX,       0,                      L"",        L"Gain",        L"",
};

HRESULT CDirectSoundParamEqDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::~CDirectSoundParamEqDMO
//
CDirectSoundParamEqDMO::~CDirectSoundParamEqDMO() 
{
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::Clone
//
STDMETHODIMP CDirectSoundParamEqDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundParamEqDMO, DSFXParamEq>(this, pp);
}
//
//	Bump - bump the delay pointers.
//
void CDirectSoundParamEqDMO::Bump(void)
{
// EAX {
// }
}


HRESULT CDirectSoundParamEqDMO::Discontinuity() 
{
// { EAX

	m_delayL1 = m_delayL2 = m_delayR1 = m_delayR2 = 0;

// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////


__forceinline void CDirectSoundParamEqDMO::DoOneSampleMono(int *l)
{
	float	inPortL = (float)*l;
	
	float	outPortL, temp1, temp2, temp3;

	temp1     = inPortL / 4;

	// 2nd Order Ladder All Pass: Zeros first version
	temp3     = m_delayL2 + temp1 * m_EaxApA;
	temp2     = temp1 - temp3 * m_EaxApA;
	m_delayL2 = m_delayL1 + temp2 * m_EaxApB;
	m_delayL1 = temp2 - m_delayL2 * m_EaxApB;

	// Regalia Mitra Structure
	temp3     = temp3 * m_EaxGainCoefA;
	temp3     = temp3 + temp1 * m_EaxGainCoefB;
	outPortL  = m_EaxScale * temp3;

	*l = Saturate(outPortL);

//	Bump();
}

//////////////////////////////////////////////////////////////////////////////


__forceinline void CDirectSoundParamEqDMO::DoOneSample(int *l, int *r)
{
	float	inPortL = (float)*l;
	float	inPortR = (float)*r;
	
	float	outPortL, outPortR, temp1, temp2, temp3;

	temp1     = inPortL / 4;

	// 2nd Order Ladder All Pass: Zeros first version
	temp3     = m_delayL2 + temp1 * m_EaxApA;
	temp2     = temp1 - temp3 * m_EaxApA;
	m_delayL2 = m_delayL1 + temp2 * m_EaxApB;
	m_delayL1 = temp2 - m_delayL2 * m_EaxApB;

	// Regalia Mitra Structure
	temp3     = temp3 * m_EaxGainCoefA;
	temp3     = temp3 + temp1 * m_EaxGainCoefB;
	outPortL  = m_EaxScale * temp3;

	*l = Saturate(outPortL);

	temp1     = inPortR / 4;

	// 2nd Order Ladder All Pass: Zeros first version
	temp3     = m_delayR2 + temp1 * m_EaxApA;
	temp2     = temp1 - temp3 * m_EaxApA;
	m_delayR2 = m_delayR1 + temp2 * m_EaxApB;
	m_delayR1 = temp2 - m_delayR2 * m_EaxApB;

	// Regalia Mitra Structure
	temp3     = temp3 * m_EaxGainCoefA;
	temp3     = temp3 + temp1 * m_EaxGainCoefB;
	outPortR  = m_EaxScale * temp3;

	*r = Saturate(outPortR);

//	Bump();
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::FBRProcess
//
HRESULT CDirectSoundParamEqDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut)
{
// { EAX
#define cb cSamples
#define pin pIn
#define pout pOut

	if (m_cChannels == 1) {
		if (m_b8bit) {
			for (;cb > 0; --cb) {
				int i, j;

				i = *(pin+0)-128;
				i *=256;
//				j  = i;

				DoOneSampleMono(&i);
				
//				i += j;
//				i /= 2;
				
				i /= 256;

				*(pout+0) = (unsigned char)(i + 128);
			
				pin  += sizeof(unsigned char);
				pout += sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *psi;
//				j =  i;

				DoOneSampleMono(&i);
				
//				i += j;
//				i /= 2;
				
               	*pso = (short)i;
			
				pin  += sizeof(short);
				pout += sizeof(short);
			}
		}
	}
	else if (m_cChannels == 2) {
		if (m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(unsigned char)) {
				int i, j;

				i = *(pin+0)-128;
				j = *(pin+1)-128;

				i *=256; j *=256;

				DoOneSample(&i, &j);
				
				i /= 256; j /= 256;
				
				*(pout+0) = (unsigned char)(i + 128);
				*(pout+1) = (unsigned char)(j + 128);
			
				pin  += 2 * sizeof(unsigned char);
				pout += 2 * sizeof(unsigned char);
			}
		}
		else if (!m_b8bit) {
			for (;cb > 0; --cb) { // for (;cb > 0; cb -= 2 * sizeof(short)) {
               	short int *psi = (short int *)pin;
               	short int *pso = (short int *)pout;
				int i, j;

				i = *(psi+0);
				j = *(psi+1);

				DoOneSample(&i, &j);
				
               	*(pso+0) = (short)i;
               	*(pso+1) = (short)j;
			
				pin  += 2 * sizeof(short);
				pout += 2 * sizeof(short);
			}
		}
	}
// } EAX
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::ProcessInPlace
//
HRESULT CDirectSoundParamEqDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    HRESULT hr=S_OK;
    // Update parameter values from any curves that may be in effect.
    this->UpdateActiveParams(rtStart, *this);

    hr = FBRProcess(ulQuanta, pcbData, pcbData);
        
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::SetParam
//
// { EAX
// }

void CDirectSoundParamEqDMO::UpdateCoefficients(void)
{
	float _gain, _omega, _lambda, _sinX;


	//Calculate linear gain coefficient
	_gain = (float)pow(10, m_EaxGain/20);

	if (!_gain) _gain = (float).00001;

	m_EaxGainCoefA = (1 - _gain)/2;
	m_EaxGainCoefB = (1 + _gain)/2;
	
	//Calculate scaling coefficient
	m_EaxScale = (float)((fabs(m_EaxGainCoefA) > fabs(m_EaxGainCoefB)) ? fabs(m_EaxGainCoefA) : fabs(m_EaxGainCoefB));
	m_EaxScale = (float)(m_EaxScale > 1 ? ceil(m_EaxScale) : 1);

	m_EaxGainCoefA /= m_EaxScale;
	m_EaxGainCoefB /= m_EaxScale;

	m_EaxScale = m_EaxScale * 4;

	//Calculate allpass coefficients

	_omega  = (float)(2*PI*m_EaxCenter/m_EaxSamplesPerSec);

	_sinX   = (float)sin(_omega);

//	if (!_sinX) _sinX = (float).000001;

	_lambda = (float)(sinh(.5 * log(2) * m_EaxBandwidth/12 * _omega/_sinX) * sin(_omega));
	m_EaxApA = (float)((1 - (_lambda/sqrt(_gain))) / (1 + (_lambda/sqrt(_gain))));
	m_EaxApB = (float)(-cos(_omega));
}

HRESULT CDirectSoundParamEqDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
    HRESULT hr = S_OK;
    HRESULT hr2 = S_OK;

    switch (dwParamIndex)
    {
// { EAX
	case PFP_Center :
		CHECK_PARAM(DSFXPARAMEQ_CENTER_MIN, DSFXPARAMEQ_CENTER_MAX);

        //if we are greater than 1/3rd the samplig rate then we need to S_FALSE;
		if (value > (m_EaxSamplesPerSec/3))
		{
		    hr = S_FALSE;
		    value = static_cast<MP_DATA>(m_EaxSamplesPerSec/3);
		}

		PUT_EAX_VALUE(Center, value);
		
		UpdateCoefficients();
		break;
	
	case PFP_Bandwidth :
		CHECK_PARAM(DSFXPARAMEQ_BANDWIDTH_MIN, DSFXPARAMEQ_BANDWIDTH_MAX);

		PUT_EAX_VALUE(Bandwidth, value);

		UpdateCoefficients();
		break;

	case PFP_Gain : {
		CHECK_PARAM(DSFXPARAMEQ_GAIN_MIN, DSFXPARAMEQ_GAIN_MAX);

		PUT_EAX_VALUE(Gain, value);

		UpdateCoefficients();
		break;
	}
// } EAX
    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls.
    // Skip the base class if fSkipPasssingToParamManager.  This indicates that we're calling the function
    //    internally using valuds that came from the base class -- thus there's no need to tell it values it
    //    already knows.
    hr2 = fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);

    if(FAILED(hr2))
    {
        hr = hr2;
    }
        
    return hr;

}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundParamEqDMO::SetAllParameters(LPCDSFXParamEq peq)
{
    HRESULT hr = S_OK;
    HRESULT hr2[3];

    ZeroMemory(hr2,sizeof(hr2));
	
	// Check that the pointer is not NULL
    if (peq == NULL)
    {
        Trace(1,"ERROR: peq is NULL\n");
        hr = E_POINTER;
    }

	// Set the parameters
	if (SUCCEEDED(hr)) hr = hr2[0] = SetParam(PFP_Center, peq->fCenter);
	if (SUCCEEDED(hr)) hr = hr2[1] = SetParam(PFP_Bandwidth, peq->fBandwidth);
    if (SUCCEEDED(hr)) hr = hr2[2] = SetParam(PFP_Gain, peq->fGain);

    // if we have any alternate success codes, grab the first one and return it.
    if(SUCCEEDED(hr))
    {
        for (int i = 0;i < 3; i++)
        {
            if (hr2[i] != S_OK)
            {
                hr = hr2[i];
                break;
            }
        }
    }

    m_fDirty = true;
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundParamEqDMO::GetAllParameters
//
STDMETHODIMP CDirectSoundParamEqDMO::GetAllParameters(LPDSFXParamEq peq)
{
    HRESULT hr = S_OK;
	MP_DATA mpd;

	if (peq ==NULL) return E_POINTER;

#define GET_PARAM(x,y) \
	if (SUCCEEDED(hr)) { \
		hr = GetParam(x, &mpd);	\
		if (SUCCEEDED(hr)) peq->y = mpd; \
	}

	GET_PARAM(PFP_Center, fCenter);
	GET_PARAM(PFP_Bandwidth, fBandwidth);
	GET_PARAM(PFP_Gain, fGain);

	return hr;
}

// GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundParamEqDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_STANDARD_PARAMEQ;
    return NOERROR;

} // GetClassID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\param.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CParams.
//

#include "dmerror.h"
#include "param.h"
#include "math.h"
#include "validate.h"
#include "debug.h"

#pragma warning(disable:4296)       

CCurveList::~CCurveList()
{
    while(this->GetHead())
    {
        delete this->RemoveHead();
    }
}

CParamsManager::CParamsManager()
  
{
    m_fDirty = FALSE;
	m_cTimeFormats = 0;
	m_pguidTimeFormats = NULL;
	m_guidCurrentTimeFormat = GUID_NULL;
	m_cParams = 0;
	m_pCurveLists = NULL;
    m_pParamInfos = NULL;
	m_dwActiveBits = 0;
	InitializeCriticalSection(&m_ParamsCriticalSection);
}

CParamsManager::~CParamsManager()
{
	delete[] m_pguidTimeFormats;
	delete[] m_pCurveLists;
	delete[] m_pParamInfos;
	DeleteCriticalSection(&m_ParamsCriticalSection);
}

HRESULT CParamsManager::InitParams(DWORD cTimeFormats, const GUID *pguidTimeFormats, DWORD dwFormatIndex, MP_TIMEDATA mptdTimeData, DWORD cParams, ParamInfo *pParamInfo)
{
    //check that the index is in a valid range
    if (0 > dwFormatIndex || dwFormatIndex >= cTimeFormats || cParams > sizeof(DWORD) * 8)
        return E_INVALIDARG;
        
    m_pCurveLists = new CCurveList[cParams];
    if (!m_pCurveLists)
        return E_OUTOFMEMORY;

    // save the time formats
    m_pguidTimeFormats = new GUID[cTimeFormats];
    if (!m_pguidTimeFormats)
        return E_OUTOFMEMORY;
        
    for (DWORD dwIndex = 0; dwIndex < cTimeFormats; dwIndex++)
    {
        memcpy(&m_pguidTimeFormats[dwIndex], &pguidTimeFormats[dwIndex], sizeof(*pguidTimeFormats));
    }

    // save the count of formats
    m_cTimeFormats = cTimeFormats;

    // save the current time format
    m_guidCurrentTimeFormat = m_pguidTimeFormats[dwFormatIndex];

    // save the TimeData
    m_mptdCurrentTimeData = mptdTimeData;

    // save the parameter info
    m_pParamInfos
    = new ParamInfo[cParams];
    if (!m_pParamInfos)
        return E_OUTOFMEMORY;
    for (dwIndex = 0; dwIndex < cParams; dwIndex++)
    {
        if (pParamInfo[dwIndex].dwIndex < cParams)
        {
            memcpy(&m_pParamInfos[pParamInfo[dwIndex].dwIndex],&pParamInfo[dwIndex],sizeof(ParamInfo));
        }
    }
    m_cParams = cParams;

    return S_OK;
}

HRESULT CParamsManager::GetParamCount(DWORD *pdwParams)

{
    if (pdwParams == NULL)
        return E_POINTER;
    
    *pdwParams = m_cParams;
    return S_OK;
}

HRESULT CParamsManager::GetParamInfo(DWORD dwParamIndex,MP_PARAMINFO *pInfo)

{
    if (!pInfo)
    {
        return E_POINTER;
    }
    if (dwParamIndex < m_cParams)
    {
        *pInfo = m_pParamInfos[dwParamIndex].MParamInfo;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CParamsManager::GetParamText(DWORD dwParamIndex,WCHAR **ppwchText)

{
    if (!ppwchText)
    {
        return E_POINTER;
    }
    if (dwParamIndex < m_cParams)
    {
        // write string of format: "Label\0Unit\0Enums1\0Enum2\0...EnumN\0\0"
        ParamInfo &pinfo = m_pParamInfos[dwParamIndex];
        int iUnit = wcslen(pinfo.MParamInfo.szLabel) + 1; // begin writing unit text here
        int iEnums = iUnit + wcslen(pinfo.MParamInfo.szUnitText) + 1; // begin writing enum text here
        int iEnd = iEnums + wcslen(pinfo.pwchText) + 1; // write the final (second) null terminator here
        WCHAR *pwsz = static_cast<WCHAR *>(CoTaskMemAlloc((iEnd + 1) * sizeof(WCHAR)));
        if (!pwsz)
            return E_OUTOFMEMORY;

        // wcscpy will write into various points of the string, neatly terminating each with a null
        wcscpy(pwsz, pinfo.MParamInfo.szLabel);
        wcscpy(pwsz + iUnit, pinfo.MParamInfo.szUnitText);
        wcscpy(pwsz + iEnums, pinfo.pwchText);

        // The text field was defined with commas to separate the enum values.
        // Replace them with NULL characters now.
        for (WCHAR *pwch = pwsz + iEnums; *pwch; ++pwch)
        {
            if (*pwch == L',')
                *pwch = L'\0';
        }

        pwsz[iEnd] = L'\0';
        
        *ppwchText = pwsz;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CParamsManager::GetNumTimeFormats(DWORD *pdwNumTimeFormats)

{
    if (!pdwNumTimeFormats)
    {
        return E_POINTER;
    }
    *pdwNumTimeFormats = m_cTimeFormats;
    return S_OK;
}

HRESULT CParamsManager::GetSupportedTimeFormat(DWORD dwFormatIndex,GUID *pguidTimeFormat)

{
    if (!pguidTimeFormat)
    {
        return E_POINTER;
    }
    if (dwFormatIndex >= m_cTimeFormats)
    {
        return E_INVALIDARG;
    }
    *pguidTimeFormat = m_pguidTimeFormats[dwFormatIndex];
    return S_OK;
}

HRESULT CParamsManager::GetCurrentTimeFormat( GUID *pguidTimeFormat,MP_TIMEDATA *pTimeData)

{
    HRESULT hr=S_OK;
    
    // Parameter Validation
    if ((pguidTimeFormat == NULL) || (pTimeData == NULL))
    {
        hr = E_POINTER;
        Trace(1,"ERROR: pGuidTimeFormat or pTimeData is NULL\n");
    }

    // Return the values
    if (SUCCEEDED(hr))
    {
        *pguidTimeFormat = m_guidCurrentTimeFormat;
        *pTimeData = m_mptdCurrentTimeData;
    }
    
    return hr;
}


HRESULT CParamsManager::CopyParamsFromSource( CParamsManager * pSource)

{
    HRESULT hr = S_OK;
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < m_cParams; dwIndex++)
    {
        if (pSource->m_guidCurrentTimeFormat == m_pguidTimeFormats[dwIndex])
        {
            break;
        }
    }
    
    
    hr = InitParams(pSource->m_cTimeFormats, pSource->m_pguidTimeFormats, dwIndex, pSource->m_mptdCurrentTimeData, pSource->m_cParams,pSource->m_pParamInfos);
    if (SUCCEEDED(hr))
    {
        for (dwIndex = 0; dwIndex < m_cParams; dwIndex++)
        {
            CCurveItem *pCurve = pSource->m_pCurveLists[dwIndex].GetHead();
            for (;pCurve;pCurve = pCurve->GetNext())
            {
	            CCurveItem *pNew = new CCurveItem;
                if (!pNew) 
                {
                    return E_OUTOFMEMORY;
                }
                pNew->m_Envelope = pCurve->m_Envelope;
                m_pCurveLists[dwIndex].AddTail(pNew);
            }
        }
    }
    return hr;
}

void
CParamsManager ::UpdateActiveParams(REFERENCE_TIME rtTime, UpdateCallback &rThis)
{
    if (!m_dwActiveBits)
        return; // nothing to recalc

    DWORD dwBit = 1;
    for (DWORD dwIndex = 0; dwIndex < m_cParams; dwIndex++, dwBit = dwBit << 1)
    {
        if (m_dwActiveBits & dwBit)
        {
            float fVal = 0;
            HRESULT hr = GetParamFloat(dwIndex, rtTime, &fVal);
            rThis.SetParamUpdate(dwIndex, fVal);
            if (hr == S_FALSE)
                m_dwActiveBits &= ~dwBit; // we're beyond the last curve, don't need to recalc next time

            TraceI(6, "DMO value: time %I64d, param #%d, current value %hf\n", rtTime, dwIndex, fVal);
        }
    }
}

inline float ValRange(float valToClip, float valMin, float valMax)
{
	return valToClip < valMin
				? valMin
				: (valToClip > valMax ? valMax : valToClip);
}

HRESULT CParamsManager::GetParamFloat(DWORD dwParamIndex,REFERENCE_TIME rtTime,float *pval)
{
	HRESULT hr = S_OK;

	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];

	// if no points, then neutral value
	CCurveItem *pCurveHead = pList->GetHead();
	if (!pCurveHead)
	{
		*pval = pInfo->MParamInfo.mpdNeutralValue;
        LeaveCriticalSection(&m_ParamsCriticalSection);
		return S_FALSE;
	}

	// Find the curve during or before the requested time
    // If the time is during a curve, we will use that.
    // If not, we need the end value of the previous curve.
    // Our list keeps these in backwards order, so we are scanning from the 
    // highest point in time backwards.

	for (CCurveItem *pCurve = pCurveHead; pCurve && pCurve->m_Envelope.rtStart > rtTime;pCurve = pCurve->GetNext());

    // If there is no pCurve, there was no curve prior to or during rtTime. Give up.
    if (!pCurve)
    {
        *pval = pInfo->MParamInfo.mpdNeutralValue;
        LeaveCriticalSection(&m_ParamsCriticalSection);
		return S_OK;
    }
    // Now, if pCurve ends before the requested time,
    // return the final value of pCurve, since that will hold until the start of the next curve.
    if (pCurve->m_Envelope.rtEnd < rtTime)
    {
		*pval = pCurve->m_Envelope.valEnd;
        LeaveCriticalSection(&m_ParamsCriticalSection);
		if (pCurve == pCurveHead)
			return S_FALSE; // past last curve
		else
			return S_OK; // there are more curves ahead
	}

    // If we get this far, the curve must bound rtTime.

	if (pCurve->m_Envelope.iCurve & MP_CURVE_JUMP)
	{
		*pval = pCurve->m_Envelope.valEnd;
        LeaveCriticalSection(&m_ParamsCriticalSection);
		return S_OK;
	}

	REFERENCE_TIME rtTimeChange = pCurve->m_Envelope.rtEnd - pCurve->m_Envelope.rtStart;
	REFERENCE_TIME rtTimeIntermediate = rtTime - pCurve->m_Envelope.rtStart; 

	float fltScalingX = static_cast<float>(rtTimeIntermediate) / rtTimeChange; // horizontal distance along curve between 0 and 1
	float fltScalingY; // height of curve at that point between 0 and 1 based on curve function
    switch (pCurve->m_Envelope.iCurve)
    {
    case MP_CURVE_SQUARE:
		fltScalingY = fltScalingX * fltScalingX;
        break;
    case MP_CURVE_INVSQUARE:
		fltScalingY = (float) sqrt(fltScalingX);
        break;
    case MP_CURVE_SINE:
        //  Maybe we should have a lookup table here?
        fltScalingY = (float) (sin(fltScalingX * 3.1415926535 - (3.1415926535/2)) + 1) / 2;
        break;
    case MP_CURVE_LINEAR:
    default:
		fltScalingY = fltScalingX;
    }

    // Find out if we need to pull the start point from the previous curve,
    // the default neutral value, or the current curve.
    float fStartVal = pCurve->m_Envelope.valStart;
    if (pCurve->m_Envelope.flags & MPF_ENVLP_BEGIN_NEUTRALVAL)
    {
        fStartVal = pInfo->MParamInfo.mpdNeutralValue;
    }
    // Currentval, if it exists, will override neutralval.
    if (pCurve->m_Envelope.flags & MPF_ENVLP_BEGIN_CURRENTVAL)
    {
        // Take advantage of the fact that these are inserted in backwards order.
        // Scan for the previous curve that ends before this time.
        CCurveItem *pPrevious = pCurve->GetNext();
       	for (;pPrevious && pPrevious->m_Envelope.rtEnd > rtTime;pPrevious = pPrevious->GetNext());
        if (pPrevious)
        {
            fStartVal = pPrevious->m_Envelope.valEnd;
        }
    }
    
    // Apply that scaling to the range of the actual points
    *pval = (pCurve->m_Envelope.valEnd - fStartVal) * fltScalingY + fStartVal;

    LeaveCriticalSection(&m_ParamsCriticalSection);
    return hr;
}

HRESULT CParamsManager::GetParamInt(DWORD dwParamIndex,REFERENCE_TIME rt,long *pval)

{
    HRESULT hr = E_POINTER;
    if (pval)
    {
        float fVal;
        hr = GetParamFloat(dwParamIndex,rt,&fVal);
        if (SUCCEEDED(hr))
        {
            *pval = (long) (fVal + 1/2);    // Round.
        }
    }
    else
    {
        Trace(1,"ERROR: pval is NULL\n");
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// IMediaParams

HRESULT CParamsManager::GetParam(DWORD dwParamIndex,MP_DATA *pValue)
{
    V_INAME(CParams::GetParam);
    V_PTR_WRITE(pValue, MP_DATA);
	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);

	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
	// if no points, then neutral value
	CCurveItem *pCurve = pList->GetHead();
	if (pCurve)
	{
		*pValue = pCurve->m_Envelope.valEnd;
	}
    else
    {
        *pValue = pInfo->MParamInfo.mpdNeutralValue;
    }
    LeaveCriticalSection(&m_ParamsCriticalSection);
    return S_OK;
}

HRESULT CParamsManager::SetParam(DWORD dwParamIndex,MP_DATA value)
{
	V_INAME(CParams::SetParam);
    
	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;
	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
	// If we've already got a list, just force the most recent curve item to this value.
    // Otherwise, create a node and add it.
	CCurveItem *pCurve = pList->GetHead();
	if (!pCurve)
	{
        pCurve = new CCurveItem;
        if (pCurve)
        {
            pCurve->m_Envelope.rtStart =    0x8000000000000000; // Max negative.
            pCurve->m_Envelope.rtEnd =      0x7FFFFFFFFFFFFFFF; // Max positive.
            pCurve->m_Envelope.flags = 0;
            pList->AddHead(pCurve);
        }
		else 
        {
            LeaveCriticalSection(&m_ParamsCriticalSection);
            return E_OUTOFMEMORY;
        }
	}
    pCurve->m_Envelope.valStart = value;
    pCurve->m_Envelope.valEnd = value;
    pCurve->m_Envelope.iCurve = MP_CURVE_JUMP;
    LeaveCriticalSection(&m_ParamsCriticalSection);

    return S_OK;
}

HRESULT CParamsManager::AddEnvelope(
		DWORD dwParamIndex,
		DWORD cPoints,
		MP_ENVELOPE_SEGMENT *ppEnvelope)
{
	V_INAME(CParams::AddEnvelope);
	V_PTR_READ(ppEnvelope, *ppEnvelope);

	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

	if (!m_pParamInfos)
		return DMUS_E_NOT_INIT;

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;

	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];

    DWORD dwCount;
    for (dwCount = 0; dwCount < cPoints; dwCount++)
    {
        CCurveItem *pCurve = new CCurveItem;
        if (!pCurve) 
        {
            hr = E_OUTOFMEMORY;
            Trace(1,"ERROR: Out of memory\n");
            break;
        }
        pCurve->m_Envelope = ppEnvelope[dwCount];
        pCurve->m_Envelope.valEnd = ValRange(pCurve->m_Envelope.valEnd, 
            pInfo->MParamInfo.mpdMinValue, pInfo->MParamInfo.mpdMaxValue);
        pCurve->m_Envelope.valStart = ValRange(pCurve->m_Envelope.valStart, 
            pInfo->MParamInfo.mpdMinValue, pInfo->MParamInfo.mpdMaxValue);
        pList->AddHead(pCurve);
        m_dwActiveBits |= 1 << dwParamIndex; // next call to UpdateActiveParams will ensure the parameter's value is recalculated

	    TraceI(6, "DMO envelope: time %I64d-%I64d, param #%d, value %hf-%hf\n",
				pCurve->m_Envelope.rtStart, pCurve->m_Envelope.rtEnd,
				dwParamIndex, pCurve->m_Envelope.valStart, pCurve->m_Envelope.valEnd);
    }

    LeaveCriticalSection(&m_ParamsCriticalSection);

	return hr;
}

HRESULT CParamsManager::FlushEnvelope(
		DWORD dwParamIndex,
		REFERENCE_TIME refTimeStart,
		REFERENCE_TIME refTimeEnd)
{
	if (dwParamIndex >= m_cParams)
		return E_INVALIDARG;

	if (!m_pParamInfos)
		return DMUS_E_NOT_INIT;

	if (refTimeStart >= refTimeEnd)
	    return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;
	CCurveList *pList = &m_pCurveLists[dwParamIndex];
	ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
    CCurveList TempList;
    CCurveItem *pCurve;
    while (pCurve = pList->RemoveHead())
    {
        if ((pCurve->m_Envelope.rtStart >= refTimeStart) && 
            (pCurve->m_Envelope.rtEnd <= refTimeEnd))
        {
            delete pCurve;
        }
        else 
        {
            TempList.AddHead(pCurve);
        }
    }
    while (pCurve = TempList.RemoveHead())
    {
        pList->AddHead(pCurve);
    }
    LeaveCriticalSection(&m_ParamsCriticalSection);

	return S_OK;
}

HRESULT CParamsManager::SetTimeFormat(
		GUID guidTimeFormat,
		MP_TIMEDATA mpTimeData)
{
    for (DWORD dwIndex = 0; dwIndex < m_cTimeFormats; dwIndex++)
    {
        if (guidTimeFormat == m_pguidTimeFormats[dwIndex])
        {
            m_guidCurrentTimeFormat = m_pguidTimeFormats[dwIndex];
            return S_OK;
        }
    }

    return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\parameqp.h ===
//
//
//
#ifndef _ParamEqp_
#define _ParamEqp_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

#define cALLPASS		((float).61803398875)	// 1-x^2=x.
#define RVB_LP_COEF		((float).1)
#define MAXALLPASS		cALLPASS
#define Delay_len  DefineDelayLineSize(8)

class CDirectSoundParamEqDMO : 
    public CDirectSoundDMO, 
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXParamEq,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundParamEqDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundParamEqDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();
    HRESULT Init();

    // Note that an Init function also exists in the CPCMDMO base class and it can be overridden
    // to provide initialization for the effect's actual audio processing.

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
    
    /* IFilter */
    STDMETHOD(SetAllParameters)             (THIS_ LPCDSFXParamEq);
    STDMETHOD(GetAllParameters)             (THIS_ LPDSFXParamEq);
    
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropParamEq, pPages); }

	// IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXParamEq(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXParamEq(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXParamEq); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value) { return SetParamInternal(dwParamIndex, value, false); }
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();
    
    bool m_fDirty;

protected:
	HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
		HRESULT hr = CPCMDMO::CheckInputType(pmt);
		if (FAILED(hr)) return hr;

		WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
		if (pWave->wFormatTag      != WAVE_FORMAT_PCM ||
			(pWave->wBitsPerSample != 8 && pWave->wBitsPerSample != 16) ||
			(pWave->nChannels      != 1 && pWave->nChannels != 2)) {
			return DMO_E_TYPE_NOT_ACCEPTED;
		}

		return S_OK;
   	}

private:
// { EAX
	__forceinline void DoOneSample(int *l, int *r);
	__forceinline void DoOneSampleMono(int *l);
	void UpdateCoefficients(void);

// Declare internal variables.

#define DECLARE_EAX_VARS(type, var) \
	type m_Eax ## var;

	DECLARE_EAX_VARS(float, GainCoefA);
	DECLARE_EAX_VARS(float, GainCoefB);
	DECLARE_EAX_VARS(float, ApA);
	DECLARE_EAX_VARS(float, ApB);
	DECLARE_EAX_VARS(float, Scale);
	DECLARE_EAX_VARS(float, Gain);
	DECLARE_EAX_VARS(float, Center);
	DECLARE_EAX_VARS(float, Bandwidth);
//	DECLARE_EAX_VARS(float, SamplesPerSec);
#define m_EaxSamplesPerSec m_ulSamplingRate

	__forceinline int Saturate(float f) {
								int i;
#ifdef DONTUSEi386
								_asm {
									fld f
									fistp i
								}
#else
								i = (int)f;
#endif 
								if (i > 32767)
									i =  32767;
								else if ( i < -32768)
									i = -32768;
								return(i);
							}


	float		m_StateL, m_StateR;

	__forceinline float Interpolate(float a, float b, float percent)
	{
		percent = a + (b - a) * percent;

		return(percent);
	}

	void Bump(void);

	float			m_delayL1;
	float			m_delayL2;
	float			m_delayR1;
	float			m_delayR2;

// } EAX
};

EXT_STD_CREATE(ParamEq);

#endif//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\param.h ===
#ifndef __TOOLPARAM_H__
#define __TOOLPARAM_H__



#include "medparam.h"
#include "alist.h"

typedef struct _ParamInfo
{
    DWORD dwIndex;                      // Which parameter.
    MP_PARAMINFO    MParamInfo;         // Standard MediaParams structure.
    WCHAR *         pwchText;           // Array of text names for enumerated types.
} ParamInfo;

class CCurveItem : public AListItem
{
public:
    CCurveItem* GetNext() { return (CCurveItem*)AListItem::GetNext();}
    MP_ENVELOPE_SEGMENT m_Envelope;     // Envelope segment.
};

class CCurveList : public AList
{
public:
//    void Clear();
    void AddHead(CCurveItem* pCurveItem) { AList::AddHead((AListItem*)pCurveItem);}
//    void Insert(CCurveItem* pCurveItem);
    CCurveItem* GetHead(){return (CCurveItem*)AList::GetHead();}
//    CCurveItem* GetItem(LONG lIndex){return (CCurveItem*)AList::GetItem(lIndex);}
    CCurveItem* RemoveHead(){ return (CCurveItem*)AList::RemoveHead();}
//    void Remove(CCurveItem* pCurveItem){AList::Remove((AListItem*)pCurveItem);}
//    void AddTail(CCurveItem* pCurveItem){AList::AddTail((AListItem*)pCurveItem);}
//    CCurveItem* GetTail(){ return (CCurveItem*)AList::GetTail();}
	~CCurveList();
};

#define MAX_REF_TIME    0x7FFFFFFFFFFFFFFF
#define MP_CAPS_ALL     MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE

class CParamsManager :  public IMediaParams, public IMediaParamInfo
{
public:
    CParamsManager();
    ~CParamsManager();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;

    // IMediaParams
    STDMETHODIMP GetParam(DWORD dwParamIndex, MP_DATA *pValue);
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value);
    STDMETHODIMP AddEnvelope(DWORD dwParamIndex,DWORD cPoints,MP_ENVELOPE_SEGMENT *ppEnvelope);
    STDMETHODIMP FlushEnvelope( DWORD dwParamIndex,REFERENCE_TIME refTimeStart,REFERENCE_TIME refTimeEnd);
    STDMETHODIMP SetTimeFormat( GUID guidTimeFormat,MP_TIMEDATA mpTimeData);

    // IMediaParamInfo
    STDMETHODIMP GetParamCount(DWORD *pdwParams);
    STDMETHODIMP GetParamInfo(DWORD dwParamIndex,MP_PARAMINFO *pInfo);
    STDMETHODIMP GetParamText(DWORD dwParamIndex,WCHAR **ppwchText);
    STDMETHODIMP GetNumTimeFormats(DWORD *pdwNumTimeFormats);
    STDMETHODIMP GetSupportedTimeFormat(DWORD dwFormatIndex,GUID *pguidTimeFormat);        
    STDMETHODIMP GetCurrentTimeFormat( GUID *pguidTimeFormat,MP_TIMEDATA *pTimeData);

    // other (non-COM) functions
    HRESULT InitParams(DWORD cTimeFormats, const GUID *pguidTimeFormats, DWORD dwFormatIndex, MP_TIMEDATA mptdTimeData, DWORD cParams, ParamInfo *pParamInfos);
    HRESULT GetParamFloat(DWORD dwParamIndex,REFERENCE_TIME rtTime,float *pval); // returns S_FALSE if rtTime is after the end time of the last curve
    HRESULT GetParamInt (DWORD dwParamIndex,REFERENCE_TIME rt,long *pval); // returns S_FALSE if rtTime is after the end time of the last curve
    HRESULT CopyParamsFromSource(CParamsManager * pSource);

    // parameter control curve handling
    class UpdateCallback
    {
    public:
        // Define this in derived classes if you are going to use UpdateActiveParams.
        //  Called by CParamsManager inside UpdateActiveParams to update the effect's internal state variables.
        //  SetParamUpdate should be the same as SetParam, except that DMO defer the call to the base class
        //  (CParamsManager::SetParam) in SetParam but should not do so in SetParamUpdate.
        virtual HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) = 0;
    };
    // function that calls SetParam to adjust the value of all parameters that may have changed to their
    // new values at time rtTime
    void UpdateActiveParams(REFERENCE_TIME rtTime, UpdateCallback &rThis); // rThis should be the derived class (*this)
    DWORD GetActiveParamBits() { return m_dwActiveBits; }

protected:
    // data

    CRITICAL_SECTION m_ParamsCriticalSection;
    BOOL            m_fDirty;					// Has data changed since last file load or save?
    DWORD           m_cTimeFormats;             // Number of supported time formats.
    GUID            *m_pguidTimeFormats;        // Array of supported time formats.
    GUID            m_guidCurrentTimeFormat;    // The time format we're set to.
    MP_TIMEDATA     m_mptdCurrentTimeData;		// The unit of measure for the current time format.
    DWORD           m_cParams;                  // Number of parameters.
    ParamInfo       *m_pParamInfos;             // Array of ParamInfo structures, one for each parameter.
    CCurveList      *m_pCurveLists;             // Array of Curve lists, one for each parameter.
    DWORD           m_dwActiveBits;             // Tracks the params that currently have curves active.
};

#endif // __TOOLPARAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\propertyhelp.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Helpers for implementation of ISpecifyPropertyPages and IPersistStream
//

#pragma once
#include "ocidl.h"

// Paste these declarations into your class methods to implement the interfaces.  Replace DSFXZZZ with the name of your struct.
// These assume that you implement GetAllParameters/SetAllParameters interfaces with a struct and that you have a public m_fDirty
// member variable that you use to hold the dirty state of your object for persistence.

/*
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropZZZ, pPages); }

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXZZZ(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXZZZ(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXZZZ); return S_OK; }
*/

// Load, Save, and GetPages are actually implemented in the following functions.

namespace PropertyHelp
{
    HRESULT GetPages(const CLSID &rclsidPropertyPage, CAUUID * pPages);

    template<class O, class S> HRESULT Load(O *pt_object, S &t_struct, IStream *pStm)
    {
        ULONG cbRead;
        HRESULT hr;

        if (pStm==NULL)
        	return E_POINTER;

        hr = pStm->Read(&t_struct, sizeof(t_struct), &cbRead);
        if (hr != S_OK || cbRead < sizeof(t_struct))
            return E_FAIL;

        hr = pt_object->SetAllParameters(&t_struct);
        pt_object->m_fDirty = false;
        return hr;
    }

    template<class O, class S> HRESULT Save(O *pt_object, S &t_struct, IStream *pStm, BOOL fClearDirty)
    {
        HRESULT hr; 

        if (pStm==NULL)
        	return E_POINTER;

        hr = pt_object->GetAllParameters(&t_struct);
        if (FAILED(hr))
            return hr;

        ULONG cbWritten;
        hr = pStm->Write(&t_struct, sizeof(t_struct), &cbWritten);
        if (hr != S_OK || cbWritten < sizeof(t_struct))
            return E_FAIL;

        if (fClearDirty)
            pt_object->m_fDirty = false;
        return S_OK;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\sverb.h ===
/***********************************************************
Copyrights : ksWaves Ltd. 1998.

Provided to Microsoft under contract between ksWaves and Microsoft.

************************************************************/

/****************************************************************************
Const defines :
*****************************************************************************/
#define FPU_DENORM_OFFS (float)1.0E-30

#define BASE_REV_DELAY  0x4000
#define BASE_DSPS_DELAY 0x800

#define DSPS_MASK   0x7ff
#define REV_MASK    0x3fff

/****************************************************************************
Coefs Struct :
*****************************************************************************/
typedef struct
{

	long mySize;
	long myVersion;
	float SampleRate;

	float directGain; 
	long  l_directGain; 
	float revGain; 
	long l_revGain; 

	long lDelay1;
	long lDelay2;
	long lDelay3;
	long lDelay4;

	long lDDly1; 
	long lDDly2; 

	float dDsps;
	long l_dDsps;

	float dDG1;
	long l_dDG1;

	float dDG2; 
	long l_dDG2; 

	float dFB11;
	long l_dFB11;
	float dFB12;
	long l_dFB12;
	float dFB21;
	long l_dFB21;
	float dFB22;
	long l_dFB22;
	float dFB31;
	long l_dFB31;
	float dFB32;
	long l_dFB32;
	float dFB41;
	long l_dFB41;
	float dFB42;
	long l_dFB42;

	float dDamp;
	long l_dDamp;


} sCoefsStruct;

/****************************************************************************
Initialization and control functions :
*****************************************************************************/

#ifdef __cplusplus
extern "C"
{
#endif

#define MAX_16 (float)((unsigned long)0x00008000)

void InitSVerbStates( long *pStates );
long DToF32( float dbl  );
void ConvertCoefsToFix( void *pC );
void InitSVerb( float SampleRate, void  *pCoefs);
void SetSVerb( float InGain, float dRevMix,  float dRevTime, 
			    float dHighFreqRTRatio, void  *pCoefs );



long GetCoefsSize(void);
long GetStatesSize(void);
long GetSVerbVersion(void);

float VerifySampleRate(void  *pCoefs);
long VerifyVersion(void  *pCoefs);
long VerifySize(void  *pCoefs);


#define CLIP_SHORT_TO_SHORT(x)\
			if (x>32767)\
				x = 32767;\
			else if (x<-32768)\
				x = -32768;

/****************************************************************************
//Process Functions :
*****************************************************************************/

__inline void dsps( float *pDly, long ref, long delay, float dDG1, float dDsps, float *inL, float *inR );
__inline void dspsL( long *pDly, long ref, long delay, long dDG1, long dDsps, long *inL, long *inR );

void SVerbMonoToMonoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbMonoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbStereoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbMonoToMonoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);

void SVerbMonoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);

void SVerbStereoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\reghlp.cpp ===
// Copyright (c) 2000 - 2000  Microsoft Corporation.  All Rights Reserved.
//
// reghlp.cpp - registration/enumeration part of DMO runtime
//
#include <windows.h>
#include <tchar.h>
#include <guiddef.h>
#include <ks.h>
#include "dmoutils.h"

#define DMO_REGISTRY_HIVE HKEY_CLASSES_ROOT
#define DMO_REGISTRY_PATH TEXT("DirectShow\\MediaObjects")

#define CPU_RESOURCES_STR "SystemResources"

// Automatically calls RegCloseKey when leaving scope
class CAutoCreateHKey {
public:
   CAutoCreateHKey(HKEY hKey, TCHAR* szSubKey, HKEY *phKey) {
      if (RegCreateKeyEx(hKey,
                         szSubKey,
                         0,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         MAXIMUM_ALLOWED,
                         NULL,
                         phKey,
                         NULL) != ERROR_SUCCESS)
         m_hKey = *phKey = NULL;
      else
         m_hKey = *phKey;
   }
   ~CAutoCreateHKey() {
      if (m_hKey)
         RegCloseKey(m_hKey);
   }
   HKEY m_hKey;
};

class CAutoOpenHKey {
public:
   CAutoOpenHKey(HKEY hKey, TCHAR* szSubKey, HKEY *phKey, REGSAM samDesired = MAXIMUM_ALLOWED) {
      if (RegOpenKeyEx(hKey,
                       szSubKey,
                       0,
                       samDesired,
                       phKey) != ERROR_SUCCESS)
         m_hKey = *phKey = NULL;
      else
         m_hKey = *phKey;
   }
   ~CAutoOpenHKey() {
      if (m_hKey)
         RegCloseKey(m_hKey);
   }
   HKEY m_hKey;
};




/////////////////////////////////////////////////////////////////////////////
//
// DMO Registration code
//

//
// Public entry point
//
STDAPI DMORegisterCpuResources
(
   REFCLSID clsidDMO,
   unsigned long ulCpuResources
) 
{
   TCHAR szSubkeyName[80];
   if (clsidDMO == GUID_NULL)
      return E_INVALIDARG;

   // open the main DMO key
   HKEY hMainKey;
   CAutoOpenHKey kMain(DMO_REGISTRY_HIVE, DMO_REGISTRY_PATH, &hMainKey);
   if (hMainKey == NULL)
      return E_FAIL;

   // open the object specific key underneath the main key
   DMOGuidToStr(szSubkeyName, clsidDMO); // BUGBUG: redundant
   HKEY hObjectKey;
   CAutoOpenHKey kObject(hMainKey, szSubkeyName, &hObjectKey);
   if (hObjectKey == NULL)
      return E_FAIL;

   // set the default value of the CPU Resources key to the value
   if (RegSetValueEx(hObjectKey, TEXT(CPU_RESOURCES_STR), (DWORD)0, REG_DWORD, (CONST BYTE *)&ulCpuResources, sizeof(DWORD))
        != ERROR_SUCCESS)
      return E_FAIL;
 

   return NOERROR;
}

//
// End registry helper code
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\reghlp.h ===
//
//
//
#ifndef _REGHLP_
#define _REGHLP_

STDAPI DMORegisterCpuResources
(
   REFCLSID clsidDMO,
   unsigned long ulCpuResources
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\sources.inc ===
#############################################################################
# Copyright (C) Microsoft Corporation 2000
#############################################################################

!ifndef DXROOT
DXROOT = $(PROJECT_ROOT)\directx
!endif

!include $(DXROOT)\project.mk
!include ..\..\buildmode.inc
	
MAJORCOMP  = windows
MINORCOMP  = directx

TARGETNAME = dsdmo
TARGETPATH = $(_OBJ_DIR)
TARGETTYPE = DYNLINK
UMTYPE     = windows
DLLDEF     = ..\dsdmo.def
DLLENTRY   = _DllMainCRTStartup

USE_MSVCRT = 1
USE_MAPSYM = 1

!if $(386)
!if !$(FREEBUILD)
MSC_OPTIMIZATION = $(MSC_OPTIMIZATION) /Od /QIfist
!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif
!else
MSC_OPTIMIZATION = $(MSC_OPTIMIZATION) /Ox /Ob2 /QIfist
!endif
!endif


# 04/11/2000 - allows for addition of BoundsChecker, etc 
# libs specified in the OS environment

TARGETLIBS = $(TARGETLIBS) \
    $(SDK_LIB_PATH)\kernel32.lib    \
    $(SDK_LIB_PATH)\user32.lib      \
    $(SDK_LIB_PATH)\advapi32.lib    \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SDK_LIB_PATH)\uuid.lib        \
    $(SDK_LIB_PATH)\dmoguids.lib    \
    $(SDK_LIB_PATH)\shlwapi.lib     \
    $(SDK_LIB_PATH)\msdmo.lib       \
    $(PROJECT_ROOT)\oem\binary_release\creative\I3DL2\*\eaxreverb.lib

# Make sure we pick up the right verinfo.h etc.

INCLUDES = $(PROJECT_INC_PATH);\
           $(DXROOT)\inc;

SOURCES =\
    oledll.cpp      \
    guid.cpp        \
    dsdmobse.cpp    \
    aec.cpp         \
    agc.cpp         \
    chorus.cpp      \
    clone.cpp       \
    compress.cpp    \
    distort.cpp     \
    ns.cpp          \
    parameq.cpp     \
    echo.cpp        \
    flanger.cpp     \
    gargle.cpp      \
    sverbdmo.cpp	\
    sverb.c			\
    dllmain.cpp     \
    common.cpp      \
    propertyhelp.cpp\
    debug.cpp       \
    dsdmo.rc        \
    alist.cpp       \
    kshlp.cpp       \
	reghlp.cpp		\
	dmoutils.cpp	\
    param.cpp		\
    dmocom.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\runtime.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       runtime.h
 *  Content:    New versions of C runtime functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/16/2000  jstokes  Created
 *
 ***************************************************************************/

#ifndef __RUNTIME_H__
#define __RUNTIME_H__


// We have BYTE, WORD and DWORD, but no QWORD?
typedef unsigned __int64 QWORD, *LPQWORD;

// Bounderies of numeric types
#define MAX_CHAR        ((CHAR)0x7F)
#define MIN_CHAR        ((CHAR)-0x7F)

#define MAX_UCHAR       ((UCHAR)0xFF)
#define MIN_UCHAR       ((UCHAR)0)

#define MAX_SHORT       ((SHORT)0x7FFF)
#define MIN_SHORT       ((SHORT)-0x7FFF)

#define MAX_USHORT      ((USHORT)0xFFFF)
#define MIN_USHORT      ((USHORT)0)

#define MAX_INT         ((INT)0x7FFFFFFF)
#define MIN_INT         ((INT)-0x7FFFFFFF)

#define MAX_UINT        ((UINT)0xFFFFFFFF)
#define MIN_UINT        ((UINT)0)

#define MAX_LONG        MAX_INT
#define MIN_LONG        MIN_INT

#define MAX_ULONG       MAX_UINT
#define MIN_ULONG       MIN_UINT

#define MAX_INT64       ((INT64)0x7FFFFFFFFFFFFFFF)
#define MIN_INT64       ((INT64)-0x7FFFFFFFFFFFFFFF)

#define MAX_UINT64      ((UINT64)0xFFFFFFFFFFFFFFFF)
#define MIN_UINT64      ((UINT64)0)

#define MAX_LONGLONG    MAX_INT64
#define MIN_LONGLONG    MIN_INT64

#define MAX_ULONGLONG   MAX_UINT64
#define MIN_ULONGLONG   MIN_UINT64

#define MAX_BYTE        MAX_UCHAR
#define MIN_BYTE        MIN_UCHAR

#define MAX_WORD        MAX_USHORT
#define MIN_WORD        MIN_USHORT

#define MAX_DWORD       MAX_ULONG
#define MIN_DWORD       MIN_ULONG

#define MAX_QWORD       MAX_UINT64
#define MIN_QWORD       MIN_UINT64

#define NUMERIC_CAST(val, type) \
            ((type)min(MAX_##type, max(MIN_##type, val)))

// Sundown
#ifdef WIN64

#pragma warning(disable:4311)   // type cast truncation

#ifndef __midl

__inline unsigned long PtrDiffToUlong(__int64 n64)
{
    return((unsigned long)n64);
}

__inline long PtrDiffToLong(__int64 n64)
{
    return((long)n64);
}

__inline int PtrDiffToInt(__int64 n64)
{
    return((int)n64);
}

#endif // __midl

#pragma warning(3:4311)   // type cast truncation

#else // WIN64

#define PtrDiffToUlong(n64) \
            ((unsigned long)(n64))

#define PtrDiffToLong(n64) \
            ((long)(n64))

#define PtrDiffToInt(n64) \
            ((int)(n64))

#endif // WIN64


#endif // __RUNTIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\sverbdmo.cpp ===
#include <windows.h>

#include "sverb.h"
#include "sverbp.h"
#include "clone.h"

STD_CREATE(WavesReverb)

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::NDQueryInterface
//
// Subclass can override if it wants to implement more interfaces.
//
STDMETHODIMP CDirectSoundWavesReverbDMO::NDQueryInterface(THIS_ REFIID riid, LPVOID *ppv)
{
    IMP_DSDMO_QI(riid,ppv);

    if (riid == IID_IPersist)
    {
        return GetInterface((IPersist*)this, ppv);
    }
    else if (riid == IID_IMediaObject)
    {
        return GetInterface((IMediaObject*)this, ppv);
    }
    else if (riid == IID_IDirectSoundFXWavesReverb)
    {
        return GetInterface((IDirectSoundFXWavesReverb*)this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages*)this, ppv);
    }
    else if (riid == IID_IMediaParams)
    {
        return GetInterface((IMediaParams*)this, ppv);
    }
    else if (riid == IID_IMediaParamInfo)
    {
        return GetInterface((IMediaParamInfo*)this, ppv);
    }
    else
        return CComBase::NDQueryInterface(riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::Clone
//
STDMETHODIMP CDirectSoundWavesReverbDMO::Clone(IMediaObjectInPlace **pp) 
{
    return StandardDMOClone<CDirectSoundWavesReverbDMO, DSFXWavesReverb>(this, pp);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::CDirectSoundWavesReverbDMO
//
CDirectSoundWavesReverbDMO::CDirectSoundWavesReverbDMO( IUnknown *pUnk, HRESULT *phr ) 
  : CComBase( pUnk, phr ), 
    m_fDirty(TRUE),
    m_pbCoeffs(NULL),
    m_plStates(NULL),
    m_fInitCPCMDMO(false),
    m_pfnSVerbProcess(NULL),
    m_fGain(DSFX_WAVESREVERB_INGAIN_DEFAULT),
    m_fMix(DSFX_WAVESREVERB_REVERBMIX_DEFAULT),
    m_fTime(DSFX_WAVESREVERB_REVERBTIME_DEFAULT),
    m_fRatio(DSFX_WAVESREVERB_HIGHFREQRTRATIO_DEFAULT)
{
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::~CDirectSoundWavesReverbDMO
//
CDirectSoundWavesReverbDMO::~CDirectSoundWavesReverbDMO() 
{
    delete[] m_pbCoeffs;
    delete[] m_plStates;

}

const MP_CAPS g_capsAll = MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE;
static ParamInfo g_params[] =
{
//  index           type        caps        min,                                    max,                                    neutral,                                    unit text,  label,              pwchText
    SVP_Gain,       MPT_FLOAT,  g_capsAll,  DSFX_WAVESREVERB_INGAIN_MIN,            DSFX_WAVESREVERB_INGAIN_MAX,            DSFX_WAVESREVERB_INGAIN_DEFAULT,            L"dB",      L"InGain",          L"",
    SVP_Mix,        MPT_FLOAT,  g_capsAll,  DSFX_WAVESREVERB_REVERBMIX_MIN,         DSFX_WAVESREVERB_REVERBMIX_MAX,         DSFX_WAVESREVERB_REVERBMIX_DEFAULT,         L"dB",      L"ReverbMix",       L"",
    SVP_ReverbTime, MPT_FLOAT,  g_capsAll,  DSFX_WAVESREVERB_REVERBTIME_MIN,        DSFX_WAVESREVERB_REVERBTIME_MAX,        DSFX_WAVESREVERB_REVERBTIME_DEFAULT,        L"ms",      L"ReverbTime",      L"",
    SVP_Ratio,      MPT_FLOAT,  g_capsAll,  DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN,   DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX,   DSFX_WAVESREVERB_HIGHFREQRTRATIO_DEFAULT,   L"",        L"HighFreqRTRatio", L"",
};

HRESULT CDirectSoundWavesReverbDMO::InitOnCreation()
{
    HRESULT hr = InitParams(1, &GUID_TIME_REFERENCE, 0, 0, sizeof(g_params)/sizeof(*g_params), g_params);
    return hr;
}

HRESULT CDirectSoundWavesReverbDMO::Init()
{
    HRESULT hr = S_OK;
    

    DMO_MEDIA_TYPE *pmt = InputType();
    
    if (pmt->majortype != MEDIATYPE_Audio || 
        pmt->subtype != MEDIASUBTYPE_PCM ||
        pmt->formattype != FORMAT_WaveFormatEx)
    {
        hr = E_INVALIDARG;
        TraceI(1,"ERROR: Invalid Format specified during SetInputType()\n");
    }

    WAVEFORMATEX *pwfex = (WAVEFORMATEX*)pmt->pbFormat;

    if (SUCCEEDED(hr))
    {
        if (pwfex->wFormatTag != WAVE_FORMAT_PCM ||
            pwfex->wBitsPerSample != 16)
        {
            hr = E_INVALIDARG;
            TraceI(1,"ERROR: Invalid Format specified during SetInputType()\n");
        }
    }

    if (SUCCEEDED(hr))
    {
        switch (pwfex->nChannels)
        {
            case 1:
                m_pfnSVerbProcess = SVerbMonoToMonoShort;
                break;

            case 2:
                m_pfnSVerbProcess = SVerbStereoToStereoShort;
                break;

            default:
                hr = E_FAIL;
                TraceI(1,"ERROR: Waves Reverb only supports mono or stereo\n");
        }
    }

    // Formats have been set. Initialize the reverb.
    //
    m_pbCoeffs = new BYTE[GetCoefsSize()];
    m_plStates = new long[(GetStatesSize() + sizeof(long) - 1)/ sizeof(long)];

    if (m_pbCoeffs == NULL || m_plStates == NULL)
    {
        hr = E_OUTOFMEMORY;
        TraceI(1,"ERROR: Out of memory\n");
    }

    if (SUCCEEDED(hr))
    {
        memset(m_plStates, 0, GetStatesSize());
        InitSVerb((float)m_ulSamplingRate, m_pbCoeffs);
        InitSVerbStates(m_plStates);
        m_fInitCPCMDMO = true;
    }

    Discontinuity();
    return hr;
}

HRESULT CDirectSoundWavesReverbDMO::Discontinuity() 
{
    HRESULT hr;
    DSFXWavesReverb wavesreverb;
    
    if (m_pbCoeffs && m_plStates)
    {
        memset(m_plStates, 0, GetStatesSize());
        InitSVerb((float)m_ulSamplingRate, m_pbCoeffs);
        InitSVerbStates(m_plStates);
    }

    hr = GetAllParameters(&wavesreverb);

    if (SUCCEEDED(hr)) 
    {   
        hr = SetAllParameters(&wavesreverb);
    }

    if (SUCCEEDED(hr)) 
    {
        UpdateCoefficients();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::FBRProcess
//
HRESULT CDirectSoundWavesReverbDMO::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut)
{
    assert(m_pfnSVerbProcess);
    
    (*m_pfnSVerbProcess)(
        cSamples, 
        (short*)pIn, 
        (short*)pOut,    
        m_pbCoeffs,
        m_plStates);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::ProcessInPlace
//
HRESULT CDirectSoundWavesReverbDMO::ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags)
{
    // Update parameter values from any curves that may be in effect.
    if (this->GetActiveParamBits())
    {
        this->UpdateActiveParams(rtStart, *this);
        this->UpdateCoefficients();
    }

    return FBRProcess(ulQuanta, pcbData, pcbData);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::SetParam
//
STDMETHODIMP CDirectSoundWavesReverbDMO::SetParam(DWORD dwParamIndex,MP_DATA value)
{
    HRESULT hr = SetParamInternal(dwParamIndex, value, false);
    if (SUCCEEDED(hr))
        this->UpdateCoefficients();
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::SetParamInternal
//
HRESULT CDirectSoundWavesReverbDMO::SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager)
{
    switch (dwParamIndex)
    {
    case SVP_Gain:
        CHECK_PARAM(DSFX_WAVESREVERB_INGAIN_MIN, DSFX_WAVESREVERB_INGAIN_MAX);
        m_fGain = value;
        break;

    case SVP_Mix:
        CHECK_PARAM(DSFX_WAVESREVERB_REVERBMIX_MIN,DSFX_WAVESREVERB_REVERBMIX_MAX);
        m_fMix = value;
        break;

    case SVP_ReverbTime:
        CHECK_PARAM(DSFX_WAVESREVERB_REVERBTIME_MIN,DSFX_WAVESREVERB_REVERBTIME_MAX);
        m_fTime = value;
        break;
    
    case SVP_Ratio:
        CHECK_PARAM(DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN,DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX);
        m_fRatio = value;
        break;

    default:
        return E_FAIL;
    }

    // Let base class set this so it can handle all the rest of the param calls
    //
    HRESULT hr = fSkipPasssingToParamManager ? S_OK : CParamsManager::SetParam(dwParamIndex, value);
    return hr;
}

void CDirectSoundWavesReverbDMO::UpdateCoefficients()
{
    // Waves Reverb has a single SetSVerb call that updates all parameters simultaneously instead of internal
    // state variables that are updated incrementally by changes to individual parameters as the other DMOs do.
    if (m_fInitCPCMDMO)
    {
        SetSVerb(
            m_fGain,
            m_fMix,
            m_fTime,
            m_fRatio,
            m_pbCoeffs);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::SetAllParameters
//
STDMETHODIMP CDirectSoundWavesReverbDMO::SetAllParameters(THIS_ LPCDSFXWavesReverb pwr)
{
    HRESULT hr = S_OK;
    
    // Check that the pointer is not NULL
    if (pwr == NULL)
    {
        TraceI(1,"ERROR: pwr is NULL\n");
        hr = E_POINTER;
    }

    // Set the parameters
    if (SUCCEEDED(hr)) hr = SetParamInternal(SVP_Gain, pwr->fInGain, false);
    if (SUCCEEDED(hr)) hr = SetParamInternal(SVP_Mix, pwr->fReverbMix, false);
    if (SUCCEEDED(hr)) hr = SetParamInternal(SVP_ReverbTime, pwr->fReverbTime, false);
    if (SUCCEEDED(hr)) hr = SetParamInternal(SVP_Ratio, pwr->fHighFreqRTRatio, false);
    this->UpdateCoefficients();

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWavesReverbDMO::GetAllParameters
//
HRESULT CDirectSoundWavesReverbDMO::GetAllParameters(THIS_ LPDSFXWavesReverb pwr)
{
    HRESULT hr = S_OK;
    MP_DATA mpd;

    if (pwr == NULL) return E_POINTER;
    
#define GET_PARAM(x,y) \
    if (SUCCEEDED(hr)) { \
        hr = GetParam(x, &mpd); \
        if (SUCCEEDED(hr)) pwr->y = mpd; \
    }

#define GET_PARAM_LONG(x,y) \
    if (SUCCEEDED(hr)) { \
        hr = GetParam(x, &mpd); \
        if (SUCCEEDED(hr)) pwr->y = (long)mpd; \
    }
    
    GET_PARAM(SVP_Gain, fInGain);
    GET_PARAM(SVP_Mix, fReverbMix);
    GET_PARAM(SVP_ReverbTime, fReverbTime);
    GET_PARAM(SVP_Ratio, fHighFreqRTRatio);

    return S_OK;
}

HRESULT CDirectSoundWavesReverbDMO::CheckInputType(const DMO_MEDIA_TYPE *pmt)
{
   if (NULL == pmt) {
      return E_POINTER;
   }

   // Verify that this is PCM with a WAVEFORMATEX format specifier
   if ((pmt->majortype  != MEDIATYPE_Audio) ||
       (pmt->subtype    != MEDIASUBTYPE_PCM) ||
       (pmt->formattype != FORMAT_WaveFormatEx) ||
       (pmt->cbFormat < sizeof(WAVEFORMATEX)) ||
       (pmt->pbFormat == NULL))
      return DMO_E_TYPE_NOT_ACCEPTED;

   // Verify the wave format
   WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmt->pbFormat;
   if (pWave->wFormatTag != WAVE_FORMAT_PCM ||
       pWave->wBitsPerSample != 16 ||
       pWave->nChannels != 1 && pWave->nChannels != 2)
   {
       return DMO_E_TYPE_NOT_ACCEPTED;
   }
   return NOERROR;
 }

 // GetClassID
//
// Part of the persistent file support.  We must supply our class id
// which can be saved in a graph file and used on loading a graph with
// this fx in it to instantiate this filter via CoCreateInstance.
//
HRESULT CDirectSoundWavesReverbDMO::GetClassID(CLSID *pClsid)
{
    if (pClsid==NULL) {
        return E_POINTER;
    }
    *pClsid = GUID_DSFX_WAVES_REVERB;
    return NOERROR;

} // GetClassID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\sverb.c ===
/***********************************************************
Copyrights : ksWaves Ltd. 1998.

Provided to Microsoft under contract between ksWaves and Microsoft.

************************************************************/

/***********************************************************
General description :

The functions in this file provides for any apoplication to process audio data
with the SVerb algorithm.

In order to do so the application should :

1. Allocate two chunks of memory for 'Coefs' and 'States' with sizes as returned 
   by the functions 'GetCoefsSize' and 'GetStatesSize' accordingly.
   
2. Initialize these memory chunks using the functions : 'InitSVerb' and 'InitSVerbStates' 
   accordingly.

3. Change the settings of the SVerb sound using the function 'SetSVerb'.

4. Call one of the process functions according to the input/output data format:

   SVerbMonoToMonoShort 
   SVerbMonoToStereoShort
   SVerbStereoToStereoShort 
   SVerbMonoToMonoFloat
   SVerbMonoToStereoFloat
   SVerbStereoToStereoFloat

   The input/output are always the same data type (i.e. both input and output are short integer
   or both are 32bits floats).

   Stereo data format is always'interlaced' left,right samples.

   The 'coefs' and 'states' memory should be passed to the process functions.
   
5. Many coefs structures can be initialized each for different SVerb settings. Passing a different
   coefs structure will cause a real time change of sound quality.

   As long as sound continuity should be maintained the states structure should not be changes or
   re-initialized. Only when a completly new audio sequence is desired should the states be re-initialized.

6. Note that the coefs are valid per sampling rate.

7. Althaugh provisions for coefs compatibility for future versions are provided, it should be avoided to save coefs
   structures to files as-is and re-use them later. Rather the application should save the 'real-world'
   settings of the reverb - namely the parameters passed to 'SetSVerb'. These 'real-world' settings 
   will always be valid for future versions, as well as if other sampling rates are used. The coefs 
   structur(es) should be re-initialized in run time using the real-world settings and call to 
   'SetSverb'.


************************************************************/

#include <windows.h>
#include <String.h>
#include <math.h>
#include "SVerb.h"

#pragma optimize( "ty", on )

/****************************************************************************

Function Name	: GetCoefsSize

Input Arguments : None

Return Value    : The size of memory in bytes, to be allocated in order to hold coefficients.

Description		:  

This function must be called before any calls to other functions that uses the coefs structure.
The calling app must than allocate the returned size of memory and initialize it using 'InitSVerb()'
and 'SetSVerb()'.

The caller should not be botherred by the internals of the coefs structure, rather only konw it's size 
and than allocate enough memory to hold it.

The structure allocated can be used in a very flexible way in order to allow for real-time, pre-computed
changes in Reverb Sound. 

*****************************************************************************/

long GetCoefsSize(void) 
{
	return sizeof(sCoefsStruct); 
};

/****************************************************************************

Function Name	: GetStatesSize

Input Arguments : None

Return Value    : The size of memory in bytes, to be allocated in order to hold states.

Description		:  

This function must be called before any calls to other functions that uses the states structure.
The calling app must than allocate the returned size of memory and initialize it using 'InitSVerbStates()'.

The states allocated are valid in run-time only, and sould be re-initialized only when a complete
new input is to be processed by the SVerb. 

When changing the settings of revevreb in real time while audio is playing, the states should not 
be re-initialized, rather the same passed states must be passed to the process functions in order 
to maintain sound continuity.

*****************************************************************************/

long GetStatesSize(void) 
{
	return sizeof(long)*(BASE_REV_DELAY+2*BASE_DSPS_DELAY+2); 
};

/****************************************************************************

Function Name	: GetSVerbVersion

Input Arguments : None

Return Value    : Version of SVerb implementation - for future compatibility.

Description		:  

Since the caller do not know about the internals of the coefs structure, this function,
together with 'VerifyVersion' function provides a way to verify if a coefs structure
match the version of the reverb used.

This should be needed only if one is using a coefs structure that was saved to file, and 
being used later.

NOTE : In normal operation, this way of usage should be avoided... and only real-world reverb
settings should be saved to files, and re-initialize the coefs in run time.

*****************************************************************************/

long GetSVerbVersion(void) 
{
	return 0x1; 
};

/****************************************************************************

Function Name	: VerifySampleRate

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The sample rate for which this coefs are valid.

Description		:  

When an application uses different sampling rates, and re-uses same coefs structures, 
it should verify that the coefs match the audio sampling rate.

*****************************************************************************/

float VerifySampleRate(void *pC) {
	return ((sCoefsStruct *)pC)->SampleRate; 
};

/****************************************************************************

Function Name	: VerifyVersion

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The version of this coefs structure.

Description		:  

When initialized, each coefs structure is 'stamped' with it's version.
The location of this variable in the structure is fixed, and thus all future versions of
SVerb will know to read it.

Note : as explained above, in normal uses coefs should not be saved to files, rather the 
'real-world' settings should be saved and coefs re-initialized in run-time.
*****************************************************************************/

long VerifyVersion(void *pC) {
	return ((sCoefsStruct *)pC)->myVersion; 
};

/****************************************************************************

Function Name	: VerifySize

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The size of this coefs structure.

Description		:  

When initialized, each coefs structure is 'stamped' with it's size.
The location of this variable in the structure is fixed, and thus all future versions of
SVerb will know to read it.

Note : as explained above, in normal uses coefs should not be saved to files, rather the 
'real-world' settings should be saved and coefs re-initialized in run-time.
*****************************************************************************/

long VerifySize(void *pC) {
	return ((sCoefsStruct *)pC)->mySize; 
};


/****************************************************************************

Function Name	: InitSVerbStates

Input Arguments : 

 float *pStates	: The pointer to the states memory.

Return Value    : none.

Description		:  

After allocating memory for the states, according to thge size returned by 'GetStatesSize'
The application MUST initialize the states using this function. 
Note : in future versions this may be more complex than simply memset to 0...
*****************************************************************************/

void InitSVerbStates( long *pStates )
{
    memset( pStates, 0, GetStatesSize() ) ;
}

/****************************************************************************

Function Name	: DToF16

Input Arguments : 

 float SampleRate	: The sampling rate.
 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

Converts a float number between -1.0 .. 1.0 to a 16bits integer 
fixed point representation.
This allows for fix point arithmetics, where two 16bits integers are multiplied to 
a 32bits integer, and we than take the upper 16 bits of the result.

*****************************************************************************/

long DToF16( float dbl  )
{
	dbl *= MAX_16;
	dbl = max(-MAX_16,min(MAX_16-(float)1.0,dbl+(float)0.5));
	return (long)(dbl);
}

/****************************************************************************

Function Name	: ConvertCoefsToFix

Input Arguments : 

 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  converts coefficients to longs, as fixed point numbers

*****************************************************************************/


void ConvertCoefsToFix( void *pC )
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);

//		float directGain; 

	pCoefs->l_directGain =  DToF16(pCoefs->directGain);

//		float revGain; 
	pCoefs->l_revGain =  DToF16(pCoefs->revGain);
//		float dDsps;
	pCoefs->l_dDsps =  DToF16(pCoefs->dDsps);
//		float dDG1;
	pCoefs->l_dDG1 =  DToF16(pCoefs->dDG1);
//		float dDG2; 
	pCoefs->l_dDG2 =  DToF16(pCoefs->dDG2);
//	float dFB11;
	pCoefs->l_dFB11 =  DToF16(pCoefs->dFB11);
//		float dFB12;
	pCoefs->l_dFB12 =  DToF16(pCoefs->dFB12);
//		float dFB21;
	pCoefs->l_dFB21 =  DToF16(pCoefs->dFB21);
//		float dFB22;
	pCoefs->l_dFB22 =  DToF16(pCoefs->dFB22);
//		float dFB31;
	pCoefs->l_dFB31 =  DToF16(pCoefs->dFB31);
//		float dFB32;
	pCoefs->l_dFB32 =  DToF16(pCoefs->dFB32);
//		float dFB41;
	pCoefs->l_dFB41 =  DToF16(pCoefs->dFB41);
//		float dFB42;
	pCoefs->l_dFB42 =  DToF16(pCoefs->dFB42);
//		float dDamp;
	pCoefs->l_dDamp =  DToF16(pCoefs->dDamp);



}

/****************************************************************************

Function Name	: InitSVerb

Input Arguments : 

 float SampleRate	: The sampling rate.
 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

After allocating memory for the coefs, according to thge size returned by 'GetCoefsSize'
The application MUST initialize the coefs using this function. 
The initialization takes the sampling rate as an argument, ans thus is valid per this
sampling rate only.

It is possible to find out what is the sampling rate a coefs structure is valid for by calling 
the function 'VerifySampleRate'.

This function initialises the SVerb to so reasonable default setting by calling 'SetSVerb' with
the following real-world settings :

InGain				= -3.0dB   (to avoid output overflows)
dRevMix				= -6.0dB   (a reasonable reverb mix)
dRevTime			= 1000.0ms (one second global reverb time)
dHighFreqRTRatio	= 0.001    (the ratio of the high frequencies to the global reverb time) 

*****************************************************************************/

void InitSVerb( float SampleRate, void *pC)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
 	//Magic numbers ...
    long lRefD;
	
	float dRatio =  (float)1.189207115003;
	
	float dD2MRatio = (float)0.2309333333;

	pCoefs->mySize = sizeof(sCoefsStruct);
	pCoefs->myVersion = 0x1;

	pCoefs->dDsps =  (float)0.6180339887499;

	pCoefs->SampleRate = SampleRate;

    lRefD = (long)( 0.5 + 0.045 * pCoefs->SampleRate ) ;

	pCoefs->lDelay1 = lRefD;
	pCoefs->lDelay3 = (long)(0.5 + dRatio * (float)pCoefs->lDelay1);
	pCoefs->lDelay2 = (long)(0.5 + dRatio * (float)pCoefs->lDelay3);
	pCoefs->lDelay4 = (long)(0.5 + dRatio * (float)pCoefs->lDelay2);
  
    pCoefs->lDDly1 = (long)(0.5 + 0.5 * dD2MRatio * (float)(pCoefs->lDelay1+pCoefs->lDelay2));
	pCoefs->lDDly2 = (long)(0.5 + 0.5 * dD2MRatio * (float)(pCoefs->lDelay3+pCoefs->lDelay4));

    pCoefs->lDelay1 -= pCoefs->lDDly1 ;    
    pCoefs->lDelay2 -= pCoefs->lDDly1 ;    
    pCoefs->lDelay3 -= pCoefs->lDDly2 ;    
    pCoefs->lDelay4 -= pCoefs->lDDly2 ;        

    pCoefs->lDelay1 <<= 2;    
    pCoefs->lDelay2 <<= 2;    
    pCoefs->lDelay3 <<= 2;    
    pCoefs->lDelay4 <<= 2;        

	pCoefs->lDDly1 <<= 1;
	pCoefs->lDDly2 <<= 1;

	SetSVerb( (float)0.0, (float)-10.0, (float)1000.0, (float)0.001, pC );

}

/****************************************************************************

Function Name	: SetSVerb

Input Arguments : 

InGain				: input gain in dB (to avoid output overflows)

dRevMix				: Reverb mix in dB. 0dB means 100% wet reverb (no direct signal)
                      Negative values gives less wet signal.
					  The coeficients are calculated so that the overall output level stays 
					  (approximately) constant regardless of the ammount of reverb mix.
dRevTime			: The global reverb time (decay time) in milliseconds.

dHighFreqRTRatio	: The ratio of the high frequencies to the global reverb time. 
					  Unless very 'splashy-bright' reverbs are wanted, this should be set to 
					  a value < 1.0.
					  For example if dRevTime==1000ms and dHighFreqRTRatio=0.1 than the 
					  decay time for high frequencies will be 100ms.

void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

This function accepts the 'real world' settings or SVerb and computes the corresponding 
coefs structure.

The coefs pointer passed to it MUST have been initialized first by InitSVerb.

In normal uses one coefs structure is allocated, initialized, and than as the user changes 
SVerb settings this function should be called repeatedly with the same coefs pointer and the 
new 'real world' settings. 

And the coefs structure passed to the process function in the next buffer to process.

Also few coefs structures can be pre allocated, and initialized, and than different 'presets' 
can be pre-computed into each of them, and switched in real time. 

The coefs structures should not be saved to files by the application for future uses, rather 
the 'real world' settings them selvs. This way future compatibility is guaranteed.

*****************************************************************************/

void SetSVerb( float InGain, float dRevMix, 
			   float dRevTime, float dHighFreqRTRatio, void *pC )
{


	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);

    float dD,dTmp,dInGain,dRevGain;

	float dHfR;
    float dAPS;

    if (dHighFreqRTRatio > (float) 0.999)
    {
        dHighFreqRTRatio = (float) 0.999;
    }
    if (dHighFreqRTRatio <= (float) 0.0)
    {
        dHighFreqRTRatio = (float) 0.001;
    }
    dHfR = ( (float)1.0/dHighFreqRTRatio - (float)1.0);

    if (dRevTime < (float) 0.001) 
    {
        dRevTime = (float) 0.001;
    }

    if (InGain > (float) 0.0)
    {
        InGain = (float) 0.0;
    }

    if (dRevMix > (float) 0.0)
    {
        dRevMix = (float) 0.0;
    }

    if (pCoefs->SampleRate < (float) 1.0) 
    {
        pCoefs->SampleRate = (float) 22050.0;
    }

    dAPS = (float)(-3000.0) / (pCoefs->SampleRate * dRevTime);


    pCoefs->dDamp = 0.0;

 	pCoefs->dDG1 = (float)pow((float)10.0,(float)(pCoefs->lDDly1>>1)*dAPS);
 	pCoefs->dDG2 = (float)pow((float)10.0,(float)(pCoefs->lDDly2>>1)*dAPS);

	//////////////////////////////

		pCoefs->dFB11 = (float)pow((float)10.0,(float)(pCoefs->lDelay1>>2)*dAPS);
        
		dD = pCoefs->dFB11 * pCoefs->dDG1;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly1>>1)+(pCoefs->lDelay1>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB12 = pCoefs->dFB11 * dTmp;
		pCoefs->dFB11 *= ((float)1.0-dTmp);

	///////////////////////////////

		pCoefs->dFB21 = (float)pow((float)10.0,(float)(pCoefs->lDelay2>>2)*dAPS);
        
		dD = pCoefs->dFB21 * pCoefs->dDG1;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly1>>1)+(pCoefs->lDelay2>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB22 = pCoefs->dFB21 * dTmp;
		pCoefs->dFB21 *= ((float)1.0-dTmp);

	////////////////////////////////

		pCoefs->dFB31 = (float)pow((float)10.0,(float)(pCoefs->lDelay3>>2)*dAPS);
        
		dD = pCoefs->dFB31 * pCoefs->dDG2;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
		    pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly2>>1)+(pCoefs->lDelay3>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB32 = pCoefs->dFB31 * dTmp;
		pCoefs->dFB31 *= ((float)1.0-dTmp);


	//////////////////////////////

		pCoefs->dFB41 = (float)pow((float)10.0,(float)(pCoefs->lDelay4>>2)*dAPS);

        dD = pCoefs->dFB41 * pCoefs->dDG2;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly2>>1)+(pCoefs->lDelay4>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB42 = pCoefs->dFB41 * dTmp;
		pCoefs->dFB41 *= ((float)1.0-dTmp);


    pCoefs->dDamp = (float)sqrt(pCoefs->dDamp);

 	dInGain = (float)pow((float)10.0, (float)0.05*InGain ) ;
	dRevMix = (float)pow((float)10.0,(float)0.1*dRevMix);

	dRevGain = (float)4.0 / pCoefs->dDamp * dInGain;

	//in the DSP we used -  	 
	

	pCoefs->directGain = dInGain * (float)sqrt((float)1.0-dRevMix);
	pCoefs->revGain = dRevGain * (float)sqrt(dRevMix);

	ConvertCoefsToFix( pC );

}

///////////////////////////////////////////////////////////////////////////////////////
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/
/* Process functions */
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/

/**********************************************************************************

Bellow are 6 different process functions.
The difference between the functions is only in the input/output data formats.

3 functions support short samples input/output.
3 other functions support float samples input/output.

Per each of the data types there are 3 functions :

  Mono-Mono
  Mono-Stereo
  Stereo-Stereo

The names of the functions are clear to which format they apply.

Stereo data is always interlaced left,right samples.

All process functions have basically the same format namely :

  SVerbXXXXXX(long NumInFrames, short *pInShort, short *pOutShort, 
			  void *pC, float *pStates)

Input arguments :

long NumInFrames	: Number of input frames
short *pInXXX		: Pointer to input buffer.
					  Each function expects the data format suggested by it's name in terms of
					  data type (short or float) and mono/stereo.
short *pOutXXX		: Pointer to output buffer.
					  Each function expects the data format suggested by it's name in terms of
					  data type (short or float) and mono/stereo.

void *pC			: The coefs structure allocated and initialized as explained above.
float *pStates		: The states structure allocated and initialized as explained above.

*******************************************************************************************/

void SVerbMonoToMonoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						  void *pC, long *pStates)
{

	sCoefsStruct *pCoefs =  ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (long)(*pInShort++)>>1;

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			Out1 += Out2;
			CLIP_SHORT_TO_SHORT(Out1)

			*pOutShort++ = (short)(Out1);
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

#ifdef USE_ALL_VERBS
void SVerbMonoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						    void *pC, long *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (long)(*pInShort++);
			In1 += (In1>>1) - (In1>>2);
			In2 = In1;

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			CLIP_SHORT_TO_SHORT(Out1)
			CLIP_SHORT_TO_SHORT(Out2)

			*pOutShort++ = (short)(Out1);
			*pOutShort++ = (short)(Out2);
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}
#endif

void SVerbStereoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						      void *pC, long *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (long)(*pInShort++);
			In2 = (long)(*pInShort++);

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			CLIP_SHORT_TO_SHORT(Out1)
			CLIP_SHORT_TO_SHORT(Out2)

			*pOutShort++ = (short)(Out1);
			*pOutShort++ = (short)(Out2);
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

#ifdef USE_ALL_VERBS

void SVerbMonoToMonoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						  void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (float)0.5 * (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1+Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

void SVerbMonoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						    void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (float)0.7071 * (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1;
			*pOutFloat++ = Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

void SVerbStereoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						      void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (*pInFloat++) + FPU_DENORM_OFFS;
			In2 = (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1;
			*pOutFloat++ = Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

__inline void dsps( float *pDly, long ref, long delay, float dDG1, float dDsps, float *inL, float *inR )
{
	float outL, outR;
	float *pDlyOut; 

    pDlyOut = pDly + ((ref+delay) & DSPS_MASK);
    pDly += (ref & DSPS_MASK);

    outL = dDG1 * (*pDlyOut++) + *inR * dDsps;
	outR = dDG1 * (*pDlyOut) - *inL * dDsps ;

    // here we feed back the output.
	*pDly++ = *inL + dDsps * outR ;
	*pDly = *inR - dDsps * outL ;

	*inL = outL;
	*inR = outR;

}
#endif

__inline void dspsL( long *pDly, long ref, long delay, long dDG1, long dDsps, long *inL, long *inR )
{
	long outL, outR;
	long *pDlyOut; 

    pDlyOut = pDly + ((ref+delay) & DSPS_MASK);
    pDly += (ref & DSPS_MASK);

    outL = (dDG1 * (*pDlyOut++) + *inR * dDsps)>>15;

	outR = (dDG1 * (*pDlyOut) - *inL * dDsps)>>15;

    // here we feed back the output.
	*pDly++ = *inL + ((dDsps * outR)>>15) ;

	*pDly = *inR - ((dDsps * outL)>>15) ;

	*inL = outL;
	*inR = outR;

}
#pragma optimize( "ty", off )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\sverbp.h ===
//
//
//
#ifndef _DirectSoundSVerb_p_
#define _DirectSoundSVerb_p_

#include "dsdmobse.h"
#include "dmocom.h"
#include "dsdmo.h"
#include "PropertyHelp.h"
#include "param.h"

class CDirectSoundWavesReverbDMO :
    public CDirectSoundDMO,
    public CParamsManager,
    public ISpecifyPropertyPages,
    public IDirectSoundFXWavesReverb,
    public CParamsManager::UpdateCallback,
    public CComBase
{
public:
    CDirectSoundWavesReverbDMO( IUnknown *pUnk, HRESULT *phr );
    ~CDirectSoundWavesReverbDMO();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
    static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);

    // InitOnCreation is called by the class factory to give the object a chance to initialize
    // immediately after it is created.  This is used to prepare the object's parameter information.
    HRESULT InitOnCreation();

    // The Init function is an override from the  CPCMDMO base class and it provides initialization
    // for the effect's actual audio processing.  Note that InputType must have been set before this
    // occurs in order for this to work.
    HRESULT Init();

    STDMETHOD(Clone)                (THIS_ IMediaObjectInPlace **);
    
        
    STDMETHOD(SetAllParameters)          (THIS_ LPCDSFXWavesReverb p);        
    STDMETHOD(GetAllParameters)          (THIS_ LPDSFXWavesReverb p);        
    
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropWavesReverb, pPages); }

    // IPersist methods
    virtual HRESULT STDMETHODCALLTYPE GetClassID( CLSID *pClassID );

    // IPersistStream
    STDMETHOD(IsDirty)(void) 
    { return m_fDirty ? S_OK : S_FALSE; }
    
    STDMETHOD(Load)(IStream *pStm) 
    { return PropertyHelp::Load(this, DSFXWavesReverb(), pStm); }
    
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) 
    { return PropertyHelp::Save(this, DSFXWavesReverb(), pStm, fClearDirty); }
    
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) 
    { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXWavesReverb); return S_OK; }

    // SetParam handling
    STDMETHODIMP SetParam(DWORD dwParamIndex,MP_DATA value);
    HRESULT SetParamUpdate(DWORD dwParamIndex, MP_DATA value) { return SetParamInternal(dwParamIndex, value, true); }
    HRESULT SetParamInternal(DWORD dwParamIndex, MP_DATA value, bool fSkipPasssingToParamManager);

    // Overrides
    //
    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
    HRESULT ProcessInPlace(ULONG ulQuanta, LPBYTE pcbData, REFERENCE_TIME rtStart, DWORD dwFlags);
    HRESULT Discontinuity();

    // Called whenever a parameter has changed to recalculate the effect coefficients based on the cached parameter values.
    void UpdateCoefficients();

    bool                m_fDirty;

private:
    bool                m_fInitCPCMDMO;
    
    // cached parameter values
    MP_DATA m_fGain;
    MP_DATA m_fMix;
    MP_DATA m_fTime;
    MP_DATA m_fRatio;

    void (*m_pfnSVerbProcess)(long, short*, short*, void*, long*);
    
    // Internal SVerb state
    //
    BYTE               *m_pbCoeffs;
    long               *m_plStates;

protected:
	HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
};

EXT_STD_CREATE(WavesReverb);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\controlhelp.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Implementation of CSliderValue.
//

#include "stdafx.h"
#include "ControlHelp.h"
#include <commctrl.h>
#include <stdio.h>

//////////////////////////////////////////////////////////////////////////////
// CSliderValue

const short g_sMaxContinuousTicks = 100;
const int g_iMaxCharBuffer = 50; // # characters big enough to hold -FLT_MAX with room to spare

CSliderValue::CSliderValue()
  : m_fInit(false)
{
}

void CSliderValue::Init(
        HWND        hwndSlider,
        HWND        hwndEdit,
        float       fMin, 
        float       fMax, 
        bool        fDiscrete)
{
    m_hwndSlider = hwndSlider;
    m_hwndEdit = hwndEdit;
    m_fMin = fMin;
    m_fMax = fMax;
    m_fDiscrete = fDiscrete;

    short sMin;
    short sMax;
    short sTicks = 4; // Lots of ticks become less useful as guides.  Use quarters for fine-grained sliders.
    if (m_fDiscrete) 
    {
        sMin = static_cast<short>(fMin);
        sMax = static_cast<short>(fMax);
        if (sMax - sMin <= 10)
            sTicks = sMax - sMin;
    }
    else
    {
        sMin = 0;
        sMax = g_sMaxContinuousTicks;
    }
    
    SendMessage(m_hwndSlider, TBM_SETRANGE, TRUE, MAKELONG(sMin, sMax));
    SendMessage(m_hwndSlider, TBM_SETTICFREQ, (sMax - sMin) / sTicks, 0);
    m_fInit = true;
}

void CSliderValue::SetValue(float fPos)
{
    if (!m_fInit)
        return;

    UpdateEditBox(fPos);
    UpdateSlider();
}

float CSliderValue::GetValue()
{
    if (!m_fInit)
        return 0;

    LRESULT lrLen = SendMessage(m_hwndEdit, WM_GETTEXTLENGTH, 0, 0);
    if (lrLen >= g_iMaxCharBuffer)
        return 0;

    char szText[g_iMaxCharBuffer] = "";
    SendMessage(m_hwndEdit, WM_GETTEXT, g_iMaxCharBuffer, reinterpret_cast<LPARAM>(szText));

    float fVal = static_cast<float>(m_fDiscrete ? atoi(szText) : atof(szText));

    if (fVal < m_fMin) fVal = m_fMin;
    if (fVal > m_fMax) fVal = m_fMax;
    return fVal;
}

float CSliderValue::GetSliderValue()
{
    short sPos = static_cast<short>(SendMessage(m_hwndSlider, TBM_GETPOS, 0, 0));
    if (m_fDiscrete)
    {
        return sPos;
    }

    float fRet = (m_fMax - m_fMin) * sPos / g_sMaxContinuousTicks + m_fMin;
    return fRet;
}

LRESULT CSliderValue::MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_fInit)
        return FALSE;

    bHandled = FALSE;

    switch (uMsg)
    {
    case WM_HSCROLL:
        if (reinterpret_cast<HWND>(lParam) == m_hwndSlider && LOWORD(wParam) >= TB_LINEUP && LOWORD(wParam) <= TB_ENDTRACK)
        {
            UpdateEditBox(GetSliderValue());
            bHandled = TRUE;
        }
        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == EN_KILLFOCUS && reinterpret_cast<HWND>(lParam) == m_hwndEdit)
        {
            UpdateSlider();
            bHandled = TRUE;
        }
        break;
    }

    return 0;
}

void CSliderValue::UpdateEditBox(float fPos)
{
    char szText[g_iMaxCharBuffer] = "";

    if (m_fDiscrete)
    {
        short sPos = static_cast<short>(fPos);
        sprintf(szText, "%hd", sPos);
    }
    else
    {
        sprintf(szText, "%.3hf", fPos);
    }

    SendMessage(m_hwndEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(szText));
}

void CSliderValue::UpdateSlider()
{
    float fVal = GetValue();
    short sPos = static_cast<short>(m_fDiscrete ? fVal : g_sMaxContinuousTicks * ((fVal - m_fMin) / (m_fMax - m_fMin)));
    SendMessage(m_hwndSlider, TBM_SETPOS, TRUE, sPos);
    UpdateEditBox(fVal); // this resets the input box back to the set float value in case the input was invalid
}

//////////////////////////////////////////////////////////////////////////////
// CSliderValue

CRadioChoice::CRadioChoice(const ButtonEntry *pButtonInfo)
  : m_pButtonInfo(pButtonInfo)
{
}

void CRadioChoice::SetChoice(HWND hDlg, LONG lValue)
{
    for (const ButtonEntry *p = m_pButtonInfo; p->nIDDlgItem; ++p)
    {
        if (p->lValue == lValue)
        {
            CheckDlgButton(hDlg, p->nIDDlgItem, BST_CHECKED);
            return;
        }
    }
}

LONG CRadioChoice::GetChoice(HWND hDlg)
{
    for (const ButtonEntry *p = m_pButtonInfo; p->nIDDlgItem; ++p)
    {
        if (BST_CHECKED == IsDlgButtonChecked(hDlg, p->nIDDlgItem))
        {
            return p->lValue;
        }
    }

    return 0;
}

LRESULT CRadioChoice::MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    bHandled = FALSE;

    if (uMsg == WM_COMMAND && HIWORD(wParam) == BN_CLICKED)
    {
        for (const ButtonEntry *p = m_pButtonInfo; p->nIDDlgItem; ++p)
        {
            if (p->nIDDlgItem == LOWORD(wParam))
            {
                bHandled = TRUE;
                return 0;
            }
        }
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// MessageHandlerChain

LRESULT MessageHandlerChain(Handler **ppHandlers, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = 0;
    bHandled = FALSE;

    for (Handler **pp = ppHandlers; *pp && !bHandled; ++pp)
    {
        lr = (*pp)->MessageHandler(uMsg, wParam, lParam, bHandled);
    }
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmo\validate.h ===
//
// validate.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Parameter validation macros
//
// Summary:
//
// V_INAME(interfacename)                - Set the interface name for error display
// V_STRUCTPTR_READ(ptr,type)            - A dwSize struct which we will read
// V_STRUCTPTR_WRITE(ptr,type)           - A dwSize struct which we will read/write
// V_PTR_READ(ptr,type)                  - A typed ptr w/o a dwSize which we will read
// V_PTR_WRITE(ptr,type)                 - A typed ptr w/o a dwSize which we will read/write
// V_PTR_WRITE_OPT(ptr,type)             - An optional typed ptr w/o a dwSize which we will read/write
// V_BUFPTR_READ(ptr,size)               - A variable-size buffer that we will read
// V_BUFPTR_READ_OPT(ptr,size)			 - An optional variable-size buffer that we will read
// V_BUFPTR_WRITE(ptr,size)              - A variable-size buffer that we will read/write
// V_BUFPTR_WRITE_OPT(ptr,size)          - An optional variable-size buffer that we will read/write
// V_PTRPTR_WRITE(ptrptr)                - A pointer to a pointer to write to
// V_PTRPTR_WRITE_OPT(ptrptr)            - A pointer to a pointer to write to that is optional
// V_PUNKOUTER(punk)                     - A pointer to a controlling unknown, aggregation supported
// V_PUNKOUTER_NOADD(punk)               - A pointer to a controlling unknown, aggregation not supported
// V_INTERFACE(ptr)                      - A pointer to a COM interface
// V_INTERFACE_OPT(ptr)                  - An optional pointer to a COM interface
// V_REFGUID(ref)                        - A reference to a GUID (type REFGUID)
// V_HWND(hwnd)							 - A window handle
// V_HWNDOPT(hwnd)						 - An optional window handle
//
// For handling different versions of structures:
// 
// V_STRUCTPTR_READ_VER(ptr,ver)         - Begin a struct version block for read access
//                                         At the end, 'ver' will contain the 
//                                         discovered version of the struct
// V_STRUCTPTR_READ_VER_CASE(base,ver)   - Test struct against version ver of
//                                         type 'base'. 
// V_STRUCTPTR_READ_VER_END(base,ptr)    - End a struct version block
//
// V_STRUCTPTR_WRITE_VER(ptr,ver)        - Struct version block for write access
// V_STRUCTPTR_WRITE_VER_CASE(base,ver)
// V_STRUCTPTR_WRITE_VER_END(base,ptr)
//
// The struct version block expects type names of a base type followed by a 
// numeric version, such as
//
// typedef struct { } FOO7;
// typedef struct { } FOO8;
//
// In the header FOO and LPFOO are conditionally typedef'd based on a version
// #define. The DLL will be compiled with the latest version number and hence
// the largest version of the struct.
//
// Since Windows headers are compiled by default with 8-byte alignment, adding
// one DWORD may not cause the size of the structure to change. If this happens
// you will get a 'case label already used' error on one of the VER_CASE macros.
// If this happens, you can get around it by adding a dwReserved field to the 
// end of the struct to force the padding.
//
// 'optional' means the pointer is allowed to be NULL by the interface specification.
//
// Sample usage:
//
// int IDirectMusic::SetFooBarInterface(
//     LPDMUS_REQUESTED_CAPS    pCaps,          // Caps w/ dwSize (read-only)
//     LPVOID                   pBuffer,        // Buffer we will fill in
//     DWORD                    cbSize,         // Size of the buffer
//     PDIRECTMUSICBAR          pBar)           // Callback interface for bar on this buffer
// {
//     V_INTERFACE(IDirectMusic::SetFooBarInterface);
//     V_BUFPTR_WRITE(pBuffer, cbSize);
//     V_INTERFACE(pBar);
//     DWORD dwCapsVer;                         // Must be a DWORD!!!
//
//     V_STRUCTPTR_READ_VER(pCaps, dwCapsVer);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 7);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 8);
//     V_STRUCTPTR_READ_VER_END_(DMUS_REQUESTED_CAPS, pCaps);
//
//     // At this point, if we are still in the function we have a valid pCaps
//     // pointer and dwCapsVer is either 7 or 8, indicating the version of
//     // the struct passed in.
//
//     ...
// }
//
#ifndef _VALIDATE_H_
#define _VALIDATE_H_


#ifdef DBG
#include <stddef.h>

#include "debug.h"

// To turn on DebugBreak on parameter error, use the following or -DRIP_BREAK in the build:
//
//#define RIP_BREAK 1

#ifdef RIP_BREAK
#define _RIP_BREAK DebugBreak();
#else
#define _RIP_BREAK 
#endif

#define V_INAME(x) \
    static const char __szValidateInterfaceName[] = #x;                       

#define RIP_E_POINTER(ptr) \
{   Trace(-1, "%s: Invalid pointer " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_POINTER; }

#define RIP_E_INVALIDARG(ptr) \
{   Trace(-1, "%s: Invalid argument " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }

#define RIP_E_HANDLE(h) \
{	Trace(-1, "%s: Invalid handle " #h "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
	return E_HANDLE; }
    
#define RIP_W_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize matches no known structure size. Defaulting to oldest structure.\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    }
    
#define RIP_E_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize is too small\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }
    
#define RIP_E_BLOCKVSDWSIZE(ptr) \
{   Trace(-1, "%s: " #ptr " does not point to as much memory as " #ptr "->dwSize indicates\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }    

// NOTE: The DebugBreak() not in #ifdef is intentional - this is something that
// must be fixed in our code, not an app-generated error.
//
#define V_ASSERT(exp) \
{   if (!(exp)) { \
        Trace(-1, "%s@%s: %s\n", __FILE__, __LINE__, #exp); \
        DebugBreak(); }}

#else

#define V_INAME(x)
#define RIP_E_POINTER(ptr)          { return E_POINTER; }
#define RIP_E_INVALIDARG(ptr)       { return E_INVALIDARG; }
#define RIP_E_HANDLE(h)	            { return E_HANDLE; }
#define RIP_E_BLOCKVSDWSIZE(ptr)    { return E_INVALIDARG; }
#define RIP_W_INVALIDSIZE(ptr)
#define RIP_E_INVALIDSIZE(ptr)      { return E_INVALIDARG; }
#define V_ASSERT(exp)

#endif          // DBG

// A passed struct we will only read from or may write to. Must be a struct
// with a dwSize.
//
// int foo(CFoo *pFoo)
// ...
// V_STRUCTPTR_READ(pFoo, CFoo);
// V_STRUCTPTR_WRITE(pFoo, CFoo);
//
// Use _PTR_ variants for structs w/o a dwSize
//
#define V_STRUCTPTR_READ(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_STRUCTPTR_WRITE(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_PTR_READ(ptr,type) \
{ if (IsBadReadPtr(ptr, sizeof(type)))                  RIP_E_POINTER(ptr); }

#define V_PTR_WRITE(ptr,type) \
{ if (IsBadWritePtr(ptr, sizeof(type)))                 RIP_E_POINTER(ptr); }

#define V_PTR_WRITE_OPT(ptr,type) \
{ if (ptr) if (IsBadWritePtr(ptr, sizeof(type)))        RIP_E_POINTER(ptr); }

// A buffer pointer with separate length (not defined by the pointer type) we will only
// read from or may write to.
//
// int foo(LPVOID *pBuffer, DWORD cbBuffer)
// ...
// V_BUFPTR_READ(pBuffer, cbBuffer);
// V_BUFPTR_WRITE(pBuffer, cbBuffer);
//
#define V_BUFPTR_READ(ptr,len) \
{   if (IsBadReadPtr(ptr, len))                         RIP_E_POINTER(ptr); }

#define V_BUFPTR_READ_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_READ(ptr,len); }

#define V_BUFPTR_WRITE(ptr,len) \
{   if (IsBadWritePtr(ptr, len))                        RIP_E_POINTER(ptr); }

#define V_BUFPTR_WRITE_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_WRITE(ptr,len); }

// A pointer to a pointer (such as a pointer to an interface pointer) to return
//
// int foo(IReturnMe **ppRet)
// ...
// V_PTRPTR_WRITE(ppRet);
// V_PTRPTR_WRITE_OPT(ppRet);
//
#define V_PTRPTR_WRITE(ptr) \
{   if (IsBadWritePtr(ptr, sizeof(void*)))              RIP_E_POINTER(ptr); }

#define V_PTRPTR_WRITE_OPT(ptr) \
{   if (ptr) if (IsBadWritePtr(ptr, sizeof(void*)))     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown
//
#define V_PUNKOUTER(punk) \
{   if (punk && IsBadCodePtr(punk))                     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown for which we don't support aggregation
//
#define V_PUNKOUTER_NOAGG(punk) \
{   if (punk && IsBadReadPtr(punk, sizeof(IUnknown)))   RIP_E_POINTER(ptr); \
    if (punk) return CLASS_E_NOAGGREGATION; }

// Validate an incoming interface pointer. 
//
struct _V_GENERIC_INTERFACE
{
    FARPROC *(__vptr[1]);
};

#define V_INTERFACE(ptr) \
{   if (IsBadReadPtr(ptr, sizeof(_V_GENERIC_INTERFACE)))                              RIP_E_POINTER(ptr); \
    if (IsBadReadPtr(*reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr, sizeof(FARPROC))) \
                                                                                      RIP_E_POINTER(ptr); \
    if (IsBadCodePtr(*(reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr)[0]))     RIP_E_POINTER(ptr); }

#define V_INTERFACE_OPT(ptr) \
{   if (ptr) V_INTERFACE(ptr); }

// Validation for a reference to a GUID, which we only ever read. 
//
#define V_REFGUID(ref) \
{   if (IsBadReadPtr((void*)&ref, sizeof(GUID)))        RIP_E_POINTER((void*)&ref); }

// Validation for a window handle
//
#define V_HWND(h) \
{	if (!IsWindow(h))									RIP_E_HANDLE(h); }	

#define V_HWND_OPT(h) \
{	if (h) if (!IsWindow(h))							RIP_E_HANDLE(h); }	

// Validation for multiple sized structs based on version
//
#define V_STRUCTPTR_READ_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_READ_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
    V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
    *pdw = ver; break;
    
#define V_STRUCTPTR_READ_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}


#define V_STRUCTPTR_WRITE_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_WRITE_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
        V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
        *pdw = ver; break;
    
#define V_STRUCTPTR_WRITE_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}



#endif          // _VALIDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\controlhelp.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Declaration of CSliderValue.
//

#pragma once

class Handler
{
public:
    virtual LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) = 0;
};

class CSliderValue
  : public Handler
{
public:
    CSliderValue();
    void Init(HWND hwndSlider, HWND hwndEdit, float fMin, float fMax, bool fDiscrete);

    void SetValue(float fPos);
    float GetValue();

    LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    bool                m_fInit;
    HWND                m_hwndSlider;
    HWND                m_hwndEdit;
    float               m_fMin;
    float               m_fMax;
    bool                m_fDiscrete;

private:
    float GetSliderValue();
    void UpdateEditBox(float fPos);
    void UpdateSlider();
};

class CRadioChoice
  : public Handler
{
public:
    struct ButtonEntry
    {
        int nIDDlgItem;
        LONG lValue;
    };

    // Create passing a ButtonEntry array terminated by an entry with nIDDlgItem of 0.
    CRadioChoice(const ButtonEntry *pButtonInfo);

    void SetChoice(HWND hDlg, LONG lValue);
    LONG GetChoice(HWND hDlg);

    LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    const ButtonEntry *m_pButtonInfo;
};

// MessageHandlerChain is a helper for implementing the property page message handler.
// It takes a NULL-terminated array of Message pointers (could be CSliderValue or CRadioChoice)
// and calls them in order until one of them sets bHandled.

LRESULT MessageHandlerChain(Handler **ppHandlers, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxchoruspage.h ===
// DirectSoundFXChorusPage.h : Declaration of the CDirectSoundFXChorusPage

#ifndef __DIRECTSOUNDFXCHORUSPAGE_H_
#define __DIRECTSOUNDFXCHORUSPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXChorusPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXChorusPage
class ATL_NO_VTABLE CDirectSoundFXChorusPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXChorusPage, &CLSID_DirectSoundFXChorusPage>,
    public IPropertyPageImpl<CDirectSoundFXChorusPage>,
    public CDialogImpl<CDirectSoundFXChorusPage>
{
public:
    CDirectSoundFXChorusPage();

    enum {IDD = IDD_DIRECTSOUNDFXCHORUSPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXCHORUSPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXChorusPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXChorusPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXChorusPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXChorus> m_IDSFXChorus;
    CSliderValue m_sliderWetDryMix;
    CSliderValue m_sliderDepth;
    CSliderValue m_sliderFeedback;
    CSliderValue m_sliderFrequency;
    CSliderValue m_sliderDelay;
    CSliderValue m_sliderPhase;
    CRadioChoice m_radioWaveform;
    Handler *m_rgpHandlers[8];
};

#endif //__DIRECTSOUNDFXCHORUSPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxchoruspage.cpp ===
// DirectSoundFXChorusPage.cpp : Implementation of CDirectSoundFXChorusPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXChorusPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXChorusPage

const CRadioChoice::ButtonEntry g_rgWaveButtons[] =
    {
        IDC_RADIO_TRIANGLE, DSFXCHORUS_WAVE_TRIANGLE,
        IDC_RADIO_SIN, DSFXCHORUS_WAVE_SIN,
        0
    };

CDirectSoundFXChorusPage::CDirectSoundFXChorusPage()
  : m_radioWaveform(g_rgWaveButtons)
{
    m_dwTitleID = IDS_TITLEDirectSoundFXChorusPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXChorusPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXChorusPage;

    m_rgpHandlers[0] = &m_sliderWetDryMix;
    m_rgpHandlers[1] = &m_sliderDepth;
    m_rgpHandlers[2] = &m_sliderFeedback;
    m_rgpHandlers[3] = &m_sliderFrequency;
    m_rgpHandlers[4] = &m_sliderDelay;
    m_rgpHandlers[5] = &m_sliderPhase;
    m_rgpHandlers[6] = &m_radioWaveform;
    m_rgpHandlers[7] = NULL;
}

STDMETHODIMP CDirectSoundFXChorusPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXChorus, reinterpret_cast<void**>(&m_IDSFXChorus));
    return hr;
}

STDMETHODIMP CDirectSoundFXChorusPage::Apply(void)
{
    if (!m_IDSFXChorus)
        return E_UNEXPECTED;

    DSFXChorus dsfxchorus;
    ZeroMemory(&dsfxchorus, sizeof(DSFXChorus));

    dsfxchorus.fWetDryMix = m_sliderWetDryMix.GetValue();
    dsfxchorus.fDepth = m_sliderDepth.GetValue();
    dsfxchorus.fFeedback = m_sliderFeedback.GetValue();
    dsfxchorus.fFrequency = m_sliderFrequency.GetValue();
    dsfxchorus.fDelay = m_sliderDelay.GetValue();
    dsfxchorus.lPhase = static_cast<short>(m_sliderPhase.GetValue());
    dsfxchorus.lWaveform = m_radioWaveform.GetChoice(*this);

    HRESULT hr = m_IDSFXChorus->SetAllParameters(&dsfxchorus);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXChorusPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXChorus)
        return 1;

    DSFXChorus dsfxchorus;
    ZeroMemory(&dsfxchorus, sizeof(DSFXChorus));
    m_IDSFXChorus->GetAllParameters(&dsfxchorus);

    m_sliderWetDryMix.Init(GetDlgItem(IDC_SLIDER_WetDryMix), GetDlgItem(IDC_EDIT_WetDryMix), 0, 100, false);
    m_sliderWetDryMix.SetValue(dsfxchorus.fWetDryMix);

    m_sliderDepth.Init(GetDlgItem(IDC_SLIDER_Depth), GetDlgItem(IDC_EDIT_Depth), 0, 100, false);
    m_sliderDepth.SetValue(dsfxchorus.fDepth);

    m_sliderFeedback.Init(GetDlgItem(IDC_SLIDER_Feedback), GetDlgItem(IDC_EDIT_Feedback), -99, 99, false);
    m_sliderFeedback.SetValue(dsfxchorus.fFeedback);

    m_sliderFrequency.Init(GetDlgItem(IDC_SLIDER_Frequency), GetDlgItem(IDC_EDIT_Frequency), 0, 10, false);
    m_sliderFrequency.SetValue(dsfxchorus.fFrequency);

    m_sliderDelay.Init(GetDlgItem(IDC_SLIDER_Delay), GetDlgItem(IDC_EDIT_Delay), 0, 20, false);
    m_sliderDelay.SetValue(dsfxchorus.fDelay);

    m_sliderPhase.Init(GetDlgItem(IDC_SLIDER_Phase), GetDlgItem(IDC_EDIT_Phase), 0, 4, true);
    m_sliderPhase.SetValue(static_cast<float>(dsfxchorus.lPhase));

    m_radioWaveform.SetChoice(*this, dsfxchorus.lWaveform);

    return 1;
}

LRESULT CDirectSoundFXChorusPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxechopage.cpp ===
// DirectSoundFXEchoPage.cpp : Implementation of CDirectSoundFXEchoPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXEchoPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXEchoPage

const CRadioChoice::ButtonEntry g_rgPanDelayButtons[] =
    {
        IDC_RADIO_PANNED, 1,
        IDC_RADIO_NOTPANNED, 0,
        0
    };

CDirectSoundFXEchoPage::CDirectSoundFXEchoPage()
  : m_radioPanDelay(g_rgPanDelayButtons)
{
    m_dwTitleID = IDS_TITLEDirectSoundFXEchoPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXEchoPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXEchoPage;

    m_rgpHandlers[0] = &m_sliderWetDryMix;
    m_rgpHandlers[1] = &m_sliderFeedback;
    m_rgpHandlers[2] = &m_sliderLeftDelay;
    m_rgpHandlers[3] = &m_sliderRightDelay;
    m_rgpHandlers[4] = &m_radioPanDelay;
    m_rgpHandlers[5] = NULL;
}

STDMETHODIMP CDirectSoundFXEchoPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXEcho, reinterpret_cast<void**>(&m_IDSFXEcho));
    return hr;
}

STDMETHODIMP CDirectSoundFXEchoPage::Apply(void)
{
    if (!m_IDSFXEcho)
        return E_UNEXPECTED;

    DSFXEcho dsfxecho;
    ZeroMemory(&dsfxecho, sizeof(DSFXEcho));

    dsfxecho.fWetDryMix = m_sliderWetDryMix.GetValue();
    dsfxecho.fFeedback = m_sliderFeedback.GetValue();
    dsfxecho.fLeftDelay = m_sliderLeftDelay.GetValue();
    dsfxecho.fRightDelay = m_sliderRightDelay.GetValue();
    dsfxecho.lPanDelay = m_radioPanDelay.GetChoice(*this);

    HRESULT hr = m_IDSFXEcho->SetAllParameters(&dsfxecho);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXEchoPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXEcho)
        return 1;

    DSFXEcho dsfxecho;
    ZeroMemory(&dsfxecho, sizeof(DSFXEcho));
    m_IDSFXEcho->GetAllParameters(&dsfxecho);

    m_sliderWetDryMix.Init(GetDlgItem(IDC_SLIDER_WetDryMix), GetDlgItem(IDC_EDIT_WetDryMix), 0, 100, false);
    m_sliderWetDryMix.SetValue(dsfxecho.fWetDryMix);

    m_sliderFeedback.Init(GetDlgItem(IDC_SLIDER_Feedback), GetDlgItem(IDC_EDIT_Feedback), 0, 100, false);
    m_sliderFeedback.SetValue(dsfxecho.fFeedback);

    m_sliderLeftDelay.Init(GetDlgItem(IDC_SLIDER_LeftDelay), GetDlgItem(IDC_EDIT_LeftDelay), 1, 2000, false);
    m_sliderLeftDelay.SetValue(dsfxecho.fLeftDelay);

    m_sliderRightDelay.Init(GetDlgItem(IDC_SLIDER_RightDelay), GetDlgItem(IDC_EDIT_RightDelay), 1, 2000, false);
    m_sliderRightDelay.SetValue(dsfxecho.fRightDelay);

    m_radioPanDelay.SetChoice(*this, dsfxecho.lPanDelay);

    return 1;
}

LRESULT CDirectSoundFXEchoPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxdistortionpage.h ===
// DirectSoundFXDistortionPage.h : Declaration of the CDirectSoundFXDistortionPage

#ifndef __DIRECTSOUNDFXDISTORTIONPAGE_H_
#define __DIRECTSOUNDFXDISTORTIONPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXDistortionPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXDistortionPage
class ATL_NO_VTABLE CDirectSoundFXDistortionPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXDistortionPage, &CLSID_DirectSoundFXDistortionPage>,
    public IPropertyPageImpl<CDirectSoundFXDistortionPage>,
    public CDialogImpl<CDirectSoundFXDistortionPage>
{
public:
    CDirectSoundFXDistortionPage();

    enum {IDD = IDD_DIRECTSOUNDFXDISTORTIONPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXDISTORTIONPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXDistortionPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXDistortionPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXDistortionPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXDistortion> m_IDSFXDistortion;
    CSliderValue m_sliderGain;
    CSliderValue m_sliderEdge;
    CSliderValue m_sliderPostEQCenterFrequency;
    CSliderValue m_sliderPostEQBandwidth;
    CSliderValue m_sliderPreLowpassCutoff;
    Handler *m_rgpHandlers[6];
};

#endif //__DIRECTSOUNDFXDISTORTIONPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxdistortionpage.cpp ===
// DirectSoundFXDistortionPage.cpp : Implementation of CDirectSoundFXDistortionPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXDistortionPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXDistortionPage

CDirectSoundFXDistortionPage::CDirectSoundFXDistortionPage()
{
    m_dwTitleID = IDS_TITLEDirectSoundFXDistortionPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXDistortionPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXDistortionPage;

    m_rgpHandlers[0] = &m_sliderGain;
    m_rgpHandlers[1] = &m_sliderEdge;
    m_rgpHandlers[2] = &m_sliderPostEQCenterFrequency;
    m_rgpHandlers[3] = &m_sliderPostEQBandwidth;
    m_rgpHandlers[4] = &m_sliderPreLowpassCutoff;
    m_rgpHandlers[5] = NULL;
}

STDMETHODIMP CDirectSoundFXDistortionPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXDistortion, reinterpret_cast<void**>(&m_IDSFXDistortion));
    return hr;
}

STDMETHODIMP CDirectSoundFXDistortionPage::Apply(void)
{
    if (!m_IDSFXDistortion)
        return E_UNEXPECTED;

    DSFXDistortion dsfxdistortion;
    ZeroMemory(&dsfxdistortion, sizeof(DSFXDistortion));

    dsfxdistortion.fGain = m_sliderGain.GetValue();
    dsfxdistortion.fEdge = m_sliderEdge.GetValue();
    dsfxdistortion.fPostEQCenterFrequency = m_sliderPostEQCenterFrequency.GetValue();
    dsfxdistortion.fPostEQBandwidth = m_sliderPostEQBandwidth.GetValue();
    dsfxdistortion.fPreLowpassCutoff = m_sliderPreLowpassCutoff.GetValue();

    HRESULT hr = m_IDSFXDistortion->SetAllParameters(&dsfxdistortion);
    if (FAILED(hr))
        return hr;

    hr = m_IDSFXDistortion->GetAllParameters(&dsfxdistortion);
    if (FAILED(hr))
        return hr;

    m_sliderGain.SetValue(dsfxdistortion.fGain);
    m_sliderEdge.SetValue(dsfxdistortion.fEdge);
    m_sliderPostEQCenterFrequency.SetValue(dsfxdistortion.fPostEQCenterFrequency);
    m_sliderPostEQBandwidth.SetValue(dsfxdistortion.fPostEQBandwidth);
    m_sliderPreLowpassCutoff.SetValue(dsfxdistortion.fPreLowpassCutoff);

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXDistortionPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXDistortion)
        return 1;

    DSFXDistortion dsfxdistortion;
    ZeroMemory(&dsfxdistortion, sizeof(DSFXDistortion));
    m_IDSFXDistortion->GetAllParameters(&dsfxdistortion);

    m_sliderGain.Init(GetDlgItem(IDC_SLIDER_Gain), GetDlgItem(IDC_EDIT_Gain), -60, 0, false);
    m_sliderGain.SetValue(dsfxdistortion.fGain);

    m_sliderEdge.Init(GetDlgItem(IDC_SLIDER_Edge), GetDlgItem(IDC_EDIT_Edge), 0, 100, false);
    m_sliderEdge.SetValue(dsfxdistortion.fEdge);

    m_sliderPostEQCenterFrequency.Init(GetDlgItem(IDC_SLIDER_PostEQCenterFrequency), GetDlgItem(IDC_EDIT_PostEQCenterFrequency), 100, 8000, true);
    m_sliderPostEQCenterFrequency.SetValue(dsfxdistortion.fPostEQCenterFrequency);

    m_sliderPostEQBandwidth.Init(GetDlgItem(IDC_SLIDER_PostEQBandwidth), GetDlgItem(IDC_EDIT_PostEQBandwidth), 100, 8000 , true);
    m_sliderPostEQBandwidth.SetValue(dsfxdistortion.fPostEQBandwidth);

    m_sliderPreLowpassCutoff.Init(GetDlgItem(IDC_SLIDER_PreLowpassCutoff), GetDlgItem(IDC_EDIT_PreLowpassCutoff), 100, 8000 , true);
    m_sliderPreLowpassCutoff.SetValue(dsfxdistortion.fPreLowpassCutoff);

    return 1;
}

LRESULT CDirectSoundFXDistortionPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxcompressorpage.cpp ===
// DirectSoundFXCompressorPage.cpp : Implementation of CDirectSoundFXCompressorPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXCompressorPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXCompressorPage

CDirectSoundFXCompressorPage::CDirectSoundFXCompressorPage()
{
    m_dwTitleID = IDS_TITLEDirectSoundFXCompressorPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXCompressorPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXCompressorPage;

    m_rgpHandlers[0] = &m_sliderGain;
    m_rgpHandlers[1] = &m_sliderAttack;
    m_rgpHandlers[2] = &m_sliderRelease;
    m_rgpHandlers[3] = &m_sliderThreshold;
    m_rgpHandlers[4] = &m_sliderRatio;
    m_rgpHandlers[5] = &m_sliderPredelay;
    m_rgpHandlers[6] = NULL;
}

STDMETHODIMP CDirectSoundFXCompressorPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXCompressor, reinterpret_cast<void**>(&m_IDSFXCompressor));
    return hr;
}

STDMETHODIMP CDirectSoundFXCompressorPage::Apply(void)
{
    if (!m_IDSFXCompressor)
        return E_UNEXPECTED;

    DSFXCompressor dsfxcompressor;
    ZeroMemory(&dsfxcompressor, sizeof(DSFXCompressor));

    dsfxcompressor.fGain = m_sliderGain.GetValue();
    dsfxcompressor.fAttack = m_sliderAttack.GetValue();
    dsfxcompressor.fRelease = m_sliderRelease.GetValue();
    dsfxcompressor.fThreshold = m_sliderThreshold.GetValue();
    dsfxcompressor.fRatio = m_sliderRatio.GetValue();
    dsfxcompressor.fPredelay = m_sliderPredelay.GetValue();

    HRESULT hr = m_IDSFXCompressor->SetAllParameters(&dsfxcompressor);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXCompressorPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXCompressor)
        return 1;

    DSFXCompressor dsfxcompressor;
    ZeroMemory(&dsfxcompressor, sizeof(DSFXCompressor));
    m_IDSFXCompressor->GetAllParameters(&dsfxcompressor);

    m_sliderGain.Init(GetDlgItem(IDC_SLIDER_Gain), GetDlgItem(IDC_EDIT_Gain), -60, 60, false);
    m_sliderGain.SetValue(dsfxcompressor.fGain);

    m_sliderAttack.Init(GetDlgItem(IDC_SLIDER_Attack), GetDlgItem(IDC_EDIT_Attack), static_cast<float>(.01), 500, false);
    m_sliderAttack.SetValue(dsfxcompressor.fAttack);

    m_sliderRelease.Init(GetDlgItem(IDC_SLIDER_Release), GetDlgItem(IDC_EDIT_Release), 50, 3000, false);
    m_sliderRelease.SetValue(dsfxcompressor.fRelease);

    m_sliderThreshold.Init(GetDlgItem(IDC_SLIDER_Threshold), GetDlgItem(IDC_EDIT_Threshold), -60, 0, false);
    m_sliderThreshold.SetValue(dsfxcompressor.fThreshold);

    m_sliderRatio.Init(GetDlgItem(IDC_SLIDER_Ratio), GetDlgItem(IDC_EDIT_Ratio), 1, 100, false);
    m_sliderRatio.SetValue(dsfxcompressor.fRatio);

    m_sliderPredelay.Init(GetDlgItem(IDC_SLIDER_Predelay), GetDlgItem(IDC_EDIT_Predelay), 0, 4, false);
    m_sliderPredelay.SetValue(dsfxcompressor.fPredelay);
    
    return 1;
}

LRESULT CDirectSoundFXCompressorPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxcompressorpage.h ===
// DirectSoundFXCompressorPage.h : Declaration of the CDirectSoundFXCompressorPage

#ifndef __DIRECTSOUNDFXCOMPRESSORPAGE_H_
#define __DIRECTSOUNDFXCOMPRESSORPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXCompressorPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXCompressorPage
class ATL_NO_VTABLE CDirectSoundFXCompressorPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXCompressorPage, &CLSID_DirectSoundFXCompressorPage>,
    public IPropertyPageImpl<CDirectSoundFXCompressorPage>,
    public CDialogImpl<CDirectSoundFXCompressorPage>
{
public:
    CDirectSoundFXCompressorPage();

    enum {IDD = IDD_DIRECTSOUNDFXCOMPRESSORPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXCOMPRESSORPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXCompressorPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXCompressorPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXCompressorPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXCompressor> m_IDSFXCompressor;
    CSliderValue m_sliderGain;
    CSliderValue m_sliderAttack;
    CSliderValue m_sliderRelease;
    CSliderValue m_sliderThreshold;
    CSliderValue m_sliderRatio;
    CSliderValue m_sliderPredelay;
    CSliderValue m_sliderCompMeterReset;
    CSliderValue m_sliderCompInputMeter;
    CSliderValue m_sliderCompGainMeter;
    Handler *m_rgpHandlers[7];
};

#endif //__DIRECTSOUNDFXCOMPRESSORPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxechopage.h ===
// DirectSoundFXEchoPage.h : Declaration of the CDirectSoundFXEchoPage

#ifndef __DIRECTSOUNDFXECHOPAGE_H_
#define __DIRECTSOUNDFXECHOPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXEchoPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXEchoPage
class ATL_NO_VTABLE CDirectSoundFXEchoPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDirectSoundFXEchoPage, &CLSID_DirectSoundFXEchoPage>,
	public IPropertyPageImpl<CDirectSoundFXEchoPage>,
	public CDialogImpl<CDirectSoundFXEchoPage>
{
public:
	CDirectSoundFXEchoPage();

	enum {IDD = IDD_DIRECTSOUNDFXECHOPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXECHOPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXEchoPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXEchoPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
	CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXEchoPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXEcho> m_IDSFXEcho;
    CSliderValue m_sliderWetDryMix;
    CSliderValue m_sliderFeedback;
    CSliderValue m_sliderLeftDelay;
    CSliderValue m_sliderRightDelay;
    CRadioChoice m_radioPanDelay;
    Handler *m_rgpHandlers[6];
};

#endif //__DIRECTSOUNDFXECHOPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxflangerpage.h ===
// DirectSoundFXFlangerPage.h : Declaration of the CDirectSoundFXFlangerPage

#ifndef __DIRECTSOUNDFXFLANGERPAGE_H_
#define __DIRECTSOUNDFXFLANGERPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXFlangerPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXFlangerPage
class ATL_NO_VTABLE CDirectSoundFXFlangerPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXFlangerPage, &CLSID_DirectSoundFXFlangerPage>,
    public IPropertyPageImpl<CDirectSoundFXFlangerPage>,
    public CDialogImpl<CDirectSoundFXFlangerPage>
{
public:
    CDirectSoundFXFlangerPage();

    enum {IDD = IDD_DIRECTSOUNDFXFLANGERPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXFLANGERPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXFlangerPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXFlangerPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXFlangerPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXFlanger> m_IDSFXFlanger;
    CSliderValue m_sliderWetDryMix;
    CSliderValue m_sliderDepth;
    CSliderValue m_sliderFeedback;
    CSliderValue m_sliderFrequency;
    CSliderValue m_sliderDelay;
    CSliderValue m_sliderPhase;
    CRadioChoice m_radioWaveform;
    Handler *m_rgpHandlers[8];
};

#endif //__DIRECTSOUNDFXFLANGERPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxflangerpage.cpp ===
// DirectSoundFXFlangerPage.cpp : Implementation of CDirectSoundFXFlangerPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXFlangerPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXFlangerPage

const CRadioChoice::ButtonEntry g_rgWaveButtons[] =
    {
        IDC_RADIO_TRIANGLE, DSFXCHORUS_WAVE_TRIANGLE, //  chorus/flanger
        IDC_RADIO_SIN, DSFXCHORUS_WAVE_SIN, //  chorus/flanger
        0
    };

CDirectSoundFXFlangerPage::CDirectSoundFXFlangerPage()
  : m_radioWaveform(g_rgWaveButtons)
{
    m_dwTitleID = IDS_TITLEDirectSoundFXFlangerPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXFlangerPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXFlangerPage;

    m_rgpHandlers[0] = &m_sliderWetDryMix;
    m_rgpHandlers[1] = &m_sliderDepth;
    m_rgpHandlers[2] = &m_sliderFeedback;
    m_rgpHandlers[3] = &m_sliderFrequency;
    m_rgpHandlers[4] = &m_sliderDelay;
    m_rgpHandlers[5] = &m_sliderPhase;
    m_rgpHandlers[6] = &m_radioWaveform;
    m_rgpHandlers[7] = NULL;
}

STDMETHODIMP CDirectSoundFXFlangerPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXFlanger, reinterpret_cast<void**>(&m_IDSFXFlanger));
    return hr;
}

STDMETHODIMP CDirectSoundFXFlangerPage::Apply(void)
{
    if (!m_IDSFXFlanger)
        return E_UNEXPECTED;

    DSFXFlanger dsfxflanger;
    ZeroMemory(&dsfxflanger, sizeof(DSFXFlanger));

    dsfxflanger.fWetDryMix = m_sliderWetDryMix.GetValue();
    dsfxflanger.fDepth = m_sliderDepth.GetValue();
    dsfxflanger.fFeedback = m_sliderFeedback.GetValue();
    dsfxflanger.fFrequency = m_sliderFrequency.GetValue();
    dsfxflanger.fDelay = m_sliderDelay.GetValue();
    dsfxflanger.lPhase = static_cast<short>(m_sliderPhase.GetValue());
    dsfxflanger.lWaveform = m_radioWaveform.GetChoice(*this);

    HRESULT hr = m_IDSFXFlanger->SetAllParameters(&dsfxflanger);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXFlangerPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXFlanger)
        return 1;

    DSFXFlanger dsfxflanger;
    ZeroMemory(&dsfxflanger, sizeof(DSFXFlanger));
    m_IDSFXFlanger->GetAllParameters(&dsfxflanger);

    m_sliderWetDryMix.Init(GetDlgItem(IDC_SLIDER_WetDryMix), GetDlgItem(IDC_EDIT_WetDryMix), 0, 100, false);
    m_sliderWetDryMix.SetValue(dsfxflanger.fWetDryMix);

    m_sliderDepth.Init(GetDlgItem(IDC_SLIDER_Depth), GetDlgItem(IDC_EDIT_Depth), 0, 100, false);
    m_sliderDepth.SetValue(dsfxflanger.fDepth);

    m_sliderFeedback.Init(GetDlgItem(IDC_SLIDER_Feedback), GetDlgItem(IDC_EDIT_Feedback), -99, 99, false);
    m_sliderFeedback.SetValue(dsfxflanger.fFeedback);

    m_sliderFrequency.Init(GetDlgItem(IDC_SLIDER_Frequency), GetDlgItem(IDC_EDIT_Frequency), 0, 10, false);
    m_sliderFrequency.SetValue(dsfxflanger.fFrequency);

    m_sliderDelay.Init(GetDlgItem(IDC_SLIDER_Delay), GetDlgItem(IDC_EDIT_Delay), 0, 4, false);
    m_sliderDelay.SetValue(dsfxflanger.fDelay);

    m_sliderPhase.Init(GetDlgItem(IDC_SLIDER_Phase), GetDlgItem(IDC_EDIT_Phase), 0, 4, true);
    m_sliderPhase.SetValue(static_cast<float>(dsfxflanger.lPhase));

    m_radioWaveform.SetChoice(*this, dsfxflanger.lWaveform);

    return 1;
}

LRESULT CDirectSoundFXFlangerPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxi3dl2reverbpage.h ===
// DirectSoundFXI3DL2ReverbPage.h : Declaration of the CDirectSoundFXI3DL2ReverbPage

#ifndef __DIRECTSOUNDFXI3DL2REVERBPAGE_H_
#define __DIRECTSOUNDFXI3DL2REVERBPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

#define NUMPRESETS 30

EXTERN_C const CLSID CLSID_DirectSoundFXI3DL2ReverbPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXI3DL2ReverbPage
class ATL_NO_VTABLE CDirectSoundFXI3DL2ReverbPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXI3DL2ReverbPage, &CLSID_DirectSoundFXI3DL2ReverbPage>,
    public IPropertyPageImpl<CDirectSoundFXI3DL2ReverbPage>,
    public CDialogImpl<CDirectSoundFXI3DL2ReverbPage>
{
public:
    CDirectSoundFXI3DL2ReverbPage();

    enum {IDD = IDD_DIRECTSOUNDFXI3DL2REVERBPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXI3DL2REVERBPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXI3DL2ReverbPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXI3DL2ReverbPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnComboControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXI3DL2ReverbPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnComboControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXI3DL2Reverb> m_IDSFXI3DL2Reverb;
    CSliderValue m_sliderRoom;
    CSliderValue m_sliderRoomHF;
    CSliderValue m_sliderRoomRolloffFactor;
    CSliderValue m_sliderDecayTime;
    CSliderValue m_sliderDecayHFRatio;
    CSliderValue m_sliderReflections;
    CSliderValue m_sliderReflectionsDelay;
    CSliderValue m_sliderReverb;
    CSliderValue m_sliderReverbDelay;
    CSliderValue m_sliderDiffusion;
    CSliderValue m_sliderDensity;
    CSliderValue m_sliderHFReference;
    CSliderValue m_sliderQuality;
    Handler *m_rgpHandlers[14];

protected:
    static DSFXI3DL2Reverb Presets[];
    void FillCombo(HWND hWnd);
};

#endif //__DIRECTSOUNDFXI3DL2REVERBPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxi3dl2sourcepage.cpp ===
// DirectSoundFXI3DL2SourcePage.cpp : Implementation of CDirectSoundFXI3DL2SourcePage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXI3DL2SourcePage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXI3DL2SourcePage

const CRadioChoice::ButtonEntry g_rgWaveFlags[] =
    {
        IDC_RADIO_LPF, DSFX_I3DL2SOURCE_OCC_LPF,
        IDC_RADIO_VOLUME, DSFX_I3DL2SOURCE_OCC_VOLUME,
        0
    };

CDirectSoundFXI3DL2SourcePage::CDirectSoundFXI3DL2SourcePage()
  : m_radioFlags(g_rgWaveFlags)
{
    m_dwTitleID = IDS_TITLEDirectSoundFXI3DL2SourcePage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXI3DL2SourcePage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXI3DL2SourcePage;

    m_rgpHandlers[0]  = &m_sliderDirect;
    m_rgpHandlers[1]  = &m_sliderDirectHF;
    m_rgpHandlers[2]  = &m_sliderRoom;
    m_rgpHandlers[3]  = &m_sliderRoomHF;
    m_rgpHandlers[4]  = &m_sliderRoomRolloffFactor;
    m_rgpHandlers[5]  = &m_sliderObstruction;
    m_rgpHandlers[6]  = &m_sliderObstructionLFRatio;
    m_rgpHandlers[7]  = &m_sliderOcclusion;
    m_rgpHandlers[8]  = &m_sliderOcclusionLFRatio;
    m_rgpHandlers[9]  = &m_radioFlags;
    m_rgpHandlers[10] = NULL;
}

STDMETHODIMP CDirectSoundFXI3DL2SourcePage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXI3DL2Source, reinterpret_cast<void**>(&m_IDSFXI3DL2Source));
    return hr;
}

STDMETHODIMP CDirectSoundFXI3DL2SourcePage::Apply(void)
{
    if (!m_IDSFXI3DL2Source)
        return E_UNEXPECTED;

    DSFXI3DL2Source dsfxi3dl2source;
    ZeroMemory(&dsfxi3dl2source, sizeof(DSFXI3DL2Source));

    dsfxi3dl2source.lDirect = static_cast<LONG>(m_sliderDirect.GetValue());
    dsfxi3dl2source.lDirectHF = static_cast<LONG>(m_sliderDirectHF.GetValue());
    dsfxi3dl2source.lRoom = static_cast<LONG>(m_sliderRoom.GetValue());
    dsfxi3dl2source.lRoomHF = static_cast<LONG>(m_sliderRoomHF.GetValue());
    dsfxi3dl2source.flRoomRolloffFactor = m_sliderRoomRolloffFactor.GetValue();
    dsfxi3dl2source.Obstruction.lHFLevel = static_cast<LONG>(m_sliderObstruction.GetValue());
    dsfxi3dl2source.Obstruction.flLFRatio = m_sliderObstructionLFRatio.GetValue();
    dsfxi3dl2source.Occlusion.lHFLevel = static_cast<LONG>(m_sliderOcclusion.GetValue());
    dsfxi3dl2source.Occlusion.flLFRatio = m_sliderOcclusionLFRatio.GetValue();
    dsfxi3dl2source.dwFlags = m_radioFlags.GetChoice(*this);

    HRESULT hr = m_IDSFXI3DL2Source->SetAllParameters(&dsfxi3dl2source);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXI3DL2SourcePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXI3DL2Source)
        return 1;

    DSFXI3DL2Source dsfxi3dl2source;
    ZeroMemory(&dsfxi3dl2source, sizeof(DSFXI3DL2Source));
    m_IDSFXI3DL2Source->GetAllParameters(&dsfxi3dl2source);

    m_sliderDirect.Init(GetDlgItem(IDC_SLIDER_Direct), GetDlgItem(IDC_EDIT_Direct), DSFX_I3DL2SOURCE_DIRECT_MIN, DSFX_I3DL2SOURCE_DIRECT_MAX, true);
    m_sliderDirect.SetValue(static_cast<float>(dsfxi3dl2source.lDirect));

    m_sliderDirectHF.Init(GetDlgItem(IDC_SLIDER_DirectHF), GetDlgItem(IDC_EDIT_DirectHF), DSFX_I3DL2SOURCE_DIRECTHF_MIN, DSFX_I3DL2SOURCE_DIRECTHF_MAX, true);
    m_sliderDirectHF.SetValue(static_cast<float>(dsfxi3dl2source.lDirectHF));

    m_sliderRoom.Init(GetDlgItem(IDC_SLIDER_Room), GetDlgItem(IDC_EDIT_Room), DSFX_I3DL2SOURCE_ROOM_MIN, DSFX_I3DL2SOURCE_ROOM_MAX, true);
    m_sliderRoom.SetValue(static_cast<float>(dsfxi3dl2source.lRoom));

    m_sliderRoomHF.Init(GetDlgItem(IDC_SLIDER_RoomHF), GetDlgItem(IDC_EDIT_RoomHF), DSFX_I3DL2SOURCE_ROOMHF_MIN, DSFX_I3DL2SOURCE_ROOMHF_MAX, true);
    m_sliderRoomHF.SetValue(static_cast<float>(dsfxi3dl2source.lRoomHF));

    m_sliderRoomRolloffFactor.Init(GetDlgItem(IDC_SLIDER_RoomRolloffFactor), GetDlgItem(IDC_EDIT_RoomRolloffFactor), DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MIN, DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MAX, false);
    m_sliderRoomRolloffFactor.SetValue(dsfxi3dl2source.flRoomRolloffFactor);

    m_sliderObstruction.Init(GetDlgItem(IDC_SLIDER_Obstruction), GetDlgItem(IDC_EDIT_Obstruction), DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MIN, DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MAX, true);
    m_sliderObstruction.SetValue(static_cast<float>(dsfxi3dl2source.Obstruction.lHFLevel));

    m_sliderObstructionLFRatio.Init(GetDlgItem(IDC_SLIDER_ObstructionLFRatio), GetDlgItem(IDC_EDIT_ObstructionLFRatio), DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MIN, DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MAX, false);
    m_sliderObstructionLFRatio.SetValue(dsfxi3dl2source.Obstruction.flLFRatio);

    m_sliderOcclusion.Init(GetDlgItem(IDC_SLIDER_Occlusion), GetDlgItem(IDC_EDIT_Occlusion), DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MIN, DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MAX, true);
    m_sliderOcclusion.SetValue(static_cast<float>(dsfxi3dl2source.Occlusion.lHFLevel));

    m_sliderOcclusionLFRatio.Init(GetDlgItem(IDC_SLIDER_OcclusionLFRatio), GetDlgItem(IDC_EDIT_OcclusionLFRatio), DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MIN, DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MAX, false);
    m_sliderOcclusionLFRatio.SetValue(dsfxi3dl2source.Occlusion.flLFRatio);

    m_radioFlags.SetChoice(*this, dsfxi3dl2source.dwFlags);

    return 1;
}

LRESULT CDirectSoundFXI3DL2SourcePage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxgarglepage.h ===
// DirectSoundFXGarglePage.h : Declaration of the CDirectSoundFXGarglePage

#ifndef __DIRECTSOUNDFXGARGLEPAGE_H_
#define __DIRECTSOUNDFXGARGLEPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXGarglePage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXGarglePage
class ATL_NO_VTABLE CDirectSoundFXGarglePage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXGarglePage, &CLSID_DirectSoundFXGarglePage>,
    public IPropertyPageImpl<CDirectSoundFXGarglePage>,
    public CDialogImpl<CDirectSoundFXGarglePage>
{
public:
    CDirectSoundFXGarglePage();

    enum {IDD = IDD_DIRECTSOUNDFXGARGLEPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXGARGLEPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXGarglePage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXGarglePage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXGarglePage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXGargle> m_IDSFXGargle;
    CSliderValue m_sliderRate;
    CRadioChoice m_radioWaveform;
    Handler *m_rgpHandlers[3];
};

#endif //__DIRECTSOUNDFXGARGLEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxgarglepage.cpp ===
// DirectSoundFXGarglePage.cpp : Implementation of CDirectSoundFXGarglePage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXGarglePage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXGarglePage

const CRadioChoice::ButtonEntry g_rgWaveButtons[] =
    {
        IDC_RADIO_TRIANGLE, DSFXGARGLE_WAVE_TRIANGLE,
        IDC_RADIO_SQUARE, DSFXGARGLE_WAVE_SQUARE,
        0
    };

CDirectSoundFXGarglePage::CDirectSoundFXGarglePage()
  : m_radioWaveform(g_rgWaveButtons)
{
    m_dwTitleID = IDS_TITLEDirectSoundFXGarglePage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXGarglePage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXGarglePage;

    m_rgpHandlers[0] = &m_sliderRate;
    m_rgpHandlers[1] = &m_radioWaveform;
    m_rgpHandlers[2] = NULL;
}

STDMETHODIMP CDirectSoundFXGarglePage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXGargle, reinterpret_cast<void**>(&m_IDSFXGargle));
    return hr;
}

STDMETHODIMP CDirectSoundFXGarglePage::Apply(void)
{
    if (!m_IDSFXGargle)
        return E_UNEXPECTED;

    DSFXGargle dsfxgargle;
    ZeroMemory(&dsfxgargle, sizeof(DSFXGargle));

    dsfxgargle.dwRateHz = static_cast<DWORD>(m_sliderRate.GetValue());
    dsfxgargle.dwWaveShape = m_radioWaveform.GetChoice(*this);

    HRESULT hr = m_IDSFXGargle->SetAllParameters(&dsfxgargle);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXGarglePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXGargle)
        return 1;

    DSFXGargle dsfxgargle;
    ZeroMemory(&dsfxgargle, sizeof(DSFXGargle));
    m_IDSFXGargle->GetAllParameters(&dsfxgargle);

    m_sliderRate.Init(GetDlgItem(IDC_SLIDER_Rate), GetDlgItem(IDC_EDIT_Rate), 1, 1000, true);
    m_sliderRate.SetValue(static_cast<float>(dsfxgargle.dwRateHz));

    m_radioWaveform.SetChoice(*this, dsfxgargle.dwWaveShape);

    return 1;
}

LRESULT CDirectSoundFXGarglePage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxi3dl2reverbpage.cpp ===
// DirectSoundFXI3DL2ReverbPage.cpp : Implementation of CDirectSoundFXI3DL2ReverbPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXI3DL2ReverbPage.h"

DSFXI3DL2Reverb CDirectSoundFXI3DL2ReverbPage::Presets[] =
{
    {I3DL2_ENVIRONMENT_PRESET_DEFAULT},
    {I3DL2_ENVIRONMENT_PRESET_GENERIC},
    {I3DL2_ENVIRONMENT_PRESET_PADDEDCELL},
    {I3DL2_ENVIRONMENT_PRESET_ROOM},
    {I3DL2_ENVIRONMENT_PRESET_BATHROOM},
    {I3DL2_ENVIRONMENT_PRESET_LIVINGROOM},
    {I3DL2_ENVIRONMENT_PRESET_STONEROOM},
    {I3DL2_ENVIRONMENT_PRESET_AUDITORIUM},
    {I3DL2_ENVIRONMENT_PRESET_CONCERTHALL},
    {I3DL2_ENVIRONMENT_PRESET_CAVE},
    {I3DL2_ENVIRONMENT_PRESET_ARENA},
    {I3DL2_ENVIRONMENT_PRESET_HANGAR},
    {I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY},
    {I3DL2_ENVIRONMENT_PRESET_HALLWAY},
    {I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR},
    {I3DL2_ENVIRONMENT_PRESET_ALLEY},
    {I3DL2_ENVIRONMENT_PRESET_FOREST},
    {I3DL2_ENVIRONMENT_PRESET_CITY},
    {I3DL2_ENVIRONMENT_PRESET_MOUNTAINS},
    {I3DL2_ENVIRONMENT_PRESET_QUARRY},
    {I3DL2_ENVIRONMENT_PRESET_PLAIN},      
    {I3DL2_ENVIRONMENT_PRESET_PARKINGLOT},
    {I3DL2_ENVIRONMENT_PRESET_SEWERPIPE},
    {I3DL2_ENVIRONMENT_PRESET_UNDERWATER}, 
    {I3DL2_ENVIRONMENT_PRESET_SMALLROOM},
    {I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM},
    {I3DL2_ENVIRONMENT_PRESET_LARGEROOM},
    {I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL},
    {I3DL2_ENVIRONMENT_PRESET_LARGEHALL},
    {I3DL2_ENVIRONMENT_PRESET_PLATE},
};
    
/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXI3DL2ReverbPage

CDirectSoundFXI3DL2ReverbPage::CDirectSoundFXI3DL2ReverbPage()
{
    m_dwTitleID = IDS_TITLEDirectSoundFXI3DL2ReverbPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXI3DL2ReverbPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXI3DL2ReverbPage;

    m_rgpHandlers[0]  = &m_sliderRoom;
    m_rgpHandlers[1]  = &m_sliderRoomHF;
    m_rgpHandlers[2]  = &m_sliderRoomRolloffFactor;
    m_rgpHandlers[3]  = &m_sliderDecayTime;
    m_rgpHandlers[4]  = &m_sliderDecayHFRatio;
    m_rgpHandlers[5]  = &m_sliderReflections;
    m_rgpHandlers[6]  = &m_sliderReflectionsDelay;
    m_rgpHandlers[7]  = &m_sliderReverb;
    m_rgpHandlers[8]  = &m_sliderReverbDelay;
    m_rgpHandlers[9]  = &m_sliderDiffusion;
    m_rgpHandlers[10] = &m_sliderDensity;
    m_rgpHandlers[11] = &m_sliderHFReference;
    m_rgpHandlers[12] = &m_sliderQuality;
    m_rgpHandlers[13] = NULL;
}

STDMETHODIMP CDirectSoundFXI3DL2ReverbPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXI3DL2Reverb, reinterpret_cast<void**>(&m_IDSFXI3DL2Reverb));
    return hr;
}

STDMETHODIMP CDirectSoundFXI3DL2ReverbPage::Apply(void)
{
    if (!m_IDSFXI3DL2Reverb)
        return E_UNEXPECTED;

    DSFXI3DL2Reverb dsfxi3dl2reverb;
    ZeroMemory(&dsfxi3dl2reverb, sizeof(DSFXI3DL2Reverb));

    dsfxi3dl2reverb.lRoom = static_cast<LONG>(m_sliderRoom.GetValue());
    dsfxi3dl2reverb.lRoomHF = static_cast<LONG>(m_sliderRoomHF.GetValue());
    dsfxi3dl2reverb.flRoomRolloffFactor = m_sliderRoomRolloffFactor.GetValue();
    dsfxi3dl2reverb.flDecayTime = m_sliderDecayTime.GetValue();
    dsfxi3dl2reverb.flDecayHFRatio = m_sliderDecayHFRatio.GetValue();
    dsfxi3dl2reverb.lReflections = static_cast<LONG>(m_sliderReflections.GetValue());
    dsfxi3dl2reverb.flReflectionsDelay = m_sliderReflectionsDelay.GetValue();
    dsfxi3dl2reverb.lReverb = static_cast<LONG>(m_sliderReverb.GetValue());
    dsfxi3dl2reverb.flReverbDelay = m_sliderReverbDelay.GetValue();
    dsfxi3dl2reverb.flDiffusion = m_sliderDiffusion.GetValue();
    dsfxi3dl2reverb.flDensity = m_sliderDensity.GetValue();
    dsfxi3dl2reverb.flHFReference = m_sliderHFReference.GetValue();

    HRESULT hr = m_IDSFXI3DL2Reverb->SetAllParameters(&dsfxi3dl2reverb);
    if (FAILED(hr))
        return hr;
    hr = m_IDSFXI3DL2Reverb->SetQuality(static_cast<long>(m_sliderQuality.GetValue()));
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXI3DL2ReverbPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXI3DL2Reverb)
        return 1;

    DSFXI3DL2Reverb dsfxi3dl2reverb;
    ZeroMemory(&dsfxi3dl2reverb, sizeof(DSFXI3DL2Reverb));
    m_IDSFXI3DL2Reverb->GetAllParameters(&dsfxi3dl2reverb);
    LONG lQuality = 0;
    m_IDSFXI3DL2Reverb->GetQuality(&lQuality);

    m_sliderRoom.Init(GetDlgItem(IDC_SLIDER_Room), GetDlgItem(IDC_EDIT_Room), DSFX_I3DL2REVERB_ROOM_MIN, DSFX_I3DL2REVERB_ROOM_MAX, true);
    m_sliderRoom.SetValue(static_cast<float>(dsfxi3dl2reverb.lRoom));

    m_sliderRoomHF.Init(GetDlgItem(IDC_SLIDER_RoomHF), GetDlgItem(IDC_EDIT_RoomHF), DSFX_I3DL2REVERB_ROOMHF_MIN, DSFX_I3DL2REVERB_ROOMHF_MAX, true);
    m_sliderRoomHF.SetValue(static_cast<float>(dsfxi3dl2reverb.lRoomHF));

    m_sliderRoomRolloffFactor.Init(GetDlgItem(IDC_SLIDER_RoomRolloffFactor), GetDlgItem(IDC_EDIT_RoomRolloffFactor), DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MIN, DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MAX, false);
    m_sliderRoomRolloffFactor.SetValue(dsfxi3dl2reverb.flRoomRolloffFactor);

    m_sliderDecayTime.Init(GetDlgItem(IDC_SLIDER_DecayTime), GetDlgItem(IDC_EDIT_DecayTime), DSFX_I3DL2REVERB_DECAYTIME_MIN, DSFX_I3DL2REVERB_DECAYTIME_MAX, false);
    m_sliderDecayTime.SetValue(dsfxi3dl2reverb.flDecayTime);

    m_sliderDecayHFRatio.Init(GetDlgItem(IDC_SLIDER_DecayHFRatio), GetDlgItem(IDC_EDIT_DecayHFRatio), DSFX_I3DL2REVERB_DECAYHFRATIO_MIN, DSFX_I3DL2REVERB_DECAYHFRATIO_MAX, false);
    m_sliderDecayHFRatio.SetValue(dsfxi3dl2reverb.flDecayHFRatio);

    m_sliderReflections.Init(GetDlgItem(IDC_SLIDER_Reflections), GetDlgItem(IDC_EDIT_Reflections), DSFX_I3DL2REVERB_REFLECTIONS_MIN, DSFX_I3DL2REVERB_REFLECTIONS_MAX, true);
    m_sliderReflections.SetValue(static_cast<float>(dsfxi3dl2reverb.lReflections));

    m_sliderReflectionsDelay.Init(GetDlgItem(IDC_SLIDER_ReflectionsDelay), GetDlgItem(IDC_EDIT_ReflectionsDelay), DSFX_I3DL2REVERB_REFLECTIONSDELAY_MIN, DSFX_I3DL2REVERB_REFLECTIONSDELAY_MAX, false);
    m_sliderReflectionsDelay.SetValue(dsfxi3dl2reverb.flReflectionsDelay);

    m_sliderReverb.Init(GetDlgItem(IDC_SLIDER_Reverb), GetDlgItem(IDC_EDIT_Reverb), DSFX_I3DL2REVERB_REVERB_MIN, DSFX_I3DL2REVERB_REVERB_MAX, true);
    m_sliderReverb.SetValue(static_cast<float>(dsfxi3dl2reverb.lReverb));

    m_sliderReverbDelay.Init(GetDlgItem(IDC_SLIDER_ReverbDelay), GetDlgItem(IDC_EDIT_ReverbDelay), DSFX_I3DL2REVERB_REVERBDELAY_MIN, DSFX_I3DL2REVERB_REVERBDELAY_MAX, false);
    m_sliderReverbDelay.SetValue(dsfxi3dl2reverb.flReverbDelay);

    m_sliderDiffusion.Init(GetDlgItem(IDC_SLIDER_Diffusion), GetDlgItem(IDC_EDIT_Diffusion), DSFX_I3DL2REVERB_DIFFUSION_MIN, DSFX_I3DL2REVERB_DIFFUSION_MAX, false);
    m_sliderDiffusion.SetValue(dsfxi3dl2reverb.flDiffusion);

    m_sliderDensity.Init(GetDlgItem(IDC_SLIDER_Density), GetDlgItem(IDC_EDIT_Density), DSFX_I3DL2REVERB_DENSITY_MIN, DSFX_I3DL2REVERB_DENSITY_MAX, false);
    m_sliderDensity.SetValue(dsfxi3dl2reverb.flDensity);

    m_sliderHFReference.Init(GetDlgItem(IDC_SLIDER_HFReference), GetDlgItem(IDC_EDIT_HFReference), DSFX_I3DL2REVERB_HFREFERENCE_MIN, DSFX_I3DL2REVERB_HFREFERENCE_MAX, false);
    m_sliderHFReference.SetValue(dsfxi3dl2reverb.flHFReference);

    m_sliderQuality.Init(GetDlgItem(IDC_SLIDER_Quality), GetDlgItem(IDC_EDIT_Quality), DSFX_I3DL2REVERB_QUALITY_MIN, DSFX_I3DL2REVERB_QUALITY_MAX, true);
    m_sliderQuality.SetValue(static_cast<float>(lQuality));

    FillCombo(GetDlgItem(IDC_PRESET));

    return 1;
}

LRESULT CDirectSoundFXI3DL2ReverbPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
    {
        //Mark the Page as Dirty
        SetDirty(TRUE);

        //Clear the ComboBox
        ::SendMessage(GetDlgItem(IDC_PRESET),CB_SETCURSEL, static_cast<WPARAM>(-1),static_cast<LPARAM>(0));
    }
    return lr;
}

void CDirectSoundFXI3DL2ReverbPage::FillCombo(HWND hWnd)
{
    CONST int BUFFERLEN=256;  //Maximum size of the string for the DropDown.
    TCHAR tchBuffer[BUFFERLEN];
    LRESULT lr;
    int cCh;
    
    //We're going to fillup the DropDown Listbox with strings and data
    for (int i=0;i<NUMPRESETS;i++)
    {
        //Load the Strings
        cCh = LoadString(_Module.GetResourceInstance(),IDS_PRESETDefault + i, tchBuffer, BUFFERLEN);

        // 0 indicates an error -- bail
        ATLASSERT(cCh != 0);

        //Put the string in the dropdown
        //lr will be the index in the dropdown where the item was put
        lr =::SendMessage(hWnd,CB_ADDSTRING,(WPARAM) 0,(LPARAM) tchBuffer);
        ATLASSERT(lr != CB_ERR && lr != CB_ERRSPACE);

        //Put the index into the preset array that goes with the string
        //into the itemdata for the dropdown
        lr = ::SendMessage(hWnd,CB_SETITEMDATA,(WPARAM) lr,(LPARAM) i);
        ATLASSERT(lr != CB_ERR);
        
        //Don't select anything to start
        ::SendMessage(hWnd,CB_SETCURSEL,(WPARAM)-1,(LPARAM)0);
    }
}

LRESULT CDirectSoundFXI3DL2ReverbPage::OnComboControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = 0;
    bHandled = FALSE;
    HWND hWnd;

    switch(uMsg)
    {
    case WM_COMMAND:
        if (HIWORD(wParam) == CBN_SELCHANGE && LOWORD(wParam) == IDC_PRESET)
        {   
            hWnd = reinterpret_cast<HWND>(lParam);
            //Get the Index of the Current Selection
            lr = ::SendMessage(hWnd, CB_GETCURSEL, static_cast<WPARAM>(0), static_cast<LPARAM>(0));
            if (lr == CB_ERR)
                break;
            //Get the ItemData -- This is the index into the Presets Array
            lr = ::SendMessage(hWnd, CB_GETITEMDATA, static_cast<WPARAM>(lr), static_cast<LPARAM>(0));
            if (lr == CB_ERR)
                break;

            //Set the object with the presets
            m_IDSFXI3DL2Reverb->SetAllParameters(&Presets[lr]);

            //Retrive the values from the object
            DSFXI3DL2Reverb dsfxi3dl2reverb;
            ZeroMemory(&dsfxi3dl2reverb, sizeof(DSFXI3DL2Reverb));
            m_IDSFXI3DL2Reverb->GetAllParameters(&dsfxi3dl2reverb);

            //Set the sliders
            m_sliderRoom.SetValue(static_cast<float>(dsfxi3dl2reverb.lRoom));
            m_sliderRoomHF.SetValue(static_cast<float>(dsfxi3dl2reverb.lRoomHF));
            m_sliderRoomRolloffFactor.SetValue(dsfxi3dl2reverb.flRoomRolloffFactor);
            m_sliderDecayTime.SetValue(dsfxi3dl2reverb.flDecayTime);
            m_sliderDecayHFRatio.SetValue(dsfxi3dl2reverb.flDecayHFRatio);
            m_sliderReflections.SetValue(static_cast<float>(dsfxi3dl2reverb.lReflections));
            m_sliderReflectionsDelay.SetValue(dsfxi3dl2reverb.flReflectionsDelay);
            m_sliderReverb.SetValue(static_cast<float>(dsfxi3dl2reverb.lReverb));
            m_sliderReverbDelay.SetValue(dsfxi3dl2reverb.flReverbDelay);
            m_sliderDiffusion.SetValue(dsfxi3dl2reverb.flDiffusion);
            m_sliderDensity.SetValue(dsfxi3dl2reverb.flDensity);
            m_sliderHFReference.SetValue(dsfxi3dl2reverb.flHFReference);
            
            bHandled = TRUE;
            SetDirty(TRUE);
        }

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxi3dl2sourcepage.h ===
// DirectSoundFXI3DL2SourcePage.h : Declaration of the CDirectSoundFXI3DL2SourcePage

#ifndef __DIRECTSOUNDFXI3DL2SOURCEPAGE_H_
#define __DIRECTSOUNDFXI3DL2SOURCEPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXI3DL2SourcePage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXI3DL2SourcePage
class ATL_NO_VTABLE CDirectSoundFXI3DL2SourcePage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXI3DL2SourcePage, &CLSID_DirectSoundFXI3DL2SourcePage>,
    public IPropertyPageImpl<CDirectSoundFXI3DL2SourcePage>,
    public CDialogImpl<CDirectSoundFXI3DL2SourcePage>
{
public:
    CDirectSoundFXI3DL2SourcePage();

    enum {IDD = IDD_DIRECTSOUNDFXI3DL2SOURCEPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXI3DL2SOURCEPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXI3DL2SourcePage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXI3DL2SourcePage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXI3DL2SourcePage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXI3DL2Source> m_IDSFXI3DL2Source;
    CSliderValue m_sliderDirect;
    CSliderValue m_sliderDirectHF;
    CSliderValue m_sliderRoom;
    CSliderValue m_sliderRoomHF;
    CSliderValue m_sliderRoomRolloffFactor;
    CSliderValue m_sliderObstruction;
    CSliderValue m_sliderObstructionLFRatio;
    CSliderValue m_sliderOcclusion;
    CSliderValue m_sliderOcclusionLFRatio;
    CRadioChoice m_radioFlags;
    Handler *m_rgpHandlers[11];
};

#endif //__DIRECTSOUNDFXI3DL2SOURCEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxwavesreverbpage.h ===
// DirectSoundFXWavesReverbPage.h : Declaration of the CDirectSoundFXWavesReverbPage

#ifndef __DIRECTSOUNDFXWAVESREVERBPAGE_H_
#define __DIRECTSOUNDFXWAVESREVERBPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXWavesReverbPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXWavesReverbPage
class ATL_NO_VTABLE CDirectSoundFXWavesReverbPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXWavesReverbPage, &CLSID_DirectSoundFXWavesReverbPage>,
    public IPropertyPageImpl<CDirectSoundFXWavesReverbPage>,
    public CDialogImpl<CDirectSoundFXWavesReverbPage>
{
public:
    CDirectSoundFXWavesReverbPage();

    enum {IDD = IDD_DIRECTSOUNDFXWAVESREVERBPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXWAVESREVERBPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXWavesReverbPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXWavesReverbPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXWavesReverbPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXWavesReverb> m_IDSFXWavesReverb;
    CSliderValue m_sliderInGain;
    CSliderValue m_sliderReverbMix;
    CSliderValue m_sliderReverbTime;
    CSliderValue m_sliderHighFreqRTRatio;
    Handler *m_rgpHandlers[5];
};

#endif //__DIRECTSOUNDFXWAVESREVERBPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxparameqpage.cpp ===
// DirectSoundFXParamEqPage.cpp : Implementation of CDirectSoundFXParamEqPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXParamEqPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXParamEqPage

CDirectSoundFXParamEqPage::CDirectSoundFXParamEqPage()
{
    m_dwTitleID = IDS_TITLEDirectSoundFXParamEqPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXParamEqPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXParamEqPage;

    m_rgpHandlers[0] = &m_sliderCenter;
    m_rgpHandlers[1] = &m_sliderBandwidth;
    m_rgpHandlers[2] = &m_sliderGain;
    m_rgpHandlers[3] = NULL;
}

STDMETHODIMP CDirectSoundFXParamEqPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXParamEq, reinterpret_cast<void**>(&m_IDSFXParamEq));
    return hr;
}

STDMETHODIMP CDirectSoundFXParamEqPage::Apply(void)
{
    if (!m_IDSFXParamEq)
        return E_UNEXPECTED;

    DSFXParamEq dsfxparameq;
    ZeroMemory(&dsfxparameq, sizeof(DSFXParamEq));

    dsfxparameq.fCenter = m_sliderCenter.GetValue();
    dsfxparameq.fBandwidth = m_sliderBandwidth.GetValue();
    dsfxparameq.fGain = m_sliderGain.GetValue();

    HRESULT hr = m_IDSFXParamEq->SetAllParameters(&dsfxparameq);
    if (FAILED(hr))
        return hr;

    hr = m_IDSFXParamEq->GetAllParameters(&dsfxparameq);
    if (FAILED(hr))
        return hr;
        
    m_sliderCenter.SetValue(dsfxparameq.fCenter);
    m_sliderBandwidth.SetValue(dsfxparameq.fBandwidth);
    m_sliderGain.SetValue(dsfxparameq.fGain);

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXParamEqPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXParamEq)
        return 1;

    DSFXParamEq dsfxparameq;
    ZeroMemory(&dsfxparameq, sizeof(DSFXParamEq));
    m_IDSFXParamEq->GetAllParameters(&dsfxparameq);

    m_sliderCenter.Init(GetDlgItem(IDC_SLIDER_Center), GetDlgItem(IDC_EDIT_Center), 80, 16000, true);
    m_sliderCenter.SetValue(dsfxparameq.fCenter);

    m_sliderBandwidth.Init(GetDlgItem(IDC_SLIDER_Bandwidth), GetDlgItem(IDC_EDIT_Bandwidth), 1, 36, false);
    m_sliderBandwidth.SetValue(dsfxparameq.fBandwidth);

    m_sliderGain.Init(GetDlgItem(IDC_SLIDER_Gain), GetDlgItem(IDC_EDIT_Gain), -15, 15, false);
    m_sliderGain.SetValue(dsfxparameq.fGain);

    return 1;
}

LRESULT CDirectSoundFXParamEqPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\makefile.inc ===
buildidl : $O\dsdmoprp.h

$O\dsdmoprp.h : ..\dsdmoprp.idl
    $(MIDL) \
    $(INCPATH0) \
    $(C_DEFINES) \
    -header  $O\dsdmoprp.h \
    -tlb     $O\dsdmoprp.tlb \
    -iid     $O\dsdmoprp_i.c \
    -dlldata $(PROXY_DIR)\dlldata.c \
    -proxy   $(PROXY_DIR)\dsdmoprp_p.c \
    ..\dsdmoprp.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxparameqpage.h ===
// DirectSoundFXParamEqPage.h : Declaration of the CDirectSoundFXParamEqPage

#ifndef __DIRECTSOUNDFXPARAMEQPAGE_H_
#define __DIRECTSOUNDFXPARAMEQPAGE_H_

#include "resource.h"       // main symbols
#include <dsound.h>
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DirectSoundFXParamEqPage;

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXParamEqPage
class ATL_NO_VTABLE CDirectSoundFXParamEqPage :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDirectSoundFXParamEqPage, &CLSID_DirectSoundFXParamEqPage>,
    public IPropertyPageImpl<CDirectSoundFXParamEqPage>,
    public CDialogImpl<CDirectSoundFXParamEqPage>
{
public:
    CDirectSoundFXParamEqPage();

    enum {IDD = IDD_DIRECTSOUNDFXPARAMEQPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DIRECTSOUNDFXPARAMEQPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDirectSoundFXParamEqPage) 
    COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDirectSoundFXParamEqPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
    MESSAGE_HANDLER(WM_HSCROLL, OnControlMessage);
    MESSAGE_HANDLER(WM_COMMAND, OnControlMessage);
    CHAIN_MSG_MAP(IPropertyPageImpl<CDirectSoundFXParamEqPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
    STDMETHOD(Apply)(void);

    // Message handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Member variables
    CComPtr<IDirectSoundFXParamEq> m_IDSFXParamEq;
    CSliderValue m_sliderCenter;
    CSliderValue m_sliderBandwidth;
    CSliderValue m_sliderGain;
    Handler *m_rgpHandlers[4];
};

#endif //__DIRECTSOUNDFXPARAMEQPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\directsoundfxwavesreverbpage.cpp ===
// DirectSoundFXWavesReverbPage.cpp : Implementation of CDirectSoundFXWavesReverbPage
#include "stdafx.h"
#include "Dsdmoprp.h"
#include "DirectSoundFXWavesReverbPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectSoundFXWavesReverbPage

CDirectSoundFXWavesReverbPage::CDirectSoundFXWavesReverbPage()
{
    m_dwTitleID = IDS_TITLEDirectSoundFXWavesReverbPage;
    m_dwHelpFileID = IDS_HELPFILEDirectSoundFXWavesReverbPage;
    m_dwDocStringID = IDS_DOCSTRINGDirectSoundFXWavesReverbPage;

    m_rgpHandlers[0] = &m_sliderInGain;
    m_rgpHandlers[1] = &m_sliderReverbMix;
    m_rgpHandlers[2] = &m_sliderReverbTime;
    m_rgpHandlers[3] = &m_sliderHighFreqRTRatio;
    m_rgpHandlers[4] = NULL;
}

STDMETHODIMP CDirectSoundFXWavesReverbPage::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
    if (nObjects < 1 || nObjects > 1)
        return E_UNEXPECTED;

    HRESULT hr = ppUnk[0]->QueryInterface(IID_IDirectSoundFXWavesReverb, reinterpret_cast<void**>(&m_IDSFXWavesReverb));
    return hr;
}

STDMETHODIMP CDirectSoundFXWavesReverbPage::Apply(void)
{
    if (!m_IDSFXWavesReverb)
        return E_UNEXPECTED;

    DSFXWavesReverb dsfxwavesreverb;
    ZeroMemory(&dsfxwavesreverb, sizeof(DSFXWavesReverb));

    dsfxwavesreverb.fInGain = m_sliderInGain.GetValue();
    dsfxwavesreverb.fReverbMix = m_sliderReverbMix.GetValue();
    dsfxwavesreverb.fReverbTime = m_sliderReverbTime.GetValue();
    dsfxwavesreverb.fHighFreqRTRatio = m_sliderHighFreqRTRatio.GetValue();

    HRESULT hr = m_IDSFXWavesReverb->SetAllParameters(&dsfxwavesreverb);
    if (FAILED(hr))
        return hr;

    SetDirty(FALSE);
    return S_OK;
}

LRESULT CDirectSoundFXWavesReverbPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_IDSFXWavesReverb)
        return 1;

    DSFXWavesReverb dsfxwavesreverb;
    ZeroMemory(&dsfxwavesreverb, sizeof(DSFXWavesReverb));
    m_IDSFXWavesReverb->GetAllParameters(&dsfxwavesreverb);

    m_sliderInGain.Init(GetDlgItem(IDC_SLIDER_InGain), GetDlgItem(IDC_EDIT_InGain), DSFX_WAVESREVERB_INGAIN_MIN, DSFX_WAVESREVERB_INGAIN_MAX, false);
    m_sliderInGain.SetValue(dsfxwavesreverb.fInGain);

    m_sliderReverbMix.Init(GetDlgItem(IDC_SLIDER_ReverbMix), GetDlgItem(IDC_EDIT_ReverbMix), DSFX_WAVESREVERB_REVERBMIX_MIN, DSFX_WAVESREVERB_REVERBMIX_MAX, false);
    m_sliderReverbMix.SetValue(dsfxwavesreverb.fReverbMix);

    m_sliderReverbTime.Init(GetDlgItem(IDC_SLIDER_ReverbTime), GetDlgItem(IDC_EDIT_ReverbTime), DSFX_WAVESREVERB_REVERBTIME_MIN, DSFX_WAVESREVERB_REVERBTIME_MAX, false);
    m_sliderReverbTime.SetValue(dsfxwavesreverb.fReverbTime);

    m_sliderHighFreqRTRatio.Init(GetDlgItem(IDC_SLIDER_HighFreqRTRatio), GetDlgItem(IDC_EDIT_HighFreqRTRatio), DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN, DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX, false);
    m_sliderHighFreqRTRatio.SetValue(dsfxwavesreverb.fHighFreqRTRatio);

    return 1;
}

LRESULT CDirectSoundFXWavesReverbPage::OnControlMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = MessageHandlerChain(m_rgpHandlers, uMsg, wParam, lParam, bHandled);

    if (bHandled)
        SetDirty(TRUE);
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\dsdmoprp.cpp ===
// dsdmoprp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f dsdmoprpps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "dsdmoprp.h"

#include "dsdmoprp_i.c"
#include "DirectSoundFXChorusPage.h"
#include "DirectSoundFXCompressorPage.h"
#include "DirectSoundFXDistortionPage.h"
#include "DirectSoundFXEchoPage.h"
#include "DirectSoundFXFlangerPage.h"
#include "DirectSoundFXParamEqPage.h"
#include "DirectSoundFXGarglePage.h"
#include "DirectSoundFXWavesReverbPage.h"
//#include "DirectSoundFXI3DL2SourcePage.h"
#include "DirectSoundFXI3DL2ReverbPage.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DirectSoundFXChorusPage, CDirectSoundFXChorusPage)
OBJECT_ENTRY(CLSID_DirectSoundFXCompressorPage, CDirectSoundFXCompressorPage)
OBJECT_ENTRY(CLSID_DirectSoundFXDistortionPage, CDirectSoundFXDistortionPage)
OBJECT_ENTRY(CLSID_DirectSoundFXEchoPage, CDirectSoundFXEchoPage)
OBJECT_ENTRY(CLSID_DirectSoundFXFlangerPage, CDirectSoundFXFlangerPage)
OBJECT_ENTRY(CLSID_DirectSoundFXParamEqPage, CDirectSoundFXParamEqPage)
OBJECT_ENTRY(CLSID_DirectSoundFXGarglePage, CDirectSoundFXGarglePage)
OBJECT_ENTRY(CLSID_DirectSoundFXWavesReverbPage, CDirectSoundFXWavesReverbPage)
//OBJECT_ENTRY(CLSID_DirectSoundFXI3DL2SourcePage, CDirectSoundFXI3DL2SourcePage)
OBJECT_ENTRY(CLSID_DirectSoundFXI3DL2ReverbPage, CDirectSoundFXI3DL2ReverbPage)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_DSDMOPRPLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\sources.inc ===
#############################################################################
# Copyright (C) Microsoft Corporation 2000
#############################################################################

!ifndef DXROOT
DXROOT = $(BASEDIR)\multimedia\directx
!endif

!include $(DXROOT)\project.mk
!include ..\..\buildmode.inc
	
MAJORCOMP  = windows
MINORCOMP  = directx

TARGETNAME = dsdmoprp
TARGETTYPE = DYNLINK
TARGETPATH = $(_OBJ_DIR)
UMTYPE     = windows
DLLDEF     = ..\dsdmoprp.def
DLLENTRY   = _DllMainCRTStartup

USE_MSVCRT = 1
USE_MAPSYM = 1

ATL_VER    = 30
USE_STATIC_ATL = 1


!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

MSC_OPTIMIZATION = $(MSC_OPTIMIZATION) /Od

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif


# 04/11/2000 - allows for addition of BoundsChecker, etc 
# libs specified in the OS environment

TARGETLIBS=$(TARGETLIBS) \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\gdi32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\oleaut32.lib \
    $(BASEDIR)\public\sdk\lib\*\kernel32.lib    \
    $(BASEDIR)\public\sdk\lib\*\user32.lib      \
    $(BASEDIR)\public\sdk\lib\*\ole32.lib       \
    $(BASEDIR)\public\sdk\lib\*\uuid.lib		\
    $(BASEDIR)\public\sdk\lib\*\advapi32.lib 

INCLUDES = $(PROJECT_INC_PATH);\
           $(DXROOT)\inc;\
           $(BASEDIR)\public\sdk\inc

SOURCES=\
    dsdmoprp.idl                      \
    dsdmoprp.cpp                      \
    dsdmoprp.rc                       \
    StdAfx.cpp                        \
    ControlHelp.cpp                   \
    DirectSoundFXChorusPage.cpp       \
    DirectSoundFXCompressorPage.cpp   \
    DirectSoundFXDistortionPage.cpp   \
    DirectSoundFXEchoPage.cpp         \
    DirectSoundFXFlangerPage.cpp      \
    DirectSoundFXGarglePage.cpp       \
    DirectSoundFXParamEqPage.cpp      \
    DirectSoundFXWavesReverbPage.cpp  \
    DirectSoundFXI3DL2ReverbPage.cpp

#   DirectSoundFXI3DL2SourcePage.cpp

NTTARGETFILE0 = buildidl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\win9x\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsdmoprp.rc
//
#define IDS_PROJNAME                    100
#define IDS_TITLEDirectSoundFXChorusPage 101
#define IDS_HELPFILEDirectSoundFXChorusPage 102
#define IDS_DOCSTRINGDirectSoundFXChorusPage 103
#define IDR_DIRECTSOUNDFXCHORUSPAGE     104
#define IDD_DIRECTSOUNDFXCHORUSPAGE     105
#define IDS_TITLEDirectSoundFXCompressorPage 106
#define IDS_HELPFILEDirectSoundFXCompressorPage 107
#define IDS_DOCSTRINGDirectSoundFXCompressorPage 108
#define IDR_DIRECTSOUNDFXCOMPRESSORPAGE 109
#define IDD_DIRECTSOUNDFXCOMPRESSORPAGE 110
#define IDS_TITLEDirectSoundFXDistortionPage 111
#define IDS_HELPFILEDirectSoundFXDistortionPage 112
#define IDS_DOCSTRINGDirectSoundFXDistortionPage 113
#define IDR_DIRECTSOUNDFXDISTORTIONPAGE 114
#define IDD_DIRECTSOUNDFXDISTORTIONPAGE 115
#define IDS_TITLEDirectSoundFXEchoPage  116
#define IDS_HELPFILEDirectSoundFXEchoPage 117
#define IDS_DOCSTRINGDirectSoundFXEchoPage 118
#define IDR_DIRECTSOUNDFXECHOPAGE       119
#define IDD_DIRECTSOUNDFXECHOPAGE       120
#define IDS_TITLEDirectSoundFXFlangerPage 121
#define IDS_HELPFILEDirectSoundFXFlangerPage 122
#define IDS_DOCSTRINGDirectSoundFXFlangerPage 123
#define IDR_DIRECTSOUNDFXFLANGERPAGE    124
#define IDD_DIRECTSOUNDFXFLANGERPAGE    125
#define IDS_TITLEDirectSoundFXParamEqPage 126
#define IDS_HELPFILEDirectSoundFXParamEqPage 127
#define IDS_DOCSTRINGDirectSoundFXParamEqPage 128
#define IDR_DIRECTSOUNDFXPARAMEQPAGE    129
#define IDD_DIRECTSOUNDFXPARAMEQPAGE    130
#define IDS_TITLEDirectSoundFXGarglePage 131
#define IDS_HELPFILEDirectSoundFXGarglePage 132
#define IDS_DOCSTRINGDirectSoundFXGarglePage 133
#define IDR_DIRECTSOUNDFXGARGLEPAGE     134
#define IDD_DIRECTSOUNDFXGARGLEPAGE     135
#define IDS_TITLEDirectSoundFXWavesReverbPage 136
#define IDS_HELPFILEDirectSoundFXWavesReverbPage 137
#define IDS_DOCSTRINGDirectSoundFXWavesReverbPage 138
#define IDR_DIRECTSOUNDFXWAVESREVERBPAGE 139
#define IDD_DIRECTSOUNDFXWAVESREVERBPAGE 140
#define IDS_TITLEDirectSoundFXI3DL2SourcePage 141
#define IDS_HELPFILEDirectSoundFXI3DL2SourcePage 142
#define IDS_DOCSTRINGDirectSoundFXI3DL2SourcePage 143
#define IDR_DIRECTSOUNDFXI3DL2SOURCEPAGE 144
#define IDD_DIRECTSOUNDFXI3DL2SOURCEPAGE 145
#define IDS_TITLEDirectSoundFXI3DL2ReverbPage 146
#define IDS_HELPFILEDirectSoundFXI3DL2ReverbPage 147
#define IDS_DOCSTRINGDirectSoundFXI3DL2ReverbPage 148
#define IDR_DIRECTSOUNDFXI3DL2REVERBPAGE 149
#define IDD_DIRECTSOUNDFXI3DL2REVERBPAGE 150
#define IDC_SLIDER_WetDryMix            201
#define IDC_EDIT_WetDryMix              202
#define IDC_SLIDER_Phase                203
#define IDC_EDIT_Phase                  204
#define IDC_RADIO_SIN                   205
#define IDC_RADIO_TRIANGLE              206
#define IDC_EDIT_Depth                  207
#define IDC_SLIDER_Depth                208
#define IDC_EDIT_Feedback               209
#define IDC_SLIDER_Feedback             210
#define IDC_EDIT_Gain                   210
#define IDC_EDIT_Frequency              211
#define IDC_SLIDER_Gain                 211
#define IDC_SLIDER_Frequency            212
#define IDC_EDIT_Edge                   212
#define IDC_EDIT_Bandwidth              212
#define IDC_EDIT_ReverbMix              212
#define IDC_EDIT_DirectHF               212
#define IDC_EDIT_Delay                  213
#define IDC_EDIT_Attack                 213
#define IDC_SLIDER_Edge                 213
#define IDC_SLIDER_Bandwidth            213
#define IDC_SLIDER_ReverbMix            213
#define IDC_SLIDER_DirectHF             213
#define IDC_SLIDER_Delay                214
#define IDC_EDIT_PostEQCenterFrequency  214
#define IDC_EDIT_ReverbTime             214
#define IDC_EDIT_Room                   214
#define IDC_SLIDER_PostEQCenterFrequency 215
#define IDC_SLIDER_ReverbTime           215
#define IDC_SLIDER_Room                 215
#define IDC_SLIDER_Attack               216
#define IDC_EDIT_PostEQBandwidth        216
#define IDC_RADIO_PANNED                216
#define IDC_EDIT_HighFreqRTRatio        216
#define IDC_EDIT_RoomHF                 216
#define IDC_SLIDER_PostEQBandwidth      217
#define IDC_RADIO_NOTPANNED             217
#define IDC_SLIDER_HighFreqRTRatio      217
#define IDC_SLIDER_RoomHF               217
#define IDC_EDIT_PreLowpassCutoff       218
#define IDC_EDIT_RoomRolloffFactor      218
#define IDC_SLIDER_PreLowpassCutoff     219
#define IDC_SLIDER_RoomRolloffFactor    219
#define IDC_EDIT_Release                220
#define IDC_EDIT_Center                 220
#define IDC_EDIT_Obstruction            220
#define IDC_SLIDER_Release              221
#define IDC_SLIDER_Center               221
#define IDC_SLIDER_Obstruction          221
#define IDC_EDIT_LeftDelay              222
#define IDC_EDIT_Rate                   222
#define IDC_EDIT_ObstructionLFRatio     222
#define IDC_SLIDER_LeftDelay            223
#define IDC_SLIDER_Rate                 223
#define IDC_SLIDER_ObstructionLFRatio   223
#define IDC_EDIT_Threshold              224
#define IDC_EDIT_RightDelay             224
#define IDC_RADIO_SQUARE                224
#define IDC_EDIT_Occlusion              224
#define IDC_SLIDER_Threshold            225
#define IDC_SLIDER_RightDelay           225
#define IDC_EDIT_InGain                 225
#define IDC_SLIDER_Occlusion            225
#define IDC_EDIT_Ratio                  226
#define IDC_SLIDER_InGain               226
#define IDC_EDIT_OcclusionLFRatio       226
#define IDC_SLIDER_Ratio                227
#define IDC_SLIDER_OcclusionLFRatio     227
#define IDC_EDIT_Direct                 228
#define IDC_SLIDER_Direct               229
#define IDC_EDIT_Predelay               230
#define IDC_SLIDER_Predelay             231
#define IDC_EDIT_CompMeterReset         232
#define IDC_RADIO_LPF                   232
#define IDC_SLIDER_CompMeterReset       233
#define IDC_RADIO_VOLUME                233
#define IDC_EDIT_CompInputMeter         234
#define IDC_SLIDER_CompInputMeter       235
#define IDC_PRESET                      235
#define IDC_EDIT_CompGainMeter          236
#define IDC_EDIT_DecayTime              236
#define IDC_SLIDER_CompGainMeter        237
#define IDC_SLIDER_DecayTime            237
#define IDC_EDIT_DecayHFRatio           238
#define IDC_SLIDER_DecayHFRatio         239
#define IDC_EDIT_Reflections            240
#define IDC_SLIDER_Reflections          241
#define IDC_EDIT_ReflectionsDelay       242
#define IDC_SLIDER_ReflectionsDelay     243
#define IDC_EDIT_Reverb                 244
#define IDC_SLIDER_Reverb               245
#define IDC_EDIT_ReverbDelay            246
#define IDC_SLIDER_ReverbDelay          247
#define IDC_EDIT_Diffusion              250
#define IDC_SLIDER_Diffusion            251
#define IDC_EDIT_Density                252
#define IDC_SLIDER_Density              253
#define IDC_EDIT_HFReference            254
#define IDC_SLIDER_HFReference          255
#define IDC_EDIT_Quality                256
#define IDC_SLIDER_Quality              257
#define IDS_PRESETDefault               500
#define IDS_PRESETGeneric               501
#define IDS_PRESETPaddedCell            502
#define IDS_PRESETRoom                  503
#define IDS_PRESETBathroom              504
#define IDS_PRESETLivingRoom            505
#define IDS_PRESETStoneRoom             506
#define IDS_PRESETAuditorium            507
#define IDS_PRESETConcertHall           508
#define IDS_PRESETCave                  509
#define IDS_PRESETArena                 510
#define IDS_PRESETHangar                511
#define IDS_PRESETCarpetedHallway       512
#define IDS_PRESETHallway               513
#define IDS_PRESETStoneCorridor         514
#define IDS_PRESETAlley                 515
#define IDS_PRESETForest                516
#define IDS_PRESETCity                  517
#define IDS_PRESETMountains             518
#define IDS_PRESETQuarry                519
#define IDS_PRESETPlain                 520
#define IDS_PRESETParkingLot            521
#define IDS_PRESETSewerPipe             522
#define IDS_PRESETUnderWater            523
#define IDS_PRESETSmallRoom             524
#define IDS_PRESETMediumRoom            525
#define IDS_PRESETLargeRoom             526
#define IDS_PRESETMediumHall            527
#define IDS_PRESETLargeHall             528
#define IDS_PRESETPlate                 529

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         236
#define _APS_NEXT_SYMED_VALUE           151
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include <initguid.h>
#include <dsound.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__AE61EBE6_B69A_44B5_A468_E1BE7AF28509__INCLUDED_)
#define AFX_STDAFX_H__AE61EBE6_B69A_44B5_A468_E1BE7AF28509__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <mmsystem.h> //  I have to put this here or dsound includes fail.

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__AE61EBE6_B69A_44B5_A468_E1BE7AF28509__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsdmoprp\bchecker\makefile.inc ===
buildidl : $(O)\dsdmoprp.h

$(O)\dsdmoprp.h : dsdmoprp.idl
    $(MIDL) \
    $(INCPATH0) \
    $(C_DEFINES) \
    -header $(O)\dsdmoprp.h \
    -tlb     $O\dsdmoprp.tlb \
    -iid     $O\dsdmoprp_i.c  \
    -dlldata $(PROXY_DIR)\dlldata.c  \
    -proxy   $(PROXY_DIR)\dsdmoprp_p.c  \
    dsdmoprp.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\capteff.h ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        capteff.h
 *  Content:     Declaration of CCaptureEffect and CCaptureEffectChain.
 *  Description: Capture effects support. More info in capteff.cpp.
 *
 *  History:
 *
 * Date      By       Reason
 * ========  =======  ======================================================
 * 04/19/00  jstokes  Cloned from effects.h
 *
 ***************************************************************************/

#ifndef __CAPTEFF_H__
#define __CAPTEFF_H__

#ifdef __cplusplus

#include "mediaobj.h"   // For DMO_MEDIA_TYPE
#include "kshlp.h"      // For KSNODE


//
// Class representing DirectSound audio capture effect instances
//

class CCaptureEffect : public CDsBasicRuntime
{
    friend class CKsTopology;

public:
    CCaptureEffect(DSCEFFECTDESC& fxDescriptor);
    ~CCaptureEffect();
    HRESULT Initialize(DMO_MEDIA_TYPE& dmoMediaType);

    DSCEFFECTDESC               m_fxDescriptor;         // Creation parameters
    IMediaObject*               m_pMediaObject;         // The DMO's standard interface
    IDirectSoundDMOProxy*       m_pDMOProxy;            // The DMO's proxy interface
    DWORD                       m_fxStatus;             // Current effect status

    // Only used if the effect is implemented by a KS filter:
    KSNODE                      m_ksNode;               // KS node controlling the effect 
};


//
// The DirectSound capture effects chain class
//

class CCaptureEffectChain
{
    friend class CKsCaptureDevice;
    friend class CKsTopology;

public:
    CCaptureEffectChain(CDirectSoundCaptureBuffer* pBuffer);
    ~CCaptureEffectChain();

    HRESULT Initialize          (DWORD dwFxCount, LPDSCEFFECTDESC pFxDesc);
    HRESULT GetFxStatus         (LPDWORD pdwResultCodes);
    HRESULT GetEffectInterface  (REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID* ppObject);

    // Public accessors
    DWORD GetFxCount()          {return m_fxList.GetNodeCount();}
    BOOL NeedsMicrosoftAEC();

private:
    // Effects processing state
    CObjectList<CCaptureEffect> m_fxList;      // Capture effect object list
    WAVEFORMATEX                m_waveFormat;  // Format of audio data to be processed
};

#endif // __cplusplus
#endif // __CAPTEFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\decibels.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       decibels.h
 *  Content:    Decibel helper functions
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/13/97     dereks  Created
 *
 ***************************************************************************/

#ifndef __DECIBELS_H__
#define __DECIBELS_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern DWORD DBToAmpFactor(LONG);
extern LONG AmpFactorToDB(DWORD);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DECIBELS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\debug.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.h
 *  Content:    Debugger helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/21/97     dereks  Created
 *  1999-2001   duganp  Fixes, changes, enhancements
 *
 ***************************************************************************/

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef DEBUG
#undef DBG
#endif

// Disable empty controlled statement warnings for our macros
#pragma warning(disable:4390)

typedef struct _DEBUGINFO
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA Data;
    HANDLE                                   hLogFile;
} DEBUGINFO, *LPDEBUGINFO;

// Longest DPF message size allowed after expansion
#define MAX_DPF_MESSAGE             0x200

#define DPFLVLMASK                  0x000000FFUL
#define NEWDPFLVL(a)                (~DPFLVLMASK | (BYTE)(a))
#define OLDDPFLVL(a)                (DPFLVLMASK & (BYTE)(a))

#define HOLYCOW                     "******************************************************************************"
#define CRLF                        "\r\n"
                                    
#define DPFLVL_ABSOLUTE             NEWDPFLVL(0)    // Disregard level
#define DPFLVL_ERROR                NEWDPFLVL(1)    // Errors
#define DPFLVL_WARNING              NEWDPFLVL(2)    // Warnings
#define DPFLVL_INFO                 NEWDPFLVL(3)    // General info
#define DPFLVL_MOREINFO             NEWDPFLVL(4)    // More info
#define DPFLVL_API                  NEWDPFLVL(5)    // API/Interface method calls
#define DPFLVL_BUSYAPI              NEWDPFLVL(6)    // Very frequent interface calls
#define DPFLVL_LOCK                 NEWDPFLVL(7)    // Lock, lock, who's got the lock?
#define DPFLVL_ENTER                NEWDPFLVL(8)    // Function enter/leave
#define DPFLVL_CONSTRUCT            NEWDPFLVL(9)    // Object con/destruction

#define DPF_GUID_STRING             "{%8.8lX-%4.4X-%4.4X-%2.2X%2.2X-%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X}"
#define DPF_GUID_VAL(guid)          (guid).Data1, (guid).Data2, (guid).Data3, (guid).Data4[0], (guid).Data4[1], (guid).Data4[2], (guid).Data4[3], (guid).Data4[4], (guid).Data4[5], (guid).Data4[6], (guid).Data4[7]

#undef DPF_FNAME
#define DPF_FNAME                   NULL

#ifdef ASSERT
#undef ASSERT  // Some headers (e.g. ntrtl.h) define ASSERTs which conflict with ours
#endif

#ifdef RDEBUG
    #define DPFINIT()               dopen(NULL)
    #define DPFCLOSE()              dclose()
    #define RPF                     DPRINTF
#else // RDEBUG
    #pragma warning(disable:4002)
    #define DPFINIT() 
    #define DPFCLOSE()
    #define RPF()
#endif // RDEBUG

#ifdef DEBUG
    #define DPF                     DPRINTF
    #define DPRINTF                 g_pszDbgFname = DPF_FNAME, g_pszDbgFile = __FILE__, g_nDbgLine = __LINE__, dprintf
    #define DSASSERT(a)             DPRINTF(DPFLVL_ABSOLUTE, CRLF HOLYCOW CRLF "Assertion failed in %s, line %u: %s" CRLF HOLYCOW, TEXT(__FILE__), __LINE__, TEXT(a))
    #ifdef USE_INLINE_ASM
        #define ASSERT(a)           do if (!(a)) {DSASSERT(#a); __asm {int 3}} while (0)
        #define BREAK()             do __asm {int 3} while (0)
    #else
        #define ASSERT(a)           do if (!(a)) {DSASSERT(#a); DebugBreak();} while (0)
        #define BREAK()             DebugBreak()
    #endif
#else // DEBUG
    #pragma warning(disable:4002)
    #define DPF()
    #define DPRINTF                 dprintf
    #define ASSERT(a)
    #define BREAK()
#endif // DEBUG

#define DPF_API0(a)                         DPF(DPFLVL_API, #a)
#define DPF_API1(a,b)                       DPF(DPFLVL_API, #a ": " #b "=0x%p", DWORD_PTR(b))
#define DPF_API2(a,b,c)                     DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p", DWORD_PTR(b), DWORD_PTR(c))
#define DPF_API3(a,b,c,d)                   DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d))
#define DPF_API4(a,b,c,d,e)                 DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e))
#define DPF_API5(a,b,c,d,e,f)               DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p, " #f "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e), DWORD_PTR(f))
#define DPF_API6(a,b,c,d,e,f,g)             DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p, " #f "=0x%p, " #g "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e), DWORD_PTR(f), DWORD_PTR(g))
#define DPF_API7(a,b,c,d,e,f,g,h)           DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p, " #f "=0x%p, " #g "=0x%p, " #h "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e), DWORD_PTR(f), DWORD_PTR(g), DWORD_PTR(h))
#define DPF_API8(a,b,c,d,e,f,g,h,i)         DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p, " #f "=0x%p, " #g "=0x%p, " #h "=0x%p, " #i "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e), DWORD_PTR(f), DWORD_PTR(g), DWORD_PTR(h), DWORD_PTR(i))
#define DPF_API9(a,b,c,d,e,f,g,h,i,j)       DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p, " #f "=0x%p, " #g "=0x%p, " #h "=0x%p, " #i "=0x%p, " #j "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e), DWORD_PTR(f), DWORD_PTR(g), DWORD_PTR(h), DWORD_PTR(i), DWORD_PTR(j))
#define DPF_API10(a,b,c,d,e,f,g,h,i,j,k)    DPF(DPFLVL_API, #a ": " #b "=0x%p, " #c "=0x%p, " #d "=0x%p, " #e "=0x%p, " #f "=0x%p, " #g "=0x%p, " #h "=0x%p, " #i "=0x%p, " #j "=0x%p, " #k "=0x%p", DWORD_PTR(b), DWORD_PTR(c), DWORD_PTR(d), DWORD_PTR(e), DWORD_PTR(f), DWORD_PTR(g), DWORD_PTR(h), DWORD_PTR(i), DWORD_PTR(j), DWORD_PTR(k))

#define DPF_CONSTRUCT(a)            DPF(DPFLVL_CONSTRUCT, "Constructing " #a " at 0x%p", this)
#define DPF_DESTRUCT(a)             DPF(DPFLVL_CONSTRUCT, "Destroying " #a " at 0x%p", this)

#define DPF_ENTER()                 DPF(DPFLVL_ENTER, "Enter")
#define DPF_LEAVE(a)                DPF(DPFLVL_ENTER, "Leave, returning 0x%p", (DWORD_PTR)(a))
#define DPF_LEAVE_VOID()            DPF(DPFLVL_ENTER, "Leave")
#define DPF_LEAVE_HRESULT(hr)       DPF(DPFLVL_ENTER, "Leave, returning %s", HRESULTtoSTRING(hr))
#define DPF_API_LEAVE(a)            DPF(DPFLVL_API, "Leave, returning 0x%p", (DWORD_PTR)(a))
#define DPF_API_LEAVE_VOID()        DPF(DPFLVL_API, "Leave")
#define DPF_API_LEAVE_HRESULT(hr)   DPF(DPFLVL_API, "Leave, returning %s", HRESULTtoSTRING(hr))

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern DEBUGINFO g_dinfo;
#ifdef DEBUG
extern LPCSTR g_pszDbgFname;
extern LPCSTR g_pszDbgFile;
extern UINT g_nDbgLine;
#endif

extern void dopen(DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA *);
extern void dclose(void);
extern void dprintf(DWORD, LPCSTR, ...);

extern PTSTR StateName(DWORD dwState);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dmacpy32.inc ===
/***************************************************************************
 *  Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

 void DMACopy32Asm (PLONG plBuild,
		  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
		  int cbOutputBuffer
)
{
   PBYTE pOutput = (PBYTE)pvOutput;

   while (plBuild < plBuildBound)
      {
      LONG iters = plBuildBound - plBuild;
      LONG i     = (PBYTE)pWrapPoint   - pOutput;
      
      if (iters > i) iters = i;
      ;
#if 1
      if (iters) 
	_asm {
	mov	ebx, iters
	mov	esi, plBuild
	mov	edi, pOutput
	lea	eax, [esi+ebx*4]
	lea	edx, [edi+ebx*1]
	dec	ebx
	mov	plBuild, eax
	mov	pOutput, edx

	mov	ecx, 0x8000

	movd		mm5, ecx
	punpckldq	mm5, mm5	// 32768, 32768

	mov	ecx, 0x80

	movd		mm6, ecx
	punpcklwd	mm6, mm6
	punpckldq	mm6, mm6


	cmp	ebx, 15
	jl	Last

	sub	ebx, 7
	and	edx, 7
	je	Top

	add	ebx, 7
First:
	mov	ecx, DWORD PTR [esi+ebx*4]

	movd		mm1, ecx
	packssdw	mm1, mm1
	punpcklwd	mm1, mm1
	psrad		mm1, 16
	paddd		mm1, mm5
	psrad		mm1, 8
	movd		ecx, mm1

	mov	BYTE PTR [edi+ebx*1], cl

	dec	ebx
	lea	eax, [edi+ebx*1]
	and	eax, 7
	cmp	eax, 7
	jne	First
	
	sub	ebx, 7

Top:
#ifdef GTW_REORDER
	movq		mm1, [esi+ebx*4]
	movq		mm2, [esi+ebx*4+8]
	jmp	Top00
Top0:
	movq		mm7, [esi+ebx*4]
	packuswb	mm1, mm3	// Saturation is NO-OP here.

	movq		[edi+ebx*1+8], mm1

	movq		mm2, [esi+ebx*4+8]
	movq		mm1, mm7
Top00:
	movq		mm3, [esi+ebx*4+16]
	packssdw	mm1, mm2	// Clip.

	movq		mm4, [esi+ebx*4+24]
	psraw		mm1, 8

	packssdw	mm3, mm4
	sub	ebx, 8

	psraw		mm3, 8
	paddw		mm1, mm6

	paddw		mm3, mm6
	jge	Top0

	packuswb	mm1, mm3	// Saturation is NO-OP here.

	movq		[edi+ebx*1+8], mm1
#else
	movq		mm1, [esi+ebx*4]
	movq		mm2, [esi+ebx*4+8]
	movq		mm3, [esi+ebx*4+16]
	movq		mm4, [esi+ebx*4+24]

	packssdw	mm1, mm2	// Clip.
	packssdw	mm3, mm4

	psraw		mm1, 8
	psraw		mm3, 8

	paddw		mm1, mm6
	paddw		mm3, mm6

	packuswb	mm1, mm3	// Saturation is NO-OP here.

	movq		[edi+ebx*1], mm1

	sub	ebx, 8
	jge	Top
#endif

	add	ebx, 7	// 8
	jl	Done	// jle

//	dec	ebx
Last:
	mov	ecx, DWORD PTR [esi+ebx*4]

	movd		mm1, ecx
	packssdw	mm1, mm1
	punpcklwd	mm1, mm1
	psrad		mm1, 16
	paddd		mm1, mm5
	psrad		mm1, 8
	movd		ecx, mm1

	mov	BYTE PTR [edi+ebx*1], cl

	dec	ebx
	jge	Last
Done:
	emms
      }
#else
      LONG Sample;
      ++iters;
      while (--iters) {
	 Sample = *plBuild;
	 plBuild++;
         if ((LONG)((SHORT)Sample) != Sample) {
	    if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
	    else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
         }
	 Sample += 32768;
	 *pOutput = (BYTE)DIVIDEBY256(Sample);
	 pOutput++;
      }
#endif
      if (pOutput >= pWrapPoint) {
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\decibels.c ===
//--------------------------------------------------------------------------;
//
//  File: decibels.c
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/15/95	FrankYe
//
//--------------------------------------------------------------------------;
#include "dsoundi.h"

#ifndef Not_VxD
#pragma warning(disable:4002)
#undef DPF
#define DPF()
#endif

//
// This table covers -96.4 dB to -0.1 dB in 0.1 dB units
//
DWORD tblDBTenthsToAmpFactor[] = {
    0x0000, // (-964/10)dB = 0.000015 * amplitude
    0x0001, // (-963/10)dB = 0.000015 * amplitude
    0x0001, // (-962/10)dB = 0.000015 * amplitude
    0x0001, // (-961/10)dB = 0.000016 * amplitude
    0x0001, // (-960/10)dB = 0.000016 * amplitude
    0x0001, // (-959/10)dB = 0.000016 * amplitude
    0x0001, // (-958/10)dB = 0.000016 * amplitude
    0x0001, // (-957/10)dB = 0.000016 * amplitude
    0x0001, // (-956/10)dB = 0.000017 * amplitude
    0x0001, // (-955/10)dB = 0.000017 * amplitude
    0x0001, // (-954/10)dB = 0.000017 * amplitude
    0x0001, // (-953/10)dB = 0.000017 * amplitude
    0x0001, // (-952/10)dB = 0.000017 * amplitude
    0x0001, // (-951/10)dB = 0.000018 * amplitude
    0x0001, // (-950/10)dB = 0.000018 * amplitude
    0x0001, // (-949/10)dB = 0.000018 * amplitude
    0x0001, // (-948/10)dB = 0.000018 * amplitude
    0x0001, // (-947/10)dB = 0.000018 * amplitude
    0x0001, // (-946/10)dB = 0.000019 * amplitude
    0x0001, // (-945/10)dB = 0.000019 * amplitude
    0x0001, // (-944/10)dB = 0.000019 * amplitude
    0x0001, // (-943/10)dB = 0.000019 * amplitude
    0x0001, // (-942/10)dB = 0.000019 * amplitude
    0x0001, // (-941/10)dB = 0.000020 * amplitude
    0x0001, // (-940/10)dB = 0.000020 * amplitude
    0x0001, // (-939/10)dB = 0.000020 * amplitude
    0x0001, // (-938/10)dB = 0.000020 * amplitude
    0x0001, // (-937/10)dB = 0.000021 * amplitude
    0x0001, // (-936/10)dB = 0.000021 * amplitude
    0x0001, // (-935/10)dB = 0.000021 * amplitude
    0x0001, // (-934/10)dB = 0.000021 * amplitude
    0x0001, // (-933/10)dB = 0.000022 * amplitude
    0x0001, // (-932/10)dB = 0.000022 * amplitude
    0x0001, // (-931/10)dB = 0.000022 * amplitude
    0x0001, // (-930/10)dB = 0.000022 * amplitude
    0x0001, // (-929/10)dB = 0.000023 * amplitude
    0x0001, // (-928/10)dB = 0.000023 * amplitude
    0x0001, // (-927/10)dB = 0.000023 * amplitude
    0x0001, // (-926/10)dB = 0.000023 * amplitude
    0x0001, // (-925/10)dB = 0.000024 * amplitude
    0x0001, // (-924/10)dB = 0.000024 * amplitude
    0x0001, // (-923/10)dB = 0.000024 * amplitude
    0x0001, // (-922/10)dB = 0.000025 * amplitude
    0x0001, // (-921/10)dB = 0.000025 * amplitude
    0x0001, // (-920/10)dB = 0.000025 * amplitude
    0x0001, // (-919/10)dB = 0.000025 * amplitude
    0x0001, // (-918/10)dB = 0.000026 * amplitude
    0x0001, // (-917/10)dB = 0.000026 * amplitude
    0x0001, // (-916/10)dB = 0.000026 * amplitude
    0x0001, // (-915/10)dB = 0.000027 * amplitude
    0x0001, // (-914/10)dB = 0.000027 * amplitude
    0x0001, // (-913/10)dB = 0.000027 * amplitude
    0x0001, // (-912/10)dB = 0.000028 * amplitude
    0x0001, // (-911/10)dB = 0.000028 * amplitude
    0x0001, // (-910/10)dB = 0.000028 * amplitude
    0x0001, // (-909/10)dB = 0.000029 * amplitude
    0x0001, // (-908/10)dB = 0.000029 * amplitude
    0x0001, // (-907/10)dB = 0.000029 * amplitude
    0x0001, // (-906/10)dB = 0.000030 * amplitude
    0x0001, // (-905/10)dB = 0.000030 * amplitude
    0x0001, // (-904/10)dB = 0.000030 * amplitude
    0x0002, // (-903/10)dB = 0.000031 * amplitude
    0x0002, // (-902/10)dB = 0.000031 * amplitude
    0x0002, // (-901/10)dB = 0.000031 * amplitude
    0x0002, // (-900/10)dB = 0.000032 * amplitude
    0x0002, // (-899/10)dB = 0.000032 * amplitude
    0x0002, // (-898/10)dB = 0.000032 * amplitude
    0x0002, // (-897/10)dB = 0.000033 * amplitude
    0x0002, // (-896/10)dB = 0.000033 * amplitude
    0x0002, // (-895/10)dB = 0.000033 * amplitude
    0x0002, // (-894/10)dB = 0.000034 * amplitude
    0x0002, // (-893/10)dB = 0.000034 * amplitude
    0x0002, // (-892/10)dB = 0.000035 * amplitude
    0x0002, // (-891/10)dB = 0.000035 * amplitude
    0x0002, // (-890/10)dB = 0.000035 * amplitude
    0x0002, // (-889/10)dB = 0.000036 * amplitude
    0x0002, // (-888/10)dB = 0.000036 * amplitude
    0x0002, // (-887/10)dB = 0.000037 * amplitude
    0x0002, // (-886/10)dB = 0.000037 * amplitude
    0x0002, // (-885/10)dB = 0.000038 * amplitude
    0x0002, // (-884/10)dB = 0.000038 * amplitude
    0x0002, // (-883/10)dB = 0.000038 * amplitude
    0x0002, // (-882/10)dB = 0.000039 * amplitude
    0x0002, // (-881/10)dB = 0.000039 * amplitude
    0x0002, // (-880/10)dB = 0.000040 * amplitude
    0x0002, // (-879/10)dB = 0.000040 * amplitude
    0x0002, // (-878/10)dB = 0.000041 * amplitude
    0x0002, // (-877/10)dB = 0.000041 * amplitude
    0x0002, // (-876/10)dB = 0.000042 * amplitude
    0x0002, // (-875/10)dB = 0.000042 * amplitude
    0x0002, // (-874/10)dB = 0.000043 * amplitude
    0x0002, // (-873/10)dB = 0.000043 * amplitude
    0x0002, // (-872/10)dB = 0.000044 * amplitude
    0x0002, // (-871/10)dB = 0.000044 * amplitude
    0x0002, // (-870/10)dB = 0.000045 * amplitude
    0x0002, // (-869/10)dB = 0.000045 * amplitude
    0x0002, // (-868/10)dB = 0.000046 * amplitude
    0x0003, // (-867/10)dB = 0.000046 * amplitude
    0x0003, // (-866/10)dB = 0.000047 * amplitude
    0x0003, // (-865/10)dB = 0.000047 * amplitude
    0x0003, // (-864/10)dB = 0.000048 * amplitude
    0x0003, // (-863/10)dB = 0.000048 * amplitude
    0x0003, // (-862/10)dB = 0.000049 * amplitude
    0x0003, // (-861/10)dB = 0.000050 * amplitude
    0x0003, // (-860/10)dB = 0.000050 * amplitude
    0x0003, // (-859/10)dB = 0.000051 * amplitude
    0x0003, // (-858/10)dB = 0.000051 * amplitude
    0x0003, // (-857/10)dB = 0.000052 * amplitude
    0x0003, // (-856/10)dB = 0.000052 * amplitude
    0x0003, // (-855/10)dB = 0.000053 * amplitude
    0x0003, // (-854/10)dB = 0.000054 * amplitude
    0x0003, // (-853/10)dB = 0.000054 * amplitude
    0x0003, // (-852/10)dB = 0.000055 * amplitude
    0x0003, // (-851/10)dB = 0.000056 * amplitude
    0x0003, // (-850/10)dB = 0.000056 * amplitude
    0x0003, // (-849/10)dB = 0.000057 * amplitude
    0x0003, // (-848/10)dB = 0.000058 * amplitude
    0x0003, // (-847/10)dB = 0.000058 * amplitude
    0x0003, // (-846/10)dB = 0.000059 * amplitude
    0x0003, // (-845/10)dB = 0.000060 * amplitude
    0x0003, // (-844/10)dB = 0.000060 * amplitude
    0x0003, // (-843/10)dB = 0.000061 * amplitude
    0x0004, // (-842/10)dB = 0.000062 * amplitude
    0x0004, // (-841/10)dB = 0.000062 * amplitude
    0x0004, // (-840/10)dB = 0.000063 * amplitude
    0x0004, // (-839/10)dB = 0.000064 * amplitude
    0x0004, // (-838/10)dB = 0.000065 * amplitude
    0x0004, // (-837/10)dB = 0.000065 * amplitude
    0x0004, // (-836/10)dB = 0.000066 * amplitude
    0x0004, // (-835/10)dB = 0.000067 * amplitude
    0x0004, // (-834/10)dB = 0.000068 * amplitude
    0x0004, // (-833/10)dB = 0.000068 * amplitude
    0x0004, // (-832/10)dB = 0.000069 * amplitude
    0x0004, // (-831/10)dB = 0.000070 * amplitude
    0x0004, // (-830/10)dB = 0.000071 * amplitude
    0x0004, // (-829/10)dB = 0.000072 * amplitude
    0x0004, // (-828/10)dB = 0.000072 * amplitude
    0x0004, // (-827/10)dB = 0.000073 * amplitude
    0x0004, // (-826/10)dB = 0.000074 * amplitude
    0x0004, // (-825/10)dB = 0.000075 * amplitude
    0x0004, // (-824/10)dB = 0.000076 * amplitude
    0x0005, // (-823/10)dB = 0.000077 * amplitude
    0x0005, // (-822/10)dB = 0.000078 * amplitude
    0x0005, // (-821/10)dB = 0.000079 * amplitude
    0x0005, // (-820/10)dB = 0.000079 * amplitude
    0x0005, // (-819/10)dB = 0.000080 * amplitude
    0x0005, // (-818/10)dB = 0.000081 * amplitude
    0x0005, // (-817/10)dB = 0.000082 * amplitude
    0x0005, // (-816/10)dB = 0.000083 * amplitude
    0x0005, // (-815/10)dB = 0.000084 * amplitude
    0x0005, // (-814/10)dB = 0.000085 * amplitude
    0x0005, // (-813/10)dB = 0.000086 * amplitude
    0x0005, // (-812/10)dB = 0.000087 * amplitude
    0x0005, // (-811/10)dB = 0.000088 * amplitude
    0x0005, // (-810/10)dB = 0.000089 * amplitude
    0x0005, // (-809/10)dB = 0.000090 * amplitude
    0x0005, // (-808/10)dB = 0.000091 * amplitude
    0x0006, // (-807/10)dB = 0.000092 * amplitude
    0x0006, // (-806/10)dB = 0.000093 * amplitude
    0x0006, // (-805/10)dB = 0.000094 * amplitude
    0x0006, // (-804/10)dB = 0.000095 * amplitude
    0x0006, // (-803/10)dB = 0.000097 * amplitude
    0x0006, // (-802/10)dB = 0.000098 * amplitude
    0x0006, // (-801/10)dB = 0.000099 * amplitude
    0x0006, // (-800/10)dB = 0.000100 * amplitude
    0x0006, // (-799/10)dB = 0.000101 * amplitude
    0x0006, // (-798/10)dB = 0.000102 * amplitude
    0x0006, // (-797/10)dB = 0.000104 * amplitude
    0x0006, // (-796/10)dB = 0.000105 * amplitude
    0x0006, // (-795/10)dB = 0.000106 * amplitude
    0x0007, // (-794/10)dB = 0.000107 * amplitude
    0x0007, // (-793/10)dB = 0.000108 * amplitude
    0x0007, // (-792/10)dB = 0.000110 * amplitude
    0x0007, // (-791/10)dB = 0.000111 * amplitude
    0x0007, // (-790/10)dB = 0.000112 * amplitude
    0x0007, // (-789/10)dB = 0.000114 * amplitude
    0x0007, // (-788/10)dB = 0.000115 * amplitude
    0x0007, // (-787/10)dB = 0.000116 * amplitude
    0x0007, // (-786/10)dB = 0.000117 * amplitude
    0x0007, // (-785/10)dB = 0.000119 * amplitude
    0x0007, // (-784/10)dB = 0.000120 * amplitude
    0x0007, // (-783/10)dB = 0.000122 * amplitude
    0x0008, // (-782/10)dB = 0.000123 * amplitude
    0x0008, // (-781/10)dB = 0.000124 * amplitude
    0x0008, // (-780/10)dB = 0.000126 * amplitude
    0x0008, // (-779/10)dB = 0.000127 * amplitude
    0x0008, // (-778/10)dB = 0.000129 * amplitude
    0x0008, // (-777/10)dB = 0.000130 * amplitude
    0x0008, // (-776/10)dB = 0.000132 * amplitude
    0x0008, // (-775/10)dB = 0.000133 * amplitude
    0x0008, // (-774/10)dB = 0.000135 * amplitude
    0x0008, // (-773/10)dB = 0.000136 * amplitude
    0x0009, // (-772/10)dB = 0.000138 * amplitude
    0x0009, // (-771/10)dB = 0.000140 * amplitude
    0x0009, // (-770/10)dB = 0.000141 * amplitude
    0x0009, // (-769/10)dB = 0.000143 * amplitude
    0x0009, // (-768/10)dB = 0.000145 * amplitude
    0x0009, // (-767/10)dB = 0.000146 * amplitude
    0x0009, // (-766/10)dB = 0.000148 * amplitude
    0x0009, // (-765/10)dB = 0.000150 * amplitude
    0x0009, // (-764/10)dB = 0.000151 * amplitude
    0x000A, // (-763/10)dB = 0.000153 * amplitude
    0x000A, // (-762/10)dB = 0.000155 * amplitude
    0x000A, // (-761/10)dB = 0.000157 * amplitude
    0x000A, // (-760/10)dB = 0.000158 * amplitude
    0x000A, // (-759/10)dB = 0.000160 * amplitude
    0x000A, // (-758/10)dB = 0.000162 * amplitude
    0x000A, // (-757/10)dB = 0.000164 * amplitude
    0x000A, // (-756/10)dB = 0.000166 * amplitude
    0x000B, // (-755/10)dB = 0.000168 * amplitude
    0x000B, // (-754/10)dB = 0.000170 * amplitude
    0x000B, // (-753/10)dB = 0.000172 * amplitude
    0x000B, // (-752/10)dB = 0.000174 * amplitude
    0x000B, // (-751/10)dB = 0.000176 * amplitude
    0x000B, // (-750/10)dB = 0.000178 * amplitude
    0x000B, // (-749/10)dB = 0.000180 * amplitude
    0x000B, // (-748/10)dB = 0.000182 * amplitude
    0x000C, // (-747/10)dB = 0.000184 * amplitude
    0x000C, // (-746/10)dB = 0.000186 * amplitude
    0x000C, // (-745/10)dB = 0.000188 * amplitude
    0x000C, // (-744/10)dB = 0.000191 * amplitude
    0x000C, // (-743/10)dB = 0.000193 * amplitude
    0x000C, // (-742/10)dB = 0.000195 * amplitude
    0x000C, // (-741/10)dB = 0.000197 * amplitude
    0x000D, // (-740/10)dB = 0.000200 * amplitude
    0x000D, // (-739/10)dB = 0.000202 * amplitude
    0x000D, // (-738/10)dB = 0.000204 * amplitude
    0x000D, // (-737/10)dB = 0.000207 * amplitude
    0x000D, // (-736/10)dB = 0.000209 * amplitude
    0x000D, // (-735/10)dB = 0.000211 * amplitude
    0x000E, // (-734/10)dB = 0.000214 * amplitude
    0x000E, // (-733/10)dB = 0.000216 * amplitude
    0x000E, // (-732/10)dB = 0.000219 * amplitude
    0x000E, // (-731/10)dB = 0.000221 * amplitude
    0x000E, // (-730/10)dB = 0.000224 * amplitude
    0x000E, // (-729/10)dB = 0.000226 * amplitude
    0x000F, // (-728/10)dB = 0.000229 * amplitude
    0x000F, // (-727/10)dB = 0.000232 * amplitude
    0x000F, // (-726/10)dB = 0.000234 * amplitude
    0x000F, // (-725/10)dB = 0.000237 * amplitude
    0x000F, // (-724/10)dB = 0.000240 * amplitude
    0x000F, // (-723/10)dB = 0.000243 * amplitude
    0x0010, // (-722/10)dB = 0.000245 * amplitude
    0x0010, // (-721/10)dB = 0.000248 * amplitude
    0x0010, // (-720/10)dB = 0.000251 * amplitude
    0x0010, // (-719/10)dB = 0.000254 * amplitude
    0x0010, // (-718/10)dB = 0.000257 * amplitude
    0x0011, // (-717/10)dB = 0.000260 * amplitude
    0x0011, // (-716/10)dB = 0.000263 * amplitude
    0x0011, // (-715/10)dB = 0.000266 * amplitude
    0x0011, // (-714/10)dB = 0.000269 * amplitude
    0x0011, // (-713/10)dB = 0.000272 * amplitude
    0x0012, // (-712/10)dB = 0.000275 * amplitude
    0x0012, // (-711/10)dB = 0.000279 * amplitude
    0x0012, // (-710/10)dB = 0.000282 * amplitude
    0x0012, // (-709/10)dB = 0.000285 * amplitude
    0x0012, // (-708/10)dB = 0.000288 * amplitude
    0x0013, // (-707/10)dB = 0.000292 * amplitude
    0x0013, // (-706/10)dB = 0.000295 * amplitude
    0x0013, // (-705/10)dB = 0.000299 * amplitude
    0x0013, // (-704/10)dB = 0.000302 * amplitude
    0x0014, // (-703/10)dB = 0.000305 * amplitude
    0x0014, // (-702/10)dB = 0.000309 * amplitude
    0x0014, // (-701/10)dB = 0.000313 * amplitude
    0x0014, // (-700/10)dB = 0.000316 * amplitude
    0x0014, // (-699/10)dB = 0.000320 * amplitude
    0x0015, // (-698/10)dB = 0.000324 * amplitude
    0x0015, // (-697/10)dB = 0.000327 * amplitude
    0x0015, // (-696/10)dB = 0.000331 * amplitude
    0x0015, // (-695/10)dB = 0.000335 * amplitude
    0x0016, // (-694/10)dB = 0.000339 * amplitude
    0x0016, // (-693/10)dB = 0.000343 * amplitude
    0x0016, // (-692/10)dB = 0.000347 * amplitude
    0x0016, // (-691/10)dB = 0.000351 * amplitude
    0x0017, // (-690/10)dB = 0.000355 * amplitude
    0x0017, // (-689/10)dB = 0.000359 * amplitude
    0x0017, // (-688/10)dB = 0.000363 * amplitude
    0x0018, // (-687/10)dB = 0.000367 * amplitude
    0x0018, // (-686/10)dB = 0.000372 * amplitude
    0x0018, // (-685/10)dB = 0.000376 * amplitude
    0x0018, // (-684/10)dB = 0.000380 * amplitude
    0x0019, // (-683/10)dB = 0.000385 * amplitude
    0x0019, // (-682/10)dB = 0.000389 * amplitude
    0x0019, // (-681/10)dB = 0.000394 * amplitude
    0x001A, // (-680/10)dB = 0.000398 * amplitude
    0x001A, // (-679/10)dB = 0.000403 * amplitude
    0x001A, // (-678/10)dB = 0.000407 * amplitude
    0x001B, // (-677/10)dB = 0.000412 * amplitude
    0x001B, // (-676/10)dB = 0.000417 * amplitude
    0x001B, // (-675/10)dB = 0.000422 * amplitude
    0x001B, // (-674/10)dB = 0.000427 * amplitude
    0x001C, // (-673/10)dB = 0.000432 * amplitude
    0x001C, // (-672/10)dB = 0.000437 * amplitude
    0x001C, // (-671/10)dB = 0.000442 * amplitude
    0x001D, // (-670/10)dB = 0.000447 * amplitude
    0x001D, // (-669/10)dB = 0.000452 * amplitude
    0x001D, // (-668/10)dB = 0.000457 * amplitude
    0x001E, // (-667/10)dB = 0.000462 * amplitude
    0x001E, // (-666/10)dB = 0.000468 * amplitude
    0x001F, // (-665/10)dB = 0.000473 * amplitude
    0x001F, // (-664/10)dB = 0.000479 * amplitude
    0x001F, // (-663/10)dB = 0.000484 * amplitude
    0x0020, // (-662/10)dB = 0.000490 * amplitude
    0x0020, // (-661/10)dB = 0.000495 * amplitude
    0x0020, // (-660/10)dB = 0.000501 * amplitude
    0x0021, // (-659/10)dB = 0.000507 * amplitude
    0x0021, // (-658/10)dB = 0.000513 * amplitude
    0x0022, // (-657/10)dB = 0.000519 * amplitude
    0x0022, // (-656/10)dB = 0.000525 * amplitude
    0x0022, // (-655/10)dB = 0.000531 * amplitude
    0x0023, // (-654/10)dB = 0.000537 * amplitude
    0x0023, // (-653/10)dB = 0.000543 * amplitude
    0x0024, // (-652/10)dB = 0.000550 * amplitude
    0x0024, // (-651/10)dB = 0.000556 * amplitude
    0x0024, // (-650/10)dB = 0.000562 * amplitude
    0x0025, // (-649/10)dB = 0.000569 * amplitude
    0x0025, // (-648/10)dB = 0.000575 * amplitude
    0x0026, // (-647/10)dB = 0.000582 * amplitude
    0x0026, // (-646/10)dB = 0.000589 * amplitude
    0x0027, // (-645/10)dB = 0.000596 * amplitude
    0x0027, // (-644/10)dB = 0.000603 * amplitude
    0x0027, // (-643/10)dB = 0.000610 * amplitude
    0x0028, // (-642/10)dB = 0.000617 * amplitude
    0x0028, // (-641/10)dB = 0.000624 * amplitude
    0x0029, // (-640/10)dB = 0.000631 * amplitude
    0x0029, // (-639/10)dB = 0.000638 * amplitude
    0x002A, // (-638/10)dB = 0.000646 * amplitude
    0x002A, // (-637/10)dB = 0.000653 * amplitude
    0x002B, // (-636/10)dB = 0.000661 * amplitude
    0x002B, // (-635/10)dB = 0.000668 * amplitude
    0x002C, // (-634/10)dB = 0.000676 * amplitude
    0x002C, // (-633/10)dB = 0.000684 * amplitude
    0x002D, // (-632/10)dB = 0.000692 * amplitude
    0x002D, // (-631/10)dB = 0.000700 * amplitude
    0x002E, // (-630/10)dB = 0.000708 * amplitude
    0x002E, // (-629/10)dB = 0.000716 * amplitude
    0x002F, // (-628/10)dB = 0.000724 * amplitude
    0x0030, // (-627/10)dB = 0.000733 * amplitude
    0x0030, // (-626/10)dB = 0.000741 * amplitude
    0x0031, // (-625/10)dB = 0.000750 * amplitude
    0x0031, // (-624/10)dB = 0.000759 * amplitude
    0x0032, // (-623/10)dB = 0.000767 * amplitude
    0x0032, // (-622/10)dB = 0.000776 * amplitude
    0x0033, // (-621/10)dB = 0.000785 * amplitude
    0x0034, // (-620/10)dB = 0.000794 * amplitude
    0x0034, // (-619/10)dB = 0.000804 * amplitude
    0x0035, // (-618/10)dB = 0.000813 * amplitude
    0x0035, // (-617/10)dB = 0.000822 * amplitude
    0x0036, // (-616/10)dB = 0.000832 * amplitude
    0x0037, // (-615/10)dB = 0.000841 * amplitude
    0x0037, // (-614/10)dB = 0.000851 * amplitude
    0x0038, // (-613/10)dB = 0.000861 * amplitude
    0x0039, // (-612/10)dB = 0.000871 * amplitude
    0x0039, // (-611/10)dB = 0.000881 * amplitude
    0x003A, // (-610/10)dB = 0.000891 * amplitude
    0x003B, // (-609/10)dB = 0.000902 * amplitude
    0x003B, // (-608/10)dB = 0.000912 * amplitude
    0x003C, // (-607/10)dB = 0.000923 * amplitude
    0x003D, // (-606/10)dB = 0.000933 * amplitude
    0x003D, // (-605/10)dB = 0.000944 * amplitude
    0x003E, // (-604/10)dB = 0.000955 * amplitude
    0x003F, // (-603/10)dB = 0.000966 * amplitude
    0x0040, // (-602/10)dB = 0.000977 * amplitude
    0x0040, // (-601/10)dB = 0.000989 * amplitude
    0x0041, // (-600/10)dB = 0.001000 * amplitude
    0x0042, // (-599/10)dB = 0.001012 * amplitude
    0x0043, // (-598/10)dB = 0.001023 * amplitude
    0x0043, // (-597/10)dB = 0.001035 * amplitude
    0x0044, // (-596/10)dB = 0.001047 * amplitude
    0x0045, // (-595/10)dB = 0.001059 * amplitude
    0x0046, // (-594/10)dB = 0.001072 * amplitude
    0x0047, // (-593/10)dB = 0.001084 * amplitude
    0x0047, // (-592/10)dB = 0.001096 * amplitude
    0x0048, // (-591/10)dB = 0.001109 * amplitude
    0x0049, // (-590/10)dB = 0.001122 * amplitude
    0x004A, // (-589/10)dB = 0.001135 * amplitude
    0x004B, // (-588/10)dB = 0.001148 * amplitude
    0x004C, // (-587/10)dB = 0.001161 * amplitude
    0x004C, // (-586/10)dB = 0.001175 * amplitude
    0x004D, // (-585/10)dB = 0.001189 * amplitude
    0x004E, // (-584/10)dB = 0.001202 * amplitude
    0x004F, // (-583/10)dB = 0.001216 * amplitude
    0x0050, // (-582/10)dB = 0.001230 * amplitude
    0x0051, // (-581/10)dB = 0.001245 * amplitude
    0x0052, // (-580/10)dB = 0.001259 * amplitude
    0x0053, // (-579/10)dB = 0.001274 * amplitude
    0x0054, // (-578/10)dB = 0.001288 * amplitude
    0x0055, // (-577/10)dB = 0.001303 * amplitude
    0x0056, // (-576/10)dB = 0.001318 * amplitude
    0x0057, // (-575/10)dB = 0.001334 * amplitude
    0x0058, // (-574/10)dB = 0.001349 * amplitude
    0x0059, // (-573/10)dB = 0.001365 * amplitude
    0x005A, // (-572/10)dB = 0.001380 * amplitude
    0x005B, // (-571/10)dB = 0.001396 * amplitude
    0x005C, // (-570/10)dB = 0.001413 * amplitude
    0x005D, // (-569/10)dB = 0.001429 * amplitude
    0x005E, // (-568/10)dB = 0.001445 * amplitude
    0x005F, // (-567/10)dB = 0.001462 * amplitude
    0x0060, // (-566/10)dB = 0.001479 * amplitude
    0x0062, // (-565/10)dB = 0.001496 * amplitude
    0x0063, // (-564/10)dB = 0.001514 * amplitude
    0x0064, // (-563/10)dB = 0.001531 * amplitude
    0x0065, // (-562/10)dB = 0.001549 * amplitude
    0x0066, // (-561/10)dB = 0.001567 * amplitude
    0x0067, // (-560/10)dB = 0.001585 * amplitude
    0x0069, // (-559/10)dB = 0.001603 * amplitude
    0x006A, // (-558/10)dB = 0.001622 * amplitude
    0x006B, // (-557/10)dB = 0.001641 * amplitude
    0x006C, // (-556/10)dB = 0.001660 * amplitude
    0x006E, // (-555/10)dB = 0.001679 * amplitude
    0x006F, // (-554/10)dB = 0.001698 * amplitude
    0x0070, // (-553/10)dB = 0.001718 * amplitude
    0x0071, // (-552/10)dB = 0.001738 * amplitude
    0x0073, // (-551/10)dB = 0.001758 * amplitude
    0x0074, // (-550/10)dB = 0.001778 * amplitude
    0x0075, // (-549/10)dB = 0.001799 * amplitude
    0x0077, // (-548/10)dB = 0.001820 * amplitude
    0x0078, // (-547/10)dB = 0.001841 * amplitude
    0x007A, // (-546/10)dB = 0.001862 * amplitude
    0x007B, // (-545/10)dB = 0.001884 * amplitude
    0x007C, // (-544/10)dB = 0.001905 * amplitude
    0x007E, // (-543/10)dB = 0.001928 * amplitude
    0x007F, // (-542/10)dB = 0.001950 * amplitude
    0x0081, // (-541/10)dB = 0.001972 * amplitude
    0x0082, // (-540/10)dB = 0.001995 * amplitude
    0x0084, // (-539/10)dB = 0.002018 * amplitude
    0x0085, // (-538/10)dB = 0.002042 * amplitude
    0x0087, // (-537/10)dB = 0.002065 * amplitude
    0x0088, // (-536/10)dB = 0.002089 * amplitude
    0x008A, // (-535/10)dB = 0.002113 * amplitude
    0x008C, // (-534/10)dB = 0.002138 * amplitude
    0x008D, // (-533/10)dB = 0.002163 * amplitude
    0x008F, // (-532/10)dB = 0.002188 * amplitude
    0x0091, // (-531/10)dB = 0.002213 * amplitude
    0x0092, // (-530/10)dB = 0.002239 * amplitude
    0x0094, // (-529/10)dB = 0.002265 * amplitude
    0x0096, // (-528/10)dB = 0.002291 * amplitude
    0x0097, // (-527/10)dB = 0.002317 * amplitude
    0x0099, // (-526/10)dB = 0.002344 * amplitude
    0x009B, // (-525/10)dB = 0.002371 * amplitude
    0x009D, // (-524/10)dB = 0.002399 * amplitude
    0x009F, // (-523/10)dB = 0.002427 * amplitude
    0x00A0, // (-522/10)dB = 0.002455 * amplitude
    0x00A2, // (-521/10)dB = 0.002483 * amplitude
    0x00A4, // (-520/10)dB = 0.002512 * amplitude
    0x00A6, // (-519/10)dB = 0.002541 * amplitude
    0x00A8, // (-518/10)dB = 0.002570 * amplitude
    0x00AA, // (-517/10)dB = 0.002600 * amplitude
    0x00AC, // (-516/10)dB = 0.002630 * amplitude
    0x00AE, // (-515/10)dB = 0.002661 * amplitude
    0x00B0, // (-514/10)dB = 0.002692 * amplitude
    0x00B2, // (-513/10)dB = 0.002723 * amplitude
    0x00B4, // (-512/10)dB = 0.002754 * amplitude
    0x00B6, // (-511/10)dB = 0.002786 * amplitude
    0x00B8, // (-510/10)dB = 0.002818 * amplitude
    0x00BA, // (-509/10)dB = 0.002851 * amplitude
    0x00BD, // (-508/10)dB = 0.002884 * amplitude
    0x00BF, // (-507/10)dB = 0.002917 * amplitude
    0x00C1, // (-506/10)dB = 0.002951 * amplitude
    0x00C3, // (-505/10)dB = 0.002985 * amplitude
    0x00C5, // (-504/10)dB = 0.003020 * amplitude
    0x00C8, // (-503/10)dB = 0.003055 * amplitude
    0x00CA, // (-502/10)dB = 0.003090 * amplitude
    0x00CC, // (-501/10)dB = 0.003126 * amplitude
    0x00CF, // (-500/10)dB = 0.003162 * amplitude
    0x00D1, // (-499/10)dB = 0.003199 * amplitude
    0x00D4, // (-498/10)dB = 0.003236 * amplitude
    0x00D6, // (-497/10)dB = 0.003273 * amplitude
    0x00D9, // (-496/10)dB = 0.003311 * amplitude
    0x00DB, // (-495/10)dB = 0.003350 * amplitude
    0x00DE, // (-494/10)dB = 0.003388 * amplitude
    0x00E0, // (-493/10)dB = 0.003428 * amplitude
    0x00E3, // (-492/10)dB = 0.003467 * amplitude
    0x00E5, // (-491/10)dB = 0.003508 * amplitude
    0x00E8, // (-490/10)dB = 0.003548 * amplitude
    0x00EB, // (-489/10)dB = 0.003589 * amplitude
    0x00ED, // (-488/10)dB = 0.003631 * amplitude
    0x00F0, // (-487/10)dB = 0.003673 * amplitude
    0x00F3, // (-486/10)dB = 0.003715 * amplitude
    0x00F6, // (-485/10)dB = 0.003758 * amplitude
    0x00F9, // (-484/10)dB = 0.003802 * amplitude
    0x00FC, // (-483/10)dB = 0.003846 * amplitude
    0x00FE, // (-482/10)dB = 0.003890 * amplitude
    0x0101, // (-481/10)dB = 0.003936 * amplitude
    0x0104, // (-480/10)dB = 0.003981 * amplitude
    0x0107, // (-479/10)dB = 0.004027 * amplitude
    0x010A, // (-478/10)dB = 0.004074 * amplitude
    0x010E, // (-477/10)dB = 0.004121 * amplitude
    0x0111, // (-476/10)dB = 0.004169 * amplitude
    0x0114, // (-475/10)dB = 0.004217 * amplitude
    0x0117, // (-474/10)dB = 0.004266 * amplitude
    0x011A, // (-473/10)dB = 0.004315 * amplitude
    0x011E, // (-472/10)dB = 0.004365 * amplitude
    0x0121, // (-471/10)dB = 0.004416 * amplitude
    0x0124, // (-470/10)dB = 0.004467 * amplitude
    0x0128, // (-469/10)dB = 0.004519 * amplitude
    0x012B, // (-468/10)dB = 0.004571 * amplitude
    0x012F, // (-467/10)dB = 0.004624 * amplitude
    0x0132, // (-466/10)dB = 0.004677 * amplitude
    0x0136, // (-465/10)dB = 0.004732 * amplitude
    0x0139, // (-464/10)dB = 0.004786 * amplitude
    0x013D, // (-463/10)dB = 0.004842 * amplitude
    0x0140, // (-462/10)dB = 0.004898 * amplitude
    0x0144, // (-461/10)dB = 0.004955 * amplitude
    0x0148, // (-460/10)dB = 0.005012 * amplitude
    0x014C, // (-459/10)dB = 0.005070 * amplitude
    0x0150, // (-458/10)dB = 0.005129 * amplitude
    0x0154, // (-457/10)dB = 0.005188 * amplitude
    0x0157, // (-456/10)dB = 0.005248 * amplitude
    0x015B, // (-455/10)dB = 0.005309 * amplitude
    0x015F, // (-454/10)dB = 0.005370 * amplitude
    0x0164, // (-453/10)dB = 0.005433 * amplitude
    0x0168, // (-452/10)dB = 0.005495 * amplitude
    0x016C, // (-451/10)dB = 0.005559 * amplitude
    0x0170, // (-450/10)dB = 0.005623 * amplitude
    0x0174, // (-449/10)dB = 0.005689 * amplitude
    0x0179, // (-448/10)dB = 0.005754 * amplitude
    0x017D, // (-447/10)dB = 0.005821 * amplitude
    0x0181, // (-446/10)dB = 0.005888 * amplitude
    0x0186, // (-445/10)dB = 0.005957 * amplitude
    0x018A, // (-444/10)dB = 0.006026 * amplitude
    0x018F, // (-443/10)dB = 0.006095 * amplitude
    0x0194, // (-442/10)dB = 0.006166 * amplitude
    0x0198, // (-441/10)dB = 0.006237 * amplitude
    0x019D, // (-440/10)dB = 0.006310 * amplitude
    0x01A2, // (-439/10)dB = 0.006383 * amplitude
    0x01A7, // (-438/10)dB = 0.006457 * amplitude
    0x01AC, // (-437/10)dB = 0.006531 * amplitude
    0x01B0, // (-436/10)dB = 0.006607 * amplitude
    0x01B6, // (-435/10)dB = 0.006683 * amplitude
    0x01BB, // (-434/10)dB = 0.006761 * amplitude
    0x01C0, // (-433/10)dB = 0.006839 * amplitude
    0x01C5, // (-432/10)dB = 0.006918 * amplitude
    0x01CA, // (-431/10)dB = 0.006998 * amplitude
    0x01CF, // (-430/10)dB = 0.007079 * amplitude
    0x01D5, // (-429/10)dB = 0.007161 * amplitude
    0x01DA, // (-428/10)dB = 0.007244 * amplitude
    0x01E0, // (-427/10)dB = 0.007328 * amplitude
    0x01E5, // (-426/10)dB = 0.007413 * amplitude
    0x01EB, // (-425/10)dB = 0.007499 * amplitude
    0x01F1, // (-424/10)dB = 0.007586 * amplitude
    0x01F6, // (-423/10)dB = 0.007674 * amplitude
    0x01FC, // (-422/10)dB = 0.007762 * amplitude
    0x0202, // (-421/10)dB = 0.007852 * amplitude
    0x0208, // (-420/10)dB = 0.007943 * amplitude
    0x020E, // (-419/10)dB = 0.008035 * amplitude
    0x0214, // (-418/10)dB = 0.008128 * amplitude
    0x021A, // (-417/10)dB = 0.008222 * amplitude
    0x0221, // (-416/10)dB = 0.008318 * amplitude
    0x0227, // (-415/10)dB = 0.008414 * amplitude
    0x022D, // (-414/10)dB = 0.008511 * amplitude
    0x0234, // (-413/10)dB = 0.008610 * amplitude
    0x023A, // (-412/10)dB = 0.008710 * amplitude
    0x0241, // (-411/10)dB = 0.008810 * amplitude
    0x0248, // (-410/10)dB = 0.008913 * amplitude
    0x024E, // (-409/10)dB = 0.009016 * amplitude
    0x0255, // (-408/10)dB = 0.009120 * amplitude
    0x025C, // (-407/10)dB = 0.009226 * amplitude
    0x0263, // (-406/10)dB = 0.009333 * amplitude
    0x026A, // (-405/10)dB = 0.009441 * amplitude
    0x0271, // (-404/10)dB = 0.009550 * amplitude
    0x0279, // (-403/10)dB = 0.009661 * amplitude
    0x0280, // (-402/10)dB = 0.009772 * amplitude
    0x0287, // (-401/10)dB = 0.009886 * amplitude
    0x028F, // (-400/10)dB = 0.010000 * amplitude
    0x0296, // (-399/10)dB = 0.010116 * amplitude
    0x029E, // (-398/10)dB = 0.010233 * amplitude
    0x02A6, // (-397/10)dB = 0.010351 * amplitude
    0x02AE, // (-396/10)dB = 0.010471 * amplitude
    0x02B6, // (-395/10)dB = 0.010593 * amplitude
    0x02BE, // (-394/10)dB = 0.010715 * amplitude
    0x02C6, // (-393/10)dB = 0.010839 * amplitude
    0x02CE, // (-392/10)dB = 0.010965 * amplitude
    0x02D6, // (-391/10)dB = 0.011092 * amplitude
    0x02DF, // (-390/10)dB = 0.011220 * amplitude
    0x02E7, // (-389/10)dB = 0.011350 * amplitude
    0x02F0, // (-388/10)dB = 0.011482 * amplitude
    0x02F9, // (-387/10)dB = 0.011614 * amplitude
    0x0301, // (-386/10)dB = 0.011749 * amplitude
    0x030A, // (-385/10)dB = 0.011885 * amplitude
    0x0313, // (-384/10)dB = 0.012023 * amplitude
    0x031D, // (-383/10)dB = 0.012162 * amplitude
    0x0326, // (-382/10)dB = 0.012303 * amplitude
    0x032F, // (-381/10)dB = 0.012445 * amplitude
    0x0339, // (-380/10)dB = 0.012589 * amplitude
    0x0342, // (-379/10)dB = 0.012735 * amplitude
    0x034C, // (-378/10)dB = 0.012882 * amplitude
    0x0356, // (-377/10)dB = 0.013032 * amplitude
    0x035F, // (-376/10)dB = 0.013183 * amplitude
    0x0369, // (-375/10)dB = 0.013335 * amplitude
    0x0374, // (-374/10)dB = 0.013490 * amplitude
    0x037E, // (-373/10)dB = 0.013646 * amplitude
    0x0388, // (-372/10)dB = 0.013804 * amplitude
    0x0393, // (-371/10)dB = 0.013964 * amplitude
    0x039D, // (-370/10)dB = 0.014125 * amplitude
    0x03A8, // (-369/10)dB = 0.014289 * amplitude
    0x03B3, // (-368/10)dB = 0.014454 * amplitude
    0x03BE, // (-367/10)dB = 0.014622 * amplitude
    0x03C9, // (-366/10)dB = 0.014791 * amplitude
    0x03D4, // (-365/10)dB = 0.014962 * amplitude
    0x03DF, // (-364/10)dB = 0.015136 * amplitude
    0x03EB, // (-363/10)dB = 0.015311 * amplitude
    0x03F7, // (-362/10)dB = 0.015488 * amplitude
    0x0402, // (-361/10)dB = 0.015668 * amplitude
    0x040E, // (-360/10)dB = 0.015849 * amplitude
    0x041A, // (-359/10)dB = 0.016032 * amplitude
    0x0426, // (-358/10)dB = 0.016218 * amplitude
    0x0433, // (-357/10)dB = 0.016406 * amplitude
    0x043F, // (-356/10)dB = 0.016596 * amplitude
    0x044C, // (-355/10)dB = 0.016788 * amplitude
    0x0458, // (-354/10)dB = 0.016982 * amplitude
    0x0465, // (-353/10)dB = 0.017179 * amplitude
    0x0472, // (-352/10)dB = 0.017378 * amplitude
    0x0480, // (-351/10)dB = 0.017579 * amplitude
    0x048D, // (-350/10)dB = 0.017783 * amplitude
    0x049A, // (-349/10)dB = 0.017989 * amplitude
    0x04A8, // (-348/10)dB = 0.018197 * amplitude
    0x04B6, // (-347/10)dB = 0.018408 * amplitude
    0x04C4, // (-346/10)dB = 0.018621 * amplitude
    0x04D2, // (-345/10)dB = 0.018836 * amplitude
    0x04E0, // (-344/10)dB = 0.019055 * amplitude
    0x04EF, // (-343/10)dB = 0.019275 * amplitude
    0x04FD, // (-342/10)dB = 0.019498 * amplitude
    0x050C, // (-341/10)dB = 0.019724 * amplitude
    0x051B, // (-340/10)dB = 0.019953 * amplitude
    0x052A, // (-339/10)dB = 0.020184 * amplitude
    0x053A, // (-338/10)dB = 0.020417 * amplitude
    0x0549, // (-337/10)dB = 0.020654 * amplitude
    0x0559, // (-336/10)dB = 0.020893 * amplitude
    0x0569, // (-335/10)dB = 0.021135 * amplitude
    0x0579, // (-334/10)dB = 0.021380 * amplitude
    0x0589, // (-333/10)dB = 0.021627 * amplitude
    0x0599, // (-332/10)dB = 0.021878 * amplitude
    0x05AA, // (-331/10)dB = 0.022131 * amplitude
    0x05BB, // (-330/10)dB = 0.022387 * amplitude
    0x05CC, // (-329/10)dB = 0.022646 * amplitude
    0x05DD, // (-328/10)dB = 0.022909 * amplitude
    0x05EE, // (-327/10)dB = 0.023174 * amplitude
    0x0600, // (-326/10)dB = 0.023442 * amplitude
    0x0612, // (-325/10)dB = 0.023714 * amplitude
    0x0624, // (-324/10)dB = 0.023988 * amplitude
    0x0636, // (-323/10)dB = 0.024266 * amplitude
    0x0648, // (-322/10)dB = 0.024547 * amplitude
    0x065B, // (-321/10)dB = 0.024831 * amplitude
    0x066E, // (-320/10)dB = 0.025119 * amplitude
    0x0681, // (-319/10)dB = 0.025410 * amplitude
    0x0694, // (-318/10)dB = 0.025704 * amplitude
    0x06A8, // (-317/10)dB = 0.026002 * amplitude
    0x06BB, // (-316/10)dB = 0.026303 * amplitude
    0x06CF, // (-315/10)dB = 0.026607 * amplitude
    0x06E3, // (-314/10)dB = 0.026915 * amplitude
    0x06F8, // (-313/10)dB = 0.027227 * amplitude
    0x070D, // (-312/10)dB = 0.027542 * amplitude
    0x0721, // (-311/10)dB = 0.027861 * amplitude
    0x0737, // (-310/10)dB = 0.028184 * amplitude
    0x074C, // (-309/10)dB = 0.028510 * amplitude
    0x0762, // (-308/10)dB = 0.028840 * amplitude
    0x0777, // (-307/10)dB = 0.029174 * amplitude
    0x078E, // (-306/10)dB = 0.029512 * amplitude
    0x07A4, // (-305/10)dB = 0.029854 * amplitude
    0x07BB, // (-304/10)dB = 0.030200 * amplitude
    0x07D2, // (-303/10)dB = 0.030549 * amplitude
    0x07E9, // (-302/10)dB = 0.030903 * amplitude
    0x0800, // (-301/10)dB = 0.031261 * amplitude
    0x0818, // (-300/10)dB = 0.031623 * amplitude
    0x0830, // (-299/10)dB = 0.031989 * amplitude
    0x0848, // (-298/10)dB = 0.032359 * amplitude
    0x0861, // (-297/10)dB = 0.032734 * amplitude
    0x087A, // (-296/10)dB = 0.033113 * amplitude
    0x0893, // (-295/10)dB = 0.033497 * amplitude
    0x08AC, // (-294/10)dB = 0.033884 * amplitude
    0x08C6, // (-293/10)dB = 0.034277 * amplitude
    0x08E0, // (-292/10)dB = 0.034674 * amplitude
    0x08FA, // (-291/10)dB = 0.035075 * amplitude
    0x0915, // (-290/10)dB = 0.035481 * amplitude
    0x0930, // (-289/10)dB = 0.035892 * amplitude
    0x094B, // (-288/10)dB = 0.036308 * amplitude
    0x0967, // (-287/10)dB = 0.036728 * amplitude
    0x0982, // (-286/10)dB = 0.037154 * amplitude
    0x099F, // (-285/10)dB = 0.037584 * amplitude
    0x09BB, // (-284/10)dB = 0.038019 * amplitude
    0x09D8, // (-283/10)dB = 0.038459 * amplitude
    0x09F5, // (-282/10)dB = 0.038905 * amplitude
    0x0A13, // (-281/10)dB = 0.039355 * amplitude
    0x0A31, // (-280/10)dB = 0.039811 * amplitude
    0x0A4F, // (-279/10)dB = 0.040272 * amplitude
    0x0A6D, // (-278/10)dB = 0.040738 * amplitude
    0x0A8C, // (-277/10)dB = 0.041210 * amplitude
    0x0AAB, // (-276/10)dB = 0.041687 * amplitude
    0x0ACB, // (-275/10)dB = 0.042170 * amplitude
    0x0AEB, // (-274/10)dB = 0.042658 * amplitude
    0x0B0C, // (-273/10)dB = 0.043152 * amplitude
    0x0B2C, // (-272/10)dB = 0.043652 * amplitude
    0x0B4D, // (-271/10)dB = 0.044157 * amplitude
    0x0B6F, // (-270/10)dB = 0.044668 * amplitude
    0x0B91, // (-269/10)dB = 0.045186 * amplitude
    0x0BB3, // (-268/10)dB = 0.045709 * amplitude
    0x0BD6, // (-267/10)dB = 0.046238 * amplitude
    0x0BF9, // (-266/10)dB = 0.046774 * amplitude
    0x0C1C, // (-265/10)dB = 0.047315 * amplitude
    0x0C40, // (-264/10)dB = 0.047863 * amplitude
    0x0C65, // (-263/10)dB = 0.048417 * amplitude
    0x0C89, // (-262/10)dB = 0.048978 * amplitude
    0x0CAE, // (-261/10)dB = 0.049545 * amplitude
    0x0CD4, // (-260/10)dB = 0.050119 * amplitude
    0x0CFA, // (-259/10)dB = 0.050699 * amplitude
    0x0D21, // (-258/10)dB = 0.051286 * amplitude
    0x0D48, // (-257/10)dB = 0.051880 * amplitude
    0x0D6F, // (-256/10)dB = 0.052481 * amplitude
    0x0D97, // (-255/10)dB = 0.053088 * amplitude
    0x0DBF, // (-254/10)dB = 0.053703 * amplitude
    0x0DE8, // (-253/10)dB = 0.054325 * amplitude
    0x0E11, // (-252/10)dB = 0.054954 * amplitude
    0x0E3B, // (-251/10)dB = 0.055590 * amplitude
    0x0E65, // (-250/10)dB = 0.056234 * amplitude
    0x0E90, // (-249/10)dB = 0.056885 * amplitude
    0x0EBB, // (-248/10)dB = 0.057544 * amplitude
    0x0EE6, // (-247/10)dB = 0.058210 * amplitude
    0x0F13, // (-246/10)dB = 0.058884 * amplitude
    0x0F3F, // (-245/10)dB = 0.059566 * amplitude
    0x0F6C, // (-244/10)dB = 0.060256 * amplitude
    0x0F9A, // (-243/10)dB = 0.060954 * amplitude
    0x0FC8, // (-242/10)dB = 0.061660 * amplitude
    0x0FF7, // (-241/10)dB = 0.062373 * amplitude
    0x1027, // (-240/10)dB = 0.063096 * amplitude
    0x1056, // (-239/10)dB = 0.063826 * amplitude
    0x1087, // (-238/10)dB = 0.064565 * amplitude
    0x10B8, // (-237/10)dB = 0.065313 * amplitude
    0x10E9, // (-236/10)dB = 0.066069 * amplitude
    0x111C, // (-235/10)dB = 0.066834 * amplitude
    0x114E, // (-234/10)dB = 0.067608 * amplitude
    0x1182, // (-233/10)dB = 0.068391 * amplitude
    0x11B5, // (-232/10)dB = 0.069183 * amplitude
    0x11EA, // (-231/10)dB = 0.069984 * amplitude
    0x121F, // (-230/10)dB = 0.070795 * amplitude
    0x1255, // (-229/10)dB = 0.071614 * amplitude
    0x128B, // (-228/10)dB = 0.072444 * amplitude
    0x12C2, // (-227/10)dB = 0.073282 * amplitude
    0x12FA, // (-226/10)dB = 0.074131 * amplitude
    0x1332, // (-225/10)dB = 0.074989 * amplitude
    0x136B, // (-224/10)dB = 0.075858 * amplitude
    0x13A4, // (-223/10)dB = 0.076736 * amplitude
    0x13DF, // (-222/10)dB = 0.077625 * amplitude
    0x141A, // (-221/10)dB = 0.078524 * amplitude
    0x1455, // (-220/10)dB = 0.079433 * amplitude
    0x1491, // (-219/10)dB = 0.080353 * amplitude
    0x14CE, // (-218/10)dB = 0.081283 * amplitude
    0x150C, // (-217/10)dB = 0.082224 * amplitude
    0x154B, // (-216/10)dB = 0.083176 * amplitude
    0x158A, // (-215/10)dB = 0.084140 * amplitude
    0x15CA, // (-214/10)dB = 0.085114 * amplitude
    0x160A, // (-213/10)dB = 0.086099 * amplitude
    0x164B, // (-212/10)dB = 0.087096 * amplitude
    0x168E, // (-211/10)dB = 0.088105 * amplitude
    0x16D0, // (-210/10)dB = 0.089125 * amplitude
    0x1714, // (-209/10)dB = 0.090157 * amplitude
    0x1758, // (-208/10)dB = 0.091201 * amplitude
    0x179E, // (-207/10)dB = 0.092257 * amplitude
    0x17E4, // (-206/10)dB = 0.093325 * amplitude
    0x182A, // (-205/10)dB = 0.094406 * amplitude
    0x1872, // (-204/10)dB = 0.095499 * amplitude
    0x18BB, // (-203/10)dB = 0.096605 * amplitude
    0x1904, // (-202/10)dB = 0.097724 * amplitude
    0x194E, // (-201/10)dB = 0.098855 * amplitude
    0x1999, // (-200/10)dB = 0.100000 * amplitude
    0x19E5, // (-199/10)dB = 0.101158 * amplitude
    0x1A32, // (-198/10)dB = 0.102329 * amplitude
    0x1A7F, // (-197/10)dB = 0.103514 * amplitude
    0x1ACE, // (-196/10)dB = 0.104713 * amplitude
    0x1B1D, // (-195/10)dB = 0.105925 * amplitude
    0x1B6E, // (-194/10)dB = 0.107152 * amplitude
    0x1BBF, // (-193/10)dB = 0.108393 * amplitude
    0x1C11, // (-192/10)dB = 0.109648 * amplitude
    0x1C65, // (-191/10)dB = 0.110917 * amplitude
    0x1CB9, // (-190/10)dB = 0.112202 * amplitude
    0x1D0E, // (-189/10)dB = 0.113501 * amplitude
    0x1D64, // (-188/10)dB = 0.114815 * amplitude
    0x1DBB, // (-187/10)dB = 0.116145 * amplitude
    0x1E13, // (-186/10)dB = 0.117490 * amplitude
    0x1E6C, // (-185/10)dB = 0.118850 * amplitude
    0x1EC7, // (-184/10)dB = 0.120226 * amplitude
    0x1F22, // (-183/10)dB = 0.121619 * amplitude
    0x1F7E, // (-182/10)dB = 0.123027 * amplitude
    0x1FDC, // (-181/10)dB = 0.124451 * amplitude
    0x203A, // (-180/10)dB = 0.125893 * amplitude
    0x209A, // (-179/10)dB = 0.127350 * amplitude
    0x20FA, // (-178/10)dB = 0.128825 * amplitude
    0x215C, // (-177/10)dB = 0.130317 * amplitude
    0x21BF, // (-176/10)dB = 0.131826 * amplitude
    0x2223, // (-175/10)dB = 0.133352 * amplitude
    0x2288, // (-174/10)dB = 0.134896 * amplitude
    0x22EE, // (-173/10)dB = 0.136458 * amplitude
    0x2356, // (-172/10)dB = 0.138038 * amplitude
    0x23BF, // (-171/10)dB = 0.139637 * amplitude
    0x2429, // (-170/10)dB = 0.141254 * amplitude
    0x2494, // (-169/10)dB = 0.142889 * amplitude
    0x2500, // (-168/10)dB = 0.144544 * amplitude
    0x256E, // (-167/10)dB = 0.146218 * amplitude
    0x25DD, // (-166/10)dB = 0.147911 * amplitude
    0x264D, // (-165/10)dB = 0.149624 * amplitude
    0x26BF, // (-164/10)dB = 0.151356 * amplitude
    0x2732, // (-163/10)dB = 0.153109 * amplitude
    0x27A6, // (-162/10)dB = 0.154882 * amplitude
    0x281B, // (-161/10)dB = 0.156675 * amplitude
    0x2892, // (-160/10)dB = 0.158489 * amplitude
    0x290B, // (-159/10)dB = 0.160325 * amplitude
    0x2984, // (-158/10)dB = 0.162181 * amplitude
    0x29FF, // (-157/10)dB = 0.164059 * amplitude
    0x2A7C, // (-156/10)dB = 0.165959 * amplitude
    0x2AFA, // (-155/10)dB = 0.167880 * amplitude
    0x2B79, // (-154/10)dB = 0.169824 * amplitude
    0x2BFA, // (-153/10)dB = 0.171791 * amplitude
    0x2C7C, // (-152/10)dB = 0.173780 * amplitude
    0x2D00, // (-151/10)dB = 0.175792 * amplitude
    0x2D86, // (-150/10)dB = 0.177828 * amplitude
    0x2E0D, // (-149/10)dB = 0.179887 * amplitude
    0x2E95, // (-148/10)dB = 0.181970 * amplitude
    0x2F1F, // (-147/10)dB = 0.184077 * amplitude
    0x2FAB, // (-146/10)dB = 0.186209 * amplitude
    0x3038, // (-145/10)dB = 0.188365 * amplitude
    0x30C7, // (-144/10)dB = 0.190546 * amplitude
    0x3158, // (-143/10)dB = 0.192752 * amplitude
    0x31EA, // (-142/10)dB = 0.194984 * amplitude
    0x327E, // (-141/10)dB = 0.197242 * amplitude
    0x3314, // (-140/10)dB = 0.199526 * amplitude
    0x33AB, // (-139/10)dB = 0.201837 * amplitude
    0x3444, // (-138/10)dB = 0.204174 * amplitude
    0x34DF, // (-137/10)dB = 0.206538 * amplitude
    0x357C, // (-136/10)dB = 0.208930 * amplitude
    0x361A, // (-135/10)dB = 0.211349 * amplitude
    0x36BB, // (-134/10)dB = 0.213796 * amplitude
    0x375D, // (-133/10)dB = 0.216272 * amplitude
    0x3801, // (-132/10)dB = 0.218776 * amplitude
    0x38A7, // (-131/10)dB = 0.221309 * amplitude
    0x394F, // (-130/10)dB = 0.223872 * amplitude
    0x39F9, // (-129/10)dB = 0.226464 * amplitude
    0x3AA5, // (-128/10)dB = 0.229087 * amplitude
    0x3B53, // (-127/10)dB = 0.231739 * amplitude
    0x3C03, // (-126/10)dB = 0.234423 * amplitude
    0x3CB5, // (-125/10)dB = 0.237137 * amplitude
    0x3D68, // (-124/10)dB = 0.239883 * amplitude
    0x3E1F, // (-123/10)dB = 0.242661 * amplitude
    0x3ED7, // (-122/10)dB = 0.245471 * amplitude
    0x3F91, // (-121/10)dB = 0.248313 * amplitude
    0x404D, // (-120/10)dB = 0.251189 * amplitude
    0x410C, // (-119/10)dB = 0.254097 * amplitude
    0x41CD, // (-118/10)dB = 0.257040 * amplitude
    0x4290, // (-117/10)dB = 0.260016 * amplitude
    0x4355, // (-116/10)dB = 0.263027 * amplitude
    0x441D, // (-115/10)dB = 0.266073 * amplitude
    0x44E7, // (-114/10)dB = 0.269153 * amplitude
    0x45B3, // (-113/10)dB = 0.272270 * amplitude
    0x4682, // (-112/10)dB = 0.275423 * amplitude
    0x4753, // (-111/10)dB = 0.278612 * amplitude
    0x4826, // (-110/10)dB = 0.281838 * amplitude
    0x48FC, // (-109/10)dB = 0.285102 * amplitude
    0x49D4, // (-108/10)dB = 0.288403 * amplitude
    0x4AAF, // (-107/10)dB = 0.291743 * amplitude
    0x4B8D, // (-106/10)dB = 0.295121 * amplitude
    0x4C6D, // (-105/10)dB = 0.298538 * amplitude
    0x4D4F, // (-104/10)dB = 0.301995 * amplitude
    0x4E34, // (-103/10)dB = 0.305492 * amplitude
    0x4F1C, // (-102/10)dB = 0.309030 * amplitude
    0x5007, // (-101/10)dB = 0.312608 * amplitude
    0x50F4, // (-100/10)dB = 0.316228 * amplitude
    0x51E4, // (-99/10)dB = 0.319890 * amplitude
    0x52D7, // (-98/10)dB = 0.323594 * amplitude
    0x53CC, // (-97/10)dB = 0.327341 * amplitude
    0x54C5, // (-96/10)dB = 0.331131 * amplitude
    0x55C0, // (-95/10)dB = 0.334965 * amplitude
    0x56BE, // (-94/10)dB = 0.338844 * amplitude
    0x57BF, // (-93/10)dB = 0.342768 * amplitude
    0x58C3, // (-92/10)dB = 0.346737 * amplitude
    0x59CA, // (-91/10)dB = 0.350752 * amplitude
    0x5AD5, // (-90/10)dB = 0.354813 * amplitude
    0x5BE2, // (-89/10)dB = 0.358922 * amplitude
    0x5CF2, // (-88/10)dB = 0.363078 * amplitude
    0x5E06, // (-87/10)dB = 0.367282 * amplitude
    0x5F1C, // (-86/10)dB = 0.371535 * amplitude
    0x6036, // (-85/10)dB = 0.375837 * amplitude
    0x6154, // (-84/10)dB = 0.380189 * amplitude
    0x6274, // (-83/10)dB = 0.384592 * amplitude
    0x6398, // (-82/10)dB = 0.389045 * amplitude
    0x64BF, // (-81/10)dB = 0.393550 * amplitude
    0x65EA, // (-80/10)dB = 0.398107 * amplitude
    0x6718, // (-79/10)dB = 0.402717 * amplitude
    0x684A, // (-78/10)dB = 0.407380 * amplitude
    0x697F, // (-77/10)dB = 0.412098 * amplitude
    0x6AB7, // (-76/10)dB = 0.416869 * amplitude
    0x6BF4, // (-75/10)dB = 0.421697 * amplitude
    0x6D34, // (-74/10)dB = 0.426580 * amplitude
    0x6E78, // (-73/10)dB = 0.431519 * amplitude
    0x6FBF, // (-72/10)dB = 0.436516 * amplitude
    0x710A, // (-71/10)dB = 0.441570 * amplitude
    0x7259, // (-70/10)dB = 0.446684 * amplitude
    0x73AC, // (-69/10)dB = 0.451856 * amplitude
    0x7503, // (-68/10)dB = 0.457088 * amplitude
    0x765E, // (-67/10)dB = 0.462381 * amplitude
    0x77BD, // (-66/10)dB = 0.467735 * amplitude
    0x7920, // (-65/10)dB = 0.473151 * amplitude
    0x7A87, // (-64/10)dB = 0.478630 * amplitude
    0x7BF2, // (-63/10)dB = 0.484172 * amplitude
    0x7D62, // (-62/10)dB = 0.489779 * amplitude
    0x7ED5, // (-61/10)dB = 0.495450 * amplitude
    0x804D, // (-60/10)dB = 0.501187 * amplitude
    0x81CA, // (-59/10)dB = 0.506991 * amplitude
    0x834A, // (-58/10)dB = 0.512861 * amplitude
    0x84D0, // (-57/10)dB = 0.518800 * amplitude
    0x8659, // (-56/10)dB = 0.524807 * amplitude
    0x87E8, // (-55/10)dB = 0.530884 * amplitude
    0x897A, // (-54/10)dB = 0.537032 * amplitude
    0x8B12, // (-53/10)dB = 0.543250 * amplitude
    0x8CAE, // (-52/10)dB = 0.549541 * amplitude
    0x8E4F, // (-51/10)dB = 0.555904 * amplitude
    0x8FF5, // (-50/10)dB = 0.562341 * amplitude
    0x91A0, // (-49/10)dB = 0.568853 * amplitude
    0x9350, // (-48/10)dB = 0.575440 * amplitude
    0x9504, // (-47/10)dB = 0.582103 * amplitude
    0x96BE, // (-46/10)dB = 0.588844 * amplitude
    0x987D, // (-45/10)dB = 0.595662 * amplitude
    0x9A41, // (-44/10)dB = 0.602560 * amplitude
    0x9C0A, // (-43/10)dB = 0.609537 * amplitude
    0x9DD9, // (-42/10)dB = 0.616595 * amplitude
    0x9FAD, // (-41/10)dB = 0.623735 * amplitude
    0xA186, // (-40/10)dB = 0.630957 * amplitude
    0xA365, // (-39/10)dB = 0.638263 * amplitude
    0xA549, // (-38/10)dB = 0.645654 * amplitude
    0xA733, // (-37/10)dB = 0.653131 * amplitude
    0xA923, // (-36/10)dB = 0.660693 * amplitude
    0xAB18, // (-35/10)dB = 0.668344 * amplitude
    0xAD13, // (-34/10)dB = 0.676083 * amplitude
    0xAF14, // (-33/10)dB = 0.683912 * amplitude
    0xB11B, // (-32/10)dB = 0.691831 * amplitude
    0xB328, // (-31/10)dB = 0.699842 * amplitude
    0xB53B, // (-30/10)dB = 0.707946 * amplitude
    0xB755, // (-29/10)dB = 0.716143 * amplitude
    0xB974, // (-28/10)dB = 0.724436 * amplitude
    0xBB9A, // (-27/10)dB = 0.732825 * amplitude
    0xBDC6, // (-26/10)dB = 0.741310 * amplitude
    0xBFF9, // (-25/10)dB = 0.749894 * amplitude
    0xC232, // (-24/10)dB = 0.758578 * amplitude
    0xC471, // (-23/10)dB = 0.767361 * amplitude
    0xC6B8, // (-22/10)dB = 0.776247 * amplitude
    0xC905, // (-21/10)dB = 0.785236 * amplitude
    0xCB59, // (-20/10)dB = 0.794328 * amplitude
    0xCDB3, // (-19/10)dB = 0.803526 * amplitude
    0xD015, // (-18/10)dB = 0.812831 * amplitude
    0xD27E, // (-17/10)dB = 0.822243 * amplitude
    0xD4EE, // (-16/10)dB = 0.831764 * amplitude
    0xD765, // (-15/10)dB = 0.841395 * amplitude
    0xD9E4, // (-14/10)dB = 0.851138 * amplitude
    0xDC6A, // (-13/10)dB = 0.860994 * amplitude
    0xDEF7, // (-12/10)dB = 0.870964 * amplitude
    0xE18C, // (-11/10)dB = 0.881049 * amplitude
    0xE429, // (-10/10)dB = 0.891251 * amplitude
    0xE6CD, // (-9/10)dB = 0.901571 * amplitude
    0xE979, // (-8/10)dB = 0.912011 * amplitude
    0xEC2D, // (-7/10)dB = 0.922571 * amplitude
    0xEEE9, // (-6/10)dB = 0.933254 * amplitude
    0xF1AD, // (-5/10)dB = 0.944061 * amplitude
    0xF47A, // (-4/10)dB = 0.954993 * amplitude
    0xF74F, // (-3/10)dB = 0.966051 * amplitude
    0xFA2C, // (-2/10)dB = 0.977237 * amplitude
    0xFD11, // (-1/10)dB = 0.988553 * amplitude
    };

;

//
//  DBToAmpFactor
//
//  Converts lDB, specified in 100ths decibels, into a
//  linear amplification factor.  For all lDB >= 0 this
//  function returns 0xffff.  This is because our current
//  implementation of DirectSound doesn't allow amplification,
//  and users of this function often require 16-bit results
//
DWORD DBToAmpFactor( LONG lDB )
{
    DWORD dwFactor;

    // input lDB is 100ths of decibels

    // REMIND hack to make mixer code work- it only handles 16-bit factors and
    //  cannot amplify
    if (0 <= lDB) return 0x0000FFFF;
    
    //
    // bias and scale the input and check boundaries for indexing into table
    //
    lDB = (lDB+5)/10;		    // scaled to 1/10th dB units
    
    if (lDB > -1)   lDB = -1;	    // upper boundary
    if (lDB < -964) lDB = -964;	    // lower boundary

    lDB = (lDB + 964);		    // bias

    // lDB better be a good index.
    ASSERT(lDB >= 0);
    ASSERT(lDB <= sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]));
    
    dwFactor = tblDBTenthsToAmpFactor[lDB];

    return dwFactor;
}

// Note, could use DirectSound3D's fyl2x function instead of searching 
// through the table.
LONG AmpFactorToDB( DWORD dwFactor )
{
    LONG    lDB;
    int	    i;
    int	    iMax;

    // dwFactor better be valid.
    ASSERT((LONG)dwFactor >= 0);

    iMax = sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]) - 1;
    
    if (dwFactor < 0x0000FFFF) 
    {
        for (i = 0; i <= iMax - 1; i++) {
	         if (dwFactor <= tblDBTenthsToAmpFactor[i]) break;
        }
        lDB = (i - 964) * 10;
    }
    else
    {
        lDB = 0; 
    }


    return lDB;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\capteff.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        capteff.cpp
 *
 *  Content:     Implementation of CCaptureEffect and CCaptureEffectChain.
 *
 *  Description: These classes support effects processing on captured audio.
 *               They are somewhat analogous to the render effect classes in
 *               but the model for capture effects is very different: render
 *               effects are only processed by DirectX Media Objects (DMOs),
 *               in user mode, whereas capture effects are processed by KS
 *               filters, in kernel mode and/or hardware, and DMOs are only
 *               used as placeholders for the KS filters.  Hence this file
 *               is mercifully simpler than effects.cpp.
 *
 *  History:
 *
 * Date      By       Reason
 * ========  =======  ======================================================
 * 04/19/00  jstokes  Created
 * 01/30/01  duganp   Removed some vestigial DMO-handling code left over
 *                    from when this file was cloned from effects.cpp
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <uuids.h>   // For MEDIATYPE_Audio, MEDIASUBTYPE_PCM and FORMAT_WaveFormatEx


/***************************************************************************
 *
 *  CCaptureEffect::CCaptureEffect
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffect::CCaptureEffect"

CCaptureEffect::CCaptureEffect(DSCEFFECTDESC& fxDescriptor)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CCaptureEffect);

    // Initialize defaults
    ASSERT(m_pMediaObject == NULL);
    ASSERT(m_pDMOProxy == NULL);
    m_fxStatus = DSCFXR_UNALLOCATED;
    m_ksNode.NodeId = NODE_UNINITIALIZED;
    m_ksNode.CpuResources = KSAUDIO_CPU_RESOURCES_UNINITIALIZED;

    // Keep local copy of our effect description structure
    m_fxDescriptor = fxDescriptor;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CCaptureEffect::~CCaptureEffect
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffect::~CCaptureEffect"

CCaptureEffect::~CCaptureEffect(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CCaptureEffect);

    // During shutdown, if the buffer hasn't been freed, these calls can
    // cause an access violation because the DMO DLL has been unloaded.
    try
    {
        RELEASE(m_pDMOProxy);
        RELEASE(m_pMediaObject);
    }
    catch (...) {}

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CCaptureEffect::Initialize
 *
 *  Description:
 *      Create the DirectX Media Object corresponding to this effect.
 *
 *  Arguments:
 *      DMO_MEDIA_TYPE* [in]: Information (wave format, etc.) used to
 *                            initialize our contained DMO.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffect::Initialize"

HRESULT CCaptureEffect::Initialize(DMO_MEDIA_TYPE& dmoMediaType)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    hr = CoCreateInstance(m_fxDescriptor.guidDSCFXInstance, NULL, CLSCTX_INPROC_SERVER, IID_IMediaObject, (void**)&m_pMediaObject);

    if (SUCCEEDED(hr))
        hr = m_pMediaObject->QueryInterface(IID_IDirectSoundDMOProxy, (void**)&m_pDMOProxy);

    if (SUCCEEDED(hr))
        hr = m_pMediaObject->SetInputType(0, &dmoMediaType, 0);

    if (SUCCEEDED(hr))
        hr = m_pMediaObject->SetOutputType(0, &dmoMediaType, 0);

    // Save the effect creation status for future reference
    m_fxStatus = SUCCEEDED(hr)              ? DSCFXR_UNALLOCATED :
                 hr == REGDB_E_CLASSNOTREG  ? DSCFXR_UNKNOWN     :
                 DSCFXR_FAILED;

    if (FAILED(hr))
    {
        RELEASE(m_pDMOProxy);
        RELEASE(m_pMediaObject);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CCaptureEffectChain::CCaptureEffectChain
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffectChain::CCaptureEffectChain"

CCaptureEffectChain::CCaptureEffectChain(CDirectSoundCaptureBuffer* pBuffer)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CCaptureEffectChain);

    // Get our owning buffer's audio data format
    DWORD dwWfxSize = sizeof m_waveFormat;
    HRESULT hr = pBuffer->GetFormat(&m_waveFormat, &dwWfxSize);
    ASSERT(SUCCEEDED(hr));

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CCaptureEffectChain::~CCaptureEffectChain
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffectChain::~CCaptureEffectChain"

CCaptureEffectChain::~CCaptureEffectChain(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CCaptureEffectChain);

    // m_fxList's destructor takes care of releasing our CCaptureEffect objects

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CCaptureEffectChain::Initialize
 *
 *  Description:
 *      Initializes the effects chain with the effects requested.
 *
 *  Arguments:
 *      DWORD [in]: Number of effects requested
 *      LPDSCEFFECTDESC [in]: Pointer to effect description structures
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffectChain::Initialize"

HRESULT CCaptureEffectChain::Initialize(DWORD dwFxCount, LPDSCEFFECTDESC pFxDesc)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    ASSERT(dwFxCount > 0);
    CHECK_READ_PTR(pFxDesc);

    DMO_MEDIA_TYPE dmt;
    ZeroMemory(&dmt, sizeof dmt);
    dmt.majortype               = MEDIATYPE_Audio;
    dmt.subtype                 = MEDIASUBTYPE_PCM;
    dmt.bFixedSizeSamples       = TRUE;
    dmt.bTemporalCompression    = FALSE;
    dmt.lSampleSize             = m_waveFormat.wBitsPerSample == 16 ? 2 : 1;
    dmt.formattype              = FORMAT_WaveFormatEx;
    dmt.cbFormat                = sizeof(WAVEFORMATEX);
    dmt.pbFormat                = PBYTE(&m_waveFormat);

    for (DWORD i=0; i<dwFxCount && SUCCEEDED(hr); ++i)
    {
        CCaptureEffect* pEffect = NEW(CCaptureEffect(pFxDesc[i]));
        hr = HRFROMP(pEffect);

        if (SUCCEEDED(hr))
            hr = pEffect->Initialize(dmt);

        if (SUCCEEDED(hr))
            m_fxList.AddNodeToList(pEffect);

        RELEASE(pEffect);  // It's managed by m_fxList now
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CCaptureEffectChain::GetFxStatus
 *
 *  Description:
 *      Obtains the HW/SW location flags for the current effect chain.
 *
 *  Arguments:
 *      DWORD* [out]: Receives the location flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffectChain::GetFxStatus"

HRESULT CCaptureEffectChain::GetFxStatus(LPDWORD pdwResultCodes)
{
    DPF_ENTER();
    ASSERT(IS_VALID_WRITE_PTR(pdwResultCodes, GetFxCount() * sizeof(DWORD)));

    DWORD n = 0;
    for (CNode<CCaptureEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
        pdwResultCodes[n++] = pFxNode->m_data->m_fxStatus;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  CCaptureEffectChain::GetEffectInterface
 *
 *  Description:
 *      Searches the effect chain for an effect with a given COM CLSID and
 *      interface IID at a given index; returns a pointer to the interface.
 *
 *  Arguments:
 *      REFGUID [in]: CLSID required, or GUID_All_Objects for any CLSID.
 *      DWORD [in]: Index N of effect desired.  If the first argument was
 *                  GUID_All_Objects, we will return the Nth effect in the
 *                  chain; and if it was a specific CLSID, we return the
 *                  Nth effect with that CLSID.
 *      REFGUID [in]: Interface to query for from the selected effect.
 *      VOID** [out]: Receives a pointer to the requested COM interface.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffectChain::GetEffectInterface"

HRESULT CCaptureEffectChain::GetEffectInterface(REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID *ppObject)
{
    HRESULT hr = DMUS_E_NOT_FOUND;
    DPF_ENTER();

    DWORD count = 0;
    for (CNode<CCaptureEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
        if (pFxNode->m_data->m_fxDescriptor.guidDSCFXClass == guidObject)
            if (count++ == dwIndex)
                break;

    if (pFxNode)
        hr = pFxNode->m_data->m_pMediaObject->QueryInterface(iidInterface, (void**)ppObject);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CCaptureEffectChain::NeedsMicrosoftAEC
 *
 *  Description:
 *      Determines whether this effect chain contains any of the Microsoft
 *      full-duplex effects (AEC, AGC, NC), and therefore requires a
 *      sysaudio graph with MS AEC enabled.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      BOOL: TRUE if we have a Microsoft full-duplex effect.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CCaptureEffectChain::NeedsMicrosoftAEC"

BOOL CCaptureEffectChain::NeedsMicrosoftAEC()
{
    BOOL fNeedsAec = FALSE;
    DPF_ENTER();

    for (CNode<CCaptureEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode && !fNeedsAec; pFxNode = pFxNode->m_pNext)
        if (pFxNode->m_data->m_fxDescriptor.guidDSCFXInstance == GUID_DSCFX_MS_AEC ||
            pFxNode->m_data->m_fxDescriptor.guidDSCFXInstance == GUID_DSCFX_MS_NS  ||
            pFxNode->m_data->m_fxDescriptor.guidDSCFXInstance == GUID_DSCFX_MS_AGC)
            fNeedsAec = TRUE;

    DPF_LEAVE(fNeedsAec);
    return fNeedsAec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\debug.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.c
 *  Content:    Debugger helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/21/97     dereks  Created.
 *  1999-2001   duganp  Fixes, changes, enhancements
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <stdio.h>          // For sprintf(), vsprintf() and vswprintf()
#include <tchar.h>          // For _stprintf()

// This entire file is conditional on RDEBUG being defined
#ifdef RDEBUG

#ifndef DPF_LIBRARY
#define DPF_LIBRARY         "Private dsound.dll"
#endif

DEBUGINFO                   g_dinfo;
BOOL                        g_fDbgOpen;

// Variables only used when detailed DEBUG output is enabled
#ifdef DEBUG
LPCSTR                      g_pszDbgFname;
LPCSTR                      g_pszDbgFile;
UINT                        g_nDbgLine;
#endif

/***************************************************************************
 *
 *  dstrcpy
 *
 *  Description:
 *      Copies one string to another.
 *
 *  Arguments:
 *      LPSTR [in/out]: destination string.
 *      LPCSTR [in]: source string.
 *
 *  Returns:  
 *      LPSTR: pointer to the end of the string.
 *
 ***************************************************************************/

LPSTR dstrcpy(LPSTR dst, LPCSTR src)
{
    while (*dst++ = *src++);
    return dst-1;
}


/***************************************************************************
 *
 *  dopen
 *
 *  Description:
 *      Initializes the debugger.
 *
 *  Arguments:
 *      DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA * [in]: optional debug 
 *                                                       information.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void dopen(DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA *pData)
{
    HKEY                    hkey;
    HRESULT                 hr;

    // Free any current settings
    dclose();

    // Initialize data
    if (pData)
        CopyMemory(&g_dinfo.Data, pData, sizeof(*pData));
    else
    {
        ZeroMemory(&g_dinfo, sizeof(g_dinfo));
        g_dinfo.Data.Flags = DIRECTSOUNDDEBUG_DPFINFOF_DEFAULT;
        g_dinfo.Data.DpfLevel = DIRECTSOUNDDEBUG_DPFLEVEL_DEFAULT;
        g_dinfo.Data.BreakLevel = DIRECTSOUNDDEBUG_BREAKLEVEL_DEFAULT;
    }

    // Get registry data
    if (pData)
        hr = RhRegOpenPath(HKEY_CURRENT_USER, &hkey, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND | REGOPENPATH_ALLOWCREATE, 1, REGSTR_DEBUG);
    else
        hr = RhRegOpenPath(HKEY_CURRENT_USER, &hkey, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, REGSTR_DEBUG);

    if (SUCCEEDED(hr))
    {
        if (pData)
        {
            RhRegSetBinaryValue(hkey, REGSTR_FLAGS, &g_dinfo.Data.Flags, sizeof(g_dinfo.Data.Flags));
            RhRegSetBinaryValue(hkey, REGSTR_DPFLEVEL, &g_dinfo.Data.DpfLevel, sizeof(g_dinfo.Data.DpfLevel));
            RhRegSetBinaryValue(hkey, REGSTR_BREAKLEVEL, &g_dinfo.Data.BreakLevel, sizeof(g_dinfo.Data.BreakLevel));
            RhRegSetStringValue(hkey, REGSTR_LOGFILE, g_dinfo.Data.LogFile);
        }
        else
        {
            RhRegGetBinaryValue(hkey, REGSTR_FLAGS, &g_dinfo.Data.Flags, sizeof(g_dinfo.Data.Flags));
            RhRegGetBinaryValue(hkey, REGSTR_DPFLEVEL, &g_dinfo.Data.DpfLevel, sizeof(g_dinfo.Data.DpfLevel));
            RhRegGetBinaryValue(hkey, REGSTR_BREAKLEVEL, &g_dinfo.Data.BreakLevel, sizeof(g_dinfo.Data.BreakLevel));
            RhRegGetStringValue(hkey, REGSTR_LOGFILE, g_dinfo.Data.LogFile, sizeof(g_dinfo.Data.LogFile));
            if (g_dinfo.Data.DpfLevel < g_dinfo.Data.BreakLevel)
                g_dinfo.Data.DpfLevel = g_dinfo.Data.BreakLevel;
        }
        RhRegCloseKey(&hkey);
    }

#ifdef DEBUG

    // Open the log file
    if (g_dinfo.Data.LogFile[0])
    {
        DWORD dwFlags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN;

        // It's only practical to write every trace message direct to disk
        // at debug levels lower than DPFLVL_API:
        if (NEWDPFLVL(g_dinfo.Data.DpfLevel) < DPFLVL_API)
            dwFlags |= FILE_FLAG_WRITE_THROUGH;
            
        g_dinfo.hLogFile = CreateFile(g_dinfo.Data.LogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, dwFlags, NULL);
    }
    if (IsValidHandleValue(g_dinfo.hLogFile))
        MakeHandleGlobal(&g_dinfo.hLogFile);

#endif // DEBUG

    g_fDbgOpen = TRUE;
}


/***************************************************************************
 *
 *  dclose
 *
 *  Description:
 *      Uninitializes the debugger.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void dclose(void)
{
    if (!g_fDbgOpen)
        return;
    
#ifdef DEBUG

    // Close the log file
    CLOSE_HANDLE(g_dinfo.hLogFile);

#endif // DEBUG

    g_fDbgOpen = FALSE;
}


/***************************************************************************
 *
 *  dprintf
 *
 *  Description:
 *      Writes a string to the debugger.
 *
 *  Arguments:
 *      DWORD [in]: debug level.  String will only print if this level is
 *                  less than or equal to the global level.
 *      LPCSTR [in]: string.
 *      ... [in]: optional string modifiers.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void dprintf(DWORD dwLevel, LPCSTR pszFormat, ...)
{
    const BOOL              fNewDpf = MAKEBOOL(dwLevel & ~DPFLVLMASK);
    CHAR                    szMessage[MAX_DPF_MESSAGE];
    LPSTR                   pszString = szMessage;
    DWORD                   dwWritten;
    va_list                 va;
    
    // Bail out early if we have nothing to do
    if (OLDDPFLVL(dwLevel) > g_dinfo.Data.DpfLevel)
        return;

    // Build up the trace message; start with the library name
    pszString = dstrcpy(pszString, DPF_LIBRARY ": ");

#ifdef DEBUG

    // Add process and thread ID
    if (g_dinfo.Data.Flags & DIRECTSOUNDDEBUG_DPFINFOF_PRINTPROCESSTHREADID)
        pszString += sprintf(pszString, "PID=%lx TID=%lx: ", GetCurrentProcessId(), GetCurrentThreadId());

    // Add the source file and line number
    if (g_dinfo.Data.Flags & DIRECTSOUNDDEBUG_DPFINFOF_PRINTFILELINE)
        pszString += sprintf(pszString, "%s:%lu: ", g_pszDbgFile, g_nDbgLine);

    // Add the function name
    if (fNewDpf && (g_dinfo.Data.Flags & DIRECTSOUNDDEBUG_DPFINFOF_PRINTFUNCTIONNAME) && dwLevel != DPFLVL_BUSYAPI)
        pszString += sprintf(pszString, "%s: ", g_pszDbgFname);

#endif // DEBUG

    // Add the type of message this is (i.e. error or warning), but only if the
    // dpf level was specified in terms of DPFLVL_*.  This will prevent confusion
    // in old code that uses raw numbers instead of DPFLVL macros.
    switch (dwLevel)
    {
        case DPFLVL_ERROR:
            pszString = dstrcpy(pszString, "Error: ");
            break;

        case DPFLVL_WARNING:
            pszString = dstrcpy(pszString, "Warning: ");
            break;

        case DPFLVL_API:
            pszString = dstrcpy(pszString, "API call: ");
            break;
    }

    // Format the string
    va_start(va, pszFormat);
#ifdef UNICODE
    {
        TCHAR szTcharMsg[MAX_DPF_MESSAGE];
        TCHAR szTcharFmt[MAX_DPF_MESSAGE];
        AnsiToTchar(szMessage, szTcharMsg, MAX_DPF_MESSAGE);
        AnsiToTchar(pszFormat, szTcharFmt, MAX_DPF_MESSAGE);
        vswprintf(szTcharMsg + lstrlen(szTcharMsg), szTcharFmt, va);
        TcharToAnsi(szTcharMsg, szMessage, MAX_DPF_MESSAGE);
    }
#else
        vsprintf(pszString, pszFormat, va);
#endif
    va_end(va);
    strcat(pszString, CRLF);

    // Output to the debugger
    if (!(g_dinfo.Data.Flags & DIRECTSOUNDDEBUG_DPFINFOF_LOGTOFILEONLY))
        OutputDebugStringA(szMessage);

#ifdef DEBUG
    // Write to the log file
    if (IsValidHandleValue(g_dinfo.hLogFile))
        WriteFile(g_dinfo.hLogFile, szMessage, strlen(szMessage), &dwWritten, NULL);      
#endif // DEBUG

    // Break into the debugger if required
    if (fNewDpf && g_dinfo.Data.BreakLevel && OLDDPFLVL(dwLevel) <= g_dinfo.Data.BreakLevel)
        BREAK();
}


/***************************************************************************
 *
 *  StateName
 *
 *  Description:
 *      Translates a combination of VAD_BUFFERSTATE flags into a string.
 *
 *  Arguments:
 *      DWORD [in]: Combination of VAD_BUFFERSTATE flags.
 *
 *  Returns:  
 *      PTSTR [out]: Pointer to static string containing the result.
 *
 ***************************************************************************/

PTSTR StateName(DWORD dwState)
{
    static TCHAR szState[100];

    if (dwState == VAD_BUFFERSTATE_STOPPED)
    {
        _stprintf(szState, TEXT("STOPPED"));
    }
    else
    {
        _stprintf(szState, TEXT("%s%s%s%s%s%s%s"),
                (dwState & VAD_BUFFERSTATE_STARTED) ? TEXT("STARTED ") : TEXT(""),
                (dwState & VAD_BUFFERSTATE_LOOPING) ? TEXT("LOOPING ") : TEXT(""),
                (dwState & VAD_BUFFERSTATE_WHENIDLE) ? TEXT("WHENIDLE ") : TEXT(""),
                (dwState & VAD_BUFFERSTATE_INFOCUS) ? TEXT("INFOCUS ") : TEXT(""),
                (dwState & VAD_BUFFERSTATE_OUTOFFOCUS) ? TEXT("OUTOFFOCUS ") : TEXT(""),
                (dwState & VAD_BUFFERSTATE_LOSTCONSOLE) ? TEXT("LOSTCONSOLE ") : TEXT(""),
                (dwState & VAD_BUFFERSTATE_SUSPEND) ? TEXT("SUSPEND") : TEXT(""));
    }

    return szState;
}

#endif // RDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dllmain.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:    DLL entry point
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#define INITGUID

#include <verinfo.h>
#include "dsoundi.h"

#ifndef NOVXD
#ifndef VER_PRODUCTVERSION_DW
#define VER_PRODUCTVERSION_DW MAKELONG(MAKEWORD(MANVERSION, MANREVISION), MAKEWORD(MANMINORREV, BUILD_NUMBER))
#endif // VER_PRODUCTVERSION_DW
#endif // NOVXD

#ifdef SHARED
#include <dbt.h>  // For DBT_DEVNODES_CHANGED
#endif // SHARED

/***************************************************************************
 *
 * Global variables
 *
 ***************************************************************************/

// DLL reference count
ULONG                       g_ulDllRefCount;

// The DirectSound Administrator
CDirectSoundAdministrator*  g_pDsAdmin;

// The virtual audio device manager
CVirtualAudioDeviceManager* g_pVadMgr;

#ifndef NOVXD

// DSOUND.VXD handle
HANDLE                      g_hDsVxd;

#endif // NOVXD

// The mixer mutex
LONG                        lMixerMutexMutex;
LONG                        lDummyMixerMutex;
PLONG                       gpMixerMutex;
int                         cMixerEntry;
DWORD                       tidMixerOwner;

// These DLL globals are used by DDHELP and therefore have to be a specific
// name (I hate globals without a g_, but what are you going to do?)
HINSTANCE                   hModule;
DWORD                       dwHelperPid;

// Prototypes
BOOL DllProcessAttach(HINSTANCE, DWORD);
void DllProcessDetach(DWORD);


/***************************************************************************
 *
 *  EnterDllMainMutex
 *
 *  Description:
 *      Takes the DllMain mutex.
 *
 *  Arguments:
 *      DWORD [in]: current process id.
 *
 *  Returns:  
 *      HANDLE: the DllMain mutex.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "EnterDllMainMutex"

HANDLE EnterDllMainMutex(DWORD dwProcessId)
{
#ifdef SHARED
    const LPCTSTR           pszMutex            = TEXT("DirectSound DllMain mutex (shared)");
#else // SHARED
    const LPCTSTR           pszMutexTemplate    = TEXT("DirectSound DllMain mutex (0x%8.8lX)");
    TCHAR                   szMutex[0x100];
    LPTSTR                  pszMutex;
#endif // SHARED

    HANDLE                  hMutex;
    DWORD                   dwWait;

    DPF_ENTER();

#ifndef SHARED
    wsprintf(szMutex, pszMutexTemplate, dwProcessId);
    pszMutex = szMutex;
#endif // SHARED

    hMutex = CreateMutex(NULL, FALSE, pszMutex);
    ASSERT(IsValidHandleValue(hMutex));

    dwWait = WaitObject(INFINITE, hMutex);
    ASSERT(WAIT_OBJECT_0 == dwWait);

    DPF_LEAVE(hMutex);
    
    return hMutex;
}


/***************************************************************************
 *
 *  LeaveDllMainMutex
 *
 *  Description:
 *      Releases the DllMain mutex.
 *
 *  Arguments:
 *      HANDLE [in]: the DllMain mutex.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "LeaveDllMainMutex"

void LeaveDllMainMutex(HANDLE hMutex)
{
    DPF_ENTER();
    
    ASSERT(IsValidHandleValue(hMutex));

    ReleaseMutex(hMutex);
    CLOSE_HANDLE(hMutex);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CleanupAfterProcess
 *
 *  Description:
 *      Cleans up behind a process that's going away.
 *
 *  Arguments:
 *      DWORD [in]: process ID to clean up after.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CleanupAfterProcess"

void CleanupAfterProcess(DWORD dwProcessId)
{
    DWORD dwCount = 0;
    
    ENTER_DLL_MUTEX();
    DPF_ENTER();
    
    DPF(DPFLVL_INFO, "Cleaning up behind process 0x%8.8lX", dwProcessId);
    
    if(g_pDsAdmin)
    {
        dwCount = g_pDsAdmin->FreeOrphanedObjects(dwProcessId, TRUE);
    }

    if(dwCount)
    {
        RPF(DPFLVL_ERROR, "Process 0x%8.8lX leaked %lu top-level objects", dwProcessId, dwCount);
    }

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  DdhelpProcessNotifyProc
 *
 *  Description:
 *      Callback procedure for DDHELP notifications.
 *
 *  Arguments:
 *      LPDDHELPDATA [in]: data.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#ifdef SHARED

#undef DPF_FNAME
#define DPF_FNAME "DdhelpProcessNotifyProc"

BOOL FAR PASCAL DdhelpProcessNotifyProc(LPDDHELPDATA pData)
{
    DPF_ENTER();

    // Detach this process from the DLL
    DllProcessDetach(pData->pid);

    DPF_LEAVE(TRUE);
    
    return TRUE;
}

#endif // SHARED


/***************************************************************************
 *
 *  DdhelpDeviceChangeNotifyProc
 *
 *  Description:
 *      Callback procedure for DDHELP notifications.
 *
 *  Arguments:
 *      UINT [in]: device change event.
 *      DWORD [in]: device change data.
 *
 *  Returns:  
 *      BOOL: TRUE to allow the device change.
 *
 ***************************************************************************/

#ifdef SHARED

#undef DPF_FNAME
#define DPF_FNAME "DdhelpDeviceChangeNotifyProc"

BOOL FAR PASCAL DdhelpDeviceChangeNotifyProc(UINT uEvent, DWORD dwData)
{
    ENTER_DLL_MUTEX();
    DPF_ENTER();

    DPF(DPFLVL_MOREINFO, "uEvent = %lu", uEvent);

    // Reset the static device list
    if(uEvent == DBT_DEVNODES_CHANGED && g_pVadMgr)
    {
        DPF(DPFLVL_INFO, "Resetting static driver list");
        g_pVadMgr->FreeStaticDriverList();
    }
    
    DPF_LEAVE(TRUE);
    LEAVE_DLL_MUTEX();
    return TRUE;
}

#endif // SHARED


/***************************************************************************
 *
 *  PinLibrary
 *
 *  Description:
 *      Adds a reference to the DLL so that it remains loaded even after
 *      freed by the owning process.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PinLibrary"

BOOL PinLibrary(HINSTANCE hInst)
{
#ifdef SHARED
    static TCHAR            szDllName[MAX_PATH];
#else // SHARED
    TCHAR                   szDllName[MAX_PATH];
#endif // SHARED

    BOOL                    fSuccess;
    HINSTANCE               hPinInst;

    DPF_ENTER();
    
    // Get our DLL path
    fSuccess = GetModuleFileName(hInst, szDllName, NUMELMS(szDllName));

    if(!fSuccess)
    {
        DPF(DPFLVL_ERROR, "Unable to get module name");
    }

    // Add a reference to the library
    if(fSuccess)
    {
#ifdef SHARED
        hPinInst = HelperLoadLibrary(szDllName);
#else // SHARED
        hPinInst = LoadLibrary(szDllName);
#endif // SHARED

        if(!hPinInst)
        {
            DPF(DPFLVL_ERROR, "Unable to load %s", szDllName);
            fSuccess = FALSE;
        }
    }

    DPF_LEAVE(fSuccess);
    
    return fSuccess;
}


/***************************************************************************
 *
 *  DllFirstProcessAttach
 *
 *  Description:
 *      Handles first process attach for DllMain.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *      DWORD [in]: process id.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllFirstProcessAttach"

BOOL DllFirstProcessAttach(HINSTANCE hInst, DWORD dwProcessId)
{
#ifndef NOVXD
    DWORD                   dwVxdVersion;
#endif // NOVXD

    BOOL                    fSuccess;
    HRESULT                 hr;

    DPF_ENTER();
    
    // We don't need thread calls
    DisableThreadLibraryCalls(hInst);
    
    // Save the module instance handle
    hModule = hInst;

    // Initialize the memory manager
    fSuccess = MemInit();

    // Initialize the debugger
    if(fSuccess)
    {
        DPFINIT();
    }

    // Create the global lock object
    if(fSuccess)
    {
        g_pDllLock = NEW(CPreferredLock);
        fSuccess = MAKEBOOL(g_pDllLock);
    }

    if(fSuccess)
    {
        hr = g_pDllLock->Initialize();
        fSuccess = SUCCEEDED(hr);
    }

#ifndef NOVXD

    // Open DSOUND.VXD
    if(fSuccess)
    {
        hr = VxdOpen();
        
        if(SUCCEEDED(hr))
        {
            hr = VxdInitialize();
            
            if(FAILED(hr))
            {
                VxdClose();
            }
        }
    }

    // Make sure the VxD and DLL match
    if(fSuccess && g_hDsVxd)
    {
        if(VER_PRODUCTVERSION_DW != (dwVxdVersion = VxdGetInternalVersionNumber()))
        {
            RPF(DPFLVL_ERROR, "DSOUND.DLL and DSOUND.VXD are mismatched.  DSOUND.DLL version: 0x%8.8lX.  DSOUND.VXD version: 0x%8.8lX", VER_PRODUCTVERSION_DW, dwVxdVersion);
            VxdShutdown();
            VxdClose();
        }
    }
    
    // Set up ptr to the kernel-mode mixer mutex
    if(fSuccess && g_hDsVxd)
    {
        gpMixerMutex = VxdGetMixerMutexPtr();
    }

#endif // NOVXD
        
    if(fSuccess && !gpMixerMutex)
    {
        gpMixerMutex = &lDummyMixerMutex;
    }

#ifdef SHARED

    // Load DDHELP
    if(fSuccess)
    {
        CreateHelperProcess(&dwHelperPid);

        if(!dwHelperPid)
        {
            DPF(DPFLVL_ERROR, "Unable to create helper process");
            fSuccess = FALSE;
        }
    }

    if(fSuccess)
    {
        if(!WaitForHelperStartup())
        {
            DPF(DPFLVL_ERROR, "WaitForHelperStartup failed");
            fSuccess = FALSE;
        }
    }

#else // SHARED

    if(fSuccess)
    {
        dwHelperPid = dwProcessId;
    }

#endif // SHARED

    // Create the virtual audio device manager
    if(fSuccess)
    {
        g_pVadMgr = NEW(CVirtualAudioDeviceManager);
        fSuccess = MAKEBOOL(g_pVadMgr);
    }
    
    // Create the DirectSound Administrator
    if(fSuccess)
    {
        g_pDsAdmin = NEW(CDirectSoundAdministrator);
        fSuccess = MAKEBOOL(g_pDsAdmin);
    }

#ifdef SHARED

    // Ask DDHELP to notify us of any device changes
    if(fSuccess)
    {
        HelperAddDeviceChangeNotify(DdhelpDeviceChangeNotifyProc);
    }

#endif // SHARED

    // Determine the WDM version based on platform
    if (fSuccess)
    {
        KsQueryWdmVersion();
    }    

    // Pin the DLL in memory.  This is odd behavior for any DLL, but it may be
    // risky to change it, for appcompat reasons.  NOTE: this must be the last
    // call made by this function, so that if any of the previous calls fails,
    // we don't pin an unitialized dsound.dll in memory (bug 395950).
    if(fSuccess)
    {
        fSuccess = PinLibrary(hInst);
    }

    // Announce our presence to the world
    if(fSuccess)
    {
        DPF(DPFLVL_INFO, "DirectSound is ready to rock at 0x%p...", hInst);
    }

    DPF_LEAVE(fSuccess);
    
    return fSuccess;
}


/***************************************************************************
 *
 *  DllLastProcessDetach
 *
 *  Description:
 *      Handles final process detach for DllMain.
 *
 *  Arguments:
 *      DWORD [in]: process id.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllLastProcessDetach"

void DllLastProcessDetach(DWORD dwProcessId)
{
    DPF_ENTER();
    
    DPF(DPFLVL_INFO, "DirectSound going away...");

    // Free the DirectSound Administrator
    ABSOLUTE_RELEASE(g_pDsAdmin);

    // Free the virtual audio device manager
    ABSOLUTE_RELEASE(g_pVadMgr);

#ifndef NOVXD

    // Release DSOUND.VXD
    if(g_hDsVxd)
    {
        VxdShutdown();
        VxdClose();
    }

#endif // NOVXD

    // Reset the mixer mutex pointer
    gpMixerMutex = NULL;

    // Free the global lock
    DELETE(g_pDllLock);

    // Free the memory manager
    MemFini();
    
    // Uninitialize the debugger
    DPFCLOSE();

    // There are no more references to this DLL
    g_ulDllRefCount = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  DllProcessAttach
 *
 *  Description:
 *      Handles process attaches for DllMain.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *      DWORD [in]: process id.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllProcessAttach"

BOOL DllProcessAttach(HINSTANCE hInst, DWORD dwProcessId)
{
    BOOL                    fSuccess    = TRUE;
    HANDLE                  hMutex      = NULL;

    DPF_ENTER();

#ifndef DX_FINAL_RELEASE
    // Warn the user if this is an expired pre-release DirectSound DLL.
    SYSTEMTIME st;
    GetSystemTime(&st);

    if ((st.wYear > DX_EXPIRE_YEAR) || 
        (st.wYear == DX_EXPIRE_YEAR && st.wMonth > DX_EXPIRE_MONTH) ||
        (st.wYear == DX_EXPIRE_YEAR && st.wMonth == DX_EXPIRE_MONTH && st.wDay > DX_EXPIRE_DAY))
    {
        MessageBox(NULL, DX_EXPIRE_TEXT, TEXT("Microsoft DirectSound"), MB_OK);
        RPF(DPFLVL_ABSOLUTE, "This pre-release version of DirectX has expired; please upgrade to the latest version.");
    }
#endif // DX_FINAL_RELEASE

#ifdef SHARED
    if(dwProcessId != dwHelperPid)
#endif // SHARED
    {
        hMutex = EnterDllMainMutex(dwProcessId);
    }

    // Increment the DLL reference count
    AddRef(&g_ulDllRefCount);

#ifdef SHARED
    if(dwProcessId != dwHelperPid)
#endif // SHARED
    {
        // Is this the first attach?
        if(1 == g_ulDllRefCount)
        {
            // Yes.  Initialize everything.
            fSuccess = DllFirstProcessAttach(hInst, dwProcessId);

            if(!fSuccess)
            {
                DllLastProcessDetach(dwProcessId);
            }
        }
    
#ifdef SHARED
        // Ask DDHELP to keep an eye on this process for us
        if(fSuccess)
        {
            SignalNewProcess(dwProcessId, DdhelpProcessNotifyProc);
        }
#endif // SHARED

    }

    if(fSuccess)
    {
        DPF(DPFLVL_INFO, "DirectSound process 0x%8.8lX started - DLL ref count=%lu", dwProcessId, g_ulDllRefCount);
    }

    if(hMutex)
    {
        LeaveDllMainMutex(hMutex);
    }

#ifdef ENABLE_PERFLOG
    // Initialize performance logging
    HKEY PerfKey=NULL;
    DWORD PerfValue=0;
    DWORD sizePerfValue=sizeof(DWORD);
    if (RegOpenKey (HKEY_LOCAL_MACHINE,TEXT("SOFTWARE\\Microsoft\\DirectX"),&PerfKey)== ERROR_SUCCESS) {
        if (RegQueryValueEx (PerfKey,TEXT("GlitchInstrumentation"),NULL,NULL,(LPBYTE)&PerfValue,&sizePerfValue)== ERROR_SUCCESS) {
            if (PerfValue>0) {
                InitializePerflog();
            } //if perfvalue
        } //if regqueryvalue
        RegCloseKey(PerfKey);
    } //if regopen key
#endif

    DPF_LEAVE(fSuccess);
    return fSuccess;
}


/***************************************************************************
 *
 *  DllProcessDetach
 *
 *  Description:
 *      Handles process detaches for DllMain.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *      DWORD [in]: process id.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllProcessDetach"

void DllProcessDetach(DWORD dwProcessId)
{
    HANDLE                  hMutex;

    DPF_ENTER();
    
    hMutex = EnterDllMainMutex(dwProcessId);
    
    // Clean up any objects left behind by the object

#ifdef SHARED
    if(dwProcessId != dwHelperPid)
#endif // SHARED
    {
        CleanupAfterProcess(dwProcessId);
    }

    // Clean up per-process streaming thread and ksuser.dll dynaload table
    FreeStreamingThread(dwProcessId);
    RemovePerProcessKsUser(dwProcessId);

    // Decrement the DLL ref count
    Release(&g_ulDllRefCount);

    // Is this the last detach?
    if(!g_ulDllRefCount)
    {
        DllLastProcessDetach(dwProcessId);
    }

    DPF(DPFLVL_INFO, "process id 0x%8.8lX, ref count %lu", dwProcessId, g_ulDllRefCount);

    LeaveDllMainMutex(hMutex);

#ifdef ENABLE_PERFLOG
    // Terminate performance logging
    PerflogShutdown();
#endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  DllThreadAttach
 *
 *  Description:
 *      Handles thread attaches for DllMain.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *      DWORD [in]: process id.
 *      DWORD [in]: thread id.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllThreadAttach"

void DllThreadAttach(DWORD dwProcessId, DWORD dwThreadId)
{
    DPF_ENTER();
    
    DPF(DPFLVL_INFO, "process id 0x%8.8lX, thread id 0x%8.8lX", dwProcessId, dwThreadId);
    
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  DllThreadDetach
 *
 *  Description:
 *      Handles thread detaches for DllMain.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *      DWORD [in]: process id.
 *      DWORD [in]: thread id.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllThreadDetach"

void DllThreadDetach(DWORD dwProcessId, DWORD dwThreadId)
{
    DPF_ENTER();
    
    DPF(DPFLVL_INFO, "process id 0x%8.8lX, thread id 0x%8.8lX", dwProcessId, dwThreadId);
    
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  DllMain
 *
 *  Description:
 *      DLL entry point.
 *
 *  Arguments:
 *      HINSTANCE [in]: DLL instance handle.
 *      DWORD [in]: reason for call.
 *      LPVOID [in]: reserved.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllMain"

BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID pvReserved)
{
    const DWORD             dwProcessId = GetCurrentProcessId();
    const DWORD             dwThreadId  = GetCurrentThreadId();
    BOOL                    fAllow      = TRUE;

    DPF_ENTER();

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            fAllow = DllProcessAttach(hInst, dwProcessId);
            break;

        case DLL_PROCESS_DETACH:

#ifdef SHARED
            if(dwProcessId == dwHelperPid)
#endif // SHARED
            {            
                DllProcessDetach(dwProcessId);
            }

            break;

        case DLL_THREAD_ATTACH:
            DllThreadAttach(dwProcessId, dwThreadId);
            break;

        case DLL_THREAD_DETACH:
            DllThreadDetach(dwProcessId, dwThreadId);
            break;

        default:
            DPF(DPFLVL_ERROR, "Unknown DllMain call reason %lu", dwReason);
            break;
    }

    DPF_LEAVE(fAllow);

    return fAllow;
}


#ifdef WIN95
/***************************************************************************
 *
 *  main
 *
 *  Description:
 *      On Windows 9x, libc.lib requires us to have a main() function.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "main"

void __cdecl main(void)
{
    DPF(DPFLVL_ERROR, "This function should never be called");
    ASSERT(FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dmacpy34.inc ===
/***************************************************************************
 *  Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

void DMACopy34Asm (PLONG plBuild,
		  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
		  int cbOutputBuffer
)
{
   PBYTE pOutput = (PBYTE)pvOutput;
   while (plBuild < plBuildBound)
      {
      LONG iters = plBuildBound - plBuild;
      LONG i     = (PBYTE)pWrapPoint   - pOutput;
      
      if (iters > i) iters = i;
      iters /= 2;;
#if 1
      if (iters) 
	_asm {
	mov	ebx, iters
	mov	esi, plBuild
	mov	edi, pOutput
	lea	eax, [esi+ebx*8]
	lea	edx, [edi+ebx*2]
	dec	ebx
	mov	plBuild, eax
	mov	pOutput, edx

	mov	ecx, 32768

	movd		mm5, ecx
	punpckldq	mm5, mm5	// 32768, 32768

	mov	ecx, 0x80

	movd		mm6, ecx
	punpcklwd	mm6, mm6
	punpckldq	mm6, mm6

	cmp	ebx, 7
	jl	Last

	sub	ebx, 3
	and	edx, 7
	je	Top

	add	ebx, 3
	lea	ebx, [ebx*2+1]
First:
	mov	ecx, DWORD PTR [esi+ebx*4]

	movd		mm1, ecx
	packssdw	mm1, mm1
	punpcklwd	mm1, mm1
	psrad		mm1, 16
	paddd		mm1, mm5
	psrad		mm1, 8
	movd		ecx, mm1

	mov	BYTE PTR [edi+ebx*1], cl

	dec	ebx
	lea	eax, [edi+ebx*1]
	and	eax, 7
	cmp	eax, 7
	jne	First
	
	shr	ebx, 1
	sub	ebx, 3

Top:
#ifdef GTW_REORDER
	movq		mm1, [esi+ebx*8]
	movq		mm2, [esi+ebx*8+8]
	jmp	Top00
Top0:
	movq		mm7, [esi+ebx*8]
	packuswb	mm1, mm3	// Saturation is NO-OP here.

	movq		[edi+ebx*2+8], mm1

	movq		mm2, [esi+ebx*8+8]
	movq		mm1, mm7
Top00:
	movq		mm3, [esi+ebx*8+16]
	packssdw	mm1, mm2	// Clip.

	movq		mm4, [esi+ebx*8+24]
	psraw		mm1, 8

	packssdw	mm3, mm4
	sub	ebx, 4

	psraw		mm3, 8
	paddw		mm1, mm6

	paddw		mm3, mm6
	jge	Top0

	packuswb	mm1, mm3	// Saturation is NO-OP here.

	movq		[edi+ebx*2+8], mm1
#else
	movq		mm1, [esi+ebx*8]
	movq		mm2, [esi+ebx*8+8]
	movq		mm3, [esi+ebx*8+16]
	movq		mm4, [esi+ebx*8+24]

	packssdw	mm1, mm2	// Clip.
	packssdw	mm3, mm4

	psraw		mm1, 8
	psraw		mm3, 8

	paddw		mm1, mm6
	paddw		mm3, mm6

	packuswb	mm1, mm3	// Saturation is NO-OP here.

	movq		[edi+ebx*2], mm1

	sub	ebx, 4
	jge	Top
#endif

	add	ebx, 3	// 4
	jl	Done	// jle

//	dec	ebx
Last:
	lea	ebx, [ebx*2+1]
Lab:
	mov	ecx, DWORD PTR [esi+ebx*4]

	movd		mm1, ecx
	packssdw	mm1, mm1
	punpcklwd	mm1, mm1
	psrad		mm1, 16
	paddd		mm1, mm5
	psrad		mm1, 8
	movd		ecx, mm1

	mov	BYTE PTR [edi+ebx*1], cl
	dec	ebx
	jge	Lab
Done:
	emms
      }
#else
      LONG SampleL;
      LONG SampleR;
      ++iters;
      while (--iters) {
	 SampleL = *plBuild;
	 SampleR = *(plBuild+1);
	 plBuild += 2;
         if ((LONG)((SHORT)SampleL) != SampleL) {
	    if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
	    else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
         }
         if ((LONG)((SHORT)SampleR) != SampleR) {
	    if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
	    else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
         }
	 SampleL += 32768;
	 SampleR += 32768;
	 *pOutput = (BYTE)DIVIDEBY256(SampleL);
	 *(pOutput+1) = (BYTE)DIVIDEBY256(SampleR);
	 pOutput += 2;
      }
#endif
      if (pOutput >= pWrapPoint) {
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dmstrm.h ===
//
// dmstrm.h
// 
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//

#ifndef DMSTRM_H
#define DMSTRM_H

#ifdef __cplusplus

// Macro to round up an odd size to RIFF 16 bit boundary.
#define RIFF_ALIGN(dwSize) (dwSize + (dwSize & 1))

typedef struct _RIFFIO
{
    FOURCC          ckid;           /* chunk ID */
    long            cksize;         /* chunk size */
    FOURCC          fccType;        /* form type or list type */
    long            lRead;          /* How much of this chunk has been read so far. */
    _RIFFIO *       pParent;        /* pointer to parent chunk */
    LARGE_INTEGER   liPosition;     /* Filled in by MarkPosition() when handing stream to another component. */
} RIFFIO;


class CRiffParser
{
public:
    CRiffParser(IStream *pStream);
    void        DebugOn() { m_fDebugOn = TRUE; } // Turns on tracing of parsing. Only available in debug builds.
    BOOL        NextChunk(HRESULT * pHr); // Does the work of LeaveChunk, MoreChunks, and EnterChunk in one call. 
    void        EnterList(RIFFIO *pChunk); // Descend into a new list.
    void        LeaveList();    // Pop out of the current list. 
    BOOL        MoreChunks();   // Returns true if there are more chunks to process in this LIST or RIFF.
    HRESULT     EnterChunk();   // Reads header of next chunk in this LIST or RIFF container.
    HRESULT     LeaveChunk();   // Move to the end of the current chunk in the LIST or RIFF.
    void        MarkPosition(); // Stores the absolute position of the start of the current chunk.
    HRESULT     SeekBack();     // Scan back to the beginning of the current chunk.
    HRESULT     SeekForward();  // Scan forward to the end of the current chunk.
    HRESULT     Read(void *pv,ULONG cb); // Reads data from stream. 
    HRESULT     Skip(ULONG ulBytes); // Seeks forward ulBytes.
    void        EnteringComponent() { m_fInComponent = true; } 
    BOOL        ComponentFailed() { return m_fComponentFailed; }
    IStream *   GetStream() { return m_pStream; }
private:
    BOOL        m_fDebugOn;     // Set true to turn tracing of parsing on. 
    BOOL        m_fFirstPass;   // Used by NextChunk to understand whether this is the first time in the list.
    IStream *   m_pStream;      // Stream to operate on. 
    RIFFIO *    m_pChunk;       // Current chunk that we are in. 
    RIFFIO *    m_pParent;      // Parent chunk of current chunk.
    long        m_lRead;        // How far we've read in the current chunk.
    BOOL        m_fComponentFailed; // Set true if a component failed to load, yet the file is okay.
    BOOL        m_fInComponent; // Set to true when inside a component's chunk.
};

#endif // __cplusplus

#endif // #ifndef DMSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dmacpy37.inc ===
/***************************************************************************
 *  Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

void DMACopy37Asm (PLONG plBuild,
		  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
		  int cbOutputBuffer
)
{
   PWORD pOutput = (PWORD)pvOutput;

   while (plBuild < plBuildBound)
      {
      LONG iters = plBuildBound - plBuild;
      LONG i     = (PWORD)pWrapPoint   - pOutput;
      
      if (iters > i) iters = i;
      ;
#if 1
      if (iters) 
	_asm {
	mov	ebx, iters
	mov	esi, plBuild
	mov	edi, pOutput
	lea	eax, [esi+ebx*4]
	lea	edx, [edi+ebx*2]
	dec	ebx
	mov	plBuild, eax
	mov	pOutput, edx
	cmp	ebx, 7
	jl	Last

	sub	ebx, 3
	and	edx, 7
	je	Top

	add	ebx, 3
First:
	mov	ecx, DWORD PTR [esi+ebx*4]

	movd		mm1, ecx
	packssdw	mm1, mm1
	movd		ecx, mm1

	mov	WORD PTR [edi+ebx*2], cx

	dec	ebx
	lea	eax, [edi+ebx*2]
	and	eax, 7
	cmp	eax, 6
	jne	First

	sub	ebx, 3
Top:
#ifdef GTW_REORDER
	jmp	Top00
Top0:
	movq		[edi+ebx*2+8], mm1

Top00:
	movq		mm1, [esi+ebx*4]

	movq		mm2, [esi+ebx*4+8]

	packssdw	mm1, mm2
	sub	ebx, 4

	jge	Top0

	movq		[edi+ebx*2+8], mm1
#else
	movq		mm1, [esi+ebx*4]
	movq		mm2, [esi+ebx*4+8]

	sub	ebx, 4

	packssdw	mm1, mm2
	movq		[edi+ebx*2+8], mm1

	jge	Top
#endif

	add	ebx, 3	// 4
	jl	Done	// jle
	
//	dec	ebx
Last:
	mov	ecx, DWORD PTR [esi+ebx*4]

	movd		mm1, ecx
	packssdw	mm1, mm1
	movd		ecx, mm1

	mov	WORD PTR [edi+ebx*2], cx

	dec	ebx
	jge	Last
Done:
	emms
      }
#else
      LONG Sample;
      ++iters;
      while (--iters) {
	 Sample = *plBuild;
	 plBuild++;
         if ((LONG)((SHORT)Sample) != Sample) {
	    if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
	    else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
         }
	 *pOutput = (WORD)Sample;
	 pOutput++;
      }
#endif
      if (pOutput >= pWrapPoint) {
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
      }
   }
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dmacpy39.inc ===
/***************************************************************************
 *  Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

void DMACopy39Asm (PLONG plBuild,
		  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
		  int cbOutputBuffer
)
{
   PWORD pOutput = (PWORD)pvOutput;

   while (plBuild < plBuildBound)
      {
      LONG iters = plBuildBound - plBuild;
      LONG i     = (PWORD)pWrapPoint   - pOutput;
      
      if (iters > i) iters = i;
      iters /= 2;;

#if 1
      if (iters)
      	_asm {
	mov	ebx, iters
	mov	esi, plBuild
	mov	edi, pOutput
	lea	eax, [esi+ebx*8]
	lea	edx, [edi+ebx*4]
	dec	ebx
	cmp	ebx, 3

	mov	plBuild, eax
	mov	pOutput, edx
	jl	Last

	dec	ebx
	and	edx, 7
	je	Top

	movq		mm1, [esi+ebx*8+8]
	packssdw	mm1, mm1
	movd		[edi+ebx*4+4], mm1

	dec	ebx

Top:
#ifdef GTW_REORDER
	jmp	Top00
Top0:
	movq		[edi+ebx*4+8], mm1

Top00:
	movq		mm1, [esi+ebx*8]

	movq		mm2, [esi+ebx*8+8]

	packssdw	mm1, mm2
	sub	ebx, 2

	jge	Top0

	movq		[edi+ebx*4+8], mm1
#else
	movq		mm1, [esi+ebx*8]
	movq		mm2, [esi+ebx*8+8]

	sub	ebx, 2

	packssdw	mm1, mm2
	movq		[edi+ebx*4+8], mm1

	jge	Top
#endif

	add	ebx, 2
	jle	Done

	dec	ebx
Last:
	movq		mm1, [esi+ebx*8]
	packssdw	mm1, mm1
	movd		[edi+ebx*4], mm1

	dec	ebx
	jge	Last
Done:
	emms
      }
#else
      LONG SampleL;
      LONG SampleR;
      ++iters;
      while (--iters) {
	 SampleL = *plBuild;
	 SampleR = *(plBuild+1);
	 plBuild += 2;
         if ((LONG)((SHORT)SampleL) != SampleL) {
	    if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
	    else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
         }
         if ((LONG)((SHORT)SampleR) != SampleR) {
	    if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
	    else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
         }
	 *pOutput = (WORD)SampleL;
	 *(pOutput+1) = (WORD)SampleR;
	 pOutput += 2;
      }
#endif
      if (pOutput >= pWrapPoint) {
         pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dmstrm.cpp ===
//
// dmstrm.cpp
//
// Copyright (c) 1995-1999 Microsoft Corporation
//

#include "dsoundi.h"
#include "dmusicc.h"

CRiffParser::CRiffParser(IStream *pStream)

{
    ASSERT(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream;
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    ASSERT (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    ASSERT (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DEBUG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            DPF(DPFLVL_MOREINFO, "Parsing %S, Read %ld of %ld\n",
                szName, m_pChunk->lRead, RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent)
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
        HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DEBUG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
                DPF(DPFLVL_MOREINFO, "Entering %S, Length %ld, File position is %ld",
                    szName, m_pChunk->cksize, (long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
            {
                hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DEBUG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        DPF(DPFLVL_MOREINFO, "Type %S", szName);
                    }
#endif
                }
                else
                {
                    DPF(DPFLVL_WARNING, "Unable to read file");
                }
            }
        }
        else
        {
            DPF(DPFLVL_WARNING, "Unable to read file");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                DPF(DPFLVL_WARNING, "Unable to read file");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DEBUG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
            DPF(DPFLVL_MOREINFO, "Leaving %S, Read %ld of %ld, File Position is %ld",
                szName, m_pChunk->lRead, lSize, (long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            DPF(DPFLVL_ERROR, "Unable to read %ld bytes from file", cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
        li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart + RIFF_ALIGN(m_pChunk->cksize);
    }
}

HRESULT CRiffParser::SeekBack()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD)));
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\ds3d.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ds3d.cpp
 *  Content:    DirectSound 3D helper objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  3/12/97     dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <math.h>

const D3DVECTOR g_vDefaultOrientationFront  = { 0.0f, 0.0f, 1.0f };
const D3DVECTOR g_vDefaultOrientationTop    = { 0.0f, 1.0f, 0.0f };
const D3DVECTOR g_vDefaultConeOrientation   = { 0.0f, 0.0f, 1.0f };
const D3DVECTOR g_vDefaultPosition          = { 0.0f, 0.0f, 0.0f };
const D3DVECTOR g_vDefaultVelocity          = { 0.0f, 0.0f, 0.0f };

/***************************************************************************
 *
 *  C3dListener
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::C3dListener"

C3dListener::C3dListener
(
    void
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(C3dListener);

    // Initialize defaults
    m_lpCurrent.dwSize = sizeof(m_lpCurrent);
    m_lpCurrent.vPosition = g_vDefaultPosition;
    m_lpCurrent.vVelocity = g_vDefaultVelocity;
    m_lpCurrent.vOrientFront = g_vDefaultOrientationFront;
    m_lpCurrent.vOrientTop = g_vDefaultOrientationTop;
    m_lpCurrent.flDistanceFactor = DS3D_DEFAULTDISTANCEFACTOR;
    m_lpCurrent.flRolloffFactor = DS3D_DEFAULTROLLOFFFACTOR;
    m_lpCurrent.flDopplerFactor = DS3D_DEFAULTDOPPLERFACTOR;

    CopyMemory(&m_lpDeferred, &m_lpCurrent, sizeof(m_lpCurrent));
    
    m_dwDeferred = 0;
    m_dwSpeakerConfig = DSSPEAKER_DEFAULT;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~C3dListener
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::~C3dListener"

C3dListener::~C3dListener
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(C3dListener);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CommitDeferred
 *
 *  Description:
 *      Commits deferred data to the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::CommitDeferred"

HRESULT 
C3dListener::CommitDeferred
(
    void
)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    // Update all deferred parameters
    if(m_dwDeferred & DS3DPARAM_LISTENER_DISTANCEFACTOR)
    {
        m_lpCurrent.flDistanceFactor = m_lpDeferred.flDistanceFactor;
    }

    if(m_dwDeferred & DS3DPARAM_LISTENER_DOPPLERFACTOR)
    {
        m_lpCurrent.flDopplerFactor = m_lpDeferred.flDopplerFactor;
    }

    if(m_dwDeferred & DS3DPARAM_LISTENER_ROLLOFFFACTOR)
    {
        m_lpCurrent.flRolloffFactor = m_lpDeferred.flRolloffFactor;
    }

    if(m_dwDeferred & DS3DPARAM_LISTENER_ORIENTATION)
    {
        m_lpCurrent.vOrientFront = m_lpDeferred.vOrientFront;
        m_lpCurrent.vOrientTop = m_lpDeferred.vOrientTop;
    }

    if(m_dwDeferred & DS3DPARAM_LISTENER_POSITION)
    {
        m_lpCurrent.vPosition = m_lpDeferred.vPosition;
    }

    if(m_dwDeferred & DS3DPARAM_LISTENER_VELOCITY)
    {
        m_lpCurrent.vVelocity = m_lpDeferred.vVelocity;
    }

    // Commit all objects deferred parameters
    hr = CommitAllObjects();

    // Update all objects
    if(SUCCEEDED(hr))
    {
        hr = UpdateAllObjects(m_dwDeferred);
    }

    // All clean
    if(SUCCEEDED(hr))
    {
        m_dwDeferred = 0;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDistanceFactor
 *
 *  Description:
 *      Sets distance factor for the world.
 *
 *  Arguments:
 *      FLOAT [in]: distance factor.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetDistanceFactor"

HRESULT 
C3dListener::SetDistanceFactor
(
    FLOAT                   flDistanceFactor, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        m_lpCurrent.flDistanceFactor = flDistanceFactor;
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_DISTANCEFACTOR);
    }
    else
    {
        m_lpDeferred.flDistanceFactor = flDistanceFactor;
        m_dwDeferred |= DS3DPARAM_LISTENER_DISTANCEFACTOR;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDopplerFactor
 *
 *  Description:
 *      Sets Doppler factor for the world.
 *
 *  Arguments:
 *      FLOAT [in]: Doppler factor.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetDopplerFactor"

HRESULT 
C3dListener::SetDopplerFactor
(
    FLOAT                   flDopplerFactor, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        m_lpCurrent.flDopplerFactor = flDopplerFactor;
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_DOPPLERFACTOR);
    }
    else
    {
        m_lpDeferred.flDopplerFactor = flDopplerFactor;
        m_dwDeferred |= DS3DPARAM_LISTENER_DOPPLERFACTOR;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetRolloffFactor
 *
 *  Description:
 *      Sets rolloff factor for the world.
 *
 *  Arguments:
 *      FLOAT [in]: rolloff factor.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetRolloffFactor"

HRESULT 
C3dListener::SetRolloffFactor
(
    FLOAT                   flRolloffFactor, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        m_lpCurrent.flRolloffFactor = flRolloffFactor;
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_ROLLOFFFACTOR);
    }
    else
    {
        m_lpDeferred.flRolloffFactor = flRolloffFactor;
        m_dwDeferred |= DS3DPARAM_LISTENER_ROLLOFFFACTOR;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetOrienation
 *
 *  Description:
 *      Sets listener orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: orientation.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetOrientation"

HRESULT 
C3dListener::SetOrientation
(
    REFD3DVECTOR            vOrientFront, 
    REFD3DVECTOR            vOrientTop, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        m_lpCurrent.vOrientFront = vOrientFront;
        m_lpCurrent.vOrientTop = vOrientTop;
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_ORIENTATION);
    }
    else
    {
        m_lpDeferred.vOrientFront = vOrientFront;
        m_lpDeferred.vOrientTop = vOrientTop;
        m_dwDeferred |= DS3DPARAM_LISTENER_ORIENTATION;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets listener position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetPosition"

HRESULT 
C3dListener::SetPosition
(
    REFD3DVECTOR            vPosition, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        m_lpCurrent.vPosition = vPosition;
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_POSITION);
    }
    else
    {
        m_lpDeferred.vPosition = vPosition;
        m_dwDeferred |= DS3DPARAM_LISTENER_POSITION;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets listener velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: velocity.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetVelocity"

HRESULT 
C3dListener::SetVelocity
(
    REFD3DVECTOR            vVelocity, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        m_lpCurrent.vVelocity = vVelocity;
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_VELOCITY);
    }
    else
    {
        m_lpDeferred.vVelocity = vVelocity;
        m_dwDeferred |= DS3DPARAM_LISTENER_VELOCITY;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all listener parameters.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: velocity.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetAllParameters"

HRESULT 
C3dListener::SetAllParameters
(
    LPCDS3DLISTENER         pParams, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        CopyMemoryOffset(&m_lpCurrent, pParams, sizeof(DS3DLISTENER), sizeof(pParams->dwSize));
        hr = UpdateAllObjects(DS3DPARAM_LISTENER_PARAMMASK);
    }
    else
    {
        CopyMemoryOffset(&m_lpDeferred, pParams, sizeof(DS3DLISTENER), sizeof(pParams->dwSize));
        m_dwDeferred |= DS3DPARAM_LISTENER_PARAMMASK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UpdateAllObjects
 *
 *  Description:
 *      Updates all objects in the world.
 *
 *  Arguments:
 *      DWORD [in]: listener settings to recalculate.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::UpdateAllObjects"

HRESULT 
C3dListener::UpdateAllObjects
(
    DWORD                   dwListener
)
{
    CNode<C3dObject *> *    pNode;
    HRESULT                 hr;
    
    DPF_ENTER();
    
    // Update all objects in the world
    for(pNode = m_lstObjects.GetListHead(), hr = DS_OK; pNode && SUCCEEDED(hr); pNode = pNode->m_pNext)
    {
        hr = pNode->m_data->Recalc(dwListener, 0);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitAllObjects
 *
 *  Description:
 *      Commits deferred settings on all objects in the world.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::CommitAllObjects"

HRESULT 
C3dListener::CommitAllObjects
(
    void
)
{
    CNode<C3dObject *> *    pNode;
    HRESULT                 hr;
    
    DPF_ENTER();
    
    // Update all objects in the world
    for(pNode = m_lstObjects.GetListHead(), hr = DS_OK; pNode && SUCCEEDED(hr); pNode = pNode->m_pNext)
    {
        hr = pNode->m_data->CommitDeferred();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetSpeakerConfig
 *
 *  Description:
 *      Sets speaker config.
 *
 *  Arguments:
 *      DWORD [in]: new speaker config.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dListener::SetSpeakerConfig"

HRESULT 
C3dListener::SetSpeakerConfig
(
    DWORD                   dwSpeakerConfig
)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    m_dwSpeakerConfig = dwSpeakerConfig;
    hr = UpdateAllObjects(DS3DPARAM_LISTENER_SPEAKERCONFIG);
    
    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  C3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *      REFGUID [in]: 3D algorithm identifier.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::C3dObject"

C3dObject::C3dObject
(
    C3dListener *           pListener, 
    REFGUID                 guid3dAlgorithm,
    BOOL                    fMuteAtMaxDistance,
    BOOL                    fDopplerEnabled
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(C3dObject);

    // Initialize defaults
    ASSERT(pListener);
    
    m_pListener = pListener;
    m_pListener->AddObjectToList(this);

    m_guid3dAlgorithm = guid3dAlgorithm;
    m_fMuteAtMaxDistance = fMuteAtMaxDistance;
    m_fDopplerEnabled = fDopplerEnabled;

    m_opCurrent.dwSize = sizeof(m_opCurrent);
    m_opCurrent.vPosition = g_vDefaultPosition;
    m_opCurrent.vVelocity = g_vDefaultVelocity;
    m_opCurrent.dwInsideConeAngle = DS3D_DEFAULTCONEANGLE;
    m_opCurrent.dwOutsideConeAngle = DS3D_DEFAULTCONEANGLE;
    m_opCurrent.vConeOrientation = g_vDefaultConeOrientation;
    m_opCurrent.lConeOutsideVolume = DS3D_DEFAULTCONEOUTSIDEVOLUME;
    m_opCurrent.flMaxDistance = DS3D_DEFAULTMAXDISTANCE;
    m_opCurrent.flMinDistance = DS3D_DEFAULTMINDISTANCE;
    m_opCurrent.dwMode = DS3DMODE_NORMAL;

    CopyMemory(&m_opDeferred, &m_opCurrent, sizeof(m_opCurrent));

    m_dwDeferred = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~C3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::~C3dObject"

C3dObject::~C3dObject
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(C3dObject);

    m_pListener->RemoveObjectFromList(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the 3D object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::Initialize"

HRESULT 
C3dObject::Initialize(void)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    // It's important that the object is positioned correctly from the
    // beginning.
    hr = Recalc(DS3DPARAM_LISTENER_MASK, DS3DPARAM_OBJECT_MASK);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitDeferred
 *
 *  Description:
 *      Commits deferred data to the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::CommitDeferred"

HRESULT 
C3dObject::CommitDeferred(void)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    // Update current data
    if(m_dwDeferred & DS3DPARAM_OBJECT_CONEANGLES)
    {
        m_opCurrent.dwInsideConeAngle = m_opDeferred.dwInsideConeAngle;
        m_opCurrent.dwOutsideConeAngle = m_opDeferred.dwOutsideConeAngle;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_CONEORIENTATION)
    {
        m_opCurrent.vConeOrientation = m_opDeferred.vConeOrientation;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_CONEOUTSIDEVOLUME)
    {
        m_opCurrent.lConeOutsideVolume = m_opDeferred.lConeOutsideVolume;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_MAXDISTANCE)
    {
        m_opCurrent.flMaxDistance = m_opDeferred.flMaxDistance;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_MINDISTANCE)
    {
        m_opCurrent.flMinDistance = m_opDeferred.flMinDistance;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_MODE)
    {
        m_opCurrent.dwMode = m_opDeferred.dwMode;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_POSITION)
    {
        m_opCurrent.vPosition = m_opDeferred.vPosition;
    }

    if(m_dwDeferred & DS3DPARAM_OBJECT_VELOCITY)
    {
        m_opCurrent.vVelocity = m_opDeferred.vVelocity;
    }

    // Recalculate the object parameters
    hr = Recalc(0, m_dwDeferred);

    // All clean
    if(SUCCEEDED(hr))
    {
        m_dwDeferred = 0;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeAngles
 *
 *  Description:
 *      Sets sound cone angles.
 *
 *  Arguments:
 *      DWORD [in]: inside cone angle.
 *      DWORD [in]: outside cone angle.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetConeAngles"

HRESULT 
C3dObject::SetConeAngles
(
    DWORD                   dwInsideConeAngle, 
    DWORD                   dwOutsideConeAngle, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.dwInsideConeAngle = dwInsideConeAngle;
        m_opCurrent.dwOutsideConeAngle = dwOutsideConeAngle;
        hr = Recalc(0, DS3DPARAM_OBJECT_CONEANGLES);
    }
    else
    {
        m_opDeferred.dwInsideConeAngle = dwInsideConeAngle;
        m_opDeferred.dwOutsideConeAngle = dwOutsideConeAngle;
        m_dwDeferred |= DS3DPARAM_OBJECT_CONEANGLES;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeOrientation
 *
 *  Description:
 *      Sets sound cone orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: orientation.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetConeOrientation"

HRESULT 
C3dObject::SetConeOrientation
(
    REFD3DVECTOR            vConeOrientation, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.vConeOrientation = vConeOrientation;
        hr = Recalc(0, DS3DPARAM_OBJECT_CONEORIENTATION);
    }
    else
    {
        m_opDeferred.vConeOrientation = vConeOrientation;
        m_dwDeferred |= DS3DPARAM_OBJECT_CONEORIENTATION;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeOutsideVolume
 *
 *  Description:
 *      Sets volume outside the sound cone.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetConeOutsideVolume"

HRESULT 
C3dObject::SetConeOutsideVolume
(
    LONG                    lConeOutsideVolume, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.lConeOutsideVolume = lConeOutsideVolume;
        hr = Recalc(0, DS3DPARAM_OBJECT_CONEOUTSIDEVOLUME);
    }
    else
    {
        m_opDeferred.lConeOutsideVolume = lConeOutsideVolume;
        m_dwDeferred |= DS3DPARAM_OBJECT_CONEOUTSIDEVOLUME;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMaxDistance
 *
 *  Description:
 *      Sets the maximum object distance from the listener.
 *
 *  Arguments:
 *      FLOAT [in]: max distance.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetMaxDistance"

HRESULT 
C3dObject::SetMaxDistance
(
    FLOAT                   flMaxDistance, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.flMaxDistance = flMaxDistance;
        hr = Recalc(0, DS3DPARAM_OBJECT_MAXDISTANCE);
    }
    else
    {
        m_opDeferred.flMaxDistance = flMaxDistance;
        m_dwDeferred |= DS3DPARAM_OBJECT_MAXDISTANCE;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMinDistance
 *
 *  Description:
 *      Sets the minimum object distance from the listener.
 *
 *  Arguments:
 *      FLOAT [in]: min distance.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetMinDistance"

HRESULT 
C3dObject::SetMinDistance
(
    FLOAT                   flMinDistance, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.flMinDistance = flMinDistance;
        hr = Recalc(0, DS3DPARAM_OBJECT_MINDISTANCE);
    }
    else
    {
        m_opDeferred.flMinDistance = flMinDistance;
        m_dwDeferred |= DS3DPARAM_OBJECT_MINDISTANCE;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the object mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetMode"

HRESULT 
C3dObject::SetMode
(
    DWORD                   dwMode, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.dwMode = dwMode;
        hr = Recalc(0, DS3DPARAM_OBJECT_MODE);
    }
    else
    {
        m_opDeferred.dwMode = dwMode;
        m_dwDeferred |= DS3DPARAM_OBJECT_MODE;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the object position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetPosition"

HRESULT 
C3dObject::SetPosition
(
    REFD3DVECTOR            vPosition, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.vPosition = vPosition;
        hr = Recalc(0, DS3DPARAM_OBJECT_POSITION);
    }
    else
    {
        m_opDeferred.vPosition = vPosition;
        m_dwDeferred |= DS3DPARAM_OBJECT_POSITION;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the object velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR[in]: velocity.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetVelocity"

HRESULT 
C3dObject::SetVelocity
(
    REFD3DVECTOR            vVelocity, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(fCommit)
    {
        m_opCurrent.vVelocity = vVelocity;
        hr = Recalc(0, DS3DPARAM_OBJECT_VELOCITY);
    }
    else
    {
        m_opDeferred.vVelocity = vVelocity;
        m_dwDeferred |= DS3DPARAM_OBJECT_VELOCITY;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all object parameters.
 *
 *  Arguments:
 *      LPCDS3DBUFFER [in]: object parameters.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::SetAllParameters"

HRESULT 
C3dObject::SetAllParameters
(
    LPCDS3DBUFFER           pParams, 
    BOOL                    fCommit
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    if(fCommit)
    {
        CopyMemoryOffset(&m_opCurrent, pParams, sizeof(DS3DBUFFER), sizeof(pParams->dwSize));
        hr = Recalc(0, DS3DPARAM_OBJECT_PARAMMASK);
    }
    else
    {
        CopyMemoryOffset(&m_opDeferred, pParams, sizeof(DS3DBUFFER), sizeof(pParams->dwSize));
        m_dwDeferred |= DS3DPARAM_OBJECT_PARAMMASK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  IsAtMaxDistance
 *
 *  Description:
 *      Determines if the object is muted based on distance.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE if the object is at its maxiumum distance.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C3dObject::IsAtMaxDistance"

BOOL
C3dObject::IsAtMaxDistance
(
    void
)
{
    BOOL                    fAtMaxDistance;
    D3DVECTOR               vHrp;
    ROTATION                rotation;
    SPHERICAL               spherical;

    DPF_ENTER();

    if(DS3DMODE_DISABLE != m_opCurrent.dwMode && m_fMuteAtMaxDistance)
    {
        if(m_pListener && DS3DMODE_NORMAL == m_opCurrent.dwMode)
        {
            GetRotations(&rotation.pitch, &rotation.yaw, &rotation.roll, &m_pListener->m_lpCurrent.vOrientFront, &m_pListener->m_lpCurrent.vOrientTop);
            GetHeadRelativeVector(&vHrp, &m_opCurrent.vPosition, &m_pListener->m_lpCurrent.vPosition, rotation.pitch, rotation.yaw, rotation.roll);
            CartesianToSpherical(&spherical.rho, &spherical.theta, &spherical.phi, &vHrp);
        }
        else
        {
            CartesianToSpherical(&spherical.rho, &spherical.theta, &spherical.phi, &m_opCurrent.vPosition);
        }

        fAtMaxDistance = (spherical.rho > m_opCurrent.flMaxDistance);
    }
    else
    {
        fAtMaxDistance = FALSE;
    }
        
    DPF_LEAVE(fAtMaxDistance);

    return fAtMaxDistance;
}


/***************************************************************************
 *
 *  CSw3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *      REFGUID [in]: 3D algorithm identifier.
 *      DWORD [in]: frequency.
 *      BOOL [in]: TRUE to mute 3D at max distance.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::CSw3dObject"

CSw3dObject::CSw3dObject
(
    C3dListener *           pListener, 
    REFGUID                 guid3dAlgorithm,
    BOOL                    fMuteAtMaxDistance,
    BOOL                    fDopplerEnabled,
    DWORD                   dwUserFrequency
)
    : C3dObject(pListener, guid3dAlgorithm, fMuteAtMaxDistance, fDopplerEnabled)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CSw3dObject);

    // Initialize defaults
    m_dwUserFrequency = dwUserFrequency;
    m_dwDopplerFrequency = dwUserFrequency;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CSw3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::~CSw3dObject"

CSw3dObject::~CSw3dObject
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CSw3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Recalc
 *
 *  Description:
 *      Recalculates and applies the object's data based on changed object 
 *      or listener valiues.
 *
 *  Arguments:
 *      DWORD [in]: changed listener settings.
 *      DWORD [in]: changed object settings.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::Recalc"

HRESULT 
CSw3dObject::Recalc
(
    DWORD                   dwListener, 
    DWORD                   dwObject
)
{
    BOOL                    fHrp                    = FALSE;
    BOOL                    fListenerOrientation    = FALSE;
    BOOL                    fDoppler                = FALSE;
    BOOL                    fPosition               = FALSE;
    BOOL                    fCone                   = FALSE;
    HRESULT                 hr                      = DS_OK;

    DPF_ENTER();

    // Determine which settings need to be recalculated
    if(dwListener & DS3DPARAM_LISTENER_DISTANCEFACTOR)
    {
        fHrp = fDoppler = TRUE;
    }
                                                           
    if(dwListener & DS3DPARAM_LISTENER_DOPPLERFACTOR)
    {
        fDoppler = TRUE;
    }

    if(dwListener & DS3DPARAM_LISTENER_ROLLOFFFACTOR)
    {
        fPosition = TRUE;
    }                              

    if(dwListener & DS3DPARAM_LISTENER_ORIENTATION)
    {
        fListenerOrientation = TRUE;
        fHrp = TRUE;
    }

    if(dwListener & DS3DPARAM_LISTENER_POSITION)
    {
        fHrp = fDoppler = TRUE;
    }

    if(dwListener & DS3DPARAM_LISTENER_VELOCITY)
    {
        fDoppler = TRUE;
    }

    if(dwListener & DS3DPARAM_LISTENER_SPEAKERCONFIG)
    {
        fHrp = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_CONEANGLES)
    {
        fCone = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_CONEORIENTATION)
    {
        fCone = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_CONEOUTSIDEVOLUME)
    {
        fCone = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_MAXDISTANCE)
    {
        fPosition = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_MINDISTANCE)
    {
        fPosition = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_MODE)
    {
        fHrp = fDoppler = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_POSITION)
    {
        fHrp = fDoppler = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_VELOCITY)
    {
        fHrp = fDoppler = TRUE;
    }

    if(dwObject & DS3DPARAM_OBJECT_FREQUENCY)
    {
        fDoppler = TRUE;
    }

    // Recalculate
    if(fListenerOrientation)
    {
        UpdateListenerOrientation();
    }

    if(fHrp)
    {
        UpdateHrp();
    }

    if(fDoppler)
    {
        UpdateDoppler();
    }

    if(fPosition && !fHrp)
    {
        UpdatePositionAttenuation();
    }

    if(fCone && !fHrp)
    {
        UpdateConeAttenuation();
    }

    // Commit to the device
    if(fHrp || fDoppler || fPosition || fCone)
    {
        hr = Commit3dChanges();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UpdateConeAttenuation
 *
 *  Description:
 *      Updates object attenuation based on cone properties.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::UpdateConeAttenuation"

void 
CSw3dObject::UpdateConeAttenuation
(
    void
)
{
    D3DVECTOR               vPos;
    D3DVECTOR               vHeadPos;
    FLOAT                   flSpreadi;
    FLOAT                   flCosSpreadi;
    FLOAT                   flSpreado;
    FLOAT                   flCosSpreado;
    FLOAT                   flCosTheta;
    DWORD                   dwMode;

    DPF_ENTER();

    //initialization
    SET_EMPTY_VECTOR(vPos);

    // Put the object at the origin - where are we now?

    // In Normal mode, we calculate it for real.  In HeadRelative mode, 
    // we assume the position given is already head relative.  In Disable 
    // mode, we assume the object is on top of the listener (no 3D).

    // If everywhere is inside the cone, don't waste time
    if(m_opCurrent.dwInsideConeAngle < 360)
    {
        dwMode = m_opCurrent.dwMode;

        if(!m_pListener && DS3DMODE_NORMAL == m_opCurrent.dwMode)
        {
            dwMode = DS3DMODE_HEADRELATIVE;
        }

        if(DS3DMODE_NORMAL == dwMode)
        {
            SubtractVector(&vPos, &m_pListener->m_lpCurrent.vPosition, &m_opCurrent.vPosition);
        }
        else if(DS3DMODE_HEADRELATIVE == dwMode)
        {
            SET_EMPTY_VECTOR(vHeadPos);
            SubtractVector(&vPos, &vHeadPos, &m_opCurrent.vPosition);
        }
    }

    // If we're at the same point as the object, we're in the cone
    // note that the angle is alwas <= 360, but we want to handle bad
    // values gracefully.
    if(m_opCurrent.dwInsideConeAngle >= 360 || IsEmptyVector(&vPos))
    {
        m_fInInnerCone = TRUE;
        m_fInOuterCone = TRUE;
    }
    else
    {
        // What is the angle between us and the cone vector?  Note
        // that the cone vector has maginitude 1 already.
        flCosTheta = DotProduct(&vPos, &m_opCurrent.vConeOrientation) 
                     / MagnitudeVector(&vPos);

        // From 0 to pi, cos(theta) > cos(phi) for theta < phi

        // Inner cone: how many radians out from the center of the cone
        // is one edge?
        flSpreadi = m_opCurrent.dwInsideConeAngle * PI_OVER_360;
        flCosSpreadi = (FLOAT)cos(flSpreadi);
        m_fInInnerCone = flCosTheta > flCosSpreadi;

        // Outer cone: how many radians out from the center of the cone
        // is one edge?
        flSpreado = m_opCurrent.dwOutsideConeAngle * PI_OVER_360;
        flCosSpreado = (FLOAT)cos(flSpreado);
        m_fInOuterCone = flCosTheta > flCosSpreado;
    }

    if(m_fInInnerCone)
    {
        // We're inside both cones.  Don't attenuate.
        m_flAttenuation = 1.0f;
        m_flHowFarOut = 1.0f;
    }
    else if(!m_fInOuterCone)
    {
        // We're outside both cones.  Fully attenuate by lConeOutsideVolume
        // 100ths of a dB.  Remember, 6dB down is half the amplitude.  Low
        // pass filter by SHADOW_CONE.
        m_flAttenuation = (FLOAT)pow2(m_opCurrent.lConeOutsideVolume 
                          * (1.0f / 600.0f));
        m_flHowFarOut = 1.0f;
    }
    else
    {
        // Where between the cones are we?  0 means on the inner edge, 1 means
        // on the outer edge.
        m_flHowFarOut = (flCosSpreadi - flCosTheta) 
                      / (flCosSpreadi - flCosSpreado);

        // Attenuate by as much as lConeOutsideVolume 100ths of a dB if we're
        // on the edge of the outer cone.  Basically, I've (dannymi) chosen to
        // do no change on the edge of the inner cone and the maximum change when
        // your on the edge of the outer cone and the above else does maximum
        // change whenever you're outside both.
        m_flAttenuation = (FLOAT)pow2(m_opCurrent.lConeOutsideVolume 
                          * m_flHowFarOut * (1.0f / 600.0f));

    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdatePositionAttenuation
 *
 *  Description:
 *      Updates object attenuation based on position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::UpdatePositionAttenuation"

void 
CSw3dObject::UpdatePositionAttenuation
(
    void
)
{
    FLOAT                   flRolloffFactor;

    DPF_ENTER();

    // Now figure out the new volume attenuation due to the new distance.
    // Every doubling of the distance of the object from its min distance
    // halves the amplitude (6dB down) with 100% rolloff (1.0).
    // For rolloff factors other than 100% we scale it so it will rolloff
    // faster/slower than normal, using the only formula I could dream up
    // that made sense.
    if(m_spherical.rho >= m_opCurrent.flMaxDistance)
    {
        m_spherical.rho = m_opCurrent.flMaxDistance;
        m_fAtMaxDistance = TRUE;
    }
    else
    {
        m_fAtMaxDistance = FALSE;
    }

    if(m_pListener)
    {
         flRolloffFactor = m_pListener->m_lpCurrent.flRolloffFactor;
    }
    else
    {
        flRolloffFactor = DS3D_DEFAULTROLLOFFFACTOR;
    }

    if(m_spherical.rho > m_opCurrent.flMinDistance && flRolloffFactor > 0.0f)
    {
        m_flAttDistance = m_opCurrent.flMinDistance / 
           ((m_spherical.rho - m_opCurrent.flMinDistance) * flRolloffFactor 
            + m_opCurrent.flMinDistance);
    }
    else
    {
        m_flAttDistance = 1.0f;
    }


    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateListenerOrientation
 *
 *  Description:
 *      Updates the listener's orientation.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::UpdateListenerOrientation"

void 
CSw3dObject::UpdateListenerOrientation
(
    void
)
{
    DWORD                   dwMode;

    DPF_ENTER();

    // Figure out where this object is relative to the listener's head

    // In Normal mode, we update the orientation.  In HeadRelative mode, 
    // we assume the orientation is the default. 

    dwMode = m_opCurrent.dwMode;

    if(!m_pListener && DS3DMODE_NORMAL == dwMode)
    {
        dwMode = DS3DMODE_HEADRELATIVE;
    }

    if(DS3DMODE_NORMAL == dwMode)
    {
        GetRotations(&m_rotation.pitch, 
                     &m_rotation.yaw, 
                     &m_rotation.roll, 
                     &m_pListener->m_lpCurrent.vOrientFront, 
                     &m_pListener->m_lpCurrent.vOrientTop); 
    }
    else 
    {
        m_rotation.pitch = 0.0;
        m_rotation.yaw = 0.0; 
        m_rotation.roll = 0.0;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateDoppler
 *
 *  Description:
 *      Updates doppler shift.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::UpdateDoppler"

void 
CSw3dObject::UpdateDoppler
(
    void
)
{
    D3DVECTOR               vListenerVelocity;
    D3DVECTOR               vListenerPosition;
    FLOAT                   flRelVel;
    FLOAT                   flFreqDoppler;
    FLOAT                   flDopplerFactor;
    FLOAT                   flDistanceFactor;
    D3DVECTOR               vHeadPos;
    D3DVECTOR               vHeadVel;
    DWORD                   dwMode;
    double                  dTemp;

    DPF_ENTER();

    // Update the Doppler effect.  Don't bother if there's no current
    // effect and we know right away we won't want one.
    if(m_pListener)
    {
        flDopplerFactor = m_pListener->m_lpCurrent.flDopplerFactor;
        flDistanceFactor = m_pListener->m_lpCurrent.flDistanceFactor;
        vListenerVelocity = m_pListener->m_lpCurrent.vVelocity;
        vListenerPosition = m_pListener->m_lpCurrent.vPosition;
    }
    else
    {
        flDopplerFactor = DS3D_DEFAULTDOPPLERFACTOR;
        flDistanceFactor = DS3D_DEFAULTDISTANCEFACTOR;
        SET_EMPTY_VECTOR(vListenerVelocity);
        SET_EMPTY_VECTOR(vListenerPosition);
    }
    
    if(flDopplerFactor > 0.0f && 
       (!IsEmptyVector(&vListenerVelocity) || !IsEmptyVector(&m_opCurrent.vVelocity)))
    {
        // In Normal mode, we calculate it for real.  In HeadRelative mode, 
        // we assume the position given is already head relative.  In Disable 
        // mode, we assume the object is on top of the listener (no 3D).
        dwMode = m_opCurrent.dwMode;

        if(!m_pListener && DS3DMODE_NORMAL == dwMode)
        {
            dwMode = DS3DMODE_HEADRELATIVE;
        }

        if(DS3DMODE_NORMAL == dwMode)
        {
            GetRelativeVelocity(&flRelVel, 
                                &m_opCurrent.vPosition, 
                                &m_opCurrent.vVelocity, 
                                &vListenerPosition, 
                                &vListenerVelocity);
        }
        else if(DS3DMODE_HEADRELATIVE == dwMode)
        {
            SET_EMPTY_VECTOR(vHeadPos);
            SET_EMPTY_VECTOR(vHeadVel);
            
            GetRelativeVelocity(&flRelVel, 
                                &m_opCurrent.vPosition, 
                                &m_opCurrent.vVelocity, 
                                &vHeadPos, &vHeadVel);
        }
        else
        {
            flRelVel = 0.0f;
        }

        // Make the units mm/s
        dTemp = flRelVel;
        dTemp *= flDistanceFactor;
        dTemp *= 1000;

        // They may want an exaggerated Doppler effect
        dTemp *= flDopplerFactor;

        // Clamp to the float type's valid range
        if (dTemp < -FLT_MAX)
            flRelVel = -FLT_MAX;
        else if (dTemp > FLT_MAX)
            flRelVel = FLT_MAX;
        else
            flRelVel = FLOAT(dTemp);

        GetDopplerShift(&flFreqDoppler, (FLOAT)m_dwUserFrequency, flRelVel);
        m_dwDopplerFrequency = (DWORD)flFreqDoppler;
    }
    else
    {
        m_dwDopplerFrequency = m_dwUserFrequency;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateHrp
 *
 *  Description:
 *      Updates object head-relative position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::UpdateHrp"

void 
CSw3dObject::UpdateHrp
(
    void
)
{
    BOOL                    fOk                 = TRUE;
    D3DVECTOR               vHrp;
    DWORD                   dwMode;

    DPF_ENTER();

    // Figure out where this object is relative to the listener's head

    // In Normal mode, we calculate it for real.  In HeadRelative mode, 
    // we assume the position given is already head relative.  In Disable 
    // mode, we assume the object is on top of the listener (no 3D).
    dwMode = m_opCurrent.dwMode;

    if(!m_pListener && DS3DMODE_NORMAL == dwMode)
    {
        dwMode = DS3DMODE_HEADRELATIVE;
    }

    if(DS3DMODE_NORMAL == dwMode)
    {
        fOk = GetHeadRelativeVector(&vHrp, 
                                    &m_opCurrent.vPosition, 
                                    &m_pListener->m_lpCurrent.vPosition, 
                                    m_rotation.pitch, 
                                    m_rotation.yaw, 
                                    m_rotation.roll);
    }
    else if(DS3DMODE_HEADRELATIVE == dwMode)
    {
        vHrp = m_opCurrent.vPosition;
    }
    else
    {
        SET_EMPTY_VECTOR(vHrp);
    }

    if(fOk)
    {
        UpdateAlgorithmHrp(&vHrp);

        // Update properties
        UpdateConeAttenuation();
        UpdatePositionAttenuation();
    }
    else
    {
        // We'll assume the head is at the origin looking forward and
        // rightside up
        CartesianToSpherical(&(m_spherical.rho), 
                             &(m_spherical.theta), 
                             &(m_spherical.phi), 
                             &m_opCurrent.vPosition);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  IsAtMaxDistance
 *
 *  Description:
 *      Determines if the object is muted based on distance.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE if the object is at its maxiumum distance.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::IsAtMaxDistance"

BOOL
CSw3dObject::IsAtMaxDistance
(
    void
)
{
    BOOL                    fAtMaxDistance;

    DPF_ENTER();

    if(DS3DMODE_DISABLE != m_opCurrent.dwMode && m_fMuteAtMaxDistance)
    {
        fAtMaxDistance = m_fAtMaxDistance;
    }
    else
    {
        fAtMaxDistance = FALSE;
    }
        
    DPF_LEAVE(fAtMaxDistance);

    return fAtMaxDistance;
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Gives the 3D object first notification of an attenuation change
 *      to its owning buffer.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: attenuation values.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::SetAttenuation"

HRESULT 
CSw3dObject::SetAttenuation
(
    PDSVOLUMEPAN            pdsvp,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr;

    DPF_ENTER();

    // We should never have allowed panning on 3D buffers, but the first release of DS3D
    // allowed it and we had to maintain it for app-compat.  In DirectSound 8.0 and later
    // this flag combination is disallowed, but this code must live on anyway.
    hr = C3dObject::SetAttenuation(pdsvp, pfContinue);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Gives the 3D object first notification of a frequency change
 *      to its owning buffer.
 *
 *  Arguments:
 *      DWORD [in]: frequency value.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSw3dObject::SetFrequency"

HRESULT 
CSw3dObject::SetFrequency
(
    DWORD                   dwFrequency,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr;

    DPF_ENTER();

    m_dwUserFrequency = dwFrequency;
    hr = Recalc(0, DS3DPARAM_OBJECT_FREQUENCY);

    if(SUCCEEDED(hr))
    {
        *pfContinue = FALSE;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CHw3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHw3dObject::CHw3dObject"

CHw3dObject::CHw3dObject
(
    C3dListener *           pListener, 
    BOOL                    fMuteAtMaxDistance,
    BOOL                    fDopplerEnabled
)
    : C3dObject(pListener, GUID_NULL, fMuteAtMaxDistance, fDopplerEnabled)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CHw3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CHw3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CHw3dObject::~CHw3dObject"

CHw3dObject::~CHw3dObject(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CHw3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CItd3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::CItd3dObject"

CItd3dObject::CItd3dObject
(
    C3dListener *           pListener, 
    BOOL                    fMuteAtMaxDistance,
    BOOL                    fDopplerEnabled,
    DWORD                   dwUserFrequency
)
    : CSw3dObject(pListener, DS3DALG_ITD, fMuteAtMaxDistance, fDopplerEnabled, dwUserFrequency)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CItd3dObject);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CItd3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::~CItd3dObject"

CItd3dObject::~CItd3dObject(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CItd3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateConeAttenuation
 *
 *  Description:
 *      Updates object attenuation based on cone properties.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::UpdateConeAttenuation"

void 
CItd3dObject::UpdateConeAttenuation
(
    void
)
{
    FLOAT                   flShadow;

    DPF_ENTER();

    CSw3dObject::UpdateConeAttenuation();

    if(m_fInInnerCone)
    {
        // We're inside both cones.  Don't attenuate.
        flShadow = 1.0f;
    }
    else if(!m_fInOuterCone)
    {
        flShadow = SHADOW_CONE;
    }
    else
    {
        flShadow = 1.0f - (1.0f - SHADOW_CONE) * m_flHowFarOut;
    }

    // Update the FIR context
    m_ofcLeft.flConeAttenuation = m_ofcRight.flConeAttenuation = m_flAttenuation;
    m_ofcLeft.flConeShadow = m_ofcRight.flConeShadow = flShadow;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdatePositionAttenuation
 *
 *  Description:
 *      Updates object attenuation based on position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::UpdatePositionAttenuation"

void 
CItd3dObject::UpdatePositionAttenuation
(
    void
)
{
    FLOAT                   flAtt3dLeft;
    FLOAT                   flAtt3dRight;
    FLOAT                   flAttShadowLeft;
    FLOAT                   flAttShadowRight;
    FLOAT                   flScale;

    DPF_ENTER();

    CSw3dObject::UpdatePositionAttenuation();

    // Now figure out the attenuations based on the position of the object
    // about your head.  We have constants defined for the attenuation and 
    // dry/wet mix you get when the object is exactly in front, rear, 
    // beside each ear, straight up, or straight down.  Interpolate in 
    // between these values to get the attenuation we will use.
    if(0.0f == m_spherical.rho)
    {
        // Sound is on top of you, well, not above I mean in the same spot, well,
        // you know what I mean
        flAtt3dLeft = flAtt3dRight = GAIN_IPSI;
        flAttShadowLeft = flAttShadowRight = SHADOW_IPSI;
    }
    else if(m_spherical.theta >= 0.0f && m_spherical.theta <= PI_OVER_TWO)
    {
        // Everything is in above you on your right
        flScale = m_spherical.theta * TWO_OVER_PI;
        flAtt3dLeft = GAIN_CONTRA + flScale * (GAIN_UP - GAIN_CONTRA);
        flAtt3dRight = GAIN_IPSI + flScale * (GAIN_UP - GAIN_IPSI);
        flAttShadowLeft = SHADOW_CONTRA + flScale * (SHADOW_UP - SHADOW_CONTRA);
        flAttShadowRight = SHADOW_IPSI + flScale * (SHADOW_UP - SHADOW_IPSI);
    }
    else if(m_spherical.theta > PI_OVER_TWO && m_spherical.theta <= PI)
    {
        // Sound is in above you on your left
        flScale = (m_spherical.theta - PI_OVER_TWO) * TWO_OVER_PI;
        flAtt3dLeft = GAIN_UP + flScale * (GAIN_IPSI - GAIN_UP);
        flAtt3dRight = GAIN_UP + flScale * (GAIN_CONTRA - GAIN_UP);
        flAttShadowLeft = SHADOW_UP + flScale * (SHADOW_IPSI - SHADOW_UP);
        flAttShadowRight = SHADOW_UP + flScale * (SHADOW_CONTRA - SHADOW_UP);
    }
    else if(m_spherical.theta > PI && m_spherical.theta <= THREE_PI_OVER_TWO)
    {
        // Sound is in below you on your left
        flScale = (m_spherical.theta - PI) * TWO_OVER_PI;
        flAtt3dLeft = GAIN_IPSI + flScale * (GAIN_DOWN - GAIN_IPSI);
        flAtt3dRight = GAIN_CONTRA + flScale * (GAIN_DOWN - GAIN_CONTRA);
        flAttShadowLeft = SHADOW_IPSI + flScale * (SHADOW_DOWN - SHADOW_IPSI);
        flAttShadowRight = SHADOW_CONTRA + flScale * (SHADOW_DOWN - SHADOW_CONTRA);
    }
    else
    {
        // Sound is in below you on your right
        flScale = (m_spherical.theta - THREE_PI_OVER_TWO) * TWO_OVER_PI;
        flAtt3dLeft = GAIN_DOWN + flScale * (GAIN_CONTRA - GAIN_DOWN);
        flAtt3dRight = GAIN_DOWN + flScale * (GAIN_IPSI - GAIN_DOWN);
        flAttShadowLeft = SHADOW_DOWN + flScale * (SHADOW_CONTRA - SHADOW_DOWN);
        flAttShadowRight = SHADOW_DOWN + flScale * (SHADOW_IPSI - SHADOW_DOWN);
    }

    if(m_spherical.phi < 0.0f)
    {
        // Sound is behind you
        flScale = m_spherical.phi * TWO_OVER_PI;
        flAtt3dLeft = flAtt3dLeft + flScale * (flAtt3dLeft - GAIN_REAR);
        flAtt3dRight = flAtt3dRight + flScale * (flAtt3dRight - GAIN_REAR);
        flAttShadowLeft = flAttShadowLeft + flScale * (flAttShadowLeft - SHADOW_REAR);
        flAttShadowRight = flAttShadowRight + flScale * (flAttShadowRight - SHADOW_REAR);
    }
    else if(m_spherical.phi > 0.0f)
    {
        // Sound is in front of you
        flScale = m_spherical.phi * TWO_OVER_PI;
        flAtt3dLeft = flAtt3dLeft - flScale * (flAtt3dLeft - GAIN_FRONT);
        flAtt3dRight = flAtt3dRight - flScale * (flAtt3dRight - GAIN_FRONT);
        flAttShadowLeft = flAttShadowLeft - flScale * (flAttShadowLeft - SHADOW_FRONT);
        flAttShadowRight = flAttShadowRight - flScale * (flAttShadowRight - SHADOW_FRONT);
    }

    // Update FIR context
    m_ofcLeft.flDistanceAttenuation = m_ofcRight.flDistanceAttenuation = m_flAttDistance;
    m_ofcLeft.flPositionAttenuation = m_flAttDistance * flAtt3dLeft;
    m_ofcRight.flPositionAttenuation = m_flAttDistance * flAtt3dRight;
    m_ofcLeft.flPositionShadow = flAttShadowLeft;
    m_ofcRight.flPositionShadow = flAttShadowRight;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateAlgorithmHrp
 *
 *  Description:
 *      Updates ITD algorithm specific head-relative position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::UpdateAlgorithmHrp"

void 
CItd3dObject::UpdateAlgorithmHrp
(
    D3DVECTOR *             pvHrp
)
{
    FLOAT                   flDelay;
    FLOAT                   flDistanceFactor;
    DWORD                   dwOutputSampleRate;

    DPF_ENTER();

    CartesianToSpherical(&(m_spherical.rho), 
                         &(m_spherical.theta), 
                         &(m_spherical.phi), 
                         pvHrp);

    // Now, figure out how much to phase shift to give 3D effect
    dwOutputSampleRate = Get3dOutputSampleRate();
    ASSERT(dwOutputSampleRate);

    if(m_pListener)
    {
        flDistanceFactor = m_pListener->m_lpCurrent.flDistanceFactor;
    }
    else
    {
        flDistanceFactor = DS3D_DEFAULTDISTANCEFACTOR;
    }
    
    GetTimeDelay(&flDelay, pvHrp, flDistanceFactor);

    if(flDelay > 0.0f)
    {
        m_ofcLeft.dwDelay = 0;
        m_ofcRight.dwDelay = (DWORD)(flDelay * dwOutputSampleRate);
    }
    else
    {
        m_ofcLeft.dwDelay = (DWORD)(-flDelay * dwOutputSampleRate);
        m_ofcRight.dwDelay = 0;
    }


    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateHrp
 *
 *  Description:
 *      Updates object head-relative position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::UpdateHrp"

void 
CItd3dObject::UpdateHrp
(
    void
)
{

    DPF_ENTER();

    // Reset the delays in case UpdateHrp cannot.
    m_ofcLeft.dwDelay = 0;
    m_ofcRight.dwDelay = 0;

    CSw3dObject::UpdateHrp();
}


/***************************************************************************
 *
 *  UpdateDoppler
 *
 *  Description:
 *      Updates doppler shift.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CItd3dObject::UpdateDoppler"

void 
CItd3dObject::UpdateDoppler
(
    void
)
{

    DPF_ENTER();

    CSw3dObject::UpdateDoppler();

    // We will do volume changes smoothly at 6dB per 1/8 second
    m_ofcRight.dwSmoothFreq = m_dwDopplerFrequency;
    m_ofcLeft.dwSmoothFreq = m_ofcRight.dwSmoothFreq;

    m_ofcRight.flVolSmoothScale = (FLOAT)pow2(8.0f / m_dwDopplerFrequency);
    m_ofcLeft.flVolSmoothScale = m_ofcRight.flVolSmoothScale;

    m_ofcRight.flVolSmoothScaleRecip = 1.0f / m_ofcLeft.flVolSmoothScale;
    m_ofcLeft.flVolSmoothScaleRecip = m_ofcRight.flVolSmoothScaleRecip;

    DPF_LEAVE_VOID();
}

/***************************************************************************
 *    
 *  CIir3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIir3dObject::CIir3dObject"

CIir3dObject::CIir3dObject
(
    C3dListener *           pListener, 
    REFGUID                 guid3dAlgorithm,
    BOOL                    fMuteAtMaxDistance,
    BOOL                    fDopplerEnabled,
    DWORD                   dwUserFrequency
)
    : CSw3dObject(pListener, guid3dAlgorithm, fMuteAtMaxDistance, fDopplerEnabled, dwUserFrequency)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CIir3dObject);

    // Initialize defaults
    m_pLut = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CIir3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIir3dObject::~CIir3dObject"

CIir3dObject::~CIir3dObject
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CIir3dObject);

    // Free memory
    DELETE(m_pLut);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the 3D object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIir3dObject::Initialize"

HRESULT 
CIir3dObject::Initialize
(
    void
)
{
    HRESULT                     hr;
    KSDS3D_HRTF_COEFF_FORMAT    cfCoeffFormat;
    KSDS3D_HRTF_FILTER_QUALITY  FilterQuality;
    KSDS3D_HRTF_FILTER_METHOD   fmFilterMethod;
    ULONG                       ulMaxBiquads;
    ULONG                       ulFilterTransitionMuteLength;
    ULONG                       ulFilterOverlapBufferLength;
    ULONG                       ulOutputOverlapBufferLength;
    ESampleRate                 IirSampleRate;
    
    DPF_ENTER();

    if(m_pLut)
    {
        // Free memory
        DELETE(m_pLut);
    }

    m_fUpdatedCoeffs = FALSE;

    // Create the IIR filter look up table object
    m_pLut = NEW(CIirLut);
    hr = HRFROMP(m_pLut);

    // Determine which filter coefficient format
    // the hardware or kmixer wants and initialize
    // the LUT appropriately.
    if(SUCCEEDED(hr))
    {
        hr = GetFilterMethodAndCoeffFormat(&fmFilterMethod,&cfCoeffFormat);
    }

    if(SUCCEEDED(hr))
    {
        if(DS3DALG_HRTF_LIGHT == m_guid3dAlgorithm)
        {
            FilterQuality = LIGHT_FILTER;
        }
        else if(DS3DALG_HRTF_FULL == m_guid3dAlgorithm)
        {
            FilterQuality = FULL_FILTER;
        }
        else
        {
            ASSERT(0);
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = 
            m_pLut->Initialize
            (
                cfCoeffFormat, 
                FilterQuality,
                m_pListener->m_dwSpeakerConfig  // Could also include Sample rate here.
            );
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pLut->DsFrequencyToIirSampleRate(m_dwUserFrequency, &IirSampleRate);
    }

    // Initialize the maximum number of coefficients.
    if(SUCCEEDED(hr))
    {
        ulMaxBiquads = m_pLut->GetMaxBiquadCoeffs();
        ulFilterTransitionMuteLength = m_pLut->GetFilterTransitionMuteLength(FilterQuality, IirSampleRate);
        ulFilterOverlapBufferLength = m_pLut->GetFilterOverlapBufferLength(FilterQuality, IirSampleRate);
        ulOutputOverlapBufferLength = m_pLut->GetOutputOverlapBufferLength(IirSampleRate);

        hr = InitializeFilters
             (
                 FilterQuality, 
                 (FLOAT)m_dwUserFrequency,  
                 NumBiquadsToNumCanonicalCoeffs(ulMaxBiquads),
                 ulFilterTransitionMuteLength,
                 ulFilterOverlapBufferLength,
                 ulOutputOverlapBufferLength
             );
    }

    // Initialize the base class
    if(SUCCEEDED(hr))
    {
        hr = C3dObject::Initialize();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UpdateAlgorithmHrp
 *
 *  Description:
 *      Updates IIR 3D algorithm specific head-relative position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIir3dObject::UpdateAlgorithmHrp"

void CIir3dObject::UpdateAlgorithmHrp
(
    D3DVECTOR *             pvHrp
)
{
    ESampleRate             eSampleRate;
    FLOAT                   flAzimuth;
    FLOAT                   flElevation;
    FLOAT                   flRho;
    BOOL                    fUpdatedSigmaCoeffs;
    BOOL                    fUpdatedDeltaCoeffs;

    DPF_ENTER();

    //Parameter validation
    if (pvHrp == NULL)
        return;
        
    // We need to recalculate m_spherical here.
    // This is a good candidate for optimization!

    CartesianToSpherical(&(m_spherical.rho), 
                         &(m_spherical.theta), 
                         &(m_spherical.phi), 
                         pvHrp);

    CartesianToAzimuthElevation(&flRho, 
                         &flAzimuth, 
                         &flElevation, 
                         pvHrp);

    flAzimuth = flAzimuth * 180.0f / PI;  // convert to degrees
    flElevation = flElevation * 180.0f / PI;

    if(flAzimuth > Cd3dvalMaxAzimuth)
    {
        flAzimuth = Cd3dvalMaxAzimuth; 
    }

    if(flAzimuth < Cd3dvalMinAzimuth) 
    {
        flAzimuth = Cd3dvalMinAzimuth; 
    }

    if(flElevation > Cd3dvalMaxElevationData)
    {
        flElevation = Cd3dvalMaxElevationData; 
    }

    if(flElevation < Cd3dvalMinElevationData)
    {
        flElevation = Cd3dvalMinElevationData; 
    }

    if(m_dwDopplerFrequency >= 46050)  // mean of 44.1 and 48 kHz
    {
        eSampleRate = tag48000Hz;
    }
    else if(46050>m_dwDopplerFrequency && m_dwDopplerFrequency >= 38050) // mean of 32.0 and 44.1 kHz
    {
        eSampleRate = tag44100Hz;
    }
    else if(38050>m_dwDopplerFrequency && m_dwDopplerFrequency >= 27025) // mean of 22.05 and 32.0 kHz
    {
        eSampleRate = tag32000Hz;
    }
    else if(27025>m_dwDopplerFrequency &&  m_dwDopplerFrequency > 19025)  // mean of 16.0 and 22.050 kHz
    {
        eSampleRate = tag22050Hz;
    }
    else if(19025>m_dwDopplerFrequency &&  m_dwDopplerFrequency > 13512.50)  // mean of 11.025 and 16.0 kHz
    {
        eSampleRate = tag16000Hz;
    }
    else if(13512.5>m_dwDopplerFrequency &&  m_dwDopplerFrequency > 9512.50)  // mean of 8.0 and 11.025 kHz
    {
        eSampleRate = tag11025Hz;
    }
    else
    {
        eSampleRate = tag8000Hz;
    }

    fUpdatedDeltaCoeffs = 
        m_pLut->HaveCoeffsChanged
        (
            flAzimuth,      
            flElevation,      
            eSampleRate,
            tagDelta
         );

    fUpdatedSigmaCoeffs = 
        m_pLut->HaveCoeffsChanged
        (
            flAzimuth,      
            flElevation,      
            eSampleRate,
            tagSigma
         );

    m_fUpdatedCoeffs = fUpdatedDeltaCoeffs 
                       | fUpdatedSigmaCoeffs;

    if(flAzimuth < 0.0f)
    {
        m_fSwapChannels = TRUE;
    }
    else
    {
        m_fSwapChannels = FALSE;
    }       

    if(fUpdatedDeltaCoeffs)
    {
        m_pDeltaCoeffs =
            m_pLut->GetCoeffs
            (
                flAzimuth, 
                flElevation,  
                eSampleRate, 
                tagDelta, 
                &m_ulNumDeltaCoeffs
            );
    }

    if(fUpdatedSigmaCoeffs)
    {
        m_pSigmaCoeffs =
            m_pLut->GetCoeffs
            (
                flAzimuth, 
                flElevation, 
                eSampleRate, 
                tagSigma, 
                &m_ulNumSigmaCoeffs
            );

    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *    
 *  CPan3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener* [in]: (passed on to our base constructor)
 *      BOOL [in]:         (passed on to our base constructor)
 *      DWORD [in]:        (passed on to our base constructor)
 *      CSecondaryRenderWaveBuffer* [in]: buffer we're associated to
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::CPan3dObject"

CPan3dObject::CPan3dObject
(
    C3dListener *                   pListener, 
    BOOL                            fMuteAtMaxDistance,
    BOOL                            fDopplerEnabled,
    DWORD                           dwFrequency,
    CSecondaryRenderWaveBuffer *    pBuffer
)
    : CSw3dObject(pListener, DS3DALG_NO_VIRTUALIZATION, fMuteAtMaxDistance, fDopplerEnabled, dwFrequency)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CPan3dObject);

    // Intialize defaults
    m_pBuffer = pBuffer;
    m_flPowerRight = 0.5f;
    m_lUserVolume = DSBVOLUME_MAX;
    m_fUserMute = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CPan3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::~CPan3dObject"

CPan3dObject::~CPan3dObject
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CPan3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Gives the 3D object first notification of an attenuation change
 *      to its owning buffer.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: attenuation values.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::SetAttenuation"

HRESULT 
CPan3dObject::SetAttenuation
(
    PDSVOLUMEPAN            pdsvp,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr;

    DPF_ENTER();

    m_lUserVolume = pdsvp->lVolume;
    
    hr = Commit3dChanges();

    if(SUCCEEDED(hr))
    {
        *pfContinue = FALSE;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Gives the 3D object first notification of a mute status change
 *      to its owning buffer.
 *
 *  Arguments:
 *      BOOL [in]: mute value.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::SetMute"

HRESULT 
CPan3dObject::SetMute
(
    BOOL                    fMute,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr;

    DPF_ENTER();

    m_fUserMute = fMute;

    hr = Commit3dChanges();

    if(SUCCEEDED(hr))
    {
        *pfContinue = FALSE;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UpdateAlgorithmHrp
 *
 *  Description:
 *      Updates Pan algorithm specific head-relative position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::UpdateAlgorithmHrp"

void 
CPan3dObject::UpdateAlgorithmHrp
(    
    D3DVECTOR *             pvHrp
)
{
    DPF_ENTER();

    // m_spherical.theta and .phi are unused for Pan3D, so here we
    // just need to update m_spherical.rho (used by our base class).
    
    if (pvHrp->x == 0 && pvHrp->y == 0 && pvHrp->z == 0)
    {
        m_spherical.rho = 0.f;
        m_flPowerRight = 0.5f;
    }
    else
    {
        m_spherical.rho = MagnitudeVector(pvHrp);
        m_flPowerRight = pvHrp->x / (2.0f * m_spherical.rho) + 0.5f;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Commit3dChanges
 *
 *  Description:
 *      Commits 3D data to the device
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::Commit3dChanges"

HRESULT 
CPan3dObject::Commit3dChanges
(
    void
)
{
    HRESULT                 hr                      = DS_OK;
    DSVOLUMEPAN             dsvp;
    BOOL                    fMute;
    DWORD                   dwFrequency;

    DPF_ENTER();

    // Calculate values
    if(DS3DMODE_DISABLE == m_opCurrent.dwMode)
    {
        dsvp.lVolume = m_lUserVolume;
        dsvp.lPan = DSBPAN_CENTER;
        fMute = m_fUserMute;
        dwFrequency = m_dwUserFrequency;
    }
    else
    {
        dsvp.lVolume = m_lUserVolume + CalculateVolume();
        dsvp.lPan = CalculatePan();
        fMute = (m_fUserMute || (DSBVOLUME_MIN == dsvp.lVolume));
        dwFrequency = m_dwDopplerFrequency;
    }
    
    // Apply values
    FillDsVolumePan(dsvp.lVolume, dsvp.lPan, &dsvp);
    
    hr = m_pBuffer->SetAttenuation(&dsvp);

    if(SUCCEEDED(hr))
    {
        hr = m_pBuffer->SetMute(fMute);
    }

    if(SUCCEEDED(hr) && m_fDopplerEnabled)
    {
        hr = m_pBuffer->SetBufferFrequency(dwFrequency, TRUE);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CalculateVolume
 *
 *  Description:
 *      Calculates a volume value based on object position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      LONG: Volume.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::CalculateVolume"

LONG
CPan3dObject::CalculateVolume
(
    void
)
{
    const double            dbLog10_2       = 0.30102999566398;  // log10(2.0)
    double                  dbAttenuation;
    LONG                    lVolume;
    
    DPF_ENTER();
    
    if(IsAtMaxDistance())
    {
        lVolume = DSBVOLUME_MIN;
    }
    else
    {
        dbAttenuation = m_flAttenuation * m_flAttDistance;
        
        if(0.0 < dbAttenuation)
        {
            lVolume = (LONG)(dbLog10_2 * fylog2x(2000.0, dbAttenuation));
            // Reduce the volume to roughly match the HRTF algorithm's level:
            lVolume -= PAN3D_HRTF_ADJUSTMENT;
        }
        else
        {
            lVolume = DSBVOLUME_MIN;
        }
    }

    DPF_LEAVE(lVolume);

    return lVolume;
}


/***************************************************************************
 *
 *  CalculatePan
 *
 *  Description:
 *      Calculates a pan value based on object position.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      LONG: Pan.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPan3dObject::CalculatePan"

LONG
CPan3dObject::CalculatePan
(
    void
)
{
    const double            dbLog10_2       = 0.30102999566398;  // log10(2.0)
    LONG                    lPan;
    
    DPF_ENTER();
    
    if(m_flPowerRight >= 0.5)
    {
        if(m_flPowerRight < 1.0)
        {
            // The magic number 3000 comes from
            // (K * 100 * 10)*log10(-2.0 * m_flPowerRight + 2.0)
            // where K = 3 was tweeked to give a nice transition 
            // ( not to sharp when crossing azimuth = 0) but not
            // creating a discontinuity on the extremes 
            // (azimuth ~= +/- 90 degrees).
            lPan = -(LONG)(dbLog10_2 * fylog2x(3000.0, -2.0 * m_flPowerRight + 2.0)); 
        }
        else
        {
            lPan = DSBPAN_RIGHT;
        }
    }
    else
    {
        if(m_flPowerRight > 0.0)
        {
            // The magic number 3000 comes from
            // (K * 100 * 10)*log10(2.0 * m_flPowerRight)
            // where K = 3 was tweeked to give a nice transition 
            // ( not to sharp when crossing azimuth = 0) but not
            // creating a discontinuity on the extremes 
            // (azimuth ~= +/- 90 degrees).
            lPan = (LONG)(dbLog10_2 * fylog2x(3000.0, 2.0 * m_flPowerRight));
        }
        else
        {
            lPan = DSBPAN_LEFT;
        }
    }

    DPF_LEAVE(lPan);

    return lPan;
}


/***************************************************************************
 *
 *  CWrapper3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *      REFGUID [in]: 3D algorithm.
 *      DWORD [in]: buffer frequency.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::CWrapper3dObject"

CWrapper3dObject::CWrapper3dObject
(
    C3dListener *           pListener,
    REFGUID                 guid3dAlgorithm,
    BOOL                    fMute3dAtMaxDistance,
    BOOL                    fDopplerEnabled,
    DWORD                   dwFrequency
)
    : C3dObject(pListener, guid3dAlgorithm, fMute3dAtMaxDistance, fDopplerEnabled)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CWrapper3dObject);

    // Initialize defaults
    m_p3dObject = NULL;
    m_dwUserFrequency = dwFrequency;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CWrapper3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::~CWrapper3dObject"

CWrapper3dObject::~CWrapper3dObject(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CWrapper3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SetObjectPointer
 *
 *  Description:
 *      Sets the real 3D object pointer.
 *
 *  Arguments:
 *      C3dObject * [in]: 3D object pointer.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetObjectPointer"

HRESULT 
CWrapper3dObject::SetObjectPointer
(
    C3dObject               *p3dObject
)
{
    HRESULT                 hr  = DS_OK;
    BOOL                    f;
    
    DPF_ENTER();

    // Update the listener's world
    if(p3dObject)
    {
        m_pListener->RemoveObjectFromList(p3dObject);
    }

    // Commit all settings to the new object
    if(p3dObject)
    {
        p3dObject->m_dwDeferred = m_dwDeferred;

        CopyMemory(&p3dObject->m_opDeferred, &m_opDeferred, sizeof(m_opDeferred));
    }

    if(p3dObject)
    {
        hr = p3dObject->SetAllParameters(&m_opCurrent, TRUE);
    }

    if(SUCCEEDED(hr) && p3dObject)
    {
        hr = p3dObject->SetAttenuation(&m_dsvpUserAttenuation, &f);
    }

    if(SUCCEEDED(hr) && p3dObject)
    {
        hr = p3dObject->SetFrequency(m_dwUserFrequency, &f);
    }

    if(SUCCEEDED(hr) && p3dObject)
    {
        hr = p3dObject->SetMute(m_fUserMute, &f);
    }

    // Save a pointer to the object
    if(SUCCEEDED(hr))
    {
        m_p3dObject = p3dObject;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitDeferred
 *
 *  Description:
 *      Commits deferred data to the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::CommitDeferred"

HRESULT 
CWrapper3dObject::CommitDeferred
(
    void
)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    hr = C3dObject::CommitDeferred();

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->CommitDeferred();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeAngles
 *
 *  Description:
 *      Sets sound cone angles.
 *
 *  Arguments:
 *      DWORD [in]: inside cone angle.
 *      DWORD [in]: outside cone angle.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetConeAngles"

HRESULT 
CWrapper3dObject::SetConeAngles
(
    DWORD                   dwInsideConeAngle, 
    DWORD                   dwOutsideConeAngle, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetConeAngles(dwInsideConeAngle, dwOutsideConeAngle, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetConeAngles(dwInsideConeAngle, dwOutsideConeAngle, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeOrientation
 *
 *  Description:
 *      Sets sound cone orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: orientation.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetConeOrientation"

HRESULT 
CWrapper3dObject::SetConeOrientation
(
    REFD3DVECTOR            vConeOrientation, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetConeOrientation(vConeOrientation, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetConeOrientation(vConeOrientation, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeOutsideVolume
 *
 *  Description:
 *      Sets volume outside the sound cone.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetConeOutsideVolume"

HRESULT 
CWrapper3dObject::SetConeOutsideVolume
(
    LONG                    lConeOutsideVolume, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetConeOutsideVolume(lConeOutsideVolume, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetConeOutsideVolume(lConeOutsideVolume, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMaxDistance
 *
 *  Description:
 *      Sets the maximum object distance from the listener.
 *
 *  Arguments:
 *      FLOAT [in]: max distance.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetMaxDistance"

HRESULT 
CWrapper3dObject::SetMaxDistance
(
    FLOAT                   flMaxDistance, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetMaxDistance(flMaxDistance, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetMaxDistance(flMaxDistance, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMinDistance
 *
 *  Description:
 *      Sets the minimum object distance from the listener.
 *
 *  Arguments:
 *      FLOAT [in]: min distance.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetMinDistance"

HRESULT 
CWrapper3dObject::SetMinDistance
(
    FLOAT                   flMinDistance, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetMinDistance(flMinDistance, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetMinDistance(flMinDistance, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the object mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetMode"

HRESULT 
CWrapper3dObject::SetMode
(
    DWORD                   dwMode, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetMode(dwMode, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetMode(dwMode, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the object position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetPosition"

HRESULT 
CWrapper3dObject::SetPosition
(
    REFD3DVECTOR            vPosition, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetPosition(vPosition, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetPosition(vPosition, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the object velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR[in]: velocity.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetVelocity"

HRESULT 
CWrapper3dObject::SetVelocity
(
    REFD3DVECTOR            vVelocity, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetVelocity(vVelocity, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetVelocity(vVelocity, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all object parameters.
 *
 *  Arguments:
 *      LPCDS3DBUFFER [in]: object parameters.
 *      BOOL [in]: TRUE to commit immediately.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetAllParameters"

HRESULT 
CWrapper3dObject::SetAllParameters
(
    LPCDS3DBUFFER           pParams, 
    BOOL                    fCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = C3dObject::SetAllParameters(pParams, fCommit);

    if(SUCCEEDED(hr) && m_p3dObject)
    {
        hr = m_p3dObject->SetAllParameters(pParams, fCommit);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Gives the 3D object first notification of an attenuation change
 *      to its owning buffer.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: attenuation values.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetAttenuation"

HRESULT 
CWrapper3dObject::SetAttenuation
(
    PDSVOLUMEPAN            pdsvp,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr;

    DPF_ENTER();

    if(m_p3dObject)
    {
        hr = m_p3dObject->SetAttenuation(pdsvp, pfContinue);
    }
    else
    {
        CopyMemory(&m_dsvpUserAttenuation, pdsvp, sizeof(*pdsvp));
        hr = C3dObject::SetAttenuation(pdsvp, pfContinue);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Gives the 3D object first notification of a frequency change
 *      to its owning buffer.
 *
 *  Arguments:
 *      DWORD [in]: frequency value.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetFrequency"

HRESULT 
CWrapper3dObject::SetFrequency
(
    DWORD                   dwFrequency,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(m_p3dObject)
    {
        hr = m_p3dObject->SetFrequency(dwFrequency, pfContinue);
    }
    else
    {
        m_dwUserFrequency = dwFrequency;
        hr = C3dObject::SetFrequency(dwFrequency, pfContinue);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Gives the 3D object first notification of a mute status change
 *      to its owning buffer.
 *
 *  Arguments:
 *      BOOL [in]: mute value.
 *      LPBOOL [out]: receives TRUE if the buffer should be notified as 
 *                    well.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::SetMute"

HRESULT 
CWrapper3dObject::SetMute
(
    BOOL                    fMute,
    LPBOOL                  pfContinue
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(m_p3dObject)
    {
        hr = m_p3dObject->SetMute(fMute, pfContinue);
    }
    else
    {
        m_fUserMute = fMute;
        hr = C3dObject::SetMute(fMute, pfContinue);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetObjectLocation
 *
 *  Description:
 *      Gets the object's location (i.e. software/hardware).
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: DSBCAPS_LOC* flags representing the object's processing
 *             location.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::GetObjectLocation"

DWORD 
CWrapper3dObject::GetObjectLocation(void)
{
    DWORD                   dwLocation;
    
    DPF_ENTER();

    if(m_p3dObject)
    {
        dwLocation = m_p3dObject->GetObjectLocation();
    }
    else
    {
        dwLocation = DSBCAPS_LOCSOFTWARE;
    }

    DPF_LEAVE(dwLocation);

    return dwLocation;
}


/***************************************************************************
 *
 *  Recalc
 *
 *  Description:
 *      Recalculates and applies the object's data based on changed object 
 *      or listener valiues.
 *
 *  Arguments:
 *      DWORD [in]: changed listener settings.
 *      DWORD [in]: changed object settings.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWrapper3dObject::Recalc"

HRESULT 
CWrapper3dObject::Recalc
(
   DWORD                    dwListener, 
   DWORD                    dwObject
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // We only want to recalc listener settings from here.  All other calls
    // to Recalc come from within C3dObject methods.
    if(m_p3dObject && dwListener)
    {
        hr = m_p3dObject->Recalc(dwListener, 0);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\ds3d.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ds3d.h
 *  Content:    DirectSound 3D helper objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  3/12/97     dereks  Created
 *
 ***************************************************************************/

#ifndef __DS3D_H__
#define __DS3D_H__

// How does overall volume change based on position?
#define GAIN_FRONT                  0.9f
#define GAIN_REAR                   0.6f
#define GAIN_IPSI                   1.f
#define GAIN_CONTRA                 0.2f
#define GAIN_UP                     0.8f
#define GAIN_DOWN                   0.5f

// How does dry/wet mix change based on position?
#define SHADOW_FRONT                1.f
#define SHADOW_REAR                 0.5f
#define SHADOW_IPSI                 1.f
#define SHADOW_CONTRA               0.2f
#define SHADOW_UP                   0.8f
#define SHADOW_DOWN                 0.2f

// Max wet/dry mix when outside cone
#define SHADOW_CONE                 0.5f

// A constant representing the average volume difference between the
// Pan3D and VMAX HRTF 3D processing algorithms, in 1/100ths of a dB:
#define PAN3D_HRTF_ADJUSTMENT       500

// Dirty bits
#define DS3DPARAM_LISTENER_DISTANCEFACTOR   0x00000001
#define DS3DPARAM_LISTENER_DOPPLERFACTOR    0x00000002
#define DS3DPARAM_LISTENER_ROLLOFFFACTOR    0x00000004
#define DS3DPARAM_LISTENER_ORIENTATION      0x00000008
#define DS3DPARAM_LISTENER_POSITION         0x00000010
#define DS3DPARAM_LISTENER_VELOCITY         0x00000020
#define DS3DPARAM_LISTENER_PARAMMASK        0x0000003F
#define DS3DPARAM_LISTENER_SPEAKERCONFIG    0x00000040
#define DS3DPARAM_LISTENER_MASK             0x0000007F

#define DS3DPARAM_OBJECT_CONEANGLES         0x00000001
#define DS3DPARAM_OBJECT_CONEORIENTATION    0x00000002
#define DS3DPARAM_OBJECT_CONEOUTSIDEVOLUME  0x00000004
#define DS3DPARAM_OBJECT_MAXDISTANCE        0x00000008
#define DS3DPARAM_OBJECT_MINDISTANCE        0x00000010
#define DS3DPARAM_OBJECT_MODE               0x00000020
#define DS3DPARAM_OBJECT_POSITION           0x00000040
#define DS3DPARAM_OBJECT_VELOCITY           0x00000080
#define DS3DPARAM_OBJECT_PARAMMASK          0x000000FF
#define DS3DPARAM_OBJECT_FREQUENCY          0x00000100
#define DS3DPARAM_OBJECT_MASK               0x000001FF

typedef FLOAT *LPFLOAT;

typedef struct tagSPHERICAL
{
    FLOAT               rho;
    FLOAT               theta;
    FLOAT               phi;
} SPHERICAL, *LPSPHERICAL;

typedef struct tagROTATION
{
    FLOAT               pitch;
    FLOAT               yaw;
    FLOAT               roll;
} ROTATION, *LPROTATION;

typedef struct tagOBJECT_ITD_CONTEXT
{
    FLOAT               flDistanceAttenuation;
    FLOAT               flConeAttenuation;
    FLOAT               flConeShadow;
    FLOAT               flPositionAttenuation;
    FLOAT               flPositionShadow;
    FLOAT               flVolSmoothScale;
    FLOAT               flVolSmoothScaleRecip;
    FLOAT               flVolSmoothScaleDry;
    FLOAT               flVolSmoothScaleWet;
    DWORD               dwSmoothFreq;
    DWORD               dwDelay;
} OBJECT_ITD_CONTEXT, *LPOBJECT_ITD_CONTEXT;

typedef struct tagOBJECT_IIR_CONTEXT
{
    BOOL                bReverseCoeffs;
    FLOAT               flCoeffs;
    FLOAT               flConeAttenuation;
    FLOAT               flConeShadow;
    FLOAT               flPositionAttenuation;
    FLOAT               flPositionShadow;
    FLOAT               flVolSmoothScale;
    FLOAT               flVolSmoothScaleRecip;
    FLOAT               flVolSmoothScaleDry;
    FLOAT               flVolSmoothScaleWet;
    DWORD               dwSmoothFreq;
    DWORD               dwDelay;
} OBJECT_IIR_CONTEXT, *LPOBJECT_IIR_CONTEXT;

#ifdef __cplusplus

// Reference typedefs
typedef const D3DVECTOR& REFD3DVECTOR;

// Fwd decl
class CVxdPropertySet;
class C3dObject;
class CIirLut;
class CSecondaryRenderWaveBuffer;

// Generic 3D listener base class
class C3dListener
    : public CDsBasicRuntime
{
    friend class C3dObject;
    friend class CSw3dObject;
    friend class CItd3dObject;
    friend class CIir3dObject;
    friend class CPan3dObject;

protected:
    CList<C3dObject *>  m_lstObjects;               // List of objects owned by this listener
    DS3DLISTENER        m_lpCurrent;                // Current parameters
    DS3DLISTENER        m_lpDeferred;               // Deferred parameters
    DWORD               m_dwDeferred;               // Lists dirty deferred parameters
    DWORD               m_dwSpeakerConfig;          // Speaker Config

public:
    C3dListener(void);
    virtual ~C3dListener(void);

public:
    // Commiting deferred data
    virtual HRESULT CommitDeferred(void);

    // Listener/world properties
    virtual HRESULT GetOrientation(D3DVECTOR*, D3DVECTOR*);
    virtual HRESULT SetOrientation(REFD3DVECTOR, REFD3DVECTOR, BOOL);
    virtual HRESULT GetPosition(D3DVECTOR*);
    virtual HRESULT SetPosition(REFD3DVECTOR, BOOL);
    virtual HRESULT GetVelocity(D3DVECTOR*);
    virtual HRESULT SetVelocity(REFD3DVECTOR, BOOL);
    virtual HRESULT GetDistanceFactor(LPFLOAT);
    virtual HRESULT SetDistanceFactor(FLOAT, BOOL);
    virtual HRESULT GetDopplerFactor(LPFLOAT);
    virtual HRESULT SetDopplerFactor(FLOAT, BOOL);
    virtual HRESULT GetRolloffFactor(LPFLOAT);
    virtual HRESULT SetRolloffFactor(FLOAT, BOOL);
    virtual HRESULT GetAllParameters(LPDS3DLISTENER);
    virtual HRESULT SetAllParameters(LPCDS3DLISTENER, BOOL);

    // Population
    virtual void AddObjectToList(C3dObject *);
    virtual void RemoveObjectFromList(C3dObject *);

    // Listener location
    virtual DWORD GetListenerLocation(void);

    // Speaker configuration
    virtual HRESULT GetSpeakerConfig(LPDWORD);
    virtual HRESULT SetSpeakerConfig(DWORD);

protected:
    virtual HRESULT CommitAllObjects(void);
    virtual HRESULT UpdateAllObjects(DWORD);
};

inline void C3dListener::AddObjectToList(C3dObject *pObject)
{
    m_lstObjects.AddNodeToList(pObject);
}

inline void C3dListener::RemoveObjectFromList(C3dObject *pObject)
{
    m_lstObjects.RemoveDataFromList(pObject);
}

inline HRESULT C3dListener::GetDistanceFactor(LPFLOAT pflDistanceFactor)
{
    *pflDistanceFactor = m_lpCurrent.flDistanceFactor;
    return DS_OK;
}

inline HRESULT C3dListener::GetDopplerFactor(LPFLOAT pflDopplerFactor)
{
    *pflDopplerFactor = m_lpCurrent.flDopplerFactor;
    return DS_OK;
}

inline HRESULT C3dListener::GetRolloffFactor(LPFLOAT pflRolloffFactor)
{
    *pflRolloffFactor = m_lpCurrent.flRolloffFactor;
    return DS_OK;
}

inline HRESULT C3dListener::GetOrientation(D3DVECTOR* pvFront, D3DVECTOR* pvTop)
{
    if(pvFront)
    {
        *pvFront = m_lpCurrent.vOrientFront;
    }

    if(pvTop)
    {
        *pvTop = m_lpCurrent.vOrientTop;
    }

    return DS_OK;
}

inline HRESULT C3dListener::GetPosition(D3DVECTOR* pvPosition)
{
    *pvPosition = m_lpCurrent.vPosition;
    return DS_OK;
}

inline HRESULT C3dListener::GetVelocity(D3DVECTOR* pvVelocity)
{
    *pvVelocity = m_lpCurrent.vVelocity;
    return DS_OK;
}

inline HRESULT C3dListener::GetAllParameters(LPDS3DLISTENER pParams)
{
    ASSERT(sizeof(*pParams) == pParams->dwSize);
    CopyMemoryOffset(pParams, &m_lpCurrent, sizeof(DS3DLISTENER), sizeof(pParams->dwSize));
    return DS_OK;
}

inline DWORD C3dListener::GetListenerLocation(void)
{
    return DSBCAPS_LOCSOFTWARE;
}

inline HRESULT C3dListener::GetSpeakerConfig(LPDWORD pdwConfig)
{
    *pdwConfig = m_dwSpeakerConfig;
    return DS_OK;
}

// Generic 3D object base class
class C3dObject
    : public CDsBasicRuntime
{
    friend class CWrapper3dObject;

protected:
    C3dListener *           m_pListener;            // Pointer to the listener that owns this object
    DS3DBUFFER              m_opCurrent;            // Current parameters
    DS3DBUFFER              m_opDeferred;           // Deferred parameters
    DWORD                   m_dwDeferred;           // Lists dirty deferred parameters
    GUID                    m_guid3dAlgorithm;      // 3D algorithm identifier
    BOOL                    m_fMuteAtMaxDistance;   // TRUE to mute 3D at max distance
    BOOL                    m_fDopplerEnabled;      // TRUE to allow Doppler processing

public:
    C3dObject(C3dListener *, REFGUID, BOOL, BOOL);
    virtual ~C3dObject(void);

public:
    // Initialization
    virtual HRESULT Initialize(void);

    // Commiting deferred data
    virtual HRESULT CommitDeferred(void);

    // Object properties
    virtual HRESULT GetConeAngles(LPDWORD, LPDWORD);
    virtual HRESULT GetConeOrientation(D3DVECTOR*);
    virtual HRESULT GetConeOutsideVolume(LPLONG);
    virtual HRESULT GetMaxDistance(LPFLOAT);
    virtual HRESULT GetMinDistance(LPFLOAT);
    virtual HRESULT GetMode(LPDWORD);
    virtual HRESULT GetPosition(D3DVECTOR*);
    virtual HRESULT GetVelocity(D3DVECTOR*);
    virtual HRESULT GetAllParameters(LPDS3DBUFFER);
    
    virtual HRESULT SetConeAngles(DWORD, DWORD, BOOL);
    virtual HRESULT SetConeOrientation(REFD3DVECTOR, BOOL);
    virtual HRESULT SetConeOutsideVolume(LONG, BOOL);
    virtual HRESULT SetMaxDistance(FLOAT, BOOL);
    virtual HRESULT SetMinDistance(FLOAT, BOOL);
    virtual HRESULT SetMode(DWORD, BOOL);
    virtual HRESULT SetPosition(REFD3DVECTOR, BOOL);
    virtual HRESULT SetVelocity(REFD3DVECTOR, BOOL);
    virtual HRESULT SetAllParameters(LPCDS3DBUFFER, BOOL);

    virtual C3dListener *GetListener(void);
    virtual REFGUID GetAlgorithm(void);

    // Object events
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN, LPBOOL);
    virtual HRESULT SetFrequency(DWORD, LPBOOL);
    virtual HRESULT SetMute(BOOL, LPBOOL);

    // Object calculation
    virtual HRESULT Recalc(DWORD, DWORD) = 0;
    virtual BOOL IsAtMaxDistance(void);

    // Object location
    virtual DWORD GetObjectLocation(void) = 0;
};

inline HRESULT C3dObject::GetConeAngles(LPDWORD pdwInside, LPDWORD pdwOutside) 
{ 
    if(pdwInside)
    {
        *pdwInside = m_opCurrent.dwInsideConeAngle; 
    }

    if(pdwOutside)
    {
        *pdwOutside = m_opCurrent.dwOutsideConeAngle; 
    }

    return DS_OK;
}

inline HRESULT C3dObject::GetConeOrientation(D3DVECTOR* pvConeOrientation)
{ 
    *pvConeOrientation = m_opCurrent.vConeOrientation;
    return DS_OK;
}

inline HRESULT C3dObject::GetConeOutsideVolume(LPLONG plConeOutsideVolume)
{
    *plConeOutsideVolume = m_opCurrent.lConeOutsideVolume;
    return DS_OK;
}

inline HRESULT C3dObject::GetMaxDistance(LPFLOAT pflMaxDistance)
{
    *pflMaxDistance = m_opCurrent.flMaxDistance;
    return DS_OK;
}

inline HRESULT C3dObject::GetMinDistance(LPFLOAT pflMinDistance)
{
    *pflMinDistance = m_opCurrent.flMinDistance;
    return DS_OK;
}

inline HRESULT C3dObject::GetMode(LPDWORD pdwMode)
{
    *pdwMode = m_opCurrent.dwMode;
    return DS_OK;
}

inline HRESULT C3dObject::GetPosition(D3DVECTOR* pvPosition)
{
    *pvPosition = m_opCurrent.vPosition;
    return DS_OK;
}

inline HRESULT C3dObject::GetVelocity(D3DVECTOR* pvVelocity)
{
    *pvVelocity = m_opCurrent.vVelocity;
    return DS_OK;
}

inline HRESULT C3dObject::GetAllParameters(LPDS3DBUFFER pParams)
{
    ASSERT(sizeof(*pParams) == pParams->dwSize);
    CopyMemoryOffset(pParams, &m_opCurrent, sizeof(DS3DBUFFER), sizeof(pParams->dwSize));
    return DS_OK;
}

inline C3dListener *C3dObject::GetListener(void)
{
    return m_pListener;
}

inline REFGUID C3dObject::GetAlgorithm(void)
{
    return m_guid3dAlgorithm;
}

inline HRESULT C3dObject::SetAttenuation(PDSVOLUMEPAN pdsvp, LPBOOL pfContinue)
{
    *pfContinue = TRUE;
    return DS_OK;
}

inline HRESULT C3dObject::SetFrequency(DWORD dwFrequency, LPBOOL pfContinue)
{
    *pfContinue = TRUE;
    return DS_OK;
}

inline HRESULT C3dObject::SetMute(BOOL fMute, LPBOOL pfContinue)
{
    *pfContinue = TRUE;
    return DS_OK;
}

// Software 3D object base class
class CSw3dObject
    : public C3dObject
{
protected:
    SPHERICAL               m_spherical;            // Spherical coordinates
    ROTATION                m_rotation;             // Object rotation
    DWORD                   m_dwUserFrequency;      // Last Buffer frequency set by the user
    DWORD                   m_dwDopplerFrequency;   // Last Buffer Doppler frequency
    BOOL                    m_fAtMaxDistance;       // TRUE if we're >= max distance
    BOOL                    m_fInInnerCone;         // TRUE if we're in the inner cone
    BOOL                    m_fInOuterCone;         // TRUE if we're in the outer cone
    FLOAT                   m_flAttenuation;        // 
    FLOAT                   m_flHowFarOut;          // 
    FLOAT                   m_flAttDistance;        // 

public:
    CSw3dObject(C3dListener *, REFGUID, BOOL, BOOL, DWORD);
    virtual ~CSw3dObject(void);

public:
    // Buffer recalc
    virtual HRESULT Recalc(DWORD, DWORD);

    // Object location
    virtual DWORD GetObjectLocation(void);

    // Object events
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN, LPBOOL);
    virtual HRESULT SetFrequency(DWORD, LPBOOL);

    // Object calculation
    virtual BOOL IsAtMaxDistance(void);

protected:
    // Nasty math
    virtual void UpdateConeAttenuation(void);
    virtual void UpdatePositionAttenuation(void);
    virtual void UpdateHrp(void);
    virtual void UpdateListenerOrientation(void);
    virtual void UpdateDoppler(void);
    virtual void UpdateAlgorithmHrp(D3DVECTOR *) = 0;

    // Writes data to the device
    virtual HRESULT Commit3dChanges(void) = 0;
};

inline DWORD CSw3dObject::GetObjectLocation(void)
{
    return DSBCAPS_LOCSOFTWARE;
}

// Hardware 3D object base class
class CHw3dObject
    : public C3dObject
{
public:
    CHw3dObject(C3dListener *, BOOL, BOOL);
    virtual ~CHw3dObject(void);

public:
    // Object location
    virtual DWORD GetObjectLocation(void);
};

inline DWORD CHw3dObject::GetObjectLocation(void)
{
    return DSBCAPS_LOCHARDWARE;
}

// Base class for all ITD 3D objects
class CItd3dObject
    : public CSw3dObject
{
protected:
    OBJECT_ITD_CONTEXT        m_ofcLeft;              // Left channel FIR context
    OBJECT_ITD_CONTEXT        m_ofcRight;             // Right channel FIR context

public:
    CItd3dObject(C3dListener *, BOOL, BOOL, DWORD);
    virtual ~CItd3dObject(void);

protected:
    // Nasty math
    virtual void UpdateConeAttenuation(void);
    virtual void UpdatePositionAttenuation(void);
    virtual void UpdateHrp(void);
    virtual void UpdateDoppler(void);
    virtual void UpdateAlgorithmHrp(D3DVECTOR *);

    // Writes data to the device
    virtual HRESULT Commit3dChanges(void) = 0;

    // Output buffer properties
    virtual DWORD Get3dOutputSampleRate(void) = 0;
};

// Base class for all IIR 3D objects
class CIir3dObject
    : public CSw3dObject
{
protected:
    CIirLut*                m_pLut;                  // IIR coefficient look up table
    OBJECT_IIR_CONTEXT      m_oicLeft;               // Left channel context
    OBJECT_IIR_CONTEXT      m_oicRight;              // Right channel context
    BOOL                    m_fUpdatedCoeffs;
    PVOID                   m_pSigmaCoeffs;
    UINT                    m_ulNumSigmaCoeffs;
    PVOID                   m_pDeltaCoeffs;
    UINT                    m_ulNumDeltaCoeffs;
    BOOL                    m_fSwapChannels;

public:
    CIir3dObject(C3dListener *, REFGUID, BOOL, BOOL, DWORD);
    virtual ~CIir3dObject(void);

public:
    // Initialization
    virtual HRESULT Initialize(void);

protected:
    // Nasty math
    virtual void UpdateAlgorithmHrp(D3DVECTOR *);

    // Writes data to the device
    virtual HRESULT Commit3dChanges(void) = 0;

    // Desired Filter Coefficient Format
    virtual HRESULT GetFilterMethodAndCoeffFormat(KSDS3D_HRTF_FILTER_METHOD*,KSDS3D_HRTF_COEFF_FORMAT*) = 0;
    virtual HRESULT InitializeFilters(KSDS3D_HRTF_FILTER_QUALITY, FLOAT, ULONG, ULONG, ULONG, ULONG) = 0;
};

// Simple stereo pan 3D object
class CPan3dObject
    : public CSw3dObject
{
private:
    CSecondaryRenderWaveBuffer *    m_pBuffer;
    FLOAT                           m_flPowerRight;
    LONG                            m_lUserVolume;
    BOOL                            m_fUserMute;

public:
    CPan3dObject(C3dListener *, BOOL, BOOL, DWORD, CSecondaryRenderWaveBuffer *);
    virtual ~CPan3dObject(void);

public:
    // Object events
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN, LPBOOL);
    virtual HRESULT SetMute(BOOL, LPBOOL);

private:
    // Nasty math
    virtual void UpdateAlgorithmHrp(D3DVECTOR *);
    virtual LONG CalculateVolume(void);
    virtual LONG CalculatePan(void);

    // Writes data to the device
    virtual HRESULT Commit3dChanges(void);
};

// Wrapper 3D object
class CWrapper3dObject
    : public C3dObject
{
protected:
    C3dObject *             m_p3dObject;            // Pointer to the real 3D object
    DSVOLUMEPAN             m_dsvpUserAttenuation;  // Last attenuation set by the user
    DWORD                   m_dwUserFrequency;      // Last buffer frequency set by the user
    BOOL                    m_fUserMute;            // Last mute status set by the user

public:
    CWrapper3dObject(C3dListener *, REFGUID, BOOL, BOOL, DWORD);
    virtual ~CWrapper3dObject(void);

public:
    // The actual 3D object
    virtual HRESULT SetObjectPointer(C3dObject *);

    // Commiting deferred data
    virtual HRESULT CommitDeferred(void);

    // Object properties
    virtual HRESULT SetConeAngles(DWORD, DWORD, BOOL);
    virtual HRESULT SetConeOrientation(REFD3DVECTOR, BOOL);
    virtual HRESULT SetConeOutsideVolume(LONG, BOOL);
    virtual HRESULT SetMaxDistance(FLOAT, BOOL);
    virtual HRESULT SetMinDistance(FLOAT, BOOL);
    virtual HRESULT SetMode(DWORD, BOOL);
    virtual HRESULT SetPosition(REFD3DVECTOR, BOOL);
    virtual HRESULT SetVelocity(REFD3DVECTOR, BOOL);
    virtual HRESULT SetAllParameters(LPCDS3DBUFFER, BOOL);

    // Buffer events
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN, LPBOOL);
    virtual HRESULT SetFrequency(DWORD, LPBOOL);
    virtual HRESULT SetMute(BOOL, LPBOOL);

    // Buffer recalc
    virtual HRESULT Recalc(DWORD, DWORD);

    // Object location
    virtual DWORD GetObjectLocation(void);
};

#endif // __cplusplus

#endif // __DS3D_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsadmin.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsadmin.h
 *  Content:    DirectSound Administrator
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/9/97      dereks  Created
 *  2/13/97     dereks  Focus manager reborn as Administrator.
 *
 ***************************************************************************/

#ifndef __DSADMIN_H__
#define __DSADMIN_H__

#include "streamer.h"

#ifndef SHARED
#define SHARED_THREAD_LIST
#endif

#define WAITDELAY_DEFAULT   500
#define WAITDELAY_CAPTURE   200

typedef struct tagDSCOOPERATIVELEVEL
{
    DWORD               dwThreadId;
    DWORD               dwPriority;
} DSCOOPERATIVELEVEL, *LPDSCOOPERATIVELEVEL;

typedef struct tagDSFOCUS
{
    HWND                hWnd;
    UINT                uState;
    BOOL                fApmSuspend;
} DSFOCUS, *LPDSFOCUS;

#ifdef SHARED_THREAD_LIST

typedef struct tagDSSHAREDTHREADLISTDATA
{
    DWORD               dwProcessId;
    DSCOOPERATIVELEVEL  dsclCooperativeLevel;
} DSSHAREDTHREADLISTDATA, *LPDSSHAREDTHREADLISTDATA;

typedef struct tagDSSHAREDCAPTUREFOCUSDATA
{
    DWORD               dwProcessId;
    HWND                hWndFocus;
    DWORD               fdwFlags;
} DSSHAREDCAPTUREFOCUSDATA, *LPDSSHAREDCAPTUREFOCUSDATA;

// Flags that can be used in the DSSHAREDCAPTUREFOCUSDATA.fdwFlags field
#define DSCBFLAG_UPDATE 0x00000100
#define DSCBFLAG_YIELD  0x00000200
#define DSCBFLAG_FOCUS  0x00000400
#define DSCBFLAG_STRICT 0x00000800

#endif // SHARED_THREAD_LIST

typedef enum
{
    DSBUFFERFOCUS_INFOCUS = 0,
    DSBUFFERFOCUS_OUTOFFOCUS,
    DSBUFFERFOCUS_LOST
} DSBUFFERFOCUS, *LPDSBUFFERFOCUS;

#ifdef __cplusplus

// Forward declarations
class CDirectSound;
class CClassFactory;
class CDirectSoundCapture;
class CDirectSoundFullDuplex;
class CDirectSoundBuffer;
class CDirectSoundBufferConfig;

// The DirectSound Administrator object
class CDirectSoundAdministrator
    : public CDsBasicRuntime, private CThread
{
public:
    CList<CDirectSound*>            m_lstDirectSound;       // List of DirectSound objects
    CList<CDirectSoundCapture*>     m_lstCapture;           // List of DirectSoundCapture objects
    CList<CDirectSoundFullDuplex*>  m_lstFullDuplex;        // List of DirectSoundFullDuplex objects
    CList<CDirectSoundSink*>        m_lstDirectSoundSink;   // List of DirectSoundSink objects
    CList<CDirectSoundBufferConfig*>m_lstDSBufferConfig;    // List of CDirectSoundBufferConfig objects
    CList<CClassFactory*>           m_lstClassFactory;      // List of ClassFactory objects

private:
    CRefCount                       m_rcThread;             // Thread reference count
    DSFOCUS                         m_dsfCurrent;           // Current focus state
    DSCOOPERATIVELEVEL              m_dsclCurrent;          // Cooperative level of window in focus
    DWORD                           m_dwWaitDelay;          // Amount of time set for wait
    ULONG                           m_ulConsoleSessionId;   // TS session currently owning the console
    
#ifdef SHARED
    HANDLE                          m_hApmSuspend;          // APM suspend event
#endif // SHARED

#ifdef SHARED_THREAD_LIST
    static const DWORD              m_dwSharedThreadLimit;  // Arbitrary limitation of threads in the shared list
    CSharedMemoryBlock *            m_pSharedThreads;       // Shared thread ID array
    static const DWORD              m_dwCaptureDataLimit;   // Arbitrary limitation of threads in the shared list
    CSharedMemoryBlock *            m_pCaptureFocusData;    // Shared thread ID array
#endif // SHARED_THREAD_LIST

public:
    CDirectSoundAdministrator(void);
    ~CDirectSoundAdministrator(void);

public:
    // Creation
    HRESULT Initialize(void);
    HRESULT Terminate(void);

    // Focus state
    void UpdateGlobalFocusState(BOOL);
    DSBUFFERFOCUS GetBufferFocusState(CDirectSoundBuffer *);
    void UpdateCaptureState(void);
    static BOOL CALLBACK EnumWinProc(HWND hWnd, LPARAM lParam);
    static BOOL IsCaptureSplitterAvailable();

    // Object maintainance
    void RegisterObject(CDirectSound*);
    void UnregisterObject(CDirectSound*);
    void RegisterObject(CDirectSoundCapture* pObj)      {m_lstCapture.AddNodeToList(pObj);}
    void UnregisterObject(CDirectSoundCapture* pObj)    {m_lstCapture.RemoveDataFromList(pObj);}
    void RegisterObject(CDirectSoundFullDuplex* pObj)   {m_lstFullDuplex.AddNodeToList(pObj);}
    void UnregisterObject(CDirectSoundFullDuplex* pObj) {m_lstFullDuplex.RemoveDataFromList(pObj);}
    void RegisterObject(CDirectSoundSink* pObj)         {m_lstDirectSoundSink.AddNodeToList(pObj);}
    void UnregisterObject(CDirectSoundSink* pObj)       {m_lstDirectSoundSink.RemoveDataFromList(pObj);}
    void RegisterObject(CDirectSoundBufferConfig* pObj) {m_lstDSBufferConfig.AddNodeToList(pObj);}
    void UnregisterObject(CDirectSoundBufferConfig*pObj){m_lstDSBufferConfig.RemoveDataFromList(pObj);}
    void RegisterObject(CClassFactory* pObj)            {m_lstClassFactory.AddNodeToList(pObj);}
    void UnregisterObject(CClassFactory* pObj)          {m_lstClassFactory.RemoveDataFromList(pObj);}
    DWORD FreeOrphanedObjects(DWORD, BOOL);

#ifdef SHARED_THREAD_LIST

    // Shared thread list
    HRESULT UpdateSharedThreadList(void);
    HRESULT UpdateCaptureFocusList(void);

    // Capture Focus list
    HRESULT WriteCaptureFocusList(void);

#endif // SHARED_THREAD_LIST

private:
    // Focus state
    void GetSystemFocusState(LPDSFOCUS);
    void GetDsoundFocusState(LPDSCOOPERATIVELEVEL, LPBOOL);
    void HandleFocusChange(void);
    void HandleCaptureFocusChange(HWND hWndCurrent);

    // The worker thread proc
    HRESULT ThreadProc(void);

#ifdef SHARED_THREAD_LIST

    // Shared thread list
    HRESULT CreateSharedThreadList(void);
    HRESULT ReadSharedThreadList(CList<DSSHAREDTHREADLISTDATA> *);
    HRESULT WriteSharedThreadList(void);

    // Shared Capture Focus Data
    HRESULT CreateCaptureFocusList(void);
    HRESULT ReadCaptureFocusList(CList<DSSHAREDCAPTUREFOCUSDATA> *);
    HRESULT MarkUpdateCaptureFocusList(DWORD dwProcessId, BOOL fUpdate);

#endif // SHARED_THREAD_LIST

};

inline void CDirectSoundAdministrator::RegisterObject(CDirectSound *pObject)
{
    m_lstDirectSound.AddNodeToList(pObject);

#ifdef SHARED_THREAD_LIST

    // Make sure the thread list actually exists.  We do this here and in
    // ::Initialize because ::RegisterObject may be called before
    // ::Initialize.
    CreateSharedThreadList();

    UpdateSharedThreadList();

#endif // SHARED_THREAD_LIST

}

inline void CDirectSoundAdministrator::UnregisterObject(CDirectSound *pObject)
{
    m_lstDirectSound.RemoveDataFromList(pObject);

#ifdef SHARED_THREAD_LIST

    UpdateSharedThreadList();

#endif // SHARED_THREAD_LIST

}

// The one and only DirectSound Administrator
extern CDirectSoundAdministrator *g_pDsAdmin;

typedef struct tagDSENUMWINDOWINFO
{
#ifdef SHARED_THREAD_LIST
    CNode<DSSHAREDCAPTUREFOCUSDATA> *pDSC;
    DWORD                            dwId;
#else   // SHARED_THREAD_LIST
    CNode<CDirectSoundCapture *>    *pDSC;
#endif  // SHARED_THREAD_LIST
    HWND                             hWndFocus;
} DSENUMWINDOWINFO, *LPDSENUMWINDOWINFO;

#endif // __cplusplus

#endif // __DSADMIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsbasic.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbasic.cpp
 *  Content:    Basic class that all DirectSound objects are derived from.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  9/4/98      dereks  Created.
 *
 ***************************************************************************/


/***************************************************************************
 *
 *  CRefCount
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      ULONG [in]: initial reference count.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRefCount::CRefCount"

inline CRefCount::CRefCount(ULONG ulRefCount)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CRefCount);

    m_ulRefCount = ulRefCount;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CRefCount
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRefCount::~CRefCount"

inline CRefCount::~CRefCount(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CRefCount);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetRefCount
 *
 *  Description:
 *      Gets the object's reference count.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRefCount::GetRefCount"

inline ULONG CRefCount::GetRefCount(void)
{
    return m_ulRefCount;
}


/***************************************************************************
 *
 *  SetRefCount
 *
 *  Description:
 *      Sets the object's reference count.
 *
 *  Arguments:
 *      ULONG [in]: object reference count.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRefCount::SetRefCount"

inline void CRefCount::SetRefCount(ULONG ulRefCount)
{
    m_ulRefCount = ulRefCount;
}


/***************************************************************************
 *
 *  AddRef
 *
 *  Description:
 *      Increments the object's reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRefCount::AddRef"

inline ULONG CRefCount::AddRef(void)
{
    return ::AddRef(&m_ulRefCount);
}


/***************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decrements the object's reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRefCount::Release"

inline ULONG CRefCount::Release(void)
{
    return ::Release(&m_ulRefCount);
}


/***************************************************************************
 *
 *  CDsBasicRuntime
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to delete the object on release.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDsBasicRuntime::CDsBasicRuntime"

inline CDsBasicRuntime::CDsBasicRuntime(BOOL fAbsoluteRelease)
    : CRefCount(1), m_dwOwnerPid(GetCurrentProcessId()), m_dwOwnerTid(GetCurrentThreadId())
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDsBasicRuntime);

    ASSERT(IN_SHARED_MEMORY(this));

    m_fAbsoluteRelease = fAbsoluteRelease;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDsBasicRuntime
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDsBasicRuntime::~CDsBasicRuntime"

inline CDsBasicRuntime::~CDsBasicRuntime(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDsBasicRuntime);

    ASSERT(!GetRefCount());

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetOwnerProcessId
 *
 *  Description:
 *      Gets the object's owning process id.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: process id.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDsBasicRuntime::GetOwnerProcessId"

inline DWORD CDsBasicRuntime::GetOwnerProcessId(void) const
{
    return m_dwOwnerPid;
}


/***************************************************************************
 *
 *  GetOwnerThreadId
 *
 *  Description:
 *      Gets the object's owning thread id.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: thread id.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDsBasicRuntime::GetOwnerThreadId"

inline DWORD CDsBasicRuntime::GetOwnerThreadId(void) const
{
    return m_dwOwnerTid;
}


/***************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decrements the object's reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDsBasicRuntime::Release"

inline ULONG CDsBasicRuntime::Release(void)
{
    ULONG                   ulRefCount;

    ulRefCount = CRefCount::Release();

    if(!ulRefCount)
    {
        AbsoluteRelease();
    }

    return ulRefCount;
}


/***************************************************************************
 *
 *  AbsoluteRelease
 *
 *  Description:
 *      Frees the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDsBasicRuntime::AbsoluteRelease"

inline void CDsBasicRuntime::AbsoluteRelease(void)
{
    CDsBasicRuntime *       pThis   = this;

    SetRefCount(0);
    
    if(m_fAbsoluteRelease)
    {
        DELETE(pThis);
    }
}


/***************************************************************************
 *
 *  __AddRef
 *
 *  Description:
 *      Increments the reference count on an object.
 *
 *  Arguments:
 *      type * [in]: object pointer.
 *
 *  Returns:  
 *      type *: object pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "__AddRef"

template <class type> type *__AddRef(type *p)
{
    if(p)
    {
        p->AddRef();
    }

    return p;
}


/***************************************************************************
 *
 *  __Release
 *
 *  Description:
 *      Releases an object.
 *
 *  Arguments:
 *      type * [in]: object pointer.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "__Release"

template <class type> void __Release(type *p)
{
    if(p)
    {
        p->Release();
    }
}


/***************************************************************************
 *
 *  __AbsoluteRelease
 *
 *  Description:
 *      Releases an object.
 *
 *  Arguments:
 *      type * [in]: object pointer.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "__AbsoluteRelease"

template <class type> void __AbsoluteRelease(type *p)
{
    if(p)
    {
        p->AbsoluteRelease();
    }
}


/***************************************************************************
 *
 *  CObjectList
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::CObjectList"

template <class type> CObjectList<type>::CObjectList(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CObjectList);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CObjectList
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::~CObjectList"

template <class type> CObjectList<type>::~CObjectList(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CObjectList);
    
    RemoveAllNodesFromList();

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  AddNodeToList
 *
 *  Description:
 *      Adds a node to the list.
 *
 *  Arguments:
 *      type& [in]: node data.
 *
 *  Returns:  
 *      CNode *: new node pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::AddNodeToList"

template <class type> CNode<type *> *CObjectList<type>::AddNodeToList(type *pData)
{
    return InsertNodeIntoList(m_lst.GetListTail(), pData);
}


/***************************************************************************
 *
 *  InsertNodeIntoList
 *
 *  Description:
 *      Inserts a new node into a specific point in the list.
 *
 *  Arguments:
 *      CNode * [in]: node to insert the new one after.
 *      type& [in]: node data.
 *
 *  Returns:  
 *      CNode *: new node pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::InsertNodeIntoList"

template <class type> CNode<type *> *CObjectList<type>::InsertNodeIntoList(CNode<type *> *pPrev, type *pData)
{
    CNode<type *> *         pNode;

    pNode = m_lst.InsertNodeIntoList(pPrev, pData);

    if(pNode && pNode->m_data)
    {
        pNode->m_data->AddRef();
    }

    return pNode;
}


/***************************************************************************
 *
 *  RemoveNodeFromList
 *
 *  Description:
 *      Removes a node from the list.
 *
 *  Arguments:
 *      CNode * [in]: node pointer.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::RemoveNodeFromList"

template <class type> void CObjectList<type>::RemoveNodeFromList(CNode<type *> *pNode)
{
    RELEASE(pNode->m_data);
    m_lst.RemoveNodeFromList(pNode);
}


/***************************************************************************
 *
 *  RemoveAllNodesFromList
 *
 *  Description:
 *      Removes all nodes from the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::RemoveAllNodesFromList"

template <class type> void CObjectList<type>::RemoveAllNodesFromList(void)
{
    while(m_lst.GetListHead())
    {
        RemoveNodeFromList(m_lst.GetListHead());
    }
}


/***************************************************************************
 *
 *  RemoveDataFromList
 *
 *  Description:
 *      Removes a node from the list.
 *
 *  Arguments:
 *      type& [in]: node data.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::RemoveDataFromList"

template <class type> BOOL CObjectList<type>::RemoveDataFromList(type *pData)
{
    CNode<type *> *         pNode;

    pNode = IsDataInList(pData);

    if(pNode)
    {
        RemoveNodeFromList(pNode);
    }

    return MAKEBOOL(pNode);
}


/***************************************************************************
 *
 *  IsDataInList
 *
 *  Description:
 *      Determines if a piece of data appears in the list.
 *
 *  Arguments:
 *      type& [in]: node data.
 *
 *  Returns:  
 *      CNode *: node pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::IsDataInList"

template <class type> CNode<type *> *CObjectList<type>::IsDataInList(type *pData)
{
    return m_lst.IsDataInList(pData);
}


/***************************************************************************
 *
 *  GetListHead
 *
 *  Description:
 *      Gets the first node in the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      CNode *: list head pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::GetListHead"

template <class type> CNode<type *> *CObjectList<type>::GetListHead(void)
{ 
    return m_lst.GetListHead();
}


/***************************************************************************
 *
 *  GetListTail
 *
 *  Description:
 *      Gets the last node in the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      CNode *: list tail pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::GetListTail"

template <class type> CNode<type *> *CObjectList<type>::GetListTail(void)
{ 
    return m_lst.GetListTail();
}


/***************************************************************************
 *
 *  GetNodeCount
 *
 *  Description:
 *      Gets the count of nodes in the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      UINT: count of nodes in the list.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::GetNodeCount"

template <class type> UINT CObjectList<type>::GetNodeCount(void)
{ 
    return m_lst.GetNodeCount(); 
}


/***************************************************************************
 *
 *  GetNodeByIndex
 *
 *  Description:
 *      Gets a node by it's index in the list.
 *
 *  Arguments:
 *      UINT [in]: node index.
 *
 *  Returns:  
 *      CNode *: node pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CObjectList::GetNodeByIndex"

template <class type> CNode<type *> *CObjectList<type>::GetNodeByIndex(UINT uIndex)
{
    return m_lst.GetNodeByIndex(uIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsaphack.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:      dsaphack.c
 *  Content:   DirectSound "app-hack" extension.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/16/98    dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"

typedef struct tagAPPHACKENTRY
{
    LPCTSTR             pszName;
    DWORD               cbData;
} APPHACKENTRY, *LPAPPHACKENTRY;

typedef struct tagAPPHACKTABLE
{
    LPAPPHACKENTRY      aEntries;
    ULONG               cEntries;
} APPHACKTABLE, *LPAPPHACKTABLE;

#define BEGIN_DECLARE_APPHACK_ENTRIES(name) \
            APPHACKENTRY name[] = {

#define DECLARE_APPHACK_ENTRY(name, type) \
                { TEXT(#name), sizeof(type) },

#define END_DECLARE_APPHACK_ENTRIES() \
            };

#define BEGIN_DECLARE_APPHACK_TABLE(name) \
            APPHACKTABLE name = 

#define DECLARE_APPHACK_TABLE(entries) \
                { entries, NUMELMS(entries) }

#define END_DECLARE_APPHACK_TABLE() \
            ;

BEGIN_DECLARE_APPHACK_ENTRIES(g_aheAppHackEntries)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_DEVACCEL, DSAPPHACK_DEVACCEL)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_DISABLEDEVICE, VADDEVICETYPE)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_PADCURSORS, LONG)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_MODIFYCSBFAILURE, HRESULT)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_RETURNWRITEPOS, VADDEVICETYPE)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_SMOOTHWRITEPOS, DSAPPHACK_SMOOTHWRITEPOS)
    DECLARE_APPHACK_ENTRY(DSAPPHACKID_CACHEPOSITIONS, VADDEVICETYPE)
END_DECLARE_APPHACK_ENTRIES()

BEGIN_DECLARE_APPHACK_TABLE(g_ahtAppHackTable)
    DECLARE_APPHACK_TABLE(g_aheAppHackEntries)
END_DECLARE_APPHACK_TABLE()


/***************************************************************************
 *
 *  AhGetCurrentApplicationPath
 *
 *  Description:
 *      Gets the full path to the current application's executable.
 *
 *  Arguments:
 *      LPTSTR [out]: receives application id.  This buffer is assumed to be 
 *                   at least MAX_PATH characters in size.
 *      LPTSTR * [out]: receives pointer to executable part of the path.
 *
 *  Returns: 
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AhGetCurrentApplicationPath"

BOOL
AhGetCurrentApplicationPath
(
    LPTSTR                  pszPath,
    LPTSTR *                ppszModule
)
{
    BOOL                    fSuccess                = TRUE;
    TCHAR                   szOriginal[MAX_PATH];
#ifdef SHARED
    BOOL                    fQuote                  = FALSE;
    LPTSTR                  pszOriginal;
    LPTSTR                  pszCommandLine;
    LPTSTR                  psz[2];
#endif // SHARED

    DPF_ENTER();
    
#ifdef SHARED

    // Get the application's command line
    pszOriginal = GetCommandLine();

    // Allocate a buffer to serve as a copy
    pszCommandLine = MEMALLOC_A(TCHAR, lstrlen(pszOriginal) + 2);

    if(!pszCommandLine)
    {
        DPF(DPFLVL_ERROR, "Out of memory allocating command-line");
        fSuccess = FALSE;
    }

    // Reformat the command-line so that NULLs divide the arguments
    // instead of quotes and spaces.
    if(fSuccess)
    {
        psz[0] = pszOriginal;
        psz[1] = pszCommandLine;

        while(*psz[0])
        {
            switch(*psz[0])
            {
                case '"':
                    fQuote = !fQuote;
                    break;

                case ' ':
                    *psz[1]++ = fQuote ? ' ' : 0;
                    break;

                default:
                    *psz[1]++ = *psz[0];
                    break;
            }

            psz[0]++;
        }
    }

    // Push the command line pointer ahead of any whitespace
    if(fSuccess)
    {
        psz[0] = pszCommandLine;

        while(' ' == *psz[0])
        {
            psz[0]++;
        }
    }
    
    // Get the module's executable name
    if(fSuccess)
    {
        fSuccess = MAKEBOOL(GetFullPathName(psz[0], MAX_PATH, pszPath, ppszModule));
    }

    // Trim any whitespace from the end of the executable path
    if(fSuccess)
    {
        psz[1] = pszPath + lstrlen(pszPath) - 1;
        
        while(psz[1] > pszPath && ' ' == *psz[1])
        {
            *psz[1]-- = 0;
        }
    }

    // Clean up
    MEMFREE(pszCommandLine);

    // A hack to fix OSR 133656.  The right way to do would be to combine this
    // function with AhGetApplicationId(), so we don't call CreateFile twice.
    if (fSuccess)
    {
        HANDLE hFile = CreateFile(pszPath, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
            fSuccess = FALSE;
        else
            CloseHandle(hFile);
    }

    // If this fails (e.g. because someone called CreateProcess without
    // putting the program name in the command line argument) we try the
    // NT solution. It seems to work as well as the above, even on Win9X.
    if (!fSuccess)

#endif // SHARED

    {
        fSuccess = GetModuleFileName(GetModuleHandle(NULL), szOriginal, MAX_PATH);
        if(fSuccess)
        {
            fSuccess = MAKEBOOL(GetFullPathName(szOriginal, MAX_PATH, pszPath, ppszModule));
        }
    }

    DPF_LEAVE(fSuccess);
    return fSuccess;
}


/***************************************************************************
 *
 *  AhGetApplicationId
 *
 *  Description:
 *      Gets the id used to identify the current application.
 *
 *  Arguments:
 *      LPTSTR [out]: receives application id.
 *
 *  Returns: 
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AhGetApplicationId"

BOOL
AhGetApplicationId
(
    LPTSTR                  pszAppId
)
{
    HANDLE                  hFile                   = NULL;
    TCHAR                   szExecutable[MAX_PATH];
    LPTSTR                  pszModule;
    IMAGE_NT_HEADERS        nth;
    IMAGE_DOS_HEADER        dh;
    DWORD                   cbRead;
    DWORD                   dwFileSize;
    BOOL                    fSuccess;

    DPF_ENTER();
    
    // Get the application path
    fSuccess = AhGetCurrentApplicationPath(szExecutable, &pszModule);

    if(fSuccess)
    {
        DPF(DPFLVL_MOREINFO, "Application executable path: %s", szExecutable);
        DPF(DPFLVL_MOREINFO, "Application module: %s", pszModule);
    }
                    
    // Open the executable
    if(fSuccess)
    {
        hFile = CreateFile(szExecutable, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

        if(!IsValidHandleValue(hFile))
        {
            DPF(DPFLVL_ERROR, "CreateFile failed to open %s with error %lu", szExecutable, GetLastError());
            fSuccess = FALSE;
        }
    }

    // Read the executable's DOS header
    if(fSuccess)
    {
        fSuccess = ReadFile(hFile, &dh, sizeof(dh), &cbRead, NULL);

        if(!fSuccess || sizeof(dh) != cbRead)
        {
            DPF(DPFLVL_ERROR, "Unable to read DOS header");
            fSuccess = FALSE;
        }
    }

    if(fSuccess && IMAGE_DOS_SIGNATURE != dh.e_magic)
    {
        DPF(DPFLVL_ERROR, "Invalid DOS signature");
        fSuccess = FALSE;
    }

    // Read the executable's PE header
    if(fSuccess)
    {
        cbRead = SetFilePointer(hFile, dh.e_lfanew, NULL, FILE_BEGIN);

        if((LONG)cbRead != dh.e_lfanew)
        {
            DPF(DPFLVL_ERROR, "Unable to seek to PE header");
            fSuccess = FALSE;
        }
    }

    if(fSuccess)
    {
        fSuccess = ReadFile(hFile, &nth, sizeof(nth), &cbRead, NULL);

        if(!fSuccess || sizeof(nth) != cbRead)
        {
            DPF(DPFLVL_ERROR, "Unable to read PE header");
            fSuccess = FALSE;
        }
    }

    if(fSuccess && IMAGE_NT_SIGNATURE != nth.Signature)
    {
        DPF(DPFLVL_ERROR, "Invalid PE signature");
        fSuccess = FALSE;
    }

    // Get the executable's size
    if(fSuccess)
    {
        // Assuming < 4 GB
        dwFileSize = GetFileSize(hFile, NULL);

        if(MAX_DWORD == dwFileSize)
        {
            DPF(DPFLVL_ERROR, "Unable to get file size");
            fSuccess = FALSE;
        }
    }

    // Create the application id
    if(fSuccess)
    {
        // Check for the QuickTime special case
        if (!lstrcmpi(pszModule, TEXT("QuickTimePlayer.exe")) && nth.FileHeader.TimeDateStamp < 0x38E50000) // Circa 3/31/2000
        {
            wsprintf(pszAppId, TEXT("Pre-May 2000 QuickTime"));
        }
        else
        {
            wsprintf(pszAppId, TEXT("%s%8.8lX%8.8lX"), pszModule, nth.FileHeader.TimeDateStamp, dwFileSize);
            CharUpper(pszAppId);
        }
        DPF(DPFLVL_INFO, "Application id: %s", pszAppId);
    }

    // Clean up
    CLOSE_HANDLE(hFile);

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


/***************************************************************************
 *
 *  AhOpenApplicationKey
 *
 *  Description:
 *      Opens or creates the application's root key.
 *
 *  Arguments:
 *      LPCTSTR [in]: application id.
 *      BOOL [in]: TRUE to allow for creation of a new key.
 *
 *  Returns: 
 *      HKEY: registry key handle.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AhOpenApplicationKey"

HKEY
AhOpenApplicationKey
(
    LPCTSTR                 pszAppId
)
{

#ifdef DEBUG

    TCHAR                   szName[0x100]   = { 0 };
    LONG                    cbName          = sizeof(szName);

#endif // DEBUG

    HKEY                    hkey            = NULL;
    HRESULT                 hr;

    DPF_ENTER();
    
    // Open the parent key
    hr = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkey, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 2, REGSTR_APPHACK, pszAppId);

#ifdef DEBUG

    // Query for the application description
    if(SUCCEEDED(hr))
    {
        RhRegGetStringValue(hkey, NULL, szName, cbName);
        DPF(DPFLVL_INFO, "Application description: %s", szName);
    }

#endif // DEBUG                

    DPF_LEAVE(hkey);

    return hkey;
}


/***************************************************************************
 *
 *  AhGetHackValue
 *
 *  Description:
 *      Queries an apphack value.
 *
 *  Arguments:
 *      HKEY [in]: application registry key.
 *      DSAPPHACKID [in]: apphack id.
 *      LPVOID [out]: receives apphack data.
 *      DWORD [in]: size of above data buffer.
 *
 *  Returns: 
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AhGetHackValue"

BOOL
AhGetHackValue
(
    HKEY                    hkey,
    DSAPPHACKID             ahid,
    LPVOID                  pvData,
    DWORD                   cbData
)
{
    HRESULT                 hr;
    
    ASSERT(ahid < (DSAPPHACKID)g_ahtAppHackTable.cEntries);
    ASSERT(cbData == g_ahtAppHackTable.aEntries[ahid].cbData);

    DPF_ENTER();
    
    hr = RhRegGetBinaryValue(hkey, g_ahtAppHackTable.aEntries[ahid].pszName, pvData, cbData);

    DPF_LEAVE(DS_OK == hr);

    return DS_OK == hr;
}


/***************************************************************************
 *
 *  AhGetAppHacks
 *
 *  Description:
 *      Gets all app-hacks for the current application.
 *
 *  Arguments:
 *      LPDSAPPHACKS [out]: receives app-hack data.
 *
 *  Returns: 
 *      BOOL: TRUE if any apphacks exist for the current application.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AhGetAppHacks"

BOOL
AhGetAppHacks
(
    LPDSAPPHACKS            pahAppHacks
)
{
    static const DSAPPHACKS ahDefaults                  = {{DIRECTSOUNDMIXER_ACCELERATIONF_FULL, 0}, 0, 0, DS_OK, FALSE, {FALSE, 0}};
    TCHAR                   szAppId[DSAPPHACK_MAXNAME]  = {0};
    HKEY                    hkey                        = NULL;
    BOOL                    fSuccess;
    
    DPF_ENTER();
    
    // Assume defaults
    CopyMemory(pahAppHacks, &ahDefaults, sizeof(ahDefaults));
    
    // Get the application id
    fSuccess = AhGetApplicationId(szAppId);

    if(fSuccess)
    {
        DPF(DPFLVL_INFO, "Finding apphacks for %s...", szAppId);
    }

    // Open the application key
    if(fSuccess)
    {
        hkey = AhOpenApplicationKey(szAppId);
        fSuccess = MAKEBOOL(hkey);
    }

    // Query all apphack values
    if(fSuccess)
    {
        AhGetHackValue(hkey, DSAPPHACKID_DEVACCEL, &pahAppHacks->daDevAccel, sizeof(pahAppHacks->daDevAccel));
        AhGetHackValue(hkey, DSAPPHACKID_DISABLEDEVICE, &pahAppHacks->vdtDisabledDevices, sizeof(pahAppHacks->vdtDisabledDevices));
        AhGetHackValue(hkey, DSAPPHACKID_PADCURSORS, &pahAppHacks->lCursorPad, sizeof(pahAppHacks->lCursorPad));
        AhGetHackValue(hkey, DSAPPHACKID_MODIFYCSBFAILURE, &pahAppHacks->hrModifyCsbFailure, sizeof(pahAppHacks->hrModifyCsbFailure));
        AhGetHackValue(hkey, DSAPPHACKID_RETURNWRITEPOS, &pahAppHacks->vdtReturnWritePos, sizeof(pahAppHacks->vdtReturnWritePos));
        AhGetHackValue(hkey, DSAPPHACKID_SMOOTHWRITEPOS, &pahAppHacks->swpSmoothWritePos, sizeof(pahAppHacks->swpSmoothWritePos));
        AhGetHackValue(hkey, DSAPPHACKID_CACHEPOSITIONS, &pahAppHacks->vdtCachePositions, sizeof(pahAppHacks->vdtCachePositions));
    }

    if(fSuccess)
    {
        DPF(DPFLVL_INFO, "dwAcceleration:               0x%lX (applied to device type 0x%lX)", pahAppHacks->daDevAccel.dwAcceleration, pahAppHacks->daDevAccel.vdtDevicesAffected);
        DPF(DPFLVL_INFO, "vdtDisabledDevices:           0x%lX", pahAppHacks->vdtDisabledDevices);
        DPF(DPFLVL_INFO, "lCursorPad:                   %ld", pahAppHacks->lCursorPad);
        DPF(DPFLVL_INFO, "hrModifyCsbFailure:           %s", HRESULTtoSTRING(pahAppHacks->hrModifyCsbFailure));
        DPF(DPFLVL_INFO, "vdtReturnWritePos:            %lu", pahAppHacks->vdtReturnWritePos);
        DPF(DPFLVL_INFO, "swpSmoothWritePos.fEnable:    %lu", pahAppHacks->swpSmoothWritePos.fEnable);
        DPF(DPFLVL_INFO, "swpSmoothWritePos.lCursorPad: %lu", pahAppHacks->swpSmoothWritePos.lCursorPad);
        DPF(DPFLVL_INFO, "vdtCachePositions:            %lu", pahAppHacks->vdtCachePositions);
    }
    else
    {
        DPF(DPFLVL_INFO, "No apphacks exist");
    }

    // Clean up
    RhRegCloseKey(&hkey);

    DPF_LEAVE(fSuccess);

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsadmin.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsadmin.cpp
 *  Content:    DirectSound Administrator
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/9/97      dereks  Created
 *  2/13/97     dereks  Focus manager reborn as Administrator.
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#include "nt.h"         // For USER_SHARED_DATA
#include "ntrtl.h"
#include "nturtl.h"
#include "dsoundi.h"

#ifdef SHARED
#include "ddhelp.h"
#endif


/***************************************************************************
 *
 *  CDirectSoundAdministrator
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::CDirectSoundAdministrator"

#ifdef SHARED_THREAD_LIST

const DWORD CDirectSoundAdministrator::m_dwSharedThreadLimit = 1024;
const DWORD CDirectSoundAdministrator::m_dwCaptureDataLimit  = 1024;

#endif // SHARED_THREAD_LIST

CDirectSoundAdministrator::CDirectSoundAdministrator(void)
    : CThread(TRUE, TEXT("DirectSound Administrator"))
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundAdministrator);

    // Initialize defaults

#ifdef SHARED
    m_hApmSuspend = NULL;
#endif // SHARED

#ifdef SHARED_THREAD_LIST
    m_pSharedThreads = NULL;
#endif // SHARED_THREAD_LIST

    m_dwWaitDelay = WAITDELAY_DEFAULT;
    m_ulConsoleSessionId = -1;
    
    // Initialize the default focus
    ZeroMemory(&m_dsfCurrent, sizeof(m_dsfCurrent));
    ZeroMemory(&m_dsclCurrent, sizeof(m_dsclCurrent));

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundAdministrator
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::~CDirectSoundAdministrator"

CDirectSoundAdministrator::~CDirectSoundAdministrator(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundAdministrator);

    // Terminate the worker thread
    CThread::Terminate();

    // Free resources

#ifdef SHARED
    CLOSE_HANDLE(m_hApmSuspend);
#endif // SHARED

#ifdef SHARED_THREAD_LIST
    RELEASE(m_pSharedThreads);
    RELEASE(m_pCaptureFocusData);
#endif // SHARED_THREAD_LIST

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::Initialize"

HRESULT CDirectSoundAdministrator::Initialize(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

#ifdef SHARED

    // Create synchronization objects
    if(!m_hApmSuspend)
    {
        m_hApmSuspend = CreateGlobalEvent(TEXT(DDHELP_APMSUSPEND_EVENT_NAME), TRUE);
        hr = HRFROMP(m_hApmSuspend);
    }

#endif // SHARED

#ifdef SHARED_THREAD_LIST

    // Make sure the thread lists exist
    if (SUCCEEDED(hr))
    {
        hr = CreateSharedThreadList();
    }

    if (SUCCEEDED(hr))
    {
        hr = CreateCaptureFocusList();
    }

#endif // SHARED_THREAD_LIST

    // Initialize focus state
    if(SUCCEEDED(hr))
    {
        UpdateGlobalFocusState(TRUE);
    }

    // Create the worker thread
    if(SUCCEEDED(hr) && !m_hThread)
    {
        hr = CThread::Initialize();
    }

    // Increment the reference count
    if(SUCCEEDED(hr))
    {
        m_rcThread.AddRef();
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Terminate
 *
 *  Description:
 *      Terminates the thread.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::Terminate"

HRESULT CDirectSoundAdministrator::Terminate(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(!m_rcThread.Release())
    {
        hr = CThread::Terminate();
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  ThreadProc
 *
 *  Description:
 *      Main thread proc for the DirectSound Administrator.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::ThreadProc"

HRESULT CDirectSoundAdministrator::ThreadProc(void)
{
    BOOL                    fContinue;

    DPF_ENTER();

    fContinue = TpWaitObjectArray(m_dwWaitDelay, 0, NULL, NULL);

    if(fContinue)
    {
        UpdateGlobalFocusState(FALSE);
    }

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  UpdateGlobalFocusState
 *
 *  Description:
 *      Updates focus state for the entire system.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to force refresh.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::UpdateGlobalFocusState"

void CDirectSoundAdministrator::UpdateGlobalFocusState(BOOL fForce)
{
    DSFOCUS                 dsf;
    DSCOOPERATIVELEVEL      dscl;

    DPF_ENTER();

#pragma TODO("Make this function thread-safe when called from the worker thread")

    // Save the current focus state
    CopyMemory(&dsf, &m_dsfCurrent, sizeof(m_dsfCurrent));
    CopyMemory(&dscl, &m_dsclCurrent, sizeof(m_dsclCurrent));

    // Update the system focus state
    GetSystemFocusState(&m_dsfCurrent);

    // Update the dsound focus state
    GetDsoundFocusState(&m_dsclCurrent, &fForce);

    // Has anything really changed?
    if(!fForce)
    {
        fForce = !CompareMemory(&dscl, &m_dsclCurrent, sizeof(m_dsclCurrent));
    }

    // If it has, handle the change for the render buffers
    if(fForce)
    {
        HandleFocusChange();
    }

    // If a different TS session has taken ownership of the console,
    // we need to force a capture focus update
    if(m_ulConsoleSessionId != USER_SHARED_DATA->ActiveConsoleId)
    {
        m_ulConsoleSessionId = USER_SHARED_DATA->ActiveConsoleId;
        fForce = TRUE;
    }
    
    // Handle the focus change for the capture buffers
    if(fForce)
    {
        HandleCaptureFocusChange(m_dsfCurrent.hWnd);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EnumWinProc
 *
 *  Description:
 *      EnumWindow callback function.
 *
 *  Arguments:
 *      HWND [in]: Current window that has focus.
 *      LPARAM [in]: Pointer to a DSENUMWINDOWINFO structure.
 *
 *  Returns:
 *      (BOOL) TRUE to continue enumerating, FALSE to stop.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::EnumWinProc"

BOOL CALLBACK CDirectSoundAdministrator::EnumWinProc(HWND hWnd, LPARAM lParam)
{
#ifdef SHARED_THREAD_LIST

    LPDSENUMWINDOWINFO                      pDSEnumInfo;
    CNode<DSSHAREDCAPTUREFOCUSDATA>        *pDSC;

    pDSEnumInfo = (LPDSENUMWINDOWINFO)lParam;

    // Are we looking for top level window?
    if (NULL == pDSEnumInfo->pDSC)
    {
        pDSEnumInfo->hWndFocus = hWnd;
        return FALSE;
    }

    // Finding highest Z-order window...
    for (pDSC = pDSEnumInfo->pDSC; pDSC; pDSC = pDSC->m_pNext)
    {
        if ((hWnd == pDSC->m_data.hWndFocus) &&
            !(pDSC->m_data.fdwFlags & DSCBFLAG_YIELD) &&
            !(pDSC->m_data.fdwFlags & DSCBFLAG_STRICT))
        {
            // Found it
            DPF(DPFLVL_INFO, "Found window handle 0x%08lx", hWnd);
            pDSEnumInfo->dwId = pDSC->m_data.dwProcessId;
            pDSEnumInfo->hWndFocus = hWnd;
            return FALSE;
        }
    }

#else // SHARED_THREAD_LIST

    LPDSENUMWINDOWINFO                      pDSEnumInfo;
    CNode<CDirectSoundCapture *> *          pCObjectNode;
    CNode<CDirectSoundCaptureBuffer *> *    pCBufferNode;
    HRESULT                                 hr;

    pDSEnumInfo = (LPDSENUMWINDOWINFO)lParam;

    // Are we looking for top level window?
    if (NULL == pDSEnumInfo->pDSC)
    {
        pDSEnumInfo->hWndFocus = hWnd;
        return FALSE;
    }

    for (pCObjectNode = pDSEnumInfo->pDSC; pCObjectNode; pCObjectNode = pCObjectNode->m_pNext)
    {
        hr = pCObjectNode->m_data->IsInit();
        if (FAILED(hr))
            continue;

        for (pCBufferNode = pCObjectNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
        {
            hr = pCBufferNode->m_data->IsInit();
            if (SUCCEEDED(hr))
            {
                if ((hWnd == pCBufferNode->m_data->m_hWndFocus) &&
                    !(pCBufferNode->m_data->m_pDeviceBuffer->m_fYieldedFocus) &&
                    !(pCBufferNode->m_data->m_pDeviceBuffer->m_dwFlags & DSCBCAPS_STRICTFOCUS))
                {
                    // Found it
                    DPF(DPFLVL_INFO, "EnumWinProc found 0x%08lx", hWnd);
                    pDSEnumInfo->hWndFocus = hWnd;
                    return FALSE;
                }
            }
        }
    }

#endif // SHARED_THREAD_LIST

    // Hmm... Still haven't found it
    return TRUE;
}


/***************************************************************************
 *
 *  UpdateCaptureState
 *
 *  Description:
 *      Updates focus state for the capture system.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::UpdateCaptureState"

void CDirectSoundAdministrator::UpdateCaptureState(void)
{
    DPF_ENTER();

#ifdef SHARED_THREAD_LIST
    // Write the status of the current buffers before updating focus status
    WriteCaptureFocusList();
#endif

    HandleCaptureFocusChange(GetForegroundApplication());

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  HandleCaptureFocusChange
 *
 *  Description:
 *      Updates focus state for the capture system.
 *
 *  Arguments:
 *      HWND [in]: Current Window that has focus.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::HandleCaptureFocusChange"

void CDirectSoundAdministrator::HandleCaptureFocusChange(HWND hWndFocus)
{
    CNode<CDirectSoundCapture *> *          pCObjectNode;
    CNode<CDirectSoundCaptureBuffer *> *    pCBufferNode;
    DSENUMWINDOWINFO                        dsewi;
    HRESULT                                 hr;

    if(TpEnterDllMutex())
    {
        DPF_ENTER();

#ifdef SHARED_THREAD_LIST  // The WinNT case

        CList<DSSHAREDCAPTUREFOCUSDATA>     lstCapture;
        CNode<DSSHAREDCAPTUREFOCUSDATA> *   pCNode;
        DWORD                               dwProcess  = GetCurrentProcessId();
        DWORD                               dwTargetId = 0L;

        // Assert that we have been initialized
        ASSERT(m_pCaptureFocusData);

        // Lock the list
        m_pCaptureFocusData->Lock();

        // Get global list of capture buffers
        hr = ReadCaptureFocusList(&lstCapture);

        // Ignore regular buffers if splitter enabled (manbug #39519)
        if (!IsCaptureSplitterAvailable())
        {
            // Check for regular buffers first
            if (SUCCEEDED(hr))
            {
                for (pCNode = lstCapture.GetListHead(); pCNode; pCNode = pCNode->m_pNext)
                {
                    if (!(pCNode->m_data.fdwFlags & DSCBFLAG_FOCUS))
                    {
                        dwTargetId = pCNode->m_data.dwProcessId;
                        hWndFocus  = pCNode->m_data.hWndFocus;
                        goto FoundWindow;
                    }
                }
            }
        }

        // No regular buffers; look for focus-aware buffers in focus
        if(SUCCEEDED(hr))
        {
            for (pCNode = lstCapture.GetListHead(); pCNode; pCNode = pCNode->m_pNext)
            {
                if ((hWndFocus == pCNode->m_data.hWndFocus) &&
                    !(pCNode->m_data.fdwFlags & DSCBFLAG_YIELD))
                {
                    dwTargetId = pCNode->m_data.dwProcessId;
                    DPF(DPFLVL_INFO, "Process 0x%08X: Found buffer for 0x%08X (hWndFocus=0x%08X)", dwProcess, dwTargetId, hWndFocus);
                    goto FoundWindow;
                }
            }
        }

        // Have to resolve through Z-order
        if(SUCCEEDED(hr))
        {
            dsewi.pDSC      = lstCapture.GetListHead();
            dsewi.dwId      = 0L;
            dsewi.hWndFocus = NULL;

            EnumWindows(EnumWinProc, (LPARAM)&dsewi);

            dwTargetId = dsewi.dwId;
            hWndFocus  = dsewi.hWndFocus;
        }

    FoundWindow:

        if(SUCCEEDED(hr))
        {
            BOOL fStarted = TRUE;

            for (pCObjectNode = m_lstCapture.GetListHead(); pCObjectNode; pCObjectNode = pCObjectNode->m_pNext)
            {
                hr = pCObjectNode->m_data->IsInit();
                if (FAILED(hr))
                    continue;

                for (pCBufferNode = pCObjectNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
                {
                    hr = pCBufferNode->m_data->IsInit();
                    if (SUCCEEDED(hr))
                    {
                        hr = pCBufferNode->m_data->ChangeFocus(hWndFocus);

                        if (FAILED(hr))
                        {
                            DPF(DPFLVL_INFO, "Process 0x%08X: ChangeFocus failed with %s", dwProcess, HRESULTtoSTRING(hr));
                            fStarted = FALSE;
                        }
                    }
                }
            }

            if (fStarted)
            {
                // Let's mark ourselves 'clean'
                MarkUpdateCaptureFocusList(dwProcess, FALSE);
            }
            else
            {
                // This probably means that we tried to start our buffer, but another
                // process has this device allocated...

                for (dwTargetId = 0, pCNode = lstCapture.GetListHead(); pCNode; pCNode = pCNode->m_pNext)
                {
                    if (pCNode->m_data.fdwFlags & VAD_BUFFERSTATE_STARTED)
                    {
                        dwTargetId = pCNode->m_data.dwProcessId;
                        break;
                    }
                }

                if (dwTargetId)
                {
                    MarkUpdateCaptureFocusList(pCNode->m_data.dwProcessId, TRUE);
                    MarkUpdateCaptureFocusList(dwProcess, TRUE);
                }
            }

            for (pCNode = lstCapture.GetListHead(); pCNode; pCNode = pCNode->m_pNext)
            {
                if (dwProcess != pCNode->m_data.dwProcessId)
                {
                    MarkUpdateCaptureFocusList(pCNode->m_data.dwProcessId, TRUE);
                }
            }

            WriteCaptureFocusList();
        }

        // Unlock the list
        m_pCaptureFocusData->Unlock();

#else // SHARED_THREAD_LIST - the Win9x case

        if (NULL == hWndFocus)
        {
            // This should never happen!
            dsewi.pDSC      = NULL;
            dsewi.hWndFocus = NULL;
            EnumWindows(EnumWinProc, (LPARAM)&dsewi);
            hWndFocus = dsewi.hWndFocus;
        }

        // Changing this to work on a per device basis...
        // Ughh! Changing this back, as it turns out, Capture object != Capture device

        // Ignore regular buffers if splitter enabled - Manbug #39519
        if (!IsCaptureSplitterAvailable())
        {
            // First we check if there any non-focus aware buffers - Millennium bug 124237
            for (pCObjectNode = m_lstCapture.GetListHead(); pCObjectNode; pCObjectNode = pCObjectNode->m_pNext)
            {
                hr = pCObjectNode->m_data->IsInit();
                if (FAILED(hr))
                    continue;

                for (pCBufferNode = pCObjectNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
                {
                    hr = pCBufferNode->m_data->IsInit();
                    if (SUCCEEDED(hr))
                    {
                        if (0 == (DSCBCAPS_FOCUSAWARE & pCBufferNode->m_data->m_pDeviceBuffer->m_dwFlags))
                        {
                            DPF(DPFLVL_INFO, "Found non-focus aware buffer.");
                            hWndFocus = NULL;
                            goto ExitLoop;
                        }
                    }
                }
            }
        }

        // Find focus aware buffer(s) associated with current window
        for (pCObjectNode = m_lstCapture.GetListHead(); pCObjectNode; pCObjectNode = pCObjectNode->m_pNext)
        {
            hr = pCObjectNode->m_data->IsInit();
            if (FAILED(hr))
                continue;

            for (pCBufferNode = pCObjectNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
            {
                hr = pCBufferNode->m_data->IsInit();
                if (SUCCEEDED(hr))
                {
                    // Note: Not double checking the DSCB_FOCUSAWARE flag since hWnd is non-zero

                    if ((hWndFocus == pCBufferNode->m_data->m_hWndFocus) &&
                        !pCBufferNode->m_data->m_pDeviceBuffer->m_fYieldedFocus)
                    {
                        DPF(DPFLVL_INFO, "Found buffer with 0x%08lx handle", hWndFocus);
                        goto ExitLoop;
                    }
                }
            }
        }

        // Didn't find window so let's enumerate them
        dsewi.pDSC      = m_lstCapture.GetListHead();
        dsewi.hWndFocus = NULL;

        EnumWindows(EnumWinProc, (LPARAM)&dsewi);

        hWndFocus = dsewi.hWndFocus;

        DPF(DPFLVL_MOREINFO, "Found z-order window 0x%08lx handle", hWndFocus);

    ExitLoop:
        // Note: Since losing focus will potentially release a device,
        // we have to "lose" focus on appropriate buffers since it may be
        // allocated when the buffer that gains focus tries to open it.

        // Losing focus
        for (pCObjectNode = m_lstCapture.GetListHead(); pCObjectNode; pCObjectNode = pCObjectNode->m_pNext)
        {
            hr = pCObjectNode->m_data->IsInit();
            if (FAILED(hr))
                continue;

            for (pCBufferNode = pCObjectNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
            {
                hr = pCBufferNode->m_data->IsInit();
                if (SUCCEEDED(hr))
                {
                    if (hWndFocus != pCBufferNode->m_data->m_hWndFocus)
                    {
                        hr = pCBufferNode->m_data->ChangeFocus(hWndFocus);
                    }
                }
            }
        }

        // Getting focus
        for (pCObjectNode = m_lstCapture.GetListHead(); pCObjectNode; pCObjectNode = pCObjectNode->m_pNext)
        {
            hr = pCObjectNode->m_data->IsInit();
            if (FAILED(hr))
                continue;

            for (pCBufferNode = pCObjectNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
            {
                hr = pCBufferNode->m_data->IsInit();
                if (SUCCEEDED(hr))
                {
                    if (hWndFocus == pCBufferNode->m_data->m_hWndFocus)
                    {
                        hr = pCBufferNode->m_data->ChangeFocus(hWndFocus);
                    }
                }
            }
        }

#endif // SHARED_THREAD_LIST

        DPF_LEAVE_VOID();
        LEAVE_DLL_MUTEX();
    }
}


/***************************************************************************
 *
 *  HandleFocusChange
 *
 *  Description:
 *      Updates focus state for the entire system.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::HandleFocusChange"

void CDirectSoundAdministrator::HandleFocusChange(void)
{
    CDirectSoundPrimaryBuffer *             pPrimaryInFocus = NULL;
    CNode<CDirectSound *> *                 pObjectNode;
    CNode<CDirectSoundSecondaryBuffer *> *  pBufferNode;
    CNode<CDirectSoundSecondaryBuffer *> *  pCheckNode;
    CList<CDirectSoundSecondaryBuffer *>    lstInFocus;
    DSBUFFERFOCUS                           bfFocus;
    HRESULT                                 hr;

    if(TpEnterDllMutex())
    {
        DPF_ENTER();
        DPF(DPFLVL_INFO, "Focus on thread 0x%8.8lX (priority %lu)", m_dsclCurrent.dwThreadId, m_dsclCurrent.dwPriority);

        // Update the system's focus state
        for(pObjectNode = m_lstDirectSound.GetListHead(); pObjectNode; pObjectNode = pObjectNode->m_pNext)
        {
            hr = pObjectNode->m_data->IsInit();
            if(SUCCEEDED(hr))
            {
                // Update all lost and out-of-focus secondary buffers
                for(pBufferNode = pObjectNode->m_data->m_lstSecondaryBuffers.GetListHead(); pBufferNode; pBufferNode = pBufferNode->m_pNext)
                {
                    hr = pBufferNode->m_data->IsInit();
                    if(SUCCEEDED(hr))
                    {
                        bfFocus = GetBufferFocusState(pBufferNode->m_data);

                        switch(bfFocus)
                        {
                            case DSBUFFERFOCUS_INFOCUS:
                                pCheckNode = lstInFocus.AddNodeToList(pBufferNode->m_data);
                                ASSERT(pCheckNode != NULL);
                                break;

                            case DSBUFFERFOCUS_OUTOFFOCUS:
                                pBufferNode->m_data->Activate(FALSE);
                                break;

                            case DSBUFFERFOCUS_LOST:
                                pBufferNode->m_data->Lose();
                                break;
                        }
                    }
                }

                // Update all lost and out-of-focus primary buffers.  It's possible that
                // there may be more than one DirectSound object in focus, so we only
                // use the first one we find.  This also means that any primary buffers
                // that are actually in focus may be considered lost or out-of-focus.
                if(SUCCEEDED(hr) && pObjectNode->m_data->m_pPrimaryBuffer)
                {
                    hr = pObjectNode->m_data->m_pPrimaryBuffer->IsInit();

                    if(SUCCEEDED(hr))
                    {
                        if(pPrimaryInFocus != pObjectNode->m_data->m_pPrimaryBuffer)
                        {
                            bfFocus = GetBufferFocusState(pObjectNode->m_data->m_pPrimaryBuffer);

                            switch(bfFocus)
                            {
             