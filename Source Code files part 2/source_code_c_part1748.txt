i] & 0x7;
            switch(Mod)
            {
            case 0:
                if (Rm == 4)
                {
                    i++;
                }
                else if (Rm == 5)
                {
                    i += 4;
                }
                break;
            case 1:
                i += 1 + (Rm == 4 ? 1 : 0);
                break;
            case 2:
                i += 4 + (Rm == 4 ? 1 : 0);
                break;
            case 3:
                // No extra bytes.
                break;
            }
        }
        else if (Code[i] >= 0x50 && Code[i] <= 0x57)
        {
            // push rd
            if (Code[i] == 0x55)
            {
                // push ebp
                // Found it.
                StackAddr += (NumRegs - Depth - 1) * STACK_SIZE;
                WDB(("        found ebp at %X\n", (ULONG)StackAddr));
                return StackAddr;
            }
            else
            {
                // Consumes a stack slot.
                Depth++;
            }
        }
        else
        {
            // Unhandled code, fail.
            return StackAddr;
        }
    }

    // Didn't find a push ebp, fail.
    WDB(("        no ebp, use %X\n", (ULONG)StackAddr));
    return StackAddr;
}


BOOL
GetFpoFrameBase(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PFPO_DATA                         pFpoData,
    BOOL                              fFirstFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    DWORD          Addr32;
    X86_KTRAP_FRAME    TrapFrame;
    DWORD64        OldFrameAddr;
    DWORD64        FrameAddr;
    DWORD64        StackAddr;
    DWORD64        ModuleBase;
    DWORD64        FuncAddr;
    DWORD          cb;
    DWORD64        StoredEbp;
    PFPO_DATA      PreviousFpoData = (PFPO_DATA)StackFrame->FuncTableEntry;

    //
    // calculate the address of the beginning of the function
    //
    ModuleBase = GetModuleBase( Process, StackFrame->AddrPC.Offset );
#ifdef NO_TEMPORARY_MODULE_BASE_HACK
    if (!ModuleBase) {
        return FALSE;
    }

    FuncAddr = ModuleBase+pFpoData->ulOffStart;
#else
    // XXX drewb - Currently we have a couple of fake
    // symbols for the new fast syscall code in the
    // user shared data area.  There is no module
    // associated with that area but we still want
    // to return FPO data for the stubs to get
    // stack traces to work well, so hack this check.
    // Later we'll do a full fake module.
    if (!ModuleBase) {
        FuncAddr = pFpoData->ulOffStart;
    } else {
        FuncAddr = ModuleBase+pFpoData->ulOffStart;
    }
#endif

    WDB(("    GetFpoFrameBase: PC %X, Func %X, first %d, FPO %p [%d,%d,%d]\n",
         (ULONG)StackFrame->AddrPC.Offset, (ULONG)FuncAddr,
         fFirstFrame, pFpoData, pFpoData->cdwParams, pFpoData->cdwLocals,
         pFpoData->cbRegs));
    
    //
    // If this isn't the first/current frame then we can add back the count
    // bytes of locals and register pushed before beginning to search for
    // vEBP.  If we are beyond prolog we can add back the count bytes of locals
    // and registers pushed as well.  If it is the first frame and EIP is
    // greater than the address of the function then the SUB for locals has
    // been done so we can add them back before beginning the search.  If we
    // are right on the function then we will need to start our search at ESP.
    //

    if ( !fFirstFrame ) {

        OldFrameAddr = StackFrame->AddrFrame.Offset;
        FrameAddr = 0;

        //
        // if this is a non-fpo or trap frame, get the frame base now:
        //

        if (pFpoData->cbFrame != FRAME_FPO) {

            if (!PreviousFpoData || PreviousFpoData->cbFrame == FRAME_NONFPO) {

                //
                // previous frame base is ebp and points to this frame's ebp
                //
                ReadMemory(Process,
                           OldFrameAddr,
                           &Addr32,
                           sizeof(DWORD),
                           &cb);

                FrameAddr = (DWORD64)(LONG64)(LONG)Addr32;
            }

            //
            // if that didn't work, try for a saved ebp
            //
            if (!FrameAddr && SAVE_EBP(StackFrame)) {

                FrameAddr = SAVE_EBP(StackFrame);
                WDB(("      non-FPO using %X\n", (ULONG)FrameAddr));

            }

            //
            // this is not an FPO frame, so the saved EBP can only have come
            // from this or a lower frame.
            //

            SAVE_EBP(StackFrame) = 0;
        }

        //
        // still no frame base - either this frame is fpo, or we couldn't
        // follow the ebp chain.
        //

        if (FrameAddr == 0) {
            FrameAddr = OldFrameAddr;

            //
            // skip over return address from prev frame
            //
            FrameAddr += FRAME_SIZE;

            //
            // skip over this frame's locals and saved regs
            //
            FrameAddr += ( pFpoData->cdwLocals * STACK_SIZE );
            FrameAddr += ( pFpoData->cbRegs * STACK_SIZE );

            if (PreviousFpoData) {
                //
                // if the previous frame had an fpo record, we can account
                // for its parameters
                //
                FrameAddr += PreviousFpoData->cdwParams * STACK_SIZE;

            }
        }

        //
        // if this is an FPO frame
        // and the previous frame was non-fpo,
        // and this frame passed the inherited ebp to the previous frame,
        //  save its ebp
        //
        // (if this frame used ebp, SAVE_EBP will be set after verifying
        // the frame base)
        //
        if (pFpoData->cbFrame == FRAME_FPO &&
            (!PreviousFpoData || PreviousFpoData->cbFrame == FRAME_NONFPO) &&
            !pFpoData->fUseBP) {

            SAVE_EBP(StackFrame) = 0;

            if (ReadMemory(Process,
                           OldFrameAddr,
                           &Addr32,
                           sizeof(DWORD),
                           &cb)) {

                SAVE_EBP(StackFrame) = (DWORD64)(LONG64)(LONG)Addr32;
                WDB(("      pass-through FP %X\n", Addr32));
            } else {
                WDB(("      clear ebp\n"));
            }
        }


    } else {

        OldFrameAddr = StackFrame->AddrFrame.Offset;
        if (pFpoData->cbFrame == FRAME_FPO && !pFpoData->fUseBP) {
            //
            // this frame didn't use EBP, so it actually belongs
            // to a non-FPO frame further up the stack.  Stash
            // it in the save area for the next frame.
            //
            SAVE_EBP(StackFrame) = StackFrame->AddrFrame.Offset;
            WDB(("      first non-ebp save %X\n", (ULONG)SAVE_EBP(StackFrame)));
        }

        if (pFpoData->cbFrame == FRAME_TRAP ||
            pFpoData->cbFrame == FRAME_TSS) {

            FrameAddr = StackFrame->AddrFrame.Offset;

        } else if (StackFrame->AddrPC.Offset == FuncAddr) {

            FrameAddr = StackFrame->AddrStack.Offset;

        } else if (StackFrame->AddrPC.Offset >= FuncAddr+pFpoData->cbProlog) {

            FrameAddr = StackFrame->AddrStack.Offset +
                        ( pFpoData->cdwLocals * STACK_SIZE ) +
                        ( pFpoData->cbRegs * STACK_SIZE );

        } else {

            FrameAddr = StackFrame->AddrStack.Offset +
                        ( pFpoData->cdwLocals * STACK_SIZE );

        }

    }


    if (pFpoData->cbFrame == FRAME_TRAP) {

        //
        // read a kernel mode trap frame from the stack
        //

        if (!ReadTrapFrame( Process,
                            FrameAddr,
                            &TrapFrame,
                            ReadMemory )) {
            return FALSE;
        }

        SAVE_TRAP(StackFrame) = FrameAddr;
        TRAP_EDITED(StackFrame) = TrapFrame.SegCs & X86_FRAME_EDITED;

        StackFrame->AddrReturn.Offset = (DWORD64)(LONG64)(LONG)(TrapFrame.Eip);
        StackFrame->AddrReturn.Mode = AddrModeFlat;
        StackFrame->AddrReturn.Segment = 0;

        return TRUE;
    }

    if (pFpoData->cbFrame == FRAME_TSS) {

        //
        // translate a tss to a kernel mode trap frame
        //

        StackAddr = FrameAddr;

        TaskGate2TrapFrame( Process, X86_KGDT_TSS, &TrapFrame, &StackAddr, ReadMemory );

        TRAP_TSS(StackFrame) = X86_KGDT_TSS;
        SAVE_TRAP(StackFrame) = StackAddr;

        StackFrame->AddrReturn.Offset = (DWORD64)(LONG64)(LONG)(TrapFrame.Eip);
        StackFrame->AddrReturn.Mode = AddrModeFlat;
        StackFrame->AddrReturn.Segment = 0;

        return TRUE;
    }

    if ((pFpoData->cbFrame != FRAME_FPO) &&
        (pFpoData->cbFrame != FRAME_NONFPO) ) {
        //
        // we either have a compiler or linker problem, or possibly
        // just simple data corruption.
        //
        return FALSE;
    }

    //
    // go look for a return address.  this is done because, even though
    // we have subtracted all that we can from the frame pointer it is
    // possible that there is other unknown data on the stack.  by
    // searching for the return address we are able to find the base of
    // the fpo frame.
    //
    FrameAddr = SearchForReturnAddress( Process,
                                        FrameAddr,
                                        FuncAddr,
                                        pFpoData->cbProcSize,
                                        ReadMemory,
                                        GetModuleBase,
                                        PreviousFpoData != NULL
                                        );
    if (!FrameAddr) {
        return FALSE;
    }

    if (pFpoData->fUseBP && pFpoData->cbFrame == FRAME_FPO) {

        //
        // this function used ebp as a general purpose register, but
        // before doing so it saved ebp on the stack.
        //
        // we must retrieve this ebp and save it for possible later
        // use if we encounter a non-fpo frame
        //

        if (fFirstFrame && StackFrame->AddrPC.Offset < FuncAddr+pFpoData->cbProlog) {

            SAVE_EBP(StackFrame) = OldFrameAddr;
            WDB(("      first use save FP %X\n", (ULONG)OldFrameAddr));

        } else {

            SAVE_EBP(StackFrame) = 0;

            // FPO information doesn't indicate which of the saved
            // registers is EBP and the compiler doesn't push in a
            // consistent way.  Scan the register slots of the
            // stack for something that looks OK.
            StackAddr = FrameAddr -
                ( ( pFpoData->cbRegs + pFpoData->cdwLocals ) * STACK_SIZE );
            StackAddr = SearchForFramePointer( Process,
                                               StackAddr,
                                               pFpoData->cbRegs,
                                               FuncAddr,
                                               pFpoData->cbProcSize,
                                               ReadMemory
                                               );
            if (StackAddr &&
                ReadMemory(Process,
                           StackAddr,
                           &Addr32,
                           sizeof(DWORD),
                           &cb)) {

                SAVE_EBP(StackFrame) = (DWORD64)(LONG64)(LONG)Addr32;
                WDB(("      use search save %X from %X\n", Addr32,
                     (ULONG)StackAddr));
            } else {
                WDB(("      use clear ebp\n"));
            }
        }
    }

    //
    // subtract the size for an ebp register if one had
    // been pushed.  this is done because the frames that
    // are virtualized need to appear as close to a real frame
    // as possible.
    //

    StackFrame->AddrFrame.Offset = FrameAddr - STACK_SIZE;

    return TRUE;
}


BOOL
ReadTrapFrame(
    HANDLE                            Process,
    DWORD64                           TrapFrameAddress,
    PX86_KTRAP_FRAME                  TrapFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    )
{
    DWORD cb;

    if (!ReadMemory(Process,
                    TrapFrameAddress,
                    TrapFrame,
                    sizeof(*TrapFrame),
                    &cb)) {
        return FALSE;
    }

    if (cb < sizeof(*TrapFrame)) {
        if (cb < sizeof(*TrapFrame) - 20) {
            //
            // shorter then the smallest possible frame type
            //
            return FALSE;
        }

        if ((TrapFrame->SegCs & 1) &&  cb < sizeof(*TrapFrame) - 16 ) {
            //
            // too small for inter-ring frame
            //
            return FALSE;
        }

        if (TrapFrame->EFlags & X86_EFLAGS_V86_MASK) {
            //
            // too small for V86 frame
            //
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
GetSelector(
    HANDLE                            Process,
    USHORT                            Processor,
    PX86_DESCRIPTOR_TABLE_ENTRY       pDescriptorTableEntry,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    )
{
    ULONG_PTR   Address;
    PVOID       TableBase;
    USHORT      TableLimit;
    ULONG       Index;
    X86_LDT_ENTRY   Descriptor;
    ULONG       bytesread;


    //
    // Fetch the address and limit of the GDT
    //
    Address = (ULONG_PTR)&(((PX86_KSPECIAL_REGISTERS)0)->Gdtr.Base);
    ReadMemory( Process, Address, &TableBase, sizeof(TableBase), (LPDWORD)-1  );
    Address = (ULONG_PTR)&(((PX86_KSPECIAL_REGISTERS)0)->Gdtr.Limit);
    ReadMemory( Process, Address, &TableLimit, sizeof(TableLimit),  (LPDWORD)-1  );

    //
    // Find out whether this is a GDT or LDT selector
    //
    if (pDescriptorTableEntry->Selector & 0x4) {

        //
        // This is an LDT selector, so we reload the TableBase and TableLimit
        // with the LDT's Base & Limit by loading the descriptor for the
        // LDT selector.
        //

        if (!ReadMemory(Process,
                        (ULONG64)TableBase+X86_KGDT_LDT,
                        &Descriptor,
                        sizeof(Descriptor),
                        &bytesread)) {
            return FALSE;
        }

        TableBase = (PVOID)(DWORD_PTR)((ULONG)Descriptor.BaseLow +    // Sundown: zero-extension from ULONG to PVOID.
                    ((ULONG)Descriptor.HighWord.Bits.BaseMid << 16) +
                    ((ULONG)Descriptor.HighWord.Bytes.BaseHi << 24));

        TableLimit = Descriptor.LimitLow;  // LDT can't be > 64k

        if(Descriptor.HighWord.Bits.Granularity) {

            //
            //  I suppose it's possible, to have an
            //  LDT with page granularity.
            //
            TableLimit <<= X86_PAGE_SHIFT;
        }
    }

    Index = (USHORT)(pDescriptorTableEntry->Selector) & ~0x7;
                                                    // Irrelevant bits
    //
    // Check to make sure that the selector is within the table bounds
    //
    if (Index >= TableLimit) {

        //
        // Selector is out of table's bounds
        //

        return FALSE;
    }

    if (!ReadMemory(Process,
                    (ULONG64)TableBase+Index,
                    &(pDescriptorTableEntry->Descriptor),
                    sizeof(pDescriptorTableEntry->Descriptor),
                    &bytesread)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
TaskGate2TrapFrame(
    HANDLE                            Process,
    USHORT                            TaskRegister,
    PX86_KTRAP_FRAME                  TrapFrame,
    PULONG64                          off,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    )
{
    X86_DESCRIPTOR_TABLE_ENTRY desc;
    ULONG                    bytesread;
    struct  {
        ULONG   r1[8];
        ULONG   Eip;
        ULONG   EFlags;
        ULONG   Eax;
        ULONG   Ecx;
        ULONG   Edx;
        ULONG   Ebx;
        ULONG   Esp;
        ULONG   Ebp;
        ULONG   Esi;
        ULONG   Edi;
        ULONG   Es;
        ULONG   Cs;
        ULONG   Ss;
        ULONG   Ds;
        ULONG   Fs;
        ULONG   Gs;
    } TaskState;


    //
    // Get the task register
    //

    desc.Selector = TaskRegister;
    if (!GetSelector(Process, 0, &desc, ReadMemory)) {
        return FALSE;
    }

    if (desc.Descriptor.HighWord.Bits.Type != 9  &&
        desc.Descriptor.HighWord.Bits.Type != 0xb) {
        //
        // not a 32bit task descriptor
        //
        return FALSE;
    }

    //
    // Read in Task State Segment
    //

    *off = ((ULONG)desc.Descriptor.BaseLow +
           ((ULONG)desc.Descriptor.HighWord.Bytes.BaseMid << 16) +
           ((ULONG)desc.Descriptor.HighWord.Bytes.BaseHi  << 24) );

    if (!ReadMemory(Process,
                    (ULONG64)(LONG64)(LONG)(*off),
                    &TaskState,
                    sizeof(TaskState),
                    &bytesread)) {
        return FALSE;
    }

    //
    // Move fields from Task State Segment to TrapFrame
    //

    ZeroMemory( TrapFrame, sizeof(*TrapFrame) );

    TrapFrame->Eip    = TaskState.Eip;
    TrapFrame->EFlags = TaskState.EFlags;
    TrapFrame->Eax    = TaskState.Eax;
    TrapFrame->Ecx    = TaskState.Ecx;
    TrapFrame->Edx    = TaskState.Edx;
    TrapFrame->Ebx    = TaskState.Ebx;
    TrapFrame->Ebp    = TaskState.Ebp;
    TrapFrame->Esi    = TaskState.Esi;
    TrapFrame->Edi    = TaskState.Edi;
    TrapFrame->SegEs  = TaskState.Es;
    TrapFrame->SegCs  = TaskState.Cs;
    TrapFrame->SegDs  = TaskState.Ds;
    TrapFrame->SegFs  = TaskState.Fs;
    TrapFrame->SegGs  = TaskState.Gs;
    TrapFrame->HardwareEsp = TaskState.Esp;
    TrapFrame->HardwareSegSs = TaskState.Ss;

    return TRUE;
}

BOOL
ProcessTrapFrame(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PFPO_DATA                         pFpoData,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess
    )
{
    X86_KTRAP_FRAME TrapFrame;
    DWORD64         StackAddr;

    if (((PFPO_DATA)StackFrame->FuncTableEntry)->cbFrame == FRAME_TSS) {
        StackAddr = SAVE_TRAP(StackFrame);
        TaskGate2TrapFrame( Process, X86_KGDT_TSS, &TrapFrame, &StackAddr, ReadMemory );
    } else {
        if (!ReadTrapFrame( Process,
                            SAVE_TRAP(StackFrame),
                            &TrapFrame,
                            ReadMemory)) {
            SAVE_TRAP(StackFrame) = 0;
            return FALSE;
        }
    }

    pFpoData = (PFPO_DATA)
               FunctionTableAccess(Process,
                                   (DWORD64)(LONG64)(LONG)TrapFrame.Eip);

    if (!pFpoData) {
        StackFrame->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.Ebp;
        SAVE_EBP(StackFrame) = 0;
    } else {
        if ((TrapFrame.SegCs & X86_MODE_MASK) ||
            (TrapFrame.EFlags & X86_EFLAGS_V86_MASK)) {
            //
            // User-mode frame, real value of Esp is in HardwareEsp
            //
            StackFrame->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)(TrapFrame.HardwareEsp - STACK_SIZE);
            StackFrame->AddrStack.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.HardwareEsp;

        } else {
            //
            // We ignore if Esp has been edited for now, and we will print a
            // separate line indicating this later.
            //
            // Calculate kernel Esp
            //

            if (((PFPO_DATA)StackFrame->FuncTableEntry)->cbFrame == FRAME_TRAP) {
                //
                // plain trap frame
                //
                if ((TrapFrame.SegCs & X86_FRAME_EDITED) == 0) {
                    StackFrame->AddrStack.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.TempEsp;
                } else {
                    StackFrame->AddrStack.Offset = (ULONG64)(LONG64)(LONG_PTR)
                        (& (((PX86_KTRAP_FRAME)SAVE_TRAP(StackFrame))->HardwareEsp) );
                }
            } else {
                //
                // tss converted to trap frame
                //
                StackFrame->AddrStack.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.HardwareEsp;
            }
        }
    }

    StackFrame->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.Ebp;
    StackFrame->AddrPC.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.Eip;

    SAVE_TRAP(StackFrame) = 0;
    StackFrame->FuncTableEntry = pFpoData;

    return TRUE;
}

BOOL
IsFarCall(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    BOOL                              *Ok,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL       fFar = FALSE;
    ULONG      cb;
    ADDRESS64  Addr;

    *Ok = TRUE;

    if (StackFrame->AddrFrame.Mode == AddrModeFlat) {
        DWORD      dwStk[ 3 ];
        //
        // If we are working with 32 bit offset stack pointers, we
        //      will say that the return address if far if the address
        //      treated as a FAR pointer makes any sense,  if not then
        //      it must be a near return
        //

        if (StackFrame->AddrFrame.Offset &&
            DoMemoryRead( &StackFrame->AddrFrame, dwStk, sizeof(dwStk), &cb )) {
            //
            //  See if segment makes sense
            //

            Addr.Offset   = (DWORD64)(LONG64)(LONG)(dwStk[1]);
            Addr.Segment  = (WORD)dwStk[2];
            Addr.Mode = AddrModeFlat;

            if (TranslateAddress( Process, Thread, &Addr ) && Addr.Offset) {
                fFar = TRUE;
            }
        } else {
            *Ok = FALSE;
        }
    } else {
        WORD       wStk[ 3 ];
        //
        // For 16 bit (i.e. windows WOW code) we do the following tests
        //      to check to see if an address is a far return value.
        //
        //      1.  if the saved BP register is odd then it is a far
        //              return values
        //      2.  if the address treated as a far return value makes sense
        //              then it is a far return value
        //      3.  else it is a near return value
        //

        if (StackFrame->AddrFrame.Offset &&
            DoMemoryRead( &StackFrame->AddrFrame, wStk, 6, &cb )) {

            if ( wStk[0] & 0x0001 ) {
                fFar = TRUE;
            } else {

                //
                //  See if segment makes sense
                //

                Addr.Offset   = wStk[1];
                Addr.Segment  = wStk[2];
                Addr.Mode = AddrModeFlat;

                if (TranslateAddress( Process, Thread, &Addr  ) && Addr.Offset) {
                    fFar = TRUE;
                }
            }
        } else {
            *Ok = FALSE;
        }
    }
    return fFar;
}


BOOL
SetNonOff32FrameAddress(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL    fFar;
    WORD    Stk[ 3 ];
    ULONG   cb;
    BOOL    Ok;

    fFar = IsFarCall( Process, Thread, StackFrame, &Ok, ReadMemory, TranslateAddress );

    if (!Ok) {
        return FALSE;
    }

    if (!DoMemoryRead( &StackFrame->AddrFrame, Stk, (DWORD)(fFar ? FRAME_SIZE1632 : FRAME_SIZE16), &cb )) {
        return FALSE;
    }

    if (SAVE_EBP(StackFrame) > 0) {
        StackFrame->AddrFrame.Offset = SAVE_EBP(StackFrame) & 0xffff;
        StackFrame->AddrPC.Offset = Stk[1];
        if (fFar) {
            StackFrame->AddrPC.Segment = Stk[2];
        }
        SAVE_EBP(StackFrame) = 0;
    } else {
        if (Stk[1] == 0) {
            return FALSE;
        } else {
            StackFrame->AddrFrame.Offset = Stk[0];
            StackFrame->AddrFrame.Offset &= 0xFFFFFFFE;
            StackFrame->AddrPC.Offset = Stk[1];
            if (fFar) {
                StackFrame->AddrPC.Segment = Stk[2];
            }
        }
    }

    return TRUE;
}

VOID
X86ReadFunctionParameters(
    HANDLE Process,
    ULONG64 Offset,
    LPSTACKFRAME64 Frame,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory
    )
{
    DWORD Params[4];
    DWORD Done;
    
    if (ReadMemory(Process, Offset, Params, sizeof(Params), &Done)) {
        Frame->Params[0] = (DWORD64)(LONG64)(LONG)(Params[0]);
        Frame->Params[1] = (DWORD64)(LONG64)(LONG)(Params[1]);
        Frame->Params[2] = (DWORD64)(LONG64)(LONG)(Params[2]);
        Frame->Params[3] = (DWORD64)(LONG64)(LONG)(Params[3]);
    } else {
        Frame->Params[0] =
        Frame->Params[1] =
        Frame->Params[2] =
        Frame->Params[3] = 0;
    }
}

VOID
GetFunctionParameters(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL                Ok;
    ADDRESS64           ParmsAddr;

    ParmsAddr = StackFrame->AddrFrame;

    //
    // calculate the frame size
    //
    if (StackFrame->AddrPC.Mode == AddrModeFlat) {

        ParmsAddr.Offset += FRAME_SIZE;

    } else
    if ( IsFarCall( Process, Thread, StackFrame, &Ok,
                    ReadMemory, TranslateAddress ) ) {

        StackFrame->Far = TRUE;
        ParmsAddr.Offset += FRAME_SIZE1632;

    } else {

        StackFrame->Far = FALSE;
        ParmsAddr.Offset += STACK_SIZE;

    }

    //
    // read the memory
    //

    if (ParmsAddr.Mode != AddrModeFlat) {
        TranslateAddress( Process, Thread, &ParmsAddr );
    }

    X86ReadFunctionParameters(Process, ParmsAddr.Offset, StackFrame,
                              ReadMemory);
}

VOID
GetReturnAddress(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess
    )
{
    ULONG               cb;
    DWORD               stack[1];


    if (SAVE_TRAP(StackFrame)) {
        //
        // if a trap frame was encountered then
        // the return address was already calculated
        //
        return;
    }

    WDB(("    GetReturnAddress: SP %X, FP %X\n",
         (ULONG)StackFrame->AddrStack.Offset,
         (ULONG)StackFrame->AddrFrame.Offset));
    
    if (StackFrame->AddrPC.Mode == AddrModeFlat) {

        ULONG64 CallOffset;
        PFPO_DATA CallFpo;
        ADDRESS64 FrameRet;
        FPO_DATA SaveCallFpo;
        PFPO_DATA RetFpo;
        
        //
        // read the frame from the process's memory
        //
        FrameRet = StackFrame->AddrFrame;
        FrameRet.Offset += STACK_SIZE;
        if (!DoMemoryRead( &FrameRet, stack, STACK_SIZE, &cb ) ||
            cb < STACK_SIZE) {
            //
            // if we could not read the memory then set
            // the return address to zero so that the stack trace
            // will terminate
            //

            stack[0] = 0;

        }

        StackFrame->AddrReturn.Offset = (DWORD64)(LONG64)(LONG)(stack[0]);
        WDB(("    read %X\n", stack[0]));

        //
        // Calls of __declspec(noreturn) functions may not have any
        // code after them to return to since the compiler knows
        // that the function will not return.  This can confuse
        // stack traces because the return address will lie outside
        // of the function's address range and FPO data will not
        // be looked up correctly.  Check and see if the return
        // address falls outside of the calling function and, if so,
        // adjust the return address back by one byte.  It'd be
        // better to adjust it back to the call itself so that
        // the return address points to valid code but
        // backing up in X86 assembly is more or less impossible.
        //

        CallOffset = StackFrame->AddrReturn.Offset - 1;
        CallFpo = (PFPO_DATA)FunctionTableAccess(Process, CallOffset);
        if (CallFpo != NULL) {
            SaveCallFpo = *CallFpo;
        }
        RetFpo = (PFPO_DATA)
            FunctionTableAccess(Process, StackFrame->AddrReturn.Offset);
        if (CallFpo != NULL) {
            if (RetFpo == NULL ||
                memcmp(&SaveCallFpo, RetFpo, sizeof(SaveCallFpo))) {
                StackFrame->AddrReturn.Offset = CallOffset;
            } 
        } else if (RetFpo != NULL) {
            StackFrame->AddrReturn.Offset = CallOffset;
        }
        
    } else {

        StackFrame->AddrReturn.Offset = StackFrame->AddrPC.Offset;
        StackFrame->AddrReturn.Segment = StackFrame->AddrPC.Segment;

    }
}

BOOL
WalkX86_Fpo_Fpo(
    HANDLE                            Process,
    HANDLE                            Thread,
    PFPO_DATA                         pFpoData,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL rval;

    WDB(("  WalkFF:\n"));
    
    rval = GetFpoFrameBase( Process,
                            StackFrame,
                            pFpoData,
                            FALSE,
                            ReadMemory,
                            GetModuleBase );

    StackFrame->FuncTableEntry = pFpoData;

    return rval;
}

BOOL
WalkX86_Fpo_NonFpo(
    HANDLE                            Process,
    HANDLE                            Thread,
    PFPO_DATA                         pFpoData,
    LPSTACKFRAME64                    StackFrame,
    PX86_CONTEXT                      ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    DWORD       stack[FRAME_SIZE+STACK_SIZE];
    DWORD       cb;
    DWORD64     FrameAddr;
    DWORD64     FuncAddr;
    DWORD       FuncSize;
    BOOL        AcceptUnreadableCallsite = FALSE;

    WDB(("  WalkFN:\n"));
    
    //
    // if the previous frame was an seh frame then we must
    // retrieve the "real" frame pointer for this frame.
    // the seh function pushed the frame pointer last.
    //

    if (((PFPO_DATA)StackFrame->FuncTableEntry)->fHasSEH) {

        if (DoMemoryRead( &StackFrame->AddrFrame, stack, FRAME_SIZE+STACK_SIZE, &cb )) {

            StackFrame->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)(stack[2]);
            StackFrame->AddrStack.Offset = (DWORD64)(LONG64)(LONG)(stack[2]);
            WalkX86Init(Process,
                        Thread,
                        StackFrame,
                        ContextRecord,
                        ReadMemory,
                        FunctionTableAccess,
                        GetModuleBase,
                        TranslateAddress);

            return TRUE;
        }
    }

    //
    // If a prior frame has stored this frame's EBP, just use it.
    //

    if (SAVE_EBP(StackFrame)) {

        StackFrame->AddrFrame.Offset = SAVE_EBP(StackFrame);
        FrameAddr = StackFrame->AddrFrame.Offset + 4;
        AcceptUnreadableCallsite = TRUE;
        WDB(("    use %X\n", (ULONG)FrameAddr));

    } else {

        //
        // Skip past the FPO frame base and parameters.
        //
        StackFrame->AddrFrame.Offset +=
            (FRAME_SIZE + (((PFPO_DATA)StackFrame->FuncTableEntry)->cdwParams * 4));

        //
        // Now this is pointing to the bottom of the non-FPO frame.
        // If the frame has an fpo record, use it:
        //

        if (pFpoData) {
            FrameAddr = StackFrame->AddrFrame.Offset +
                            4* (pFpoData->cbRegs + pFpoData->cdwLocals);
            AcceptUnreadableCallsite = TRUE;
        } else {
            //
            // We don't know if the non-fpo frame has any locals, but
            // skip past the EBP anyway.
            //
            FrameAddr = StackFrame->AddrFrame.Offset + 4;
        }

        WDB(("    compute %X\n", (ULONG)FrameAddr));
    }

    //
    // at this point we may not be sitting at the base of the frame
    // so we now search for the return address and then subtract the
    // size of the frame pointer and use that address as the new base.
    //

    if (pFpoData) {
        FuncAddr = GetModuleBase(Process,StackFrame->AddrPC.Offset) + pFpoData->ulOffStart;
        FuncSize = pFpoData->cbProcSize;

    } else {
        FuncAddr = StackFrame->AddrPC.Offset - MAX_CALL;
        FuncSize = MAX_CALL;
    }



    FrameAddr = SearchForReturnAddress( Process,
                                        FrameAddr,
                                        FuncAddr,
                                        FuncSize,
                                        ReadMemory,
                                        GetModuleBase,
                                        AcceptUnreadableCallsite
                                        );
    if (FrameAddr) {
        StackFrame->AddrFrame.Offset = FrameAddr - STACK_SIZE;
    }

    if (!DoMemoryRead( &StackFrame->AddrFrame, stack, FRAME_SIZE, &cb )) {
        //
        // a failure means that we likely have a bad address.
        // returning zero will terminate that stack trace.
        //
        stack[0] = 0;
    }

    SAVE_EBP(StackFrame) = (DWORD64)(LONG64)(LONG)(stack[0]);
    WDB(("    save %X\n", stack[0]));

    StackFrame->FuncTableEntry = pFpoData;

    return TRUE;
}

BOOL
WalkX86_NonFpo_Fpo(
    HANDLE                            Process,
    HANDLE                            Thread,
    PFPO_DATA                         pFpoData,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL           rval;

    WDB(("  WalkNF:\n"));
    
    rval = GetFpoFrameBase( Process,
                            StackFrame,
                            pFpoData,
                            FALSE,
                            ReadMemory,
                            GetModuleBase );

    StackFrame->FuncTableEntry = pFpoData;

    return rval;
}

BOOL
WalkX86_NonFpo_NonFpo(
    HANDLE                            Process,
    HANDLE                            Thread,
    PFPO_DATA                         pFpoData,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    DWORD       stack[FRAME_SIZE*4];
    DWORD       cb;

    WDB(("  WalkNN:\n"));
    
    //
    // a previous function in the call stack was a fpo function that used ebp as
    // a general purpose register.  ul contains the ebp value that was good  before
    // that function executed.  it is that ebp that we want, not what was just read
    // from the stack.  what was just read from the stack is totally bogus.
    //
    if (SAVE_EBP(StackFrame)) {

        StackFrame->AddrFrame.Offset = SAVE_EBP(StackFrame);
        SAVE_EBP(StackFrame) = 0;

    } else {

        //
        // read the first 2 dwords off the stack
        //
        if (!DoMemoryRead( &StackFrame->AddrFrame, stack, FRAME_SIZE, &cb )) {
            return FALSE;
        }

        StackFrame->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)(stack[0]);
    }

    StackFrame->FuncTableEntry = pFpoData;

    return TRUE;
}

BOOL
X86ApplyFrameData(
    HANDLE Process,
    LPSTACKFRAME64 StackFrame,
    PX86_CONTEXT ContextRecord,
    BOOL FirstFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    PGET_MODULE_BASE_ROUTINE64 GetModuleBase
    )
{
    IDiaFrameData* DiaFrame;
    BOOL Succ = FALSE;
    
    // If we can get VC7-style frame data just execute
    // the frame data program to unwind the stack.
    // If weren't given a context record we cannot use
    // the new VC7 unwind information as we have nowhere
    // to save intermediate context values.
    if (StackFrame->AddrPC.Mode != AddrModeFlat ||
        !g_vc7fpo ||
        !ContextRecord ||
        !diaGetFrameData(Process, StackFrame->AddrPC.Offset, &DiaFrame))
    {
        return FALSE;
    }

    if (FirstFrame)
    {
        ContextRecord->Ebp = (ULONG)StackFrame->AddrFrame.Offset;
        ContextRecord->Esp = (ULONG)StackFrame->AddrStack.Offset;
        ContextRecord->Eip = (ULONG)StackFrame->AddrPC.Offset;
    }
    
    WDB(("  Applying frame data program for PC %X SP %X FP %X\n",
         ContextRecord->Eip, ContextRecord->Esp, ContextRecord->Ebp));

    //
    // execute() does not currently work when the PC is
    // within the function prologue.  This should only
    // happen on calls from WalkX86Init, in which case the
    // normal failure path here where the non-frame-data
    // code will be executed is correct as that will handle
    // normal prologue code.
    //
    
    X86WalkFrame WalkFrame(Process, ContextRecord,
                           ReadMemory, GetModuleBase);
    Succ = DiaFrame->execute(&WalkFrame) == S_OK;
            
    if (Succ) {
        WDB(("  Result PC %X SP %X FP %X\n",
             ContextRecord->Eip, ContextRecord->Esp, ContextRecord->Ebp));

        StackFrame->AddrStack.Mode = AddrModeFlat;
        StackFrame->AddrStack.Offset = EXTEND64(ContextRecord->Esp);
        StackFrame->AddrFrame.Mode = AddrModeFlat;
        // The frame value we want to return is the frame value
        // used for the function that was just unwound, not
        // the current value of EBP.  After the unwind the current
        // value of EBP is the caller's EBP, not the callee's
        // frame.  Instead we always set the callee's frame to
        // the offset beyond where the return address would be
        // as that's where the frame will be in a normal non-FPO
        // function and where we fake it as being for FPO functions.
        // We save the true EBP away for future frame use.
        StackFrame->AddrFrame.Offset =
            StackFrame->AddrStack.Offset - FRAME_SIZE;
        StackFrame->AddrReturn.Offset = EXTEND64(ContextRecord->Eip);
        SAVE_EBP(StackFrame) = ContextRecord->Ebp;

        // Do not return a pointer to an FPO record as
        // no such data was retrieved.
        StackFrame->FuncTableEntry = NULL;

        X86ReadFunctionParameters(Process, StackFrame->AddrStack.Offset,
                                  StackFrame, ReadMemory);
        
    } else {
        WDB(("  Apply failed\n"));
    }
    
    DiaFrame->Release();
    return Succ;
}

VOID
X86UpdateContextFromFrame(
    HANDLE Process,
    LPSTACKFRAME64 StackFrame,
    PX86_CONTEXT ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory
    )
{
    ULONG Ebp;
    ULONG Done;
    
    if (StackFrame->AddrPC.Mode != AddrModeFlat ||
        !ContextRecord) {
        return;
    }
    
    ContextRecord->Esp = (ULONG)StackFrame->AddrFrame.Offset + FRAME_SIZE;
    ContextRecord->Eip = (ULONG)StackFrame->AddrReturn.Offset;
    
    if (StackFrame->FuncTableEntry) {
        PFPO_DATA  pFpoData = (PFPO_DATA)StackFrame->FuncTableEntry;
        ULONG64 FrameAddr;


        Ebp = 0;

        if (pFpoData->cbFrame == FRAME_NONFPO) {

            FrameAddr = StackFrame->AddrFrame.Offset;
            //
            // frame base is ebp and points to next frame's ebp
            //
            ReadMemory(Process,
                       FrameAddr,
                       &Ebp,
                       sizeof(DWORD),
                       &Done);

            if (Ebp == 0) {
                Ebp = (ULONG) FrameAddr + STACK_SIZE;
            }
        } else if (pFpoData->fUseBP) {
            Ebp = (ULONG)SAVE_EBP(StackFrame);
        } else {

            Ebp = ContextRecord->Esp;
            Ebp += pFpoData->cdwParams * STACK_SIZE;
        }
        ContextRecord->Ebp = Ebp;

    } else {

        if (ReadMemory(Process, StackFrame->AddrFrame.Offset,
                       &Ebp, sizeof(Ebp), &Done) &&
            Done == sizeof(Ebp)) {
            ContextRecord->Ebp = Ebp;
        }
    }
}

BOOL
WalkX86Next(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PX86_CONTEXT                      ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    PFPO_DATA      pFpoData = NULL;
    BOOL           rVal = TRUE;
    DWORD64        Address;
    DWORD          cb;
    DWORD64        ThisPC;
    DWORD64        ModuleBase;
    DWORD64        SystemRangeStart;

    WDB(("WalkNext: PC %X, SP %X, FP %X\n",
         (ULONG)StackFrame->AddrReturn.Offset,
         (ULONG)StackFrame->AddrStack.Offset,
         (ULONG)StackFrame->AddrFrame.Offset));
    
    if (g.AppVersion.Revision >= 6) {
        SystemRangeStart = (ULONG64)(LONG64)(LONG_PTR)(SYSTEM_RANGE_START(StackFrame));
    } else {
        //
        // This might not really work right with old debuggers, but it keeps
        // us from looking off the end of the structure anyway.
        //
        SystemRangeStart = 0xFFFFFFFF80000000;
    }


    ThisPC = StackFrame->AddrPC.Offset;

    //
    // the previous frame's return address is this frame's pc
    //
    StackFrame->AddrPC = StackFrame->AddrReturn;

    if (StackFrame->AddrPC.Mode != AddrModeFlat) {
        //
        // the call stack is from either WOW or a DOS app
        //
        SetNonOff32FrameAddress( Process,
                                 Thread,
                                 StackFrame,
                                 ReadMemory,
                                 FunctionTableAccess,
                                 GetModuleBase,
                                 TranslateAddress
                               );
        goto exit;
    }

    //
    // if the last frame was the usermode callback dispatcher,
    // switch over to the kernel stack:
    //

    ModuleBase = GetModuleBase(Process, ThisPC);

    if ((g.AppVersion.Revision >= 4) &&
        (CALLBACK_STACK(StackFrame) != 0) &&
        (pFpoData = (PFPO_DATA)StackFrame->FuncTableEntry) &&
        (CALLBACK_DISPATCHER(StackFrame) == ModuleBase + pFpoData->ulOffStart) )  {


      NextCallback:

        rVal = FALSE;

        //
        // find callout frame
        //

        if ((ULONG64)(LONG64)(LONG_PTR)(CALLBACK_STACK(StackFrame)) >= SystemRangeStart) {

            //
            // it is the pointer to the stack frame that we want,
            // or -1.

            Address = (ULONG64)(LONG64)(LONG) CALLBACK_STACK(StackFrame);

        } else {

            //
            // if it is below SystemRangeStart, it is the offset to
            // the address in the thread.
            // Look up the pointer:
            //

            rVal = ReadMemory(Process,
                              (CALLBACK_THREAD(StackFrame) +
                                 CALLBACK_STACK(StackFrame)),
                              &Address,
                              sizeof(DWORD),
                              &cb);

            Address = (ULONG64)(LONG64)(LONG)Address;

            if (!rVal || Address == 0) {
                Address = 0xffffffff;
                CALLBACK_STACK(StackFrame) = 0xffffffff;
            }

        }

        if ((Address == 0xffffffff) ||
            !(pFpoData = (PFPO_DATA) FunctionTableAccess( Process,
                                                 CALLBACK_FUNC(StackFrame))) ) {
            rVal = FALSE;

        } else {

            StackFrame->FuncTableEntry = pFpoData;

            StackFrame->AddrPC.Offset = CALLBACK_FUNC(StackFrame) +
                                                    pFpoData->cbProlog;

            StackFrame->AddrStack.Offset = Address;

            ReadMemory(Process,
                       Address + CALLBACK_FP(StackFrame),
                       &StackFrame->AddrFrame.Offset,
                       sizeof(DWORD),
                       &cb);

            StackFrame->AddrFrame.Offset = (ULONG64)(LONG64)(LONG)
                                         StackFrame->AddrFrame.Offset;

            ReadMemory(Process,
                       Address + CALLBACK_NEXT(StackFrame),
                       &CALLBACK_STACK(StackFrame),
                       sizeof(DWORD),
                       &cb);

            SAVE_TRAP(StackFrame) = 0;

            rVal = WalkX86Init(
                Process,
                Thread,
                StackFrame,
                ContextRecord,
                ReadMemory,
                FunctionTableAccess,
                GetModuleBase,
                TranslateAddress
                );

        }

        return rVal;

    }

    //
    // if there is a trap frame then handle it
    //
    if (SAVE_TRAP(StackFrame)) {
        rVal = ProcessTrapFrame(
            Process,
            StackFrame,
            pFpoData,
            ReadMemory,
            FunctionTableAccess
            );
        if (!rVal) {
            return rVal;
        }
        rVal = WalkX86Init(
            Process,
            Thread,
            StackFrame,
            ContextRecord,
            ReadMemory,
            FunctionTableAccess,
            GetModuleBase,
            TranslateAddress
            );
        return rVal;
    }

    //
    // if the PC address is zero then we're at the end of the stack
    //
    //if (GetModuleBase(Process, StackFrame->AddrPC.Offset) == 0)

    if (StackFrame->AddrPC.Offset < 65536) {

        //
        // if we ran out of stack, check to see if there is
        // a callback stack chain
        //
        if (g.AppVersion.Revision >= 4 && CALLBACK_STACK(StackFrame) != 0) {
            goto NextCallback;
        }

        return FALSE;
    }

    //
    // If the frame, pc and return address are all identical, then we are
    // at the top of the idle loop
    //

    if ((StackFrame->AddrPC.Offset == StackFrame->AddrReturn.Offset) &&
        (StackFrame->AddrPC.Offset == StackFrame->AddrFrame.Offset))
    {
        return FALSE;
    }

    if (X86ApplyFrameData(Process, StackFrame, ContextRecord, FALSE,
                          ReadMemory, GetModuleBase)) {
        return TRUE;
    }
    
    //
    // check to see if the current frame is an fpo frame
    //
    pFpoData = (PFPO_DATA) FunctionTableAccess(Process, StackFrame->AddrPC.Offset);


    if (pFpoData && pFpoData->cbFrame != FRAME_NONFPO) {
        if (StackFrame->FuncTableEntry && ((PFPO_DATA)StackFrame->FuncTableEntry)->cbFrame != FRAME_NONFPO) {

            rVal = WalkX86_Fpo_Fpo( Process,
                                  Thread,
                                  pFpoData,
                                  StackFrame,
                                  ReadMemory,
                                  FunctionTableAccess,
                                  GetModuleBase,
                                  TranslateAddress
                                );

        } else {

            rVal = WalkX86_NonFpo_Fpo( Process,
                                     Thread,
                                     pFpoData,
                                     StackFrame,
                                     ReadMemory,
                                     FunctionTableAccess,
                                     GetModuleBase,
                                     TranslateAddress
                                   );

        }
    } else {
        if (StackFrame->FuncTableEntry && ((PFPO_DATA)StackFrame->FuncTableEntry)->cbFrame != FRAME_NONFPO) {

            rVal = WalkX86_Fpo_NonFpo( Process,
                                     Thread,
                                     pFpoData,
                                     StackFrame,
                                     ContextRecord,
                                     ReadMemory,
                                     FunctionTableAccess,
                                     GetModuleBase,
                                     TranslateAddress
                                   );

        } else {

            rVal = WalkX86_NonFpo_NonFpo( Process,
                                        Thread,
                                        pFpoData,
                                        StackFrame,
                                        ReadMemory,
                                        FunctionTableAccess,
                                        GetModuleBase,
                                        TranslateAddress
                                      );

        }
    }

exit:
    StackFrame->AddrFrame.Mode = StackFrame->AddrPC.Mode;
    StackFrame->AddrReturn.Mode = StackFrame->AddrPC.Mode;

    GetFunctionParameters( Process, Thread, StackFrame,
                           ReadMemory, GetModuleBase, TranslateAddress );

    GetReturnAddress( Process, Thread, StackFrame,
                      ReadMemory, GetModuleBase, TranslateAddress,
                      FunctionTableAccess );

    X86UpdateContextFromFrame(Process, StackFrame, ContextRecord, ReadMemory);
    
    return rVal;
}

BOOL
WalkX86Init(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PX86_CONTEXT                      ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    UCHAR               code[3];
    DWORD               stack[FRAME_SIZE*4];
    PFPO_DATA           pFpoData = NULL;
    ULONG               cb;

    StackFrame->Virtual = TRUE;
    StackFrame->Reserved[0] =
    StackFrame->Reserved[1] =
    StackFrame->Reserved[2] = 0;
    StackFrame->AddrReturn = StackFrame->AddrPC;

    if (StackFrame->AddrPC.Mode != AddrModeFlat) {
        goto exit;
    }

    WDB(("WalkInit: PC %X, SP %X, FP %X\n",
         (ULONG)StackFrame->AddrPC.Offset, (ULONG)StackFrame->AddrStack.Offset,
         (ULONG)StackFrame->AddrFrame.Offset));

    if (X86ApplyFrameData(Process, StackFrame, ContextRecord, TRUE,
                          ReadMemory, GetModuleBase)) {
        return TRUE;
    }
    
    StackFrame->FuncTableEntry = pFpoData = (PFPO_DATA)
        FunctionTableAccess(Process, StackFrame->AddrPC.Offset);

    if (pFpoData && pFpoData->cbFrame != FRAME_NONFPO) {

        GetFpoFrameBase( Process,
                         StackFrame,
                         pFpoData,
                         TRUE,
                         ReadMemory,
                         GetModuleBase );

    } else {

        //
        // this code determines whether eip is in the function prolog
        //
        if (!DoMemoryRead( &StackFrame->AddrPC, code, 3, &cb )) {
            //
            // assume a call to a bad address if the memory read fails
            //
            code[0] = PUSHBP;
        }
        if ((code[0] == PUSHBP) || (*(LPWORD)&code[0] == MOVBPSP)) {
            SAVE_EBP(StackFrame) = StackFrame->AddrFrame.Offset;
            StackFrame->AddrFrame.Offset = StackFrame->AddrStack.Offset;
            if (StackFrame->AddrPC.Mode != AddrModeFlat) {
                StackFrame->AddrFrame.Offset &= 0xffff;
            }
            if (code[0] == PUSHBP) {
                if (StackFrame->AddrPC.Mode == AddrModeFlat) {
                    StackFrame->AddrFrame.Offset -= STACK_SIZE;
                } else {
                    StackFrame->AddrFrame.Offset -= STACK_SIZE16;
                }
            }
        } else {
            //
            // read the first 2 dwords off the stack
            //
            if (DoMemoryRead( &StackFrame->AddrFrame, stack, FRAME_SIZE, &cb )) {

                SAVE_EBP(StackFrame) = (ULONG64)(LONG64)(LONG)stack[0];

            }

            if (StackFrame->AddrPC.Mode != AddrModeFlat) {
                StackFrame->AddrFrame.Offset &= 0x0000FFFF;
            }
        }

    }

exit:
    StackFrame->AddrFrame.Mode = StackFrame->AddrPC.Mode;

    GetFunctionParameters( Process, Thread, StackFrame,
                           ReadMemory, GetModuleBase, TranslateAddress );

    GetReturnAddress( Process, Thread, StackFrame,
                      ReadMemory, GetModuleBase, TranslateAddress,
                      FunctionTableAccess );

    X86UpdateContextFromFrame(Process, StackFrame, ContextRecord, ReadMemory);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\wppfmt.h ===
// The main Formatting routine, normally used by Binplace and TracePDB
// Takes a PDB and creates guid.tmf files from it, all in TraceFormatFilePath
//
DWORD
BinplaceWppFmt(
              LPTSTR PdbFileName,
              LPTSTR TraceFormatFilePath,
              LPSTR szRSDSDllToLoad,
              BOOL  TraceVerbose
              ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\dbhtools\makefile.inc ===
$(O)\dbh.res: ..\dbh.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\amd64\chksum.asm ===
title  "Compute Checksum"
;/*++
;
; Copyright (c) 2001  Microsoft Corporation
;
; Module Name:
;
;   chksum.asm
;
; Abstract:
;
;   This module implements a fucntion to compute the checksum of a buffer.
;
; Author:
;
;   David N. Cutler (davec) 25-Jan-2001
;
; Environment:
;
;   Any mode.
;
; Revision History:
;
;--*/

include ksamd64.inc

        subttl  "Checksum"
;++
;
; USHORT
; ChkSum(
;   IN ULONG cksum,
;   IN PUSHORT buf,
;   IN ULONG len
;   )
;
; Routine Description:
;
;   This function computes the checksum of the specified buffer.
;
; Arguments:
;
;   cksum (ecx) - Suppiles the initial checksum value.
;
;   buf (rdx) - Supplies a pointer to the buffer that is checksumed.
;
;   len (r8d) - Supplies the of the buffer in words.
;
; Return Value:
;
;    The computed checksum is returned as the function value.
;
;--

        LEAF_ENTRY ChkSum, _TEXT$00

        mov     eax, ecx                ; set initial checksum value
        mov     ecx, r8d                ; set length of buffer in words
        shl     ecx, 1                  ; convert to length in bytes
        jz      cks80                   ; if z, no words to checksum

;
; Compute checksum in cascading order of block size until 128 byte blocks
; are all that is left, then loop on 128-byte blocks.
;

        test    rdx, 02h                ; check if source dword aligned
        jz      short cks10             ; if z, source is dword aligned
        xor     r8, r8                  ; get initial word for alignment
        mov     r8w, [rdx]              ;
        add     eax, r8d                ; update partial checkcum
        adc     eax, 0                  ; add carry
        add     rdx, 2                  ; update source address
        sub     ecx, 2                  ; reduce length in bytes
cks10:  mov     r8d, ecx                ; isolate residual bytes
        and     r8d, 07h                ;
        sub     ecx, r8d                ; subtract residual bytes
        jz      cks60                   ; if z, no 8-byte blocks
        test    ecx, 08h                ; test if initial 8-byte block
        jz      short cks20             ; if z, no initial 8-byte block
        add     eax, [rdx]              ; compute 8-byte checksum
        adc     eax, 4[rdx]             ;
        adc     eax, 0                  ; add carry
        add     rdx, 8                  ; update source address
        sub     ecx, 8                  ; reduce length of checksum
        jz      cks60                   ; if z, end of 8-byte blocks
cks20:  test    ecx, 010h               ; test if initial 16-byte block
        jz      short cks30             ; if z, no initial 16-byte block
        add     eax, [rdx]              ; compute 16-byte checksum
        adc     eax, 4[rdx]             ;
        adc     eax, 8[rdx]             ;
        adc     eax, 12[rdx]            ;
        adc     eax, 0                  ; add carry
        add     rdx, 16                 ; update source address
        sub     ecx, 16                 ; reduce length of checksum
        jz      cks60                   ; if z, end of 8-byte blocks
cks30:  test    ecx, 020h               ; test if initial 32-byte block
        jz      short cks40             ; if z set, no initial 32-byte block
        add     eax, [rdx]              ; compute 32-byte checksum
        adc     eax, 4[rdx]             ;
        adc     eax, 8[rdx]             ;
        adc     eax, 12[rdx]            ;
        adc     eax, 16[rdx]            ;
        adc     eax, 20[rdx]            ;
        adc     eax, 24[rdx]            ;
        adc     eax, 28[rdx]            ;
        adc     eax, 0                  ; add carry
        add     rdx, 32                 ; update source address
        sub     ecx, 32                 ; reduce length of checksum
        jz      cks60                   ; if z, end of 8-byte blocks
cks40:  test    ecx, 040h               ; test if initial 64-byte block
        jz      cks50                   ; if z, no initial 64-byte block
        add     eax, [rdx]              ; compute 64-byte checksum
        adc     eax, 4[rdx]             ;
        adc     eax, 8[rdx]             ;
        adc     eax, 12[rdx]            ;
        adc     eax, 16[rdx]            ;
        adc     eax, 20[rdx]            ;
        adc     eax, 24[rdx]            ;
        adc     eax, 28[rdx]            ;
        adc     eax, 32[rdx]            ;
        adc     eax, 36[rdx]            ;
        adc     eax, 40[rdx]            ;
        adc     eax, 44[rdx]            ;
        adc     eax, 48[rdx]            ;
        adc     eax, 52[rdx]            ;
        adc     eax, 56[rdx]            ;
        adc     eax, 60[rdx]            ;
        adc     eax, 0                  ; add carry
        add     rdx, 64                 ; update source address
        sub     ecx, 64                 ; reduce length of checksum
        jz      cks60                   ; if z, end of 8-byte blocks
cks50:  add     eax, [rdx]              ; compute 128-byte checksum
        adc     eax, 4[rdx]             ;
        adc     eax, 8[rdx]             ;
        adc     eax, 12[rdx]            ;
        adc     eax, 16[rdx]            ;
        adc     eax, 20[rdx]            ;
        adc     eax, 24[rdx]            ;
        adc     eax, 28[rdx]            ;
        adc     eax, 32[rdx]            ;
        adc     eax, 36[rdx]            ;
        adc     eax, 40[rdx]            ;
        adc     eax, 44[rdx]            ;
        adc     eax, 48[rdx]            ;
        adc     eax, 52[rdx]            ;
        adc     eax, 56[rdx]            ;
        adc     eax, 60[rdx]            ;
        adc     eax, 64[rdx]            ;
        adc     eax, 68[rdx]            ;
        adc     eax, 72[rdx]            ;
        adc     eax, 76[rdx]            ;
        adc     eax, 80[rdx]            ;
        adc     eax, 84[rdx]            ;
        adc     eax, 88[rdx]            ;
        adc     eax, 92[rdx]            ;
        adc     eax, 96[rdx]            ;
        adc     eax, 100[rdx]           ;
        adc     eax, 104[rdx]           ;
        adc     eax, 108[rdx]           ;
        adc     eax, 112[rdx]           ;
        adc     eax, 116[rdx]           ;
        adc     eax, 120[rdx]           ;
        adc     eax, 124[rdx]           ;
        adc     eax, 0                  ; add carry
        add     rdx, 128                ; update source address
        sub     ecx, 128                ; reduce length of checksum
        jnz     short cks50             ; if nz, not end of 8-byte blocks

;
; Compute checksum on 2-byte blocks.
;

cks60:  test    r8d, r8d                ; check if any 2-byte blocks
        jz      short cks80             ; if z, no 2-byte blocks
        xor     ecx, ecx                ; clear entire register
cks70:  mov     cx, [rdx]               ; load 2-byte block
        add     eax, ecx                ; compute 2-byte checksum
        adc     eax, 0                  ;
        add     rdx, 2                  ; update source address
        sub     r8d, 2                  ; reduce length of checksum
        jnz     short cks70             ; if nz, more 2-bytes blocks

;
; Fold 32-but checksum into 16-bits
;

cks80:  mov     edx, eax                ; copy checksum value
        shr     edx, 16                 ; isolate high order bits
        and     eax, 0ffffh             ; isolate low order bits
        add     eax, edx                ; sum high and low order bits
        mov     edx, eax                ; isolate possible carry
        shr     edx, 16                 ;
        add     eax, edx                ; add carry
        and     eax, 0ffffh             ; clear possible carry bit
        ret                             ;

        LEAF_END ChkSum, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\i386\chksum.asm ===
title  "Compute Checksum"

;/*++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    chksum.asm
;
; Abstract:
;
;    This module implements a fucntion to compute the checksum of a buffer.
;
; Author:
;
;    David N. Cutler (davec) 27-Jan-1992
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--*/

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        .list

        .code

;++
;
; USHORT
; ChkSum(
;   IN ULONG cksum,
;   IN PUSHORT buf,
;   IN ULONG len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;
; Arguments:
;
;    cksum - Suppiles the initial checksum value.
;
;    buf - Supplies a pointer to the buffer that is checksumed.
;
;    len - Supplies the of the buffer in words.
;
; Return Value:
;
;    The computed checksum is returned as the function value.
;
;--

cksum   equ     8                       ; stack offset to initial checksum
buf     equ     12                      ; stack offset to source address
len     equ     16                      ; stack offset to length in words

cPublicProc ChkSum,3

	push	esi                     ; save nonvolatile register
        mov     ecx,[esp + len]         ; get length in words
        mov     esi,[esp + buf]         ; get source address
        mov     eax,[esp + cksum]       ; get initial checksum
        shl     ecx,1                   ; convert to length in bytes
        jz      cks80                   ; if z set, no words to checksum

;
; Compute checksum in cascading order of block size until 128 byte blocks
; are all that is left, then loop on 128-bute blocks.
;

        test    esi,02h                 ; check if source dword aligned
        jz      short cks10             ; if z set, source is dword aligned
        sub     edx,edx                 ; get initial word for alignment
        mov     dx,[esi + 0]            ;
        add     eax,edx                 ; update partial checkcum
        adc     eax,0                   ; add carry
        add     esi,2                   ; update source address
        sub     ecx,2                   ; reduce length in bytes
cks10:  mov     edx,ecx                 ; isolate residual bytes
        and     edx,07h                 ;
        sub     ecx,edx                 ; subtract residual bytes
        jz      cks60                   ; if z set, no 8-byte blocks
        test    ecx,08h                 ; test if initial 8-byte block
        jz      short cks20             ; if z set, no initial 8-byte block
        add     eax,[esi + 0]           ; compute 8-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,0                   ; add carry
        add     esi,8                   ; update source address
        sub     ecx,8                   ; reduce length of checksum
        jz      cks60                   ; if z set, end of 8-byte blocks
cks20:  test    ecx,010h                ; test if initial 16-byte block
        jz      short cks30             ; if z set, no initial 16-byte block
        add     eax,[esi + 0]           ; compute 16-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,[esi + 8]           ;
        adc     eax,[esi + 12]          ;
        adc     eax,0                   ; add carry
        add     esi,16                  ; update source address
        sub     ecx,16                  ; reduce length of checksum
        jz      cks60                   ; if z set, end of 8-byte blocks
cks30:  test    ecx,020h                ; test if initial 32-byte block
        jz      short cks40             ; if z set, no initial 32-byte block
        add     eax,[esi + 0]           ; compute 32-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,[esi + 8]           ;
        adc     eax,[esi + 12]          ;
        adc     eax,[esi + 16]          ;
        adc     eax,[esi + 20]          ;
        adc     eax,[esi + 24]          ;
        adc     eax,[esi + 28]          ;
        adc     eax,0                   ; add carry
        add     esi,32                  ; update source address
        sub     ecx,32                  ; reduce length of checksum
        jz      cks60                   ; if z set, end of 8-byte blocks
cks40:  test    ecx,040h                ; test if initial 64-byte block
        jz      cks50                   ; if z set, no initial 64-byte block
        add     eax,[esi + 0]           ; compute 64-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,[esi + 8]           ;
        adc     eax,[esi + 12]          ;
        adc     eax,[esi + 16]          ;
        adc     eax,[esi + 20]          ;
        adc     eax,[esi + 24]          ;
        adc     eax,[esi + 28]          ;
        adc     eax,[esi + 32]          ;
        adc     eax,[esi + 36]          ;
        adc     eax,[esi + 40]          ;
        adc     eax,[esi + 44]          ;
        adc     eax,[esi + 48]          ;
        adc     eax,[esi + 52]          ;
        adc     eax,[esi + 56]          ;
        adc     eax,[esi + 60]          ;
        adc     eax,0                   ; add carry
        add     esi,64                  ; update source address
        sub     ecx,64                  ; reduce length of checksum
        jz      short cks60             ; if z set, end of 8-byte blocks
cks50:  add     eax,[esi + 0]           ; compute 64-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,[esi + 8]           ;
        adc     eax,[esi + 12]          ;
        adc     eax,[esi + 16]          ;
        adc     eax,[esi + 20]          ;
        adc     eax,[esi + 24]          ;
        adc     eax,[esi + 28]          ;
        adc     eax,[esi + 32]          ;
        adc     eax,[esi + 36]          ;
        adc     eax,[esi + 40]          ;
        adc     eax,[esi + 44]          ;
        adc     eax,[esi + 48]          ;
        adc     eax,[esi + 52]          ;
        adc     eax,[esi + 56]          ;
        adc     eax,[esi + 60]          ;
        adc     eax,[esi + 64]          ;
        adc     eax,[esi + 68]          ;
        adc     eax,[esi + 72]          ;
        adc     eax,[esi + 76]          ;
        adc     eax,[esi + 80]          ;
        adc     eax,[esi + 84]          ;
        adc     eax,[esi + 88]          ;
        adc     eax,[esi + 92]          ;
        adc     eax,[esi + 96]          ;
        adc     eax,[esi + 100]         ;
        adc     eax,[esi + 104]         ;
        adc     eax,[esi + 108]         ;
        adc     eax,[esi + 112]         ;
        adc     eax,[esi + 116]         ;
        adc     eax,[esi + 120]         ;
        adc     eax,[esi + 124]         ;
        adc     eax,0                   ; add carry
        add     esi,128                 ; update source address
        sub     ecx,128                 ; reduce length of checksum
        jnz     short cks50             ; if z clear, not end of 8-byte blocks

;
; Compute checksum on 2-byte blocks.
;

cks60:  test    edx,edx                 ; check if any 2-byte blocks
        jz      short cks80             ; if z set, no 2-byte blocks
cks70:  sub     ecx,ecx                 ; load 2-byte block
        mov     cx,[esi + 0]            ;
        add     eax,ecx                 ; compue 2-byte checksum
        adc     eax,0                   ;
        add     esi,2                   ; update source address
        sub     edx,2                   ; reduce length of checksum
        jnz     short cks70             ; if z clear, more 2-bytes blocks

;
; Fold 32-but checksum into 16-bits
;

cks80:  mov     edx,eax                 ; copy checksum value
        shr     edx,16                  ; isolate high order bits
        and     eax,0ffffh              ; isolate low order bits
        add     eax,edx                 ; sum high and low order bits
        mov     edx,eax                 ; isolate possible carry
        shr     edx,16                  ;
        add     eax,edx                 ; add carry
        and     eax,0ffffh              ; clear possible carry bit
	pop     esi                     ; restore nonvolatile register
        stdRET  ChkSum

stdENDP ChkSum

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\ia64\chksum.s ===
#include "ksia64.h"

        LEAF_ENTRY (ChkSum)

        alloc    t22 = ar.pfs, 3, 0, 0, 0
        mov      t10 = 0xffff
        zxt4     a2 = a2
        ;;

        cmp4.eq  pt0 = zero, a2
        zxt4     a0 = a0
(pt0)   br.cond.spnt cs20

cs10:
        ld2      t0 = [a1], 2
        add      a2 = -1, a2
        ;;
        add      a0 = t0, a0
        ;;

        cmp4.ne  pt1 = zero, a2
        extr.u   t1 = a0, 16, 16
        and      t2 = a0, t10
        ;;

        add      a0 = t1, t2
        nop.f    0
(pt1)   br.cond.sptk cs10
        ;;
        
cs20:
  
        nop.m    0
        extr.u   t1 = a0, 16, 16
        ;;
        add      a0 = t1, a0
        ;;

        nop.m    0
        and      v0 = a0, t10
        br.ret.sptk brp

        LEAF_EXIT (ChkSum)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\dbghelp\makefile.inc ===
$(O)\dbghelp.res: ..\dbghelp.rc

..\debug.c ..\undname.c: $(SDK_INC_PATH)\ntverp.h

$(O)\pdbghelp.def : ..\imagehlp.src
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc..\imagehlp.src > $@
$(CPPXX: =
)
-DPRIVATE=
<<NOKEEP

$(O)\pdbghelp.lib : $(O)\pdbghelp.def $(IMPLIB_DEPEND)
    -lib -out:$@ @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\pdbghelp.def
$(LIBRARY_OBJS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\amd64lib\fakeit.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tchar.h>


typedef LONG PDB;
typedef LONG EC;
typedef ULONG AGE;
typedef ULONG SIG;
typedef ULONG PCSIG70;
typedef LONG DBI;
typedef LONG Mod;
typedef LONG ITSM;
typedef LONG TPI;

#define LNGNM_CONST
#define cbErrMax 1

BOOL __cdecl PDBOpenValidate (
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb
    );

BOOL __cdecl PDBCopyTo (
    PDB* ppdb,
    const char* szTargetPdb,
    DWORD dwCopyFilter,
    DWORD dwReserved
    );

BOOL __cdecl PDBOpen(
    LNGNM_CONST char *,
    LNGNM_CONST char *,
    SIG,
    EC *,
    char [cbErrMax],
    PDB **
    );

BOOL __cdecl PDBClose (
    PDB* ppdb
    );

BOOL __cdecl DBIQueryNextMod (
    DBI* pdbi, Mod* pmod, Mod** ppmodNext
    );

BOOL __cdecl MODClose (
    Mod* pmod
    );

BOOL __cdecl MODQueryLines (
    Mod* pmod, BYTE* pbLines, long* pcb
    );

BOOL __cdecl MODQuerySymbols (
    Mod* pmod, BYTE* pbSym, long* pcb
    );

BOOL __cdecl DBIQueryTypeServer (
    DBI* pdbi, ITSM itsm, OUT TPI** pptpi
    );

BOOL __cdecl PDBOpenTpi (
    PDB* ppdb, const char* szMode, OUT TPI** pptpi
    );

BOOL __cdecl TypesQueryTiMinEx (
    TPI* ptpi
    );

BOOL __cdecl TypesQueryTiMacEx (
    TPI* ptpi
    );

BOOL __cdecl TypesClose (
    TPI* ptpi
    );

BOOL __cdecl PDBOpenDbi (
    PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi
    );

BOOL __cdecl DBIClose (
    DBI* pdbi
    );

// Functions

BOOL __cdecl PDBCopyTo (
    PDB* ppdb,
    const char* szTargetPdb,
    DWORD dwCopyFilter,
    DWORD dwReserved
    )
{
    return (FALSE);
}

BOOL __cdecl PDBOpen (
    LNGNM_CONST char * a,
    LNGNM_CONST char * b,
    SIG c,
    EC * d,
    char e[cbErrMax],
    PDB ** f
    )
{
    return (FALSE);
}

BOOL  __cdecl PDBClose (
    PDB* ppdb
    )
{
    return (FALSE);
}


BOOL __cdecl IDATE4 (
    const wchar_t *wszPDB,
    const char *szMode,
    PCSIG70 pcsig70,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb
    )
{
    return (FALSE);
}

BOOL __cdecl DBIQueryNextMod (
    DBI* pdbi, Mod* pmod, Mod** ppmodNext
    )
{
    return (FALSE);
}

BOOL __cdecl ModClose (
    Mod* pmod
    )
{
    return (FALSE);
}

BOOL __cdecl ModQueryLines (
    Mod* pmod, BYTE* pbLines, long* pcb
    )
{
    return (FALSE);
}

BOOL __cdecl ModQuerySymbols (
    Mod* pmod, BYTE* pbSym, long* pcb
    )
{
    return (FALSE);
}

BOOL __cdecl DBIQueryTypeServer (
    DBI* pdbi, ITSM itsm, OUT TPI** pptpi
    )
{
    return (FALSE);
}

BOOL __cdecl PDBOpenTpi (
    PDB* ppdb, const char* szMode, OUT TPI** pptpi
    )
{
    return (FALSE);
}

BOOL __cdecl TypesQueryTiMinEx (
    TPI* ptpi
    )
{
    return (FALSE);
}

BOOL __cdecl TypesQueryTiMacEx (
    TPI* ptpi
    )
{
    return (FALSE);
}

BOOL __cdecl TypesClose (
    TPI* ptpi
    )
{
    return (FALSE);
}

BOOL __cdecl PDBOpenDBI (
    PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi
    )
{
    return (FALSE);
}

BOOL __cdecl DBIClose (
    DBI* pdbi
    )
{
    return (FALSE);
}

BOOL __cdecl PDBOpenValidate(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb)
{
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\imagehlp\makefile.inc ===
$(O)\imagehlp.res: ..\imagehlp.rc

..\debug.c ..\undname.c: $(SDK_INC_PATH)\ntverp.h

$(O)\pimagehlp.def : ..\imagehlp.src
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc..\imagehlp.src > $@
$(CPPXX: =
)
-DPRIVATE=
<<NOKEEP

$(O)\pimagehlp.lib : $(O)\pimagehlp.def $(IMPLIB_DEPEND)
    -lib -out:$@ @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\pimagehlp.def
$(LIBRARY_OBJS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\tools\makefile.inc ===
$(O)\bind.res: ..\bind.rc

$(O)\binplace.res: ..\binplace.rc

$(O)\checkfix.res: ..\checkfix.rc

$(O)\dbgdump.res: ..\dbgdump.rc

$(O)\dumpsym.res: ..\dumpsym.rc

$(O)\editsym.res: ..\binplace.rc

$(O)\imagecfg.res: ..\imagecfg.rc

$(O)\imagechk.res: ..\imagechk.rc

$(O)\impchk.res: ..\impchk.rc

$(O)\rebase.res: ..\rebase.rc

$(O)\smashlck.res: ..\smashlck.rc

$(O)\splitsym.res: ..\splitsym.rc

$(O)\stripcv.res: ..\stripcv.rc

$(O)\symchk.res: ..\symchk.rc

$(O)\undname.res: ..\undname.rc

$(O)\verfix.res: ..\verfix.rc

$(O)\editsym.res: ..\editsym.rc

$(O)\upddbg.res: ..\upddbg.rc

$(O)\certify.res: ..\certify.rc

$(O)\imhlptst.res: ..\imhlptst.rc

$(O)\dbh.res: ..\dbh.rc

$(O)\tracepdb.res: ..\tracepdb.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\removesym\removesym.c ===
#include <private.h>

WCHAR **SymbolNames;

typedef BOOL ( __cdecl *PPDBOPEN2W )(
    const wchar_t *,
    LNGNM_CONST char *,
    EC *,
    wchar_t *,
    size_t,
    PDB **
    );

typedef BOOL ( __cdecl *PPDBCLOSE ) (
    PDB* ppdb
    );

typedef BOOL (__cdecl *PPDBCOPYTOW2) (
    PDB *ppdb, 
    const wchar_t *szTargetPdb, 
    DWORD dwCopyFilter, 
    PfnPDBCopyQueryCallback pfnCallBack, 
    void * pvClientContext
    );

PPDBOPEN2W pPDBOpen2W;
PPDBCLOSE  pPDBClose;
PPDBCOPYTOW2 pPDBCopyToW2;
wchar_t NewPdbName[_MAX_FNAME];

CHAR SymbolName[2048];
WCHAR SymbolNameW[2048];
PWCHAR *SymbolsToRemove;
ULONG SymbolCount;

int
__cdecl
MyWcsCmp(const void*Ptr1, const void *Ptr2)
{
    wchar_t*String1 = *(wchar_t**)Ptr1;
    wchar_t*String2 = *(wchar_t**)Ptr2;

//    printf("String1: %p - %ws\nString2: %p - %ws\n%d\n", String1, String1, String2, String2, wcscmp(String1, String2));
    return (wcscmp(String1, String2));
}

__cdecl
MyWcsCmp2(const void*Ptr1, const void *Ptr2)
{
    wchar_t*String1 = (wchar_t*)Ptr1;
    wchar_t*String2 = *(wchar_t**)Ptr2;

//    printf("String1: %p - %ws\nString2: %p - %ws\n%d\n", String1, String1, String2, String2, wcscmp(String1, String2));
    return (wcscmp(String1, String2));
}


BOOL
LoadNamesFromSymbolFile(
    WCHAR *SymbolFileName
    )
{
    FILE *SymbolFile;
    ULONG i;

    SymbolFile = _wfopen(SymbolFileName, L"rt");
    if (!SymbolFile)
        return FALSE;

    SymbolCount = 0;
    while (fgets(SymbolName,sizeof(SymbolName),SymbolFile)) {
        SymbolCount++;
    }

    fseek(SymbolFile, 0, SEEK_SET);

    SymbolsToRemove = (PWCHAR *) malloc(SymbolCount * sizeof(PWCHAR));

    if (!SymbolsToRemove) {
        fclose(SymbolFile);
        return FALSE;
    }

    SymbolCount = 0;

    while (fgets(SymbolName,sizeof(SymbolName),SymbolFile)) {
        // Remove trailing spaces
        if (strlen(SymbolName)) {
            PCHAR SymPtr = SymbolName + strlen(SymbolName) - 1;
            while ((*SymPtr == ' ') || (*SymPtr == '\r') || (*SymPtr == '\n')) {
                *SymPtr = '\0';
                SymPtr--;
            }
        }

        if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, SymbolName, -1, SymbolNameW, sizeof(SymbolName)) == 0) {
            fclose(SymbolFile);
            return FALSE;
        }
        
        SymbolsToRemove[SymbolCount] = malloc((wcslen(SymbolNameW) + 1) * sizeof(WCHAR));
        if (!SymbolsToRemove[SymbolCount]) {
            fclose(SymbolFile);
            return FALSE;
        }

        wcscpy(SymbolsToRemove[SymbolCount], SymbolNameW);
        SymbolCount++;
    }

    fclose(SymbolFile);

    qsort(&SymbolsToRemove[0], SymbolCount, sizeof(PWCHAR), MyWcsCmp);

    return TRUE;
}


BOOL PDBCALL PdbCopyFilterPublics (
    void *          pvClientContext,
    DWORD           dwFilterFlags,
    unsigned int    offPublic,
    unsigned int    sectPublic,
    unsigned int    grfPublic,
    const wchar_t * szPublic,
    wchar_t **      pszNewPublic
    ) {

    static size_t   cPubs = 0;
    static wchar_t  wszNewName[2048];

    if (SymbolCount > 1) {
        if (bsearch(szPublic, &SymbolsToRemove[0], SymbolCount, sizeof(PWCHAR), MyWcsCmp2)) {
            return FALSE;
        }
    } else {
        if (!wcscmp(szPublic, *SymbolsToRemove)) {
            return FALSE;
        }
    }

    return TRUE;

//    if ((cPubs++ % 16) == 0) {
//        if ((cPubs % 32) == 1) {
//            wcscpy(wszNewName, szPublic);
//            wcscat(wszNewName, L"_BobsYerUncle");
//            *pszNewPublic = wszNewName;
//        }
//        return TRUE;
//    }
//    else {
//        return FALSE;
//    }
}

PDBCOPYCALLBACK PDBCALL PdbCopyQueryCallback(void * pv, PCC pccQuery) {
    switch (pccQuery) {
    case pccFilterPublics:
        return (PDBCOPYCALLBACK) PdbCopyFilterPublics;
        break;
    default:
        return NULL;
    }
}

void Usage(void)
{
    _putws(L"Usage: removesym -d:<pdbdll path> -p:<pdbname> {-s:<symbol to remove> | -f:<file with symbols to remove>}");
}

int __cdecl wmain(int argc, wchar_t *argv[])
{
    WCHAR *szPdbName = NULL;
    WCHAR *szNewPdbName = NULL;
    WCHAR *pSymbolName = NULL;
    WCHAR *pSymbolFileName = NULL;
    HINSTANCE hmodMsPdb;
    BOOL rc;
    LONG ErrorCode;
    WCHAR ErrorString[1024];
    PDB * pSrcPdb;
    int i;
    WCHAR PdbDllName[_MAX_PATH] = {0};
    WCHAR *pPdbDllPath = NULL;

    // Grab the arguments
     
    if (argc < 4) {
        Usage();
        return 1;
    }

    i = 1;

    while (i < argc)
    {
        if (argv[i][0] == L'-' || argv[i][0] == L'/') {
            if (argv[i][1] == L'p' && argv[i][2] == ':') {
                // Pdb Name
                szPdbName = &argv[i][3];
            } else 
            if (argv[i][1] == L's' && argv[i][2] == ':') {
                // Single Symbol name
                pSymbolName = &argv[i][3];
            } else 
            if (argv[i][1] == L'f' && argv[i][2] == ':') {
                // File with symbol names
                pSymbolFileName = &argv[i][3];
            } else
            if (argv[i][1] == L'd' && argv[i][2] == ':') {
                // Single Symbol name
                pPdbDllPath = &argv[i][3];
            } else { 
                Usage();
                return 1;
            }
        }
        i++;
    }

    if (!szPdbName) {
        _putws(L"Pdb name missing");
        Usage();
        return 1;
    }

    if (!pSymbolName && !pSymbolFileName) {
        _putws(L"Symbol name or file missing");
        Usage();
        return 1;
    }

    if (pSymbolName && pSymbolFileName) {
        _putws(L"Symbol name and symbol file specified - only one allowed");
        Usage();
        return 1;
    }

    if (!pPdbDllPath) {
        _putws(L"Pdb DllPath not specified");
        Usage();
        return 1;
    }

    // If there's a symfile, load it

    if (pSymbolFileName) {
        rc = LoadNamesFromSymbolFile(pSymbolFileName);
        if (!rc) {
            _putws(L"Unable do load names from symbol file");
            exit(1);
        }
    } else {
        SymbolsToRemove = &pSymbolName;
        SymbolCount = 1;
    }

    // Load mspdb60.dll and the necessar api's

    wcscpy(PdbDllName, pPdbDllPath);
    wcscat(PdbDllName, L"\\mspdb60.dll");

    hmodMsPdb = LoadLibraryW(PdbDllName);
    
    if (!hmodMsPdb) {
        _putws(L"Unable to loadlib mspdb60.dll");
        exit(1);
    }

    pPDBOpen2W = (PPDBOPEN2W) GetProcAddress(hmodMsPdb, "PDBOpen2W");
    pPDBClose = (PPDBCLOSE) GetProcAddress(hmodMsPdb, "PDBClose");
    pPDBCopyToW2 = (PPDBCOPYTOW2) GetProcAddress(hmodMsPdb, "PDBCopyToW2");
    if (!pPDBOpen2W || !pPDBClose || !pPDBCopyToW2) {
        _putws(L"Unable to find the necessary api's in the pdb dll");
        FreeLibrary(hmodMsPdb);
        exit(1);
    }

    __try {
        rc = pPDBOpen2W(szPdbName, "r", &ErrorCode, ErrorString, sizeof(ErrorString) / sizeof(ErrorString[0]), &pSrcPdb);
        if (!rc) {
            _putws(L"Unable to open pdb for changes");
            leave;
        }

        szNewPdbName = _wtmpnam(NewPdbName);

        rc = pPDBCopyToW2(pSrcPdb, szNewPdbName, 1, PdbCopyQueryCallback, NULL);

        pPDBClose(pSrcPdb);

        if (!rc) {
            _putws(L"CopyTo operation failed");
            __leave;
        }

        rc = CopyFile(szNewPdbName, szPdbName, FALSE);
        if (!rc) {
            _putws(L"Unable to overwrite old pdb with new pdb");
        }

        DeleteFile(szNewPdbName);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          _putws(L"Exception occured in pdb api's");
          rc = FALSE;
    }

    FreeLibrary(hmodMsPdb);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\vc\cvexefmt.h ===
/***    cvexefmt.h - format of CodeView information in exe
 *
 *      Structures, constants, etc. for reading CodeView information
 *      from the executable.
 *
 */


/***    The master copy of this file resides in the LANGAPI project.
 *      All Microsoft projects are required to use the master copy without
 *      modification.  Modification of the master version or a copy
 *      without consultation with all parties concerned is extremely
 *      risky.
 *
 */


#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif



//  The following structures and constants describe the format of the
//  CodeView Debug OMF for that will be accepted by CodeView 4.0 and
//  later.  These are executables with signatures of NB05, NB06 and NB08.
//  There is some confusion about the signatures NB03 and NB04 so none
//  of the utilites will accept executables with these signatures.  NB07 is
//  the signature for QCWIN 1.0 packed executables.

//  All of the structures described below must start on a long word boundary
//  to maintain natural alignment.  Pad space can be inserted during the
//  write operation and the addresses adjusted without affecting the contents
//  of the structures.

#ifndef _CV_INFO_INCLUDED
#include "cvinfo.h"
#endif

#ifndef FAR
#if _M_IX86 >= 300
#define FAR
#else
#define FAR far
#endif
#endif


//  Type of subsection entry.

#define sstModule           0x120
#define sstTypes            0x121
#define sstPublic           0x122
#define sstPublicSym        0x123   // publics as symbol (waiting for link)
#define sstSymbols          0x124
#define sstAlignSym         0x125
#define sstSrcLnSeg         0x126   // because link doesn't emit SrcModule
#define sstSrcModule        0x127
#define sstLibraries        0x128
#define sstGlobalSym        0x129
#define sstGlobalPub        0x12a
#define sstGlobalTypes      0x12b
#define sstMPC              0x12c
#define sstSegMap           0x12d
#define sstSegName          0x12e
#define sstPreComp          0x12f   // precompiled types
#define sstPreCompMap       0x130   // map precompiled types in global types
#define sstOffsetMap16      0x131
#define sstOffsetMap32      0x132
#define sstFileIndex        0x133   // Index of file names
#define sstStaticSym        0x134

typedef enum OMFHash {
    OMFHASH_NONE,           // no hashing
    OMFHASH_SUMUC16,        // upper case sum of chars in 16 bit table
    OMFHASH_SUMUC32,        // upper case sum of chars in 32 bit table
    OMFHASH_ADDR16,         // sorted by increasing address in 16 bit table
    OMFHASH_ADDR32          // sorted by increasing address in 32 bit table
} OMFHASH;

//  CodeView Debug OMF signature.  The signature at the end of the file is
//  a negative offset from the end of the file to another signature.  At
//  the negative offset (base address) is another signature whose filepos
//  field points to the first OMFDirHeader in a chain of directories.
//  The NB05 signature is used by the link utility to indicated a completely
//  unpacked file.  The NB06 signature is used by ilink to indicate that the
//  executable has had CodeView information from an incremental link appended
//  to the executable.  The NB08 signature is used by cvpack to indicate that
//  the CodeView Debug OMF has been packed.  CodeView will only process
//  executables with the NB08 signature.


typedef struct OMFSignature {
    char            Signature[4];   // "NBxx"
    long            filepos;        // offset in file
} OMFSignature;



//  directory information structure
//  This structure contains the information describing the directory.
//  It is pointed to by the signature at the base address or the directory
//  link field of a preceeding directory.  The directory entries immediately
//  follow this structure.


typedef struct OMFDirHeader {
    unsigned short  cbDirHeader;    // length of this structure
    unsigned short  cbDirEntry;     // number of bytes in each directory entry
    unsigned long   cDir;           // number of directorie entries
    long            lfoNextDir;     // offset from base of next directory
    unsigned long   flags;          // status flags
} OMFDirHeader;




//  directory structure
//  The data in this structure is used to reference the data for each
//  subsection of the CodeView Debug OMF information.  Tables that are
//  not associated with a specific module will have a module index of
//  oxffff.  These tables are the global types table, the global symbol
//  table, the global public table and the library table.


typedef struct OMFDirEntry {
    unsigned short  SubSection;     // subsection type (sst...)
    unsigned short  iMod;           // module index
    long            lfo;            // large file offset of subsection
    unsigned long   cb;             // number of bytes in subsection
} OMFDirEntry;



//  information decribing each segment in a module

typedef struct OMFSegDesc {
    unsigned short  Seg;            // segment index
    unsigned short  pad;            // pad to maintain alignment
    unsigned long   Off;            // offset of code in segment
    unsigned long   cbSeg;          // number of bytes in segment
} OMFSegDesc;




//  per module information
//  There is one of these subsection entries for each module
//  in the executable.  The entry is generated by link/ilink.
//  This table will probably require padding because of the
//  variable length module name.

typedef struct OMFModule {
    unsigned short  ovlNumber;      // overlay number
    unsigned short  iLib;           // library that the module was linked from
    unsigned short  cSeg;           // count of number of segments in module
    char            Style[2];       // debugging style "CV"
    OMFSegDesc      SegInfo[1];     // describes segments in module
    char            Name[];         // length prefixed module name padded to
                                    // long word boundary
} OMFModule;



//  Symbol hash table format
//  This structure immediately preceeds the global publics table
//  and global symbol tables.

typedef struct  OMFSymHash {
    unsigned short  symhash;        // symbol hash function index
    unsigned short  addrhash;       // address hash function index
    unsigned long   cbSymbol;       // length of symbol information
    unsigned long   cbHSym;         // length of symbol hash data
    unsigned long   cbHAddr;        // length of address hashdata
} OMFSymHash;



//  Global types subsection format
//  This structure immediately preceeds the global types table.
//  The offsets in the typeOffset array are relative to the address
//  of ctypes.  Each type entry following the typeOffset array must
//  begin on a long word boundary.

typedef struct OMFTypeFlags {
    unsigned long   sig     :8;
    unsigned long   unused  :24;
} OMFTypeFlags;


typedef struct OMFGlobalTypes {
    OMFTypeFlags    flags;
    unsigned long   cTypes;         // number of types
    unsigned long   typeOffset[];   // array of offsets to types
} OMFGlobalTypes;




//  Precompiled types mapping table
//  This table should be ignored by all consumers except the incremental
//  packer.


typedef struct OMFPreCompMap {
    CV_typ_t        FirstType;      // first precompiled type index
    CV_typ_t        cTypes;         // number of precompiled types
    unsigned long   signature;      // precompiled types signature
    CV_typ_t        map[];          // mapping of precompiled types
} OMFPreCompMap;



//  Source line to address mapping table.
//  This table is generated by the link/ilink utility from line number
//  information contained in the object file OMF data.  This table contains
//  only the code contribution for one segment from one source file.


typedef struct OMFSourceLine {
    unsigned short  Seg;            // linker segment index
    unsigned short  cLnOff;         // count of line/offset pairs
    unsigned long   offset[1];      // array of offsets in segment
    unsigned short  lineNbr[1];     // array of line lumber in source
} OMFSourceLine;

typedef OMFSourceLine * LPSL;


//  Source file description
//  This table is generated by the linker


typedef struct OMFSourceFile {
    unsigned short  cSeg;           // number of segments from source file
    unsigned short  reserved;       // reserved
    unsigned long   baseSrcLn[1];   // base of OMFSourceLine tables
                                    // this array is followed by array
                                    // of segment start/end pairs followed by
                                    // an array of linker indices
                                    // for each segment in the file
    unsigned short  cFName;         // length of source file name
    char            Name;           // name of file padded to long boundary
} OMFSourceFile;

typedef OMFSourceFile * LPSF;


//  Source line to address mapping header structure
//  This structure describes the number and location of the
//  OMFAddrLine tables for a module.  The offSrcLine entries are
//  relative to the beginning of this structure.


typedef struct OMFSourceModule {
    unsigned short  cFile;          // number of OMFSourceTables
    unsigned short  cSeg;           // number of segments in module
    unsigned long   baseSrcFile[1]; // base of OMFSourceFile table
                                    // this array is followed by array
                                    // of segment start/end pairs followed
                                    // by an array of linker indices
                                    // for each segment in the module
} OMFSourceModule;

typedef OMFSourceModule * LPSM;

//  sstLibraries

typedef struct OMFLibrary {
    unsigned char   cbLibs;     // count of library names
    char            Libs[1];    // array of length prefixed lib names (first entry zero length)
} OMFLibrary;


// sstFileIndex - An index of all of the files contributing to an
//  executable.

typedef struct OMFFileIndex {
    unsigned short  cmodules;       // Number of modules
    unsigned short  cfilerefs;      // Number of file references
    unsigned short  modulelist[1];  // Index to beginning of list of files
                                    // for module i. (0 for module w/o files)
    unsigned short  cfiles[1];      // Number of file names associated
                                    // with module i.
    unsigned long   ulNames[1];     // Offsets from the beginning of this
                                    // table to the file names
    char            Names[];        // The length prefixed names of files
} OMFFileIndex;


//  Offset mapping table
//  This table provides a mapping from logical to physical offsets.
//  This mapping is applied between the logical to physical mapping
//  described by the seg map table.

typedef struct OMFOffsetMap16 {
    unsigned long   csegment;       // Count of physical segments

    // The next six items are repeated for each segment

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned short  rgoffLog[1];    // Array of logical offsets
    short           rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned short  rgoffPhys[1];   // Array of physical offsets
    short           rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap16;

typedef struct OMFOffsetMap32 {
    unsigned long   csection;       // Count of physical sections

    // The next six items are repeated for each section

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned long   rgoffLog[1];    // Array of logical offsets
    long            rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned long   rgoffPhys[1];   // Array of physical offsets
    long            rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap32;

//  Pcode support.  This subsection contains debug information generated
//  by the MPC utility used to process Pcode executables.  Currently
//  it contains a mapping table from segment index (zero based) to
//  frame paragraph.  MPC converts segmented exe's to non-segmented
//  exe's for DOS support.  To avoid backpatching all CV info, this
//  table is provided for the mapping.  Additional info may be provided
//  in the future for profiler support.

typedef struct OMFMpcDebugInfo {
    unsigned short  cSeg;       // number of segments in module
    unsigned short  mpSegFrame[1];  // map seg (zero based) to frame
} OMFMpcDebugInfo;

//  The following structures and constants describe the format of the
//  CodeView Debug OMF for linkers that emit executables with the NB02
//  signature.  Current utilities with the exception of cvpack and cvdump
//  will not accept or emit executables with the NB02 signature.  Cvdump
//  will dump an unpacked executable with the NB02 signature.  Cvpack will
//  read an executable with the NB02 signature but the packed executable
//  will be written with the table format, contents and signature of NB08.





//  subsection type constants

#define SSTMODULE       0x101   // Basic info. about object module
#define SSTPUBLIC       0x102   // Public symbols
#define SSTTYPES        0x103   // Type information
#define SSTSYMBOLS      0x104   // Symbol Data
#define SSTSRCLINES     0x105   // Source line information
#define SSTLIBRARIES    0x106   // Names of all library files used
#define SSTIMPORTS      0x107   // Symbols for DLL fixups
#define SSTCOMPACTED    0x108   // Compacted types section
#define SSTSRCLNSEG     0x109   // Same as source lines, contains segment


typedef struct DirEntry{
    unsigned short  SubSectionType;
    unsigned short  ModuleIndex;
    long            lfoStart;
    unsigned short  Size;
} DirEntry;


//  information decribing each segment in a module

typedef struct oldnsg {
    unsigned short  Seg;            // segment index
    unsigned short  Off;            // offset of code in segment
    unsigned short  cbSeg;          // number of bytes in segment
} oldnsg;


//   old subsection module information

typedef struct oldsmd {
    oldnsg          SegInfo;        // describes first segment in module
    unsigned short  ovlNbr;         // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;           // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];      // length prefixed name of module
    oldnsg          arnsg[];        // cSeg-1 structures exist for alloc text or comdat code
} oldsmd;

typedef struct{
    unsigned short  Seg;
    unsigned long   Off;
    unsigned long   cbSeg;
} oldnsg32;

typedef struct {
    oldnsg32        SegInfo;        // describes first segment in module
    unsigned short  ovlNbr;         // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;           // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];      // length prefixed name of module
    oldnsg32        arnsg[];        // cSeg-1 structures exist for alloc text or comdat code
} oldsmd32;


// OMFSegMap - This table contains the mapping between the logical segment indices
// used in the symbol table and the physical segments where the program is loaded

typedef struct OMFSegMapFlags {
    union {
        struct {
            unsigned short      fRead   :1;
            unsigned short      fWrite  :1;
            unsigned short      fExecute:1;
            unsigned short      f32Bit  :1;
            unsigned short      res1    :4;
            unsigned short      fSel    :1;
            unsigned short      fAbs    :1;
            unsigned short      res2    :2;
            unsigned short      fGroup  :1;  // OBSOLETE - do not use, debugger will assert
            unsigned short      res3    :3;
        };
        unsigned short fAll;
    };
} OMFSegMapFlags;

typedef struct OMFSegMapDesc {
    OMFSegMapFlags  flags;          // descriptor flags bit field.
    unsigned short  ovl;            // the logical overlay number
    unsigned short  group;          // group index into the descriptor array
    unsigned short  frame;          // logical segment index - interpreted via flags
    unsigned short  iSegName;       // segment or group name - index into sstSegName
    unsigned short  iClassName;     // class name - index into sstSegName
    unsigned long   offset;         // byte offset of the logical within the physical segment
    unsigned long   cbSeg;          // byte count of the logical segment or group
} OMFSegMapDesc;

typedef struct OMFSegMap {
    unsigned short  cSeg;           // total number of segment descriptors
    unsigned short  cSegLog;        // number of logical segment descriptors
    OMFSegMapDesc   rgDesc[0];      // array of segment descriptors
} OMFSegMap;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\vc\cvtypes.h ===
//  CVTYPES.H
//
//  This file contains a common set of base type declarations
//  between multiple CodeView projects.  If you touch this in one
//  project be sure to copy it to all other projects as well.

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef CV_PROJECT_BASE_TYPES
#define CV_PROJECT_BASE_TYPES

#if !defined(DOLPHIN)
//#include "dbapiver.h"
#endif

#include "types.h"

typedef HANDLE HDEP;
typedef HANDLE HIND;

#if 0

// Phoey.  A Handle is a handle.  Clean up this later.  BryanT - 2/23/96

//  HDEP is a machine dependent size and passes as a general handle.
//  HIND is a machine independent sized handle and is used for things
//      which are passed between machines

#ifdef STRICT
DECLARE_HANDLE(HDEP);
DECLARE_HANDLE(HIND);
#else
typedef HANDLE  HDEP;
typedef HANDLE  HIND;
#endif

#endif

typedef HDEP FAR *  LPHDEP;
typedef HIND FAR *  LPHIND;

// HMEM should be avoided (HDEP should be used instead), but for now we'll
// define it for backwards compatibility.

typedef HDEP    HMEM;
typedef HMEM FAR *  LPHMEM;

// These values are used in the SegType field of the Expression Evaluator's
// TI structure, and as the third parameter to the Symbol Handler's
// SHGetNearestHsym function.

#define EECODE      0x01
#define EEDATA      0x02
#define EEANYSEG    0xFFFF

#ifdef STRICT
DECLARE_HANDLE(HPID);
DECLARE_HANDLE(HTID);
#else
typedef HIND    HPID;
typedef HIND    HTID;
#endif

typedef HPID FAR *LPHPID;
typedef HTID FAR *LPHTID;

typedef ULONG   SEGMENT;    // 32-bit compiler doesn't like "_segment"
typedef USHORT  SEG16;
typedef ULONG   SEG32;
typedef SEGMENT FAR * LPSEGMENT;
typedef ULONG   UOFF32;
typedef UOFF32 FAR * LPUOFF32;
typedef USHORT  UOFF16;
typedef UOFF16 FAR * LPUOFF16;
typedef LONG    OFF32;
typedef OFF32 FAR * LPOFF32;
typedef SHORT   OFF16;
typedef OFF16 FAR * LPOFF16;

typedef OFF32   SOFFSET;
typedef UOFF32  UOFFSET;
typedef UOFF32  OFFSET;
typedef SOFFSET FAR * LPSOFFSET;
typedef UOFFSET FAR * LPUOFFSET;
typedef OFFSET FAR * LPOFFSET;

//  address definitions
//  the address packet is always a 16:32 address.

typedef struct {
    UOFF32      off;
    SEGMENT     seg;
} address_t;

#define SegAddrT(a)   ((a).seg)
#define OffAddrT(a)   ((a).off)

#ifdef __cplusplus
void
__inline
AddrTInit(
    address_t * paddrT,
    SEGMENT segSet,
    UOFF32 offSet
    )
{
    SegAddrT(*(paddrT)) = segSet;
    OffAddrT(*(paddrT)) = offSet;
}
#else
#define AddrTInit(paddrT,segSet,offSet)     \
        {                                   \
            SegAddrT(*(paddrT)) = segSet;   \
            OffAddrT(*(paddrT)) = offSet;   \
        }
#endif

typedef struct {
    BYTE    fFlat   :1;         // true if address is flat
    BYTE    fOff32  :1;         // true if offset is 32 bits
    BYTE    fIsLI   :1;         // true if segment is linker index
    BYTE    fReal   :1;         // x86: is segment a real mode address
    BYTE    fSql    :1;         // true if execution context is SQL SP
    BYTE    fJava   :1;                     // true if Java addr
    BYTE    unused  :2;         // unused
} memmode_t;

#define MODE_IS_FLAT(m)     ((m).fFlat)
#define MODE_IS_OFF32(m)    ((m).fOff32)
#define MODE_IS_LI(m)       ((m).fIsLI)
#define MODE_IS_REAL(m)     ((m).fReal)

#ifdef __cplusplus
void
__inline
ModeInit(
    memmode_t *pmode,
    BOOL fFlat,
    BOOL fOff32,
    BOOL fLi,
    BOOL fRealSet
    )
{
    MODE_IS_FLAT(*(pmode))    = (BYTE)fFlat;
    MODE_IS_OFF32(*(pmode))   = (BYTE)fOff32;
    MODE_IS_LI(*(pmode))      = (BYTE)fLi;
    MODE_IS_REAL(*(pmode))    = (BYTE)fRealSet;
    pmode->fSql               = FALSE;
    pmode->fJava              = FALSE;
}
#else
#define ModeInit(pmode,fFlat,fOff32,fLi,fRealSet)   \
        {                                           \
            MODE_IS_FLAT(*(pmode))    = fFlat;      \
            MODE_IS_OFF32(*(pmode))   = fOff32;     \
            MODE_IS_LI(*(pmode))      = fLi;        \
            MODE_IS_REAL(*(pmode))    = fRealSet;   \
            (pmode)->fSql             = FALSE;      \
            (pmode)->fJava            = FALSE;      \
        }
#endif

#ifdef STRICT
DECLARE_HANDLE(HEMI);
#else
typedef HIND    HEMI;           // Executable Module Index
#endif

typedef struct ADDR {
    address_t   addr;
    HEMI        emi;
    memmode_t   mode;
} ADDR;                     // An address specifier
typedef ADDR *  PADDR;
typedef ADDR *  LPADDR;

#define addrAddr(a)         ((a).addr)
#define emiAddr(a)          ((a).emi)
#define modeAddr(a)         ((a).mode)

#ifdef __cplusplus
void
__inline
AddrInit(
    LPADDR paddr,
    HEMI emiSet,
    SEGMENT segSet,
    UOFF32 offSet,
    BOOL fFlat,
    BOOL fOff32,
    BOOL fLi,
    BOOL fRealSet
    )
{
    AddrTInit( &(addrAddr(*(paddr))), segSet, offSet );
    emiAddr(*(paddr)) = emiSet;
    ModeInit( &(modeAddr(*(paddr))),fFlat,fOff32,fLi,fRealSet);
}
#else
#define AddrInit(paddr,emiSet,segSet,offSet,fFlat,fOff32,fLi,fRealSet)  \
        {                                                               \
            AddrTInit( &(addrAddr(*(paddr))), segSet, offSet );         \
            emiAddr(*(paddr)) = emiSet;                                 \
            ModeInit( &(modeAddr(*(paddr))),fFlat,fOff32,fLi,fRealSet); \
        }
#endif

#define ADDR_IS_FLAT(a)     (MODE_IS_FLAT(modeAddr(a)))
#define ADDR_IS_OFF32(a)    (MODE_IS_OFF32(modeAddr(a)))
#define ADDR_IS_LI(a)       (MODE_IS_LI(modeAddr(a)))
#define ADDR_IS_REAL(a)     (MODE_IS_REAL(modeAddr(a)))

#define ADDRSEG16(a)        {ADDR_IS_FLAT(a) = FALSE; ADDR_IS_OFF32(a) = FALSE;}
#define ADDRSEG32(a)        {ADDR_IS_FLAT(a) = FALSE; ADDR_IS_OFF32(a) = TRUE;}
#define ADDRLIN32(a)        {ADDR_IS_FLAT(a) = TRUE;  ADDR_IS_OFF32(a) = TRUE;}

#define GetAddrSeg(a)       ((a).addr.seg)
#define GetAddrOff(a)       ((a).addr.off)
#define SetAddrSeg(a,s)     ((a)->addr.seg=s)
#define SetAddrOff(a,o)     ((a)->addr.off=o)

// Because an ADDR has some filler areas (in the mode and the address_t),
// it's bad to use memcmp two ADDRs to see if they're equal.  Use this
// macro instead.  (I deliberately left out the test for fAddr32(), because
// I think it's probably not necessary when comparing.)
#ifdef __cplusplus
BOOL
__inline
FAddrsEq(
    ADDR &a1,
    ADDR &a2
    )
{
    return
    (GetAddrOff(a1) == GetAddrOff(a2)) &&
    (GetAddrSeg(a1) == GetAddrSeg(a2)) &&
    (ADDR_IS_LI(a1) == ADDR_IS_LI(a2)) &&
    (emiAddr(a1)    == emiAddr(a2));
}
#else
#define FAddrsEq(a1, a2)                        \
    (                                           \
    GetAddrOff(a1) == GetAddrOff(a2) &&         \
    GetAddrSeg(a1) == GetAddrSeg(a2) &&         \
    ADDR_IS_LI(a1) == ADDR_IS_LI(a2) &&         \
    emiAddr(a1)    == emiAddr(a2)               \
    )
#endif

#if 0 // JLS
//  address definitions
//  the address packet is always a 16:32 address.

typedef struct FRAME {
    SEG16       SS;
    address_t   BP;
    SEG16       DS;
    memmode_t   mode;
    HPID        PID;
    HTID        TID;
    address_t   SLP;        // Static link pointer
} FRAME;
typedef FRAME *PFRAME;

#define addrFrameSS(a)     ((a).SS)
#define addrFrameBP(a)     ((a).BP)
#define GetFrameBPOff(a)   ((a).BP.off)
#define GetFrameBPSeg(a)   ((a).BP.seg)
#define SetFrameBPOff(a,o) ((a).BP.off = o)
#define SetFrameBPSeg(a,s) ((a).BP.seg = s)
#define GetFrameSLPOff(a)   ((a).SLP.off)
#define GetFrameSLPSeg(a)   ((a).SLP.seg)
#define SetFrameSLPOff(a,o) ((a).SLP.off = o)
#define SetFrameSLPSeg(a,s) ((a).SLP.seg = s)
#define FRAMEMODE(a)       ((a).mode)
#define FRAMEPID(a)        ((a).PID)
#define FRAMETID(a)        ((a).TID)

#define FrameFlat(a)       MODE_IS_FLAT((a).mode)
#define FrameOff32(a)      MODE_IS_OFF32((a).mode)
#define FrameReal(a)       MODE_IS_REAL((a).mode)
#else  // JLS
DECLARE_HANDLE(HFRAME);
#endif // JLS

//  A few public types related to the linked list manager

typedef HDEP    HLLI;       // A handle to a linked list
typedef HDEP    HLLE;       // A handle to a linked list entry

typedef void (FAR PASCAL * LPFNKILLNODE)(LPVOID);
typedef int  (FAR PASCAL * LPFNFCMPNODE)(LPVOID, LPVOID, LONG );

typedef DWORD          LLF;    // Linked List Flags
#define llfNull         (LLF)0x0
#define llfAscending    (LLF)0x1
#define llfDescending   (LLF)0x2
#define fCmpLT              (-1)
#define fCmpEQ              (0)
#define fCmpGT              (1)

//  EXPCALL indicates that a function should use whatever calling
//      convention is preferable for exported functions.

#define EXPCALL         __stdcall

// copied from winnt.h:

#ifndef PAGE_NOACCESS

#define PAGE_NOACCESS          0x01
#define PAGE_READONLY          0x02
#define PAGE_READWRITE         0x04
#define PAGE_WRITECOPY         0x08
#define PAGE_EXECUTE           0x10
#define PAGE_EXECUTE_READ      0x20
#define PAGE_EXECUTE_READWRITE 0x40
#define PAGE_EXECUTE_WRITECOPY 0x80
#define PAGE_GUARD            0x100
#define PAGE_NOCACHE          0x200

#define MEM_COMMIT           0x1000
#define MEM_RESERVE          0x2000
#define MEM_FREE            0x10000

#define MEM_PRIVATE         0x20000
#define MEM_MAPPED          0x40000
#define MEM_IMAGE         0x1000000

#endif

typedef struct _MEMINFO {
    ADDR    addr;
    ADDR    addrAllocBase;
    UOFF32  uRegionSize;
    DWORD   dwProtect;
    DWORD   dwState;
    DWORD   dwType;
    DWORD   dwAllocationProtect;
} MEMINFO;
typedef MEMINFO FAR * LPMEMINFO;

//  Return values for mtrcEndian -- big or little endian -- which
//  byte is [0] most or least significat byte

enum _END {
    endBig,
    endLittle
};
typedef DWORD END;

//  Return values for mtrcProcessorType

enum _MPT {
    mptix86  = 1,   // Intel X86
    mptm68k  = 2,   // Mac 68K
    mptdaxp  = 3,   // Alpha AXP
    mptmips  = 4,   // MIPS
    mptmppc  = 5,   // Mac PPC
    mptntppc = 6,   // NT PPC
    mptJavaVM10 = 7,        // Java VM
    mptia64  = 8,   // IA64
    mptUnknown
};
typedef DWORD MPT;

//#include <dbgver.h>     // For AVS definition and support functions

#endif  // CV_PROJECT_BASE_TYPES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\vc\cvinfo.h ===
/***    cvinfo.h - Generic CodeView information definitions
 *
 *      Structures, constants, etc. for accessing and interpreting
 *      CodeView information.
 *
 */


/***    The master copy of this file resides in the langapi project.
 *      All Microsoft projects are required to use the master copy without
 *      modification.  Modification of the master version or a copy
 *      without consultation with all parties concerned is extremely
 *      risky.
 *
 *      When this file is modified, the corresponding documentation file
 *      omfdeb.doc in the langapi project must be updated.
 */

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#pragma once

#include "cvconst.h"

#ifndef _CV_INFO_INCLUDED
#define _CV_INFO_INCLUDED

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif

#ifndef __INLINE
#ifdef  __cplusplus
#define __INLINE inline
#else
#define __INLINE __inline
#endif
#endif

#pragma pack ( push, 1 )
typedef unsigned long   CV_uoff32_t;
typedef          long   CV_off32_t;
typedef unsigned short  CV_uoff16_t;
typedef          short  CV_off16_t;
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned long   CV_pubsymflag_t;    // must be same as CV_typ_t.
typedef unsigned short  _2BYTEPAD;
typedef unsigned long   CV_tkn_t;

#if !defined (CV_ZEROLEN)
#define CV_ZEROLEN
#endif

#if !defined (FLOAT10)
#if defined(_M_I86)                    // 16 bit x86 supporting long double
typedef long double FLOAT10;
#else                                  // 32 bit w/o long double support
typedef struct FLOAT10
{
    char b[10];
} FLOAT10;
#endif
#endif


#define CV_SIGNATURE_C6         0L  // Actual signature is >64K
#define CV_SIGNATURE_C7         1L  // First explicit signature
#define CV_SIGNATURE_C11        2L  // C11 (vc5.x) 32-bit types
#define CV_SIGNATURE_C13        4L  // C13 (vc7.x) zero terminated names
#define CV_SIGNATURE_RESERVED   5L  // All signatures from 5 to 64K are reserved

#define CV_MAXOFFSET   0xffffffff

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID {          // size is 16
    unsigned long   Data1;
    unsigned short  Data2;
    unsigned short  Data3;
    unsigned char   Data4[8];
} GUID;

#endif // !GUID_DEFINED

typedef GUID            SIG70;      // new to 7.0 are 16-byte guid-like signatures
typedef SIG70 *         PSIG70;
typedef const SIG70 *   PCSIG70;



/**     CodeView Symbol and Type OMF type information is broken up into two
 *      ranges.  Type indices less than 0x1000 describe type information
 *      that is frequently used.  Type indices above 0x1000 are used to
 *      describe more complex features such as functions, arrays and
 *      structures.
 */




/**     Primitive types have predefined meaning that is encoded in the
 *      values of the various bit fields in the value.
 *
 *      A CodeView primitive type is defined as:
 *
 *      1 1
 *      1 089  7654  3  210
 *      r mode type  r  sub
 *
 *      Where
 *          mode is the pointer mode
 *          type is a type indicator
 *          sub  is a subtype enumeration
 *          r    is a reserved field
 *
 *      See Microsoft Symbol and Type OMF (Version 4.0) for more
 *      information.
 */


#define CV_MMASK        0x700       // mode mask
#define CV_TMASK        0x0f0       // type mask

// can we use the reserved bit ??
#define CV_SMASK        0x00f       // subtype mask

#define CV_MSHIFT       8           // primitive mode right shift count
#define CV_TSHIFT       4           // primitive type right shift count
#define CV_SSHIFT       0           // primitive subtype right shift count

// macros to extract primitive mode, type and size

#define CV_MODE(typ)    (((typ) & CV_MMASK) >> CV_MSHIFT)
#define CV_TYPE(typ)    (((typ) & CV_TMASK) >> CV_TSHIFT)
#define CV_SUBT(typ)    (((typ) & CV_SMASK) >> CV_SSHIFT)

// macros to insert new primitive mode, type and size

#define CV_NEWMODE(typ, nm)     ((CV_typ_t)(((typ) & ~CV_MMASK) | ((nm) << CV_MSHIFT)))
#define CV_NEWTYPE(typ, nt)     (((typ) & ~CV_TMASK) | ((nt) << CV_TSHIFT))
#define CV_NEWSUBT(typ, ns)     (((typ) & ~CV_SMASK) | ((ns) << CV_SSHIFT))



//     pointer mode enumeration values

typedef enum CV_prmode_e {
    CV_TM_DIRECT = 0,       // mode is not a pointer
    CV_TM_NPTR   = 1,       // mode is a near pointer
    CV_TM_FPTR   = 2,       // mode is a far pointer
    CV_TM_HPTR   = 3,       // mode is a huge pointer
    CV_TM_NPTR32 = 4,       // mode is a 32 bit near pointer
    CV_TM_FPTR32 = 5,       // mode is a 32 bit far pointer
    CV_TM_NPTR64 = 6,       // mode is a 64 bit near pointer
    CV_TM_NPTR128 = 7,      // mode is a 128 bit near pointer
} CV_prmode_e;




//      type enumeration values


typedef enum CV_type_e {
    CV_SPECIAL      = 0x00,         // special type size values
    CV_SIGNED       = 0x01,         // signed integral size values
    CV_UNSIGNED     = 0x02,         // unsigned integral size values
    CV_BOOLEAN      = 0x03,         // Boolean size values
    CV_REAL         = 0x04,         // real number size values
    CV_COMPLEX      = 0x05,         // complex number size values
    CV_SPECIAL2     = 0x06,         // second set of special types
    CV_INT          = 0x07,         // integral (int) values
    CV_CVRESERVED   = 0x0f,
} CV_type_e;




//      subtype enumeration values for CV_SPECIAL


typedef enum CV_special_e {
    CV_SP_NOTYPE    = 0x00,
    CV_SP_ABS       = 0x01,
    CV_SP_SEGMENT   = 0x02,
    CV_SP_VOID      = 0x03,
    CV_SP_CURRENCY  = 0x04,
    CV_SP_NBASICSTR = 0x05,
    CV_SP_FBASICSTR = 0x06,
    CV_SP_NOTTRANS  = 0x07,
    CV_SP_HRESULT   = 0x08,
} CV_special_e;




//      subtype enumeration values for CV_SPECIAL2


typedef enum CV_special2_e {
    CV_S2_BIT       = 0x00,
    CV_S2_PASCHAR   = 0x01          // Pascal CHAR
} CV_special2_e;





//      subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN


typedef enum CV_integral_e {
    CV_IN_1BYTE     = 0x00,
    CV_IN_2BYTE     = 0x01,
    CV_IN_4BYTE     = 0x02,
    CV_IN_8BYTE     = 0x03,
    CV_IN_16BYTE    = 0x04
} CV_integral_e;





//      subtype enumeration values for CV_REAL and CV_COMPLEX


typedef enum CV_real_e {
    CV_RC_REAL32    = 0x00,
    CV_RC_REAL64    = 0x01,
    CV_RC_REAL80    = 0x02,
    CV_RC_REAL128   = 0x03,
    CV_RC_REAL48    = 0x04
} CV_real_e;




//      subtype enumeration values for CV_INT (really int)


typedef enum CV_int_e {
    CV_RI_CHAR      = 0x00,
    CV_RI_INT1      = 0x00,
    CV_RI_WCHAR     = 0x01,
    CV_RI_UINT1     = 0x01,
    CV_RI_INT2      = 0x02,
    CV_RI_UINT2     = 0x03,
    CV_RI_INT4      = 0x04,
    CV_RI_UINT4     = 0x05,
    CV_RI_INT8      = 0x06,
    CV_RI_UINT8     = 0x07,
    CV_RI_INT16     = 0x08,
    CV_RI_UINT16    = 0x09
} CV_int_e;




// macros to check the type of a primitive

#define CV_TYP_IS_DIRECT(typ)   (CV_MODE(typ) == CV_TM_DIRECT)
#define CV_TYP_IS_PTR(typ)      (CV_MODE(typ) != CV_TM_DIRECT)
#define CV_TYP_IS_NPTR(typ)     (CV_MODE(typ) == CV_TM_NPTR)
#define CV_TYP_IS_FPTR(typ)     (CV_MODE(typ) == CV_TM_FPTR)
#define CV_TYP_IS_HPTR(typ)     (CV_MODE(typ) == CV_TM_HPTR)
#define CV_TYP_IS_NPTR32(typ)   (CV_MODE(typ) == CV_TM_NPTR32)
#define CV_TYP_IS_FPTR32(typ)   (CV_MODE(typ) == CV_TM_FPTR32)

#define CV_TYP_IS_SIGNED(typ)   (((CV_TYPE(typ) == CV_SIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_INT1)  || \
                                 (typ == T_INT2)  || \
                                 (typ == T_INT4)  || \
                                 (typ == T_INT8)  || \
                                 (typ == T_INT16) || \
                                 (typ == T_RCHAR))

#define CV_TYP_IS_UNSIGNED(typ) (((CV_TYPE(typ) == CV_UNSIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_UINT1) || \
                                 (typ == T_UINT2) || \
                                 (typ == T_UINT4) || \
                                 (typ == T_UINT8) || \
                                 (typ == T_UINT16))

#define CV_TYP_IS_REAL(typ)     ((CV_TYPE(typ) == CV_REAL)  && CV_TYP_IS_DIRECT(typ))

#define CV_FIRST_NONPRIM 0x1000
#define CV_IS_PRIMITIVE(typ)    ((typ) < CV_FIRST_NONPRIM)
#define CV_TYP_IS_COMPLEX(typ)  ((CV_TYPE(typ) == CV_COMPLEX)   && CV_TYP_IS_DIRECT(typ))
#define CV_IS_INTERNAL_PTR(typ) (CV_IS_PRIMITIVE(typ) && \
                                 CV_TYPE(typ) == CV_CVRESERVED && \
                                 CV_TYP_IS_PTR(typ))






// selected values for type_index - for a more complete definition, see
// Microsoft Symbol and Type OMF document




//      Special Types

typedef enum TYPE_ENUM_e {
//      Special Types

    T_NOTYPE        = 0x0000,   // uncharacterized type (no type)
    T_ABS           = 0x0001,   // absolute symbol
    T_SEGMENT       = 0x0002,   // segment type
    T_VOID          = 0x0003,   // void
    T_HRESULT       = 0x0008,   // OLE/COM HRESULT
    T_32PHRESULT    = 0x0408,   // OLE/COM HRESULT __ptr32 *
    T_64PHRESULT    = 0x0608,   // OLE/COM HRESULT __ptr64 *
    T_PVOID         = 0x0103,   // near pointer to void
    T_PFVOID        = 0x0203,   // far pointer to void
    T_PHVOID        = 0x0303,   // huge pointer to void
    T_32PVOID       = 0x0403,   // 32 bit pointer to void
    T_32PFVOID      = 0x0503,   // 16:32 pointer to void
    T_64PVOID       = 0x0603,   // 64 bit pointer to void
    T_CURRENCY      = 0x0004,   // BASIC 8 byte currency value
    T_NBASICSTR     = 0x0005,   // Near BASIC string
    T_FBASICSTR     = 0x0006,   // Far BASIC string
    T_NOTTRANS      = 0x0007,   // type not translated by cvpack
    T_BIT           = 0x0060,   // bit
    T_PASCHAR       = 0x0061,   // Pascal CHAR


//      Character types

    T_CHAR          = 0x0010,   // 8 bit signed
    T_PCHAR         = 0x0110,   // 16 bit pointer to 8 bit signed
    T_PFCHAR        = 0x0210,   // 16:16 far pointer to 8 bit signed
    T_PHCHAR        = 0x0310,   // 16:16 huge pointer to 8 bit signed
    T_32PCHAR       = 0x0410,   // 32 bit pointer to 8 bit signed
    T_32PFCHAR      = 0x0510,   // 16:32 pointer to 8 bit signed
    T_64PCHAR       = 0x0610,   // 64 bit pointer to 8 bit signed

    T_UCHAR         = 0x0020,   // 8 bit unsigned
    T_PUCHAR        = 0x0120,   // 16 bit pointer to 8 bit unsigned
    T_PFUCHAR       = 0x0220,   // 16:16 far pointer to 8 bit unsigned
    T_PHUCHAR       = 0x0320,   // 16:16 huge pointer to 8 bit unsigned
    T_32PUCHAR      = 0x0420,   // 32 bit pointer to 8 bit unsigned
    T_32PFUCHAR     = 0x0520,   // 16:32 pointer to 8 bit unsigned
    T_64PUCHAR      = 0x0620,   // 64 bit pointer to 8 bit unsigned


//      really a character types

    T_RCHAR         = 0x0070,   // really a char
    T_PRCHAR        = 0x0170,   // 16 bit pointer to a real char
    T_PFRCHAR       = 0x0270,   // 16:16 far pointer to a real char
    T_PHRCHAR       = 0x0370,   // 16:16 huge pointer to a real char
    T_32PRCHAR      = 0x0470,   // 32 bit pointer to a real char
    T_32PFRCHAR     = 0x0570,   // 16:32 pointer to a real char
    T_64PRCHAR      = 0x0670,   // 64 bit pointer to a real char


//      really a wide character types

    T_WCHAR         = 0x0071,   // wide char
    T_PWCHAR        = 0x0171,   // 16 bit pointer to a wide char
    T_PFWCHAR       = 0x0271,   // 16:16 far pointer to a wide char
    T_PHWCHAR       = 0x0371,   // 16:16 huge pointer to a wide char
    T_32PWCHAR      = 0x0471,   // 32 bit pointer to a wide char
    T_32PFWCHAR     = 0x0571,   // 16:32 pointer to a wide char
    T_64PWCHAR      = 0x0671,   // 64 bit pointer to a wide char


//      8 bit int types

    T_INT1          = 0x0068,   // 8 bit signed int
    T_PINT1         = 0x0168,   // 16 bit pointer to 8 bit signed int
    T_PFINT1        = 0x0268,   // 16:16 far pointer to 8 bit signed int
    T_PHINT1        = 0x0368,   // 16:16 huge pointer to 8 bit signed int
    T_32PINT1       = 0x0468,   // 32 bit pointer to 8 bit signed int
    T_32PFINT1      = 0x0568,   // 16:32 pointer to 8 bit signed int
    T_64PINT1       = 0x0668,   // 64 bit pointer to 8 bit signed int

    T_UINT1         = 0x0069,   // 8 bit unsigned int
    T_PUINT1        = 0x0169,   // 16 bit pointer to 8 bit unsigned int
    T_PFUINT1       = 0x0269,   // 16:16 far pointer to 8 bit unsigned int
    T_PHUINT1       = 0x0369,   // 16:16 huge pointer to 8 bit unsigned int
    T_32PUINT1      = 0x0469,   // 32 bit pointer to 8 bit unsigned int
    T_32PFUINT1     = 0x0569,   // 16:32 pointer to 8 bit unsigned int
    T_64PUINT1      = 0x0669,   // 64 bit pointer to 8 bit unsigned int


//      16 bit short types

    T_SHORT         = 0x0011,   // 16 bit signed
    T_PSHORT        = 0x0111,   // 16 bit pointer to 16 bit signed
    T_PFSHORT       = 0x0211,   // 16:16 far pointer to 16 bit signed
    T_PHSHORT       = 0x0311,   // 16:16 huge pointer to 16 bit signed
    T_32PSHORT      = 0x0411,   // 32 bit pointer to 16 bit signed
    T_32PFSHORT     = 0x0511,   // 16:32 pointer to 16 bit signed
    T_64PSHORT      = 0x0611,   // 64 bit pointer to 16 bit signed

    T_USHORT        = 0x0021,   // 16 bit unsigned
    T_PUSHORT       = 0x0121,   // 16 bit pointer to 16 bit unsigned
    T_PFUSHORT      = 0x0221,   // 16:16 far pointer to 16 bit unsigned
    T_PHUSHORT      = 0x0321,   // 16:16 huge pointer to 16 bit unsigned
    T_32PUSHORT     = 0x0421,   // 32 bit pointer to 16 bit unsigned
    T_32PFUSHORT    = 0x0521,   // 16:32 pointer to 16 bit unsigned
    T_64PUSHORT     = 0x0621,   // 64 bit pointer to 16 bit unsigned


//      16 bit int types

    T_INT2          = 0x0072,   // 16 bit signed int
    T_PINT2         = 0x0172,   // 16 bit pointer to 16 bit signed int
    T_PFINT2        = 0x0272,   // 16:16 far pointer to 16 bit signed int
    T_PHINT2        = 0x0372,   // 16:16 huge pointer to 16 bit signed int
    T_32PINT2       = 0x0472,   // 32 bit pointer to 16 bit signed int
    T_32PFINT2      = 0x0572,   // 16:32 pointer to 16 bit signed int
    T_64PINT2       = 0x0672,   // 64 bit pointer to 16 bit signed int

    T_UINT2         = 0x0073,   // 16 bit unsigned int
    T_PUINT2        = 0x0173,   // 16 bit pointer to 16 bit unsigned int
    T_PFUINT2       = 0x0273,   // 16:16 far pointer to 16 bit unsigned int
    T_PHUINT2       = 0x0373,   // 16:16 huge pointer to 16 bit unsigned int
    T_32PUINT2      = 0x0473,   // 32 bit pointer to 16 bit unsigned int
    T_32PFUINT2     = 0x0573,   // 16:32 pointer to 16 bit unsigned int
    T_64PUINT2      = 0x0673,   // 64 bit pointer to 16 bit unsigned int


//      32 bit long types

    T_LONG          = 0x0012,   // 32 bit signed
    T_ULONG         = 0x0022,   // 32 bit unsigned
    T_PLONG         = 0x0112,   // 16 bit pointer to 32 bit signed
    T_PULONG        = 0x0122,   // 16 bit pointer to 32 bit unsigned
    T_PFLONG        = 0x0212,   // 16:16 far pointer to 32 bit signed
    T_PFULONG       = 0x0222,   // 16:16 far pointer to 32 bit unsigned
    T_PHLONG        = 0x0312,   // 16:16 huge pointer to 32 bit signed
    T_PHULONG       = 0x0322,   // 16:16 huge pointer to 32 bit unsigned

    T_32PLONG       = 0x0412,   // 32 bit pointer to 32 bit signed
    T_32PULONG      = 0x0422,   // 32 bit pointer to 32 bit unsigned
    T_32PFLONG      = 0x0512,   // 16:32 pointer to 32 bit signed
    T_32PFULONG     = 0x0522,   // 16:32 pointer to 32 bit unsigned
    T_64PLONG       = 0x0612,   // 64 bit pointer to 32 bit signed
    T_64PULONG      = 0x0622,   // 64 bit pointer to 32 bit unsigned


//      32 bit int types

    T_INT4          = 0x0074,   // 32 bit signed int
    T_PINT4         = 0x0174,   // 16 bit pointer to 32 bit signed int
    T_PFINT4        = 0x0274,   // 16:16 far pointer to 32 bit signed int
    T_PHINT4        = 0x0374,   // 16:16 huge pointer to 32 bit signed int
    T_32PINT4       = 0x0474,   // 32 bit pointer to 32 bit signed int
    T_32PFINT4      = 0x0574,   // 16:32 pointer to 32 bit signed int
    T_64PINT4       = 0x0674,   // 64 bit pointer to 32 bit signed int

    T_UINT4         = 0x0075,   // 32 bit unsigned int
    T_PUINT4        = 0x0175,   // 16 bit pointer to 32 bit unsigned int
    T_PFUINT4       = 0x0275,   // 16:16 far pointer to 32 bit unsigned int
    T_PHUINT4       = 0x0375,   // 16:16 huge pointer to 32 bit unsigned int
    T_32PUINT4      = 0x0475,   // 32 bit pointer to 32 bit unsigned int
    T_32PFUINT4     = 0x0575,   // 16:32 pointer to 32 bit unsigned int
    T_64PUINT4      = 0x0675,   // 64 bit pointer to 32 bit unsigned int


//      64 bit quad types

    T_QUAD          = 0x0013,   // 64 bit signed
    T_PQUAD         = 0x0113,   // 16 bit pointer to 64 bit signed
    T_PFQUAD        = 0x0213,   // 16:16 far pointer to 64 bit signed
    T_PHQUAD        = 0x0313,   // 16:16 huge pointer to 64 bit signed
    T_32PQUAD       = 0x0413,   // 32 bit pointer to 64 bit signed
    T_32PFQUAD      = 0x0513,   // 16:32 pointer to 64 bit signed
    T_64PQUAD       = 0x0613,   // 64 bit pointer to 64 bit signed

    T_UQUAD         = 0x0023,   // 64 bit unsigned
    T_PUQUAD        = 0x0123,   // 16 bit pointer to 64 bit unsigned
    T_PFUQUAD       = 0x0223,   // 16:16 far pointer to 64 bit unsigned
    T_PHUQUAD       = 0x0323,   // 16:16 huge pointer to 64 bit unsigned
    T_32PUQUAD      = 0x0423,   // 32 bit pointer to 64 bit unsigned
    T_32PFUQUAD     = 0x0523,   // 16:32 pointer to 64 bit unsigned
    T_64PUQUAD      = 0x0623,   // 64 bit pointer to 64 bit unsigned


//      64 bit int types

    T_INT8          = 0x0076,   // 64 bit signed int
    T_PINT8         = 0x0176,   // 16 bit pointer to 64 bit signed int
    T_PFINT8        = 0x0276,   // 16:16 far pointer to 64 bit signed int
    T_PHINT8        = 0x0376,   // 16:16 huge pointer to 64 bit signed int
    T_32PINT8       = 0x0476,   // 32 bit pointer to 64 bit signed int
    T_32PFINT8      = 0x0576,   // 16:32 pointer to 64 bit signed int
    T_64PINT8       = 0x0676,   // 64 bit pointer to 64 bit signed int

    T_UINT8         = 0x0077,   // 64 bit unsigned int
    T_PUINT8        = 0x0177,   // 16 bit pointer to 64 bit unsigned int
    T_PFUINT8       = 0x0277,   // 16:16 far pointer to 64 bit unsigned int
    T_PHUINT8       = 0x0377,   // 16:16 huge pointer to 64 bit unsigned int
    T_32PUINT8      = 0x0477,   // 32 bit pointer to 64 bit unsigned int
    T_32PFUINT8     = 0x0577,   // 16:32 pointer to 64 bit unsigned int
    T_64PUINT8      = 0x0677,   // 64 bit pointer to 64 bit unsigned int


//      128 bit octet types

    T_OCT           = 0x0014,   // 128 bit signed
    T_POCT          = 0x0114,   // 16 bit pointer to 128 bit signed
    T_PFOCT         = 0x0214,   // 16:16 far pointer to 128 bit signed
    T_PHOCT         = 0x0314,   // 16:16 huge pointer to 128 bit signed
    T_32POCT        = 0x0414,   // 32 bit pointer to 128 bit signed
    T_32PFOCT       = 0x0514,   // 16:32 pointer to 128 bit signed
    T_64POCT        = 0x0614,   // 64 bit pointer to 128 bit signed

    T_UOCT          = 0x0024,   // 128 bit unsigned
    T_PUOCT         = 0x0124,   // 16 bit pointer to 128 bit unsigned
    T_PFUOCT        = 0x0224,   // 16:16 far pointer to 128 bit unsigned
    T_PHUOCT        = 0x0324,   // 16:16 huge pointer to 128 bit unsigned
    T_32PUOCT       = 0x0424,   // 32 bit pointer to 128 bit unsigned
    T_32PFUOCT      = 0x0524,   // 16:32 pointer to 128 bit unsigned
    T_64PUOCT       = 0x0624,   // 64 bit pointer to 128 bit unsigned


//      128 bit int types

    T_INT16         = 0x0078,   // 128 bit signed int
    T_PINT16        = 0x0178,   // 16 bit pointer to 128 bit signed int
    T_PFINT16       = 0x0278,   // 16:16 far pointer to 128 bit signed int
    T_PHINT16       = 0x0378,   // 16:16 huge pointer to 128 bit signed int
    T_32PINT16      = 0x0478,   // 32 bit pointer to 128 bit signed int
    T_32PFINT16     = 0x0578,   // 16:32 pointer to 128 bit signed int
    T_64PINT16      = 0x0678,   // 64 bit pointer to 128 bit signed int

    T_UINT16        = 0x0079,   // 128 bit unsigned int
    T_PUINT16       = 0x0179,   // 16 bit pointer to 128 bit unsigned int
    T_PFUINT16      = 0x0279,   // 16:16 far pointer to 128 bit unsigned int
    T_PHUINT16      = 0x0379,   // 16:16 huge pointer to 128 bit unsigned int
    T_32PUINT16     = 0x0479,   // 32 bit pointer to 128 bit unsigned int
    T_32PFUINT16    = 0x0579,   // 16:32 pointer to 128 bit unsigned int
    T_64PUINT16     = 0x0679,   // 64 bit pointer to 128 bit unsigned int


//      32 bit real types

    T_REAL32        = 0x0040,   // 32 bit real
    T_PREAL32       = 0x0140,   // 16 bit pointer to 32 bit real
    T_PFREAL32      = 0x0240,   // 16:16 far pointer to 32 bit real
    T_PHREAL32      = 0x0340,   // 16:16 huge pointer to 32 bit real
    T_32PREAL32     = 0x0440,   // 32 bit pointer to 32 bit real
    T_32PFREAL32    = 0x0540,   // 16:32 pointer to 32 bit real
    T_64PREAL32     = 0x0640,   // 64 bit pointer to 32 bit real


//      48 bit real types

    T_REAL48        = 0x0044,   // 48 bit real
    T_PREAL48       = 0x0144,   // 16 bit pointer to 48 bit real
    T_PFREAL48      = 0x0244,   // 16:16 far pointer to 48 bit real
    T_PHREAL48      = 0x0344,   // 16:16 huge pointer to 48 bit real
    T_32PREAL48     = 0x0444,   // 32 bit pointer to 48 bit real
    T_32PFREAL48    = 0x0544,   // 16:32 pointer to 48 bit real
    T_64PREAL48     = 0x0644,   // 64 bit pointer to 48 bit real


//      64 bit real types

    T_REAL64        = 0x0041,   // 64 bit real
    T_PREAL64       = 0x0141,   // 16 bit pointer to 64 bit real
    T_PFREAL64      = 0x0241,   // 16:16 far pointer to 64 bit real
    T_PHREAL64      = 0x0341,   // 16:16 huge pointer to 64 bit real
    T_32PREAL64     = 0x0441,   // 32 bit pointer to 64 bit real
    T_32PFREAL64    = 0x0541,   // 16:32 pointer to 64 bit real
    T_64PREAL64     = 0x0641,   // 64 bit pointer to 64 bit real


//      80 bit real types

    T_REAL80        = 0x0042,   // 80 bit real
    T_PREAL80       = 0x0142,   // 16 bit pointer to 80 bit real
    T_PFREAL80      = 0x0242,   // 16:16 far pointer to 80 bit real
    T_PHREAL80      = 0x0342,   // 16:16 huge pointer to 80 bit real
    T_32PREAL80     = 0x0442,   // 32 bit pointer to 80 bit real
    T_32PFREAL80    = 0x0542,   // 16:32 pointer to 80 bit real
    T_64PREAL80     = 0x0642,   // 64 bit pointer to 80 bit real


//      128 bit real types

    T_REAL128       = 0x0043,   // 128 bit real
    T_PREAL128      = 0x0143,   // 16 bit pointer to 128 bit real
    T_PFREAL128     = 0x0243,   // 16:16 far pointer to 128 bit real
    T_PHREAL128     = 0x0343,   // 16:16 huge pointer to 128 bit real
    T_32PREAL128    = 0x0443,   // 32 bit pointer to 128 bit real
    T_32PFREAL128   = 0x0543,   // 16:32 pointer to 128 bit real
    T_64PREAL128    = 0x0643,   // 64 bit pointer to 128 bit real


//      32 bit complex types

    T_CPLX32        = 0x0050,   // 32 bit complex
    T_PCPLX32       = 0x0150,   // 16 bit pointer to 32 bit complex
    T_PFCPLX32      = 0x0250,   // 16:16 far pointer to 32 bit complex
    T_PHCPLX32      = 0x0350,   // 16:16 huge pointer to 32 bit complex
    T_32PCPLX32     = 0x0450,   // 32 bit pointer to 32 bit complex
    T_32PFCPLX32    = 0x0550,   // 16:32 pointer to 32 bit complex
    T_64PCPLX32     = 0x0650,   // 64 bit pointer to 32 bit complex


//      64 bit complex types

    T_CPLX64        = 0x0051,   // 64 bit complex
    T_PCPLX64       = 0x0151,   // 16 bit pointer to 64 bit complex
    T_PFCPLX64      = 0x0251,   // 16:16 far pointer to 64 bit complex
    T_PHCPLX64      = 0x0351,   // 16:16 huge pointer to 64 bit complex
    T_32PCPLX64     = 0x0451,   // 32 bit pointer to 64 bit complex
    T_32PFCPLX64    = 0x0551,   // 16:32 pointer to 64 bit complex
    T_64PCPLX64     = 0x0651,   // 64 bit pointer to 64 bit complex


//      80 bit complex types

    T_CPLX80        = 0x0052,   // 80 bit complex
    T_PCPLX80       = 0x0152,   // 16 bit pointer to 80 bit complex
    T_PFCPLX80      = 0x0252,   // 16:16 far pointer to 80 bit complex
    T_PHCPLX80      = 0x0352,   // 16:16 huge pointer to 80 bit complex
    T_32PCPLX80     = 0x0452,   // 32 bit pointer to 80 bit complex
    T_32PFCPLX80    = 0x0552,   // 16:32 pointer to 80 bit complex
    T_64PCPLX80     = 0x0652,   // 64 bit pointer to 80 bit complex


//      128 bit complex types

    T_CPLX128       = 0x0053,   // 128 bit complex
    T_PCPLX128      = 0x0153,   // 16 bit pointer to 128 bit complex
    T_PFCPLX128     = 0x0253,   // 16:16 far pointer to 128 bit complex
    T_PHCPLX128     = 0x0353,   // 16:16 huge pointer to 128 bit real
    T_32PCPLX128    = 0x0453,   // 32 bit pointer to 128 bit complex
    T_32PFCPLX128   = 0x0553,   // 16:32 pointer to 128 bit complex
    T_64PCPLX128    = 0x0653,   // 64 bit pointer to 128 bit complex


//      boolean types

    T_BOOL08        = 0x0030,   // 8 bit boolean
    T_PBOOL08       = 0x0130,   // 16 bit pointer to  8 bit boolean
    T_PFBOOL08      = 0x0230,   // 16:16 far pointer to  8 bit boolean
    T_PHBOOL08      = 0x0330,   // 16:16 huge pointer to  8 bit boolean
    T_32PBOOL08     = 0x0430,   // 32 bit pointer to 8 bit boolean
    T_32PFBOOL08    = 0x0530,   // 16:32 pointer to 8 bit boolean
    T_64PBOOL08     = 0x0630,   // 64 bit pointer to 8 bit boolean

    T_BOOL16        = 0x0031,   // 16 bit boolean
    T_PBOOL16       = 0x0131,   // 16 bit pointer to 16 bit boolean
    T_PFBOOL16      = 0x0231,   // 16:16 far pointer to 16 bit boolean
    T_PHBOOL16      = 0x0331,   // 16:16 huge pointer to 16 bit boolean
    T_32PBOOL16     = 0x0431,   // 32 bit pointer to 18 bit boolean
    T_32PFBOOL16    = 0x0531,   // 16:32 pointer to 16 bit boolean
    T_64PBOOL16     = 0x0631,   // 64 bit pointer to 18 bit boolean

    T_BOOL32        = 0x0032,   // 32 bit boolean
    T_PBOOL32       = 0x0132,   // 16 bit pointer to 32 bit boolean
    T_PFBOOL32      = 0x0232,   // 16:16 far pointer to 32 bit boolean
    T_PHBOOL32      = 0x0332,   // 16:16 huge pointer to 32 bit boolean
    T_32PBOOL32     = 0x0432,   // 32 bit pointer to 32 bit boolean
    T_32PFBOOL32    = 0x0532,   // 16:32 pointer to 32 bit boolean
    T_64PBOOL32     = 0x0632,   // 64 bit pointer to 32 bit boolean

    T_BOOL64        = 0x0033,   // 64 bit boolean
    T_PBOOL64       = 0x0133,   // 16 bit pointer to 64 bit boolean
    T_PFBOOL64      = 0x0233,   // 16:16 far pointer to 64 bit boolean
    T_PHBOOL64      = 0x0333,   // 16:16 huge pointer to 64 bit boolean
    T_32PBOOL64     = 0x0433,   // 32 bit pointer to 64 bit boolean
    T_32PFBOOL64    = 0x0533,   // 16:32 pointer to 64 bit boolean
    T_64PBOOL64     = 0x0633,   // 64 bit pointer to 64 bit boolean


//      ???

    T_NCVPTR        = 0x01f0,   // CV Internal type for created near pointers
    T_FCVPTR        = 0x02f0,   // CV Internal type for created far pointers
    T_HCVPTR        = 0x03f0,   // CV Internal type for created huge pointers
    T_32NCVPTR      = 0x04f0,   // CV Internal type for created near 32-bit pointers
    T_32FCVPTR      = 0x05f0,   // CV Internal type for created far 32-bit pointers
    T_64NCVPTR      = 0x06f0,   // CV Internal type for created near 64-bit pointers

} TYPE_ENUM_e;

/**     No leaf index can have a value of 0x0000.  The leaf indices are
 *      separated into ranges depending upon the use of the type record.
 *      The second range is for the type records that are directly referenced
 *      in symbols. The first range is for type records that are not
 *      referenced by symbols but instead are referenced by other type
 *      records.  All type records must have a starting leaf index in these
 *      first two ranges.  The third range of leaf indices are used to build
 *      up complex lists such as the field list of a class type record.  No
 *      type record can begin with one of the leaf indices. The fourth ranges
 *      of type indices are used to represent numeric data in a symbol or
 *      type record. These leaf indices are greater than 0x8000.  At the
 *      point that type or symbol processor is expecting a numeric field, the
 *      next two bytes in the type record are examined.  If the value is less
 *      than 0x8000, then the two bytes contain the numeric value.  If the
 *      value is greater than 0x8000, then the data follows the leaf index in
 *      a format specified by the leaf index. The final range of leaf indices
 *      are used to force alignment of subfields within a complex type record..
 */


typedef enum LEAF_ENUM_e {
    // leaf indices starting records but referenced from symbol records

    LF_MODIFIER_16t     = 0x0001,
    LF_POINTER_16t      = 0x0002,
    LF_ARRAY_16t        = 0x0003,
    LF_CLASS_16t        = 0x0004,
    LF_STRUCTURE_16t    = 0x0005,
    LF_UNION_16t        = 0x0006,
    LF_ENUM_16t         = 0x0007,
    LF_PROCEDURE_16t    = 0x0008,
    LF_MFUNCTION_16t    = 0x0009,
    LF_VTSHAPE          = 0x000a,
    LF_COBOL0_16t       = 0x000b,
    LF_COBOL1           = 0x000c,
    LF_BARRAY_16t       = 0x000d,
    LF_LABEL            = 0x000e,
    LF_NULL             = 0x000f,
    LF_NOTTRAN          = 0x0010,
    LF_DIMARRAY_16t     = 0x0011,
    LF_VFTPATH_16t      = 0x0012,
    LF_PRECOMP_16t      = 0x0013,       // not referenced from symbol
    LF_ENDPRECOMP       = 0x0014,       // not referenced from symbol
    LF_OEM_16t          = 0x0015,       // oem definable type string
#ifdef LNGNM
    LF_TYPESERVER_ST    = 0x0016,       // not referenced from symbol
#else
    LF_TYPESERVER       = 0x0016,       // not referenced from symbol
#endif

    // leaf indices starting records but referenced only from type records

    LF_SKIP_16t         = 0x0200,
    LF_ARGLIST_16t      = 0x0201,
    LF_DEFARG_16t       = 0x0202,
    LF_LIST             = 0x0203,
    LF_FIELDLIST_16t    = 0x0204,
    LF_DERIVED_16t      = 0x0205,
    LF_BITFIELD_16t     = 0x0206,
    LF_METHODLIST_16t   = 0x0207,
    LF_DIMCONU_16t      = 0x0208,
    LF_DIMCONLU_16t     = 0x0209,
    LF_DIMVARU_16t      = 0x020a,
    LF_DIMVARLU_16t     = 0x020b,
    LF_REFSYM           = 0x020c,

    LF_BCLASS_16t       = 0x0400,
    LF_VBCLASS_16t      = 0x0401,
    LF_IVBCLASS_16t     = 0x0402,
#ifdef LNGNM
    LF_ENUMERATE_ST     = 0x0403,
#else
    LF_ENUMERATE        = 0x0403,
#endif
    LF_FRIENDFCN_16t    = 0x0404,
    LF_INDEX_16t        = 0x0405,
    LF_MEMBER_16t       = 0x0406,
    LF_STMEMBER_16t     = 0x0407,
    LF_METHOD_16t       = 0x0408,
    LF_NESTTYPE_16t     = 0x0409,
    LF_VFUNCTAB_16t     = 0x040a,
    LF_FRIENDCLS_16t    = 0x040b,
    LF_ONEMETHOD_16t    = 0x040c,
    LF_VFUNCOFF_16t     = 0x040d,

// 32-bit type index versions of leaves, all have the 0x1000 bit set
//
    LF_TI16_MAX         = 0x1000,

    LF_MODIFIER         = 0x1001,
    LF_POINTER          = 0x1002,
#ifdef LNGNM
    LF_ARRAY_ST         = 0x1003,
    LF_CLASS_ST         = 0x1004,
    LF_STRUCTURE_ST     = 0x1005,
    LF_UNION_ST         = 0x1006,
    LF_ENUM_ST          = 0x1007,
#else
    LF_ARRAY            = 0x1003,
    LF_CLASS            = 0x1004,
    LF_STRUCTURE        = 0x1005,
    LF_UNION            = 0x1006,
    LF_ENUM             = 0x1007,
#endif
    LF_PROCEDURE        = 0x1008,
    LF_MFUNCTION        = 0x1009,
    LF_COBOL0           = 0x100a,
    LF_BARRAY           = 0x100b,
#ifdef LNGNM
    LF_DIMARRAY_ST      = 0x100c,
#else
    LF_DIMARRAY         = 0x100c,
#endif
    LF_VFTPATH          = 0x100d,
#ifdef LNGNM
    LF_PRECOMP_ST       = 0x100e,       // not referenced from symbol
#else
    LF_PRECOMP          = 0x100e,       // not referenced from symbol
#endif
    LF_OEM              = 0x100f,       // oem definable type string
#ifdef LNGNM
    LF_ALIAS_ST         = 0x1010,       // alias (typedef) type
#else
    LF_ALIAS            = 0x1010,       // alias (typedef) type
#endif
    LF_OEM2             = 0x1011,       // oem definable type string

    // leaf indices starting records but referenced only from type records

    LF_SKIP             = 0x1200,
    LF_ARGLIST          = 0x1201,
#ifdef LNGNM
    LF_DEFARG_ST        = 0x1202,
#else
    LF_DEFARG           = 0x1202,
#endif
    LF_FIELDLIST        = 0x1203,
    LF_DERIVED          = 0x1204,
    LF_BITFIELD         = 0x1205,
    LF_METHODLIST       = 0x1206,
    LF_DIMCONU          = 0x1207,
    LF_DIMCONLU         = 0x1208,
    LF_DIMVARU          = 0x1209,
    LF_DIMVARLU         = 0x120a,

    LF_BCLASS           = 0x1400,
    LF_VBCLASS          = 0x1401,
    LF_IVBCLASS         = 0x1402,
#ifdef LNGNM
    LF_FRIENDFCN_ST     = 0x1403,
#else
    LF_FRIENDFCN        = 0x1403,
#endif
    LF_INDEX            = 0x1404,
#ifdef LNGNM
    LF_MEMBER_ST        = 0x1405,
    LF_STMEMBER_ST      = 0x1406,
    LF_METHOD_ST        = 0x1407,
    LF_NESTTYPE_ST      = 0x1408,
#else
    LF_MEMBER           = 0x1405,
    LF_STMEMBER         = 0x1406,
    LF_METHOD           = 0x1407,
    LF_NESTTYPE         = 0x1408,
#endif
    LF_VFUNCTAB         = 0x1409,
    LF_FRIENDCLS        = 0x140a,
#ifdef LNGNM
    LF_ONEMETHOD_ST     = 0x140b,
#else
    LF_ONEMETHOD        = 0x140b,
#endif
    LF_VFUNCOFF         = 0x140c,
#ifndef LNGNM
    LF_NESTTYPEEX       = 0x140d,
    LF_MEMBERMODIFY     = 0x140e,
    LF_MANAGED          = 0x140f,

#else
    LF_NESTTYPEEX_ST    = 0x140d,
    LF_MEMBERMODIFY_ST  = 0x140e,
    LF_MANAGED_ST       = 0x140f,

    // Types w/ SZ names

    LF_ST_MAX           = 0x1500,

    LF_TYPESERVER       = 0x1501,       // not referenced from symbol
    LF_ENUMERATE        = 0x1502,
    LF_ARRAY            = 0x1503,
    LF_CLASS            = 0x1504,
    LF_STRUCTURE        = 0x1505,
    LF_UNION            = 0x1506,
    LF_ENUM             = 0x1507,
    LF_DIMARRAY         = 0x1508,
    LF_PRECOMP          = 0x1509,       // not referenced from symbol
    LF_ALIAS            = 0x150a,       // alias (typedef) type
    LF_DEFARG           = 0x150b,
    LF_FRIENDFCN        = 0x150c,
    LF_MEMBER           = 0x150d,
    LF_STMEMBER         = 0x150e,
    LF_METHOD           = 0x150f,
    LF_NESTTYPE         = 0x1510,
    LF_ONEMETHOD        = 0x1511,
    LF_NESTTYPEEX       = 0x1512,
    LF_MEMBERMODIFY     = 0x1513,
    LF_MANAGED          = 0x1514,
    LF_TYPESERVER2      = 0x1515,
#endif


    LF_NUMERIC          = 0x8000,
    LF_CHAR             = 0x8000,
    LF_SHORT            = 0x8001,
    LF_USHORT           = 0x8002,
    LF_LONG             = 0x8003,
    LF_ULONG            = 0x8004,
    LF_REAL32           = 0x8005,
    LF_REAL64           = 0x8006,
    LF_REAL80           = 0x8007,
    LF_REAL128          = 0x8008,
    LF_QUADWORD         = 0x8009,
    LF_UQUADWORD        = 0x800a,
    LF_REAL48           = 0x800b,
    LF_COMPLEX32        = 0x800c,
    LF_COMPLEX64        = 0x800d,
    LF_COMPLEX80        = 0x800e,
    LF_COMPLEX128       = 0x800f,
    LF_VARSTRING        = 0x8010,

    LF_OCTWORD          = 0x8017,
    LF_UOCTWORD         = 0x8018,

    LF_DECIMAL          = 0x8019,
    LF_DATE             = 0x801a,
    LF_UTF8STRING       = 0x801b,

    LF_PAD0             = 0xf0,
    LF_PAD1             = 0xf1,
    LF_PAD2             = 0xf2,
    LF_PAD3             = 0xf3,
    LF_PAD4             = 0xf4,
    LF_PAD5             = 0xf5,
    LF_PAD6             = 0xf6,
    LF_PAD7             = 0xf7,
    LF_PAD8             = 0xf8,
    LF_PAD9             = 0xf9,
    LF_PAD10            = 0xfa,
    LF_PAD11            = 0xfb,
    LF_PAD12            = 0xfc,
    LF_PAD13            = 0xfd,
    LF_PAD14            = 0xfe,
    LF_PAD15            = 0xff,

} LEAF_ENUM_e;

// end of leaf indices




//      Type enum for pointer records
//      Pointers can be one of the following types


typedef enum CV_ptrtype_e {
    CV_PTR_NEAR         = 0x00, // 16 bit pointer
    CV_PTR_FAR          = 0x01, // 16:16 far pointer
    CV_PTR_HUGE         = 0x02, // 16:16 huge pointer
    CV_PTR_BASE_SEG     = 0x03, // based on segment
    CV_PTR_BASE_VAL     = 0x04, // based on value of base
    CV_PTR_BASE_SEGVAL  = 0x05, // based on segment value of base
    CV_PTR_BASE_ADDR    = 0x06, // based on address of base
    CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
    CV_PTR_BASE_TYPE    = 0x08, // based on type
    CV_PTR_BASE_SELF    = 0x09, // based on self
    CV_PTR_NEAR32       = 0x0a, // 32 bit pointer
    CV_PTR_FAR32        = 0x0b, // 16:32 pointer
    CV_PTR_64           = 0x0c, // 64 bit pointer
    CV_PTR_UNUSEDPTR    = 0x0d  // first unused pointer type
} CV_ptrtype_e;





//      Mode enum for pointers
//      Pointers can have one of the following modes


typedef enum CV_ptrmode_e {
    CV_PTR_MODE_PTR     = 0x00, // "normal" pointer
    CV_PTR_MODE_REF     = 0x01, // reference
    CV_PTR_MODE_PMEM    = 0x02, // pointer to data member
    CV_PTR_MODE_PMFUNC  = 0x03, // pointer to member function
    CV_PTR_MODE_RESERVED= 0x04  // first unused pointer mode
} CV_ptrmode_e;


//      enumeration for method properties

typedef enum CV_methodprop_e {
    CV_MTvanilla        = 0x00,
    CV_MTvirtual        = 0x01,
    CV_MTstatic         = 0x02,
    CV_MTfriend         = 0x03,
    CV_MTintro          = 0x04,
    CV_MTpurevirt       = 0x05,
    CV_MTpureintro      = 0x06
} CV_methodprop_e;




//      enumeration for virtual shape table entries

typedef enum CV_VTS_desc_e {
    CV_VTS_near         = 0x00,
    CV_VTS_far          = 0x01,
    CV_VTS_thin         = 0x02,
    CV_VTS_outer        = 0x03,
    CV_VTS_meta         = 0x04,
    CV_VTS_near32       = 0x05,
    CV_VTS_far32        = 0x06,
    CV_VTS_unused       = 0x07
} CV_VTS_desc_e;




//      enumeration for LF_LABEL address modes

typedef enum CV_LABEL_TYPE_e {
    CV_LABEL_NEAR = 0,       // near return
    CV_LABEL_FAR  = 4        // far return
} CV_LABEL_TYPE_e;



//      enumeration for LF_MODIFIER values


typedef struct CV_modifier_t {
    unsigned short  MOD_const       :1;
    unsigned short  MOD_volatile    :1;
    unsigned short  MOD_unaligned   :1;
    unsigned short  MOD_unused      :13;
} CV_modifier_t;


//  bit field structure describing class/struct/union/enum properties

typedef struct CV_prop_t {
    unsigned short  packed      :1;     // true if structure is packed
    unsigned short  ctor        :1;     // true if constructors or destructors present
    unsigned short  ovlops      :1;     // true if overloaded operators present
    unsigned short  isnested    :1;     // true if this is a nested class
    unsigned short  cnested     :1;     // true if this class contains nested types
    unsigned short  opassign    :1;     // true if overloaded assignment (=)
    unsigned short  opcast      :1;     // true if casting methods
    unsigned short  fwdref      :1;     // true if forward reference (incomplete defn)
    unsigned short  scoped      :1;     // scoped definition
    unsigned short  reserved    :7;
} CV_prop_t;




//  class field attribute

typedef struct CV_fldattr_t {
    unsigned short  access      :2;     // access protection CV_access_t
    unsigned short  mprop       :3;     // method properties CV_methodprop_t
    unsigned short  pseudo      :1;     // compiler generated fcn and does not exist
    unsigned short  noinherit   :1;     // true if class cannot be inherited
    unsigned short  noconstruct :1;     // true if class cannot be constructed
    unsigned short  compgenx    :1;     // compiler generated fcn and does exist
    unsigned short  unused      :7;     // unused
} CV_fldattr_t;



//  Structures to access to the type records


typedef struct TYPTYPE {
    unsigned short  len;
    unsigned short  leaf;
    unsigned char   data[CV_ZEROLEN];
} TYPTYPE;          // general types record


__INLINE char *NextType (char * pType) {
    return (pType + ((TYPTYPE *)pType)->len + sizeof(unsigned short));
}

typedef enum CV_PMEMBER {
    CV_PDM16_NONVIRT    = 0x00, // 16:16 data no virtual fcn or base
    CV_PDM16_VFCN       = 0x01, // 16:16 data with virtual functions
    CV_PDM16_VBASE      = 0x02, // 16:16 data with virtual bases
    CV_PDM32_NVVFCN     = 0x03, // 16:32 data w/wo virtual functions
    CV_PDM32_VBASE      = 0x04, // 16:32 data with virtual bases

    CV_PMF16_NEARNVSA   = 0x05, // 16:16 near method nonvirtual single address point
    CV_PMF16_NEARNVMA   = 0x06, // 16:16 near method nonvirtual multiple address points
    CV_PMF16_NEARVBASE  = 0x07, // 16:16 near method virtual bases
    CV_PMF16_FARNVSA    = 0x08, // 16:16 far method nonvirtual single address point
    CV_PMF16_FARNVMA    = 0x09, // 16:16 far method nonvirtual multiple address points
    CV_PMF16_FARVBASE   = 0x0a, // 16:16 far method virtual bases

    CV_PMF32_NVSA       = 0x0b, // 16:32 method nonvirtual single address point
    CV_PMF32_NVMA       = 0x0c, // 16:32 method nonvirtual multiple address point
    CV_PMF32_VBASE      = 0x0d  // 16:32 method virtual bases
} CV_PMEMBER;



//  memory representation of pointer to member.  These representations are
//  indexed by the enumeration above in the LF_POINTER record




//  representation of a 16:16 pointer to data for a class with no
//  virtual functions or virtual bases


struct CV_PDMR16_NONVIRT {
    CV_off16_t      mdisp;      // displacement to data (NULL = -1)
};




//  representation of a 16:16 pointer to data for a class with virtual
//  functions


struct CV_PMDR16_VFCN {
    CV_off16_t      mdisp;      // displacement to data ( NULL = 0)
};




//  representation of a 16:16 pointer to data for a class with
//  virtual bases


struct CV_PDMR16_VBASE {
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement to vbptr
    CV_off16_t      vdisp;      // displacement within vbase table
                                // NULL = (,,0xffff)
};




//  representation of a 32 bit pointer to data for a class with
//  or without virtual functions and no virtual bases


struct CV_PDMR32_NVVFCN {
    CV_off32_t      mdisp;      // displacement to data (NULL = 0x80000000)
};




//  representation of a 32 bit pointer to data for a class
//  with virtual bases


struct CV_PDMR32_VBASE {
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
                                // NULL = (,,0xffffffff)
};




//  representation of a 16:16 pointer to near member function for a
//  class with no virtual functions or bases and a single address point


struct CV_PMFR16_NEARNVSA {
    CV_uoff16_t     off;        // near address of function (NULL = 0)
};



//  representation of a 16 bit pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_NEARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x)
    signed short    disp;
};




//  representation of a 16 bit pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_NEARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x,x,x)
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement
};




//  representation of a 16:16 pointer to far member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR16_FARNVSA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0)
    unsigned short  seg;        // segment of function
};




//  representation of a 16:16 far pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_FARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x)
    unsigned short  seg;
    signed short    disp;
};




//  representation of a 16:16 far pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_FARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x,x,x)
    unsigned short  seg;
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement

};




//  representation of a 32 bit pointer to member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR32_NVSA {
    CV_uoff32_t      off;        // near address of function (NULL = 0L)
};




//  representation of a 32 bit pointer to member function for a
//  class with no virtual bases and multiple address points


struct CV_PMFR32_NVMA {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x)
    CV_off32_t      disp;
};




//  representation of a 32 bit pointer to member function for a
//  class with virtual bases


struct CV_PMFR32_VBASE {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x,x,x)
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
};





//  Easy leaf - used for generic casting to reference leaf field
//  of a subfield of a complex list

typedef struct lfEasy {
    unsigned short  leaf;           // LF_...
} lfEasy;


/**     The following type records are basically variant records of the
 *      above structure.  The "unsigned short leaf" of the above structure and
 *      the "unsigned short leaf" of the following type definitions are the same
 *      symbol.  When the OMF record is locked via the MHOMFLock API
 *      call, the address of the "unsigned short leaf" is returned
 */

/**     Notes on alignment
 *      Alignment of the fields in most of the type records is done on the
 *      basis of the TYPTYPE record base.  That is why in most of the lf*
 *      records that the CV_typ_t (32-bit types) is located on what appears to
 *      be a offset mod 4 == 2 boundary.  The exception to this rule are those
 *      records that are in a list (lfFieldList, lfMethodList), which are
 *      aligned to their own bases since they don't have the length field
 */

/**** Change log for 16-bit to 32-bit type and symbol records

    Record type         Change (f == field arrangement, p = padding added)
    ----------------------------------------------------------------------
    lfModifer           f
    lfPointer           fp
    lfClass             f
    lfStructure         f
    lfUnion             f
    lfEnum              f
    lfVFTPath           p
    lfPreComp           p
    lfOEM               p
    lfArgList           p
    lfDerived           p
    mlMethod            p   (method list member)
    lfBitField          f
    lfDimCon            f
    lfDimVar            p
    lfIndex             p   (field list member)
    lfBClass            f   (field list member)
    lfVBClass           f   (field list member)
    lfFriendCls         p   (field list member)
    lfFriendFcn         p   (field list member)
    lfMember            f   (field list member)
    lfSTMember          f   (field list member)
    lfVFuncTab          p   (field list member)
    lfVFuncOff          p   (field list member)
    lfNestType          p   (field list member)

    DATASYM32           f
    PROCSYM32           f
    VPATHSYM32          f
    REGREL32            f
    THREADSYM32         f
    PROCSYMMIPS         f


*/

//      Type record for LF_MODIFIER

typedef struct lfModifier_16t {
    unsigned short  leaf;           // LF_MODIFIER_16t
    CV_modifier_t   attr;           // modifier attribute modifier_t
    CV_typ16_t      type;           // modified type
} lfModifier_16t;

typedef struct lfModifier {
    unsigned short  leaf;           // LF_MODIFIER
    CV_typ_t        type;           // modified type
    CV_modifier_t   attr;           // modifier attribute modifier_t
} lfModifier;




//      type record for LF_POINTER

#ifndef __cplusplus
typedef struct lfPointer_16t {
#endif
    struct lfPointerBody_16t {
        unsigned short      leaf;           // LF_POINTER_16t
        struct lfPointerAttr_16t {
            unsigned char   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned char   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned char   isflat32    :1; // true if 0:32 pointer
            unsigned char   isvolatile  :1; // TRUE if volatile pointer
            unsigned char   isconst     :1; // TRUE if const pointer
            unsigned char   isunaligned :1; // TRUE if unaligned pointer
            unsigned char   unused      :4;
        } attr;
        CV_typ16_t  utype;          // type index of the underlying type
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer_16t : public lfPointerBody_16t {
#endif
    union {
        struct {
            CV_typ16_t      pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ16_t      index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer_16t;

#ifndef __cplusplus
typedef struct lfPointer {
#endif
    struct lfPointerBody {
        unsigned short      leaf;           // LF_POINTER
        CV_typ_t            utype;          // type index of the underlying type
        struct lfPointerAttr {
            unsigned long   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned long   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned long   isflat32    :1; // true if 0:32 pointer
            unsigned long   isvolatile  :1; // TRUE if volatile pointer
            unsigned long   isconst     :1; // TRUE if const pointer
            unsigned long   isunaligned :1; // TRUE if unaligned pointer
            unsigned long   isrestrict  :1; // TRUE if restricted pointer (allow agressive opts)
            unsigned long   unused      :19;// pad out to 32-bits for following cv_typ_t's
        } attr;
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer : public lfPointerBody {
#endif
    union {
        struct {
            CV_typ_t        pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ_t        index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer;




//      type record for LF_ARRAY


typedef struct lfArray_16t {
    unsigned short  leaf;           // LF_ARRAY_16t
    CV_typ16_t      elemtype;       // type index of element type
    CV_typ16_t      idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray_16t;

typedef struct lfArray {
    unsigned short  leaf;           // LF_ARRAY
    CV_typ_t        elemtype;       // type index of element type
    CV_typ_t        idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray;




//      type record for LF_CLASS, LF_STRUCTURE


typedef struct lfClass_16t {
    unsigned short  leaf;           // LF_CLASS_16t, LF_STRUCT_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ16_t      derived;        // type index of derived from list if not zero
    CV_typ16_t      vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass_16t;
typedef lfClass_16t lfStructure_16t;


typedef struct lfClass {
    unsigned short  leaf;           // LF_CLASS, LF_STRUCT
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_typ_t        derived;        // type index of derived from list if not zero
    CV_typ_t        vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass;
typedef lfClass lfStructure;




//      type record for LF_UNION


typedef struct lfUnion_16t {
    unsigned short  leaf;           // LF_UNION_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion_16t;


typedef struct lfUnion {
    unsigned short  leaf;           // LF_UNION
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion;


//      type record for LF_ALIAS

typedef struct lfAlias {
    unsigned short  leaf;           // LF_ALIAS
    CV_typ_t        utype;          // underlying type
    unsigned char   Name[1];        // alias name
} lfAlias;


//      type record for LF_MANAGED

typedef struct lfManaged {
    unsigned short  leaf;           // LF_MANAGED
    unsigned char   Name[1];        // utf8, zero terminated managed type name
} lfManaged;


//      type record for LF_ENUM


typedef struct lfEnum_16t {
    unsigned short  leaf;           // LF_ENUM_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      utype;          // underlying type of the enum
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum_16t;

typedef struct lfEnum {
    unsigned short  leaf;           // LF_ENUM
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        utype;          // underlying type of the enum
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum;




//      Type record for LF_PROCEDURE


typedef struct lfProc_16t {
    unsigned short  leaf;           // LF_PROCEDURE_16t
    CV_typ16_t      rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
} lfProc_16t;

typedef struct lfProc {
    unsigned short  leaf;           // LF_PROCEDURE
    CV_typ_t        rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
} lfProc;



//      Type record for member function


typedef struct lfMFunc_16t {
    unsigned short  leaf;           // LF_MFUNCTION_16t
    CV_typ16_t      rvtype;         // type index of return value
    CV_typ16_t      classtype;      // type index of containing class
    CV_typ16_t      thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc_16t;

typedef struct lfMFunc {
    unsigned short  leaf;           // LF_MFUNCTION
    CV_typ_t        rvtype;         // type index of return value
    CV_typ_t        classtype;      // type index of containing class
    CV_typ_t        thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc;




//     type record for virtual function table shape


typedef struct lfVTShape {
    unsigned short  leaf;       // LF_VTSHAPE
    unsigned short  count;      // number of entries in vfunctable
    unsigned char   desc[CV_ZEROLEN];     // 4 bit (CV_VTS_desc) descriptors
} lfVTShape;




//      type record for cobol0


typedef struct lfCobol0_16t {
    unsigned short  leaf;       // LF_COBOL0_16t
    CV_typ16_t      type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0_16t;

typedef struct lfCobol0 {
    unsigned short  leaf;       // LF_COBOL0
    CV_typ_t        type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0;




//      type record for cobol1


typedef struct lfCobol1 {
    unsigned short  leaf;       // LF_COBOL1
    unsigned char   data[CV_ZEROLEN];
} lfCobol1;




//      type record for basic array


typedef struct lfBArray_16t {
    unsigned short  leaf;       // LF_BARRAY_16t
    CV_typ16_t      utype;      // type index of underlying type
} lfBArray_16t;

typedef struct lfBArray {
    unsigned short  leaf;       // LF_BARRAY
    CV_typ_t        utype;      // type index of underlying type
} lfBArray;

//      type record for assembler labels


typedef struct lfLabel {
    unsigned short  leaf;       // LF_LABEL
    unsigned short  mode;       // addressing mode of label
} lfLabel;



//      type record for dimensioned arrays


typedef struct lfDimArray_16t {
    unsigned short  leaf;       // LF_DIMARRAY_16t
    CV_typ16_t      utype;      // underlying type of the array
    CV_typ16_t      diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray_16t;

typedef struct lfDimArray {
    unsigned short  leaf;       // LF_DIMARRAY
    CV_typ_t        utype;      // underlying type of the array
    CV_typ_t        diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray;



//      type record describing path to virtual function table


typedef struct lfVFTPath_16t {
    unsigned short  leaf;       // LF_VFTPATH_16t
    unsigned short  count;      // count of number of bases in path
    CV_typ16_t      base[1];    // bases from root to leaf
} lfVFTPath_16t;

typedef struct lfVFTPath {
    unsigned short  leaf;       // LF_VFTPATH
    unsigned long   count;      // count of number of bases in path
    CV_typ_t        base[1];    // bases from root to leaf
} lfVFTPath;


//      type record describing inclusion of precompiled types


typedef struct lfPreComp_16t {
    unsigned short  leaf;       // LF_PRECOMP_16t
    unsigned short  start;      // starting type index included
    unsigned short  count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp_16t;

typedef struct lfPreComp {
    unsigned short  leaf;       // LF_PRECOMP
    unsigned long   start;      // starting type index included
    unsigned long   count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp;



//      type record describing end of precompiled types that can be
//      included by another file


typedef struct lfEndPreComp {
    unsigned short  leaf;       // LF_ENDPRECOMP
    unsigned long   signature;  // signature
} lfEndPreComp;





//      type record for OEM definable type strings


typedef struct lfOEM_16t {
    unsigned short  leaf;       // LF_OEM_16t
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned short  count;      // count of type indices to follow
    CV_typ16_t      index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM_16t;

typedef struct lfOEM {
    unsigned short  leaf;       // LF_OEM
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned long   count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM;

#define OEM_MS_FORTRAN90        0xF090
#define OEM_ODI                 0x0010
#define OEM_THOMSON_SOFTWARE    0x5453
#define OEM_ODI_REC_BASELIST    0x0000

typedef struct lfOEM2 {
    unsigned short  leaf;       // LF_OEM2
    unsigned char   idOem[16];  // an oem ID (GUID)
    unsigned long   count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM2;

//      type record describing using of a type server

typedef struct lfTypeServer {
    unsigned short  leaf;       // LF_TYPESERVER
    unsigned long   signature;  // signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer;

//      type record describing using of a type server with v7 (GUID) signatures

typedef struct lfTypeServer2 {
    unsigned short  leaf;       // LF_TYPESERVER2
    SIG70           sig70;      // guid signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer2;

//      description of type records that can be referenced from
//      type records referenced by symbols



//      type record for skip record


typedef struct lfSkip_16t {
    unsigned short  leaf;       // LF_SKIP_16t
    CV_typ16_t      type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip_16t;

typedef struct lfSkip {
    unsigned short  leaf;       // LF_SKIP
    CV_typ_t        type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip;



//      argument list leaf


typedef struct lfArgList_16t {
    unsigned short  leaf;           // LF_ARGLIST_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      arg[CV_ZEROLEN];      // number of arguments
} lfArgList_16t;

typedef struct lfArgList {
    unsigned short  leaf;           // LF_ARGLIST
    unsigned long   count;          // number of arguments
    CV_typ_t        arg[CV_ZEROLEN];      // number of arguments
} lfArgList;




//      derived class list leaf


typedef struct lfDerived_16t {
    unsigned short  leaf;           // LF_DERIVED_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived_16t;

typedef struct lfDerived {
    unsigned short  leaf;           // LF_DERIVED
    unsigned long   count;          // number of arguments
    CV_typ_t        drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived;




//      leaf for default arguments


typedef struct lfDefArg_16t {
    unsigned short  leaf;               // LF_DEFARG_16t
    CV_typ16_t      type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg_16t;

typedef struct lfDefArg {
    unsigned short  leaf;               // LF_DEFARG
    CV_typ_t        type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg;



//      list leaf
//          This list should no longer be used because the utilities cannot
//          verify the contents of the list without knowing what type of list
//          it is.  New specific leaf indices should be used instead.


typedef struct lfList {
    unsigned short  leaf;           // LF_LIST
    char            data[CV_ZEROLEN];         // data format specified by indexing type
} lfList;




//      field list leaf
//      This is the header leaf for a complex list of class and structure
//      subfields.


typedef struct lfFieldList_16t {
    unsigned short  leaf;           // LF_FIELDLIST_16t
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList_16t;


typedef struct lfFieldList {
    unsigned short  leaf;           // LF_FIELDLIST
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList;







//  type record for non-static methods and friends in overloaded method list

typedef struct mlMethod_16t {
    CV_fldattr_t   attr;           // method attribute
    CV_typ16_t     index;          // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod_16t;

typedef struct mlMethod {
    CV_fldattr_t    attr;           // method attribute
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record for procedure
    unsigned long   vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod;


typedef struct lfMethodList_16t {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod_16t type
} lfMethodList_16t;

typedef struct lfMethodList {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod type
} lfMethodList;





//      type record for LF_BITFIELD


typedef struct lfBitfield_16t {
    unsigned short  leaf;           // LF_BITFIELD_16t
    unsigned char   length;
    unsigned char   position;
    CV_typ16_t      type;           // type of bitfield

} lfBitfield_16t;

typedef struct lfBitfield {
    unsigned short  leaf;           // LF_BITFIELD
    CV_typ_t        type;           // type of bitfield
    unsigned char   length;
    unsigned char   position;

} lfBitfield;




//      type record for dimensioned array with constant bounds


typedef struct lfDimCon_16t {
    unsigned short  leaf;           // LF_DIMCONU_16t or LF_DIMCONLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon_16t;

typedef struct lfDimCon {
    unsigned short  leaf;           // LF_DIMCONU or LF_DIMCONLU
    CV_typ_t        typ;            // type of index
    unsigned short  rank;           // number of dimensions
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon;




//      type record for dimensioned array with variable bounds


typedef struct lfDimVar_16t {
    unsigned short  leaf;           // LF_DIMVARU_16t or LF_DIMVARLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    CV_typ16_t      dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The referenced
                                    // types must be LF_REFSYM or T_VOID
} lfDimVar_16t;

typedef struct lfDimVar {
    unsigned short  leaf;           // LF_DIMVARU or LF_DIMVARLU
    unsigned long   rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    CV_typ_t        dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The count of type
                                    // indices is rank or rank*2 depending on
                                    // whether it is LFDIMVARU or LF_DIMVARLU.
                                    // The referenced types must be
                                    // LF_REFSYM or T_VOID
} lfDimVar;




//      type record for referenced symbol


typedef struct lfRefSym {
    unsigned short  leaf;           // LF_REFSYM
    unsigned char   Sym[1];         // copy of referenced symbol record
                                    // (including length)
} lfRefSym;





/**     the following are numeric leaves.  They are used to indicate the
 *      size of the following variable length data.  When the numeric
 *      data is a single byte less than 0x8000, then the data is output
 *      directly.  If the data is more the 0x8000 or is a negative value,
 *      then the data is preceeded by the proper index.
 */



//      signed character leaf

typedef struct lfChar {
    unsigned short  leaf;           // LF_CHAR
    signed char     val;            // signed 8-bit value
} lfChar;




//      signed short leaf

typedef struct lfShort {
    unsigned short  leaf;           // LF_SHORT
    short           val;            // signed 16-bit value
} lfShort;




//      unsigned short leaf

typedef struct lfUShort {
    unsigned short  leaf;           // LF_unsigned short
    unsigned short  val;            // unsigned 16-bit value
} lfUShort;




//      signed long leaf

typedef struct lfLong {
    unsigned short  leaf;           // LF_LONG
    long            val;            // signed 32-bit value
} lfLong;




//      unsigned long leaf

typedef struct lfULong {
    unsigned short  leaf;           // LF_ULONG
    unsigned long   val;            // unsigned 32-bit value
} lfULong;




//      signed quad leaf

typedef struct lfQuad {
    unsigned short  leaf;           // LF_QUAD
    unsigned char   val[8];         // signed 64-bit value
} lfQuad;




//      unsigned quad leaf

typedef struct lfUQuad {
    unsigned short  leaf;           // LF_UQUAD
    unsigned char   val[8];         // unsigned 64-bit value
} lfUQuad;


//      signed int128 leaf

typedef struct lfOct {
    unsigned short  leaf;           // LF_OCT
    unsigned char   val[16];        // signed 128-bit value
} lfOct;

//      unsigned int128 leaf

typedef struct lfUOct {
    unsigned short  leaf;           // LF_UOCT
    unsigned char   val[16];        // unsigned 128-bit value
} lfUOct;




//      real 32-bit leaf

typedef struct lfReal32 {
    unsigned short  leaf;           // LF_REAL32
    float           val;            // 32-bit real value
} lfReal32;




//      real 48-bit leaf

typedef struct lfReal48 {
    unsigned short  leaf;           // LF_REAL48
    unsigned char   val[6];         // 48-bit real value
} lfReal48;




//      real 64-bit leaf

typedef struct lfReal64 {
    unsigned short  leaf;           // LF_REAL64
    double          val;            // 64-bit real value
} lfReal64;




//      real 80-bit leaf

typedef struct lfReal80 {
    unsigned short  leaf;           // LF_REAL80
    FLOAT10         val;            // real 80-bit value
} lfReal80;




//      real 128-bit leaf

typedef struct lfReal128 {
    unsigned short  leaf;           // LF_REAL128
    char            val[16];        // real 128-bit value
} lfReal128;




//      complex 32-bit leaf

typedef struct lfCmplx32 {
    unsigned short  leaf;           // LF_COMPLEX32
    float           val_real;       // real component
    float           val_imag;       // imaginary component
} lfCmplx32;




//      complex 64-bit leaf

typedef struct lfCmplx64 {
    unsigned short  leaf;           // LF_COMPLEX64
    double          val_real;       // real component
    double          val_imag;       // imaginary component
} flCmplx64;




//      complex 80-bit leaf

typedef struct lfCmplx80 {
    unsigned short  leaf;           // LF_COMPLEX80
    FLOAT10         val_real;       // real component
    FLOAT10         val_imag;       // imaginary component
} lfCmplx80;




//      complex 128-bit leaf

typedef struct lfCmplx128 {
    unsigned short  leaf;           // LF_COMPLEX128
    char            val_real[16];   // real component
    char            val_imag[16];   // imaginary component
} lfCmplx128;



//  variable length numeric field

typedef struct lfVarString {
    unsigned short  leaf;       // LF_VARSTRING
    unsigned short  len;        // length of value in bytes
    unsigned char   value[CV_ZEROLEN];  // value
} lfVarString;

//***********************************************************************


//      index leaf - contains type index of another leaf
//      a major use of this leaf is to allow the compilers to emit a
//      long complex list (LF_FIELD) in smaller pieces.

typedef struct lfIndex_16t {
    unsigned short  leaf;           // LF_INDEX_16t
    CV_typ16_t      index;          // type index of referenced leaf
} lfIndex_16t;

typedef struct lfIndex {
    unsigned short  leaf;           // LF_INDEX
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // type index of referenced leaf
} lfIndex;


//      subfield record for base class field

typedef struct lfBClass_16t {
    unsigned short  leaf;           // LF_BCLASS_16t
    CV_typ16_t      index;          // type index of base class
    CV_fldattr_t    attr;           // attribute
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass_16t;

typedef struct lfBClass {
    unsigned short  leaf;           // LF_BCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of base class
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass;





//      subfield record for direct and indirect virtual base class field

typedef struct lfVBClass_16t {
    unsigned short  leaf;           // LF_VBCLASS_16t | LV_IVBCLASS_16t
    CV_typ16_t      index;          // type index of direct virtual base class
    CV_typ16_t      vbptr;          // type index of virtual base pointer
    CV_fldattr_t    attr;           // attribute
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass_16t;

typedef struct lfVBClass {
    unsigned short  leaf;           // LF_VBCLASS | LV_IVBCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of direct virtual base class
    CV_typ_t        vbptr;          // type index of virtual base pointer
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass;





//      subfield record for friend class


typedef struct lfFriendCls_16t {
    unsigned short  leaf;           // LF_FRIENDCLS_16t
    CV_typ16_t      index;          // index to type record of friend class
} lfFriendCls_16t;

typedef struct lfFriendCls {
    unsigned short  leaf;           // LF_FRIENDCLS
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend class
} lfFriendCls;





//      subfield record for friend function


typedef struct lfFriendFcn_16t {
    unsigned short  leaf;           // LF_FRIENDFCN_16t
    CV_typ16_t      index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn_16t;

typedef struct lfFriendFcn {
    unsigned short  leaf;           // LF_FRIENDFCN
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn;



//      subfield record for non-static data members

typedef struct lfMember_16t {
    unsigned short  leaf;           // LF_MEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember_16t;

typedef struct lfMember {
    unsigned short  leaf;           // LF_MEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember;



//  type record for static data members

typedef struct lfSTMember_16t {
    unsigned short  leaf;           // LF_STMEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember_16t;

typedef struct lfSTMember {
    unsigned short  leaf;           // LF_STMEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember;



//      subfield record for virtual function table pointer

typedef struct lfVFuncTab_16t {
    unsigned short  leaf;           // LF_VFUNCTAB_16t
    CV_typ16_t      type;           // type index of pointer
} lfVFuncTab_16t;

typedef struct lfVFuncTab {
    unsigned short  leaf;           // LF_VFUNCTAB
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        type;           // type index of pointer
} lfVFuncTab;



//      subfield record for virtual function table pointer with offset

typedef struct lfVFuncOff_16t {
    unsigned short  leaf;           // LF_VFUNCOFF_16t
    CV_typ16_t      type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff_16t;

typedef struct lfVFuncOff {
    unsigned short  leaf;           // LF_VFUNCOFF
    _2BYTEPAD       pad0;           // internal padding, must be 0.
    CV_typ_t        type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff;



//      subfield record for overloaded method list


typedef struct lfMethod_16t {
    unsigned short  leaf;           // LF_METHOD_16t
    unsigned short  count;          // number of occurrences of function
    CV_typ16_t      mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod_16t;

typedef struct lfMethod {
    unsigned short  leaf;           // LF_METHOD
    unsigned short  count;          // number of occurrences of function
    CV_typ_t        mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod;



//      subfield record for nonoverloaded method


typedef struct lfOneMethod_16t {
    unsigned short leaf;            // LF_ONEMETHOD_16t
    CV_fldattr_t   attr;            // method attribute
    CV_typ16_t     index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod_16t;

typedef struct lfOneMethod {
    unsigned short leaf;            // LF_ONEMETHOD
    CV_fldattr_t   attr;            // method attribute
    CV_typ_t       index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod;


//      subfield record for enumerate

typedef struct lfEnumerate {
    unsigned short  leaf;       // LF_ENUMERATE
    CV_fldattr_t    attr;       // access
    unsigned char   value[CV_ZEROLEN];    // variable length value field followed
                                // by length prefixed name
} lfEnumerate;


//  type record for nested (scoped) type definition

typedef struct lfNestType_16t {
    unsigned short  leaf;       // LF_NESTTYPE_16t
    CV_typ16_t      index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType_16t;

typedef struct lfNestType {
    unsigned short  leaf;       // LF_NESTTYPE
    _2BYTEPAD       pad0;       // internal padding, must be 0
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType;

//  type record for nested (scoped) type definition, with attributes
//  new records for vC v5.0, no need to have 16-bit ti versions.

typedef struct lfNestTypeEx {
    unsigned short  leaf;       // LF_NESTTYPEEX
    CV_fldattr_t    attr;       // member access
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestTypeEx;

//  type record for modifications to members

typedef struct lfMemberModify {
    unsigned short  leaf;       // LF_MEMBERMODIFY
    CV_fldattr_t    attr;       // the new attributes
    CV_typ_t        index;      // index of base class type definition
    unsigned char   Name[1];    // length prefixed member name
} lfMemberModify;

//  type record for pad leaf

typedef struct lfPad {
    unsigned char   leaf;
} SYM_PAD;



//  Symbol definitions

typedef enum SYM_ENUM_e {
    S_COMPILE       =  0x0001, // Compile flags symbol
    S_REGISTER_16t  =  0x0002, // Register variable
    S_CONSTANT_16t  =  0x0003, // constant symbol
    S_UDT_16t       =  0x0004, // User defined type
    S_SSEARCH       =  0x0005, // Start Search
    S_END           =  0x0006, // Block, procedure, "with" or thunk end
    S_SKIP          =  0x0007, // Reserve symbol space in $$Symbols table
    S_CVRESERVE     =  0x0008, // Reserved symbol for CV internal use
#ifdef LNGNM
    S_OBJNAME_ST    =  0x0009, // path to object file name
#else
    S_OBJNAME       =  0x0009, // path to object file name
#endif
    S_ENDARG        =  0x000a, // end of argument/return list
    S_COBOLUDT_16t  =  0x000b, // special UDT for cobol that does not symbol pack
    S_MANYREG_16t   =  0x000c, // multiple register variable
    S_RETURN        =  0x000d, // return description symbol
    S_ENTRYTHIS     =  0x000e, // description of this pointer on entry

    S_BPREL16       =  0x0100, // BP-relative
    S_LDATA16       =  0x0101, // Module-local symbol
    S_GDATA16       =  0x0102, // Global data symbol
    S_PUB16         =  0x0103, // a public symbol
    S_LPROC16       =  0x0104, // Local procedure start
    S_GPROC16       =  0x0105, // Global procedure start
    S_THUNK16       =  0x0106, // Thunk Start
    S_BLOCK16       =  0x0107, // block start
    S_WITH16        =  0x0108, // with start
    S_LABEL16       =  0x0109, // code label
    S_CEXMODEL16    =  0x010a, // change execution model
    S_VFTABLE16     =  0x010b, // address of virtual function table
    S_REGREL16      =  0x010c, // register relative address

    S_BPREL32_16t   =  0x0200, // BP-relative
    S_LDATA32_16t   =  0x0201, // Module-local symbol
    S_GDATA32_16t   =  0x0202, // Global data symbol
    S_PUB32_16t     =  0x0203, // a public symbol (CV internal reserved)
    S_LPROC32_16t   =  0x0204, // Local procedure start
    S_GPROC32_16t   =  0x0205, // Global procedure start
#ifdef LNGNM
    S_THUNK32_ST    =  0x0206, // Thunk Start
    S_BLOCK32_ST    =  0x0207, // block start
    S_WITH32_ST     =  0x0208, // with start
    S_LABEL32_ST    =  0x0209, // code label
#else
    S_THUNK32       =  0x0206, // Thunk Start
    S_BLOCK32       =  0x0207, // block start
    S_WITH32        =  0x0208, // with start
    S_LABEL32       =  0x0209, // code label
#endif
    S_CEXMODEL32    =  0x020a, // change execution model
    S_VFTABLE32_16t =  0x020b, // address of virtual function table
    S_REGREL32_16t  =  0x020c, // register relative address
    S_LTHREAD32_16t =  0x020d, // local thread storage
    S_GTHREAD32_16t =  0x020e, // global thread storage
    S_SLINK32       =  0x020f, // static link for MIPS EH implementation

    S_LPROCMIPS_16t =  0x0300, // Local procedure start
    S_GPROCMIPS_16t =  0x0301, // Global procedure start

#ifdef LNGNM
    // if these ref symbols have names following then the names are in ST format
    S_PROCREF_ST    =  0x0400, // Reference to a procedure
    S_DATAREF_ST    =  0x0401, // Reference to data
#else
    S_PROCREF       =  0x0400, // Reference to a procedure
    S_DATAREF       =  0x0401, // Reference to data
#endif
    S_ALIGN         =  0x0402, // Used for page alignment of symbols

#ifdef LNGNM
    S_LPROCREF_ST   =  0x0403, // Local Reference to a procedure
#else
    S_LPROCREF      =  0x0403, // Local Reference to a procedure
#endif
    S_OEM           =  0x0404, // OEM defined symbol

    // sym records with 32-bit types embedded instead of 16-bit
    // all have 0x1000 bit set for easy identification
    // only do the 32-bit target versions since we don't really
    // care about 16-bit ones anymore.
    S_TI16_MAX          =  0x1000,
#ifndef LNGNM
    S_REGISTER      =  0x1001, // Register variable
    S_CONSTANT      =  0x1002, // constant symbol
    S_UDT           =  0x1003, // User defined type
    S_COBOLUDT      =  0x1004, // special UDT for cobol that does not symbol pack
    S_MANYREG       =  0x1005, // multiple register variable
    S_BPREL32       =  0x1006, // BP-relative
    S_LDATA32       =  0x1007, // Module-local symbol
    S_GDATA32       =  0x1008, // Global data symbol
    S_PUB32         =  0x1009, // a public symbol (CV internal reserved)
    S_LPROC32       =  0x100a, // Local procedure start
    S_GPROC32       =  0x100b, // Global procedure start
    S_VFTABLE32     =  0x100c, // address of virtual function table
    S_REGREL32      =  0x100d, // register relative address
    S_LTHREAD32     =  0x100e, // local thread storage
    S_GTHREAD32     =  0x100f, // global thread storage

    S_LPROCMIPS     =  0x1010, // Local procedure start
    S_GPROCMIPS     =  0x1011, // Global procedure start

    // new symbol records for edit and continue information

    S_FRAMEPROC     =  0x1012, // extra frame and proc information
    S_COMPILE2      =  0x1013, // extended compile flags and info

    // new symbols necessary for 16-bit enumerates of IA64 registers
    // and IA64 specific symbols

    S_MANYREG2      =  0x1014, // multiple register variable
    S_LPROCIA64     =  0x1015, // Local procedure start (IA64)
    S_GPROCIA64     =  0x1016, // Global procedure start (IA64)

    // Local symbols for IL
    S_LOCALSLOT     = 0x1017,  // local IL sym with field for local slot index
    S_SLOT          = S_LOCALSLOT,  // alias for LOCALSLOT
    S_PARAMSLOT     = 0x1018,  // local IL sym with field for parameter slot index

    S_ANNOTATION    =  0x1019, // Annotation string literals

    // symbols to support managed code debugging
    S_GMANPROC      =  0x101a,  // Global proc
    S_LMANPROC      =  0x101b,  // Local proc
    S_RESERVED1     =  0x101c,  // reserved
    S_RESERVED2     =  0x101d,  // reserved
    S_RESERVED3     =  0x101e,  // reserved
    S_RESERVED4     =  0x101f,  // reserved
    S_LMANDATA      =  0x1020,  // Static data
    S_GMANDATA      =  0x1021,  // Global data
    S_MANFRAMEREL   =  0x1022,  // Frame relative local var or param
    S_MANREGISTER   =  0x1023,  // Register local var or param
    S_MANSLOT       =  0x1024,  // Slot local var or param
    S_MANMANYREG    =  0x1025,  // Multiple register local var or param
    S_MANREGREL     =  0x1026,  // Register relative local var or param
    S_MANMANYREG2   =  0x1027,  // Multiple register local var or param
    S_MANTYPREF     =  0x1028,  // Index for type referenced by name from metadata
    S_UNAMESPACE    =  0x1029,  // Using namespace

    S_NOLNGNAMEMAX,
    S_NOLNGNAMELAST = S_NOLNGNAMEMAX - 1,

    // Keep the long name and non-long name versions of S_ANNOTATIONREF
    // and S_TOKENREF the same
    //
    S_ANNOTATIONREF =  0x1128,  // Reference to S_ANNOTATION symbol

#else
    S_REGISTER_ST   =  0x1001, // Register variable
    S_CONSTANT_ST   =  0x1002, // constant symbol
    S_UDT_ST        =  0x1003, // User defined type
    S_COBOLUDT_ST   =  0x1004, // special UDT for cobol that does not symbol pack
    S_MANYREG_ST    =  0x1005, // multiple register variable
    S_BPREL32_ST    =  0x1006, // BP-relative
    S_LDATA32_ST    =  0x1007, // Module-local symbol
    S_GDATA32_ST    =  0x1008, // Global data symbol
    S_PUB32_ST      =  0x1009, // a public symbol (CV internal reserved)
    S_LPROC32_ST    =  0x100a, // Local procedure start
    S_GPROC32_ST    =  0x100b, // Global procedure start
    S_VFTABLE32     =  0x100c, // address of virtual function table
    S_REGREL32_ST   =  0x100d, // register relative address
    S_LTHREAD32_ST  =  0x100e, // local thread storage
    S_GTHREAD32_ST  =  0x100f, // global thread storage

    S_LPROCMIPS_ST  =  0x1010, // Local procedure start
    S_GPROCMIPS_ST  =  0x1011, // Global procedure start

    // new symbol records for edit and continue information

    S_FRAMEPROC     =  0x1012, // extra frame and proc information
    S_COMPILE2_ST   =  0x1013, // extended compile flags and info

    // new symbols necessary for 16-bit enumerates of IA64 registers
    // and IA64 specific symbols

    S_MANYREG2_ST   =  0x1014, // multiple register variable
    S_LPROCIA64_ST  =  0x1015, // Local procedure start (IA64)
    S_GPROCIA64_ST  =  0x1016, // Global procedure start (IA64)

    // Local symbols for IL
    S_LOCALSLOT_ST  = 0x1017,  // local IL sym with field for local slot index
    S_PARAMSLOT_ST  = 0x1018,  // local IL sym with field for parameter slot index

    S_ANNOTATION    =  0x1019, // Annotation string literals

    // symbols to support managed code debugging
    S_GMANPROC_ST   =  0x101a,  // Global proc
    S_LMANPROC_ST   =  0x101b,  // Local proc
    S_RESERVED1     =  0x101c,  // reserved
    S_RESERVED2     =  0x101d,  // reserved
    S_RESERVED3     =  0x101e,  // reserved
    S_RESERVED4     =  0x101f,  // reserved
    S_LMANDATA_ST   =  0x1020,
    S_GMANDATA_ST   =  0x1021,
    S_MANFRAMEREL_ST=  0x1022,
    S_MANREGISTER_ST=  0x1023,
    S_MANSLOT_ST    =  0x1024,
    S_MANMANYREG_ST =  0x1025,
    S_MANREGREL_ST  =  0x1026,
    S_MANMANYREG2_ST=  0x1027,
    S_MANTYPREF     =  0x1028,  // Index for type referenced by name from metadata
    S_UNAMESPACE_ST =  0x1029,  // Using namespace

    // Symbols w/ SZ name fields. All name fields contain utf8 encoded strings.
    S_ST_MAX        =  0x1100,  // starting point for SZ name symbols

    S_OBJNAME       =  0x1101, // path to object file name
    S_THUNK32       =  0x1102, // Thunk Start
    S_BLOCK32       =  0x1103, // block start
    S_WITH32        =  0x1104, // with start
    S_LABEL32       =  0x1105, // code label
    S_REGISTER      =  0x1106, // Register variable
    S_CONSTANT      =  0x1107, // constant symbol
    S_UDT           =  0x1108, // User defined type
    S_COBOLUDT      =  0x1109, // special UDT for cobol that does not symbol pack
    S_MANYREG       =  0x110a, // multiple register variable
    S_BPREL32       =  0x110b, // BP-relative
    S_LDATA32       =  0x110c, // Module-local symbol
    S_GDATA32       =  0x110d, // Global data symbol
    S_PUB32         =  0x110e, // a public symbol (CV internal reserved)
    S_LPROC32       =  0x110f, // Local procedure start
    S_GPROC32       =  0x1110, // Global procedure start
    S_REGREL32      =  0x1111, // register relative address
    S_LTHREAD32     =  0x1112, // local thread storage
    S_GTHREAD32     =  0x1113, // global thread storage

    S_LPROCMIPS     =  0x1114, // Local procedure start
    S_GPROCMIPS     =  0x1115, // Global procedure start
    S_COMPILE2      =  0x1116, // extended compile flags and info
    S_MANYREG2      =  0x1117, // multiple register variable
    S_LPROCIA64     =  0x1118, // Local procedure start (IA64)
    S_GPROCIA64     =  0x1119, // Global procedure start (IA64)
    S_LOCALSLOT     =  0x111a, // local IL sym with field for local slot index
    S_SLOT          = S_LOCALSLOT,  // alias for LOCALSLOT
    S_PARAMSLOT     =  0x111b, // local IL sym with field for parameter slot index

    // symbols to support managed code debugging
    S_LMANDATA      =  0x111c,
    S_GMANDATA      =  0x111d,
    S_MANFRAMEREL   =  0x111e,
    S_MANREGISTER   =  0x111f,
    S_MANSLOT       =  0x1120,
    S_MANMANYREG    =  0x1121,
    S_MANREGREL     =  0x1122,
    S_MANMANYREG2   =  0x1123,
    S_UNAMESPACE    =  0x1124,  // Using namespace

    // ref symbols with name fields
    S_PROCREF       =  0x1125, // Reference to a procedure
    S_DATAREF       =  0x1126, // Reference to data
    S_LPROCREF      =  0x1127, // Local Reference to a procedure
    S_ANNOTATIONREF =  0x1128,  // Reference to an S_ANNOTATION symbol
    S_TOKENREF      =  0x1129,  // Reference to one of the many MANPROCSYM's

    // continuation of managed symbols
    S_GMANPROC      =  0x112a,  // Global proc
    S_LMANPROC      =  0x112b,  // Local proc

    // short, light-weight thunks
    S_TRAMPOLINE    =  0x112c,  // trampoline thunks
    S_MANCONSTANT   =  0x112d,  // constants with metadata type info
#endif

    S_RECTYPE_MAX,             // one greater than last
    S_RECTYPE_LAST  = S_RECTYPE_MAX - 1,

} SYM_ENUM_e;






//  enum describing compile flag ambient data model


typedef enum CV_CFL_DATA {
    CV_CFL_DNEAR    = 0x00,
    CV_CFL_DFAR     = 0x01,
    CV_CFL_DHUGE    = 0x02
} CV_CFL_DATA;




//  enum describing compile flag ambiant code model


typedef enum CV_CFL_CODE_e {
    CV_CFL_CNEAR    = 0x00,
    CV_CFL_CFAR     = 0x01,
    CV_CFL_CHUGE    = 0x02
} CV_CFL_CODE_e;




//  enum describing compile flag target floating point package

typedef enum CV_CFL_FPKG_e {
    CV_CFL_NDP      = 0x00,
    CV_CFL_EMU      = 0x01,
    CV_CFL_ALT      = 0x02
} CV_CFL_FPKG_e;


// enum describing function return method


typedef struct CV_PROCFLAGS {
    union {
        unsigned char   bAll;
        unsigned char   grfAll;
        struct {
            unsigned char CV_PFLAG_NOFPO     :1; // frame pointer present
            unsigned char CV_PFLAG_INT       :1; // interrupt return
            unsigned char CV_PFLAG_FAR       :1; // far return
            unsigned char CV_PFLAG_NEVER     :1; // function does not return
            unsigned char CV_PFLAG_NOTREACHED:1; // label isn't fallen into
            unsigned char CV_PFLAG_CUST_CALL :1; // custom calling convention
            unsigned char CV_PFLAG_NOINLINE  :1; // function marked as noinline
            unsigned char unused             :1; //
        };
    };
} CV_PROCFLAGS;

// Extended proc flags
//
typedef struct CV_EXPROCFLAGS {
    CV_PROCFLAGS cvpf;
    union {
        unsigned char   grfAll;
        struct {
            unsigned char   __reserved      :8; // must be zero
        };
    };
} CV_EXPROCFLAGS;

// local variable flags
typedef struct CV_LVARFLAGS {
    unsigned short fIsParam          :1; // variable is a parameter
    unsigned short fAddrTaken        :1; // address is taken
    unsigned short fCompGenx         :1; // variable is compiler generated
    unsigned short unused            :13;// must be zero
} CV_LVARFLAGS;

// extended attributes common to all local variables
typedef struct CV_lvar_attr {
    CV_uoff32_t     off;        // first code address where var is live
    unsigned short  seg;
    CV_LVARFLAGS    flags;      // local var flags
} CV_lvar_attr;

// enum describing function data return method

typedef enum CV_GENERIC_STYLE_e {
    CV_GENERIC_VOID   = 0x00,       // void return type
    CV_GENERIC_REG    = 0x01,       // return data is in registers
    CV_GENERIC_ICAN   = 0x02,       // indirect caller allocated near
    CV_GENERIC_ICAF   = 0x03,       // indirect caller allocated far
    CV_GENERIC_IRAN   = 0x04,       // indirect returnee allocated near
    CV_GENERIC_IRAF   = 0x05,       // indirect returnee allocated far
    CV_GENERIC_UNUSED = 0x06        // first unused
} CV_GENERIC_STYLE_e;


typedef struct CV_GENERIC_FLAG {
    unsigned short  cstyle  :1;     // true push varargs right to left
    unsigned short  rsclean :1;     // true if returnee stack cleanup
    unsigned short  unused  :14;    // unused
} CV_GENERIC_FLAG;





typedef struct SYMTYPE {
    unsigned short      reclen;     // Record length
    unsigned short      rectyp;     // Record type
    char                data[CV_ZEROLEN];
} SYMTYPE;

__INLINE SYMTYPE *NextSym (SYMTYPE * pSym) {
    return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(unsigned short));
}

//      non-model specific symbol types



typedef struct REGSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER_16t
    CV_typ16_t      typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM_16t;

typedef struct REGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER
    CV_typ_t        typind;     // Type index or Metadata token
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM;

typedef struct ATTRREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANREGISTER
    CV_typ_t        typind;     // Type index or Metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} ATTRREGSYM;

typedef struct MANYREGSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG_16t
    CV_typ16_t      typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM_16t;

typedef struct MANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG
    CV_typ_t        typind;     // Type index or metadata token
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM;

typedef struct MANYREGSYM2 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG2
    CV_typ_t        typind;     // Type index or metadata token
    unsigned short  count;      // count of number of registers
    unsigned short  reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM2;

typedef struct ATTRMANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANMANYREG
    CV_typ_t        typind;     // Type index or metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} ATTRMANYREGSYM;

typedef struct ATTRMANYREGSYM2 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANMANYREG2
    CV_typ_t        typind;     // Type index or metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned short  count;      // count of number of registers
    unsigned short  reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} ATTRMANYREGSYM2;

typedef struct CONSTSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT_16t
    CV_typ16_t      typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM_16t;

typedef struct CONSTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT or S_MANCONSTANT
    CV_typ_t        typind;     // Type index (containing enum if enumerate) or metadata token
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM;


typedef struct UDTSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT_16t | S_COBOLUDT_16t
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM_16t;


typedef struct UDTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT | S_COBOLUDT
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM;

typedef struct MANTYPREF {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANTYPREF
    CV_typ_t        typind;     // Type index
} MANTYPREF;

typedef struct SEARCHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_SSEARCH
    unsigned long   startsym;   // offset of the procedure
    unsigned short  seg;        // segment of symbol
} SEARCHSYM;


typedef struct CFLAGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE
    unsigned char   machine;    // target processor
    struct  {
        unsigned char   language    :8; // language index
        unsigned char   pcode       :1; // true if pcode present
        unsigned char   floatprec   :2; // floating precision
        unsigned char   floatpkg    :2; // float package
        unsigned char   ambdata     :3; // ambient data model
        unsigned char   ambcode     :3; // ambient code model
        unsigned char   mode32      :1; // true if compiled 32 bit mode
        unsigned char   pad         :4; // reserved
    } flags;
    unsigned char       ver[1];     // Length-prefixed compiler version string
} CFLAGSYM;


typedef struct COMPILESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE2
    struct {
        unsigned long   iLanguage       :  8;   // language index
        unsigned long   fEC             :  1;   // compiled for E/C
        unsigned long   fNoDbgInfo      :  1;   // not compiled with debug info
        unsigned long   fLTCG           :  1;   // compiled with LTCG
        unsigned long   fNoDataAlign    :  1;   // compiled with -Bzalign
        unsigned long   fManagedPresent :  1;   // managed code/data present
        unsigned long   pad             : 19;   // reserved, must be 0
    } flags;
    unsigned short  machine;    // target processor
    unsigned short  verFEMajor; // front end major version #
    unsigned short  verFEMinor; // front end minor version #
    unsigned short  verFEBuild; // front end build version #
    unsigned short  verMajor;   // back end major version #
    unsigned short  verMinor;   // back end minor version #
    unsigned short  verBuild;   // back end build version #
    unsigned char   verSt[1];   // Length-prefixed compiler version string, followed
                                //  by an optional block of zero terminated strings
                                //  terminated with a double zero.
} COMPILESYM;


typedef struct OBJNAMESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OBJNAME
    unsigned long   signature;  // signature
    unsigned char   name[1];    // Length-prefixed name
} OBJNAMESYM;


typedef struct ENDARGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENDARG
} ENDARGSYM;


typedef struct RETURNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_RETURN
    CV_GENERIC_FLAG flags;      // flags
    unsigned char   style;      // CV_GENERIC_STYLE_e return style
                                // followed by return method data
} RETURNSYM;


typedef struct ENTRYTHISSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENTRYTHIS
    unsigned char   thissym;    // symbol describing this pointer on entry
} ENTRYTHISSYM;


//      symbol types for 16:16 memory model


typedef struct BPRELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL16
    CV_off16_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM16;


typedef struct DATASYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA or S_GDATA
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM16;
typedef DATASYM16 PUBSYM16;


typedef struct PROCSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned short  len;        // Proc length
    unsigned short  DbgStart;   // Debug start offset
    unsigned short  DbgEnd;     // Debug end offset
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM16;


typedef struct THUNKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // THUNK_ORDINAL specifying type of thunk
    unsigned char   name[1];    // name of thunk
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM16;

typedef struct LABELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM16;


typedef struct BLOCKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM16;


typedef struct WITHSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   expr[1];    // Length-prefixed expression
} WITHSYM16;


typedef enum CEXM_MODEL_e {
    CEXM_MDL_table          = 0x00, // not executable
    CEXM_MDL_jumptable      = 0x01, // Compiler generated jump table
    CEXM_MDL_datapad        = 0x02, // Data padding for alignment
    CEXM_MDL_native         = 0x20, // native (actually not-pcode)
    CEXM_MDL_cobol          = 0x21, // cobol
    CEXM_MDL_codepad        = 0x22, // Code padding for alignment
    CEXM_MDL_code           = 0x23, // code
    CEXM_MDL_sql            = 0x30, // sql
    CEXM_MDL_pcode          = 0x40, // pcode
    CEXM_MDL_pcode32Mac     = 0x41, // macintosh 32 bit pcode
    CEXM_MDL_pcode32MacNep  = 0x42, // macintosh 32 bit pcode native entry point
    CEXM_MDL_javaInt        = 0x50,
    CEXM_MDL_unknown        = 0xff
} CEXM_MODEL_e;

// use the correct enumerate name
#define CEXM_MDL_SQL CEXM_MDL_sql

typedef enum CV_COBOL_e {
    CV_COBOL_dontstop,
    CV_COBOL_pfm,
    CV_COBOL_false,
    CV_COBOL_extcall
} CV_COBOL_e;

typedef struct CEXMSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union {
        struct  {
            CV_uoff16_t pcdtable;   // offset to pcode function table
            CV_uoff16_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
    };
} CEXMSYM16;


typedef struct VPATHSYM16 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH16
    CV_uoff16_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM16;


typedef struct REGREL16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  reg;        // register index
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL16;


typedef struct BPRELSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32_16t
    CV_off32_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32_16t;

typedef struct BPRELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32
    CV_off32_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index or Metadata token
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32;

typedef struct FRAMERELSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANFRAMEREL
    CV_off32_t      off;        // Frame relative offset
    CV_typ_t        typind;     // Type index or Metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned char   name[1];    // Length-prefixed name
} FRAMERELSYM;

typedef struct SLOTSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LOCALSLOT or S_PARAMSLOT
    unsigned long   iSlot;      // slot index
    CV_typ_t        typind;     // Type index or Metadata token
    unsigned char   name[1];    // Length-prefixed name
} SLOTSYM32;

typedef struct ATTRSLOTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANSLOT
    unsigned long   iSlot;      // slot index
    CV_typ_t        typind;     // Type index or Metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned char   name[1];    // Length-prefixed name
} ATTRSLOTSYM;

typedef struct ANNOTATIONSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ANNOTATION
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  csz;        // Count of zero terminated annotation strings
    unsigned char   rgsz[1];    // Sequence of zero terminated annotation strings
} ANNOTATIONSYM;

typedef struct DATASYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32_16t, S_GDATA32_16t or S_PUB32_16t
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32_16t;
typedef DATASYM32_16t PUBSYM32_16t;

typedef struct DATASYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32, S_GDATA32 or S_PUB32, S_LMANDATA, S_GMANDATA
    CV_typ_t        typind;     // Type index, or Metadata token if a managed symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32;

typedef enum CV_PUBSYMFLAGS_e
 {
    cvpsfNone     = 0,
    cvpsfCode     = 0x00000001,
    cvpsfFunction = 0x00000002,
    cvpsfManaged  = 0x00000004,
    cvpsfMSIL     = 0x00000008,
} CV_PUBSYMFLAGS_e;

typedef union CV_PUBSYMFLAGS {
    CV_pubsymflag_t grfFlags;
    struct {
        CV_pubsymflag_t fCode       : 1;    // set if public symbol refers to a code address
        CV_pubsymflag_t fFunction   : 1;    // set if public symbol is a function
        CV_pubsymflag_t fManaged    : 1;    // set if managed code (native or IL)
        CV_pubsymflag_t fMSIL       : 1;    // set if managed IL code
        CV_pubsymflag_t __unused    :28;    // must be zero
    };
} CV_PUBSYMFLAGS;

typedef struct PUBSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PUB32
    CV_PUBSYMFLAGS  pubsymflags;
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   name[1];    // Length-prefixed name
} PUBSYM32;


typedef struct PROCSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32_16t or S_LPROC32_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32_16t;

typedef struct PROCSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32 or S_LPROC32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32;

typedef struct MANPROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GMANPROC, S_LMANPROC, S_GMANPROCIA64 or S_LMANPROCIA64
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_tkn_t        token;      // COM+ metadata token for method
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned short  retReg;     // Register return value is in (may not be used for all archs)
    unsigned char   name[1];    // optional name field
} MANPROCSYM;

typedef struct MANPROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GMANPROCMIPS or S_LMANPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_tkn_t        token;      // COM+ token type
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // optional name field
} MANPROCSYMMIPS;

typedef struct THUNKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // THUNK_ORDINAL specifying type of thunk
    unsigned char   name[1];    // Length-prefixed name
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM32;

typedef enum TRAMP_e {      // Trampoline subtype
    trampIncremental,           // incremental thunks
    trampBranchIsland,          // Branch island thunks
} TRAMP_e;

typedef struct TRAMPOLINESYM {  // Trampoline thunk symbol
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_TRAMPOLINE
    unsigned short  trampType;  // trampoline sym subtype
    unsigned short  cbThunk;    // size of the thunk
    CV_uoff32_t     offThunk;   // offset of the thunk
    CV_uoff32_t     offTarget;  // offset of the target of the thunk
    unsigned short  sectThunk;  // section index of the thunk
    unsigned short  sectTarget; // section index of the target of the thunk
} TRAMPOLINE;

typedef struct LABELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM32;


typedef struct BLOCKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM32;


typedef struct WITHSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   expr[1];    // Length-prefixed expression string
} WITHSYM32;



typedef struct CEXMSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union {
        struct  {
            CV_uoff32_t pcdtable;   // offset to pcode function table
            CV_uoff32_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
        struct {
            CV_uoff32_t calltableOff; // offset to function table
            unsigned short calltableSeg; // segment of function table
        } pcode32Mac;
    };
} CEXMSYM32;



typedef struct VPATHSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32_16t
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM32_16t;

typedef struct VPATHSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
} VPATHSYM32;





typedef struct REGREL32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32_16t
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  reg;        // register index for symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL32_16t;

typedef struct REGREL32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32
    CV_uoff32_t     off;        // offset of symbol
    CV_typ_t        typind;     // Type index or metadata token
    unsigned short  reg;        // register index for symbol
    unsigned char   name[1];    // Length-prefixed name
} REGREL32;

typedef struct ATTRREGREL {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANREGREL
    CV_uoff32_t     off;        // offset of symbol
    CV_typ_t        typind;     // Type index or metadata token
    unsigned short  reg;        // register index for symbol
    CV_lvar_attr    attr;       // local var attributes
    unsigned char   name[1];    // Length-prefixed name
} ATTRREGREL;

typedef struct THREADSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32_16t | S_GTHREAD32_16t
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    CV_typ16_t      typind;     // type index
    unsigned char   name[1];    // length prefixed name
} THREADSYM32_16t;

typedef struct THREADSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32 | S_GTHREAD32
    CV_typ_t        typind;     // type index
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    unsigned char   name[1];    // length prefixed name
} THREADSYM32;

typedef struct SLINK32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_SLINK32
    unsigned long   framesize;  // frame size of parent procedure
    CV_off32_t      off;        // signed offset where the static link was saved relative to the value of reg
    unsigned short  reg;
} SLINK32;

typedef struct PROCSYMMIPS_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS_16t or S_LPROCMIPS_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    CV_typ16_t      typind;     // Type index
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS_16t;

typedef struct PROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS or S_LPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS;

typedef struct PROCSYMIA64 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCIA64 or S_LPROCIA64
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned short  retReg;     // Register return value is in
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMIA64;

typedef struct REFSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF_ST, S_DATAREF_ST, or S_LPROCREF_ST
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned short  usFill;     // align this record
} REFSYM;

typedef struct REFSYM2 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF, S_DATAREF, or S_LPROCREF
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned char   name[1];    // hidden name made a first class member
} REFSYM2;

typedef struct ALIGNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ALIGN
} ALIGNSYM;

typedef struct OEMSYMBOL {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OEM
    unsigned char   idOem[16];  // an oem ID (GUID)
    CV_typ_t        typind;     // Type index
    unsigned long   rgl[];      // user data, force 4-byte alignment
} OEMSYMBOL;

//  generic block definition symbols
//  these are similar to the equivalent 16:16 or 16:32 symbols but
//  only define the length, type and linkage fields

typedef struct PROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} PROCSYM;


typedef struct THUNKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} THUNKSYM;

typedef struct BLOCKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} BLOCKSYM;


typedef struct WITHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} WITHSYM;

typedef struct FRAMEPROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_FRAMEPROC
    unsigned long   cbFrame;    // count of bytes of total frame of procedure
    unsigned long   cbPad;      // count of bytes of padding in the frame
    CV_uoff32_t     offPad;     // offset (relative to frame poniter) to where
                                //  padding starts
    unsigned long   cbSaveRegs; // count of bytes of callee save registers
    CV_uoff32_t     offExHdlr;  // offset of exception handler
    unsigned short  sectExHdlr; // section id of exception handler

    struct {
        unsigned long   fHasAlloca  :  1;   // function uses _alloca()
        unsigned long   fHasSetJmp  :  1;   // function uses setjmp()
        unsigned long   fHasLongJmp :  1;   // function uses longjmp()
        unsigned long   fHasInlAsm  :  1;   // function uses inline asm
        unsigned long   fHasEH      :  1;   // function has EH states
        unsigned long   fInlSpec    :  1;   // function was speced as inline
        unsigned long   fHasSEH     :  1;   // function has SEH
        unsigned long   pad         : 25;   // must be zero
    } flags;
} FRAMEPROCSYM;

typedef struct UNAMESPACE {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UNAMESPACE
    unsigned char   name[1];    // name
} UNAMESPACE;

//
// V7 line number data types
//

enum DEBUG_S_SUBSECTION_TYPE {
    DEBUG_S_IGNORE = 0x80000000,   // if this bit is set in a subsection type then ignore the subsection contents

    DEBUG_S_SYMBOLS = 0xf1,
    DEBUG_S_LINES,
    DEBUG_S_STRINGTABLE,
    DEBUG_S_FILECHKSMS,
    DEBUG_S_FRAMEDATA,
};

//
// Line flags (data present)
//
#define CV_LINES_HAVE_COLUMNS 0x0001

struct CV_Line_t {
        unsigned long   offset;             // Offset to start of code bytes for line number
        unsigned long   linenumStart:24;    // line where statement/expression starts
        unsigned long   deltaLineEnd:7;     // delta to line where statement ends (optional)
        unsigned long   fStatement:1;       // true if a statement linenumber, else an expression line num
};

typedef unsigned short CV_columnpos_t;    // byte offset in a source line

struct CV_Column_t {
    CV_columnpos_t offColumnStart;
    CV_columnpos_t offColumnEnd;
};


struct tagFRAMEDATA {
    unsigned long   ulRvaStart;
    unsigned long   cbBlock;
    unsigned long   cbLocals;
    unsigned long   cbParams;
    unsigned long   cbStkMax;
    unsigned long   frameFunc;
    unsigned short  cbProlog;
    unsigned short  cbSavedRegs;
    unsigned long   fHasSEH:1;
    unsigned long   fHasEH:1;
    unsigned long   fIsFunctionStart:1;
    unsigned long   reserved:29;
};

typedef struct tagFRAMEDATA FRAMEDATA, * PFRAMEDATA;

typedef struct tagXFIXUP_DATA {
   unsigned short wType;
   unsigned short wExtra;
   unsigned long rva;
   unsigned long rvaTarget;
} XFIXUP_DATA;


#pragma pack ( pop )

#endif /* CV_INFO_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\vc\dia2.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu May 31 03:31:56 2001
 */
/* Compiler settings for f:\vs70builds\9247\vc\langapi\idl\dia2.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dia2_h__
#define __dia2_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDiaLoadCallback_FWD_DEFINED__
#define __IDiaLoadCallback_FWD_DEFINED__
typedef interface IDiaLoadCallback IDiaLoadCallback;
#endif 	/* __IDiaLoadCallback_FWD_DEFINED__ */


#ifndef __IDiaReadExeAtOffsetCallback_FWD_DEFINED__
#define __IDiaReadExeAtOffsetCallback_FWD_DEFINED__
typedef interface IDiaReadExeAtOffsetCallback IDiaReadExeAtOffsetCallback;
#endif 	/* __IDiaReadExeAtOffsetCallback_FWD_DEFINED__ */


#ifndef __IDiaReadExeAtRVACallback_FWD_DEFINED__
#define __IDiaReadExeAtRVACallback_FWD_DEFINED__
typedef interface IDiaReadExeAtRVACallback IDiaReadExeAtRVACallback;
#endif 	/* __IDiaReadExeAtRVACallback_FWD_DEFINED__ */


#ifndef __IDiaDataSource_FWD_DEFINED__
#define __IDiaDataSource_FWD_DEFINED__
typedef interface IDiaDataSource IDiaDataSource;
#endif 	/* __IDiaDataSource_FWD_DEFINED__ */


#ifndef __IDiaEnumSymbols_FWD_DEFINED__
#define __IDiaEnumSymbols_FWD_DEFINED__
typedef interface IDiaEnumSymbols IDiaEnumSymbols;
#endif 	/* __IDiaEnumSymbols_FWD_DEFINED__ */


#ifndef __IDiaEnumSymbolsByAddr_FWD_DEFINED__
#define __IDiaEnumSymbolsByAddr_FWD_DEFINED__
typedef interface IDiaEnumSymbolsByAddr IDiaEnumSymbolsByAddr;
#endif 	/* __IDiaEnumSymbolsByAddr_FWD_DEFINED__ */


#ifndef __IDiaEnumSourceFiles_FWD_DEFINED__
#define __IDiaEnumSourceFiles_FWD_DEFINED__
typedef interface IDiaEnumSourceFiles IDiaEnumSourceFiles;
#endif 	/* __IDiaEnumSourceFiles_FWD_DEFINED__ */


#ifndef __IDiaEnumLineNumbers_FWD_DEFINED__
#define __IDiaEnumLineNumbers_FWD_DEFINED__
typedef interface IDiaEnumLineNumbers IDiaEnumLineNumbers;
#endif 	/* __IDiaEnumLineNumbers_FWD_DEFINED__ */


#ifndef __IDiaEnumInjectedSources_FWD_DEFINED__
#define __IDiaEnumInjectedSources_FWD_DEFINED__
typedef interface IDiaEnumInjectedSources IDiaEnumInjectedSources;
#endif 	/* __IDiaEnumInjectedSources_FWD_DEFINED__ */


#ifndef __IDiaEnumSegments_FWD_DEFINED__
#define __IDiaEnumSegments_FWD_DEFINED__
typedef interface IDiaEnumSegments IDiaEnumSegments;
#endif 	/* __IDiaEnumSegments_FWD_DEFINED__ */


#ifndef __IDiaEnumSectionContribs_FWD_DEFINED__
#define __IDiaEnumSectionContribs_FWD_DEFINED__
typedef interface IDiaEnumSectionContribs IDiaEnumSectionContribs;
#endif 	/* __IDiaEnumSectionContribs_FWD_DEFINED__ */


#ifndef __IDiaEnumFrameData_FWD_DEFINED__
#define __IDiaEnumFrameData_FWD_DEFINED__
typedef interface IDiaEnumFrameData IDiaEnumFrameData;
#endif 	/* __IDiaEnumFrameData_FWD_DEFINED__ */


#ifndef __IDiaEnumDebugStreamData_FWD_DEFINED__
#define __IDiaEnumDebugStreamData_FWD_DEFINED__
typedef interface IDiaEnumDebugStreamData IDiaEnumDebugStreamData;
#endif 	/* __IDiaEnumDebugStreamData_FWD_DEFINED__ */


#ifndef __IDiaEnumDebugStreams_FWD_DEFINED__
#define __IDiaEnumDebugStreams_FWD_DEFINED__
typedef interface IDiaEnumDebugStreams IDiaEnumDebugStreams;
#endif 	/* __IDiaEnumDebugStreams_FWD_DEFINED__ */


#ifndef __IDiaAddressMap_FWD_DEFINED__
#define __IDiaAddressMap_FWD_DEFINED__
typedef interface IDiaAddressMap IDiaAddressMap;
#endif 	/* __IDiaAddressMap_FWD_DEFINED__ */


#ifndef __IDiaSession_FWD_DEFINED__
#define __IDiaSession_FWD_DEFINED__
typedef interface IDiaSession IDiaSession;
#endif 	/* __IDiaSession_FWD_DEFINED__ */


#ifndef __IDiaSymbol_FWD_DEFINED__
#define __IDiaSymbol_FWD_DEFINED__
typedef interface IDiaSymbol IDiaSymbol;
#endif 	/* __IDiaSymbol_FWD_DEFINED__ */


#ifndef __IDiaSourceFile_FWD_DEFINED__
#define __IDiaSourceFile_FWD_DEFINED__
typedef interface IDiaSourceFile IDiaSourceFile;
#endif 	/* __IDiaSourceFile_FWD_DEFINED__ */


#ifndef __IDiaLineNumber_FWD_DEFINED__
#define __IDiaLineNumber_FWD_DEFINED__
typedef interface IDiaLineNumber IDiaLineNumber;
#endif 	/* __IDiaLineNumber_FWD_DEFINED__ */


#ifndef __IDiaSectionContrib_FWD_DEFINED__
#define __IDiaSectionContrib_FWD_DEFINED__
typedef interface IDiaSectionContrib IDiaSectionContrib;
#endif 	/* __IDiaSectionContrib_FWD_DEFINED__ */


#ifndef __IDiaSegment_FWD_DEFINED__
#define __IDiaSegment_FWD_DEFINED__
typedef interface IDiaSegment IDiaSegment;
#endif 	/* __IDiaSegment_FWD_DEFINED__ */


#ifndef __IDiaInjectedSource_FWD_DEFINED__
#define __IDiaInjectedSource_FWD_DEFINED__
typedef interface IDiaInjectedSource IDiaInjectedSource;
#endif 	/* __IDiaInjectedSource_FWD_DEFINED__ */


#ifndef __IDiaStackWalkFrame_FWD_DEFINED__
#define __IDiaStackWalkFrame_FWD_DEFINED__
typedef interface IDiaStackWalkFrame IDiaStackWalkFrame;
#endif 	/* __IDiaStackWalkFrame_FWD_DEFINED__ */


#ifndef __IDiaFrameData_FWD_DEFINED__
#define __IDiaFrameData_FWD_DEFINED__
typedef interface IDiaFrameData IDiaFrameData;
#endif 	/* __IDiaFrameData_FWD_DEFINED__ */


#ifndef __IDiaImageData_FWD_DEFINED__
#define __IDiaImageData_FWD_DEFINED__
typedef interface IDiaImageData IDiaImageData;
#endif 	/* __IDiaImageData_FWD_DEFINED__ */


#ifndef __IDiaTable_FWD_DEFINED__
#define __IDiaTable_FWD_DEFINED__
typedef interface IDiaTable IDiaTable;
#endif 	/* __IDiaTable_FWD_DEFINED__ */


#ifndef __IDiaEnumTables_FWD_DEFINED__
#define __IDiaEnumTables_FWD_DEFINED__
typedef interface IDiaEnumTables IDiaEnumTables;
#endif 	/* __IDiaEnumTables_FWD_DEFINED__ */


#ifndef __DiaSource_FWD_DEFINED__
#define __DiaSource_FWD_DEFINED__

#ifdef __cplusplus
typedef class DiaSource DiaSource;
#else
typedef struct DiaSource DiaSource;
#endif /* __cplusplus */

#endif 	/* __DiaSource_FWD_DEFINED__ */


#ifndef __DiaSourceAlt_FWD_DEFINED__
#define __DiaSourceAlt_FWD_DEFINED__

#ifdef __cplusplus
typedef class DiaSourceAlt DiaSourceAlt;
#else
typedef struct DiaSourceAlt DiaSourceAlt;
#endif /* __cplusplus */

#endif 	/* __DiaSourceAlt_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oaidl.h"
#include "cvconst.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dia2_0000 */
/* [local] */ 


enum NameSearchOptions
    {	nsNone	= 0,
	nsfCaseSensitive	= 0x1,
	nsfCaseInsensitive	= 0x2,
	nsfFNameExt	= 0x4,
	nsfRegularExpression	= 0x8,
	nsfUndecoratedName	= 0x10,
	nsCaseSensitive	= nsfCaseSensitive,
	nsCaseInsensitive	= nsfCaseInsensitive,
	nsFNameExt	= nsfCaseInsensitive | nsfFNameExt,
	nsRegularExpression	= nsfRegularExpression | nsfCaseSensitive,
	nsCaseInRegularExpression	= nsfRegularExpression | nsfCaseInsensitive
    } ;

enum __MIDL___MIDL_itf_dia2_0000_0001
    {	E_PDB_OK	= ( HRESULT  )(( unsigned long  )1 << 31 | ( unsigned long  )( LONG  )0x6d << 16 | ( unsigned long  )1),
	E_PDB_USAGE	= E_PDB_OK + 1,
	E_PDB_OUT_OF_MEMORY	= E_PDB_USAGE + 1,
	E_PDB_FILE_SYSTEM	= E_PDB_OUT_OF_MEMORY + 1,
	E_PDB_NOT_FOUND	= E_PDB_FILE_SYSTEM + 1,
	E_PDB_INVALID_SIG	= E_PDB_NOT_FOUND + 1,
	E_PDB_INVALID_AGE	= E_PDB_INVALID_SIG + 1,
	E_PDB_PRECOMP_REQUIRED	= E_PDB_INVALID_AGE + 1,
	E_PDB_OUT_OF_TI	= E_PDB_PRECOMP_REQUIRED + 1,
	E_PDB_NOT_IMPLEMENTED	= E_PDB_OUT_OF_TI + 1,
	E_PDB_V1_PDB	= E_PDB_NOT_IMPLEMENTED + 1,
	E_PDB_FORMAT	= E_PDB_V1_PDB + 1,
	E_PDB_LIMIT	= E_PDB_FORMAT + 1,
	E_PDB_CORRUPT	= E_PDB_LIMIT + 1,
	E_PDB_TI16	= E_PDB_CORRUPT + 1,
	E_PDB_ACCESS_DENIED	= E_PDB_TI16 + 1,
	E_PDB_ILLEGAL_TYPE_EDIT	= E_PDB_ACCESS_DENIED + 1,
	E_PDB_INVALID_EXECUTABLE	= E_PDB_ILLEGAL_TYPE_EDIT + 1,
	E_PDB_DBG_NOT_FOUND	= E_PDB_INVALID_EXECUTABLE + 1,
	E_PDB_NO_DEBUG_INFO	= E_PDB_DBG_NOT_FOUND + 1,
	E_PDB_INVALID_EXE_TIMESTAMP	= E_PDB_NO_DEBUG_INFO + 1,
	E_PDB_RESERVED	= E_PDB_INVALID_EXE_TIMESTAMP + 1,
	E_PDB_DEBUG_INFO_NOT_IN_PDB	= E_PDB_RESERVED + 1,
	E_PDB_MAX	= E_PDB_DEBUG_INFO_NOT_IN_PDB + 1
    } ;

enum __MIDL___MIDL_itf_dia2_0000_0002
    {	DIA_E_MODNOTFOUND	= E_PDB_MAX + 1,
	DIA_E_PROCNOTFOUND	= DIA_E_MODNOTFOUND + 1
    } ;
typedef void ( __cdecl *PfnPDBDebugDirV )( 
    BOOL __MIDL_0010,
    void *__MIDL_0011);












extern RPC_IF_HANDLE __MIDL_itf_dia2_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_0000_v0_0_s_ifspec;

#ifndef __IDiaLoadCallback_INTERFACE_DEFINED__
#define __IDiaLoadCallback_INTERFACE_DEFINED__

/* interface IDiaLoadCallback */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaLoadCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C32ADB82-73F4-421b-95D5-A4706EDF5DBE")
    IDiaLoadCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyDebugDir( 
            /* [in] */ BOOL fExecutable,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOpenDBG( 
            /* [in] */ LPCOLESTR dbgPath,
            /* [in] */ HRESULT resultCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOpenPDB( 
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ HRESULT resultCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestrictRegistryAccess( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestrictSymbolServerAccess( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaLoadCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaLoadCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaLoadCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaLoadCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyDebugDir )( 
            IDiaLoadCallback * This,
            /* [in] */ BOOL fExecutable,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOpenDBG )( 
            IDiaLoadCallback * This,
            /* [in] */ LPCOLESTR dbgPath,
            /* [in] */ HRESULT resultCode);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOpenPDB )( 
            IDiaLoadCallback * This,
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ HRESULT resultCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictRegistryAccess )( 
            IDiaLoadCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictSymbolServerAccess )( 
            IDiaLoadCallback * This);
        
        END_INTERFACE
    } IDiaLoadCallbackVtbl;

    interface IDiaLoadCallback
    {
        CONST_VTBL struct IDiaLoadCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaLoadCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaLoadCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaLoadCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaLoadCallback_NotifyDebugDir(This,fExecutable,cbData,data)	\
    (This)->lpVtbl -> NotifyDebugDir(This,fExecutable,cbData,data)

#define IDiaLoadCallback_NotifyOpenDBG(This,dbgPath,resultCode)	\
    (This)->lpVtbl -> NotifyOpenDBG(This,dbgPath,resultCode)

#define IDiaLoadCallback_NotifyOpenPDB(This,pdbPath,resultCode)	\
    (This)->lpVtbl -> NotifyOpenPDB(This,pdbPath,resultCode)

#define IDiaLoadCallback_RestrictRegistryAccess(This)	\
    (This)->lpVtbl -> RestrictRegistryAccess(This)

#define IDiaLoadCallback_RestrictSymbolServerAccess(This)	\
    (This)->lpVtbl -> RestrictSymbolServerAccess(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaLoadCallback_NotifyDebugDir_Proxy( 
    IDiaLoadCallback * This,
    /* [in] */ BOOL fExecutable,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE data[  ]);


void __RPC_STUB IDiaLoadCallback_NotifyDebugDir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_NotifyOpenDBG_Proxy( 
    IDiaLoadCallback * This,
    /* [in] */ LPCOLESTR dbgPath,
    /* [in] */ HRESULT resultCode);


void __RPC_STUB IDiaLoadCallback_NotifyOpenDBG_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_NotifyOpenPDB_Proxy( 
    IDiaLoadCallback * This,
    /* [in] */ LPCOLESTR pdbPath,
    /* [in] */ HRESULT resultCode);


void __RPC_STUB IDiaLoadCallback_NotifyOpenPDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_RestrictRegistryAccess_Proxy( 
    IDiaLoadCallback * This);


void __RPC_STUB IDiaLoadCallback_RestrictRegistryAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_RestrictSymbolServerAccess_Proxy( 
    IDiaLoadCallback * This);


void __RPC_STUB IDiaLoadCallback_RestrictSymbolServerAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaLoadCallback_INTERFACE_DEFINED__ */


#ifndef __IDiaReadExeAtOffsetCallback_INTERFACE_DEFINED__
#define __IDiaReadExeAtOffsetCallback_INTERFACE_DEFINED__

/* interface IDiaReadExeAtOffsetCallback */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaReadExeAtOffsetCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("587A461C-B80B-4f54-9194-5032589A6319")
    IDiaReadExeAtOffsetCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadExecutableAt( 
            /* [in] */ DWORDLONG fileOffset,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaReadExeAtOffsetCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaReadExeAtOffsetCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaReadExeAtOffsetCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaReadExeAtOffsetCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadExecutableAt )( 
            IDiaReadExeAtOffsetCallback * This,
            /* [in] */ DWORDLONG fileOffset,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        END_INTERFACE
    } IDiaReadExeAtOffsetCallbackVtbl;

    interface IDiaReadExeAtOffsetCallback
    {
        CONST_VTBL struct IDiaReadExeAtOffsetCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaReadExeAtOffsetCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaReadExeAtOffsetCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaReadExeAtOffsetCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaReadExeAtOffsetCallback_ReadExecutableAt(This,fileOffset,cbData,pcbData,data)	\
    (This)->lpVtbl -> ReadExecutableAt(This,fileOffset,cbData,pcbData,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaReadExeAtOffsetCallback_ReadExecutableAt_Proxy( 
    IDiaReadExeAtOffsetCallback * This,
    /* [in] */ DWORDLONG fileOffset,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaReadExeAtOffsetCallback_ReadExecutableAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaReadExeAtOffsetCallback_INTERFACE_DEFINED__ */


#ifndef __IDiaReadExeAtRVACallback_INTERFACE_DEFINED__
#define __IDiaReadExeAtRVACallback_INTERFACE_DEFINED__

/* interface IDiaReadExeAtRVACallback */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaReadExeAtRVACallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E3F80CA-7517-432a-BA07-285134AAEA8E")
    IDiaReadExeAtRVACallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadExecutableAtRVA( 
            /* [in] */ DWORD relativeVirtualAddress,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaReadExeAtRVACallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaReadExeAtRVACallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaReadExeAtRVACallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaReadExeAtRVACallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadExecutableAtRVA )( 
            IDiaReadExeAtRVACallback * This,
            /* [in] */ DWORD relativeVirtualAddress,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        END_INTERFACE
    } IDiaReadExeAtRVACallbackVtbl;

    interface IDiaReadExeAtRVACallback
    {
        CONST_VTBL struct IDiaReadExeAtRVACallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaReadExeAtRVACallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaReadExeAtRVACallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaReadExeAtRVACallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaReadExeAtRVACallback_ReadExecutableAtRVA(This,relativeVirtualAddress,cbData,pcbData,data)	\
    (This)->lpVtbl -> ReadExecutableAtRVA(This,relativeVirtualAddress,cbData,pcbData,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaReadExeAtRVACallback_ReadExecutableAtRVA_Proxy( 
    IDiaReadExeAtRVACallback * This,
    /* [in] */ DWORD relativeVirtualAddress,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaReadExeAtRVACallback_ReadExecutableAtRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaReadExeAtRVACallback_INTERFACE_DEFINED__ */


#ifndef __IDiaDataSource_INTERFACE_DEFINED__
#define __IDiaDataSource_INTERFACE_DEFINED__

/* interface IDiaDataSource */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaDataSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79F1BB5F-B66E-48e5-B6A9-1545C323CA3D")
    IDiaDataSource : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lastError( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadDataFromPdb( 
            /* [in] */ LPCOLESTR pdbPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadAndValidateDataFromPdb( 
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ GUID *pcsig70,
            /* [in] */ DWORD sig,
            /* [in] */ DWORD age) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadDataForExe( 
            /* [in] */ LPCOLESTR executable,
            /* [in] */ LPCOLESTR searchPath,
            /* [in] */ IUnknown *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadDataFromIStream( 
            /* [in] */ IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE openSession( 
            /* [out] */ IDiaSession **ppSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaDataSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaDataSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaDataSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaDataSource * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastError )( 
            IDiaDataSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataFromPdb )( 
            IDiaDataSource * This,
            /* [in] */ LPCOLESTR pdbPath);
        
        HRESULT ( STDMETHODCALLTYPE *loadAndValidateDataFromPdb )( 
            IDiaDataSource * This,
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ GUID *pcsig70,
            /* [in] */ DWORD sig,
            /* [in] */ DWORD age);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataForExe )( 
            IDiaDataSource * This,
            /* [in] */ LPCOLESTR executable,
            /* [in] */ LPCOLESTR searchPath,
            /* [in] */ IUnknown *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataFromIStream )( 
            IDiaDataSource * This,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *openSession )( 
            IDiaDataSource * This,
            /* [out] */ IDiaSession **ppSession);
        
        END_INTERFACE
    } IDiaDataSourceVtbl;

    interface IDiaDataSource
    {
        CONST_VTBL struct IDiaDataSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaDataSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaDataSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaDataSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaDataSource_get_lastError(This,pRetVal)	\
    (This)->lpVtbl -> get_lastError(This,pRetVal)

#define IDiaDataSource_loadDataFromPdb(This,pdbPath)	\
    (This)->lpVtbl -> loadDataFromPdb(This,pdbPath)

#define IDiaDataSource_loadAndValidateDataFromPdb(This,pdbPath,pcsig70,sig,age)	\
    (This)->lpVtbl -> loadAndValidateDataFromPdb(This,pdbPath,pcsig70,sig,age)

#define IDiaDataSource_loadDataForExe(This,executable,searchPath,pCallback)	\
    (This)->lpVtbl -> loadDataForExe(This,executable,searchPath,pCallback)

#define IDiaDataSource_loadDataFromIStream(This,pIStream)	\
    (This)->lpVtbl -> loadDataFromIStream(This,pIStream)

#define IDiaDataSource_openSession(This,ppSession)	\
    (This)->lpVtbl -> openSession(This,ppSession)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaDataSource_get_lastError_Proxy( 
    IDiaDataSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaDataSource_get_lastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadDataFromPdb_Proxy( 
    IDiaDataSource * This,
    /* [in] */ LPCOLESTR pdbPath);


void __RPC_STUB IDiaDataSource_loadDataFromPdb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadAndValidateDataFromPdb_Proxy( 
    IDiaDataSource * This,
    /* [in] */ LPCOLESTR pdbPath,
    /* [in] */ GUID *pcsig70,
    /* [in] */ DWORD sig,
    /* [in] */ DWORD age);


void __RPC_STUB IDiaDataSource_loadAndValidateDataFromPdb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadDataForExe_Proxy( 
    IDiaDataSource * This,
    /* [in] */ LPCOLESTR executable,
    /* [in] */ LPCOLESTR searchPath,
    /* [in] */ IUnknown *pCallback);


void __RPC_STUB IDiaDataSource_loadDataForExe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadDataFromIStream_Proxy( 
    IDiaDataSource * This,
    /* [in] */ IStream *pIStream);


void __RPC_STUB IDiaDataSource_loadDataFromIStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_openSession_Proxy( 
    IDiaDataSource * This,
    /* [out] */ IDiaSession **ppSession);


void __RPC_STUB IDiaDataSource_openSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaDataSource_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSymbols_INTERFACE_DEFINED__
#define __IDiaEnumSymbols_INTERFACE_DEFINED__

/* interface IDiaEnumSymbols */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSymbols;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CAB72C48-443B-48f5-9B0B-42F0820AB29A")
    IDiaEnumSymbols : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSymbol **symbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSymbols **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSymbolsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSymbols * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSymbols * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSymbols * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSymbols * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSymbols * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSymbols * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSymbol **symbol);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSymbols * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSymbols * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSymbols * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSymbols * This,
            /* [out] */ IDiaEnumSymbols **ppenum);
        
        END_INTERFACE
    } IDiaEnumSymbolsVtbl;

    interface IDiaEnumSymbols
    {
        CONST_VTBL struct IDiaEnumSymbolsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSymbols_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSymbols_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSymbols_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSymbols_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSymbols_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSymbols_Item(This,index,symbol)	\
    (This)->lpVtbl -> Item(This,index,symbol)

#define IDiaEnumSymbols_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSymbols_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSymbols_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSymbols_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_get__NewEnum_Proxy( 
    IDiaEnumSymbols * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSymbols_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_get_Count_Proxy( 
    IDiaEnumSymbols * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSymbols_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Item_Proxy( 
    IDiaEnumSymbols * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSymbol **symbol);


void __RPC_STUB IDiaEnumSymbols_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Next_Proxy( 
    IDiaEnumSymbols * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSymbol **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSymbols_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Skip_Proxy( 
    IDiaEnumSymbols * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSymbols_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Reset_Proxy( 
    IDiaEnumSymbols * This);


void __RPC_STUB IDiaEnumSymbols_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Clone_Proxy( 
    IDiaEnumSymbols * This,
    /* [out] */ IDiaEnumSymbols **ppenum);


void __RPC_STUB IDiaEnumSymbols_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSymbols_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSymbolsByAddr_INTERFACE_DEFINED__
#define __IDiaEnumSymbolsByAddr_INTERFACE_DEFINED__

/* interface IDiaEnumSymbolsByAddr */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSymbolsByAddr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("624B7D9C-24EA-4421-9D06-3B577471C1FA")
    IDiaEnumSymbolsByAddr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE symbolByAddr( 
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [retval][out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE symbolByRVA( 
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE symbolByVA( 
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Prev( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSymbolsByAddr **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSymbolsByAddrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSymbolsByAddr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSymbolsByAddr * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *symbolByAddr )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [retval][out] */ IDiaSymbol **ppSymbol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *symbolByRVA )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *symbolByVA )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Prev )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSymbolsByAddr * This,
            /* [out] */ IDiaEnumSymbolsByAddr **ppenum);
        
        END_INTERFACE
    } IDiaEnumSymbolsByAddrVtbl;

    interface IDiaEnumSymbolsByAddr
    {
        CONST_VTBL struct IDiaEnumSymbolsByAddrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSymbolsByAddr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSymbolsByAddr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSymbolsByAddr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSymbolsByAddr_symbolByAddr(This,isect,offset,ppSymbol)	\
    (This)->lpVtbl -> symbolByAddr(This,isect,offset,ppSymbol)

#define IDiaEnumSymbolsByAddr_symbolByRVA(This,relativeVirtualAddress,ppSymbol)	\
    (This)->lpVtbl -> symbolByRVA(This,relativeVirtualAddress,ppSymbol)

#define IDiaEnumSymbolsByAddr_symbolByVA(This,virtualAddress,ppSymbol)	\
    (This)->lpVtbl -> symbolByVA(This,virtualAddress,ppSymbol)

#define IDiaEnumSymbolsByAddr_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSymbolsByAddr_Prev(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Prev(This,celt,rgelt,pceltFetched)

#define IDiaEnumSymbolsByAddr_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_symbolByAddr_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ DWORD isect,
    /* [in] */ DWORD offset,
    /* [retval][out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaEnumSymbolsByAddr_symbolByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_symbolByRVA_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ DWORD relativeVirtualAddress,
    /* [retval][out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaEnumSymbolsByAddr_symbolByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_symbolByVA_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ ULONGLONG virtualAddress,
    /* [retval][out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaEnumSymbolsByAddr_symbolByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_Next_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSymbol **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSymbolsByAddr_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_Prev_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSymbol **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSymbolsByAddr_Prev_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_Clone_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [out] */ IDiaEnumSymbolsByAddr **ppenum);


void __RPC_STUB IDiaEnumSymbolsByAddr_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSymbolsByAddr_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSourceFiles_INTERFACE_DEFINED__
#define __IDiaEnumSourceFiles_INTERFACE_DEFINED__

/* interface IDiaEnumSourceFiles */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSourceFiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10F3DBD9-664F-4469-B808-9471C7A50538")
    IDiaEnumSourceFiles : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSourceFile **sourceFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSourceFile **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSourceFiles **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSourceFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSourceFiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSourceFiles * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSourceFiles * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSourceFiles * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSourceFile **sourceFile);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSourceFile **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSourceFiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSourceFiles * This,
            /* [out] */ IDiaEnumSourceFiles **ppenum);
        
        END_INTERFACE
    } IDiaEnumSourceFilesVtbl;

    interface IDiaEnumSourceFiles
    {
        CONST_VTBL struct IDiaEnumSourceFilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSourceFiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSourceFiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSourceFiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSourceFiles_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSourceFiles_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSourceFiles_Item(This,index,sourceFile)	\
    (This)->lpVtbl -> Item(This,index,sourceFile)

#define IDiaEnumSourceFiles_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSourceFiles_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSourceFiles_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSourceFiles_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_get__NewEnum_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSourceFiles_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_get_Count_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSourceFiles_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Item_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSourceFile **sourceFile);


void __RPC_STUB IDiaEnumSourceFiles_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Next_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSourceFile **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSourceFiles_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Skip_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSourceFiles_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Reset_Proxy( 
    IDiaEnumSourceFiles * This);


void __RPC_STUB IDiaEnumSourceFiles_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Clone_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [out] */ IDiaEnumSourceFiles **ppenum);


void __RPC_STUB IDiaEnumSourceFiles_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSourceFiles_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumLineNumbers_INTERFACE_DEFINED__
#define __IDiaEnumLineNumbers_INTERFACE_DEFINED__

/* interface IDiaEnumLineNumbers */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumLineNumbers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FE30E878-54AC-44f1-81BA-39DE940F6052")
    IDiaEnumLineNumbers : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaLineNumber **lineNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaLineNumber **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumLineNumbers **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumLineNumbersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumLineNumbers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumLineNumbers * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumLineNumbers * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumLineNumbers * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaLineNumber **lineNumber);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaLineNumber **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumLineNumbers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumLineNumbers * This,
            /* [out] */ IDiaEnumLineNumbers **ppenum);
        
        END_INTERFACE
    } IDiaEnumLineNumbersVtbl;

    interface IDiaEnumLineNumbers
    {
        CONST_VTBL struct IDiaEnumLineNumbersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumLineNumbers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumLineNumbers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumLineNumbers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumLineNumbers_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumLineNumbers_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumLineNumbers_Item(This,index,lineNumber)	\
    (This)->lpVtbl -> Item(This,index,lineNumber)

#define IDiaEnumLineNumbers_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumLineNumbers_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumLineNumbers_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumLineNumbers_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_get__NewEnum_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumLineNumbers_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_get_Count_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumLineNumbers_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Item_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaLineNumber **lineNumber);


void __RPC_STUB IDiaEnumLineNumbers_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Next_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaLineNumber **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumLineNumbers_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Skip_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumLineNumbers_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Reset_Proxy( 
    IDiaEnumLineNumbers * This);


void __RPC_STUB IDiaEnumLineNumbers_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Clone_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [out] */ IDiaEnumLineNumbers **ppenum);


void __RPC_STUB IDiaEnumLineNumbers_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumLineNumbers_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumInjectedSources_INTERFACE_DEFINED__
#define __IDiaEnumInjectedSources_INTERFACE_DEFINED__

/* interface IDiaEnumInjectedSources */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumInjectedSources;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D5612573-6925-4468-8883-98CDEC8C384A")
    IDiaEnumInjectedSources : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaInjectedSource **injectedSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaInjectedSource **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumInjectedSources **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumInjectedSourcesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumInjectedSources * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumInjectedSources * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumInjectedSources * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumInjectedSources * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaInjectedSource **injectedSource);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaInjectedSource **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumInjectedSources * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumInjectedSources * This,
            /* [out] */ IDiaEnumInjectedSources **ppenum);
        
        END_INTERFACE
    } IDiaEnumInjectedSourcesVtbl;

    interface IDiaEnumInjectedSources
    {
        CONST_VTBL struct IDiaEnumInjectedSourcesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumInjectedSources_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumInjectedSources_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumInjectedSources_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumInjectedSources_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumInjectedSources_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumInjectedSources_Item(This,index,injectedSource)	\
    (This)->lpVtbl -> Item(This,index,injectedSource)

#define IDiaEnumInjectedSources_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumInjectedSources_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumInjectedSources_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumInjectedSources_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_get__NewEnum_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumInjectedSources_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_get_Count_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumInjectedSources_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Item_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaInjectedSource **injectedSource);


void __RPC_STUB IDiaEnumInjectedSources_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Next_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaInjectedSource **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumInjectedSources_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Skip_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumInjectedSources_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Reset_Proxy( 
    IDiaEnumInjectedSources * This);


void __RPC_STUB IDiaEnumInjectedSources_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Clone_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [out] */ IDiaEnumInjectedSources **ppenum);


void __RPC_STUB IDiaEnumInjectedSources_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumInjectedSources_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSegments_INTERFACE_DEFINED__
#define __IDiaEnumSegments_INTERFACE_DEFINED__

/* interface IDiaEnumSegments */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSegments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E8368CA9-01D1-419d-AC0C-E31235DBDA9F")
    IDiaEnumSegments : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSegment **segment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSegment **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSegments **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSegmentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSegments * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSegments * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSegments * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSegments * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSegments * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSegments * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSegment **segment);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSegments * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSegment **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSegments * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSegments * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSegments * This,
            /* [out] */ IDiaEnumSegments **ppenum);
        
        END_INTERFACE
    } IDiaEnumSegmentsVtbl;

    interface IDiaEnumSegments
    {
        CONST_VTBL struct IDiaEnumSegmentsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSegments_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSegments_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSegments_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSegments_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSegments_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSegments_Item(This,index,segment)	\
    (This)->lpVtbl -> Item(This,index,segment)

#define IDiaEnumSegments_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSegments_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSegments_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSegments_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSegments_get__NewEnum_Proxy( 
    IDiaEnumSegments * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSegments_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSegments_get_Count_Proxy( 
    IDiaEnumSegments * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSegments_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Item_Proxy( 
    IDiaEnumSegments * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSegment **segment);


void __RPC_STUB IDiaEnumSegments_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Next_Proxy( 
    IDiaEnumSegments * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSegment **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSegments_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Skip_Proxy( 
    IDiaEnumSegments * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSegments_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Reset_Proxy( 
    IDiaEnumSegments * This);


void __RPC_STUB IDiaEnumSegments_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Clone_Proxy( 
    IDiaEnumSegments * This,
    /* [out] */ IDiaEnumSegments **ppenum);


void __RPC_STUB IDiaEnumSegments_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSegments_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSectionContribs_INTERFACE_DEFINED__
#define __IDiaEnumSectionContribs_INTERFACE_DEFINED__

/* interface IDiaEnumSectionContribs */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSectionContribs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1994DEB2-2C82-4b1d-A57F-AFF424D54A68")
    IDiaEnumSectionContribs : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSectionContrib **section) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSectionContrib **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSectionContribs **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSectionContribsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSectionContribs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSectionContribs * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSectionContribs * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSectionContribs * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSectionContrib **section);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSectionContrib **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSectionContribs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSectionContribs * This,
            /* [out] */ IDiaEnumSectionContribs **ppenum);
        
        END_INTERFACE
    } IDiaEnumSectionContribsVtbl;

    interface IDiaEnumSectionContribs
    {
        CONST_VTBL struct IDiaEnumSectionContribsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSectionContribs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSectionContribs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSectionContribs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSectionContribs_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSectionContribs_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSectionContribs_Item(This,index,section)	\
    (This)->lpVtbl -> Item(This,index,section)

#define IDiaEnumSectionContribs_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSectionContribs_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSectionContribs_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSectionContribs_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_get__NewEnum_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSectionContribs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_get_Count_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSectionContribs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Item_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSectionContrib **section);


void __RPC_STUB IDiaEnumSectionContribs_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Next_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSectionContrib **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSectionContribs_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Skip_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSectionContribs_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Reset_Proxy( 
    IDiaEnumSectionContribs * This);


void __RPC_STUB IDiaEnumSectionContribs_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Clone_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [out] */ IDiaEnumSectionContribs **ppenum);


void __RPC_STUB IDiaEnumSectionContribs_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSectionContribs_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumFrameData_INTERFACE_DEFINED__
#define __IDiaEnumFrameData_INTERFACE_DEFINED__

/* interface IDiaEnumFrameData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumFrameData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9FC77A4B-3C1C-44ed-A798-6C1DEEA53E1F")
    IDiaEnumFrameData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaFrameData **frame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaFrameData **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumFrameData **ppenum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE frameByRVA( 
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaFrameData **frame) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE frameByVA( 
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaFrameData **frame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumFrameDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumFrameData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumFrameData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumFrameData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumFrameData * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumFrameData * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumFrameData * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaFrameData **frame);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumFrameData * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaFrameData **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumFrameData * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumFrameData * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumFrameData * This,
            /* [out] */ IDiaEnumFrameData **ppenum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *frameByRVA )( 
            IDiaEnumFrameData * This,
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaFrameData **frame);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *frameByVA )( 
            IDiaEnumFrameData * This,
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaFrameData **frame);
        
        END_INTERFACE
    } IDiaEnumFrameDataVtbl;

    interface IDiaEnumFrameData
    {
        CONST_VTBL struct IDiaEnumFrameDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumFrameData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumFrameData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumFrameData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumFrameData_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumFrameData_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumFrameData_Item(This,index,frame)	\
    (This)->lpVtbl -> Item(This,index,frame)

#define IDiaEnumFrameData_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumFrameData_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumFrameData_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumFrameData_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#define IDiaEnumFrameData_frameByRVA(This,relativeVirtualAddress,frame)	\
    (This)->lpVtbl -> frameByRVA(This,relativeVirtualAddress,frame)

#define IDiaEnumFrameData_frameByVA(This,virtualAddress,frame)	\
    (This)->lpVtbl -> frameByVA(This,virtualAddress,frame)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_get__NewEnum_Proxy( 
    IDiaEnumFrameData * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumFrameData_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_get_Count_Proxy( 
    IDiaEnumFrameData * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumFrameData_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Item_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaFrameData **frame);


void __RPC_STUB IDiaEnumFrameData_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Next_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaFrameData **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumFrameData_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Skip_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumFrameData_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Reset_Proxy( 
    IDiaEnumFrameData * This);


void __RPC_STUB IDiaEnumFrameData_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Clone_Proxy( 
    IDiaEnumFrameData * This,
    /* [out] */ IDiaEnumFrameData **ppenum);


void __RPC_STUB IDiaEnumFrameData_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_frameByRVA_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ DWORD relativeVirtualAddress,
    /* [retval][out] */ IDiaFrameData **frame);


void __RPC_STUB IDiaEnumFrameData_frameByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_frameByVA_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ ULONGLONG virtualAddress,
    /* [retval][out] */ IDiaFrameData **frame);


void __RPC_STUB IDiaEnumFrameData_frameByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumFrameData_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumDebugStreamData_INTERFACE_DEFINED__
#define __IDiaEnumDebugStreamData_INTERFACE_DEFINED__

/* interface IDiaEnumDebugStreamData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumDebugStreamData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("486943E8-D187-4a6b-A3C4-291259FFF60D")
    IDiaEnumDebugStreamData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumDebugStreamData **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumDebugStreamDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumDebugStreamData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumDebugStreamData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumDebugStreamData * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumDebugStreamData * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IDiaEnumDebugStreamData * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ DWORD index,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ ULONG celt,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ],
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumDebugStreamData * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumDebugStreamData * This,
            /* [out] */ IDiaEnumDebugStreamData **ppenum);
        
        END_INTERFACE
    } IDiaEnumDebugStreamDataVtbl;

    interface IDiaEnumDebugStreamData
    {
        CONST_VTBL struct IDiaEnumDebugStreamDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumDebugStreamData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumDebugStreamData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumDebugStreamData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumDebugStreamData_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumDebugStreamData_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumDebugStreamData_get_name(This,pRetVal)	\
    (This)->lpVtbl -> get_name(This,pRetVal)

#define IDiaEnumDebugStreamData_Item(This,index,cbData,pcbData,data)	\
    (This)->lpVtbl -> Item(This,index,cbData,pcbData,data)

#define IDiaEnumDebugStreamData_Next(This,celt,cbData,pcbData,data,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,cbData,pcbData,data,pceltFetched)

#define IDiaEnumDebugStreamData_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumDebugStreamData_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumDebugStreamData_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_get__NewEnum_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumDebugStreamData_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_get_Count_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumDebugStreamData_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_get_name_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaEnumDebugStreamData_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Item_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [in] */ DWORD index,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaEnumDebugStreamData_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Next_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [in] */ ULONG celt,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumDebugStreamData_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Skip_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumDebugStreamData_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Reset_Proxy( 
    IDiaEnumDebugStreamData * This);


void __RPC_STUB IDiaEnumDebugStreamData_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Clone_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [out] */ IDiaEnumDebugStreamData **ppenum);


void __RPC_STUB IDiaEnumDebugStreamData_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumDebugStreamData_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumDebugStreams_INTERFACE_DEFINED__
#define __IDiaEnumDebugStreams_INTERFACE_DEFINED__

/* interface IDiaEnumDebugStreams */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumDebugStreams;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08CBB41E-47A6-4f87-92F1-1C9C87CED044")
    IDiaEnumDebugStreams : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaEnumDebugStreamData **stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaEnumDebugStreamData **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumDebugStreams **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumDebugStreamsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumDebugStreams * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumDebugStreams * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumDebugStreams * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumDebugStreams * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaEnumDebugStreamData **stream);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaEnumDebugStreamData **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumDebugStreams * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumDebugStreams * This,
            /* [out] */ IDiaEnumDebugStreams **ppenum);
        
        END_INTERFACE
    } IDiaEnumDebugStreamsVtbl;

    interface IDiaEnumDebugStreams
    {
        CONST_VTBL struct IDiaEnumDebugStreamsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumDebugStreams_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumDebugStreams_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumDebugStreams_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumDebugStreams_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumDebugStreams_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumDebugStreams_Item(This,index,stream)	\
    (This)->lpVtbl -> Item(This,index,stream)

#define IDiaEnumDebugStreams_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumDebugStreams_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumDebugStreams_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumDebugStreams_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_get__NewEnum_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumDebugStreams_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_get_Count_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumDebugStreams_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Item_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ IDiaEnumDebugStreamData **stream);


void __RPC_STUB IDiaEnumDebugStreams_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Next_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaEnumDebugStreamData **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumDebugStreams_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Skip_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumDebugStreams_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Reset_Proxy( 
    IDiaEnumDebugStreams * This);


void __RPC_STUB IDiaEnumDebugStreams_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Clone_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [out] */ IDiaEnumDebugStreams **ppenum);


void __RPC_STUB IDiaEnumDebugStreams_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumDebugStreams_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dia2_0123 */
/* [local] */ 

struct DiaAddressMapEntry
    {
    DWORD rva;
    DWORD rvaTo;
    } ;


extern RPC_IF_HANDLE __MIDL_itf_dia2_0123_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_0123_v0_0_s_ifspec;

#ifndef __IDiaAddressMap_INTERFACE_DEFINED__
#define __IDiaAddressMap_INTERFACE_DEFINED__

/* interface IDiaAddressMap */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaAddressMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B62A2E7A-067A-4ea3-B598-04C09717502C")
    IDiaAddressMap : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressMapEnabled( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_addressMapEnabled( 
            /* [in] */ BOOL NewVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddressEnabled( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_relativeVirtualAddressEnabled( 
            /* [in] */ BOOL NewVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_imageAlign( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_imageAlign( 
            /* [in] */ DWORD NewVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_imageHeaders( 
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE data[  ],
            /* [in] */ BOOL originalHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_addressMap( 
            /* [in] */ DWORD cData,
            /* [size_is][in] */ struct DiaAddressMapEntry data[  ],
            /* [in] */ BOOL imageToSymbols) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaAddressMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaAddressMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaAddressMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaAddressMap * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressMapEnabled )( 
            IDiaAddressMap * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_addressMapEnabled )( 
            IDiaAddressMap * This,
            /* [in] */ BOOL NewVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddressEnabled )( 
            IDiaAddressMap * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_relativeVirtualAddressEnabled )( 
            IDiaAddressMap * This,
            /* [in] */ BOOL NewVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_imageAlign )( 
            IDiaAddressMap * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_imageAlign )( 
            IDiaAddressMap * This,
            /* [in] */ DWORD NewVal);
        
        HRESULT ( STDMETHODCALLTYPE *set_imageHeaders )( 
            IDiaAddressMap * This,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE data[  ],
            /* [in] */ BOOL originalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *set_addressMap )( 
            IDiaAddressMap * This,
            /* [in] */ DWORD cData,
            /* [size_is][in] */ struct DiaAddressMapEntry data[  ],
            /* [in] */ BOOL imageToSymbols);
        
        END_INTERFACE
    } IDiaAddressMapVtbl;

    interface IDiaAddressMap
    {
        CONST_VTBL struct IDiaAddressMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaAddressMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaAddressMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaAddressMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaAddressMap_get_addressMapEnabled(This,pRetVal)	\
    (This)->lpVtbl -> get_addressMapEnabled(This,pRetVal)

#define IDiaAddressMap_put_addressMapEnabled(This,NewVal)	\
    (This)->lpVtbl -> put_addressMapEnabled(This,NewVal)

#define IDiaAddressMap_get_relativeVirtualAddressEnabled(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddressEnabled(This,pRetVal)

#define IDiaAddressMap_put_relativeVirtualAddressEnabled(This,NewVal)	\
    (This)->lpVtbl -> put_relativeVirtualAddressEnabled(This,NewVal)

#define IDiaAddressMap_get_imageAlign(This,pRetVal)	\
    (This)->lpVtbl -> get_imageAlign(This,pRetVal)

#define IDiaAddressMap_put_imageAlign(This,NewVal)	\
    (This)->lpVtbl -> put_imageAlign(This,NewVal)

#define IDiaAddressMap_set_imageHeaders(This,cbData,data,originalHeaders)	\
    (This)->lpVtbl -> set_imageHeaders(This,cbData,data,originalHeaders)

#define IDiaAddressMap_set_addressMap(This,cData,data,imageToSymbols)	\
    (This)->lpVtbl -> set_addressMap(This,cData,data,imageToSymbols)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_get_addressMapEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaAddressMap_get_addressMapEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_put_addressMapEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ BOOL NewVal);


void __RPC_STUB IDiaAddressMap_put_addressMapEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_get_relativeVirtualAddressEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaAddressMap_get_relativeVirtualAddressEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_put_relativeVirtualAddressEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ BOOL NewVal);


void __RPC_STUB IDiaAddressMap_put_relativeVirtualAddressEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_get_imageAlign_Proxy( 
    IDiaAddressMap * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaAddressMap_get_imageAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_put_imageAlign_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ DWORD NewVal);


void __RPC_STUB IDiaAddressMap_put_imageAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaAddressMap_set_imageHeaders_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE data[  ],
    /* [in] */ BOOL originalHeaders);


void __RPC_STUB IDiaAddressMap_set_imageHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaAddressMap_set_addressMap_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ DWORD cData,
    /* [size_is][in] */ struct DiaAddressMapEntry data[  ],
    /* [in] */ BOOL imageToSymbols);


void __RPC_STUB IDiaAddressMap_set_addressMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaAddressMap_INTERFACE_DEFINED__ */


#ifndef __IDiaSession_INTERFACE_DEFINED__
#define __IDiaSession_INTERFACE_DEFINED__

/* interface IDiaSession */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67138B34-79CD-4b42-B74A-A18ADBB799DF")
    IDiaSession : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_loadAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_loadAddress( 
            /* [in] */ ULONGLONG NewVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_globalScope( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEnumTables( 
            /* [out] */ IDiaEnumTables **ppEnumTables) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getSymbolsByAddr( 
            /* [out] */ IDiaEnumSymbolsByAddr **ppEnumbyAddr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findChildren( 
            /* [in] */ IDiaSymbol *parent,
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByAddr( 
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByRVA( 
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByVA( 
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByToken( 
            /* [in] */ ULONG token,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE symsAreEquiv( 
            /* [in] */ IDiaSymbol *symbolA,
            /* [in] */ IDiaSymbol *symbolB) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE symbolById( 
            /* [in] */ DWORD id,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByRVAEx( 
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByVAEx( 
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findFile( 
            /* [in] */ IDiaSymbol *pCompiland,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSourceFiles **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findFileById( 
            /* [in] */ DWORD uniqueId,
            /* [out] */ IDiaSourceFile **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLines( 
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByAddr( 
            /* [in] */ DWORD seg,
            /* [in] */ DWORD offset,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByRVA( 
            /* [in] */ DWORD rva,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByVA( 
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByLinenum( 
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [in] */ DWORD linenum,
            /* [in] */ DWORD column,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findInjectedSource( 
            /* [in] */ LPCOLESTR srcFile,
            /* [out] */ IDiaEnumInjectedSources **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEnumDebugStreams( 
            /* [out] */ IDiaEnumDebugStreams **ppEnumDebugStreams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSession * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_loadAddress )( 
            IDiaSession * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_loadAddress )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG NewVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_globalScope )( 
            IDiaSession * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *getEnumTables )( 
            IDiaSession * This,
            /* [out] */ IDiaEnumTables **ppEnumTables);
        
        HRESULT ( STDMETHODCALLTYPE *getSymbolsByAddr )( 
            IDiaSession * This,
            /* [out] */ IDiaEnumSymbolsByAddr **ppEnumbyAddr);
        
        HRESULT ( STDMETHODCALLTYPE *findChildren )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *parent,
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByAddr )( 
            IDiaSession * This,
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByRVA )( 
            IDiaSession * This,
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByVA )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByToken )( 
            IDiaSession * This,
            /* [in] */ ULONG token,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *symsAreEquiv )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *symbolA,
            /* [in] */ IDiaSymbol *symbolB);
        
        HRESULT ( STDMETHODCALLTYPE *symbolById )( 
            IDiaSession * This,
            /* [in] */ DWORD id,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByRVAEx )( 
            IDiaSession * This,
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByVAEx )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement);
        
        HRESULT ( STDMETHODCALLTYPE *findFile )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *pCompiland,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSourceFiles **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findFileById )( 
            IDiaSession * This,
            /* [in] */ DWORD uniqueId,
            /* [out] */ IDiaSourceFile **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLines )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByAddr )( 
            IDiaSession * This,
            /* [in] */ DWORD seg,
            /* [in] */ DWORD offset,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByRVA )( 
            IDiaSession * This,
            /* [in] */ DWORD rva,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByVA )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByLinenum )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [in] */ DWORD linenum,
            /* [in] */ DWORD column,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findInjectedSource )( 
            IDiaSession * This,
            /* [in] */ LPCOLESTR srcFile,
            /* [out] */ IDiaEnumInjectedSources **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *getEnumDebugStreams )( 
            IDiaSession * This,
            /* [out] */ IDiaEnumDebugStreams **ppEnumDebugStreams);
        
        END_INTERFACE
    } IDiaSessionVtbl;

    interface IDiaSession
    {
        CONST_VTBL struct IDiaSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSession_get_loadAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_loadAddress(This,pRetVal)

#define IDiaSession_put_loadAddress(This,NewVal)	\
    (This)->lpVtbl -> put_loadAddress(This,NewVal)

#define IDiaSession_get_globalScope(This,pRetVal)	\
    (This)->lpVtbl -> get_globalScope(This,pRetVal)

#define IDiaSession_getEnumTables(This,ppEnumTables)	\
    (This)->lpVtbl -> getEnumTables(This,ppEnumTables)

#define IDiaSession_getSymbolsByAddr(This,ppEnumbyAddr)	\
    (This)->lpVtbl -> getSymbolsByAddr(This,ppEnumbyAddr)

#define IDiaSession_findChildren(This,parent,symtag,name,compareFlags,ppResult)	\
    (This)->lpVtbl -> findChildren(This,parent,symtag,name,compareFlags,ppResult)

#define IDiaSession_findSymbolByAddr(This,isect,offset,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByAddr(This,isect,offset,symtag,ppSymbol)

#define IDiaSession_findSymbolByRVA(This,rva,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByRVA(This,rva,symtag,ppSymbol)

#define IDiaSession_findSymbolByVA(This,va,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByVA(This,va,symtag,ppSymbol)

#define IDiaSession_findSymbolByToken(This,token,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByToken(This,token,symtag,ppSymbol)

#define IDiaSession_symsAreEquiv(This,symbolA,symbolB)	\
    (This)->lpVtbl -> symsAreEquiv(This,symbolA,symbolB)

#define IDiaSession_symbolById(This,id,ppSymbol)	\
    (This)->lpVtbl -> symbolById(This,id,ppSymbol)

#define IDiaSession_findSymbolByRVAEx(This,rva,symtag,ppSymbol,displacement)	\
    (This)->lpVtbl -> findSymbolByRVAEx(This,rva,symtag,ppSymbol,displacement)

#define IDiaSession_findSymbolByVAEx(This,va,symtag,ppSymbol,displacement)	\
    (This)->lpVtbl -> findSymbolByVAEx(This,va,symtag,ppSymbol,displacement)

#define IDiaSession_findFile(This,pCompiland,name,compareFlags,ppResult)	\
    (This)->lpVtbl -> findFile(This,pCompiland,name,compareFlags,ppResult)

#define IDiaSession_findFileById(This,uniqueId,ppResult)	\
    (This)->lpVtbl -> findFileById(This,uniqueId,ppResult)

#define IDiaSession_findLines(This,compiland,file,ppResult)	\
    (This)->lpVtbl -> findLines(This,compiland,file,ppResult)

#define IDiaSession_findLinesByAddr(This,seg,offset,length,ppResult)	\
    (This)->lpVtbl -> findLinesByAddr(This,seg,offset,length,ppResult)

#define IDiaSession_findLinesByRVA(This,rva,length,ppResult)	\
    (This)->lpVtbl -> findLinesByRVA(This,rva,length,ppResult)

#define IDiaSession_findLinesByVA(This,va,length,ppResult)	\
    (This)->lpVtbl -> findLinesByVA(This,va,length,ppResult)

#define IDiaSession_findLinesByLinenum(This,compiland,file,linenum,column,ppResult)	\
    (This)->lpVtbl -> findLinesByLinenum(This,compiland,file,linenum,column,ppResult)

#define IDiaSession_findInjectedSource(This,srcFile,ppResult)	\
    (This)->lpVtbl -> findInjectedSource(This,srcFile,ppResult)

#define IDiaSession_getEnumDebugStreams(This,ppEnumDebugStreams)	\
    (This)->lpVtbl -> getEnumDebugStreams(This,ppEnumDebugStreams)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSession_get_loadAddress_Proxy( 
    IDiaSession * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSession_get_loadAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaSession_put_loadAddress_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG NewVal);


void __RPC_STUB IDiaSession_put_loadAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSession_get_globalScope_Proxy( 
    IDiaSession * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSession_get_globalScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_getEnumTables_Proxy( 
    IDiaSession * This,
    /* [out] */ IDiaEnumTables **ppEnumTables);


void __RPC_STUB IDiaSession_getEnumTables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_getSymbolsByAddr_Proxy( 
    IDiaSession * This,
    /* [out] */ IDiaEnumSymbolsByAddr **ppEnumbyAddr);


void __RPC_STUB IDiaSession_getSymbolsByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findChildren_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *parent,
    /* [in] */ enum SymTagEnum symtag,
    /* [in] */ LPCOLESTR name,
    /* [in] */ DWORD compareFlags,
    /* [out] */ IDiaEnumSymbols **ppResult);


void __RPC_STUB IDiaSession_findChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByAddr_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD isect,
    /* [in] */ DWORD offset,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByRVA_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD rva,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByVA_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByToken_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONG token,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_symsAreEquiv_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *symbolA,
    /* [in] */ IDiaSymbol *symbolB);


void __RPC_STUB IDiaSession_symsAreEquiv_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_symbolById_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD id,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_symbolById_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByRVAEx_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD rva,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol,
    /* [out] */ long *displacement);


void __RPC_STUB IDiaSession_findSymbolByRVAEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByVAEx_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol,
    /* [out] */ long *displacement);


void __RPC_STUB IDiaSession_findSymbolByVAEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findFile_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *pCompiland,
    /* [in] */ LPCOLESTR name,
    /* [in] */ DWORD compareFlags,
    /* [out] */ IDiaEnumSourceFiles **ppResult);


void __RPC_STUB IDiaSession_findFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findFileById_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD uniqueId,
    /* [out] */ IDiaSourceFile **ppResult);


void __RPC_STUB IDiaSession_findFileById_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLines_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *compiland,
    /* [in] */ IDiaSourceFile *file,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByAddr_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD seg,
    /* [in] */ DWORD offset,
    /* [in] */ DWORD length,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByRVA_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD rva,
    /* [in] */ DWORD length,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByVA_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ DWORD length,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByLinenum_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *compiland,
    /* [in] */ IDiaSourceFile *file,
    /* [in] */ DWORD linenum,
    /* [in] */ DWORD column,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByLinenum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findInjectedSource_Proxy( 
    IDiaSession * This,
    /* [in] */ LPCOLESTR srcFile,
    /* [out] */ IDiaEnumInjectedSources **ppResult);


void __RPC_STUB IDiaSession_findInjectedSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_getEnumDebugStreams_Proxy( 
    IDiaSession * This,
    /* [out] */ IDiaEnumDebugStreams **ppEnumDebugStreams);


void __RPC_STUB IDiaSession_getEnumDebugStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSession_INTERFACE_DEFINED__ */


#ifndef __IDiaSymbol_INTERFACE_DEFINED__
#define __IDiaSymbol_INTERFACE_DEFINED__

/* interface IDiaSymbol */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSymbol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72827A48-D320-4eaf-8436-548ADE47D5E5")
    IDiaSymbol : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_symIndexId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_symTag( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lexicalParent( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_classParent( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_dataKind( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_locationType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_registerId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_offset( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_slot( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_volatileType( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_constType( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_unalignedType( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_access( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_libraryName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_platform( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_language( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_editAndContinueEnabled( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frontEndMajor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frontEndMinor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frontEndBuild( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_backEndMajor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_backEndMinor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_backEndBuild( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceFileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_objectFileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_thunkOrdinal( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_thisAdjust( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBaseOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtual( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_intro( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_pure( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_callingConvention( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [retval][out] */ VARIANT *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_baseType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_token( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_timeStamp( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_guid( 
            /* [retval][out] */ GUID *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_symbolsFileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_reference( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_bitPosition( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_arrayIndexType( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_packed( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_constructor( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_overloadedOperator( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_nested( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasNestedTypes( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasAssignmentOperator( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasCastOperator( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_scoped( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBaseClass( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_indirectVirtualBaseClass( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBasePointerOffset( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualTableShape( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lexicalParentId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_classParentId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_typeId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_arrayIndexTypeId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualTableShapeId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_code( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_function( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_managed( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_msil( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBaseDispIndex( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_undecoratedName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_age( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_signature( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilerGenerated( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressTaken( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_rank( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lowerBound( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_upperBound( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lowerBoundId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_upperBoundId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_dataBytes( 
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findChildren( 
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetRelativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetVirtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_machineType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_oemId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_oemSymbolId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_types( 
            /* [in] */ DWORD cTypes,
            /* [out] */ DWORD *pcTypes,
            /* [length_is][size_is][out] */ IDiaSymbol *types[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_typeIds( 
            /* [in] */ DWORD cTypeIds,
            /* [out] */ DWORD *pcTypeIds,
            /* [length_is][size_is][out] */ DWORD typeIds[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSymbolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSymbol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSymbol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSymbol * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_symIndexId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_symTag )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lexicalParent )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_classParent )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataKind )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_locationType )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_registerId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_offset )( 
            IDiaSymbol * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaSymbol * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_slot )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_volatileType )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_constType )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_unalignedType )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_access )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_libraryName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_platform )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_language )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_editAndContinueEnabled )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frontEndMajor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frontEndMinor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frontEndBuild )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_backEndMajor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_backEndMinor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_backEndBuild )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceFileName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_objectFileName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_thunkOrdinal )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_thisAdjust )( 
            IDiaSymbol * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBaseOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtual )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_intro )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_pure )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_callingConvention )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_value )( 
            IDiaSymbol * This,
            /* [retval][out] */ VARIANT *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseType )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_token )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_timeStamp )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_guid )( 
            IDiaSymbol * This,
            /* [retval][out] */ GUID *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_symbolsFileName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_reference )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_count )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_bitPosition )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_arrayIndexType )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_packed )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_constructor )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_overloadedOperator )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nested )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasNestedTypes )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasAssignmentOperator )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasCastOperator )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_scoped )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBaseClass )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_indirectVirtualBaseClass )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBasePointerOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualTableShape )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lexicalParentId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_classParentId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_typeId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_arrayIndexTypeId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualTableShapeId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_code )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_function )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_managed )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_msil )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBaseDispIndex )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_undecoratedName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_age )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_signature )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilerGenerated )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressTaken )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_rank )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lowerBound )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_upperBound )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lowerBoundId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_upperBoundId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_dataBytes )( 
            IDiaSymbol * This,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *findChildren )( 
            IDiaSymbol * This,
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetSection )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetRelativeVirtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetVirtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_machineType )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_oemId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_oemSymbolId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_types )( 
            IDiaSymbol * This,
            /* [in] */ DWORD cTypes,
            /* [out] */ DWORD *pcTypes,
            /* [length_is][size_is][out] */ IDiaSymbol *types[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *get_typeIds )( 
            IDiaSymbol * This,
            /* [in] */ DWORD cTypeIds,
            /* [out] */ DWORD *pcTypeIds,
            /* [length_is][size_is][out] */ DWORD typeIds[  ]);
        
        END_INTERFACE
    } IDiaSymbolVtbl;

    interface IDiaSymbol
    {
        CONST_VTBL struct IDiaSymbolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSymbol_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSymbol_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSymbol_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSymbol_get_symIndexId(This,pRetVal)	\
    (This)->lpVtbl -> get_symIndexId(This,pRetVal)

#define IDiaSymbol_get_symTag(This,pRetVal)	\
    (This)->lpVtbl -> get_symTag(This,pRetVal)

#define IDiaSymbol_get_name(This,pRetVal)	\
    (This)->lpVtbl -> get_name(This,pRetVal)

#define IDiaSymbol_get_lexicalParent(This,pRetVal)	\
    (This)->lpVtbl -> get_lexicalParent(This,pRetVal)

#define IDiaSymbol_get_classParent(This,pRetVal)	\
    (This)->lpVtbl -> get_classParent(This,pRetVal)

#define IDiaSymbol_get_type(This,pRetVal)	\
    (This)->lpVtbl -> get_type(This,pRetVal)

#define IDiaSymbol_get_dataKind(This,pRetVal)	\
    (This)->lpVtbl -> get_dataKind(This,pRetVal)

#define IDiaSymbol_get_locationType(This,pRetVal)	\
    (This)->lpVtbl -> get_locationType(This,pRetVal)

#define IDiaSymbol_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaSymbol_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaSymbol_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaSymbol_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaSymbol_get_registerId(This,pRetVal)	\
    (This)->lpVtbl -> get_registerId(This,pRetVal)

#define IDiaSymbol_get_offset(This,pRetVal)	\
    (This)->lpVtbl -> get_offset(This,pRetVal)

#define IDiaSymbol_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaSymbol_get_slot(This,pRetVal)	\
    (This)->lpVtbl -> get_slot(This,pRetVal)

#define IDiaSymbol_get_volatileType(This,pRetVal)	\
    (This)->lpVtbl -> get_volatileType(This,pRetVal)

#define IDiaSymbol_get_constType(This,pRetVal)	\
    (This)->lpVtbl -> get_constType(This,pRetVal)

#define IDiaSymbol_get_unalignedType(This,pRetVal)	\
    (This)->lpVtbl -> get_unalignedType(This,pRetVal)

#define IDiaSymbol_get_access(This,pRetVal)	\
    (This)->lpVtbl -> get_access(This,pRetVal)

#define IDiaSymbol_get_libraryName(This,pRetVal)	\
    (This)->lpVtbl -> get_libraryName(This,pRetVal)

#define IDiaSymbol_get_platform(This,pRetVal)	\
    (This)->lpVtbl -> get_platform(This,pRetVal)

#define IDiaSymbol_get_language(This,pRetVal)	\
    (This)->lpVtbl -> get_language(This,pRetVal)

#define IDiaSymbol_get_editAndContinueEnabled(This,pRetVal)	\
    (This)->lpVtbl -> get_editAndContinueEnabled(This,pRetVal)

#define IDiaSymbol_get_frontEndMajor(This,pRetVal)	\
    (This)->lpVtbl -> get_frontEndMajor(This,pRetVal)

#define IDiaSymbol_get_frontEndMinor(This,pRetVal)	\
    (This)->lpVtbl -> get_frontEndMinor(This,pRetVal)

#define IDiaSymbol_get_frontEndBuild(This,pRetVal)	\
    (This)->lpVtbl -> get_frontEndBuild(This,pRetVal)

#define IDiaSymbol_get_backEndMajor(This,pRetVal)	\
    (This)->lpVtbl -> get_backEndMajor(This,pRetVal)

#define IDiaSymbol_get_backEndMinor(This,pRetVal)	\
    (This)->lpVtbl -> get_backEndMinor(This,pRetVal)

#define IDiaSymbol_get_backEndBuild(This,pRetVal)	\
    (This)->lpVtbl -> get_backEndBuild(This,pRetVal)

#define IDiaSymbol_get_sourceFileName(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceFileName(This,pRetVal)

#define IDiaSymbol_get_objectFileName(This,pRetVal)	\
    (This)->lpVtbl -> get_objectFileName(This,pRetVal)

#define IDiaSymbol_get_thunkOrdinal(This,pRetVal)	\
    (This)->lpVtbl -> get_thunkOrdinal(This,pRetVal)

#define IDiaSymbol_get_thisAdjust(This,pRetVal)	\
    (This)->lpVtbl -> get_thisAdjust(This,pRetVal)

#define IDiaSymbol_get_virtualBaseOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBaseOffset(This,pRetVal)

#define IDiaSymbol_get_virtual(This,pRetVal)	\
    (This)->lpVtbl -> get_virtual(This,pRetVal)

#define IDiaSymbol_get_intro(This,pRetVal)	\
    (This)->lpVtbl -> get_intro(This,pRetVal)

#define IDiaSymbol_get_pure(This,pRetVal)	\
    (This)->lpVtbl -> get_pure(This,pRetVal)

#define IDiaSymbol_get_callingConvention(This,pRetVal)	\
    (This)->lpVtbl -> get_callingConvention(This,pRetVal)

#define IDiaSymbol_get_value(This,pRetVal)	\
    (This)->lpVtbl -> get_value(This,pRetVal)

#define IDiaSymbol_get_baseType(This,pRetVal)	\
    (This)->lpVtbl -> get_baseType(This,pRetVal)

#define IDiaSymbol_get_token(This,pRetVal)	\
    (This)->lpVtbl -> get_token(This,pRetVal)

#define IDiaSymbol_get_timeStamp(This,pRetVal)	\
    (This)->lpVtbl -> get_timeStamp(This,pRetVal)

#define IDiaSymbol_get_guid(This,pRetVal)	\
    (This)->lpVtbl -> get_guid(This,pRetVal)

#define IDiaSymbol_get_symbolsFileName(This,pRetVal)	\
    (This)->lpVtbl -> get_symbolsFileName(This,pRetVal)

#define IDiaSymbol_get_reference(This,pRetVal)	\
    (This)->lpVtbl -> get_reference(This,pRetVal)

#define IDiaSymbol_get_count(This,pRetVal)	\
    (This)->lpVtbl -> get_count(This,pRetVal)

#define IDiaSymbol_get_bitPosition(This,pRetVal)	\
    (This)->lpVtbl -> get_bitPosition(This,pRetVal)

#define IDiaSymbol_get_arrayIndexType(This,pRetVal)	\
    (This)->lpVtbl -> get_arrayIndexType(This,pRetVal)

#define IDiaSymbol_get_packed(This,pRetVal)	\
    (This)->lpVtbl -> get_packed(This,pRetVal)

#define IDiaSymbol_get_constructor(This,pRetVal)	\
    (This)->lpVtbl -> get_constructor(This,pRetVal)

#define IDiaSymbol_get_overloadedOperator(This,pRetVal)	\
    (This)->lpVtbl -> get_overloadedOperator(This,pRetVal)

#define IDiaSymbol_get_nested(This,pRetVal)	\
    (This)->lpVtbl -> get_nested(This,pRetVal)

#define IDiaSymbol_get_hasNestedTypes(This,pRetVal)	\
    (This)->lpVtbl -> get_hasNestedTypes(This,pRetVal)

#define IDiaSymbol_get_hasAssignmentOperator(This,pRetVal)	\
    (This)->lpVtbl -> get_hasAssignmentOperator(This,pRetVal)

#define IDiaSymbol_get_hasCastOperator(This,pRetVal)	\
    (This)->lpVtbl -> get_hasCastOperator(This,pRetVal)

#define IDiaSymbol_get_scoped(This,pRetVal)	\
    (This)->lpVtbl -> get_scoped(This,pRetVal)

#define IDiaSymbol_get_virtualBaseClass(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBaseClass(This,pRetVal)

#define IDiaSymbol_get_indirectVirtualBaseClass(This,pRetVal)	\
    (This)->lpVtbl -> get_indirectVirtualBaseClass(This,pRetVal)

#define IDiaSymbol_get_virtualBasePointerOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBasePointerOffset(This,pRetVal)

#define IDiaSymbol_get_virtualTableShape(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualTableShape(This,pRetVal)

#define IDiaSymbol_get_lexicalParentId(This,pRetVal)	\
    (This)->lpVtbl -> get_lexicalParentId(This,pRetVal)

#define IDiaSymbol_get_classParentId(This,pRetVal)	\
    (This)->lpVtbl -> get_classParentId(This,pRetVal)

#define IDiaSymbol_get_typeId(This,pRetVal)	\
    (This)->lpVtbl -> get_typeId(This,pRetVal)

#define IDiaSymbol_get_arrayIndexTypeId(This,pRetVal)	\
    (This)->lpVtbl -> get_arrayIndexTypeId(This,pRetVal)

#define IDiaSymbol_get_virtualTableShapeId(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualTableShapeId(This,pRetVal)

#define IDiaSymbol_get_code(This,pRetVal)	\
    (This)->lpVtbl -> get_code(This,pRetVal)

#define IDiaSymbol_get_function(This,pRetVal)	\
    (This)->lpVtbl -> get_function(This,pRetVal)

#define IDiaSymbol_get_managed(This,pRetVal)	\
    (This)->lpVtbl -> get_managed(This,pRetVal)

#define IDiaSymbol_get_msil(This,pRetVal)	\
    (This)->lpVtbl -> get_msil(This,pRetVal)

#define IDiaSymbol_get_virtualBaseDispIndex(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBaseDispIndex(This,pRetVal)

#define IDiaSymbol_get_undecoratedName(This,pRetVal)	\
    (This)->lpVtbl -> get_undecoratedName(This,pRetVal)

#define IDiaSymbol_get_age(This,pRetVal)	\
    (This)->lpVtbl -> get_age(This,pRetVal)

#define IDiaSymbol_get_signature(This,pRetVal)	\
    (This)->lpVtbl -> get_signature(This,pRetVal)

#define IDiaSymbol_get_compilerGenerated(This,pRetVal)	\
    (This)->lpVtbl -> get_compilerGenerated(This,pRetVal)

#define IDiaSymbol_get_addressTaken(This,pRetVal)	\
    (This)->lpVtbl -> get_addressTaken(This,pRetVal)

#define IDiaSymbol_get_rank(This,pRetVal)	\
    (This)->lpVtbl -> get_rank(This,pRetVal)

#define IDiaSymbol_get_lowerBound(This,pRetVal)	\
    (This)->lpVtbl -> get_lowerBound(This,pRetVal)

#define IDiaSymbol_get_upperBound(This,pRetVal)	\
    (This)->lpVtbl -> get_upperBound(This,pRetVal)

#define IDiaSymbol_get_lowerBoundId(This,pRetVal)	\
    (This)->lpVtbl -> get_lowerBoundId(This,pRetVal)

#define IDiaSymbol_get_upperBoundId(This,pRetVal)	\
    (This)->lpVtbl -> get_upperBoundId(This,pRetVal)

#define IDiaSymbol_get_dataBytes(This,cbData,pcbData,data)	\
    (This)->lpVtbl -> get_dataBytes(This,cbData,pcbData,data)

#define IDiaSymbol_findChildren(This,symtag,name,compareFlags,ppResult)	\
    (This)->lpVtbl -> findChildren(This,symtag,name,compareFlags,ppResult)

#define IDiaSymbol_get_targetSection(This,pRetVal)	\
    (This)->lpVtbl -> get_targetSection(This,pRetVal)

#define IDiaSymbol_get_targetOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_targetOffset(This,pRetVal)

#define IDiaSymbol_get_targetRelativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_targetRelativeVirtualAddress(This,pRetVal)

#define IDiaSymbol_get_targetVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_targetVirtualAddress(This,pRetVal)

#define IDiaSymbol_get_machineType(This,pRetVal)	\
    (This)->lpVtbl -> get_machineType(This,pRetVal)

#define IDiaSymbol_get_oemId(This,pRetVal)	\
    (This)->lpVtbl -> get_oemId(This,pRetVal)

#define IDiaSymbol_get_oemSymbolId(This,pRetVal)	\
    (This)->lpVtbl -> get_oemSymbolId(This,pRetVal)

#define IDiaSymbol_get_types(This,cTypes,pcTypes,types)	\
    (This)->lpVtbl -> get_types(This,cTypes,pcTypes,types)

#define IDiaSymbol_get_typeIds(This,cTypeIds,pcTypeIds,typeIds)	\
    (This)->lpVtbl -> get_typeIds(This,cTypeIds,pcTypeIds,typeIds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_symIndexId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_symIndexId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_symTag_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_symTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_name_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lexicalParent_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_lexicalParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_classParent_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_classParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_type_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_dataKind_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_dataKind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_locationType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_locationType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_addressSection_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_addressOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_relativeVirtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_registerId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_registerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_offset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_offset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_length_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_slot_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_slot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_volatileType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_volatileType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_constType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_constType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_unalignedType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_unalignedType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_access_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_access_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_libraryName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_libraryName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_platform_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_platform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_language_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_editAndContinueEnabled_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_editAndContinueEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_frontEndMajor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_frontEndMajor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_frontEndMinor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_frontEndMinor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_frontEndBuild_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_frontEndBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_backEndMajor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_backEndMajor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_backEndMinor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_backEndMinor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_backEndBuild_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_backEndBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_sourceFileName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_sourceFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_objectFileName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_objectFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_thunkOrdinal_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_thunkOrdinal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_thisAdjust_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_thisAdjust_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBaseOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBaseOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtual_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_intro_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_intro_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_pure_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_pure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_callingConvention_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_callingConvention_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_value_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ VARIANT *pRetVal);


void __RPC_STUB IDiaSymbol_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_baseType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_baseType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_token_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_token_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_timeStamp_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_timeStamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_guid_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ GUID *pRetVal);


void __RPC_STUB IDiaSymbol_get_guid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_symbolsFileName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_symbolsFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_reference_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_reference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_count_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_bitPosition_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_bitPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_arrayIndexType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_arrayIndexType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_packed_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_packed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_constructor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_constructor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_overloadedOperator_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_overloadedOperator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_nested_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_nested_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasNestedTypes_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasNestedTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasAssignmentOperator_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasAssignmentOperator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasCastOperator_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasCastOperator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_scoped_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_scoped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBaseClass_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBaseClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_indirectVirtualBaseClass_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_indirectVirtualBaseClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBasePointerOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBasePointerOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualTableShape_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualTableShape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lexicalParentId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_lexicalParentId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_classParentId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_classParentId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_typeId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_typeId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_arrayIndexTypeId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_arrayIndexTypeId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualTableShapeId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualTableShapeId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_code_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_code_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_function_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_function_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_managed_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_managed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_msil_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_msil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBaseDispIndex_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBaseDispIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_undecoratedName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_undecoratedName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_age_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_age_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_signature_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_signature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_compilerGenerated_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_compilerGenerated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_addressTaken_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_addressTaken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_rank_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_rank_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lowerBound_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_lowerBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_upperBound_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_upperBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lowerBoundId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_lowerBoundId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_upperBoundId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_upperBoundId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_dataBytes_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaSymbol_get_dataBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_findChildren_Proxy( 
    IDiaSymbol * This,
    /* [in] */ enum SymTagEnum symtag,
    /* [in] */ LPCOLESTR name,
    /* [in] */ DWORD compareFlags,
    /* [out] */ IDiaEnumSymbols **ppResult);


void __RPC_STUB IDiaSymbol_findChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetSection_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetRelativeVirtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetRelativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetVirtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_machineType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_machineType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_oemId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_oemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_oemSymbolId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_oemSymbolId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_types_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD cTypes,
    /* [out] */ DWORD *pcTypes,
    /* [length_is][size_is][out] */ IDiaSymbol *types[  ]);


void __RPC_STUB IDiaSymbol_get_types_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_typeIds_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD cTypeIds,
    /* [out] */ DWORD *pcTypeIds,
    /* [length_is][size_is][out] */ DWORD typeIds[  ]);


void __RPC_STUB IDiaSymbol_get_typeIds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSymbol_INTERFACE_DEFINED__ */


#ifndef __IDiaSourceFile_INTERFACE_DEFINED__
#define __IDiaSourceFile_INTERFACE_DEFINED__

/* interface IDiaSourceFile */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSourceFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A2EF5353-F5A8-4eb3-90D2-CB526ACB3CDD")
    IDiaSourceFile : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_uniqueId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_fileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_checksumType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilands( 
            /* [retval][out] */ IDiaEnumSymbols **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_checksum( 
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSourceFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSourceFile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSourceFile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSourceFile * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_uniqueId )( 
            IDiaSourceFile * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileName )( 
            IDiaSourceFile * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_checksumType )( 
            IDiaSourceFile * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilands )( 
            IDiaSourceFile * This,
            /* [retval][out] */ IDiaEnumSymbols **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_checksum )( 
            IDiaSourceFile * This,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        END_INTERFACE
    } IDiaSourceFileVtbl;

    interface IDiaSourceFile
    {
        CONST_VTBL struct IDiaSourceFileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSourceFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSourceFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSourceFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSourceFile_get_uniqueId(This,pRetVal)	\
    (This)->lpVtbl -> get_uniqueId(This,pRetVal)

#define IDiaSourceFile_get_fileName(This,pRetVal)	\
    (This)->lpVtbl -> get_fileName(This,pRetVal)

#define IDiaSourceFile_get_checksumType(This,pRetVal)	\
    (This)->lpVtbl -> get_checksumType(This,pRetVal)

#define IDiaSourceFile_get_compilands(This,pRetVal)	\
    (This)->lpVtbl -> get_compilands(This,pRetVal)

#define IDiaSourceFile_get_checksum(This,cbData,pcbData,data)	\
    (This)->lpVtbl -> get_checksum(This,cbData,pcbData,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_uniqueId_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSourceFile_get_uniqueId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_fileName_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSourceFile_get_fileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_checksumType_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSourceFile_get_checksumType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_compilands_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ IDiaEnumSymbols **pRetVal);


void __RPC_STUB IDiaSourceFile_get_compilands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_checksum_Proxy( 
    IDiaSourceFile * This,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaSourceFile_get_checksum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSourceFile_INTERFACE_DEFINED__ */


#ifndef __IDiaLineNumber_INTERFACE_DEFINED__
#define __IDiaLineNumber_INTERFACE_DEFINED__

/* interface IDiaLineNumber */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaLineNumber;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B388EB14-BE4D-421d-A8A1-6CF7AB057086")
    IDiaLineNumber : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compiland( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceFile( 
            /* [retval][out] */ IDiaSourceFile **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lineNumber( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lineNumberEnd( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_columnNumber( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_columnNumberEnd( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceFileId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_statement( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilandId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaLineNumberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaLineNumber * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaLineNumber * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaLineNumber * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compiland )( 
            IDiaLineNumber * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceFile )( 
            IDiaLineNumber * This,
            /* [retval][out] */ IDiaSourceFile **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lineNumber )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lineNumberEnd )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnNumber )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnNumberEnd )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaLineNumber * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceFileId )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_statement )( 
            IDiaLineNumber * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilandId )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        END_INTERFACE
    } IDiaLineNumberVtbl;

    interface IDiaLineNumber
    {
        CONST_VTBL struct IDiaLineNumberVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaLineNumber_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaLineNumber_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaLineNumber_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaLineNumber_get_compiland(This,pRetVal)	\
    (This)->lpVtbl -> get_compiland(This,pRetVal)

#define IDiaLineNumber_get_sourceFile(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceFile(This,pRetVal)

#define IDiaLineNumber_get_lineNumber(This,pRetVal)	\
    (This)->lpVtbl -> get_lineNumber(This,pRetVal)

#define IDiaLineNumber_get_lineNumberEnd(This,pRetVal)	\
    (This)->lpVtbl -> get_lineNumberEnd(This,pRetVal)

#define IDiaLineNumber_get_columnNumber(This,pRetVal)	\
    (This)->lpVtbl -> get_columnNumber(This,pRetVal)

#define IDiaLineNumber_get_columnNumberEnd(This,pRetVal)	\
    (This)->lpVtbl -> get_columnNumberEnd(This,pRetVal)

#define IDiaLineNumber_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaLineNumber_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaLineNumber_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaLineNumber_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaLineNumber_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaLineNumber_get_sourceFileId(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceFileId(This,pRetVal)

#define IDiaLineNumber_get_statement(This,pRetVal)	\
    (This)->lpVtbl -> get_statement(This,pRetVal)

#define IDiaLineNumber_get_compilandId(This,pRetVal)	\
    (This)->lpVtbl -> get_compilandId(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_compiland_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaLineNumber_get_compiland_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_sourceFile_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ IDiaSourceFile **pRetVal);


void __RPC_STUB IDiaLineNumber_get_sourceFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_lineNumber_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_lineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_lineNumberEnd_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_lineNumberEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_columnNumber_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_columnNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_columnNumberEnd_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_columnNumberEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_addressSection_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_addressOffset_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_relativeVirtualAddress_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_virtualAddress_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaLineNumber_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_length_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_sourceFileId_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_sourceFileId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_statement_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaLineNumber_get_statement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_compilandId_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_compilandId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaLineNumber_INTERFACE_DEFINED__ */


#ifndef __IDiaSectionContrib_INTERFACE_DEFINED__
#define __IDiaSectionContrib_INTERFACE_DEFINED__

/* interface IDiaSectionContrib */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSectionContrib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0CF4B60E-35B1-4c6c-BDD8-854B9C8E3857")
    IDiaSectionContrib : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compiland( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_notPaged( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_code( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_initializedData( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_uninitializedData( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_remove( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_comdat( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_discardable( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_notCached( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_share( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_execute( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_read( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_write( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_dataCrc( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relocationsCrc( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilandId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSectionContribVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSectionContrib * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSectionContrib * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSectionContrib * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compiland )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_notPaged )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_code )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_initializedData )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_uninitializedData )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_remove )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_comdat )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_discardable )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_notCached )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_share )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_execute )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_read )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_write )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataCrc )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relocationsCrc )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilandId )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        END_INTERFACE
    } IDiaSectionContribVtbl;

    interface IDiaSectionContrib
    {
        CONST_VTBL struct IDiaSectionContribVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSectionContrib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSectionContrib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSectionContrib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSectionContrib_get_compiland(This,pRetVal)	\
    (This)->lpVtbl -> get_compiland(This,pRetVal)

#define IDiaSectionContrib_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaSectionContrib_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaSectionContrib_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaSectionContrib_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaSectionContrib_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaSectionContrib_get_notPaged(This,pRetVal)	\
    (This)->lpVtbl -> get_notPaged(This,pRetVal)

#define IDiaSectionContrib_get_code(This,pRetVal)	\
    (This)->lpVtbl -> get_code(This,pRetVal)

#define IDiaSectionContrib_get_initializedData(This,pRetVal)	\
    (This)->lpVtbl -> get_initializedData(This,pRetVal)

#define IDiaSectionContrib_get_uninitializedData(This,pRetVal)	\
    (This)->lpVtbl -> get_uninitializedData(This,pRetVal)

#define IDiaSectionContrib_get_remove(This,pRetVal)	\
    (This)->lpVtbl -> get_remove(This,pRetVal)

#define IDiaSectionContrib_get_comdat(This,pRetVal)	\
    (This)->lpVtbl -> get_comdat(This,pRetVal)

#define IDiaSectionContrib_get_discardable(This,pRetVal)	\
    (This)->lpVtbl -> get_discardable(This,pRetVal)

#define IDiaSectionContrib_get_notCached(This,pRetVal)	\
    (This)->lpVtbl -> get_notCached(This,pRetVal)

#define IDiaSectionContrib_get_share(This,pRetVal)	\
    (This)->lpVtbl -> get_share(This,pRetVal)

#define IDiaSectionContrib_get_execute(This,pRetVal)	\
    (This)->lpVtbl -> get_execute(This,pRetVal)

#define IDiaSectionContrib_get_read(This,pRetVal)	\
    (This)->lpVtbl -> get_read(This,pRetVal)

#define IDiaSectionContrib_get_write(This,pRetVal)	\
    (This)->lpVtbl -> get_write(This,pRetVal)

#define IDiaSectionContrib_get_dataCrc(This,pRetVal)	\
    (This)->lpVtbl -> get_dataCrc(This,pRetVal)

#define IDiaSectionContrib_get_relocationsCrc(This,pRetVal)	\
    (This)->lpVtbl -> get_relocationsCrc(This,pRetVal)

#define IDiaSectionContrib_get_compilandId(This,pRetVal)	\
    (This)->lpVtbl -> get_compilandId(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_compiland_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSectionContrib_get_compiland_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_addressSection_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_addressOffset_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_relativeVirtualAddress_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_virtualAddress_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_length_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_notPaged_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_notPaged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_code_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_code_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_initializedData_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_initializedData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_uninitializedData_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_uninitializedData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_remove_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_comdat_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_comdat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_discardable_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_discardable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_notCached_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_notCached_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_share_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_share_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_execute_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_read_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_write_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_dataCrc_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_dataCrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_relocationsCrc_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_relocationsCrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_compilandId_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_compilandId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSectionContrib_INTERFACE_DEFINED__ */


#ifndef __IDiaSegment_INTERFACE_DEFINED__
#define __IDiaSegment_INTERFACE_DEFINED__

/* interface IDiaSegment */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSegment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0775B784-C75B-4449-848B-B7BD3159545B")
    IDiaSegment : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frame( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_offset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_read( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_write( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_execute( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSegmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSegment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSegment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSegment * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frame )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_offset )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_read )( 
            IDiaSegment * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_write )( 
            IDiaSegment * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_execute )( 
            IDiaSegment * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaSegment * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        END_INTERFACE
    } IDiaSegmentVtbl;

    interface IDiaSegment
    {
        CONST_VTBL struct IDiaSegmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSegment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSegment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSegment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSegment_get_frame(This,pRetVal)	\
    (This)->lpVtbl -> get_frame(This,pRetVal)

#define IDiaSegment_get_offset(This,pRetVal)	\
    (This)->lpVtbl -> get_offset(This,pRetVal)

#define IDiaSegment_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaSegment_get_read(This,pRetVal)	\
    (This)->lpVtbl -> get_read(This,pRetVal)

#define IDiaSegment_get_write(This,pRetVal)	\
    (This)->lpVtbl -> get_write(This,pRetVal)

#define IDiaSegment_get_execute(This,pRetVal)	\
    (This)->lpVtbl -> get_execute(This,pRetVal)

#define IDiaSegment_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaSegment_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaSegment_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_frame_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_frame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_offset_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_offset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_length_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_read_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSegment_get_read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_write_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSegment_get_write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_execute_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSegment_get_execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_addressSection_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_relativeVirtualAddress_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_virtualAddress_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSegment_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSegment_INTERFACE_DEFINED__ */


#ifndef __IDiaInjectedSource_INTERFACE_DEFINED__
#define __IDiaInjectedSource_INTERFACE_DEFINED__

/* interface IDiaInjectedSource */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaInjectedSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE605CDC-8105-4a23-B710-3259F1E26112")
    IDiaInjectedSource : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_crc( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_filename( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_objectFilename( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualFilename( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceCompression( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_source( 
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaInjectedSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaInjectedSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaInjectedSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaInjectedSource * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_crc )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_filename )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_objectFilename )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualFilename )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceCompression )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_source )( 
            IDiaInjectedSource * This,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        END_INTERFACE
    } IDiaInjectedSourceVtbl;

    interface IDiaInjectedSource
    {
        CONST_VTBL struct IDiaInjectedSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaInjectedSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaInjectedSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaInjectedSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaInjectedSource_get_crc(This,pRetVal)	\
    (This)->lpVtbl -> get_crc(This,pRetVal)

#define IDiaInjectedSource_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaInjectedSource_get_filename(This,pRetVal)	\
    (This)->lpVtbl -> get_filename(This,pRetVal)

#define IDiaInjectedSource_get_objectFilename(This,pRetVal)	\
    (This)->lpVtbl -> get_objectFilename(This,pRetVal)

#define IDiaInjectedSource_get_virtualFilename(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualFilename(This,pRetVal)

#define IDiaInjectedSource_get_sourceCompression(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceCompression(This,pRetVal)

#define IDiaInjectedSource_get_source(This,cbData,pcbData,data)	\
    (This)->lpVtbl -> get_source(This,cbData,pcbData,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_crc_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_crc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_length_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_filename_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_filename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_objectFilename_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_objectFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_virtualFilename_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_virtualFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_sourceCompression_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_sourceCompression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_source_Proxy( 
    IDiaInjectedSource * This,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaInjectedSource_get_source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaInjectedSource_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dia2_0131 */
/* [local] */ 


enum __MIDL___MIDL_itf_dia2_0131_0001
    {	E_DIA_INPROLOG	= ( HRESULT  )(( unsigned long  )1 << 31 | ( unsigned long  )( LONG  )0x6d << 16 | ( unsigned long  )100),
	E_DIA_SYNTAX	= E_DIA_INPROLOG + 1,
	E_DIA_FRAME_ACCESS	= E_DIA_SYNTAX + 1,
	E_DIA_VALUE	= E_DIA_FRAME_ACCESS + 1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_dia2_0131_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_0131_v0_0_s_ifspec;

#ifndef __IDiaStackWalkFrame_INTERFACE_DEFINED__
#define __IDiaStackWalkFrame_INTERFACE_DEFINED__

/* interface IDiaStackWalkFrame */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaStackWalkFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97F0F1A6-E04E-4ea4-B4F9-B0D0E8D90F5D")
    IDiaStackWalkFrame : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_registerValue( 
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_registerValue( 
            /* [in] */ DWORD index,
            /* [in] */ ULONGLONG NewVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE readMemory( 
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE searchForReturnAddress( 
            /* [in] */ IDiaFrameData *frame,
            /* [out] */ ULONGLONG *returnAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE searchForReturnAddressStart( 
            /* [in] */ IDiaFrameData *frame,
            /* [in] */ ULONGLONG startAddress,
            /* [out] */ ULONGLONG *returnAddress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaStackWalkFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaStackWalkFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaStackWalkFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaStackWalkFrame * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_registerValue )( 
            IDiaStackWalkFrame * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_registerValue )( 
            IDiaStackWalkFrame * This,
            /* [in] */ DWORD index,
            /* [in] */ ULONGLONG NewVal);
        
        HRESULT ( STDMETHODCALLTYPE *readMemory )( 
            IDiaStackWalkFrame * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddress )( 
            IDiaStackWalkFrame * This,
            /* [in] */ IDiaFrameData *frame,
            /* [out] */ ULONGLONG *returnAddress);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddressStart )( 
            IDiaStackWalkFrame * This,
            /* [in] */ IDiaFrameData *frame,
            /* [in] */ ULONGLONG startAddress,
            /* [out] */ ULONGLONG *returnAddress);
        
        END_INTERFACE
    } IDiaStackWalkFrameVtbl;

    interface IDiaStackWalkFrame
    {
        CONST_VTBL struct IDiaStackWalkFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaStackWalkFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaStackWalkFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaStackWalkFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaStackWalkFrame_get_registerValue(This,index,pRetVal)	\
    (This)->lpVtbl -> get_registerValue(This,index,pRetVal)

#define IDiaStackWalkFrame_put_registerValue(This,index,NewVal)	\
    (This)->lpVtbl -> put_registerValue(This,index,NewVal)

#define IDiaStackWalkFrame_readMemory(This,va,cbData,pcbData,data)	\
    (This)->lpVtbl -> readMemory(This,va,cbData,pcbData,data)

#define IDiaStackWalkFrame_searchForReturnAddress(This,frame,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddress(This,frame,returnAddress)

#define IDiaStackWalkFrame_searchForReturnAddressStart(This,frame,startAddress,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddressStart(This,frame,startAddress,returnAddress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_get_registerValue_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaStackWalkFrame_get_registerValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_put_registerValue_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ DWORD index,
    /* [in] */ ULONGLONG NewVal);


void __RPC_STUB IDiaStackWalkFrame_put_registerValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_readMemory_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaStackWalkFrame_readMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_searchForReturnAddress_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ IDiaFrameData *frame,
    /* [out] */ ULONGLONG *returnAddress);


void __RPC_STUB IDiaStackWalkFrame_searchForReturnAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_searchForReturnAddressStart_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ IDiaFrameData *frame,
    /* [in] */ ULONGLONG startAddress,
    /* [out] */ ULONGLONG *returnAddress);


void __RPC_STUB IDiaStackWalkFrame_searchForReturnAddressStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaStackWalkFrame_INTERFACE_DEFINED__ */


#ifndef __IDiaFrameData_INTERFACE_DEFINED__
#define __IDiaFrameData_INTERFACE_DEFINED__

/* interface IDiaFrameData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaFrameData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A39184B7-6A36-42de-8EEC-7DF9F3F59F33")
    IDiaFrameData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthBlock( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthLocals( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthParams( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_maxStack( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthProlog( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthSavedRegisters( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_program( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_systemExceptionHandling( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_cplusplusExceptionHandling( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_functionStart( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_allocatesBasePointer( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_functionParent( 
            /* [retval][out] */ IDiaFrameData **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE execute( 
            IDiaStackWalkFrame *frame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaFrameDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaFrameData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaFrameData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaFrameData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaFrameData * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthBlock )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthLocals )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthParams )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_maxStack )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthProlog )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthSavedRegisters )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_program )( 
            IDiaFrameData * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_systemExceptionHandling )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_cplusplusExceptionHandling )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_functionStart )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_allocatesBasePointer )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_functionParent )( 
            IDiaFrameData * This,
            /* [retval][out] */ IDiaFrameData **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *execute )( 
            IDiaFrameData * This,
            IDiaStackWalkFrame *frame);
        
        END_INTERFACE
    } IDiaFrameDataVtbl;

    interface IDiaFrameData
    {
        CONST_VTBL struct IDiaFrameDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaFrameData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaFrameData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaFrameData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaFrameData_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaFrameData_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaFrameData_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaFrameData_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaFrameData_get_lengthBlock(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthBlock(This,pRetVal)

#define IDiaFrameData_get_lengthLocals(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthLocals(This,pRetVal)

#define IDiaFrameData_get_lengthParams(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthParams(This,pRetVal)

#define IDiaFrameData_get_maxStack(This,pRetVal)	\
    (This)->lpVtbl -> get_maxStack(This,pRetVal)

#define IDiaFrameData_get_lengthProlog(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthProlog(This,pRetVal)

#define IDiaFrameData_get_lengthSavedRegisters(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthSavedRegisters(This,pRetVal)

#define IDiaFrameData_get_program(This,pRetVal)	\
    (This)->lpVtbl -> get_program(This,pRetVal)

#define IDiaFrameData_get_systemExceptionHandling(This,pRetVal)	\
    (This)->lpVtbl -> get_systemExceptionHandling(This,pRetVal)

#define IDiaFrameData_get_cplusplusExceptionHandling(This,pRetVal)	\
    (This)->lpVtbl -> get_cplusplusExceptionHandling(This,pRetVal)

#define IDiaFrameData_get_functionStart(This,pRetVal)	\
    (This)->lpVtbl -> get_functionStart(This,pRetVal)

#define IDiaFrameData_get_allocatesBasePointer(This,pRetVal)	\
    (This)->lpVtbl -> get_allocatesBasePointer(This,pRetVal)

#define IDiaFrameData_get_type(This,pRetVal)	\
    (This)->lpVtbl -> get_type(This,pRetVal)

#define IDiaFrameData_get_functionParent(This,pRetVal)	\
    (This)->lpVtbl -> get_functionParent(This,pRetVal)

#define IDiaFrameData_execute(This,frame)	\
    (This)->lpVtbl -> execute(This,frame)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_addressSection_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_addressOffset_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_relativeVirtualAddress_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_virtualAddress_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaFrameData_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthBlock_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthLocals_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthLocals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthParams_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_maxStack_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_maxStack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthProlog_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthProlog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthSavedRegisters_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthSavedRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_program_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaFrameData_get_program_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_systemExceptionHandling_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_systemExceptionHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_cplusplusExceptionHandling_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_cplusplusExceptionHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_functionStart_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_functionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_allocatesBasePointer_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_allocatesBasePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_type_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_functionParent_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ IDiaFrameData **pRetVal);


void __RPC_STUB IDiaFrameData_get_functionParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaFrameData_execute_Proxy( 
    IDiaFrameData * This,
    IDiaStackWalkFrame *frame);


void __RPC_STUB IDiaFrameData_execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaFrameData_INTERFACE_DEFINED__ */


#ifndef __IDiaImageData_INTERFACE_DEFINED__
#define __IDiaImageData_INTERFACE_DEFINED__

/* interface IDiaImageData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaImageData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C8E40ED2-A1D9-4221-8692-3CE661184B44")
    IDiaImageData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_imageBase( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaImageDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaImageData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaImageData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaImageData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaImageData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaImageData * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_imageBase )( 
            IDiaImageData * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        END_INTERFACE
    } IDiaImageDataVtbl;

    interface IDiaImageData
    {
        CONST_VTBL struct IDiaImageDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaImageData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaImageData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaImageData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaImageData_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaImageData_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaImageData_get_imageBase(This,pRetVal)	\
    (This)->lpVtbl -> get_imageBase(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaImageData_get_relativeVirtualAddress_Proxy( 
    IDiaImageData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaImageData_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaImageData_get_virtualAddress_Proxy( 
    IDiaImageData * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaImageData_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaImageData_get_imageBase_Proxy( 
    IDiaImageData * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaImageData_get_imageBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaImageData_INTERFACE_DEFINED__ */


#ifndef __IDiaTable_INTERFACE_DEFINED__
#define __IDiaTable_INTERFACE_DEFINED__

/* interface IDiaTable */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4A59FB77-ABAC-469b-A30B-9ECC85BFEF14")
    IDiaTable : public IEnumUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IUnknown **element) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaTable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaTable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaTable * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaTable * This,
            /* [in] */ ULONG celt,
            /* [out] */ IUnknown **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaTable * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaTable * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaTable * This,
            /* [out] */ IEnumUnknown **ppenum);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaTable * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IDiaTable * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaTable * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaTable * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IUnknown **element);
        
        END_INTERFACE
    } IDiaTableVtbl;

    interface IDiaTable
    {
        CONST_VTBL struct IDiaTableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaTable_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaTable_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaTable_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaTable_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)


#define IDiaTable_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaTable_get_name(This,pRetVal)	\
    (This)->lpVtbl -> get_name(This,pRetVal)

#define IDiaTable_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaTable_Item(This,index,element)	\
    (This)->lpVtbl -> Item(This,index,element)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaTable_get__NewEnum_Proxy( 
    IDiaTable * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaTable_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaTable_get_name_Proxy( 
    IDiaTable * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaTable_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaTable_get_Count_Proxy( 
    IDiaTable * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaTable_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaTable_Item_Proxy( 
    IDiaTable * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IUnknown **element);


void __RPC_STUB IDiaTable_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaTable_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumTables_INTERFACE_DEFINED__
#define __IDiaEnumTables_INTERFACE_DEFINED__

/* interface IDiaEnumTables */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumTables;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C65C2B0A-1150-4d7a-AFCC-E05BF3DEE81E")
    IDiaEnumTables : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaTable **table) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            ULONG celt,
            IDiaTable **rgelt,
            ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumTables **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumTablesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumTables * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumTables * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumTables * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumTables * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumTables * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumTables * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaTable **table);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumTables * This,
            ULONG celt,
            IDiaTable **rgelt,
            ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumTables * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumTables * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumTables * This,
            /* [out] */ IDiaEnumTables **ppenum);
        
        END_INTERFACE
    } IDiaEnumTablesVtbl;

    interface IDiaEnumTables
    {
        CONST_VTBL struct IDiaEnumTablesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumTables_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumTables_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumTables_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumTables_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumTables_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumTables_Item(This,index,table)	\
    (This)->lpVtbl -> Item(This,index,table)

#define IDiaEnumTables_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumTables_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumTables_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumTables_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumTables_get__NewEnum_Proxy( 
    IDiaEnumTables * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumTables_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumTables_get_Count_Proxy( 
    IDiaEnumTables * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumTables_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumTables_Item_Proxy( 
    IDiaEnumTables * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ IDiaTable **table);


void __RPC_STUB IDiaEnumTables_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Next_Proxy( 
    IDiaEnumTables * This,
    ULONG celt,
    IDiaTable **rgelt,
    ULONG *pceltFetched);


void __RPC_STUB IDiaEnumTables_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Skip_Proxy( 
    IDiaEnumTables * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumTables_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Reset_Proxy( 
    IDiaEnumTables * This);


void __RPC_STUB IDiaEnumTables_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Clone_Proxy( 
    IDiaEnumTables * This,
    /* [out] */ IDiaEnumTables **ppenum);


void __RPC_STUB IDiaEnumTables_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumTables_INTERFACE_DEFINED__ */



#ifndef __Dia2Lib_LIBRARY_DEFINED__
#define __Dia2Lib_LIBRARY_DEFINED__

/* library Dia2Lib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_Dia2Lib;

EXTERN_C const CLSID CLSID_DiaSource;

#ifdef __cplusplus

class DECLSPEC_UUID("151CE278-3CCB-4161-8658-679F8BCF29ED")
DiaSource;
#endif

EXTERN_C const CLSID CLSID_DiaSourceAlt;

#ifdef __cplusplus

class DECLSPEC_UUID("AF74D59B-5AF2-4f36-9E86-87B754DC8A4E")
DiaSourceAlt;
#endif
#endif /* __Dia2Lib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_dia2_0136 */
/* [local] */ 

#define	DiaTable_Symbols	( L"Symbols" )

#define	DiaTable_Sections	( L"Sections" )

#define	DiaTable_SrcFiles	( L"SourceFiles" )

#define	DiaTable_LineNums	( L"LineNumbers" )

#define	DiaTable_SegMap	( L"SegmentMap" )

#define	DiaTable_Dbg	( L"Dbg" )

#define	DiaTable_InjSrc	( L"InjectedSource" )

#define	DiaTable_FrameData	( L"FrameData" )



extern RPC_IF_HANDLE __MIDL_itf_dia2_0136_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_0136_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\vc\diacreate_int.h ===
// diacreate_int.h - creation helper functions for DIA initialization - Microsoft internal version
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------
#ifndef _DIACREATE_INT_H_
#define _DIACREATE_INT_H_

//
// Create a dia data source object from a static dia library
//
HRESULT STDMETHODCALLTYPE DiaCoCreate(
                        REFCLSID   rclsid,
                        REFIID     riid,
                        void     **ppv);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\vc\diacreate.h ===
#ifndef _DIACREATE_H_
#define _DIACREATE_H_

#ifdef DIA_LIBRARY

//
// Create a dia data source object from a static dia library
//
HRESULT STDMETHODCALLTYPE DiaCoCreate(
                        REFCLSID   rclsid,
                        REFIID     riid,
                        void     **ppv);

#else

//
// Create a dia data source object from the dia dll (by dll name - does not access the registry).
//
HRESULT STDMETHODCALLTYPE NoRegCoCreate(  const char*dllName,
                        REFCLSID   rclsid,
                        REFIID     riid,
                        void     **ppv);

//
// Create a dia data source object from the dia dll (looks up the class id in the registry).
//
HRESULT STDMETHODCALLTYPE NoOleCoCreate(  REFCLSID   rclsid,
                        REFIID     riid,
                        void     **ppv);

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\vc\exe_vxd.h ===
/*
 *  Title
 *
 *	exe386.h
 *	Wieslaw Kalkus
 *	(C) Copyright Microsoft Corp 1988-1992
 *	5 August 1988
 *
 *  Description
 *
 *	Data structure definitions for the OS/2
 *	executable file format (flat model).
 *
 *  Modification History
 *
 *	88/08/05	Wieslaw Kalkus	Initial version
 */


#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif


    /*_________________________________________________________________*
     |                                                                 |
     |                                                                 |
     |	OS/2 .EXE FILE HEADER DEFINITION - 386 version 0:32	       |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */


#define BITPERWORD	16
#define BITPERBYTE	8
#define OBJPAGELEN	4096
#define E32MAGIC1	'L'		/* New magic number  "LE" */
#define E32MAGIC2	'E'		/* New magic number  "LE" */
#define E32MAGIC        0x454c          /* New magic number  "LE" */
#define E32RESBYTES1    0               /* First bytes reserved */
#define E32RESBYTES2	0		/* Second bytes reserved */
#define E32RESBYTES3	24		/* Third bytes reserved */
#define E32LEBO 	0x00		/* Little Endian Byte Order */
#define E32BEBO 	0x01		/* Big Endian Byte Order */
#define E32LEWO 	0x00		/* Little Endian Word Order */
#define E32BEWO 	0x01		/* Big Endian Word Order */
#define E32LEVEL	0L		/* 32-bit EXE format level */
#define E32CPU286	0x001		/* Intel 80286 or upwardly compatibile */
#define E32CPU386	0x002		/* Intel 80386 or upwardly compatibile */
#define E32CPU486	0x003		/* Intel 80486 or upwardly compatibile */



struct e32_exe {			/* New 32-bit .EXE header */
    unsigned char	e32_magic[2];	/* Magic number E32_MAGIC */
    unsigned char	e32_border;	/* The byte ordering for the .EXE */
    unsigned char	e32_worder;	/* The word ordering for the .EXE */
    unsigned long	e32_level;	/* The EXE format level for now = 0 */
    unsigned short	e32_cpu;	/* The CPU type */
    unsigned short	e32_os; 	/* The OS type */
    unsigned long	e32_ver;	/* Module version */
    unsigned long	e32_mflags;	/* Module flags */
    unsigned long	e32_mpages;	/* Module # pages */
    unsigned long	e32_startobj;	/* Object # for instruction pointer */
    unsigned long	e32_eip;	/* Extended instruction pointer */
    unsigned long	e32_stackobj;	/* Object # for stack pointer */
    unsigned long	e32_esp;	/* Extended stack pointer */
    unsigned long	e32_pagesize;	/* .EXE page size */
    unsigned long       e32_lastpagesize;/* Last page size in .EXE */
    unsigned long	e32_fixupsize;	/* Fixup section size */
    unsigned long	e32_fixupsum;	/* Fixup section checksum */
    unsigned long	e32_ldrsize;	/* Loader section size */
    unsigned long	e32_ldrsum;	/* Loader section checksum */
    unsigned long	e32_objtab;	/* Object table offset */
    unsigned long	e32_objcnt;	/* Number of objects in module */
    unsigned long	e32_objmap;	/* Object page map offset */
    unsigned long	e32_itermap;	/* Object iterated data map offset */
    unsigned long	e32_rsrctab;	/* Offset of Resource Table */
    unsigned long	e32_rsrccnt;	/* Number of resource entries */
    unsigned long	e32_restab;	/* Offset of resident name table */
    unsigned long	e32_enttab;	/* Offset of Entry Table */
    unsigned long	e32_dirtab;	/* Offset of Module Directive Table */
    unsigned long	e32_dircnt;	/* Number of module directives */
    unsigned long	e32_fpagetab;	/* Offset of Fixup Page Table */
    unsigned long	e32_frectab;	/* Offset of Fixup Record Table */
    unsigned long	e32_impmod;	/* Offset of Import Module Name Table */
    unsigned long	e32_impmodcnt;	/* Number of entries in Import Module Name Table */
    unsigned long	e32_impproc;	/* Offset of Import Procedure Name Table */
    unsigned long	e32_pagesum;	/* Offset of Per-Page Checksum Table */
    unsigned long	e32_datapage;	/* Offset of Enumerated Data Pages */
    unsigned long	e32_preload;	/* Number of preload pages */
    unsigned long	e32_nrestab;	/* Offset of Non-resident Names Table */
    unsigned long	e32_cbnrestab;	/* Size of Non-resident Name Table */
    unsigned long	e32_nressum;	/* Non-resident Name Table Checksum */
    unsigned long	e32_autodata;	/* Object # for automatic data object */
    unsigned long	e32_debuginfo;	/* Offset of the debugging information */
    unsigned long	e32_debuglen;	/* The length of the debugging info. in bytes */
    unsigned long	e32_instpreload;/* Number of instance pages in preload section of .EXE file */
    unsigned long	e32_instdemand; /* Number of instance pages in demand load section of .EXE file */
    unsigned long	e32_heapsize;	/* Size of heap - for 16-bit apps */
    unsigned char	e32_res3[E32RESBYTES3 - 4 - 8];
					/* Pad structure to 192 bytes */
    unsigned long	e32_winresoff ;
    unsigned long	e32_winreslen ;
    unsigned short	Dev386_Device_ID;
					/* Device ID for VxD */
    unsigned short	Dev386_DDK_Version;
					/* DDK version for VxD */
};



#define E32_MAGIC1(x)	    (x).e32_magic[0]
#define E32_MAGIC2(x)	    (x).e32_magic[1]
#define E32_BORDER(x)	    (x).e32_border
#define E32_WORDER(x)	    (x).e32_worder
#define E32_LEVEL(x)	    (x).e32_level
#define E32_CPU(x)	    (x).e32_cpu
#define E32_OS(x)	    (x).e32_os
#define E32_VER(x)	    (x).e32_ver
#define E32_MFLAGS(x)	    (x).e32_mflags
#define E32_MPAGES(x)	    (x).e32_mpages
#define E32_STARTOBJ(x)     (x).e32_startobj
#define E32_EIP(x)	    (x).e32_eip
#define E32_STACKOBJ(x)     (x).e32_stackobj
#define E32_ESP(x)	    (x).e32_esp
#define E32_PAGESIZE(x)     (x).e32_pagesize
#define E32_LASTPAGESIZE(x) (x).e32_lastpagesize
#define E32_FIXUPSIZE(x)    (x).e32_fixupsize
#define E32_FIXUPSUM(x)     (x).e32_fixupsum
#define E32_LDRSIZE(x)	    (x).e32_ldrsize
#define E32_LDRSUM(x)	    (x).e32_ldrsum
#define E32_OBJTAB(x)	    (x).e32_objtab
#define E32_OBJCNT(x)	    (x).e32_objcnt
#define E32_OBJMAP(x)	    (x).e32_objmap
#define E32_ITERMAP(x)	    (x).e32_itermap
#define E32_RSRCTAB(x)	    (x).e32_rsrctab
#define E32_RSRCCNT(x)	    (x).e32_rsrccnt
#define E32_RESTAB(x)	    (x).e32_restab
#define E32_ENTTAB(x)	    (x).e32_enttab
#define E32_DIRTAB(x)	    (x).e32_dirtab
#define E32_DIRCNT(x)	    (x).e32_dircnt
#define E32_FPAGETAB(x)     (x).e32_fpagetab
#define E32_FRECTAB(x)	    (x).e32_frectab
#define E32_IMPMOD(x)	    (x).e32_impmod
#define E32_IMPMODCNT(x)    (x).e32_impmodcnt
#define E32_IMPPROC(x)	    (x).e32_impproc
#define E32_PAGESUM(x)	    (x).e32_pagesum
#define E32_DATAPAGE(x)     (x).e32_datapage
#define E32_PRELOAD(x)	    (x).e32_preload
#define E32_NRESTAB(x)	    (x).e32_nrestab
#define E32_CBNRESTAB(x)    (x).e32_cbnrestab
#define E32_NRESSUM(x)	    (x).e32_nressum
#define E32_AUTODATA(x)     (x).e32_autodata
#define E32_DEBUGINFO(x)    (x).e32_debuginfo
#define E32_DEBUGLEN(x)     (x).e32_debuglen
#define E32_INSTPRELOAD(x)  (x).e32_instpreload
#define E32_INSTDEMAND(x)   (x).e32_instdemand
#define E32_HEAPSIZE(x)     (x).e32_heapsize



/*
 *  Format of E32_MFLAGS(x):
 *
 *  Low word has the following format:
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *   |	   |	    | | |     | |   |
 *   |	   |	    | | |     | |   +------- Per-Process Library Initialization
 *   |	   |	    | | |     | +----------- No Internal Fixups for Module in .EXE
 *   |	   |	    | | |     +------------- No External Fixups for Module in .EXE
 *   |	   |	    | | +------------------- Incompatible with PM Windowing
 *   |	   |	    | +--------------------- Compatible with PM Windowing
 *   |	   |	    +----------------------- Uses PM Windowing API
 *   |	   +-------------------------------- Module not Loadable
 *   +-------------------------------------- Library Module
 */


#define E32NOTP 	 0x8000L	/* Library Module - used as NENOTP */
#define E32NOLOAD	 0x2000L	/* Module not Loadable */
#define E32PMAPI	 0x0300L	/* Uses PM Windowing API */
#define E32PMW		 0x0200L	/* Compatible with PM Windowing */
#define E32NOPMW	 0x0100L	/* Incompatible with PM Windowing */
#define E32NOEXTFIX	 0x0020L	/* NO External Fixups in .EXE */
#define E32NOINTFIX	 0x0010L	/* NO Internal Fixups in .EXE */
#define E32LIBINIT	 0x0004L	/* Per-Process Library Initialization */
#define E32APPMASK	 0x0700L	/* Aplication Type Mask */


/*
 *  Format of E32_MFLAGS(x):
 *
 *  High word has the following format:
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *				      | |
 *				      | +--- Protected memory library module
 *				      +----- Device driver
 */

#define E32PROTDLL	 0x10000L	// Protected memory library module
#define E32DEVICE	 0x20000L	// Device driver
#define E32MODEXE	 0x00000L	// .EXE module
#define E32MODDLL	 0x08000L	// .DLL module
#define E32MODPROTDLL	 0x18000L	// Protected memory library module
#define E32MODPDEV	 0x20000L	// Physical device driver
#define E32MODVDEV	 0x28000L	// Virtual device driver
#define E32MODVDEVDYN	 0x38000L	// Virtual device driver (dynamic)
#define E32MODMASK	 0x38000L	// Module type mask

/*
 *  RELOCATION DEFINITIONS - RUN-TIME FIXUPS
 */


#pragma pack(1) 			/* This data must be packed */


typedef union _offset
{
    unsigned short offset16;
    unsigned long  offset32;
}
    offset;				/* 16-bit or 32-bit offset */


/***ET+	r32_rlc - Relocation item */

struct r32_rlc {			/* Relocation item */
    unsigned char nr_stype;		/* Source type - shared with new_rlc */
    unsigned char nr_flags;		/* Flag byte - shared with new_rlc */
    short r32_soff;			/* Source page offset */
    unsigned short r32_objmod;		/* Target obj. no. or Module ordinal */

    union targetid {			/* BEGIN UNION */
	unsigned long intref;		/* Internal fixup offset */
	unsigned long proc;		/* Procedure name offset */
	unsigned long ord;	 	/* Procedure ordinal */
    } r32_target;			/* END UNION */
    unsigned long addval;		/* Value added to the address */
    unsigned short r32_srccount;	/* Number of chained fixup records */
    unsigned short r32_chain;		/* Chain head */
};


#pragma pack()				/* Stop packing */


/*
 *  In 32-bit .EXE file run-time relocations are written as varying size
 *  records, so we need many size definitions.
 */

#define RINTSIZE16	8
#define RINTSIZE32	10
#define RORDSIZE	8
#define RNAMSIZE16	8
#define RNAMSIZE32	10
#define RADDSIZE16	10
#define RADDSIZE32	12



#if FALSE
/*
 *  Access macros defined in NEWEXE.H !!!
 */
#define NR_STYPE(x)	 (x).nr_stype
#define NR_FLAGS(x)	 (x).nr_flags
#endif

#define R32_SOFF(x)	 (x).r32_soff
#define R32_OBJNO(x)	 (x).r32_objmod
#define R32_MODORD(x)	 (x).r32_objmod
#define R32_OFFSET(x)    (x).r32_target.intref
#define R32_PROCOFF(x)   (x).r32_target.proc
#define R32_PROCORD(x)	 (x).r32_target.ord
#define R32_ADDVAL(x)    (x).addval
#define R32_SRCCNT(x)	 (x).r32_srccount
#define R32_CHAIN(x)	 (x).r32_chain



/*
 *  Format of NR_STYPE(x)
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *	     | | | | | |
 *	     | | +-+-+-+--- Source type
 *	     | +----------- Fixup to 16:16 alias
 *	     +------------- List of source offset follows fixup record
 */

#if FALSE

	    /* DEFINED in newexe.h !!! */

#define NRSTYP		0x0f		/* Source type mask */
#define NRSBYT		0x00		/* lo byte (8-bits)*/
#define NRSSEG		0x02		/* 16-bit segment (16-bits) */
#define NRSPTR		0x03		/* 16:16 pointer (32-bits) */
#define NRSOFF		0x05		/* 16-bit offset (16-bits) */
#define NRPTR48 	0x06		/* 16:32 pointer (48-bits) */
#define NROFF32 	0x07		/* 32-bit offset (32-bits) */
#define NRSOFF32	0x08		/* 32-bit self-relative offset (32-bits) */
#endif


#define NRSRCMASK	0x0f		/* Source type mask */
#define NRALIAS 	0x10		/* Fixup to alias */
#define NRCHAIN 	0x20		/* List of source offset follows */
					/* fixup record, source offset field */
					/* in fixup record contains number */
					/* of elements in list */

/*
 *  Format of NR_FLAGS(x) and R32_FLAGS(x):
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *	 | | | |   | | |
 *	 | | | |   | +-+--- Reference type
 *	 | | | |   +------- Additive fixup
 *	 | | | +----------- 32-bit Target Offset Flag (1 - 32-bit; 0 - 16-bit)
 *	 | | +------------- 32-bit Additive Flag (1 - 32-bit; 0 - 16-bit)
 *	 | +--------------- 16-bit Object/Module ordinal (1 - 16-bit; 0 - 8-bit)
 *	 +----------------- 8-bit import ordinal (1 - 8-bit;
 *						  0 - NR32BITOFF toggles
 *						      between 16 and 32 bit
 *						      ordinal)
 */

#if FALSE

	    /* DEFINED in newexe.h !!! */

#define NRADD		0x04		/* Additive fixup */
#define NRRTYP		0x03		/* Reference type mask */
#define NRRINT		0x00		/* Internal reference */
#define NRRORD		0x01		/* Import by ordinal */
#define NRRNAM		0x02		/* Import by name */
#endif

#define NRRENT		0x03		/* Internal entry table fixup */

#define NR32BITOFF	0x10		/* 32-bit Target Offset */
#define NR32BITADD	0x20		/* 32-bit Additive fixup */
#define NR16OBJMOD	0x40		/* 16-bit Object/Module ordinal */
#define NR8BITORD	0x80		/* 8-bit import ordinal */
/*end*/

/*
 *  Data structures for storing run-time fixups in linker virtual memory.
 *
 *  Each object has a list of Object Page Directories which specify
 *  fixups for given page. Each page has its own hash table which is
 *  used to detect fixups to the same target.
 */

#define PAGEPERDIR	62
#define LG2DIR		7


typedef struct _OBJPAGEDIR
{
    DWORD   next;			/* Virtual pointer to next dir on list */
    WORD    ht[PAGEPERDIR];		/* Pointers to individual hash tables */
}
    OBJPAGEDIR;



/*
 *  OBJECT TABLE
 */

/***ET+	o32_obj Object Table Entry */

struct o32_obj				/* Flat .EXE object table entry */
{
    unsigned long	o32_size;	/* Object virtual size */
    unsigned long	o32_base;	/* Object base virtual address */
    unsigned long	o32_flags;	/* Attribute flags */
    unsigned long	o32_pagemap;	/* Object page map index */
    unsigned long	o32_mapsize;	/* Number of entries in object page map */
    unsigned long	o32_reserved;	/* Reserved */
};


#define O32_SIZE(x)	(x).o32_size
#define O32_BASE(x)	(x).o32_base
#define O32_FLAGS(x)	(x).o32_flags
#define O32_PAGEMAP(x)	(x).o32_pagemap
#define O32_MAPSIZE(x)	(x).o32_mapsize
#define O32_RESERVED(x) (x).o32_reserved



/*
 *  Format of O32_FLAGS(x)
 *
 *  High word of dword flag field is not used for now.
 *  Low word has the following format:
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *   |	|  |  |     | | | | | | | | | | |
 *   |	|  |  |     | | | | | | | | | | +--- Readable Object
 *   |	|  |  |     | | | | | | | | | +----- Writeable Object
 *   |	|  |  |     | | | | | | | | +------- Executable Object
 *   |	|  |  |     | | | | | | | +--------- Resource Object
 *   |	|  |  |     | | | | | | +----------- Object is Discardable
 *   |	|  |  |     | | | | | +------------- Object is Shared
 *   |	|  |  |     | | | | +--------------- Object has preload pages
 *   |	|  |  |     | | | +----------------- Object has invalid pages
 *   |	|  |  |     | | +------------------- Object is permanent and swappable
 *   |	|  |  |     | +--------------------- Object is permanent and resident
 *   |	|  |  |     +----------------------- Object is permanent and long lockable
 *   |	|  |  +----------------------------- 16:16 alias required (80x86 specific)
 *   |	|  +-------------------------------- Big/Default bit setting (80x86 specific)
 *   |	+----------------------------------- Object is conforming for code (80x86 specific)
 *   +-------------------------------------- Object I/O privilege level (80x86 specific)
 *
 */

#define OBJREAD 	0x0001L 	    /* Readable Object	 */
#define OBJWRITE	0x0002L 	    /* Writeable Object  */
#define OBJRSRC 	0x0008L 	    /* Resource Object	 */
#define OBJINVALID	0x0080L 	    /* Object has invalid pages  */
#define OBJNONPERM	0x0600L 	    /* Object is nonpermanent - should be */
					    /* zero in the .EXE but internally we use 6 */
#define OBJPERM 	0x0100L 	    /* Object is permanent and swappable */
#define OBJRESIDENT	0x0200L 	    /* Object is permanent and resident */
#define OBJCONTIG	0x0300L 	    /* Object is resident and contiguous */
#define OBJDYNAMIC	0x0400L 	    /* Object is permanent and long locable */
#define OBJTYPEMASK	0x0700L 	    /* Object type mask */
#define OBJALIAS16	0x1000L 	    /* 16:16 alias required (80x86 specific)	       */
#define OBJBIGDEF	0x2000L 	    /* Big/Default bit setting (80x86 specific)        */
#define OBJIOPL 	0x8000L 	    /* Object I/O privilege level (80x86 specific)     */

#define OBJDISCARD	 0x0010L	    /* Object is Discardable */
#define OBJSHARED	 0x0020L	    /* Object is Shared */
#define OBJPRELOAD	 0x0040L	    /* Object has preload pages  */
#define OBJEXEC 	 0x0004L	    /* Executable Object */
#define OBJCONFORM	 0x4000L	    /* Object is conforming for code (80x86 specific)  */

/*
 *  Life will be easier, if we keep the same names for the following flags:
 */
#define NSDISCARD	OBJDISCARD 	    /* Object is Discardable */
#define NSMOVE		NSDISCARD	    /* Moveable object is for sure Discardable */
#define NSSHARED	OBJSHARED 	    /* Object is Shared */
#define NSPRELOAD	OBJPRELOAD 	    /* Object has preload pages  */
#define NSEXRD		OBJEXEC 	    /* Executable Object */
#define NSCONFORM	OBJCONFORM 	    /* Object is conforming for code (80x86 specific)  */
/*end*/

/***ET+	o32_map - Object Page Map entry */

struct o32_map				    /* Object Page Map entry */
{
    unsigned char   o32_pageidx[3];	    /* 24-bit page # in .EXE file */
    unsigned char   o32_pageflags;	    /* Per-Page attributes */
};


#define GETPAGEIDX(x)	((((unsigned long)((x).o32_pageidx[0])) << BITPERWORD) + \
			 (((x).o32_pageidx[1]) << BITPERBYTE) + \
			   (x).o32_pageidx[2])

#define PUTPAGEIDX(x,i) ((x).o32_pageidx[0] = (unsigned char) ((unsigned long)(i) >> BITPERWORD), \
			 (x).o32_pageidx[1] = (unsigned char) ((i) >> BITPERBYTE), \
			 (x).o32_pageidx[2] = (unsigned char) ((i) &  0xff))

#define PAGEFLAGS(x)	(x).o32_pageflags


#define VALID		0x00		    /* Valid Physical Page in .EXE */
#define ITERDATA	0x01		    /* Iterated Data Page */
#define INVALID 	0x02		    /* Invalid Page */
#define ZEROED		0x03		    /* Zero Filled Page */
#define RANGE		0x04		    /* Range of pages */
/*end*/

/*
 *  RESOURCE TABLE
 */

/***ET+	rsrc32 - Resource Table Entry */

struct rsrc32				    /* Resource Table Entry */
{
    unsigned short	type;		    /* Resource type */
    unsigned short	name;		    /* Resource name */
    unsigned long	cb;		    /* Resource size */
    unsigned short	obj;		    /* Object number */
    unsigned long	offset; 	    /* Offset within object */
};
/*end*/


#pragma pack(1) 			/* This data must be packed */

/*
 *  ENTRY TABLE DEFINITIONS
 */

/***ET+	b32_bundle - Entry Table */

struct b32_bundle
{
    unsigned char	b32_cnt;	/* Number of entries in this bundle */
    unsigned char	b32_type;	/* Bundle type */
    unsigned short	b32_obj;	/* Object number */
};					/* Follows entry types */

struct e32_entry
{
    unsigned char	e32_flags;	/* Entry point flags */
    union entrykind
    {
	offset		e32_offset;	/* 16-bit/32-bit offset entry */
	struct
	{
	    unsigned short offset;	/* Offset in segment */
	    unsigned short callgate;	/* Callgate selector */
	}
			e32_callgate;	/* 286 (16-bit) call gate */
	struct
	{
	    unsigned short  modord;	/* Module ordinal number */
	    unsigned long   value;	/* Proc name offset or ordinal */
	}
			e32_fwd;	/* Forwarder */
    }
			e32_variant;	/* Entry variant */
};

#pragma pack()				/* Stop packing */


#define B32_CNT(x)	(x).b32_cnt
#define B32_TYPE(x)	(x).b32_type
#define B32_OBJ(x)	(x).b32_obj

#define E32_EFLAGS(x)	(x).e32_flags
#define E32_OFFSET16(x) (x).e32_variant.e32_offset.offset16
#define E32_OFFSET32(x) (x).e32_variant.e32_offset.offset32
#define E32_GATEOFF(x)	(x).e32_variant.e32_callgate.offset
#define E32_GATE(x)	(x).e32_variant.e32_callgate.callgate
#define E32_MODORD(x)	(x).e32_variant.e32_fwd.modord
#define E32_VALUE(x)	(x).e32_variant.e32_fwd.value

#define FIXENT16	3
#define FIXENT32	5
#define GATEENT16	5
#define FWDENT		7

/*
 *  BUNDLE TYPES
 */

#define EMPTY	     0x00		/* Empty bundle */
#define ENTRY16      0x01		/* 16-bit offset entry point */
#define GATE16	     0x02		/* 286 call gate (16-bit IOPL) */
#define ENTRY32      0x03		/* 32-bit offset entry point */
#define ENTRYFWD     0x04		/* Forwarder entry point */
#define TYPEINFO     0x80		/* Typing information present flag */


/*
 *  Format for E32_EFLAGS(x)
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *	 | | | | | | | |
 *	 | | | | | | | +--- exported entry
 *	 | | | | | | +----- uses shared data
 *	 +-+-+-+-+-+------- parameter word count
 */

#define E32EXPORT	0x01		/* Exported entry */
#define E32SHARED	0x02		/* Uses shared data */
#define E32PARAMS	0xf8		/* Parameter word count mask */

/*
 *  Flags for forwarders only:
 */

#define FWD_ORDINAL	0x01		/* Imported by ordinal */
/*end*/


struct VxD_Desc_Block {
    ULONG DDB_Next;         /* VMM RESERVED FIELD */
    USHORT DDB_SDK_Version;     /* INIT <DDK_VERSION> RESERVED FIELD */
    USHORT DDB_Req_Device_Number;   /* INIT <UNDEFINED_DEVICE_ID> */
    UCHAR DDB_Dev_Major_Version;    /* INIT <0> Major device number */
    UCHAR DDB_Dev_Minor_Version;    /* INIT <0> Minor device number */
    USHORT DDB_Flags;           /* INIT <0> for init calls complete */
    UCHAR DDB_Name[8];          /* AINIT <"        "> Device name */
    ULONG DDB_Init_Order;       /* INIT <UNDEFINED_INIT_ORDER> */
    ULONG DDB_Control_Proc;     /* Offset of control procedure */
    ULONG DDB_V86_API_Proc;     /* INIT <0> Offset of API procedure */
    ULONG DDB_PM_API_Proc;      /* INIT <0> Offset of API procedure */
    ULONG DDB_V86_API_CSIP;     /* INIT <0> CS:IP of API entry point */
    ULONG DDB_PM_API_CSIP;      /* INIT <0> CS:IP of API entry point */
    ULONG DDB_Reference_Data;       /* Reference data from real mode */
    ULONG DDB_Service_Table_Ptr;    /* INIT <0> Pointer to service table */
    ULONG DDB_Service_Table_Size;   /* INIT <0> Number of services */
    ULONG DDB_Win32_Service_Table;  /* INIT <0> Pointer to Win32 services */
    ULONG DDB_Prev;         /* INIT <'Prev'> Ptr to prev 4.0 DDB */
    ULONG DDB_Reserved0;        /* INIT <0> Reserved */
    ULONG DDB_Reserved1;        /* INIT <'Rsv1'> Reserved */
    ULONG DDB_Reserved2;        /* INIT <'Rsv2'> Reserved */
    ULONG DDB_Reserved3;        /* INIT <'Rsv3'> Reserved */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\vc\shapi.h ===
//  shapi.h - Public API to the Symbol Handler
//
//    This file contains all types and APIs that are defined by
//    the Symbol Handler and are publicly accessible by other
//    components.
//
//    Before including this file, you must include cvtypes.h.


//  The master copy of this file resides in the CVINC project.
//    All Microsoft projects are required to use the master copy without
//    modification.  Modification of the master version or a copy
//    without consultation with all parties concerned is extremely
//    risky.

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#include <tchar.h>

#ifndef SH_API
#define SH_API

#define DECL_STR(n, v, s) n = v,
typedef enum {                  // Error returns from some SH functions
#include "sherror.h"
} SHE;
#undef DECL_STR

enum {
  sopNone  =  0,
  sopData  =  1,
  sopStack =  2,
  sopReg   =  4,
  sopLab   =  8,
  sopFcn   = 16,
  sopExact = 32
};
typedef short SOP;              // Symbol OPtions

typedef enum {
    fstNone,
    fstSymbol,
    fstPublic
} FST;                          // Function Symbol Type

typedef enum {
    fcdUnknown,
    fcdNear,
    fcdFar,
    fcdData
} FCD;                          // Function Call Distance (near/far/unknown)

typedef enum {
    fptUnknown,
    fptPresent,
    fptOmitted
} FPT;                          // Frame Pointer Type

typedef struct _ODR {
    FST     fst;
    FCD     fcd;
    FPT     fpt;
    WORD    cbProlog;
    DWORD   dwDeltaOff;
    LSZ     lszName;
} ODR;                          // OSDebug Return type
typedef ODR *LPODR;


typedef enum {
    astNone,
    astAddress,
    astRegister,
    astBaseOff
} AST;                          // Assembler symbol return Types

typedef struct _ASR {
    AST ast;
    union {
        struct {
            FCD  fcd;
            ADDR addr;
        };
        WORD   ireg;
        OFFSET off;
    };
} ASR;      // Assembler Symbol Return structure
typedef ASR *LPASR;

typedef HEMI            SHEMI;
typedef BOOL            SHFLAG; // A TRUE/FALSE flag var
typedef SHFLAG *        PSHFLAG;
typedef SEGMENT         SHSEG;  // A segment/selector value
typedef UOFFSET         SHOFF;  // An offset value

typedef void *          HVOID;  // Generic handle type
typedef HIND            HMOD;   // A module handle
typedef HIND            HGRP;   // A group handle (sub group of module
                                //   currently either a seg or filename)
typedef HVOID           HPROC;  // A handle to a procedure
typedef HVOID           HBLK;   // A handle to a block.
typedef HVOID           HSF;    // A handle to source file table
typedef HIND            HEXE;   // An Executable file handle
typedef HVOID           HTYPE;  // A handle to a type
typedef HVOID           HSYM;   // A handle to a symbol
typedef HIND            HPDS;   // A handle to a process

typedef HSYM *          PHSYM;

typedef CV_typ_t        THIDX;

typedef struct CXT {
    ADDR  addr;
    HMOD  hMod;
    HGRP  hGrp;
    HPROC hProc;
    HBLK  hBlk;
} CXT;                          // General Symbol context pkt
typedef CXT *PCXT;

typedef struct CXF {
    CXT   cxt;
#if 0
    FRAME Frame;
#else
    HFRAME      hFrame;
#endif
} CXF;                          // Symbol context pkt locked to a frame ptr
typedef CXF *PCXF;

typedef enum {
    SHFar,
    SHNear
} SHCALL;

typedef struct SHREG {
    DWORD      hReg;
    union {
        unsigned char   Byte1;
        struct {
            unsigned short  Byte2;
            unsigned short  Byte2High;
        };
        struct {
            unsigned long Byte4;
            unsigned long Byte4High;
        };
        double      Byte8;
        unsigned __int64 Byte8i;
        FLOAT10     Byte10;
    };
} SHREG;
typedef SHREG *PSHREG;

typedef struct _SLP {
    ADDR    addr;
    SHOFF   cb;
} SLP;                          // Source Line Pair (used by SLCAddrFromLine)
typedef SLP * LPSLP;

//  structure defining parameters of symbol to be searched for.  The address
//  of this structure is passed on the the EE's symbol compare routine.  Any
//  additional data required by the EE's routine must follow this structure.

typedef struct _SSTR {          // string with length byte and pointer to data
    LPB             lpName;     // pointer to the string itself
    unsigned char   cb;         // length byte
    unsigned char   searchmask; // mask to control symbol searching
    unsigned short  symtype;    // symbol types to be checked
    unsigned char * pRE;        // pointer to regular expression
} SSTR;
typedef SSTR *LPSSTR;

#define SSTR_proc       0x0001  // compare only procs with correct type
#define SSTR_data       0x0002  // compare only global data with correct type
#define SSTR_RE         0x0004  // compare using regular expression
#define SSTR_NoHash     0x0008  // do a linear search of the table
#define SSTR_symboltype 0x0010  // pass only symbols of symtype to the
                                //  comparison function.
#define SSTR_FuzzyPublic 0x0020 // Ignore leading _, .. or trailing @xxx


#define SHpCXTFrompCXF(a)   (&((a)->cxt))
//#define SHpFrameFrompCXF(a) (&(a)->Frame)
#define SHhFrameFrompCXF(a) ((a)->hFrame)
#define SHHMODFrompCXT(a)   ((a)->hMod)
#define SHHPROCFrompCXT(a)  ((a)->hProc)
#define SHHBLKFrompCXT(a)   ((a)->hBlk)
#define SHpADDRFrompCXT(a)  (&((a)->addr))
#define SHPAddrFromPCxf(a)  (SHpADDRFrompCXT(SHpCXTFrompCXF(a)))

#define SHIsCXTMod(a)       ((a)->hMod  && !(a)->hProc  && !(a)->hBlk)
#define SHIsCXTProc(a)      ((a)->hMod  &&  (a)->hProc  && !(a)->hBlk)
#define SHIsCXTBlk(a)       ((a)->hMod  &&  (a)->hProc  &&  (a)->hBlk)

#define SHHGRPFrompCXT(a)   ((a)->hGrp)


// Used by comparison functions
//
// Structure to cross-check validity of .dbg file
// against the image.
//
// The values are returned to the caller so that the
// caller can format the error message.
typedef struct _VLDCHK {
    //
    // Values from image
    DWORD   ImgTimeDateStamp;
    DWORD   ImgCheckSum;
    //
    // Values from sym file
    DWORD   SymTimeDateStamp;
    DWORD   SymCheckSum;
} VLDCHK;
typedef VLDCHK *LPVLDCHK;
typedef VLDCHK *PVLDCHK;

// comparison prototype
typedef SHFLAG  (FAR PASCAL *PFNCMP) (HVOID, HVOID, LSZ, SHFLAG);
typedef SHE     (FAR PASCAL *PFNVALIDATEEXE) (INT, PVLDCHK);
typedef BOOL    (FAR PASCAL *PFNVALIDATEDEBUGINFOFILE) (LPCSTR szFile, ULONG * errcode );

#define LPFNSYM     WINAPI *
#define LPFNSYMC    CDECL *

#if 0
typedef struct omap_tag {
    DWORD       rva;
    DWORD       rvaTo;
} OMAP, *POMAP, *LPOMAP;
#else
typedef POMAP LPOMAP;
#endif

typedef struct {
    DWORD Offset;
    DWORD Size;
    DWORD Flags;
} SECSTART, *LPSECSTART;

typedef struct _tagDEBUGDATA {
    union {
        PIMAGE_RUNTIME_FUNCTION_ENTRY lpRtf;          // Runtime function table - fpo or pdata
        PFPO_DATA lpFpo;
    };
    DWORD       cRtf;           // Count of rtf entries
    PIMAGE_RUNTIME_FUNCTION_ENTRY lpOriginalRtf;  // Original pdata address
    LPOMAP      lpOmapFrom;     // Omap table - From Source
    DWORD       cOmapFrom;      // Count of omap entries - From Source
    LPOMAP      lpOmapTo;       // Omap table - To Source
    DWORD       cOmapTo;        // Count of omap entries - To Source
    LPSECSTART  lpSecStart;     // Original section table (pre-Lego)
//    SHE         she;            // Remember any load errors
} DEBUGDATA, *LPDEBUGDATA;

#if 0
// get rid of this for compatibility with pdb.h

typedef struct _tagSEARCHDEBUGINFO {
    DWORD   cb;                         // doubles as version detection
    BOOL    fMainDebugFile;             // indicates "core" or "ancilliary" file
                                        // eg: main.exe has main.pdb and foo.lib->foo.pdb
    LSZ     szMod;                      // exe/dll
    LSZ     szLib;                      // lib if appropriate
    LSZ     szObj;                      // object file
    LSZ *   rgszTriedThese;             // list of ones that were tried,
                                        // NULL terminated list of LSZ's
    _TCHAR  szValidatedFile[_MAX_PATH]; // output of validated filename,
    PFNVALIDATEDEBUGINFOFILE
            pfnValidateDebugInfoFile;   // validation function
} SEARCHDEBUGINFO, *PSEARCHDEBUGINFO;
#endif

typedef struct _KNF {
    int   cb;

    PVOID (LPFNSYM lpfnMHAlloc)     (UINT);
    PVOID (LPFNSYM lpfnMHRealloc)   (PVOID, UINT);
    VOID  (LPFNSYM lpfnMHFree)      (PVOID);
    PVOID (LPFNSYM lpfnMHAllocHuge) (LONG, UINT);
    VOID  (LPFNSYM lpfnMHFreeHuge)  (PVOID);

    HDEP  (LPFNSYM lpfnMMAllocHmem) (UINT);
    VOID  (LPFNSYM lpfnMMFreeHmem)  (HDEP);
    PVOID (LPFNSYM lpfnMMLock)      (HDEP);
    VOID  (LPFNSYM lpfnMMUnlock)    (HDEP);

    HLLI  (LPFNSYM lpfnLLInit)      (DWORD, LLF, LPFNKILLNODE, LPFNFCMPNODE);
    HLLE  (LPFNSYM lpfnLLCreate)    (HLLI);
    VOID  (LPFNSYM lpfnLLAdd)       (HLLI, HLLE);
    VOID  (LPFNSYM lpfnLLAddHead)   (HLLI, HLLE);
    VOID  (LPFNSYM lpfnLLInsert)    (HLLI, HLLE, DWORD);
    BOOL  (LPFNSYM lpfnLLDelete)    (HLLI, HLLE);
    BOOL  (LPFNSYM lpfnLLRemove)    (HLLI, HLLE);
    DWORD (LPFNSYM lpfnLLDestroy)   (HLLI);
    HLLE  (LPFNSYM lpfnLLNext)      (HLLI, HLLE);
    HLLE  (LPFNSYM lpfnLLFind)      (HLLI, HLLE, PVOID, DWORD);
    HLLE  (LPFNSYM lpfnLLLast)      (HLLI);
    DWORD (LPFNSYM lpfnLLSize)      (HLLI);
    PVOID (LPFNSYM lpfnLLLock)      (HLLE);
    VOID  (LPFNSYM lpfnLLUnlock)    (HLLE);

    BOOL  (LPFNSYM lpfnLBPrintf)    (LPCH, LPCH, DWORD);
    BOOL  (LPFNSYM lpfnLBQuit)      (DWORD);

    UINT  (LPFNSYM lpfnSYOpen)      (LSZ);
    VOID  (LPFNSYM lpfnSYClose)     (UINT);
    UINT  (LPFNSYM lpfnSYReadFar)   (UINT, LPB, UINT);
    LONG  (LPFNSYM lpfnSYSeek)      (UINT, LONG, UINT);
    int   (LPFNSYM lpfnSYFixupAddr) (PADDR);
    int   (LPFNSYM lpfnSYUnFixupAddr)(PADDR);
    UINT  (LPFNSYM lpfnSYProcessor) (DWORD);

// Added/Changed for NT merge.

//    VOID  (LPFNSYM lpfn_searchenv)  (LSZ, LSZ, LSZ);
//    UINT  (LPFNSYMC lpfnsprintf)    (LSZ, LSZ, ...);
//    VOID  (LPFNSYM lpfn_splitpath)  (LSZ, LSZ, LSZ, LSZ, LSZ);
//    LSZ   (LPFNSYM lpfn_fullpath)   (LSZ, LSZ, UINT);
//    VOID  (LPFNSYM lpfn_makepath)   (LSZ, LSZ, LSZ, LSZ, LSZ);
//    UINT  (LPFNSYM lpfnstat)        (LSZ, LPCH);

    LONG  (LPFNSYM lpfnSYTell)          (UINT);
    UINT  (LPFNSYM lpfnSYFindExeFile)   (LSZ, LSZ, UINT, PVLDCHK, PFNVALIDATEEXE, SHE *);
    VOID  (LPFNSYM lpfnLoadedSymbols)   (SHE, LSZ);
    BOOL  (LPFNSYM lpfnSYGetDefaultShe) (LSZ, SHE *);

// Added for separate type pool work

    BOOL  (LPFNSYM pfnSYFindDebugInfoFile) ( PSEARCHDEBUGINFO );
    BOOL  (WINAPI * lpfnGetRegistryRoot)            ( LPTSTR, LPDWORD );

#ifdef NT_BUILD_ONLY
// Added for WinDbg back port
    BOOL    (LPFNSYM lpfnSetProfileString)(LPCSTR, LPCSTR);
    BOOL    (LPFNSYM lpfnGetProfileString)(LPCSTR, LPSTR, ULONG, ULONG *);

#endif

} KNF;  // KerNel Functions exported to the Symbol Handler
typedef KNF *LPKNF;

typedef struct _SHF {
    int     cb;
    HPDS    (LPFNSYM pSHCreateProcess)      (VOID);
    VOID    (LPFNSYM pSHSetHpid)            (HPID);
    BOOL    (LPFNSYM pSHDeleteProcess)      (HPDS);
    HPDS    (LPFNSYM pSHChangeProcess)      (HPDS);
    SHE     (LPFNSYM pSHAddDll)             (LSZ, BOOL);          // Changed for NT
    SHE     (LPFNSYM pSHAddDllsToProcess)   (VOID);
    SHE     (LPFNSYM pSHLoadDll)            (LSZ, BOOL);
    VOID    (LPFNSYM pSHUnloadDll)          (HEXE);
    UOFFSET (LPFNSYM pSHGetDebugStart)      (HSYM);
    LSZ     (LPFNSYM pSHGetSymName)         (HSYM, LSZ);
    BOOL    (LPFNSYM pSHAddrFromHsym)       (PADDR, HSYM);        // Changed for NT
    HMOD    (LPFNSYM pSHHModGetNextGlobal)  (HEXE *, HMOD);
    int     (LPFNSYM pSHModelFromAddr)      (PADDR, LPW, LPB, UOFFSET *);
    int     (LPFNSYM pSHPublicNameToAddr)   (PADDR, PADDR, LSZ, PFNCMP);
    LSZ     (LPFNSYM pSHGetSymbol)          (LPADDR, LPADDR, SOP, LPODR);
    BOOL    (LPFNSYM pSHGetPublicAddr)      (PADDR, LSZ);
    BOOL    (LPFNSYM pSHIsLabel)            (HSYM);

    VOID    (LPFNSYM pSHSetDebuggeeDir)     (LSZ);
//    VOID    (LPFNSYM pSHSetUserDir)         (LSZ);                // Deleted for NT
    BOOL    (LPFNSYM pSHAddrToLabel)        (PADDR, LSZ);

    int     (LPFNSYM pSHGetSymLoc)          (HSYM, LSZ, UINT, PCXT);
    BOOL    (LPFNSYM pSHFIsAddrNonVirtual)  (PADDR);
    BOOL    (LPFNSYM pSHIsFarProc)          (HSYM);

    HEXE    (LPFNSYM pSHGetNextExe)         (HEXE);
    HEXE    (LPFNSYM pSHHexeFromHmod)       (HMOD);
    HMOD    (LPFNSYM pSHGetNextMod)         (HEXE, HMOD);
    PCXT    (LPFNSYM pSHGetCxtFromHmod)     (HMOD, PCXT);
    PCXT    (LPFNSYM pSHSetCxt)             (PADDR, PCXT);
    PCXT    (LPFNSYM pSHSetCxtMod)          (PADDR, PCXT);
    HSYM    (LPFNSYM pSHFindNameInGlobal)   (HSYM,
                                             PCXT,
                                             LPSSTR,
                                             SHFLAG,
                                             PFNCMP,
                                             PCXT
                                            );
    HSYM    (LPFNSYM pSHFindNameInContext)  (HSYM,
                                             PCXT,
                                             LPSSTR,
                                             SHFLAG,
                                             PFNCMP,
                                             PCXT
                                            );
    HSYM    (LPFNSYM pSHGoToParent)         (PCXT, PCXT);
    HSYM    (LPFNSYM pSHHsymFromPcxt)       (PCXT);
    HSYM    (LPFNSYM pSHNextHsym)           (HMOD, HSYM);
    PCXF    (LPFNSYM pSHGetFuncCXF)         (PADDR, PCXF);
    LPCH    (LPFNSYM pSHGetModName)         (HMOD);
    LPCH    (LPFNSYM pSHGetExeName)         (HEXE);
    HEXE    (LPFNSYM pSHGethExeFromName)    (LPCH);
    UOFF32  (LPFNSYM pSHGetNearestHsym)     (PADDR, HMOD, int, PHSYM);
    SHFLAG  (LPFNSYM pSHIsInProlog)         (PCXT);
    SHFLAG  (LPFNSYM pSHIsAddrInCxt)        (PCXT, PADDR);
    SHFLAG  (LPFNSYM pSHCompareRE)          (LPCH, LPCH, BOOL);
    BOOL    (LPFNSYM pSHFindSymbol)         (LSZ, PADDR, LPASR);
    UOFF32  (LPFNSYM pPHGetNearestHsym)     (PADDR, HEXE, PHSYM);
    HSYM    (LPFNSYM pPHFindNameInPublics)  (HSYM, HEXE, LPSSTR, SHFLAG, PFNCMP);
    HTYPE   (LPFNSYM pTHGetTypeFromIndex)   (HMOD, THIDX);
    HTYPE   (LPFNSYM pTHGetNextType)        (HMOD, HTYPE);
    PVOID   (LPFNSYM pSHLpGSNGetTable)      (HEXE);
    BOOL    (LPFNSYM pSHCanDisplay)         (HSYM);

    //  Source Line handler API Exports

    BOOL    (LPFNSYM pSLLineFromAddr)       (LPADDR, LPDWORD, SHOFF *, SHOFF *);
    BOOL    (LPFNSYM pSLFLineToAddr)        (HSF, DWORD, LPADDR, SHOFF *, DWORD *);
    LPCH    (LPFNSYM pSLNameFromHsf)        (HSF);
    LPCH    (LPFNSYM pSLNameFromHmod)       (HMOD, WORD);
    BOOL    (LPFNSYM pSLFQueryModSrc)       (HMOD);
    HMOD    (LPFNSYM pSLHmodFromHsf)        (HEXE, HSF);
    HSF     (LPFNSYM pSLHsfFromPcxt)        (PCXT);
    HSF     (LPFNSYM pSLHsfFromFile)        (HMOD, LSZ);

    int     (LPFNSYM pSLCAddrFromLine)      (HEXE, HMOD, LSZ, WORD, LPSLP *);
    VOID    (LPFNSYM pSHFree)               (PVOID);
    VOID    (LPFNSYM pSHUnloadSymbolHandler)(BOOL);
// REVIEW: piersh
#ifdef NT_BUILD_ONLY
    SHE     (LPFNSYM pSHGetExeTimeStamp)    (LPSTR, ULONG *);
#else
    SHE     (LPFNSYM pSHGetExeTimeStamp)    (LPSTR, ULONG* Time, ULONG* Check);
#endif
    VOID    (LPFNSYM pSHPdbNameFromExe)     (LSZ, LSZ, UINT);
    LPVOID  (LPFNSYM pSHGetDebugData)       (HEXE);
    BOOL    (LPFNSYM pSHIsThunk)            (HSYM);
    HSYM    (LPFNSYM pSHFindSymInExe)       (HEXE, LPSSTR, BOOL);
    HSYM    (LPFNSYM pSHFindSLink32)        (PCXT);
    BOOL    (LPFNSYM pSHIsDllLoaded)        (HEXE);

// Entries added for NT work.

    LSZ     (LPFNSYM pSHGetModule)          (PADDR, LSZ);
    PCXT    (LPFNSYM pSHGetCxtFromHexe)     (HEXE, PCXT);
    LPCH    (LPFNSYM pSHGetModNameFromHexe) (HEXE);
    LPCH    (LPFNSYM pSHGetSymFName)        (HEXE);
    HEXE    (LPFNSYM pSHGethExeFromModuleName) (LPCH);
    LSZ     (LPFNSYM pSHLszGetErrorText)    (SHE);
    BOOL    (LPFNSYM pSHWantSymbols)        (HEXE);
    HSYM    (LPFNSYM pSHFindNameInTypes)    ( PCXT, LPSSTR, SHFLAG, PFNCMP, PCXT );

// Entries added for separate type pools work
    BOOL    (LPFNSYM pTHAreTypesEqual)      (HMOD, CV_typ_t, CV_typ_t);


//  New work
    BOOL    (LPFNSYM pSHSymbolsLoaded)(HEXE, SHE *);
    BOOL    (LPFNSYM pSHSymbolsLoadError)(HEXE, SHE *);
    SHE     (LPFNSYM pSHUnloadSymbols)(HEXE);

} SHF;  // Symbol Handler Functions
typedef SHF *LPSHF;

// FNSHINIT is the prototype for the SHInit function

typedef BOOL EXPCALL FNSHINIT(LPSHF *, LPKNF);

typedef FNSHINIT * LPFNSHINIT;
typedef FNSHINIT * PFNSHINIT;

typedef BOOL    (* LPFNSHUNINIT)(VOID);
typedef BOOL    (* LPFNSHSTARTBACKGROUND)(VOID);
typedef BOOL    (* LPFNSHSTOPBACKGROUND)(VOID);

// This is the only SH function that's actually exported from the DLL
FNSHINIT SHInit;

#endif // SH_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\vc\pdb.h ===
// Debug Information API
// Copyright (C) 1993-1996, Microsoft Corp.  All Rights Reserved.

#pragma once

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __PDB_INCLUDED__
#define __PDB_INCLUDED__

typedef int BOOL;
typedef unsigned UINT;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned __int64 DWORDLONG;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef ULONG   INTV;       // interface version number
typedef ULONG   IMPV;       // implementation version number
typedef ULONG   SIG;        // unique (across PDB instances) signature
typedef ULONG   AGE;        // no. of times this instance has been updated
typedef const char*     SZ_CONST;   // const string
typedef void *          PV;
typedef const void *    PCV;

#ifdef  LNGNM
#define LNGNM_CONST	const
#else   // LNGNM
#define LNGNM_CONST
#endif  // LNGNM

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID {          // size is 16
    DWORD   Data1;
    WORD    Data2;
    WORD    Data3;
    BYTE    Data4[8];
} GUID;

#endif // !GUID_DEFINED

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef long HRESULT;

#endif // !_HRESULT_DEFINED


typedef GUID            SIG70;      // new to 7.0 are 16-byte guid-like signatures
typedef SIG70 *         PSIG70;
typedef const SIG70 *   PCSIG70;

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

enum {
#ifdef LNGNM
    PDBIntv70   = 20000406,
    PDBIntv70Dep = 20000301,
#else
    PDBIntv70   = 20000301,
#endif
    PDBIntv69   = 19990511,
    PDBIntv61   = 19980914,
    PDBIntv50a  = 19970116,
    PDBIntv60   = PDBIntv50a,
    PDBIntv50   = 19960502,
    PDBIntv41   = 920924,
#ifdef LNGNM
    PDBIntv     = PDBIntv70,   // Now we support both 50 & 60, 69 is only an intermediate version
    PDBIntvAlt  = PDBIntv50,   
    PDBIntvAlt2 = PDBIntv60,   
    PDBIntvAlt3 = PDBIntv69,
#else
    PDBIntvAlt  = PDBIntv50,   // Alternate (backward compatible) supported interface
    PDBIntvAlt2 = PDBIntv60,   // Alternate (backward compatible) supported interface
    PDBIntvAlt3 = PDBIntv61,
    PDBIntv     = PDBIntv69,
#endif  
};

enum {
    PDBImpvVC2  = 19941610,
    PDBImpvVC4  = 19950623,
    PDBImpvVC41 = 19950814,
    PDBImpvVC50 = 19960307,
    PDBImpvVC98 = 19970604,
    PDBImpvVC70 = 20000404,
    PDBImpvVC70Dep = 19990604,  // deprecated vc70 implementation version
#ifdef LNGNM
    PDBImpv     = PDBImpvVC70,
#else
    PDBImpv     = PDBImpvVC98,
#endif
};


enum {
    niNil        = 0,
    PDB_MAX_PATH = 260,
    cbErrMax     = 1024,
};

// cvinfo.h type index, intentionally typedef'ed here to check equivalence.
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned long   CV_pubsymflag_t;    // must be same as CV_typ_t.

typedef CV_typ_t        TI;     // PDB name for type index
typedef CV_typ16_t      TI16;   // 16-bit version
typedef unsigned long   NI;     // name index
typedef TI *            PTi;
typedef TI16 *          PTi16;

typedef BYTE            ITSM;   // type server map index
typedef ITSM*           PITSM;

typedef BOOL    (__stdcall *PFNVALIDATEDEBUGINFOFILE) (const char * szFile, ULONG * errcode );

typedef struct _tagSEARCHDEBUGINFO {
    DWORD   cb;                         // doubles as version detection
    BOOL    fMainDebugFile;             // indicates "core" or "ancilliary" file
                                        // eg: main.exe has main.pdb and foo.lib->foo.pdb
    char *  szMod;                      // exe/dll
    char *  szLib;                      // lib if appropriate
    char *  szObj;                      // object file
    char * *rgszTriedThese;             // list of ones that were tried,
                                        // NULL terminated list of LSZ's
    char  szValidatedFile[PDB_MAX_PATH];// output of validated filename,
    PFNVALIDATEDEBUGINFOFILE
            pfnValidateDebugInfoFile;   // validation function
    char *  szExe;                      // exe/dll
} SEARCHDEBUGINFO, *PSEARCHDEBUGINFO;

typedef BOOL ( __stdcall * PfnFindDebugInfoFile) ( PSEARCHDEBUGINFO );

#define PdbInterface struct

PdbInterface PDB;                   // program database
PdbInterface DBI;                   // debug information within the PDB
PdbInterface Mod;                   // a module within the DBI
PdbInterface TPI;                   // type info within the DBI
PdbInterface GSI;                   // global symbol info
PdbInterface SO;                    
PdbInterface Stream;                // some named bytestream in the PDB
PdbInterface StreamImage;           // some memory mapped stream
PdbInterface NameMap;              // name mapping
PdbInterface Enum;                 // generic enumerator
PdbInterface EnumNameMap;          // enumerate names within a NameMap
PdbInterface EnumContrib;          // enumerate contributions
PdbInterface Dbg;                   // misc debug data (FPO, OMAP, etc)
PdbInterface Src;                   // Src file data
PdbInterface EnumSrc;               // Src file enumerator
PdbInterface SrcHash;               // Src file hasher
PdbInterface EnumLines;

typedef PdbInterface PDB PDB;
typedef PdbInterface DBI DBI;
typedef PdbInterface Mod Mod;
typedef PdbInterface TPI TPI;
typedef PdbInterface GSI GSI;
typedef PdbInterface SO SO;
typedef PdbInterface Stream Stream;
typedef PdbInterface StreamImage StreamImage;
typedef PdbInterface NameMap NameMap;
typedef PdbInterface Enum Enum;
typedef PdbInterface EnumStreamNames EnumStreamNames;
typedef PdbInterface EnumNameMap EnumNameMap;
typedef PdbInterface EnumContrib EnumContrib;
typedef PdbInterface WidenTi WidenTi;
typedef PdbInterface Dbg Dbg;
typedef PdbInterface EnumThunk EnumThunk;
typedef PdbInterface Src Src;
typedef PdbInterface EnumSrc EnumSrc;
typedef PdbInterface SrcHash SrcHash;

typedef SrcHash *   PSrcHash;

typedef long EC;            // error code
enum PDBErrors {
    EC_OK,                  // -, no problemo
    EC_USAGE,               // -, invalid parameter or call order
    EC_OUT_OF_MEMORY,       // -, out of RAM
    EC_FILE_SYSTEM,         // "pdb name", can't write file, out of disk, etc.
    EC_NOT_FOUND,           // "pdb name", PDB file not found
    EC_INVALID_SIG,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_INVALID_AGE,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_PRECOMP_REQUIRED,    // "obj name", Mod::AddTypes() only
    EC_OUT_OF_TI,           // "pdb name", TPI::QueryTiForCVRecord() only
    EC_NOT_IMPLEMENTED,     // -
    EC_V1_PDB,              // "pdb name", PDB::Open* only
    EC_FORMAT,              // accessing pdb with obsolete format
    EC_LIMIT,
    EC_CORRUPT,             // cv info corrupt, recompile mod
    EC_TI16,                // no 16-bit type interface present
    EC_ACCESS_DENIED,       // "pdb name", PDB file read-only
    EC_ILLEGAL_TYPE_EDIT,   // trying to edit types in read-only mode
    EC_INVALID_EXECUTABLE,  // not recogized as a valid executable
    EC_DBG_NOT_FOUND,       // A required .DBG file was not found
    EC_NO_DEBUG_INFO,       // No recognized debug info found
    EC_INVALID_EXE_TIMESTAMP, // Invalid timestamp on Openvalidate of exe
    EC_RESERVED, // RESERVED for future use
    EC_DEBUG_INFO_NOT_IN_PDB, // returned by OpenValidateX
    EC_MAX
};

#define  pure = 0

#ifndef PDBCALL
#define PDBCALL  __cdecl
#endif

#ifdef PDB_SERVER
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllexport) RTYPE PDBCALL
#elif   defined(PDB_LIBRARY)
#define PDB_IMPORT_EXPORT(RTYPE)    RTYPE PDBCALL
#else
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllimport) RTYPE PDBCALL
#endif

#define PDBAPI PDB_IMPORT_EXPORT

#ifndef IN
#define IN                  /* in parameter, parameters are IN by default */
#endif
#ifndef OUT
#define OUT                 /* out parameter */
#endif

// Type of callback arg to PDB::OpenValidate5

enum POVC
{
    povcNotifyDebugDir,
    povcNotifyOpenDBG,
    povcNotifyOpenPDB,
    povcNotifySymbolServerQuery,
    povcReadExecutableAt,
    povcReadExecutableAtRVA,
};

typedef int (PDBCALL *PDBCALLBACK)();

typedef PDBCALLBACK (PDBCALL *PfnPDBQueryCallback)(void *pvClient, enum POVC povc);

typedef void (PDBCALL *PfnPDBNotifyDebugDir)(void *pvClient, BOOL fExecutable, const struct _IMAGE_DEBUG_DIRECTORY *pdbgdir);
typedef void (PDBCALL *PfnPDBNotifyOpenDBG)(void *pvClient, const wchar_t *wszDbgPath, enum PDBErrors ec, const wchar_t *wszError);
typedef void (PDBCALL *PfnPDBNotifyOpenPDB)(void *pvClient, const wchar_t *wszPdbPath, enum PDBErrors ec, const wchar_t *wszError);
typedef void (PDBCALL *PfnPDBNotifySymbolServerQuery)(void *pvClient, const char *szURL, HRESULT hr);
typedef HRESULT (PDBCALL *PfnPDBReadExecutableAt)(void *pvClient, DWORDLONG fo, DWORD cb, void *pv);
typedef HRESULT (PDBCALL *PfnPDBReadExecutableAtRVA)(void *pvClient, DWORD rva, DWORD cb, void *pv);

// type of callback arg to PDB::GetRawBytes
typedef BOOL (PDBCALL *PFNfReadPDBRawBytes)(const void *, long);

// WidenTi interface needs a couple of structures to communicate info back
// and forth.
struct OffMap {
    ULONG       offOld;
    ULONG       offNew;
};
typedef struct OffMap   OffMap;
typedef OffMap *        POffMap;

struct SymConvertInfo {
    ULONG       cbSyms;             // size necessary for converting a block
    ULONG       cSyms;              // count of symbols, necessary to allocate
                                    // mpoffOldoffNew array.
    BYTE *      pbSyms;             // block of symbols (output side)
    OffMap *    rgOffMap;           // OffMap rgOffMap[cSyms]
};
typedef struct SymConvertInfo   SymConvertInfo;
enum { wtiSymsNB09 = 0, wtiSymsNB10 = 1 };

// Filter values for PDBCopyTo
enum { 
    copyRemovePrivate       = 0x00000001,   // remove private debug information
    copyCreateNewSig        = 0x00000002,   // create new signature for target pdb
};

// PDBCopy callback signatures and function pointer types for PDB::CopyTo2 and CopyToW2
//
enum PCC {
    pccFilterPublics,
};

#if !defined(__cplusplus)
typedef enum PCC    PCC;
#endif  // __cplusplus

typedef BOOL (PDBCALL *PDBCOPYCALLBACK)();
typedef PDBCOPYCALLBACK (PDBCALL *PfnPDBCopyQueryCallback)(void *pvClientContext, PCC pcc);

// Return (true, pszNewPublic==NULL) to keep the name as is,
// (true, pszNewPublic!=NULL) changes name to pszNewPublic,
// false to discard public entirely.
//
typedef BOOL (PDBCALL *PfnPDBCopyFilterPublics)(
    void *          pvClientContext,
    DWORD           dwFilterFlags,
    unsigned int    offPublic,
    unsigned int    sectPublic,
    unsigned int    grfPublic,      // see cvinfo.h, definition of CV_PUBSYMFLAGS_e and
                                    // CV_PUBSYMFLAGS give the format of this bitfield.
    const wchar_t * szPublic,
    wchar_t **      pszNewPublic
    );

enum DBGTYPE {
    dbgtypeFPO,
    dbgtypeException,   // deprecated
    dbgtypeFixup,
    dbgtypeOmapToSrc,
    dbgtypeOmapFromSrc,
    dbgtypeSectionHdr,
#if !defined(VER60)
    dbgtypeTokenRidMap,
    dbgtypeXData,
    dbgtypePData,
    dbgtypeNewFPO,
#endif
    dbgtypeMax          // must be last!
};

typedef enum DBGTYPE DBGTYPE;

// Linker data necessary for relinking an image.  Record contains two SZ strings
// off of the end of the record with two offsets from the base 
//
enum VerLinkInfo {
    vliOne = 1,
    vliTwo = 2,
    vliCur = vliTwo,
};

struct LinkInfo {
    ULONG           cb;             // size of the whole record.  computed as
                                    //  sizeof(LinkInfo) + strlen(szCwd) + 1 +
                                    //  strlen(szCommand) + 1
    ULONG           ver;            // version of this record (VerLinkInfo)
    ULONG           offszCwd;       // offset from base of this record to szCwd
    ULONG           offszCommand;   // offset from base of this record
    ULONG           ichOutfile;     // index of start of output file in szCommand
    ULONG           offszLibs;      // offset from base of this record to szLibs

    // The command includes the full path to the linker, the -re and -out:...
    // swithches.
    // A sample might look like the following:
    // "c:\program files\msdev\bin\link.exe -re -out:debug\foo.exe"
    // with ichOutfile being 48.
    // the -out switch is guaranteed to be the last item in the command line.
#ifdef __cplusplus
    VerLinkInfo Ver() const {
        return VerLinkInfo(ver);
    }
    long Cb() const {
        return cb;
    }
    char *     SzCwd() const {
        return (char *)((char *)(this) + offszCwd);
    }
    char *    SzCommand() const {
        return (char *)((char *)(this) + offszCommand);
    }
    char *    SzOutFile() const {
        return SzCommand() + ichOutfile;
    }
    LinkInfo() :
        cb(0), ver(vliCur), offszCwd(0), offszCommand(0), ichOutfile(0)
    {
    }
    char *    SzLibs() const {
        return (char *)((char *)(this) + offszLibs);
    }

#endif
};

#ifdef LNGNM
#ifdef __cplusplus
struct LinkInfoW : public LinkInfo
{
    wchar_t* SzCwdW() const {
        return (wchar_t *)((wchar_t *)(this) + offszCwd);
    }
    wchar_t* SzCommandW() const {
        return (wchar_t *)((wchar_t *)(this) + offszCommand);
    }
    wchar_t* SzOutFileW() const {
        return SzCommandW() + ichOutfile;
    }
    wchar_t* SzLibsW() const {
        return (wchar_t *)((wchar_t *)(this) + offszLibs);
    }
};
#else
typedef struct LinkInfo LinkInfoW;
#endif  // __cplusplus

typedef LinkInfoW * PLinkInfoW;

#endif  // LNGNM

typedef struct LinkInfo LinkInfo;
typedef LinkInfo *      PLinkInfo;


//
// Source (Src) info
//
// This is the source file server for virtual and real source code.
// It is structured as an index on the object file name concatenated
// with 
enum SrcVer {
    srcverOne = 19980827,
};

enum SrcCompress {
    srccompressNone,
    srccompressRLE,
    srccompressHuffman,
    srccompressLZ,
};

#ifdef LNGNM
struct tagSrcHeader {
#else
struct SrcHeader {
#endif
    unsigned long   cb;         // record length
    unsigned long   ver;        // header version
    unsigned long   sig;        // CRC of the data for uniqueness w/o full compare
    unsigned long   cbSource;   // count of bytes of the resulting source
    unsigned char   srccompress;// compression algorithm used
    union {
        unsigned char       grFlags;
        struct {
            unsigned char   fVirtual : 1;   // file is a virtual file (injected)
            unsigned char   pad : 7;        // must be zero
        };
    };
#ifndef LNGNM
    unsigned char   szNames[1]; // file names (szFile "\0" szObj "\0" szVirtual,
                                //  as in: "f.cpp" "\0" "f.obj" "\0" "*inj:1:f.obj")
                                // in the case of non-virtual files, szVirtual is
                                // the same as szFile.
#endif
};

#ifdef LNGNM
struct SrcHeader : public tagSrcHeader
{
    unsigned char szNames[1];   // see comment above
};

struct SrcHeaderW : public tagSrcHeader
{
    wchar_t szNames[1];   // see comment above
};

typedef struct SrcHeaderW    SrcHeaderW;
typedef SrcHeaderW *         PSrcHeaderW;
typedef const SrcHeaderW *   PCSrcHeaderW;

//cassert(offsetof(SrcHeader,szNames) == sizeof(tagSrcHeader));
//cassert(offsetof(SrcHeaderW,szNames) == sizeof(tagSrcHeader));

#endif      // LNGNM

typedef struct SrcHeader    SrcHeader;
typedef SrcHeader *         PSrcHeader;
typedef const SrcHeader *   PCSrcHeader;

// header used for storing the info and for output to clients who are reading
//
struct SrcHeaderOut {
    unsigned long   cb;         // record length
    unsigned long   ver;        // header version
    unsigned long   sig;        // CRC of the data for uniqueness w/o full compare
    unsigned long   cbSource;   // count of bytes of the resulting source
    unsigned long   niFile;
    unsigned long   niObj;
    unsigned long   niVirt;
    unsigned char   srccompress;// compression algorithm used
    union {
        unsigned char       grFlags;
        struct {
            unsigned char   fVirtual : 1;   // file is a virtual file (injected)
            unsigned char   pad : 7;        // must be zero
        };
    };
    short           sPad;
    union {
        void *      pvReserved1;
        __int64     pv64Reserved2;
    };
};

typedef struct SrcHeaderOut SrcHeaderOut;
typedef SrcHeaderOut *      PSrcHeaderOut;
typedef const SrcHeaderOut *PCSrcHeaderOut;

struct SrcHeaderBlock {
    __int32     ver;
    __int32     cb;
    struct {
        DWORD   dwLowDateTime;
        DWORD   dwHighDateTime;
    } ft;
    __int32     age;
    BYTE        rgbPad[44];
};

typedef struct SrcHeaderBlock   SrcHeaderBlock;


#ifdef __cplusplus

struct IStream;

// C++ Binding

PdbInterface PDB {                 // program database
    enum {
        intv  = PDBIntv,
#if defined(LNGNM)
        intvVC70Dep = PDBIntv70Dep, // deprecated
#endif
        intvAlt = PDBIntvAlt,
        intvAlt2 = PDBIntvAlt2,
        intvAlt3 = PDBIntvAlt3,
    };

    static PDBAPI(BOOL)
           OpenValidate(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               OUT EC* pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidateEx(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPathOrig,
               LNGNM_CONST char *szSearchPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           Open(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szMode,
               SIG sigInitial,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate2(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               long cbPage,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidateEx2(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPathOrig,
               LNGNM_CONST char *szSearchPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               long cbPage,
               OUT EC* pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenEx(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szMode,
               SIG sigInitial,
               long cbPage,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate3(
               const char *szExecutable,
               const char *szSearchPath,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT char szDbgPath[PDB_MAX_PATH],
               OUT DWORD *pfo,
               OUT DWORD *pcb,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate4(
               const wchar_t *wszPDB,
               const char *szMode,
               PCSIG70 pcsig70,
               SIG sig,
               AGE age,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL) OpenInStream(
               IStream *pIStream,
               const char *szMode,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL) ExportValidateInterface(INTV intv);
    static PDBAPI(BOOL) ExportValidateImplementation(IMPV impv);

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual EC   QueryLastError(OUT char szError[cbErrMax]) pure;
    virtual char*QueryPDBName(OUT char szPDB[PDB_MAX_PATH]) pure;
    virtual SIG  QuerySignature() pure;
    virtual AGE  QueryAge() pure;
    virtual BOOL CreateDBI(const char* szTarget, OUT DBI** ppdbi) pure;
    virtual BOOL OpenDBI(const char* szTarget, const char* szMode, OUT DBI** ppdbi ) pure;
    virtual BOOL OpenTpi(const char* szMode, OUT TPI** pptpi) pure;

    virtual BOOL Commit() pure;
    virtual BOOL Close() pure;
    virtual BOOL OpenStream(const char* szStream, OUT Stream** ppstream) pure;
    virtual BOOL GetEnumStreamNameMap(OUT Enum** ppenum) pure;
    virtual BOOL GetRawBytes(PFNfReadPDBRawBytes fSnarfRawBytes) pure;
    virtual IMPV QueryPdbImplementationVersion() pure;

    virtual BOOL OpenDBIEx(const char* szTarget, const char* szMode, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn=0) pure;

    virtual BOOL CopyTo(const char *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;

    //
    // support for source file data
    //
    virtual BOOL OpenSrc(OUT Src** ppsrc) pure;

    virtual EC   QueryLastErrorExW(OUT wchar_t *wszError, size_t cchMax) pure;
    virtual wchar_t *QueryPDBNameExW(OUT wchar_t *wszPDB, size_t cchMax) pure;
    virtual BOOL QuerySignature2(PSIG70 psig70) pure;
    virtual BOOL CopyToW(const wchar_t *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;
    virtual BOOL fIsSZPDB() const pure;
#ifdef LNGNM
    virtual BOOL OpenStreamW(const wchar_t * szStream, OUT Stream** ppstream) pure;
#endif


    inline BOOL ValidateInterface()
    {
        return ExportValidateInterface(intv);
    }

    static PDBAPI(BOOL)
           Open2W(
               const wchar_t *wszPDB,
               const char *szMode,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenEx2W(
               const wchar_t *wszPDB,
               const char *szMode,
               long cbPage,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate5(
               const wchar_t *wszExecutable,
               const wchar_t *wszSearchPath,
               void *pvClient,
               PfnPDBQueryCallback pfnQueryCallback,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);


};


// Review: a stream directory service would be more appropriate
// than Stream::Delete, ...

PdbInterface Stream {
    virtual long QueryCb() pure;
    virtual BOOL Read(long off, void* pvBuf, long* pcbBuf) pure;
    virtual BOOL Write(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Replace(void* pvBuf, long cbBuf) pure;
    virtual BOOL Append(void* pvBuf, long cbBuf) pure;
    virtual BOOL Delete() pure;
    virtual BOOL Release() pure;
    virtual BOOL Read2(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Truncate(long cb) pure;
};

PdbInterface StreamImage {
    static PDBAPI(BOOL) open(Stream* pstream, long cb, OUT StreamImage** ppsi);
    virtual long size() pure;
    virtual void* base() pure;
    virtual BOOL noteRead(long off, long cb, OUT void** ppv) pure;
    virtual BOOL noteWrite(long off, long cb, OUT void** ppv) pure;
    virtual BOOL writeBack() pure;
    virtual BOOL release() pure;
};

PdbInterface DBI {             // debug information
    enum { intv = PDBIntv };
    virtual IMPV QueryImplementationVersion() pure;
    virtual INTV QueryInterfaceVersion() pure;
    virtual BOOL OpenMod(const char* szModule, const char* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteMod(const char* szModule) pure;
    virtual BOOL QueryNextMod(Mod* pmod, Mod** ppmodNext) pure;
    virtual BOOL OpenGlobals(OUT GSI **ppgsi) pure;
    virtual BOOL OpenPublics(OUT GSI **ppgsi) pure;
    virtual BOOL AddSec(USHORT isect, USHORT flags, long off, long cb) pure;
    virtual BOOL QueryModFromAddr(USHORT isect, long off, OUT Mod** ppmod,
                    OUT USHORT* pisect, OUT long* poff, OUT long* pcb) pure;
    virtual BOOL QuerySecMap(OUT BYTE* pb, long* pcb) pure;
    virtual BOOL QueryFileInfo(OUT BYTE* pb, long* pcb) pure;
    virtual void DumpMods() pure;
    virtual void DumpSecContribs() pure;
    virtual void DumpSecMap() pure;

    virtual BOOL Close() pure;
    virtual BOOL AddThunkMap(long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                    struct SO* psoSectMap, unsigned nSects,
                    USHORT isectThunkTable, long offThunkTable) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL getEnumContrib(OUT Enum** ppenum) pure;
    virtual BOOL QueryTypeServer( ITSM itsm, OUT TPI** pptpi ) pure;
    virtual BOOL QueryItsmForTi( TI ti, OUT ITSM* pitsm ) pure;
    virtual BOOL QueryNextItsm( ITSM itsm, OUT ITSM *inext ) pure;
    virtual BOOL QueryLazyTypes() pure;
    virtual BOOL SetLazyTypes( BOOL fLazy ) pure;   // lazy is default and can only be turned off
    virtual BOOL FindTypeServers( OUT EC* pec, OUT char szError[cbErrMax] ) pure;
    virtual void DumpTypeServers() pure;
    virtual BOOL OpenDbg(DBGTYPE dbgtype, OUT Dbg **ppdbg) pure;
    virtual BOOL QueryDbgTypes(OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype) pure;
    // apis to support EnC work
    virtual BOOL QueryAddrForSec(OUT USHORT* pisect, OUT long* poff, 
            USHORT imod, long cb, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdb( OUT PDB** pppdb ) pure;
    virtual BOOL AddLinkInfo(IN PLinkInfo ) pure;
    virtual BOOL QueryLinkInfo(PLinkInfo, OUT long * pcb) pure;
    // new to vc6
    virtual AGE  QueryAge() const pure;
    virtual void * QueryHeader() const pure;
    virtual void FlushTypeServers() pure;
    virtual BOOL QueryTypeServerByPdb(const char* szPdb, OUT ITSM* pitsm) pure;

#ifdef LNGNM        // Long filename support
    virtual BOOL OpenModW(const wchar_t* szModule, const wchar_t* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteModW(const wchar_t* szModule) pure;
    virtual BOOL AddPublicW(const wchar_t* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL QueryTypeServerByPdbW( const wchar_t* szPdb, OUT ITSM* pitsm ) pure;
    virtual BOOL AddLinkInfoW(IN PLinkInfoW ) pure;
    virtual BOOL AddPublic2(const char* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual USHORT QueryMachineType() const pure;
    virtual void SetMachineType(USHORT wMachine) pure;
    virtual void RemoveDataForRva( ULONG rva, ULONG cb ) pure;
#endif

};

PdbInterface Mod {             // info for one module within DBI
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BOOL AddTypes(BYTE* pbTypes, long cb) pure;
    virtual BOOL AddSymbols(BYTE* pbSym, long cb) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL AddLines(const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          USHORT lineStart, BYTE* pbCoff, long cbCoff) pure;
    virtual BOOL AddSecContrib(USHORT isect, long off, long cb, ULONG dwCharacteristics) pure;
    virtual BOOL QueryCBName(OUT long* pcb) pure;
    virtual BOOL QueryName(OUT char szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySymbols(BYTE* pbSym, long* pcb) pure;
    virtual BOOL QueryLines(BYTE* pbLines, long* pcb) pure;

    virtual BOOL SetPvClient(void *pvClient) pure;
    virtual BOOL GetPvClient(OUT void** ppvClient) pure;
    virtual BOOL QueryFirstCodeSecContrib(OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
//
// Make all users of this api use the real one, as this is exactly what it was
// supposed to query in the first place
//
#define QuerySecContrib QueryFirstCodeSecContrib

    virtual BOOL QueryImod(OUT USHORT* pimod) pure;
    virtual BOOL QueryDBI(OUT DBI** ppdbi) pure;
    virtual BOOL Close() pure;
    virtual BOOL QueryCBFile(OUT long* pcb) pure;
    virtual BOOL QueryFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryTpi(OUT TPI** pptpi) pure; // return this Mod's Tpi
    // apis to support EnC work
    virtual BOOL AddSecContribEx(USHORT isect, long off, long cb, ULONG dwCharacteristics, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QueryItsm(OUT USHORT* pitsm) pure;
    virtual BOOL QuerySrcFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdbFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL ReplaceLines(BYTE* pbLines, long cb) pure;
#ifdef LNGNM
    // V7 line number support
	virtual bool GetEnumLines( EnumLines** ppenum ) pure;
	virtual bool QueryLineFlags( OUT DWORD* pdwFlags ) pure;	// what data is present?
	virtual bool QueryFileNameInfo( 
                    IN DWORD        fileId,                 // source file identifier
                    OUT wchar_t*    szFilename,             // file name string 
                    IN OUT DWORD*   pccFilename,            // length of string
                    OUT DWORD*      pChksumType,            // type of chksum
                    OUT BYTE*       pbChksum,   	        // pointer to buffer for chksum data
                    IN OUT DWORD*   pcbChksum		        // number of bytes of chksum (in/out)
                    ) pure; 	    
    // Long filenames support
    virtual BOOL AddPublicW(const wchar_t* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL AddLinesW(const wchar_t* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          ULONG lineStart, BYTE* pbCoff, long cbCoff) pure;
    virtual BOOL QueryNameW(OUT wchar_t szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySrcFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryPdbFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL AddPublic2(const char* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
#endif
};

PdbInterface TPI {             // type info

    enum { intv = PDBIntv };

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;

    virtual BOOL QueryTi16ForCVRecord(BYTE* pb, OUT TI16* pti) pure;
    virtual BOOL QueryCVRecordForTi16(TI16 ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi16(TI16 ti, OUT BYTE** ppb) pure;
    virtual TI16 QueryTi16Min() pure;
    virtual TI16 QueryTi16Mac() pure;

    virtual long QueryCb() pure;
    virtual BOOL Close() pure;
    virtual BOOL Commit() pure;

    virtual BOOL QueryTi16ForUDT(LNGNM_CONST char *sz, BOOL fCase, OUT TI16* pti) pure;
    virtual BOOL SupportQueryTiForUDT() pure;

    // the new versions that truly take 32-bit types
    virtual BOOL fIs16bitTypePool() pure;
    virtual BOOL QueryTiForUDT(LNGNM_CONST char *sz, BOOL fCase, OUT TI* pti) pure;
    virtual BOOL QueryTiForCVRecord(BYTE* pb, OUT TI* pti) pure;
    virtual BOOL QueryCVRecordForTi(TI ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi(TI ti, OUT BYTE** ppb) pure;
    virtual TI   QueryTiMin() pure;
    virtual TI   QueryTiMac() pure;
    virtual BOOL AreTypesEqual( TI ti1, TI ti2 ) pure;
    virtual BOOL IsTypeServed( TI ti ) pure;
#ifdef LNGNM
    virtual BOOL QueryTiForUDTW(const wchar_t *wcs, BOOL fCase, OUT TI* pti) pure;
#endif
};

PdbInterface GSI {
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BYTE* NextSym(BYTE* pbSym) pure;
    virtual BYTE* HashSym(const char* szName, BYTE* pbSym) pure;
    virtual BYTE* NearestSym(USHORT isect, long off, OUT long* pdisp) pure;      //currently only supported for publics
    virtual BOOL Close() pure;
    virtual BOOL getEnumThunk(USHORT isect, long off, OUT EnumThunk** ppenum) pure;
    virtual unsigned long OffForSym(BYTE *pbSym) pure;
    virtual BYTE* SymForOff(unsigned long off) pure;
#ifdef LNGNM
    virtual BYTE* HashSymW(const wchar_t *wcsName, BYTE* pbSym) pure;
#endif
};


PdbInterface NameMap {
    static PDBAPI(BOOL) open(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
    virtual BOOL close() pure;
    virtual BOOL reinitialize() pure;
    virtual BOOL getNi(const char* sz, OUT NI* pni) pure;
    virtual BOOL getName(NI ni, OUT const char** psz) pure;
    virtual BOOL getEnumNameMap(OUT Enum** ppenum) pure;
    virtual BOOL contains(const char* sz, OUT NI* pni) pure;
    virtual BOOL commit() pure;
    virtual BOOL isValidNi(NI ni) pure;
#ifdef LNGNM
    virtual BOOL getNiW(const wchar_t* sz, OUT NI* pni) pure;
    virtual BOOL getNameW(NI ni, OUT wchar_t* szName, IN OUT size_t * pcch) pure;
    virtual BOOL containsW(const wchar_t *sz, OUT NI* pni) pure;
#endif
};

#define __ENUM_INCLUDED__
PdbInterface Enum {
    virtual void release() pure;
    virtual void reset() pure;
    virtual BOOL next() pure;
};

PdbInterface EnumNameMap : Enum {
    virtual void get(OUT const char** psz, OUT NI* pni) pure;
};

PdbInterface EnumContrib : Enum {
    virtual void get(OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
    virtual void getCrcs(OUT DWORD* pcrcData, OUT DWORD* pcrcReloc ) pure;
    virtual bool fUpdate(IN long off, IN long cb) pure;
};

PdbInterface EnumThunk: Enum {
	virtual void get( OUT USHORT* pisect, OUT long* poff, OUT long* pcb ) pure;
};

struct CV_Line_t;
struct CV_Column_t;
PdbInterface EnumLines: public Enum
{
    // 
    // Blocks of lines are always in offset order, lines within blocks are also ordered by offset
    //
    virtual bool getLines( 	
        OUT DWORD*      fileId, 	// id for the filename
        OUT DWORD*      poffset,	// offset part of address
        OUT WORD*	    pseg, 		// segment part of address
        OUT DWORD*      pcb,        // count of bytes of code described by this block
        IN OUT DWORD*   pcLines, 	// number of lines (in/out)
        OUT CV_Line_t*  pLines		// pointer to buffer for line info
        ) = 0;
    virtual bool getLinesColumns( 	
        OUT DWORD*      fileId,     // id for the filename	    
        OUT DWORD*      poffset, 	// offset part of address
        OUT WORD*	    pseg, 		// segment part of address
        OUT DWORD*      pcb,        // count of bytes of code described by this block
        IN OUT DWORD*   pcLines,    // number of lines (in/out)
        OUT CV_Line_t*  pLines,		// pointer to buffer for line info
        OUT CV_Column_t*pColumns	// pointer to buffer for column info
        ) = 0;
};

//
// interface to use to widen type indices from 16 to 32 bits
// and store the results in a new location.
//
PdbInterface WidenTi {
public:
    static PDBAPI(BOOL)
    fCreate (
        WidenTi *&,
        unsigned cTypeInitialCache =256,
        BOOL fNB10Syms =wtiSymsNB09
        );

    virtual void
    release() pure;

    virtual BYTE /* TYPTYPE */ *
    pTypeWidenTi ( TI ti16, BYTE /* TYPTYPE */ * ) pure;

    virtual BYTE /* SYMTYPE */ *
    pSymWidenTi ( BYTE /* SYMTYPE */ * ) pure;

    virtual BOOL
    fTypeWidenTiNoCache ( BYTE * pbTypeDst, BYTE * pbTypeSrc, long & cbDst ) pure;

    virtual BOOL
    fSymWidenTiNoCache ( BYTE * pbSymDst, BYTE * pbSymSrc, long & cbDst ) pure;

    virtual BOOL
    fTypeNeedsWidening ( BYTE * pbType ) pure;

    virtual BOOL
    fSymNeedsWidening ( BYTE * pbSym ) pure;

    virtual BOOL
    freeRecord ( void * ) pure;

    // symbol block converters/query.  symbols start at doff from pbSymIn,
    // converted symbols will go at sci.pbSyms + doff, cbSyms are all including
    // doff.
    virtual BOOL
        fQuerySymConvertInfo (
        SymConvertInfo &    sciOut,
        BYTE *              pbSym,
        long                cbSym,
        int                 doff =0
        ) pure;

    virtual BOOL
    fConvertSymbolBlock (
        SymConvertInfo &    sciOut,
        BYTE *              pbSymIn,
        long                cbSymIn,
        int                 doff =0
        ) pure;
};

// interface for managing Dbg data
PdbInterface Dbg {
   // close Dbg Interface
   virtual BOOL Close() pure;
   // return number of elements (NOT bytes)
   virtual long QuerySize() pure;
   // reset enumeration index
   virtual void Reset() pure;
   // skip next celt elements (move enumeration index)
   virtual BOOL Skip(ULONG celt) pure;
   // query next celt elements into user-supplied buffer
   virtual BOOL QueryNext(ULONG celt, OUT void *rgelt) pure;
   // search for an element and fill in the entire struct given a field.
   // Only supported for the following debug types and fields:
   // DBG_FPO              'ulOffStart' field of FPO_DATA
   // DBG_FUNC             'StartingAddress' field of IMAGE_FUNCTION_ENTRY
   // DBG_OMAP             'rva' field of OMAP
   virtual BOOL Find(IN OUT void *pelt) pure;
   // remove debug data
   virtual BOOL Clear() pure;
   // append celt elements
   virtual BOOL Append(ULONG celt, const void *rgelt) pure;
   // replace next celt elements
   virtual BOOL ReplaceNext(ULONG celt, const void *rgelt) pure;
};

PdbInterface Src {
    // close and commit the changes (when open for write)
    virtual bool
    Close() pure;

    // add a source file or file-ette
    virtual bool
    Add(IN PCSrcHeader psrcheader, IN const void * pvData) pure;

    // remove a file or file-ette or all of the injected code for
    // one particular compiland (using the object file name)
    virtual bool
    Remove(IN SZ_CONST szFile) pure;

    // query and copy the header/control data to the output buffer
    virtual bool
    QueryByName(IN SZ_CONST szFile, OUT PSrcHeaderOut psrcheaderOut) const pure;

    // copy the file data (the size of the buffer is in the SrcHeaderOut
    // structure) to the output buffer.
    virtual bool
    GetData(IN PCSrcHeaderOut pcsrcheader, OUT void * pvData) const pure;

    // create an enumerator to traverse all of the files included
    // in the mapping.
    virtual bool
    GetEnum(OUT EnumSrc ** ppenum) const pure;

    // Get the header block (master header) of the Src data.
    // Includes age, time stamp, version, and size of the master stream
    virtual bool
    GetHeaderBlock(SrcHeaderBlock & shb) const pure;
#ifdef LNGNM
    virtual bool RemoveW(IN wchar_t *wcsFile) pure;
    virtual bool QueryByNameW(IN wchar_t *wcsFile, OUT PSrcHeaderOut psrcheaderOut) const pure;
    virtual bool AddW(IN PCSrcHeaderW psrcheader, IN const void * pvData) pure;
#endif
};

PdbInterface EnumSrc : Enum {
    virtual void get(OUT PCSrcHeaderOut * ppcsrcheader) pure;
};


PdbInterface SrcHash {

    // Various types we need
    //
    
    // Tri-state return type
    //
    enum TriState {
        tsYes,
        tsNo,
        tsMaybe,
    };

    // Hash identifier
    //
    enum HID {
        hidNone,
        hidMD5,
        hidMax,
    };

    // Define machine independent types for storage of HashID and size_t
    //
    typedef __int32 HashID_t;
    typedef unsigned __int32 CbHash_t;

    // Create a SrcHash object with the usual two-stage construction technique
    //
    static PDBAPI(bool)
    FCreateSrcHash(OUT PSrcHash &);

    // Accumulate more bytes into the hash
    //
    virtual bool
    FHashBuffer(IN PCV pvBuf, IN size_t cbBuf) pure;

    // Query the hash id
    //
    virtual HashID_t
    HashID() const pure;

    // Query the size of the hash 
    //
    virtual CbHash_t
    CbHash() const pure;

    // Copy the hash bytes to the client buffer
    //
    virtual void
    GetHash(OUT PV pvHash, IN CbHash_t cbHash) const pure;

    // Verify the incoming hash against a target buffer of bytes
    // returning a yes it matches, no it doesn't, or indeterminate.
    //
    virtual TriState
    TsVerifyHash(
        IN HID,
        IN CbHash_t cbHash,
        IN PCV pvHash,
        IN size_t cbBuf,
        IN PCV pvBuf
        ) pure;

    // Reset this object to pristine condition
    //
    virtual bool
    FReset() pure;

    // Close off and release this object
    //
    virtual void
    Close() pure;
};

#endif  // __cplusplus

// ANSI C Binding

#if __cplusplus
extern "C" {
#endif

typedef BOOL (PDBCALL *PfnPDBOpen)(
    LNGNM_CONST char *,
    LNGNM_CONST char *,
    SIG,
    EC *,
    char [cbErrMax],
    PDB **);

PDBAPI(BOOL)
PDBOpen(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szMode,
    SIG sigInitial,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenEx(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szMode,
    SIG sigInitial,
    long cbPage,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpen2W(
    const wchar_t *wszPDB,
    const char *szMode,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenEx2W(
    const wchar_t *wszPDB,
    const char *szMode,
    long cbPage,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPathOrig,
    LNGNM_CONST char *szSearchPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate2(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx2(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPathOrig,
    LNGNM_CONST char *szSearchPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate3(
    const char *szExecutable,
    const char *szSearchPath,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT char szDbgPath[PDB_MAX_PATH],
    OUT DWORD *pfo,
    OUT DWORD *pcb,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate4(
    const wchar_t *wszPDB,
    const char *szMode,
    PCSIG70 pcsig70,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate5(
    const wchar_t *wszExecutable,
    const wchar_t *wszSearchPath,
    void *pvClient,
    PfnPDBQueryCallback pfnQueryCallback,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

// a dbi client should never call PDBExportValidateInterface directly - use PDBValidateInterface
PDBAPI(BOOL)
PDBExportValidateInterface(
    INTV intv);

__inline BOOL PDBValidateInterface()
{
    return PDBExportValidateInterface(PDBIntv);
}

typedef BOOL (PDBCALL *PfnPDBExportValidateInterface)(INTV);

__inline BOOL PDBValidateInterfacePfn(PfnPDBExportValidateInterface pfn)
{
    return (*pfn)(PDBIntv);
}

PDBAPI(EC)     PDBQueryLastError(PDB *ppdb, OUT char szError[cbErrMax]);
PDBAPI(INTV)   PDBQueryInterfaceVersion(PDB* ppdb);
PDBAPI(IMPV)   PDBQueryImplementationVersion(PDB* ppdb);
PDBAPI(char*)  PDBQueryPDBName(PDB* ppdb, OUT char szPDB[PDB_MAX_PATH]);
PDBAPI(SIG)    PDBQuerySignature(PDB* ppdb);
PDBAPI(AGE)    PDBQueryAge(PDB* ppdb);
PDBAPI(BOOL)   PDBCreateDBI(PDB* ppdb, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenDBIEx(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn);
PDBAPI(BOOL)   PDBOpenDBI(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenTpi(PDB* ppdb, const char* szMode, OUT TPI** pptpi);
PDBAPI(BOOL)   PDBCommit(PDB* ppdb);
PDBAPI(BOOL)   PDBClose(PDB* ppdb);
PDBAPI(BOOL)   PDBOpenStream(PDB* ppdb, const char* szStream, OUT Stream** ppstream);
PDBAPI(BOOL)   PDBCopyTo(PDB *ppdb, const char *szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);
PDBAPI(BOOL)   PDBCopyToW(PDB *ppdb, const wchar_t *szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);
PDBAPI(BOOL)   PDBfIsSZPDB(PDB *ppdb);
PDBAPI(BOOL)   PDBCopyToW2(PDB *ppdb, const wchar_t *szTargetPdb, DWORD dwCopyFilter, PfnPDBCopyQueryCallback pfnCallBack, void * pvClientContext);

PDBAPI(INTV)   DBIQueryInterfaceVersion(DBI* pdbi);
PDBAPI(IMPV)   DBIQueryImplementationVersion(DBI* pdbi);
PDBAPI(BOOL)   DBIOpenMod(DBI* pdbi, const char* szModule, const char* szFile, OUT Mod** ppmod);
PDBAPI(BOOL)   DBIDeleteMod(DBI* pdbi, const char* szModule);
PDBAPI(BOOL)   DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext);
PDBAPI(BOOL)   DBIOpenGlobals(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIOpenPublics(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIAddSec(DBI* pdbi, USHORT isect, USHORT flags, long off, long cb);
PDBAPI(BOOL)   DBIAddPublic(DBI* pdbi, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   DBIQueryModFromAddr(DBI* pdbi, USHORT isect, long off, OUT Mod** ppmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb);
PDBAPI(BOOL)   DBIQuerySecMap(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQueryFileInfo(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQuerySupportsEC(DBI* pdbi);
PDBAPI(void)   DBIDumpMods(DBI* pdbi);
PDBAPI(void)   DBIDumpSecContribs(DBI* pdbi);
PDBAPI(void)   DBIDumpSecMap(DBI* pdbi);
PDBAPI(BOOL)   DBIClose(DBI* pdbi);
PDBAPI(BOOL)   DBIAddThunkMap(DBI* pdbi, long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                              struct SO* psoSectMap, unsigned nSects, USHORT isectThunkTable, long offThunkTable);
PDBAPI(BOOL)   DBIGetEnumContrib(DBI* pdbi, OUT Enum** ppenum);
PDBAPI(BOOL)   DBIQueryTypeServer(DBI* pdbi, ITSM itsm, OUT TPI** pptpi );
PDBAPI(BOOL)   DBIQueryItsmForTi(DBI* pdbi, TI ti, OUT ITSM* pitsm );
PDBAPI(BOOL)   DBIQueryNextItsm(DBI* pdbi, ITSM itsm, OUT ITSM *inext );
PDBAPI(BOOL)   DBIQueryLazyTypes(DBI* pdbi);
PDBAPI(BOOL)   DBIFindTypeServers( DBI* pdbi, OUT EC* pec, OUT char szError[cbErrMax] );
PDBAPI(BOOL)   DBIOpenDbg(DBI* pdbi, DBGTYPE dbgtype, OUT Dbg **ppdbg);
PDBAPI(BOOL)   DBIQueryDbgTypes(DBI* pdbi, OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype);
PDBAPI(BOOL)   DBIAddLinkInfo(DBI* pdbi, IN PLinkInfo);
PDBAPI(BOOL)   DBIQueryLinkInfo(DBI* pdbi, PLinkInfo, IN OUT long * pcb);

PDBAPI(INTV)   ModQueryInterfaceVersion(Mod* pmod);
PDBAPI(IMPV)   ModQueryImplementationVersion(Mod* pmod);
PDBAPI(BOOL)   ModAddTypes(Mod* pmod, BYTE* pbTypes, long cb);
PDBAPI(BOOL)   ModAddSymbols(Mod* pmod, BYTE* pbSym, long cb);
PDBAPI(BOOL)   ModAddPublic(Mod* pmod, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   ModAddLines(Mod* pmod, const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                           USHORT lineStart, BYTE* pbCoff, long cbCoff);
PDBAPI(BOOL)   ModAddSecContrib(Mod * pmod, USHORT isect, long off, long cb, ULONG dwCharacteristics);
PDBAPI(BOOL)   ModQueryCBName(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryName(Mod* pmod, OUT char szName[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySymbols(Mod* pmod, BYTE* pbSym, long* pcb);
PDBAPI(BOOL)   ModQueryLines(Mod* pmod, BYTE* pbLines, long* pcb);
PDBAPI(BOOL)   ModSetPvClient(Mod* pmod, void *pvClient);
PDBAPI(BOOL)   ModGetPvClient(Mod* pmod, OUT void** ppvClient);
PDBAPI(BOOL)   ModQuerySecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryFirstCodeSecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryImod(Mod* pmod, OUT USHORT* pimod);
PDBAPI(BOOL)   ModQueryDBI(Mod* pmod, OUT DBI** ppdbi);
PDBAPI(BOOL)   ModClose(Mod* pmod);
PDBAPI(BOOL)   ModQueryCBFile(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySrcFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQueryPdbFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySupportsEC(Mod* pmod);
PDBAPI(BOOL)   ModQueryTpi(Mod* pmod, OUT TPI** pptpi);
PDBAPI(BOOL)   ModReplaceLines(Mod* pmod, BYTE* pbLines, long cb);

PDBAPI(INTV)   TypesQueryInterfaceVersion(TPI* ptpi);
PDBAPI(IMPV)   TypesQueryImplementationVersion(TPI* ptpi);
// can't use the same api's for 32-bit TIs.
PDBAPI(BOOL)   TypesQueryTiForCVRecordEx(TPI* ptpi, BYTE* pb, OUT TI* pti);
PDBAPI(BOOL)   TypesQueryCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE* pb, IN OUT long* pcb);
PDBAPI(BOOL)   TypesQueryPbCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE** ppb);
PDBAPI(TI)     TypesQueryTiMinEx(TPI* ptpi);
PDBAPI(TI)     TypesQueryTiMacEx(TPI* ptpi);
PDBAPI(long)   TypesQueryCb(TPI* ptpi);
PDBAPI(BOOL)   TypesClose(TPI* ptpi);
PDBAPI(BOOL)   TypesCommit(TPI* ptpi);
PDBAPI(BOOL)   TypesQueryTiForUDTEx(TPI* ptpi, LNGNM_CONST char *sz, BOOL fCase, OUT TI* pti);
PDBAPI(BOOL)   TypesSupportQueryTiForUDT(TPI*);
PDBAPI(BOOL)   TypesfIs16bitTypePool(TPI*);
// Map all old ones to new ones for new compilands.
#define TypesQueryTiForCVRecord     TypesQueryTiForCVRecordEx
#define TypesQueryCVRecordForTi     TypesQueryCVRecordForTiEx
#define TypesQueryPbCVRecordForTi   TypesQueryPbCVRecordForTiEx
#define TypesQueryTiMin             TypesQueryTiMinEx
#define TypesQueryTiMac             TypesQueryTiMacEx
#define TypesQueryTiForUDT          TypesQueryTiForUDTEx
PDBAPI(BOOL)    TypesAreTypesEqual( TPI* ptpi, TI ti1, TI ti2 );
PDBAPI(BOOL)    TypesIsTypeServed( TPI* ptpi, TI ti );

PDBAPI(BYTE*)  GSINextSym (GSI* pgsi, BYTE* pbSym);
PDBAPI(BYTE*)  GSIHashSym (GSI* pgsi, const char* szName, BYTE* pbSym);
PDBAPI(BYTE*)  GSINearestSym (GSI* pgsi, USHORT isect, long off,OUT long* pdisp);//currently only supported for publics
PDBAPI(BOOL)   GSIClose(GSI* pgsi);
PDBAPI(unsigned long)   GSIOffForSym( GSI* pgsi, BYTE* pbSym );
PDBAPI(BYTE*)   GSISymForOff( GSI* pgsi, unsigned long off );

PDBAPI(long)   StreamQueryCb(Stream* pstream);
PDBAPI(BOOL)   StreamRead(Stream* pstream, long off, void* pvBuf, long* pcbBuf);
PDBAPI(BOOL)   StreamWrite(Stream* pstream, long off, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamReplace(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamAppend(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamDelete(Stream* pstream);
PDBAPI(BOOL)   StreamTruncate(Stream* pstream, long cb);
PDBAPI(BOOL)   StreamRelease(Stream* pstream);

PDBAPI(BOOL)   StreamImageOpen(Stream* pstream, long cb, OUT StreamImage** ppsi);
PDBAPI(void*)  StreamImageBase(StreamImage* psi);
PDBAPI(long)   StreamImageSize(StreamImage* psi);
PDBAPI(BOOL)   StreamImageNoteRead(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageNoteWrite(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageWriteBack(StreamImage* psi);
PDBAPI(BOOL)   StreamImageRelease(StreamImage* psi);

PDBAPI(BOOL)   NameMapOpen(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
PDBAPI(BOOL)   NameMapClose(NameMap* pnm);
PDBAPI(BOOL)   NameMapReinitialize(NameMap* pnm);
PDBAPI(BOOL)   NameMapGetNi(NameMap* pnm, const char* sz, OUT NI* pni);
PDBAPI(BOOL)   NameMapGetName(NameMap* pnm, NI ni, OUT const char** psz);
PDBAPI(BOOL)   NameMapGetEnumNameMap(NameMap* pnm, OUT Enum** ppenum);
PDBAPI(BOOL)   NameMapCommit(NameMap* pnm);

PDBAPI(void)   EnumNameMapRelease(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapReset(EnumNameMap* penum);
PDBAPI(BOOL)   EnumNameMapNext(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapGet(EnumNameMap* penum, OUT const char** psz, OUT NI* pni);

PDBAPI(void)   EnumContribRelease(EnumContrib* penum);
PDBAPI(void)   EnumContribReset(EnumContrib* penum);
PDBAPI(BOOL)   EnumContribNext(EnumContrib* penum);
PDBAPI(void)   EnumContribGet(EnumContrib* penum, OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(void)   EnumContribGetCrcs(EnumContrib* penum, OUT DWORD* pcrcData, OUT DWORD* pcrcReloc);
PDBAPI(BOOL)   EnumContribfUpdate(EnumContrib* penum, IN long off, IN long cb);

PDBAPI(SIG)    SigForPbCb(BYTE* pb, size_t cb, SIG sig);
PDBAPI(void)   TruncStFromSz(char *stDst, const char *szSrc, size_t cbSrc);

PDBAPI(BOOL)   DbgClose(Dbg *pdbg);
PDBAPI(long)   DbgQuerySize(Dbg *pdbg);
PDBAPI(void)   DbgReset(Dbg *pdbg);
PDBAPI(BOOL)   DbgSkip(Dbg *pdbg, ULONG celt);
PDBAPI(BOOL)   DbgQueryNext(Dbg *pdbg, ULONG celt, OUT void *rgelt);
PDBAPI(BOOL)   DbgFind(Dbg *pdbg, IN OUT void *pelt);
PDBAPI(BOOL)   DbgClear(Dbg *pdbg);
PDBAPI(BOOL)   DbgAppend(Dbg *pdbg, ULONG celt, const void *rgelt);
PDBAPI(BOOL)   DbgReplaceNext(Dbg *pdbg, ULONG celt, const void *rgelt);

#if __cplusplus
};
#endif

struct SO {
    long off;
    USHORT isect;
    unsigned short pad;
};

#ifndef cbNil
#define cbNil   ((long)-1)
#endif
#define tsNil   ((TPI*)0)
#define tiNil   ((TI)0)
#define imodNil ((USHORT)(-1))

#define pdbWrite                "w"
#define pdbRead                 "r"
#define pdbGetTiOnly            "i"
#define pdbGetRecordsOnly       "c"
#define pdbFullBuild            "f"
#define pdbTypeAppend           "a"
#define pdbRepro                "z"

#endif // __PDB_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\vc\sherror.h ===
/*++

    This file contains the symbolic names and test for SH errors

--*/

DECL_STR( sheNone,                       0, "symbols loaded"               )
DECL_STR( sheNoSymbols,                  1, "no symbols loaded"            )
DECL_STR( sheFutureSymbols,              2, "symbol format not supported"  )
DECL_STR( sheMustRelink,                 3, "symbol format not supported"  )
DECL_STR( sheNotPacked,                  4, "must run cvpack on symbols"   )
DECL_STR( sheOutOfMemory,                5, "out of memory"                )
DECL_STR( sheCorruptOmf,                 6, "symbol information corrupt"  )
DECL_STR( sheFileOpen,                   7, "could not open symbol file"   )
DECL_STR( sheSuppressSyms,               8, "symbol loading suppressed"    )
DECL_STR( sheDeferSyms,                  9, "symbol loading deferred"      )
DECL_STR( sheSymbolsConverted,          10, "symbols converted & loaded"   )
DECL_STR( sheBadTimeStamp,              11, "has mismatched timestamps"    )
DECL_STR( sheBadChecksum,               12, "has mismatched checksums"     )
DECL_STR( shePdbNotFound,               13, "can't find/open pdb file"     )
DECL_STR( shePdbBadSig,                 14, "internal pdb signature doesn't match sym handler" )
DECL_STR( shePdbInvalidAge,             15, "pdb info doesn't match image" )
DECL_STR( shePdbOldFormat,              16, "pdb format is obsolete"       )
DECL_STR( sheConvertTIs,                17, "16 bit data was converted to 32 bits")  // NB09 format, needs conversion to 32-bit type indices
DECL_STR( sheJavaInvalidClass,          18, "Invalid Java class"           )  // the class given is invalid
DECL_STR( sheJavaNoCurrentProcess,      19, "No Java process"              )  // no current process
DECL_STR( sheJavaInvalidFile,           20, "Invalid Java file"            )  // the file given is invalid
DECL_STR( sheExportsConverted,          21, "exports loaded"               )
DECL_STR( sheCouldntReadImageHeader,    22, "Image header could not be read" )  // When the debugger cannot read the image header (because it 
                                                                                // is paged out), it gets -1 for timestamps and checksums.  
                                                                                // This message really means that it could not verifty that the symbols match, not that it thinks they don't.

//
// Last resort error returned by SHLszGetErrorText()
// always the last one...
//
DECL_STR( sheMax,                       23, "unknown symbol handler error" )  // marker for count of she's
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\vc\sapi.h ===
//  SAPI.H - Private header file for SAPI
//
//  DESCRIPTION
//      This file contains types that are private to the SAPI project.


#ifndef _SAPI_INCLUDED_
#define _SAPI_INCLUDED_

typedef HIND    HEXR;               // A handle to an EXR (exe reference)
typedef HIND    HEXG;               // A handle to an EXG (exe structure global)
typedef HVOID   HST;                // A handle to source module table
typedef HVOID   HSL;                // A handle to source line table
typedef HVOID   HFL;                // A handle to an instance of a file

#define hmodNull ((HMOD)NULL)
#define hexgNull ((HEXG)NULL)
#define hexrNull ((HEXR)NULL)
#define hexeNull ((HEXE)NULL)
#define hpdsNull ((HPDS)NULL)

#define MDS_INDEX   1L


// The following are defs stolen from CVDEF

#include <stdlib.h>

#define _MAX_CVPATH     _MAX_PATH   // max. length of full pathname
#define _MAX_CVDRIVE    _MAX_DRIVE  // max. length of drive component
#define _MAX_CVDIR      _MAX_DIR    // max. length of path component
#define _MAX_CVFNAME    _MAX_FNAME  // max. length of file name component
#define _MAX_CVEXT      _MAX_EXT    // max. length of extension component

typedef SYMTYPE         *SYMPTR;
typedef CFLAGSYM        *CFLAGPTR;
typedef CONSTSYM        *CONSTPTR;
typedef REGSYM          *REGPTR;
typedef UDTSYM          *UDTPTR;
typedef SEARCHSYM       *SEARCHPTR;
typedef BLOCKSYM16      *BLOCKPTR16;
typedef DATASYM16       *DATAPTR16;
typedef PUBSYM16        *PUBPTR16;
typedef LABELSYM16      *LABELPTR16;
typedef BPRELSYM16      *BPRELPTR16;
typedef PROCSYM16       *PROCPTR16;
typedef THUNKSYM16      *THUNKPTR16;
typedef CEXMSYM16       *CEXMPTR16;
typedef VPATHSYM16      *VPATHPTR16;
typedef WITHSYM16       *WITHPTR16;

typedef BLOCKSYM32      *BLOCKPTR32;
typedef DATASYM32       *DATAPTR32;
typedef PUBSYM32        *PUBPTR32;
typedef LABELSYM32      *LABELPTR32;
typedef BPRELSYM32      *BPRELPTR32;
typedef PROCSYM32       *PROCPTR32;
typedef PROCSYMMIPS     *PROCPTRMIPS;
typedef THUNKSYM32      *THUNKPTR32;
typedef CEXMSYM32       *CEXMPTR32;
typedef WITHSYM32       *WITHPTR32;
typedef VPATHSYM32      *VPATHPTR32;

typedef BLOCKSYM        *BLOCKPTR;
typedef PROCSYM         *PROCPTR;
typedef THUNKSYM        *THUNKPTR;
typedef WITHSYM         *WITHPTR;

// End of CVDEF defines

typedef struct _PDS {
    HLLI    hlliExe;
    HPID    hpid;
} PDS;  // PiD Struct
typedef PDS *       PPDS;
typedef PDS *   LPPDS;

typedef union _UFOP {
    DWORD   lfo;
    PVOID   lpv;
} UFOP; // Union of long File Offset & Pointer
typedef UFOP *LPUFOP;

typedef struct _ALM {
    BOOL    fSeq;
    WORD    btAlign;
    WORD    cbBlock;
    DWORD   cb;
    LPB     pbData;
    UFOP    rgufop [1];
//  WORD    cbLast;             // After a null terminator, there is a field
                                //  containing the cb of the last align block
} ALM; // ALigned Map
typedef ALM *LPALM;

typedef struct _ULP {
    DWORD   ib;                 // Byte offset into the symbol table
    DWORD   ulId;               // Identified (either a uoff or a checksum)
} ULP;  // ULong Pair
typedef ULP *LPULP;

typedef struct _SHT {
    WORD    HashIndex;
    WORD    ccib;               // count of buckets [0..n)
    DWORD * rgcib;              // count of ULPs in chain i, 0 <= i < n
    DWORD * rgib;               // offset of start of chain i, 0 <= i < n
    LPALM   lpalm;              // block of ULPs
} SHT;  // Symbol Hash Table
typedef SHT *LPSHT;

typedef struct _GST {
    LPALM   lpalm;
    SHT     shtName;
    SHT     shtAddr;
#if CC_CVTYPE32
    SymConvertInfo  sci;
#endif
} GST;  // Global Symbol Table -- Globals, Publics, or Statics
typedef GST *LPGST;

typedef struct _SGC {
    WORD    seg;
    DWORD   off;
    DWORD   cb;
} SGC;  // SeGment Contributer
typedef SGC *LPSGC;

typedef struct _SGE {
    SGC     sgc;
    HMOD    hmod;
} SGE;  // SeGment directory Entry
typedef SGE *LPSGE;

typedef struct _SGD {
    WORD    csge;
    LPSGE   lpsge;
} SGD;  // SeGment Directory
typedef SGD *LPSGD;

typedef struct _MDS {
    HEXG    hexg;               // EXG parent of MDS list
    WORD    imds;

    DWORD   cbSymbols;

    LPB     symbols;
    HST     hst;
    LSZ     name;

    DWORD   ulhst;
    DWORD   cbhst;

    DWORD   ulsym;

    WORD    csgc;
    LPSGC   lpsgc;
    Mod*    pmod;                 // NB10

#if CC_CVTYPE32
    SymConvertInfo  sci;        // necessary info to keep around while
                                // loading symbols that need to be
                                // converted.
#endif
} MDS;  // MoDule Information
typedef MDS *PMDS;
typedef MDS *LPMDS;

struct STAB;
typedef struct STAB STAB;

typedef struct _EXG {
    BOOL    fOmfLoaded:1;
    BOOL    fOmfMissing:1;
    BOOL    fOmfSkipped:1;
    BOOL    fOmfDefered:1;
    BOOL    fOmfLoading:1;
    BOOL    fIsPE:1;
    BOOL    fIsRisc:1;
    BOOL    fSymConverted:1;
    SHE     sheLoadStatus;      // Load status: defered, startup, etc
    SHE     sheLoadError;       // Load error
    LONGLONG llUnload;

    LSZ     lszName;            // File name of exe
    LSZ     lszModule;          // Module name of exe
    LSZ     lszDebug;           // File name for debug info
    LSZ     lszPdbName;         // File name of pdb
    LSZ     lszAltName;         // Alternate name (for KD debugging)
    LPB     lpbData;            // Pointer to raw data for this image (non-PDB)
    LPB     lpgsi;              // GSN Info table
    PVOID   pvSymMappedBase;

    PDB   * ppdb;
    DBI   * pdbi;
    TPI   * ptpi;
    GSI   * pgsiPubs;           // public symbols
    GSI   * pgsiGlobs;          // globals
    LPALM   lpalmTypes;         // Types table
    DWORD   citd;               // Number of types
    DWORD * rgitd;              // Array of pointers to types
    GST     gstPublics;
    GST     gstGlobals;
    GST     gstStatics;
    STAB  * pstabUDTSym;
    WORD    csgd;               // Segment Directory
    LPSGD   lpsgd;
    LPSGE   lpsge;
    DWORD   cMod;               // Count of modules (count of sstModule should = sstFileIndex.cmodules)
    LPB     lpefi;              // Pointer to raw file index (for freeing)
    WORD  * rgiulFile;          // List of beginning index of module
                                //  file lists.
    WORD  * rgculFile;          // List of counts of module file lists
    DWORD * rgichFile;          // Index into string table of file names
    DWORD   cbFileNames;        // Number of bytes in string table of file
                                // names (lpchFileNames)
    LPCH    lpchFileNames;      // String table of file names
    DEBUGDATA   debugData;      // OSDEBUG4 information pdata/omap/fpo
    WORD    cRef;               // Reference count on this image
    LPMDS   rgMod;              // Array of module contributions.
    DWORD   LoadAddress;        // Bass address for this image
    DWORD   ulTimeStamp;        // Timestamp from the image
    DWORD   ulCheckSum;         // Checksum from the image
    WidenTi *   pwti;           // for converting all of this exe's types
                                // and syms to 32-bit type indices
} EXG; // EXe structure Global
typedef EXG *PEXG;
typedef EXG * LPEXG;

typedef struct _EXE {
    HPDS    hpds;               // PID of process
    HEXG    hexg;
    DWORD   timestamp;
    DWORD   TargetMachine;
    BOOL    fIsLoaded;
    DWORD   LoadAddress;
    LPDEBUGDATA pDebugData;
} EXE;   // EXE struct
typedef EXE *PEXE;
typedef EXE *LPEXE;

typedef struct _LBS  {
    ADDR        addr;
    HMOD        tagMod;
    SYMPTR      tagLoc;
    SYMPTR      tagLab;
    SYMPTR      tagProc;
    SYMPTR      tagThunk;
    CEXMPTR16   tagModelMin;
    CEXMPTR16   tagModelMax;
} LBS; // LaBel Structure ???
typedef LBS *PLBS;
typedef LBS *LPLBS;

#define NEXTSYM(a,b)    ((a) (((LPB) (b)) + ((SYMPTR) (b))->reclen + 2))

// New Source Line table handling and maintenance

typedef struct _OFP {
    UOFFSET offStart;
    UOFFSET offEnd;
} OFP;  // OFset Pair -- used to maintain start/end offset pairs
typedef OFP *LPOFP;

typedef struct OPT {
    UOFFSET offStart;
    LPOFP   lpofp;
} OPT;  // Offset Pair Table -- used to maintain start/end offset pairs
typedef OPT *LPOPT;

typedef  char *  (* CONVERTPROC) (HANDLE, char *);

typedef struct _LINECACHE {
    HSF   hsf;
    DWORD wLine;
    ADDR  addr;
    SHOFF cbLn;
    DWORD rgw[2];
    BOOL  fRet;
    WORD  rgiLn[2];
} LINECACHE;
extern LINECACHE LineCache;

// hexe <--> hmod map cache
typedef struct _MODCACHE {
    HMOD hmod;
    HEXE hexe;
    HPDS hpds;
} MODCACHE;
extern MODCACHE ModCache;

typedef struct _HSFCACHE {
    HSF     Hsf;
    HMOD    Hmod;
} HSFCACHE;
extern HSFCACHE HsfCache;

typedef struct _CXTCACHE {
    HMOD    hmod;
    HGRP    hgrp;
    HEXE    hexe;
    HPDS    hpds;
    WORD    seg;
    UOFFSET uoffBase;
    UOFFSET uoffLim;
} CXTCACHE;
extern CXTCACHE CxtCache;

typedef struct _SLCACHE {
    char    szFile[ _MAX_CVPATH ];
    HEXE    hexe;
    HMOD    hmod;
    WORD    line;
    LPSLP   lpslp;
    int     cslp;
} SLCACHE;
extern SLCACHE SlCache;

typedef struct _ADDRCACHE {
    ADDR  addr;
    DWORD wLine;
    int   cb;
} ADDRCACHE;
extern ADDRCACHE AddrCache;

//
//  Matching criteria for DLL list
//
typedef enum _MATCH_CRIT {
    MATCH_FULLPATH,             //  Match full path
    MATCH_FILENAME,             //  Match filename
    MATCH_BASENAME              //  Match base name (no extension)
} MATCH_CRIT;

#if 0
INT     FHOpen (LSZ);
#define FHRead(fh,lpb,cb) (SYReadFar(fh, lpb, cb))
#define FHClose(fh)
#define FHSeek(fh,ib) (SYSeek(fh, ib, SEEK_SET))
#define SYError() assert(FALSE)
#endif

#define cbAlign     0x1000
#define cbAlignType 0xC000


#endif      // _SAPI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\gen.h ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    gen.c

Abstract:

    Generic routines that work on all operating systems.

Author:

    Matthew D Hendel (math) 20-Oct-1999

Revision History:

--*/

#pragma once

#define KBYTE (1024)
#define SIGN_EXTEND(_v) ((ULONG64) (LONG64) (_v))
#define ARRAY_COUNT(_array) (sizeof (_array) / sizeof ((_array)[0]))

// Ran out of memory during dump writing.
#define MDSTATUS_OUT_OF_MEMORY         0x00000001
// ReadProcessMemory failed during dump writing.
#define MDSTATUS_UNABLE_TO_READ_MEMORY 0x00000002
// OS routine failed during dump writing.
#define MDSTATUS_CALL_FAILED           0x00000004
// Unexpected internal failure during dump writing.
#define MDSTATUS_INTERNAL_ERROR        0x00000008

ULONG FORCEINLINE
FileTimeToTimeDate(LPFILETIME FileTime)
{
    ULARGE_INTEGER LargeTime;
    
    LargeTime.LowPart = FileTime->dwLowDateTime;
    LargeTime.HighPart = FileTime->dwHighDateTime;
    // Convert to seconds and from base year 1601 to base year 1970.
    return (ULONG)(LargeTime.QuadPart / 10000000 - 11644473600);
}

ULONG FORCEINLINE
FileTimeToSeconds(LPFILETIME FileTime)
{
    ULARGE_INTEGER LargeTime;
    
    LargeTime.LowPart = FileTime->dwLowDateTime;
    LargeTime.HighPart = FileTime->dwHighDateTime;
    // Convert to seconds.
    return (ULONG)(LargeTime.QuadPart / 10000000);
}

struct _INTERNAL_THREAD;
struct _INTERNAL_PROCESS;
struct _INTERNAL_MODULE;
struct _INTERNAL_FUNCTION_TABLE;

ULONG
GenGetAccumulatedStatus(
    void
    );

void
GenAccumulateStatus(
    IN ULONG Status
    );

void
GenClearAccumulatedStatus(
    void
    );

BOOL
GenExecuteIncludeThreadCallback(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN ULONG DumpType,
    IN ULONG ThreadId,
    IN MINIDUMP_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID CallbackParam,
    OUT PULONG WriteFlags
    );

BOOL
GenExecuteIncludeModuleCallback(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN ULONG DumpType,
    IN ULONG64 BaseOfImage,
    IN MINIDUMP_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID CallbackParam,
    OUT PULONG WriteFlags
    );

BOOL
GenGetDataContributors(
    IN OUT PINTERNAL_PROCESS Process,
    IN PINTERNAL_MODULE Module
    );

HANDLE
GenOpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    );

HRESULT
GenAllocateThreadObject(
    IN struct _INTERNAL_PROCESS* Process,
    IN HANDLE ProcessHandle,
    IN ULONG ThreadId,
    IN ULONG DumpType,
    IN ULONG WriteFlags,
    OUT struct _INTERNAL_THREAD** Thread
    );

BOOL
GenGetThreadInstructionWindow(
    IN struct _INTERNAL_PROCESS* Process,
    IN struct _INTERNAL_THREAD* Thread
    );

struct _INTERNAL_PROCESS*
GenAllocateProcessObject(
    IN HANDLE hProcess,
    IN ULONG ProcessId
    );

BOOL
GenFreeProcessObject(
    IN struct _INTERNAL_PROCESS * Process
    );

struct _INTERNAL_MODULE*
GenAllocateModuleObject(
    IN PINTERNAL_PROCESS Process,
    IN PWSTR FullPath,
    IN ULONG_PTR BaseOfModule,
    IN ULONG DumpType,
    IN ULONG WriteFlags
    );

VOID
GenFreeModuleObject(
    struct _INTERNAL_MODULE * Module
    );

struct _INTERNAL_UNLOADED_MODULE*
GenAllocateUnloadedModuleObject(
    IN PWSTR Path,
    IN ULONG_PTR BaseOfModule,
    IN ULONG SizeOfModule,
    IN ULONG CheckSum,
    IN ULONG TimeDateStamp
    );

VOID
GenFreeUnloadedModuleObject(
    struct _INTERNAL_UNLOADED_MODULE * Module
    );

struct _INTERNAL_FUNCTION_TABLE*
GenAllocateFunctionTableObject(
    IN ULONG64 MinAddress,
    IN ULONG64 MaxAddress,
    IN ULONG64 BaseAddress,
    IN ULONG EntryCount,
    IN PDYNAMIC_FUNCTION_TABLE RawTable
    );

VOID
GenFreeFunctionTableObject(
    IN struct _INTERNAL_FUNCTION_TABLE* Table
    );

BOOL
GenIncludeUnwindInfoMemory(
    IN PINTERNAL_PROCESS Process,
    IN ULONG DumpType,
    IN struct _INTERNAL_FUNCTION_TABLE* Table
    );

LPVOID
GenGetTebAddress(
    IN HANDLE Thread,
    OUT PULONG SizeOfTeb
    );

LPVOID
GenGetPebAddress(
    IN HANDLE Process,
    OUT PULONG SizeOfPeb
    );

HRESULT
GenGetThreadInfo(
    IN HANDLE Process,
    IN HANDLE Thread,
    OUT PULONG64 Teb,
    OUT PULONG SizeOfTeb,
    OUT PULONG64 StackBase,
    OUT PULONG64 StackLimit,
    OUT PULONG64 StoreBase,
    OUT PULONG64 StoreLimit
    );

PVA_RANGE
GenAddMemoryBlock(
    IN PINTERNAL_PROCESS Process,
    IN MEMBLOCK_TYPE Type,
    IN ULONG64 Start,
    IN ULONG Size
    );

void
GenRemoveMemoryRange(
    IN PINTERNAL_PROCESS Process,
    IN ULONG64 Start,
    IN ULONG Size
    );

LPVOID
AllocMemory(
    SIZE_T Size
    );

VOID
FreeMemory(
    IN LPVOID Memory
    );


enum {
    Unknown,
    Win9x,
    WinNt,
    WinCe
};

VOID
WINAPI
GenGetSystemType(
    OUT ULONG * Type, OPTIONAL
    OUT ULONG * Major, OPTIONAL
    OUT ULONG * Minor, OPTIONAL
    OUT ULONG * ServicePack, OPTIONAL
    OUT ULONG * BuildNumber OPTIONAL
    );


BOOL
GenGetProcessInfo(
    IN HANDLE hProcess,
    IN ULONG ProcessId,
    IN ULONG DumpType,
    IN MINIDUMP_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID CallbackParam,
    OUT struct _INTERNAL_PROCESS ** ProcessRet
    );

BOOL
GenWriteHandleData(
    IN HANDLE ProcessHandle,
    IN HANDLE hFile,
    IN struct _MINIDUMP_STREAM_INFO * StreamInfo
    );

//
// Stolen from NTRTL to avoid having to include it here.
//

#ifndef InitializeListHead
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))
#endif
    

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#ifndef InsertTailList
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
#endif

//
//  VOID
//  InsertListAfter(
//      PLIST_ENTRY ListEntry,
//      PLIST_ENTRY InsertEntry
//      );
//

#ifndef InsertListAfter
#define InsertListAfter(ListEntry,InsertEntry) {\
    (InsertEntry)->Flink = (ListEntry)->Flink;\
    (InsertEntry)->Blink = (ListEntry);\
    (ListEntry)->Flink->Blink = (InsertEntry);\
    (ListEntry)->Flink = (InsertEntry);\
    }
#endif

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#ifndef RemoveEntryList
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
}
#endif

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#ifndef IsListEmpty
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))
#endif


struct _THREADENTRY32;

BOOL
ProcessThread32Next(
    HANDLE hSnapshot,
    DWORD dwProcessID,
    struct tagTHREADENTRY32 * ThreadInfo
    );

BOOL
ProcessThread32First(
    HANDLE hSnapshot,
    DWORD dwProcessID,
    struct tagTHREADENTRY32 * ThreadInfo
    );

ULONG
CheckSum (
    IN ULONG                PartialSum,
    IN PVOID                SourceVa,
    IN ULONG_PTR            Length
    );

BOOL
ThGetProcessInfo(
    IN HANDLE hProcess,
    IN ULONG ProcessId,
    IN ULONG DumpType,
    IN MINIDUMP_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID CallbackParam,
    OUT struct _INTERNAL_PROCESS ** ProcessRet
    );

//
// Undefine ASSERT so we do not get RtlAssert().
//

#ifdef ASSERT
#undef ASSERT
#endif

#if DBG

#define ASSERT(_x)\
    if (!(_x)){\
        OutputDebugString ("ASSERT Failed");\
        DebugBreak ();\
    }

#else

#define ASSERT(_x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\imagedir.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    imagedir.c

Abstract:

    For backwards compatability on Win9x platforms, the imagehlp ImageNtHeader
    etc. functions have been physically compiled into minidump.dll.

Author:

    Matthew D Hendel (math) 28-April-1999

Revision History:

--*/

#include "pch.h"

PIMAGE_NT_HEADERS
xxxImageNtHeader (
    IN PVOID Base
    )

/*++

Routine Description:

    This function returns the address of the NT Header.

Arguments:

    Base - Supplies the base of the image.

Return Value:

    Returns the address of the NT Header.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders = NULL;

    if (Base != NULL && Base != (PVOID)-1) {
        if (((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) {
            NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);

            if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {
                NtHeaders = NULL;
            }
        }
    }

    return NtHeaders;
}


PIMAGE_SECTION_HEADER
xxxSectionTableFromVirtualAddress (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Address
    )

/*++

Routine Description:

    This function locates a VirtualAddress within the image header
    of a file that is mapped as a file and returns a pointer to the
    section table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Address - Supplies the virtual address to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the pointer of the section entry containing the data.

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if ((ULONG)Address >= NtSection->VirtualAddress &&
            (ULONG)Address < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}


PVOID
xxxAddressInSectionTable (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Address
    )

/*++

Routine Description:

    This function locates a VirtualAddress within the image header
    of a file that is mapped as a file and returns the seek address
    of the data the Directory describes.

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Address - Supplies the virtual address to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = xxxSectionTableFromVirtualAddress( NtHeaders,
                                                   Base,
                                                   Address
                                                 );
    if (NtSection != NULL) {
        return( ((PCHAR)Base + ((ULONG_PTR)Address - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }
    else {
        return( NULL );
        }
}


PVOID
xxxpImageDirectoryEntryToData32 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    PIMAGE_NT_HEADERS32 NtHeaders
    )
{
    ULONG DirectoryAddress;

    if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {
        return( NULL );
    }

    if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        return( NULL );
    }

    *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {
        return( (PVOID)((PCHAR)Base + DirectoryAddress) );
    }

    return( xxxAddressInSectionTable((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));
}


PVOID
xxxpImageDirectoryEntryToData64 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    PIMAGE_NT_HEADERS64 NtHeaders
    )
{
    ULONG DirectoryAddress;

    if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {
        return( NULL );
    }

    if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        return( NULL );
    }

    *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {
        return( (PVOID)((PCHAR)Base + DirectoryAddress) );
    }

    return( xxxAddressInSectionTable((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));
}


PVOID
xxxImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    )

/*++

Routine Description:

    This function locates a Directory Entry within the image header
    and returns either the virtual address or seek address of the
    data the Directory describes.

Arguments:

    Base - Supplies the base of the image or data file.

    MappedAsImage - FALSE if the file is mapped as a data file.
                  - TRUE if the file is mapped as an image.

    DirectoryEntry - Supplies the directory entry to locate.

    Size - Return the size of the directory.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;

    if ((ULONG_PTR)Base & 0x00000001) {
        Base = (PVOID)((ULONG_PTR)Base & ~0x00000001);
        MappedAsImage = FALSE;
        }

    NtHeaders = xxxImageNtHeader(Base);

    if (!NtHeaders)
        return NULL;

    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        return (xxxpImageDirectoryEntryToData32(Base,
                                                MappedAsImage,
                                                DirectoryEntry,
                                                Size,
                                                (PIMAGE_NT_HEADERS32)NtHeaders));
    } else if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        return (xxxpImageDirectoryEntryToData64(Base,
                                                MappedAsImage,
                                                DirectoryEntry,
                                                Size,
                                                (PIMAGE_NT_HEADERS64)NtHeaders));
    } else {
        return (NULL);
    }
}


#if 0
#if !defined(NTOS_KERNEL_RUNTIME) && !defined(BLDR_KERNEL_RUNTIME)

PIMAGE_SECTION_HEADER
RtlImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file
    that is mapped as a file and returns a pointer to the section
    table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.  The image
        was mapped as a data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

Return Value:

    NULL - The RVA was not found within any of the sections of the image.

    NON-NULL - Returns the pointer to the image section that contains
               the RVA

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}



PVOID
RtlImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file that
    is mapped as a file and returns the virtual addrees of the
    corresponding byte in the file.


Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.  The image
        was mapped as a data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

    LastRvaSection - Optional parameter that if specified, points
        to a variable that contains the last section value used for
        the specified image to translate and RVA to a VA.

Return Value:

    NULL - The file does not contain the specified RVA

    NON-NULL - Returns the virtual addrees in the mapped file.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    if (!ARGUMENT_PRESENT( LastRvaSection ) ||
        (NtSection = *LastRvaSection) == NULL ||
        Rva < NtSection->VirtualAddress ||
        Rva >= NtSection->VirtualAddress + NtSection->SizeOfRawData
       ) {
        NtSection = RtlImageRvaToSection( NtHeaders,
                                          Base,
                                          Rva
                                        );
        }

    if (NtSection != NULL) {
        if (LastRvaSection != NULL) {
            *LastRvaSection = NtSection;
            }

        return (PVOID)((PCHAR)Base +
                       (Rva - NtSection->VirtualAddress) +
                       NtSection->PointerToRawData
                      );
        }
    else {
        return NULL;
        }
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\vc\types.h ===
/**		types.h - Generic types
 *
 *		This file contains generic types such as USHORT, ushort,
 *		WORD, etc., which are not directly related to CodeView.
 *		Every attempt is made to define them in such a way as they
 *		will not conflict with the standard header files such as
 *		windows.h and os2.h.
 */


/***	The master copy of this file resides in the CVINC project.
 *		All Microsoft projects are required to use the master copy without
 *		modification.  Modification of the master version or a copy
 *		without consultation with all parties concerned is extremely
 *		risky.
 *
 *		The projects known to use this file are:
 *
 *			CodeView (uses version in CVINC project)
 *			C/C++ expression evaluator (uses version in CVINC project)
 *			Symbol Handler (uses version in CVINC project)
 *			Stump (OSDebug) (uses version in CVINC project)
 */

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef CVINC_TYPES /* whole file */
#define CVINC_TYPES

#ifdef HOST32	/* { */

#define _export

#ifndef LOADDS
#define	LOADDS
#endif

#ifndef PASCAL
#define PASCAL __stdcall
#endif

#ifndef CDECL
#define	CDECL _cdecl
#endif

#ifndef FASTCALL
#define FASTCALL __fastcall
#endif

#ifndef far
#define far
#endif

#ifndef FAR
#define	FAR far
#endif

#ifndef near
#define near
#endif

#ifndef NEAR
#define NEAR near
#endif

#ifndef _HUGE_
#define _HUGE_
#endif

// Use SEGBASED for based on a segment [e.g. SEGBASED(__segname("_CODE"))]
#ifndef SEGBASED
#define SEGBASED(x)
#endif

/*
**	This set of functions need to be expanded to deal with
**	unicode and other problems.
*/

// These #defines are taken care of by windowsx.h

#ifndef _INC_WINDOWSX

#define _ncalloc    calloc
#define _nexpand    expand
#define _ffree      free
#define _fmalloc    malloc
#define _fmemccpy   _memccpy
#define _fmemchr    memchr
#define _fmemcmp    memcmp
#define _fmemcpy    memcpy
#define _fmemicmp   _memicmp
#define _fmemmove   memmove
#define _fmemset    memset
#define _fmsize     _msize
#define _frealloc   realloc
#define _fstrcat    strcat
#define _fstrchr    strchr
#define _fstrcmp    strcmp
#define _fstrcpy    strcpy
#define _fstrcspn   strcspn
#define _fstrdup    _strdup
#define _fstricmp   _stricmp
#define _fstrlen    strlen
#define _fstrlwr    _strlwr
#define _fstrncat   strncat
#define _fstrncmp   strncmp
#define _fstrncpy   strncpy
#define _fstrnicmp  _strnicmp
#define _fstrnset   _strnset
#define _fstrpbrk   strpbrk
#define _fstrrchr   strrchr
#define _fstrrev    _strrev
#define _fstrset    _strset
#define _fstrspn    strspn
#define _fstrstr    strstr
#define _fstrtok    strtok
#define _fstrupr    _strupr
#define _nfree      free
#define _nmalloc    malloc
#define _nmsize     msize
#define _nrealloc   realloc
#define _nstrdup    _strdup
#define hmemcpy     memcpy

#endif

#define FP_OFF(x) x

#else	// !HOST32 }{

#ifndef LOADDS
#define LOADDS _loadds
#endif

#ifndef PASCAL
#define PASCAL _pascal
#endif

#ifndef CDECL
#define	CDECL _cdecl
#endif

#ifndef FASTCALL
#define FASTCALL _fastcall
#endif

#ifndef FAR
#define FAR _far
#endif

#ifndef NEAR
#define NEAR _near
#endif

#ifndef _HUGE_
#define _HUGE_ _huge
#endif

// Use SEGBASED for based on a segment [e.g. SEGBASED(__segname("_CODE"))]
#ifndef SEGBASED
#define SEGBASED(x) _based(x)
#endif

#endif	// HOST32 }

#ifndef INTERRUPT
#define INTERRUPT _interrupt
#endif

#ifndef LOCAL
#ifdef DEBUGVER
#define LOCAL
#else
#define LOCAL static
#endif
#endif

#ifndef GLOBAL
#define GLOBAL
#endif

#ifndef INLINE
#define INLINE __inline
#endif

//
// Things that come from either windows.h or os2.h
//

#if !defined(LOWORD) && !defined(OS2_INCLUDED)

	#define VOID			void

	typedef unsigned char	BYTE;

	typedef int				BOOL;

	#define LONG			long

#endif

//
// Things that come from windows.h and cwindows.h
//

#if !defined(LOWORD)

#if defined ( _WIN32 ) || defined ( _M_MPPC ) || defined ( _M_M68K )
	typedef void *			HANDLE;
#else
	typedef unsigned int	HANDLE;
#endif

	typedef HANDLE			HWND;
	typedef char FAR *		LPSTR;

	typedef unsigned short	WORD;
	typedef unsigned long	DWORD;


#endif

#if !defined ( WIN32 ) && !defined ( WIN32S ) && !defined ( WIN )

    typedef unsigned long       DWORD;
    typedef int                 BOOL;
    typedef unsigned char       BYTE;
    typedef unsigned short      WORD;
    typedef float               FLOAT;
    typedef FLOAT               *PFLOAT;
    typedef BOOL near           *PBOOL;
    typedef BOOL far            *LPBOOL;
    typedef BYTE near           *PBYTE;
    typedef BYTE far            *LPBYTE;
    typedef int near            *PINT;
    typedef int far             *LPINT;
    typedef WORD near           *PWORD;
    typedef WORD far            *LPWORD;
    typedef long far            *LPLONG;
    typedef DWORD near          *PDWORD;
    typedef DWORD far           *LPDWORD;
    typedef void far            *LPVOID;

    typedef int                 INT;
    typedef unsigned int        UINT;
    typedef unsigned int        *PUINT;

    typedef HANDLE FAR          *LPHANDLE;

#endif


//
// Things that come from os2.h
//

#if !defined(OS2_INCLUDED)

	#define CHAR			char

	typedef	unsigned char	UCHAR;
	typedef short			SHORT;
	typedef int				INT;
	typedef unsigned short	USHORT;
	typedef unsigned int	UINT;
	typedef unsigned long	ULONG;

	typedef char *			PCH;

#endif

#if !defined(LOWORD)

	#define LOWORD(l)	((WORD)(l))
	#define HIWORD(l)	((WORD)(((DWORD)(l) >> 16) & 0xFFFF))

#endif

#ifndef NULL
	#define	NULL		((void *) 0)
#endif

#if !defined(TRUE) || !defined(FALSE)
	#undef TRUE
	#undef FALSE

	#define FALSE		0
	#define TRUE		1
#endif

#if !defined(fTrue) || !defined(fFalse)
	#undef fTrue
	#undef fFalse

	#define fFalse		0
	#define fTrue		1
#endif

#ifndef min
#define min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#endif

#ifndef Unreferenced
#define	Unreferenced(a) ((void)a)
#endif

typedef unsigned short ushort;
typedef unsigned char  uchar;
typedef unsigned long  ulong;
typedef unsigned int   uint;

typedef void *		PV;
typedef void FAR *	LPV;

typedef char *		SZ;
typedef char FAR *	LSZ;
typedef char FAR *	LPCH;

typedef BOOL FAR *	LPF;
typedef BYTE FAR *	LPB;
typedef WORD FAR *  LPW;
typedef DWORD FAR * LPDW;
typedef LONG FAR *	LPL;
typedef ULONG FAR *	LPUL;
typedef USHORT FAR *LPUS;
typedef DWORD FAR *	LPDWORD;

typedef short		SWORD;

#ifndef _BASETSD_H_
typedef UINT		WPARAM;
typedef LONG		LPARAM;
#endif

#ifdef HOST32
typedef ULONG		IWORD;
#else
typedef USHORT		IWORD;
#endif

#endif /* CVINC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\gen.c ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    gen.c

Abstract:

    Generic routins for minidump that work on both NT and Win9x.

Author:

    Matthew D Hendel (math) 10-Sep-1999

Revision History:

--*/

#include "pch.h"

#include <limits.h>

#include "nt4.h"
#include "win.h"
#include "ntx.h"
#include "wce.h"

#include "impl.h"

#define REASONABLE_NB11_RECORD_SIZE (10 * KBYTE)
#define REASONABLE_MISC_RECORD_SIZE (10 * KBYTE)

ULONG g_MiniDumpStatus;

#if defined (i386)

//
// For FPO frames on x86 we access bytes outside of the ESP - StackBase range.
// This variable determines how many extra bytes we need to add for this
// case.
//

#define X86_STACK_FRAME_EXTRA_FPO_BYTES 4

#endif


LPVOID
AllocMemory(
    SIZE_T Size
    )
{
    LPVOID Mem = HeapAlloc ( GetProcessHeap (), HEAP_ZERO_MEMORY, Size );
    if (!Mem) {
        // Handle marking the no-memory state for all allocations.
        GenAccumulateStatus(MDSTATUS_OUT_OF_MEMORY);
    }
    return Mem;
}

VOID
FreeMemory(
    IN LPVOID Memory
    )
{
    if ( Memory ) {
        HeapFree ( GetProcessHeap (),  0, Memory );
    }

    return;
}

PVOID
ReAllocMemory(
    IN LPVOID Memory,
    IN SIZE_T Size
    )
{
    LPVOID Mem = HeapReAlloc ( GetProcessHeap (), HEAP_ZERO_MEMORY, Memory, Size);
    if (!Mem) {
        // Handle marking the no-memory state for all allocations.
        GenAccumulateStatus(MDSTATUS_OUT_OF_MEMORY);
    }
    return Mem;
}


BOOL
ProcessThread32Next(
    HANDLE hSnapshot,
    DWORD dwProcessID,
    THREADENTRY32 * ThreadInfo
    )
{
    BOOL succ;

    //
    // NB: Toolhelp says nothing about the order of the threads will be
    // returned in (i.e., if they are grouped by process or not). If they
    // are groupled by process -- which they emperically seem to be -- there
    // is a more efficient algorithm than simple brute force.
    //

    do {
        ThreadInfo->dwSize = sizeof (*ThreadInfo);
        succ = Thread32Next (hSnapshot, ThreadInfo);

    } while (succ && ThreadInfo->th32OwnerProcessID != dwProcessID);

    return succ;
}

BOOL
ProcessThread32First(
    HANDLE hSnapshot,
    DWORD dwProcessID,
    THREADENTRY32 * ThreadInfo
    )
{
    BOOL succ;

    ThreadInfo->dwSize = sizeof (*ThreadInfo);
    succ = Thread32First (hSnapshot, ThreadInfo);

    if (succ && ThreadInfo->th32OwnerProcessID != dwProcessID) {
        succ = ProcessThread32Next (hSnapshot, dwProcessID, ThreadInfo);
    }

    return succ;
}


ULONG
GenGetAccumulatedStatus(
    void
    )
{
    return g_MiniDumpStatus;
}

void
GenAccumulateStatus(
    IN ULONG Status
    )
{
    g_MiniDumpStatus |= Status;
}

void
GenClearAccumulatedStatus(
    void
    )
{
    g_MiniDumpStatus = 0;
}


VOID
GenGetDefaultWriteFlags(
    IN ULONG DumpType,
    OUT PULONG ModuleWriteFlags,
    OUT PULONG ThreadWriteFlags
    )
{
    *ModuleWriteFlags = ModuleWriteModule | ModuleWriteMiscRecord |
        ModuleWriteCvRecord;
    if (DumpType & MiniDumpWithDataSegs) {
        *ModuleWriteFlags |= ModuleWriteDataSeg;
    }
    
    *ThreadWriteFlags = ThreadWriteThread | ThreadWriteContext;
    if (!(DumpType & MiniDumpWithFullMemory)) {
        *ThreadWriteFlags |= ThreadWriteStack | ThreadWriteInstructionWindow;
#if defined (DUMP_BACKING_STORE)
        *ThreadWriteFlags |= ThreadWriteBackingStore;
#endif
    }
    if (DumpType & MiniDumpWithProcessThreadData) {
        *ThreadWriteFlags |= ThreadWriteThreadData;
    }
}

BOOL
GenExecuteIncludeThreadCallback(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN ULONG DumpType,
    IN ULONG ThreadId,
    IN MINIDUMP_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID CallbackParam,
    OUT PULONG WriteFlags
    )
{
    BOOL Succ;
    MINIDUMP_CALLBACK_INPUT CallbackInput;
    MINIDUMP_CALLBACK_OUTPUT CallbackOutput;


    // Initialize the default write flags.
    GenGetDefaultWriteFlags(DumpType, &CallbackOutput.ModuleWriteFlags,
                            WriteFlags);

    //
    // If there are no callbacks to call, then we are done.
    //

    if ( CallbackRoutine == NULL ) {
        return TRUE;
    }

    CallbackInput.ProcessHandle = hProcess;
    CallbackInput.ProcessId = ProcessId;
    CallbackInput.CallbackType = IncludeThreadCallback;

    CallbackInput.IncludeThread.ThreadId = ThreadId;

    CallbackOutput.ThreadWriteFlags = *WriteFlags;

    Succ = CallbackRoutine (CallbackParam,
                            &CallbackInput,
                            &CallbackOutput);

    //
    // If the callback returned FALSE, quit now.
    //

    if ( !Succ ) {
        return FALSE;
    }

    // Limit the flags that can be added.
    *WriteFlags &= CallbackOutput.ThreadWriteFlags;

    return TRUE;
}

BOOL
GenExecuteIncludeModuleCallback(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN ULONG DumpType,
    IN ULONG64 BaseOfImage,
    IN MINIDUMP_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID CallbackParam,
    OUT PULONG WriteFlags
    )
{
    BOOL Succ;
    MINIDUMP_CALLBACK_INPUT CallbackInput;
    MINIDUMP_CALLBACK_OUTPUT CallbackOutput;


    // Initialize the default write flags.
    GenGetDefaultWriteFlags(DumpType, WriteFlags,
                            &CallbackOutput.ThreadWriteFlags);

    //
    // If there are no callbacks to call, then we are done.
    //

    if ( CallbackRoutine == NULL ) {
        return TRUE;
    }

    CallbackInput.ProcessHandle = hProcess;
    CallbackInput.ProcessId = ProcessId;
    CallbackInput.CallbackType = IncludeModuleCallback;

    CallbackInput.IncludeModule.BaseOfImage = BaseOfImage;

    CallbackOutput.ModuleWriteFlags = *WriteFlags;

    Succ = CallbackRoutine (CallbackParam,
                            &CallbackInput,
                            &CallbackOutput);

    //
    // If the callback returned FALSE, quit now.
    //

    if ( !Succ ) {
        return FALSE;
    }

    // Limit the flags that can be added.
    *WriteFlags = (*WriteFlags | ModuleReferencedByMemory) &
        CallbackOutput.ModuleWriteFlags;

    return TRUE;
}



BOOL
GenGetVersionInfo(
    IN PWSTR FullPath,
    OUT VS_FIXEDFILEINFO * VersionInfo
    )

/*++

Routine Description:

    Get the VS_FIXEDFILEINFO for the module described by FullPath.

Arguments:

    FullPath - FullPath to the module.

    VersionInfo - Buffer to copy the Version information.

Return Values:

    TRUE - Success.

    FALSE - Failure.

--*/

{
    BOOL Succ;
    ULONG unused;
    ULONG Size;
    UINT VerSize;
    PVOID VersionBlock;
    PVOID VersionData;
    CHAR FullPathA [ MAX_PATH + 10 ];
    BOOL UseAnsi = FALSE;

    //
    // Get the version information.
    //

    Size = GetFileVersionInfoSizeW (FullPath, &unused);

    if (Size == 0 &&
        GetLastError() == ERROR_CALL_NOT_IMPLEMENTED) {

        // We're on an OS that doesn't support Unicode
        // file operations.  Convert to ANSI and see if
        // that helps.

        if (WideCharToMultiByte (CP_ACP,
                                 0,
                                 FullPath,
                                 -1,
                                 FullPathA,
                                 sizeof (FullPathA),
                                 0,
                                 0
                                 ) > 0) {

            Size = GetFileVersionInfoSizeA(FullPathA, &unused);
            UseAnsi = TRUE;
        }
    }
    
    if (Size) {
        VersionBlock = AllocMemory (Size);

        if (VersionBlock) {
            if (UseAnsi) {
                Succ = GetFileVersionInfoA(FullPathA,
                                           0,
                                           Size,
                                           VersionBlock);
            } else {
                Succ = GetFileVersionInfoW(FullPath,
                                           0,
                                           Size,
                                           VersionBlock);
            }

            if (Succ)
            {
                //
                // Get the VS_FIXEDFILEINFO from the image.
                //

                VerSize = 0; // ?? sizeof (Module->VersionInfo);
                Succ = VerQueryValue(VersionBlock,
                                     "\\",
                                     &VersionData,
                                     &VerSize);

                if ( Succ && (VerSize == sizeof (VS_FIXEDFILEINFO)) ) {
                    CopyMemory (VersionInfo, VersionData, sizeof (*VersionInfo));
                    FreeMemory(VersionBlock);
                    return TRUE;
                }
            }

            FreeMemory (VersionBlock);
        }
    }

    // Files don't have to have version information
    // so don't accumulate status for this failure.
    return FALSE;
}



BOOL
GenGetDebugRecord(
    IN PVOID Base,
    IN ULONG MappedSize,
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN ULONG DebugRecordType,
    IN ULONG DebugRecordMaxSize,
    OUT PVOID * DebugInfo,
    OUT ULONG * SizeOfDebugInfo
    )
{
    ULONG i;
    ULONG Size;
    ULONG NumberOfDebugDirectories;
    IMAGE_DEBUG_DIRECTORY UNALIGNED* DebugDirectories;


    Size = 0;

    //
    // Find the debug directory and copy the memory into the.
    //

    DebugDirectories = (IMAGE_DEBUG_DIRECTORY UNALIGNED *)
        ImageDirectoryEntryToData (Base,
                                   FALSE,
                                   IMAGE_DIRECTORY_ENTRY_DEBUG,
                                   &Size);

    //
    // Check that we got a valid record.
    //

    if (DebugDirectories &&
        ((Size % sizeof (IMAGE_DEBUG_DIRECTORY)) == 0) &&
        (ULONG_PTR)DebugDirectories - (ULONG_PTR)Base + Size <= MappedSize)
    {
        NumberOfDebugDirectories = Size / sizeof (IMAGE_DEBUG_DIRECTORY);

        for (i = 0 ; i < NumberOfDebugDirectories; i++)
        {
            //
            // We should check if it's a NB10 or something record.
            //

            if ((DebugDirectories[ i ].Type == DebugRecordType) &&
                (DebugDirectories[ i ].SizeOfData < DebugRecordMaxSize))
            {
                if (DebugDirectories[i].PointerToRawData +
                    DebugDirectories[i].SizeOfData > MappedSize)
                {
                    break;
                }
                
                *SizeOfDebugInfo = DebugDirectories [ i ].SizeOfData;
                *DebugInfo = AllocMemory ( *SizeOfDebugInfo );

                if (!(*DebugInfo))
                {
                    break;
                }

                CopyMemory(*DebugInfo,
                           ((PBYTE) Base) +
                           DebugDirectories [ i ].PointerToRawData,
                           *SizeOfDebugInfo);

                return TRUE;
            }
        }
    }

    return FALSE;
}


PVOID
GenOpenMapping(
    IN PCWSTR FilePath,
    OUT PULONG Size,
    OUT PWSTR LongPath,
    IN ULONG LongPathChars
    )
{
    HANDLE hFile;
    HANDLE hMappedFile;
    PVOID MappedFile;
    DWORD Chars;

    //
    // The module may be loaded with a short name.  Open
    // the mapping with the name given, but also determine
    // the long name if possible.  This is done here as
    // the ANSI/Unicode issues are already being handled here.
    //

    hFile = CreateFileW(
                FilePath,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if ( hFile == NULL || hFile == INVALID_HANDLE_VALUE ) {

        if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED) {

            // We're on an OS that doesn't support Unicode
            // file operations.  Convert to ANSI and see if
            // that helps.
            
            CHAR FilePathA [ MAX_PATH + 10 ];

            if (WideCharToMultiByte (CP_ACP,
                                     0,
                                     FilePath,
                                     -1,
                                     FilePathA,
                                     sizeof (FilePathA),
                                     0,
                                     0
                                     ) > 0) {

                hFile = CreateFileA(FilePathA,
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL
                                    );
                
                if (hFile != INVALID_HANDLE_VALUE) {
                    Chars = GetLongPathNameA(FilePathA, FilePathA,
                                             ARRAY_COUNT(FilePathA));
                    if (Chars == 0 || Chars >= ARRAY_COUNT(FilePathA) ||
                        MultiByteToWideChar(CP_ACP, 0, FilePathA, -1,
                                            LongPath, LongPathChars) == 0) {
                        // Couldn't get the long path, just use the
                        // given path.
                        lstrcpynW(LongPath, FilePath, LongPathChars);
                    }
                }
            }
        }

        if ( hFile == NULL || hFile == INVALID_HANDLE_VALUE ) {
            GenAccumulateStatus(MDSTATUS_CALL_FAILED);
            return NULL;
        }
    } else {
        Chars = GetLongPathNameW(FilePath, LongPath, LongPathChars);
        if (Chars == 0 || Chars >= LongPathChars) {
            // Couldn't get the long path, just use the given path.
            lstrcpynW(LongPath, FilePath, LongPathChars);
        }
    }

    *Size = GetFileSize(hFile, NULL);
    if (*Size == -1) {
        CloseHandle( hFile );
        GenAccumulateStatus(MDSTATUS_CALL_FAILED);
        return NULL;
    }
    
    hMappedFile = CreateFileMapping (
                        hFile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );

    if ( !hMappedFile ) {
        CloseHandle ( hFile );
        GenAccumulateStatus(MDSTATUS_CALL_FAILED);
        return NULL;
    }

    MappedFile = MapViewOfFile (
                        hMappedFile,
                        FILE_MAP_READ,
                        0,
                        0,
                        0
                        );

    CloseHandle (hMappedFile);
    CloseHandle (hFile);

    if (!MappedFile) {
        GenAccumulateStatus(MDSTATUS_CALL_FAILED);
    }
    
    return MappedFile;
}

BOOL
GenGetDataContributors(
    IN OUT PINTERNAL_PROCESS Process,
    IN PINTERNAL_MODULE Module
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;
    BOOL Succ = TRUE;
    PVOID MappedBase;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG MappedSize;
    BOOL AnsiApi;

    MappedBase = GenOpenMapping ( Module->FullPath, &MappedSize, NULL, 0 );
    if ( MappedBase == NULL ) {
        return FALSE;
    }
    
    NtHeaders = ImageNtHeader ( MappedBase );
    NtSection = IMAGE_FIRST_SECTION ( NtHeaders );

    for (i = 0; i < NtHeaders->FileHeader.NumberOfSections; i++) {

        if ( (NtSection[ i ].Characteristics & IMAGE_SCN_MEM_WRITE) &&
             (NtSection[ i ].Characteristics & IMAGE_SCN_MEM_READ) &&
             ( (NtSection[ i ].Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) ||
               (NtSection[ i ].Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA) )
           ) {
            
            if (!GenAddMemoryBlock(Process, MEMBLOCK_DATA_SEG,
                                   SIGN_EXTEND (NtSection[i].VirtualAddress + Module->BaseOfImage),
                                   NtSection[i].Misc.VirtualSize)) {
                Succ = FALSE;
            } else {
#if 0
                printf ("Section: %8.8s Addr: %08x Size: %08x Raw Size: %08x\n",
                        NtSection[ i ].Name,
                        (ULONG)(NtSection[ i ].VirtualAddress + Module->BaseOfImage),
                        NtSection[ i ].Misc.VirtualSize,
                        NtSection[ i ].SizeOfRawData
                        );
#endif
            }
        }
    }

    UnmapViewOfFile(MappedBase);
    return Succ;
}


HANDLE
GenOpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    )
{
    ULONG Type;
    ULONG Major;
    HANDLE hThread;

    //
    // First try the OpenThred call in the system, if one exists. This is
    // thunked to return NULL via the delay-load import mechanism if it
    // doesn't exist.
    //

    hThread = OpenThread (dwDesiredAccess,
                          bInheritHandle,
                          dwThreadId
                          );


    if ( hThread != NULL ) {
        return hThread;
    }

    //
    // Did not succeed. Try alternate methods.
    //

    GenGetSystemType ( &Type, &Major, NULL, NULL, NULL );

    if ( Type == WinNt && Major == 4 ) {

        hThread = Nt4OpenThread (
                             dwDesiredAccess,
                             bInheritHandle,
                             dwThreadId
                             );


    } else if ( Type == Win9x ) {

        //
        // The Access and Inheritable parameters are ignored on Win9x.
        //

        hThread = WinOpenThread (
                            dwDesiredAccess,
                            bInheritHandle,
                            dwThreadId
                            );
    } else {

        hThread = NULL;
    }

    // Errors are sometimes expected due to
    // thread instability during initial suspension,
    // so do not accumulate status here.

    return hThread;
}



HRESULT
GenAllocateThreadObject(
    IN struct _INTERNAL_PROCESS* Process,
    IN HANDLE ProcessHandle,
    IN ULONG ThreadId,
    IN ULONG DumpType,
    IN ULONG WriteFlags,
    PINTERNAL_THREAD* ThreadRet
    )

/*++

Routine Description:

    Allocate and initialize an INTERNAL_THREAD structure.

Return Values:

    S_OK on success.

    S_FALSE if the thread can't be opened.
    
    Errors on failure.

--*/

{
    HRESULT Succ;
    PINTERNAL_THREAD Thread;
    ULONG64 StackEnd;
    ULONG64 StackLimit;
    ULONG64 StoreLimit;

    ASSERT ( ProcessHandle );

    Thread = (PINTERNAL_THREAD) AllocMemory ( sizeof (INTERNAL_THREAD) );

    if (Thread == NULL) {
        return E_OUTOFMEMORY;
    }

    *ThreadRet = Thread;
    
    Thread->ThreadId = ThreadId;
    Thread->ThreadHandle = GenOpenThread (
                                THREAD_ALL_ACCESS,
                                FALSE,
                                Thread->ThreadId);

    if ( Thread->ThreadHandle == NULL ) {
        // The thread may have exited before we got around
        // to trying to open it.  If the open fails with
        // a not-found code return an alternate success to
        // indicate that it's not a critical failure.
        Succ = HRESULT_FROM_WIN32(GetLastError());
        if (Succ == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) ||
            Succ == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) {
            Succ = S_FALSE;
        } else if (SUCCEEDED(Succ)) {
            Succ = E_FAIL;
        }
        if (FAILED(Succ)) {
            GenAccumulateStatus(MDSTATUS_CALL_FAILED);
        }
        goto Exit;
    }

    // If the current thread is dumping itself we can't
    // suspend.  We can also assume the suspend count must
    // be zero since the thread is running.
    if (Thread->ThreadId == GetCurrentThreadId()) {
        Thread->SuspendCount = 0;
    } else {
        Thread->SuspendCount = SuspendThread ( Thread->ThreadHandle );
    }
    Thread->WriteFlags = WriteFlags;

    //
    // Add this if we ever need it
    //

    Thread->PriorityClass = 0;
    Thread->Priority = 0;

    //
    // Initialize the thread context.
    //

    Thread->Context.ContextFlags = ALL_REGISTERS;

    Succ = GetThreadContext (Thread->ThreadHandle,
                             &Thread->Context) ? S_OK : E_FAIL;
    if ( Succ != S_OK ) {
        GenAccumulateStatus(MDSTATUS_CALL_FAILED);
        goto Exit;
    }

    Thread->SizeOfContext = sizeof (CONTEXT);


    Succ = GenGetThreadInfo(ProcessHandle,
                            Thread->ThreadHandle,
                            &Thread->Teb,
                            &Thread->SizeOfTeb,
                            &Thread->StackBase,
                            &StackLimit,
                            &Thread->BackingStoreBase,
                            &StoreLimit);
    if (Succ != S_OK) {
        goto Exit;
    }

    //
    // If the stack pointer (SP) is within the range of the stack
    // region (as allocated by the OS), only take memory from
    // the stack region up to the SP. Otherwise, assume the program
    // has blown it's SP -- purposefully, or not -- and copy
    // the entire stack as known by the OS.
    //

    StackEnd = SIGN_EXTEND (STACK_POINTER (&Thread->Context));

#if defined (i386)

    //
    // Note: for FPO frames on x86 we access bytes outside of the
    // ESP - StackBase range. Add a couple of bytes extra here so we
    // don't fail these cases.
    //

    StackEnd -= X86_STACK_FRAME_EXTRA_FPO_BYTES;
#endif

#ifdef DUMP_BACKING_STORE
    Thread->BackingStoreSize =
        (ULONG)(SIGN_EXTEND(BSTORE_POINTER(&Thread->Context)) -
                Thread->BackingStoreBase);
#else
    Thread->BackingStoreSize = 0;
#endif

    if (StackLimit <= StackEnd && StackEnd < Thread->StackBase) {
        Thread->StackEnd = StackEnd;
    } else {
        Thread->StackEnd = StackLimit;
    }

    if ((ULONG)(Thread->StackBase - Thread->StackEnd) >
        Process->MaxStackOrStoreSize) {
        Process->MaxStackOrStoreSize =
            (ULONG)(Thread->StackBase - Thread->StackEnd);
    }
    if (Thread->BackingStoreSize > Process->MaxStackOrStoreSize) {
        Process->MaxStackOrStoreSize = Thread->BackingStoreSize;
    }
    
Exit:

    if ( Succ != S_OK ) {
        FreeMemory ( Thread );
    }

    return Succ;
}

VOID
GenFreeThreadObject(
    IN PINTERNAL_THREAD Thread
    )
{
    if (Thread->SuspendCount != -1 &&
        Thread->ThreadId != GetCurrentThreadId()) {
        ResumeThread (Thread->ThreadHandle);
        Thread->SuspendCount = -1;
    }
    CloseHandle (Thread->ThreadHandle);
    Thread->ThreadHandle = NULL;
    FreeMemory ( Thread );
    Thread = NULL;
}

BOOL
GenGetThreadInstructionWindow(
    IN PINTERNAL_PROCESS Process,
    IN PINTERNAL_THREAD Thread
    )
{
    PVOID MemBuf;
    PUCHAR InstrStart;
    ULONG InstrSize;
    SIZE_T BytesRead;
    BOOL Succ = FALSE;

    //
    // Store a window of the instruction stream around
    // the current program counter.  This allows some
    // instruction context to be given even when images
    // can't be mapped.  It also allows instruction
    // context to be given for generated code where
    // no image contains the necessary instructions.
    //

    InstrStart = (PUCHAR)PROGRAM_COUNTER(&Thread->Context) -
        INSTRUCTION_WINDOW_SIZE / 2;
    InstrSize = INSTRUCTION_WINDOW_SIZE;
        
    MemBuf = AllocMemory(InstrSize);
    if (!MemBuf) {
        return FALSE;
    }

    for (;;) {
        // If we can read the instructions through the
        // current program counter we'll say that's
        // good enough.
        if (ReadProcessMemory(Process->ProcessHandle,
                              InstrStart,
                              MemBuf,
                              InstrSize,
                              &BytesRead) &&
            InstrStart + BytesRead >
            (PUCHAR)PROGRAM_COUNTER(&Thread->Context)) {
            Succ = GenAddMemoryBlock(Process, MEMBLOCK_INSTR_WINDOW,
                                     SIGN_EXTEND(InstrStart),
                                     (ULONG)BytesRead) != NULL;
            break;
        }

        // We couldn't read up to the program counter.
        // If the start address is on the previous page
        // move it up to the same page.
        if (((ULONG_PTR)InstrStart & ~(PAGE_SIZE - 1)) !=
            (PROGRAM_COUNTER(&Thread->Context) & ~(PAGE_SIZE - 1))) {
            ULONG Fraction = PAGE_SIZE -
                (ULONG)(ULONG_PTR)InstrStart & (PAGE_SIZE - 1);
            InstrSize -= Fraction;
            InstrStart += Fraction;
        } else {
            // The start and PC were on the same page so
            // we just can't read memory.  There may have been
            // a jump to a bad address or something, so this
            // doesn't constitute an unexpected failure.
            break;
        }
    }
    
    FreeMemory(MemBuf);
    return Succ;
}


PINTERNAL_MODULE
GenAllocateModuleObject(
    IN PINTERNAL_PROCESS Process,
    IN PWSTR FullPathW,
    IN ULONG_PTR BaseOfModule,
    IN ULONG DumpType,
    IN ULONG WriteFlags
    )

/*++

Routine Description:

    Given the full-path to the module and the base of the module, create and
    initialize an INTERNAL_MODULE object, and return it.

--*/

{
    BOOL Succ;
    PVOID MappedBase;
    ULONG MappedSize;
    PIMAGE_NT_HEADERS NtHeaders;
    PINTERNAL_MODULE Module;
    ULONG Chars;
    BOOL AnsiApi;

    ASSERT (FullPathW);
    ASSERT (BaseOfModule);

    Module = (PINTERNAL_MODULE) AllocMemory ( sizeof (INTERNAL_MODULE) );

    if (Module == NULL) {
        return NULL;
    }
    
    MappedBase = GenOpenMapping ( FullPathW, &MappedSize,
                                  Module->FullPath,
                                  ARRAY_COUNT(Module->FullPath) );

    if ( MappedBase == NULL ) {
        FreeMemory(Module);
        return NULL;
    }

    if (IsFlagSet(DumpType, MiniDumpFilterModulePaths)) {
        Module->SavePath = Module->FullPath + lstrlenW(Module->FullPath);
        while (Module->SavePath > Module->FullPath) {
            Module->SavePath--;
            if (*Module->SavePath == '\\' ||
                *Module->SavePath == '/' ||
                *Module->SavePath == ':') {
                Module->SavePath++;
                break;
            }
        }
    } else {
        Module->SavePath = Module->FullPath;
    }

    //
    // Cull information from the image header.
    //

    NtHeaders = ImageNtHeader ( MappedBase );

    Module->BaseOfImage = SIGN_EXTEND (BaseOfModule);
    Module->SizeOfImage = NtHeaders->OptionalHeader.SizeOfImage;
    Module->CheckSum = NtHeaders->OptionalHeader.CheckSum;
    Module->TimeDateStamp = NtHeaders->FileHeader.TimeDateStamp;
    Module->WriteFlags = WriteFlags;

    //
    // Get the version information for the module.
    //

    Succ = GenGetVersionInfo (
                FullPathW,
                &Module->VersionInfo
                );


    if ( !Succ ) {
        Module->VersionInfo.dwSignature = 0;
    }

    //
    // Get the CV record from the debug directory.
    //

    if (IsFlagSet(Module->WriteFlags, ModuleWriteCvRecord)) {
        Succ = GenGetDebugRecord(MappedBase,
                                 MappedSize,
                                 NtHeaders,
                                 IMAGE_DEBUG_TYPE_CODEVIEW,
                                 REASONABLE_NB11_RECORD_SIZE,
                                 &Module->CvRecord,
                                 &Module->SizeOfCvRecord);
        if ( !Succ ) {
            Module->CvRecord = NULL;
            Module->SizeOfCvRecord = 0;
        }
    }

    //
    // Get the MISC record from the debug directory.
    //

    if (IsFlagSet(Module->WriteFlags, ModuleWriteMiscRecord)) {
        Succ = GenGetDebugRecord(MappedBase,
                                 MappedSize,
                                 NtHeaders,
                                 IMAGE_DEBUG_TYPE_MISC,
                                 REASONABLE_MISC_RECORD_SIZE,
                                 &Module->MiscRecord,
                                 &Module->SizeOfMiscRecord);
        if ( !Succ ) {
            Module->MiscRecord = NULL;
            Module->SizeOfMiscRecord = 0;
        }
    }

    UnmapViewOfFile ( MappedBase );
    return Module;
}

VOID
GenFreeModuleObject(
    IN PINTERNAL_MODULE Module
    )
{
    FreeMemory ( Module->CvRecord );
    Module->CvRecord = NULL;

    FreeMemory ( Module->MiscRecord );
    Module->MiscRecord = NULL;

    FreeMemory ( Module );
    Module = NULL;
}

PINTERNAL_UNLOADED_MODULE
GenAllocateUnloadedModuleObject(
    IN PWSTR Path,
    IN ULONG_PTR BaseOfModule,
    IN ULONG SizeOfModule,
    IN ULONG CheckSum,
    IN ULONG TimeDateStamp
    )
{
    PINTERNAL_UNLOADED_MODULE Module;

    Module = (PINTERNAL_UNLOADED_MODULE)
        AllocMemory ( sizeof (*Module) );
    if (Module == NULL) {
        return NULL;
    }
    
    lstrcpynW (Module->Path, Path, ARRAY_COUNT(Module->Path));

    Module->BaseOfImage = SIGN_EXTEND (BaseOfModule);
    Module->SizeOfImage = SizeOfModule;
    Module->CheckSum = CheckSum;
    Module->TimeDateStamp = TimeDateStamp;

    return Module;
}

VOID
GenFreeUnloadedModuleObject(
    IN PINTERNAL_UNLOADED_MODULE Module
    )
{
    FreeMemory ( Module );
    Module = NULL;
}

typedef BOOL (WINAPI* FN_GetProcessTimes)(
    IN HANDLE hProcess,
    OUT LPFILETIME lpCreationTime,
    OUT LPFILETIME lpExitTime,
    OUT LPFILETIME lpKernelTime,
    OUT LPFILETIME lpUserTime
    );

PINTERNAL_PROCESS
GenAllocateProcessObject(
    IN HANDLE hProcess,
    IN ULONG ProcessId
    )
{
    PINTERNAL_PROCESS Process;
    FN_GetProcessTimes GetProcTimes;
    LPVOID Peb;

    Process = (PINTERNAL_PROCESS) AllocMemory ( sizeof (INTERNAL_PROCESS) );
    if (!Process) {
        return NULL;
    }

    Process->ProcessId = ProcessId;
    Process->ProcessHandle = hProcess;
    Process->NumberOfThreads = 0;
    Process->NumberOfModules = 0;
    Process->NumberOfFunctionTables = 0;
    InitializeListHead (&Process->ThreadList);
    InitializeListHead (&Process->ModuleList);
    InitializeListHead (&Process->UnloadedModuleList);
    InitializeListHead (&Process->FunctionTableList);
    InitializeListHead (&Process->MemoryBlocks);

    GetProcTimes = (FN_GetProcessTimes)
        GetProcAddress(GetModuleHandle("kernel32.dll"),
                       "GetProcessTimes");
    if (GetProcTimes) {
        FILETIME Create, Exit, User, Kernel;

        if (GetProcTimes(hProcess, &Create, &Exit, &User, &Kernel)) {
            Process->TimesValid = TRUE;
            Process->CreateTime = FileTimeToTimeDate(&Create);
            Process->UserTime = FileTimeToSeconds(&User);
            Process->KernelTime = FileTimeToSeconds(&Kernel);
        } else {
            GenAccumulateStatus(MDSTATUS_CALL_FAILED);
        }
    }

    Peb = GenGetPebAddress(hProcess, &Process->SizeOfPeb);
    Process->Peb = SIGN_EXTEND(Peb);
    
    return Process;
}

BOOL
GenFreeProcessObject(
    IN PINTERNAL_PROCESS Process
    )
{
    PINTERNAL_MODULE Module;
    PINTERNAL_UNLOADED_MODULE UnlModule;
    PINTERNAL_THREAD Thread;
    PINTERNAL_FUNCTION_TABLE Table;
    PVA_RANGE Range;
    PLIST_ENTRY Entry;

    Thread = NULL;
    Module = NULL;

    Entry = Process->ModuleList.Flink;
    while ( Entry != &Process->ModuleList ) {

        Module = CONTAINING_RECORD (Entry, INTERNAL_MODULE, ModulesLink);
        Entry = Entry->Flink;

        GenFreeModuleObject ( Module );
        Module = NULL;
    }

    Entry = Process->UnloadedModuleList.Flink;
    while ( Entry != &Process->UnloadedModuleList ) {

        UnlModule = CONTAINING_RECORD (Entry, INTERNAL_UNLOADED_MODULE,
                                       ModulesLink);
        Entry = Entry->Flink;

        GenFreeUnloadedModuleObject ( UnlModule );
        UnlModule = NULL;
    }

    Entry = Process->ThreadList.Flink;
    while ( Entry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (Entry, INTERNAL_THREAD, ThreadsLink);
        Entry = Entry->Flink;

        if (Thread->SuspendCount != -1) {
            GenFreeThreadObject ( Thread );
            Thread = NULL;
        }

    }

    Entry = Process->FunctionTableList.Flink;
    while ( Entry != &Process->FunctionTableList ) {

        Table = CONTAINING_RECORD (Entry, INTERNAL_FUNCTION_TABLE, TableLink);
        Entry = Entry->Flink;

        GenFreeFunctionTableObject ( Table );

    }

    Entry = Process->MemoryBlocks.Flink;
    while (Entry != &Process->MemoryBlocks) {
        Range = CONTAINING_RECORD(Entry, VA_RANGE, NextLink);
        Entry = Entry->Flink;
        FreeMemory(Range);
    }

    FreeMemory ( Process );
    Process = NULL;

    return TRUE;
}

struct _INTERNAL_FUNCTION_TABLE*
GenAllocateFunctionTableObject(
    IN ULONG64 MinAddress,
    IN ULONG64 MaxAddress,
    IN ULONG64 BaseAddress,
    IN ULONG EntryCount,
    IN PDYNAMIC_FUNCTION_TABLE RawTable
    )
{
    PINTERNAL_FUNCTION_TABLE Table;

    Table = (PINTERNAL_FUNCTION_TABLE)
        AllocMemory ( sizeof (INTERNAL_FUNCTION_TABLE) );
    if (Table) {
        Table->RawEntries = AllocMemory(sizeof(RUNTIME_FUNCTION) * EntryCount);
        if (Table->RawEntries) {
            Table->MinimumAddress = MinAddress;
            Table->MaximumAddress = MaxAddress;
            Table->BaseAddress = BaseAddress;
            Table->EntryCount = EntryCount;
            Table->RawTable = *RawTable;
            // RawEntries will be filled out afterwards.
        } else {
            FreeMemory(Table);
            Table = NULL;
        }
    }

    return Table;
}

VOID
GenFreeFunctionTableObject(
    IN struct _INTERNAL_FUNCTION_TABLE* Table
    )
{
    if (Table->RawEntries) {
        FreeMemory(Table->RawEntries);
    }

    FreeMemory(Table);
}

BOOL
GenIncludeUnwindInfoMemory(
    IN PINTERNAL_PROCESS Process,
    IN ULONG DumpType,
    IN struct _INTERNAL_FUNCTION_TABLE* Table
    )
{
    ULONG i;
    PRUNTIME_FUNCTION FuncEnt;
    
    if (DumpType & MiniDumpWithFullMemory) {
        // Memory will be included by default.
        return TRUE;
    }

    // This code only needs to scan IA64 and AMD64 tables.
#if !defined(_IA64_) && !defined(_AMD64_)
    return TRUE;
#endif
    
    FuncEnt = (PRUNTIME_FUNCTION)Table->RawEntries;
    for (i = 0; i < Table->EntryCount; i++) {

#if defined(_IA64_) || defined(_AMD64_)
        SIZE_T Done;
        UNWIND_INFO Info;
        ULONG64 Start;
        ULONG Size;
#endif
                
#if defined(_IA64_)

        Start = Table->BaseAddress + FuncEnt->UnwindInfoAddress;
        if (!ReadProcessMemory(Process->ProcessHandle, (PVOID)Start,
                               &Info, sizeof(Info), &Done) ||
            Done != sizeof(Info)) {
            GenAccumulateStatus(MDSTATUS_UNABLE_TO_READ_MEMORY);
            return FALSE;
        }
        Size = sizeof(Info) + Info.DataLength * sizeof(ULONG64);
        
#elif defined(_AMD64_)

        Start = Table->BaseAddress + FuncEnt->UnwindData;
        if (!ReadProcessMemory(Process->ProcessHandle, (PVOID)Start,
                               &Info, sizeof(Info), &Done) ||
            Done != sizeof(Info)) {
            GenAccumulateStatus(MDSTATUS_UNABLE_TO_READ_MEMORY);
            return FALSE;
        }
        Size = sizeof(Info) +
            (Info.CountOfCodes - 1) * sizeof(UNWIND_CODE);
        // An extra alignment code and pointer may be added on to handle
        // the chained info case where the chain pointer is just
        // beyond the end of the normal code array.
        if ((Info.Flags & UNW_FLAG_CHAININFO) != 0) {
            if ((Info.CountOfCodes & 1) != 0) {
                Size += sizeof(UNWIND_CODE);
            }
            Size += sizeof(ULONG64);
        }
        
#endif

#if defined(_IA64_) || defined(_AMD64_)
        if (!GenAddMemoryBlock(Process, MEMBLOCK_UNWIND_INFO, Start, Size)) {
            return FALSE;
        }
#endif

        FuncEnt++;
    }

    return TRUE;
}



PVOID
GenGetTebAddress(
    IN HANDLE Thread,
    OUT PULONG SizeOfTeb
    )

/*++

Routine Description:

    Get the TIB (or TEB, if you prefer) address for the thread identified
    by ThreadHandle.

Arguments:

    Thread - A handle for a thread that has THRED_QUERY_CONTEXT and
            THREAD_QUERY_INFORMATION privileges.

Return Values:

    Linear address of the Tib (Teb) on success.

    NULL on failure.

--*/

{
    LPVOID TebAddress;
    ULONG Type;
    ULONG Major;

    GenGetSystemType (&Type, &Major, NULL, NULL, NULL);

    if ( Type == WinNt ) {

        TebAddress = NtxGetTebAddress (Thread, SizeOfTeb);

    } else if ( Type != Win9x ) {

        // WinCE doesn't have a TIB.
        TebAddress = NULL;
        *SizeOfTeb = 0;
        
    } else {

#ifdef _X86_

        BOOL Succ;
        ULONG Addr;
        LDT_ENTRY Ldt;
        CONTEXT Context;

        Context.ContextFlags = CONTEXT_SEGMENTS;

        Succ = GetThreadContext (Thread, &Context);

        if ( !Succ ) {
            GenAccumulateStatus(MDSTATUS_CALL_FAILED);
            return NULL;
        }

        Succ = GetThreadSelectorEntry (Thread,
                                       Context.SegFs,
                                       &Ldt
                                       );

        if ( !Succ ) {
            GenAccumulateStatus(MDSTATUS_CALL_FAILED);
            return NULL;
        }

        Addr = (Ldt.HighWord.Bytes.BaseHi << 24) |
            (Ldt.HighWord.Bytes.BaseMid << 16) |
            (Ldt.BaseLow);

        TebAddress = (LPVOID) Addr;
        *SizeOfTeb = sizeof(NT_TIB);

#else

        TebAddress = NULL;
        *SizeOfTeb = 0;

#endif // _X86_
    }

    return TebAddress;
}

PVOID
GenGetPebAddress(
    IN HANDLE Process,
    OUT PULONG SizeOfPeb
    )
{
    LPVOID PebAddress;
    ULONG Type;
    ULONG Major;

    GenGetSystemType (&Type, &Major, NULL, NULL, NULL);

    if ( Type == WinNt ) {

        PebAddress = NtxGetPebAddress (Process, SizeOfPeb);

    } else if ( Type == WinCe ) {

        PebAddress = WceGetPebAddress (Process, SizeOfPeb);

    } else {

        // No process data.
        PebAddress = NULL;
        *SizeOfPeb = 0;
        
    }

    return PebAddress;
}

HRESULT
GenGetThreadInfo(
    IN HANDLE Process,
    IN HANDLE Thread,
    OUT PULONG64 Teb,
    OUT PULONG SizeOfTeb,
    OUT PULONG64 StackBase,
    OUT PULONG64 StackLimit,
    OUT PULONG64 StoreBase,
    OUT PULONG64 StoreLimit
    )
{
    ULONG Type;

    GenGetSystemType (&Type, NULL, NULL, NULL, NULL);

    if ( Type == WinCe ) {

        return WceGetThreadInfo(Process, Thread,
                                Teb, SizeOfTeb,
                                StackBase, StackLimit,
                                StoreBase, StoreLimit);

    } else {

        LPVOID TebAddress = GenGetTebAddress (Thread, SizeOfTeb);
        if (!TebAddress) {
            return E_FAIL;
        }
        
        *Teb = SIGN_EXTEND((LONG_PTR)TebAddress);
        return TibGetThreadInfo(Process, TebAddress,
                                StackBase, StackLimit,
                                StoreBase, StoreLimit);

    }
}

void
GenRemoveMemoryBlock(
    IN PINTERNAL_PROCESS Process,
    IN PVA_RANGE Block
    )
{
    RemoveEntryList(&Block->NextLink);
    Process->NumberOfMemoryBlocks--;
    Process->SizeOfMemoryBlocks -= Block->Size;
}

PVA_RANGE
GenAddMemoryBlock(
    IN PINTERNAL_PROCESS Process,
    IN MEMBLOCK_TYPE Type,
    IN ULONG64 Start,
    IN ULONG Size
    )
{
    ULONG64 End;
    PLIST_ENTRY ScanEntry;
    PVA_RANGE Scan;
    ULONG64 ScanEnd;
    PVA_RANGE New = NULL;
    SIZE_T Done;
    UCHAR Byte;

    // Do not use Size after this to avoid ULONG overflows.
    End = Start + Size;
    if (End < Start) {
        End = (ULONG64)-1;
    }
    
    if (Start == End) {
        // Nothing to add.
        return NULL;
    }

    if ((End - Start) > ULONG_MAX - Process->SizeOfMemoryBlocks) {
        // Overflow.
        GenAccumulateStatus(MDSTATUS_INTERNAL_ERROR);
        return NULL;
    }

    //
    // First trim the range down to memory that can actually
    // be accessed.
    //

    while (Start < End) {
        if (ReadProcessMemory(Process->ProcessHandle,
                              (PVOID)(ULONG_PTR)Start,
                              &Byte, sizeof(Byte), &Done) && Done) {
            break;
        }

        // Move up to the next page.
        Start = (Start + PAGE_SIZE) & ~(PAGE_SIZE - 1);
        if (!Start) {
            // Wrapped around.
            return NULL;
        }
    }

    if (Start >= End) {
        // No valid memory.
        return NULL;
    }

    ScanEnd = (Start + PAGE_SIZE) & ~(PAGE_SIZE - 1);
    for (;;) {
        if (ScanEnd >= End) {
            break;
        }

        if (!ReadProcessMemory(Process->ProcessHandle,
                               (PVOID)(ULONG_PTR)ScanEnd,
                               &Byte, sizeof(Byte), &Done) || !Done) {
            End = ScanEnd;
            break;
        }

        // Move up to the next page.
        ScanEnd = (ScanEnd + PAGE_SIZE) & ~(PAGE_SIZE - 1);
        if (!ScanEnd) {
            ScanEnd--;
            break;
        }
    }

    //
    // When adding memory to the list of memory to be saved
    // we want to avoid overlaps and also coalesce adjacent regions
    // so that the list has the largest possible non-adjacent
    // blocks.  In order to accomplish this we make a pass over
    // the list and merge all listed blocks that overlap or abut the
    // incoming range with the incoming range, then remove the
    // merged entries from the list.  After this pass we have
    // a region which is guaranteed not to overlap or abut anything in
    // the list.
    //

    ScanEntry = Process->MemoryBlocks.Flink;
    while (ScanEntry != &Process->MemoryBlocks) {
        Scan = CONTAINING_RECORD(ScanEntry, VA_RANGE, NextLink);
        ScanEnd = Scan->Start + Scan->Size;
        ScanEntry = Scan->NextLink.Flink;
        
        if (Scan->Start > End || ScanEnd < Start) {
            // No overlap or adjacency.
            continue;
        }

        //
        // Compute the union of the incoming range and
        // the scan block, then remove the scan block.
        //

        if (Scan->Start < Start) {
            Start = Scan->Start;
        }
        if (ScanEnd > End) {
            End = ScanEnd;
        }

        // We've lost the specific type.  This is not a problem
        // right now but if specific types must be preserved
        // all the way through in the future it will be necessary
        // to avoid merging.
        Type = MEMBLOCK_MERGED;

        GenRemoveMemoryBlock(Process, Scan);

        if (!New) {
            // Save memory for reuse.
            New = Scan;
        } else {
            FreeMemory(Scan);
        }
    }

    if (!New) {
        New = (PVA_RANGE)AllocMemory(sizeof(*New));
        if (!New) {
            return NULL;
        }
    }

    New->Start = Start;
    // Overflow is extremely unlikely, so don't do anything
    // fancy to handle it.
    if (End - Start > ULONG_MAX) {
        New->Size = ULONG_MAX;
    } else {
        New->Size = (ULONG)(End - Start);
    }
    New->Type = Type;
    InsertTailList(&Process->MemoryBlocks, &New->NextLink);
    Process->NumberOfMemoryBlocks++;
    Process->SizeOfMemoryBlocks += New->Size;

    return New;
}

void
GenRemoveMemoryRange(
    IN PINTERNAL_PROCESS Process,
    IN ULONG64 Start,
    IN ULONG Size
    )
{
    ULONG64 End = Start + Size;
    PLIST_ENTRY ScanEntry;
    PVA_RANGE Scan;
    ULONG64 ScanEnd;

 Restart:
    ScanEntry = Process->MemoryBlocks.Flink;
    while (ScanEntry != &Process->MemoryBlocks) {
        Scan = CONTAINING_RECORD(ScanEntry, VA_RANGE, NextLink);
        ScanEnd = Scan->Start + Scan->Size;
        ScanEntry = Scan->NextLink.Flink;
        
        if (Scan->Start >= End || ScanEnd <= Start) {
            // No overlap.
            continue;
        }

        if (Scan->Start < Start) {
            // Trim block to non-overlapping pre-Start section.
            Scan->Size = (ULONG)(Start - Scan->Start);
            if (ScanEnd > End) {
                // There's also a non-overlapping section post-End.
                // We need to add a new block.
                GenAddMemoryBlock(Process, Scan->Type,
                                  End, (ULONG)(ScanEnd - End));
                // The list has changed so restart.
                goto Restart;
            }
        } else if (ScanEnd > End) {
            // Trim block to non-overlapping post-End section.
            Scan->Start = End;
            Scan->Size = (ULONG)(ScanEnd - End);
        } else {
            // Scan is completely contained.
            GenRemoveMemoryBlock(Process, Scan);
            FreeMemory(Scan);
        }
    }
}

VOID
WINAPI
GenGetSystemType(
    OUT ULONG * Type, OPTIONAL
    OUT ULONG * Major, OPTIONAL
    OUT ULONG * Minor, OPTIONAL
    OUT ULONG * ServicePack, OPTIONAL
    OUT ULONG * BuildNumber OPTIONAL
    )
{
    OSVERSIONINFO Version;

    Version.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    GetVersionEx (&Version);

    if (Type) {
        if (Version.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
            *Type = Win9x;
        } else if (Version.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            *Type = WinNt;
        } else if (Version.dwPlatformId == VER_PLATFORM_WIN32_CE) {
            *Type = WinCe;
        } else {
            *Type = Unknown;
        }
    }

    if (Major) {
        if (Version.dwPlatformId == VER_PLATFORM_WIN32_NT ||
            Version.dwPlatformId == VER_PLATFORM_WIN32_CE) {
            *Major = Version.dwMajorVersion;
        } else {
            if (Version.dwMinorVersion == 0) {
                *Major = 95;
            } else {
                *Major = 98;
            }
        }
    }

    if (Minor) {
        if (Version.dwPlatformId == VER_PLATFORM_WIN32_NT ||
            Version.dwPlatformId == VER_PLATFORM_WIN32_CE) {
            *Minor = Version.dwMinorVersion;
        } else {
            *Minor = 0;
        }
    }

    //
    // TODO: Derive this from known build numbers only if it's necessary
    // for external stuff.
    //

    if (ServicePack) {
        *ServicePack = 0;
    }

    if (BuildNumber) {
        *BuildNumber = Version.dwBuildNumber;
    }
}


BOOL
GenScanAddressSpace(
    IN PINTERNAL_PROCESS Process,
    IN ULONG DumpType
    )
{
    ULONG ProtectMask = 0, TypeMask = 0;
    BOOL Succ;
    ULONG_PTR Offset;
    MEMORY_BASIC_INFORMATION Info;

    if (DumpType & MiniDumpWithPrivateReadWriteMemory) {
        ProtectMask |= PAGE_READWRITE;
        TypeMask |= MEM_PRIVATE;
    }

    if (!ProtectMask || !TypeMask) {
        // Nothing to scan for.
        return TRUE;
    }

    Succ = TRUE;

    Offset = 0;
    for (;;) {
        if (!VirtualQueryEx(Process->ProcessHandle, (LPVOID)Offset,
                            &Info, sizeof(Info))) {
            break;
        }

        Offset = (ULONG_PTR)Info.BaseAddress + Info.RegionSize;
        
        if (Info.State == MEM_COMMIT &&
            (Info.Protect & ProtectMask) &&
            (Info.Type & TypeMask)) {
            
            while (Info.RegionSize > 0) {
                ULONG BlockSize;

                if (Info.RegionSize > ULONG_MAX / 2) {
                    BlockSize = ULONG_MAX / 2;
                } else {
                    BlockSize = (ULONG)Info.RegionSize;
                }
                
                if (!GenAddMemoryBlock(Process, MEMBLOCK_PRIVATE_RW,
                                       SIGN_EXTEND(Info.BaseAddress),
                                       BlockSize)) {
                    Succ = FALSE;
                }

                Info.BaseAddress = (PVOID)
                    ((ULONG_PTR)Info.BaseAddress + BlockSize);
                Info.RegionSize -= BlockSize;
            }
        }
    }
    
    return Succ;
}


BOOL
GenGetProcessInfo(
    IN HANDLE hProcess,
    IN ULONG ProcessId,
    IN ULONG DumpType,
    IN MINIDUMP_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID CallbackParam,
    OUT PINTERNAL_PROCESS * ProcessRet
    )
{
    BOOL Succ;
    ULONG Type;
    ULONG Major;

    GenGetSystemType (&Type, &Major, NULL, NULL, NULL);

    if ( Type == WinNt && Major > 4 ) {

        Succ = NtxGetProcessInfo (hProcess, ProcessId, DumpType,
                                  CallbackRoutine, CallbackParam,
                                  ProcessRet);

    } else if ( Type == WinNt && Major == 4 ) {

        Succ = Nt4GetProcessInfo (hProcess, ProcessId, DumpType,
                                  CallbackRoutine, CallbackParam,
                                  ProcessRet);

    } else if ( Type == Win9x || Type == WinCe ) {

        Succ = ThGetProcessInfo (hProcess, ProcessId, DumpType,
                                 CallbackRoutine, CallbackParam,
                                 ProcessRet);

    } else {

        Succ = FALSE;
    }

    if (Succ) {
        // We don't consider a failure here to be a critical
        // failure.  The dump won't contain all of the
        // requested information but it'll still have
        // the basic thread information, which could be
        // valuable on its own.
        GenScanAddressSpace(*ProcessRet, DumpType);
    }
    
    return Succ;
}


BOOL
GenWriteHandleData(
    IN HANDLE ProcessHandle,
    IN HANDLE hFile,
    IN struct _MINIDUMP_STREAM_INFO * StreamInfo
    )
{
    BOOL Succ;
    ULONG Type;
    ULONG Major;

    GenGetSystemType(&Type, &Major, NULL, NULL, NULL);

    if ( Type == WinNt ) {

        Succ = NtxWriteHandleData(ProcessHandle, hFile, StreamInfo);
        
    } else {

        Succ = FALSE;

    }

    return Succ;
}


ULONG
CheckSum (
    IN ULONG                PartialSum,
    IN PVOID                SourceVa,
    IN ULONG_PTR            Length
    )
/*++

Routine Description:

    Computes a checksum for the supplied virtual address and length

    This function comes from Dr. Dobbs Journal, May 1992

Arguments:

    PartialSum  - The previous partial checksum

    SourceVa    - Starting address

    Length      - Length, in bytes, of the range

Return Value:

    The checksum value

--*/
{

    PUSHORT     Source;

    Source = (PUSHORT) SourceVa;
    Length = Length / 2;

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xFFFF);
    }

    return PartialSum;
}

BOOL
ThGetProcessInfo(
    IN HANDLE hProcess,
    IN ULONG ProcessId,
    IN ULONG DumpType,
    IN MINIDUMP_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID CallbackParam,
    OUT PINTERNAL_PROCESS * ProcessRet
    )

/*++

Routine Description:

    Using toolhelp, obtain the process information for this process.
    As toolhelp provides an abstraction for retrieval, this
    code is "generic" and can run on any platform supporting toolhelp.

Return Values:

    TRUE - Success.

    FALSE - Failure:

Environment:

    Any platform that supports toolhelp.

--*/

{
    BOOL Succ;
    BOOL MoreThreads;
    BOOL MoreModules;
    HANDLE Snapshot;
    MODULEENTRY32 ModuleInfo;
    THREADENTRY32 ThreadInfo;
    PINTERNAL_THREAD Thread;
    PINTERNAL_PROCESS Process;
    PINTERNAL_MODULE Module;
    WCHAR UnicodePath [ MAX_PATH + 10 ];

    ASSERT ( hProcess );
    ASSERT ( ProcessId != 0 );
    ASSERT ( ProcessRet );

    Process = NULL;
    Thread = NULL;
    Module = NULL;
    Snapshot = NULL;
    ModuleInfo.dwSize = sizeof (MODULEENTRY32);
    ThreadInfo.dwSize = sizeof (THREADENTRY32);

    Process = GenAllocateProcessObject ( hProcess, ProcessId );

    if ( Process == NULL ) {
        return FALSE;
    }

    Snapshot = CreateToolhelp32Snapshot (
                            TH32CS_SNAPMODULE | TH32CS_SNAPTHREAD,
                            ProcessId
                            );

    if ( Snapshot == (HANDLE) -1 ) {
        GenAccumulateStatus(MDSTATUS_CALL_FAILED);
        Succ = FALSE;
        goto Exit;
    }

    //
    // Walk thread list, suspending all threads and getting thread info.
    //


    for (MoreThreads = ProcessThread32First (Snapshot, ProcessId, &ThreadInfo );
         MoreThreads;
         MoreThreads = ProcessThread32Next ( Snapshot, ProcessId, &ThreadInfo ) ) {
        HRESULT Status;
        ULONG WriteFlags;

        if (!GenExecuteIncludeThreadCallback(hProcess,
                                             ProcessId,
                                             DumpType,
                                             ThreadInfo.th32ThreadID,
                                             CallbackRoutine,
                                             CallbackParam,
                                             &WriteFlags) ||
            IsFlagClear(WriteFlags, ThreadWriteThread)) {
            continue;
        }

        Status = GenAllocateThreadObject (
                                        Process,
                                        hProcess,
                                        ThreadInfo.th32ThreadID,
                                        DumpType,
                                        WriteFlags,
                                        &Thread
                                        );

        if ( FAILED(Status) ) {
            Succ = FALSE;
            goto Exit;
        }

        // If Status is S_FALSE it means that the thread
        // couldn't be opened and probably exited before
        // we got to it.  Just continue on.
        if (Status == S_OK) {
            Process->NumberOfThreads++;
            InsertTailList (&Process->ThreadList, &Thread->ThreadsLink);
        }
    }

    //
    // Walk module list, getting module information.
    //

    for (MoreModules = Module32First ( Snapshot, &ModuleInfo );
         MoreModules;
         MoreModules = Module32Next ( Snapshot, &ModuleInfo ) ) {
        ULONG WriteFlags;

        ASSERT ( (ULONG_PTR)ModuleInfo.modBaseAddr == (ULONG_PTR)ModuleInfo.hModule );

        if (!GenExecuteIncludeModuleCallback(hProcess,
                                             ProcessId,
                                             DumpType,
                                             (LONG_PTR)ModuleInfo.modBaseAddr,
                                             CallbackRoutine,
                                             CallbackParam,
                                             &WriteFlags) ||
            IsFlagClear(WriteFlags, ModuleWriteModule)) {
            continue;
        }
        
        MultiByteToWideChar (CP_ACP,
                             0,
                             ModuleInfo.szExePath,
                             -1,
                             UnicodePath,
                             ARRAY_COUNT(UnicodePath)
                             );


        Module = GenAllocateModuleObject (
                                    Process,
                                    UnicodePath,
                                    (LONG_PTR) ModuleInfo.modBaseAddr,
                                    DumpType,
                                    WriteFlags
                                    );

        if ( Module == NULL ) {
            Succ = FALSE;
            goto Exit;
        }

        Process->NumberOfModules++;
        InsertTailList (&Process->ModuleList, &Module->ModulesLink);
    }

    Succ = TRUE;

Exit:

    if ( Snapshot ) {
        CloseHandle ( Snapshot );
        Snapshot = NULL;
    }

    if ( !Succ && Process != NULL ) {
        GenFreeProcessObject ( Process );
        Process = NULL;
    }

    *ProcessRet = Process;

    return Succ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\impl.c ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    impl.c

Abstract:

    
    
Author:

    Matthew D Hendel (math) 22-Sept-1999

Revision History:

Comments:

    Any functions that will not be available on all platforms must be thunked
    so that the minidump dll will load on all platforms. For functions
    outside of NTDLL and KERNEL32, we use the delay-load import facility to
    achieve this. For functions that are in NTDLL and KERNEL32, we use bind
    the functions manually at DLL-load time.

Functions:

  NTDLL

    NtOpenThread                        NT
    NtQuerySystemInformation            NT
    NtQueryInformationProcess           NT
    NtQueryInformationThread            NT
    NtQueryObject                       NT
    RtlFreeHeap                         NT

  Kernel32:

    OpenThread                          NT5
    Thread32First                       Not on NT4
    Thread32Next                        Not on NT4
    Module32First                       Not on NT4
    Module32Next                        Not on NT4
    CreateToolhelp32Snapshot            Not on NT4
    GetLongPathNameA/W                  Not on NT4/Win95.

  PSAPI:

    EnumProcessModules                  NT5
    GetModuleFileNameExW                NT5

--*/

#include "pch.h"

#ifndef _WIN32_WCE
#include <delayimp.h>
#endif

#if !defined (_WIN64_)
#include "mprivate.h"
#endif

#include "nt4.h"
#include "impl.h"

//
// Exported from Win.h
//

BOOL
WinInitialize(
    );

VOID
WinFree(
    );



//
// Global Variables
//

HINSTANCE _DbgHelp;
HINSTANCE _PsApi;
BOOL FreeWin;

//
// APIs from DBGHELP
//


MINI_DUMP_READ_DUMP_STREAM xxxReadDumpStream;
MINI_DUMP_WRITE_DUMP       xxxWriteDump;

//
// APIs from NTDLL
//

NT_OPEN_THREAD xxxNtOpenThread;
NT_QUERY_SYSTEM_INFORMATION xxxNtQuerySystemInformation;
NT_QUERY_INFORMATION_PROCESS xxxNtQueryInformationProcess;
NT_QUERY_INFORMATION_THREAD xxxNtQueryInformationThread;
NT_QUERY_OBJECT xxxNtQueryObject;
RTL_FREE_HEAP xxxRtlFreeHeap;

#if defined (_X86_)

//
// APIs from Kernel32
//

OPEN_THREAD xxxOpenThread;
THREAD32_FIRST xxxThread32First;
THREAD32_NEXT xxxThread32Next;
MODULE32_FIRST xxxModule32First;
MODULE32_NEXT xxxModule32Next;
MODULE32_FIRST xxxModule32FirstW;
MODULE32_NEXT xxxModule32NextW;
CREATE_TOOLHELP32_SNAPSHOT xxxCreateToolhelp32Snapshot;
GET_LONG_PATH_NAME_A xxxGetLongPathNameA;
GET_LONG_PATH_NAME_W xxxGetLongPathNameW;

#endif

//
// APIs from PSAPI
//

ENUM_PROCESS_MODULES xxxEnumProcessModules;
GET_MODULE_FILE_NAME_EX_W xxxGetModuleFileNameExW;


//
// Function from dbghelp.dll
//

BOOL
FailReadDumpStream(
    IN PVOID Base,
    ULONG StreamNumber,
    OUT PMINIDUMP_DIRECTORY * Dir, OPTIONAL
    OUT PVOID * Stream, OPTIONAL
    OUT ULONG * StreamSize OPTIONAL
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return FALSE;
}

BOOL
FailWriteDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return FALSE;
}


//
// Functions imported from PSAPI.DLL.
//

BOOL
WINAPI
FailEnumProcessModules(
    HANDLE hProcess,
    HMODULE* lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return FALSE;
}

DWORD
WINAPI
FailGetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    PWSTR lpFilename,
    DWORD nSize
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return 0;
}


//
// Functions imported from NTDLL.DLL. NT Only.
//


NTSTATUS
WINAPI
FailNtOpenThread(
    PHANDLE ThreadHandle,
    ULONG Mask,
    PVOID Attributes,
    PVOID ClientId
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
WINAPI
FailNtQuerySystemInformation(
    IN INT SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
WINAPI
FailNtQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN INT ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
WINAPI
FailNtQueryInformationThread(
    IN HANDLE ThreadHandle,
    IN INT ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
WINAPI
FailNtQueryObject(
    IN HANDLE Handle,
    IN INT ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return STATUS_UNSUCCESSFUL;
}

BOOLEAN
NTAPI
FailRtlFreeHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )
{
    return FALSE;
}

//
// Functions imported from KERNEL32.DLL that may not be present.
//

HANDLE
WINAPI
FailOpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return NULL;
}


//
// Toolhelp functions. Not present on NT4.
//

BOOL
WINAPI
FailThread32First(
    HANDLE hSnapshot,
    PVOID ThreadEntry
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return FALSE;
}


BOOL
WINAPI
FailThread32Next(
    HANDLE hSnapshot,
    PVOID ThreadEntry
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return FALSE;
}

BOOL
WINAPI
FailModule32First(
    HANDLE hSnapshot,
    PVOID Module
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return FALSE;
}

BOOL
WINAPI
FailModule32Next(
    HANDLE hSnapshot,
    PVOID Module
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return FALSE;
}

BOOL
WINAPI
FailModule32FirstW(
    HANDLE hSnapshot,
    PVOID Module
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return FALSE;
}

BOOL
WINAPI
FailModule32NextW(
    HANDLE hSnapshot,
    PVOID Module
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return FALSE;
}

HANDLE
WINAPI
FailCreateToolhelp32Snapshot(
    DWORD dwFlags,
    DWORD th32ProcessID
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return FALSE;
}

DWORD
WINAPI
FailGetLongPathNameA(
    LPCSTR lpszShortPath,
    LPSTR lpszLongPath,
    DWORD cchBuffer
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return 0;
}

DWORD
WINAPI
FailGetLongPathNameW(
    LPCWSTR lpszShortPath,
    LPWSTR lpszLongPath,
    DWORD cchBuffer
    )
{
    SetLastError (ERROR_NOT_SUPPORTED);
    return 0;
}


//
//
// Setup an import
//

#define SETUP_IMPORT(_dll, _import, _type) {                            \
    if (_dll && xxx##_import == NULL ) {                                \
        xxx##_import = (_type) GetProcAddress (_dll, #_import);         \
    }                                                                   \
    if ( xxx##_import == NULL) {                                        \
        xxx##_import = Fail##_import;                                   \
    }                                                                   \
}


VOID
BindImports(
    )
{
    HINSTANCE Ntdll;

#if !defined (_DBGHELP_SOURCE_)

    //
    // Bind to dbghelp imports.
    //
    // We can only use the dbghelp imports if the dbghelp on
    // the system is of recent vintage and therefore has a good
    // chance of including all the latest minidump code.  Currently
    // Windows.NET Server (5.01 >= build 3620) has the latest minidump
    // code so its dbghelp can be used.  If minidump.lib has major
    // feature additions this check will need to be revised.
    //
    
    {
        ULONG Type;
        ULONG Major;
        ULONG Minor;
        ULONG Build;
        
        GenGetSystemType (&Type, &Major, &Minor, NULL, &Build);
        if (Type != WinNt || Major < 5 || Minor < 1 || Build < 3620) {
            xxxReadDumpStream = FailReadDumpStream;
            xxxWriteDump = FailWriteDump;
        } else {
            if (_DbgHelp == NULL) {
                _DbgHelp = LoadLibrary ( "DBGHELP.DLL" );
            }

            SETUP_IMPORT (_DbgHelp, ReadDumpStream, MINI_DUMP_READ_DUMP_STREAM);
            SETUP_IMPORT (_DbgHelp, WriteDump, MINI_DUMP_WRITE_DUMP);
        }
    }
    
#endif

    //
    // Bind imports from NTDLL.DLL
    //
    
    Ntdll = GetModuleHandle ( "NTDLL.DLL" );

    SETUP_IMPORT (Ntdll, NtOpenThread, NT_OPEN_THREAD);
    SETUP_IMPORT (Ntdll, NtQuerySystemInformation, NT_QUERY_SYSTEM_INFORMATION);
    SETUP_IMPORT (Ntdll, NtQueryInformationProcess, NT_QUERY_INFORMATION_PROCESS);
    SETUP_IMPORT (Ntdll, NtQueryInformationThread, NT_QUERY_INFORMATION_THREAD);
    SETUP_IMPORT (Ntdll, NtQueryObject, NT_QUERY_OBJECT);
    SETUP_IMPORT (Ntdll, RtlFreeHeap, RTL_FREE_HEAP);

#if defined (_X86_)

    //
    // Bind imports from KERNEL32.DLL
    //

    {
        HINSTANCE Kernel32;
    
        Kernel32 = GetModuleHandle ( "KERNEL32.DLL" );

        SETUP_IMPORT (Kernel32, OpenThread, OPEN_THREAD);
        SETUP_IMPORT (Kernel32, Thread32First, THREAD32_FIRST);
        SETUP_IMPORT (Kernel32, Thread32Next, THREAD32_NEXT);
        SETUP_IMPORT (Kernel32, Module32First, MODULE32_FIRST);
        SETUP_IMPORT (Kernel32, Module32Next, MODULE32_NEXT);
        SETUP_IMPORT (Kernel32, Module32FirstW, MODULE32_FIRST);
        SETUP_IMPORT (Kernel32, Module32NextW, MODULE32_NEXT);
        SETUP_IMPORT (Kernel32, CreateToolhelp32Snapshot, CREATE_TOOLHELP32_SNAPSHOT);
        SETUP_IMPORT (Kernel32, GetLongPathNameA, GET_LONG_PATH_NAME_A);
        SETUP_IMPORT (Kernel32, GetLongPathNameW, GET_LONG_PATH_NAME_W);
    }

#endif

    if ( _PsApi == NULL ) {
        _PsApi = LoadLibrary ("PSAPI.DLL");
    }

#if defined (_X86_)
    if (_PsApi == NULL) {

        ULONG Type;
        ULONG Major;
        
        //
        // NT5 and later versions of NT come with PSAPI. If its not present
        // on the system and this is an NT4 system, use internal versions
        // of this function.
        //
    
        GenGetSystemType (&Type, &Major, NULL, NULL, NULL);

        if ( Type == WinNt && Major == 4) {

            xxxEnumProcessModules = Nt4EnumProcessModules;
            xxxGetModuleFileNameExW = Nt4GetModuleFileNameExW;
        }
    }

#endif

    //
    // This will only change the thunks values when they are non-NULL.
    //
    
    SETUP_IMPORT (_PsApi, EnumProcessModules, ENUM_PROCESS_MODULES);
    SETUP_IMPORT (_PsApi, GetModuleFileNameExW, GET_MODULE_FILE_NAME_EX_W);
}

#if defined (_X86_)
//
// Win9x doesn't export these functions.
//

wchar_t *
__cdecl
xxx_wcscpy(
    wchar_t * dst,
    const wchar_t * src
    )
{
    wchar_t * cp = dst;

    while( *cp++ = *src++ )
        ;       /* Copy src over dst */

    return( dst );
}

LPWSTR
WINAPI
xxx_lstrcpynW(
    OUT LPWSTR lpString1,
    IN LPCWSTR lpString2,
    IN int iMaxLength
    )
{
    wchar_t * cp = lpString1;

    if (iMaxLength > 0)
    {
        while( iMaxLength > 1 && (*cp++ = *lpString2++) )
            iMaxLength--;       /* Copy src over dst */
        if (cp > lpString1 && cp[-1]) {
            *cp = 0;
        }
    }

    return( lpString1 );
}

size_t
__cdecl
xxx_wcslen (
    const wchar_t * wcs
    )
{
    const wchar_t *eos = wcs;

    while( *eos++ )
        ;

    return( (size_t)(eos - wcs - 1) );
}
#endif


VOID
FreeImports(
    )
{
    xxxNtOpenThread = NULL;
    xxxNtQuerySystemInformation = NULL;
    xxxNtQueryInformationProcess = NULL;
    xxxNtQueryInformationThread = NULL;
    xxxNtQueryObject = NULL;
    xxxRtlFreeHeap = NULL;

#if defined (_X86_)
    xxxOpenThread = NULL;
    xxxThread32First = NULL;
    xxxThread32Next = NULL;
    xxxModule32First = NULL;
    xxxModule32Next = NULL;
    xxxModule32FirstW = NULL;
    xxxModule32NextW = NULL;
    xxxCreateToolhelp32Snapshot = NULL;
    xxxGetLongPathNameA = NULL;
    xxxGetLongPathNameW = NULL;
#endif

    xxxEnumProcessModules = NULL;
    xxxGetModuleFileNameExW = NULL;
}


BOOL
MiniDumpSetup(
    )
{
    DWORD Type;
    
    GenGetSystemType ( &Type, NULL, NULL, NULL, NULL );
    
    BindImports ();

#if defined (_X86_)
    if ( xxxOpenThread == FailOpenThread &&
         Type == Win9x ) {

        FreeWin = WinInitialize ();

        if (!FreeWin) {
            return FALSE;
        }
    }

#endif

    return TRUE;
}

VOID
MiniDumpFree(
    )
{
    if (_PsApi) {
        FreeLibrary ( _PsApi );
        _PsApi = NULL;
    }

#if defined (_X86_)

    if ( FreeWin ) {
        WinFree ();
        FreeWin = FALSE;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\impl.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    impl.h

Abstract:

    OS-specific thunks.

Author:

    Matthew D Hendel (math) 20-Sept-1999

Revision History:

--*/

#pragma once

//
// dbghelp routines
//

typedef
BOOL
(WINAPI * MINI_DUMP_READ_DUMP_STREAM) (
    IN PVOID Base,
    ULONG StreamNumber,
    OUT PMINIDUMP_DIRECTORY * Dir, OPTIONAL
    OUT PVOID * Stream, OPTIONAL
    OUT ULONG * StreamSize OPTIONAL
    );

typedef
BOOL
(WINAPI * MINI_DUMP_WRITE_DUMP) (
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    );

extern MINI_DUMP_READ_DUMP_STREAM xxxReadDumpStream;
extern MINI_DUMP_WRITE_DUMP       xxxWriteDump;


//
// PSAPI APIs.
//


typedef
BOOL
(WINAPI *
ENUM_PROCESS_MODULES) (
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    );

typedef
DWORD
(WINAPI *
GET_MODULE_FILE_NAME_EX_W) (
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

extern ENUM_PROCESS_MODULES xxxEnumProcessModules;
extern GET_MODULE_FILE_NAME_EX_W xxxGetModuleFileNameExW;

#define EnumProcessModules xxxEnumProcessModules
#define GetModuleFileNameExW xxxGetModuleFileNameExW

//
// Functions exportd from impl.c
//

BOOL
MiniDumpSetup(
    );

VOID
MiniDumpFree(
    );

//
// Redirect the NT APIs since we don't want dbghelp to link to NTDLL directly
//

typedef LONG NTSTATUS;

typedef 
NTSTATUS
(WINAPI *
NT_OPEN_THREAD) (
    PHANDLE ThreadHandle,
    ULONG Mask,
    PVOID Attributes,
    PVOID ClientId
    );

typedef
NTSTATUS
(WINAPI *
NT_QUERY_SYSTEM_INFORMATION) (
    IN INT SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef
NTSTATUS
(WINAPI *
NT_QUERY_INFORMATION_PROCESS) (
    IN HANDLE ProcessHandle,
    IN INT ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef
NTSTATUS
(WINAPI *
NT_QUERY_INFORMATION_THREAD) (
    IN HANDLE ThreadHandle,
    IN INT ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef
NTSTATUS
(WINAPI *
NT_QUERY_OBJECT) (
    IN HANDLE Handle,
    IN INT ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef
BOOLEAN
(NTAPI*
RTL_FREE_HEAP) (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

//
// We will be using the xxx routines instead of the real routines.
//

//
// NTDLL APIs.
//

extern NT_OPEN_THREAD xxxNtOpenThread;
extern NT_QUERY_SYSTEM_INFORMATION xxxNtQuerySystemInformation;
extern NT_QUERY_INFORMATION_PROCESS xxxNtQueryInformationProcess;
extern NT_QUERY_INFORMATION_THREAD xxxNtQueryInformationThread;
extern NT_QUERY_OBJECT xxxNtQueryObject;
extern RTL_FREE_HEAP xxxRtlFreeHeap;

//
// Aliased names, for convienence.
//

#define NtOpenThread xxxNtOpenThread
#define NtQuerySystemInformation xxxNtQuerySystemInformation
#define NtQueryInformationProcess xxxNtQueryInformationProcess
#define NtQueryInformationThread xxxNtQueryInformationThread
#define NtQueryObject xxxNtQueryObject
#define RtlFreeHeap xxxRtlFreeHeap



#if defined (_X86_)

//
// Win64 supports the full NT5 Win32 API and does not have any legacy baggage
// to support. Therefore, we can directly link to all toolhelp, PSAPI and
// imagehlp functions.
//
// On some Win32 platforms, like Win95, Win98 and NT4, either Toolhelp, PSAPI,
// or OpenThread (kernel32) may not be supported. For these platforms,
// redirect these functions to internal APIs that fail gracefully.
//

typedef
HANDLE
(WINAPI *
OPEN_THREAD) (
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    );

typedef
BOOL
(WINAPI *
THREAD32_FIRST) (
    HANDLE hSnapshot,
    PVOID ThreadEntry
    );

typedef
BOOL
(WINAPI *
THREAD32_NEXT) (
    HANDLE hSnapshot,
    PVOID ThreadEntry
    );

typedef
BOOL
(WINAPI *
MODULE32_FIRST) (
    HANDLE hSnapshot,
    PVOID Module
    );

typedef
BOOL
(WINAPI *
MODULE32_NEXT) (
    HANDLE hSnapshot,
    PVOID Module
    );

typedef
HANDLE
(WINAPI *
CREATE_TOOLHELP32_SNAPSHOT) (
    DWORD dwFlags,
    DWORD th32ProcessID
    );

typedef
DWORD
(WINAPI *
GET_LONG_PATH_NAME_A) (
    LPCSTR lpszShortPath,
    LPSTR lpszLongPath,
    DWORD cchBuffer
    );

typedef
DWORD
(WINAPI *
GET_LONG_PATH_NAME_W) (
    LPCWSTR lpszShortPath,
    LPWSTR lpszLongPath,
    DWORD cchBuffer
    );

struct _IMAGE_NT_HEADERS*
xxxImageNtHeader (
    IN PVOID Base
    );

PVOID
xxxImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );


//
// We will be using the xxx routines instead of the real routines.
//

//
// Kernel32 APIs.
//

extern OPEN_THREAD xxxOpenThread;
extern THREAD32_FIRST xxxThread32First;
extern THREAD32_NEXT xxxThread32Next;
extern MODULE32_FIRST xxxModule32First;
extern MODULE32_NEXT xxxModule32Next;
extern MODULE32_FIRST xxxModule32FirstW;
extern MODULE32_NEXT xxxModule32NextW;
extern CREATE_TOOLHELP32_SNAPSHOT xxxCreateToolhelp32Snapshot;
extern GET_LONG_PATH_NAME_A xxxGetLongPathNameA;
extern GET_LONG_PATH_NAME_W xxxGetLongPathNameW;

//
// Aliased names, for convienence.
//

#define OpenThread xxxOpenThread
#define Thread32First xxxThread32First
#define Thread32Next xxxThread32Next
#define Module32First xxxModule32First
#define Module32Next xxxModule32Next
#define Module32FirstW xxxModule32FirstW
#define Module32NextW xxxModule32NextW
#define CreateToolhelp32Snapshot xxxCreateToolhelp32Snapshot
#define GetLongPathNameA xxxGetLongPathNameA
#define GetLongPathNameW xxxGetLongPathNameW

//
// Imagehlp functions.
//

#define ImageNtHeader xxxImageNtHeader
#define ImageDirectoryEntryToData xxxImageDirectoryEntryToData

//
// For Win9x support
//

wchar_t *
__cdecl
xxx_wcscpy(
    wchar_t * dst,
    const wchar_t * src
    );
    
LPWSTR
WINAPI
xxx_lstrcpynW(
    OUT LPWSTR lpString1,
    IN LPCWSTR lpString2,
    IN int iMaxLength
    );

size_t
__cdecl
xxx_wcslen (
    const wchar_t * wcs
    );

#define wcslen xxx_wcslen
#define strlenW xxx_wcslen
#define lstrlenW xxx_wcslen
#define wcscpy xxx_wcscpy
#define strcpyW xxx_wcscpy
#define lstrcpyW xxx_wcscpy
#define lstrcpynW xxx_lstrcpynW

#endif //!X86
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\minidump.c ===
/*++

Copyright(c) 1999-2002 Microsoft Corporation

Module Name:

    minidump.c

Abstract:

    Minidump user-mode crashdump support.

Author:

    Matthew D Hendel (math) 20-Aug-1999

--*/


#include "pch.h"

#ifdef _WIN32_WCE
#include <time.h>
#endif

#include <limits.h>
#include <dbgver.h>

#include "mprivate.h"
#include "impl.h"

PINTERNAL_MODULE
ModuleContainingAddress(
    IN PINTERNAL_PROCESS Process,
    IN ULONG64 Address
    )
{
    PINTERNAL_MODULE Module;
    PLIST_ENTRY ModuleEntry;

    ModuleEntry = Process->ModuleList.Flink;
    while ( ModuleEntry != &Process->ModuleList ) {

        Module = CONTAINING_RECORD (ModuleEntry, INTERNAL_MODULE,
                                    ModulesLink);
        ModuleEntry = ModuleEntry->Flink;

        if (Address >= Module->BaseOfImage &&
            Address < Module->BaseOfImage + Module->SizeOfImage) {
            return Module;
        }
    }

    return NULL;
}

VOID
ScanMemoryForModuleRefs(
    IN PINTERNAL_PROCESS Process,
    IN HANDLE hProcess,
    IN ULONG64 Base,
    IN ULONG Size,
    IN PVOID MemBuffer,
    IN MEMBLOCK_TYPE TypeOfMemory,
    IN BOOL FilterContent
    )
{
    PULONG_PTR CurMem;
    SIZE_T Done;

    // We only want to scan certain kinds of memory.
    if (TypeOfMemory != MEMBLOCK_STACK &&
        TypeOfMemory != MEMBLOCK_STORE &&
        TypeOfMemory != MEMBLOCK_DATA_SEG &&
        TypeOfMemory != MEMBLOCK_INDIRECT)
    {
        return;
    }
    
    // If the base address is not pointer-size aligned
    // we can't easily assume that this is a meaningful
    // area of memory to scan for references.  Normal
    // stack and store addresses will always be pointer
    // size aligned so this should only reject invalid
    // addresses.
    if (!Base || !Size || (Base & (sizeof(PVOID) - 1))) {
        return;
    }

    if (hProcess) {
        if (!ReadProcessMemory(hProcess, (PVOID)(ULONG_PTR)Base,
                               MemBuffer, Size, &Done)) {
            return;
        }
    } else {
        Done = Size;
    }

    CurMem = (PULONG_PTR)MemBuffer;
    Done /= sizeof(PVOID);
    while (Done-- > 0) {
        
        PINTERNAL_MODULE Module;
        BOOL InAny;

#ifdef _IA64_
        // An IA64 backing store can contain PFS values
        // that must be preserved in order to allow stack walking.
        // The high two bits of PFS are the privilege level, which
        // should always be 0y11 for user-mode code so we use this
        // as a marker to look for PFS entries.
        // There is also a NAT collection flush at every 0x1F8
        // offset.  These values cannot be filtered.
        if (TypeOfMemory == MEMBLOCK_STORE) {
            if ((Base & 0x1f8) == 0x1f8 ||
                (*CurMem & 0xc000000000000000UI64) == 0xc000000000000000UI64) {
                goto Next;
            }
        }
#endif
        
        InAny = FALSE;

        if (Module = ModuleContainingAddress(Process, SIGN_EXTEND(*CurMem))) {
            Module->WriteFlags |= ModuleReferencedByMemory;
            InAny = TRUE;
        }

        // If the current pointer is not a module reference
        // or an internal reference for a thread stack or store,
        // filter it.
        if (FilterContent && !InAny) {

            PINTERNAL_THREAD Thread;
            PLIST_ENTRY ThreadEntry;

            ThreadEntry = Process->ThreadList.Flink;
            while ( ThreadEntry != &Process->ThreadList ) {

                Thread = CONTAINING_RECORD (ThreadEntry, INTERNAL_THREAD,
                                            ThreadsLink);
                ThreadEntry = ThreadEntry->Flink;

                if ((*CurMem >= (ULONG_PTR)Thread->StackEnd &&
                     *CurMem < (ULONG_PTR)Thread->StackBase) ||
                    (*CurMem >= (ULONG_PTR)Thread->BackingStoreBase &&
                     *CurMem < (ULONG_PTR)Thread->BackingStoreBase +
                     Thread->BackingStoreSize)) {
                    InAny = TRUE;
                    break;
                }
            }

            if (!InAny) {
                *CurMem = 0;
            }
        }

#ifdef _IA64_
    Next:
#endif
        CurMem++;
        Base += sizeof(ULONG_PTR);
    }
}

BOOL
WriteAtOffset(
    IN HANDLE hFile,
    ULONG Offset,
    PVOID Buffer,
    ULONG BufferSize
    )
{
    BOOL Succ;
    DWORD OffsetRet;
    ULONG BytesWritten;

    OffsetRet = SetFilePointer (
                     hFile,
                     Offset,
                     NULL,
                     FILE_BEGIN
                     );

    if ( OffsetRet != Offset ) {
        return FALSE;
    }

    Succ = WriteFile (hFile,
                      Buffer,
                      BufferSize,
                      &BytesWritten,
                      NULL
                      );

    if ( !Succ || BytesWritten != BufferSize ) {
        return FALSE;
    }

    return TRUE;
}

BOOL
WriteOther(
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PVOID Buffer,
    IN ULONG SizeOfBuffer,
    OUT ULONG * BufferRva
    )

/*++

Routine Description:

    Write the buffer to the Other stream of the file.

Arguments:

    FileHandle - A file handle opened for writing.

    StreamInfo - Minidump size information structure.

    Buffer - The buffer to write.

    SizeOfBuffer - The size of the buffer to write.

    BufferRva - The RVA in the file that the buffer was written to.

Return Values:

    TRUE - Success.

    FALSE - Failure.

--*/

{
    BOOL Succ;
    ULONG Rva;
    ULONG BytesWritten;

    ASSERT (FileHandle && FileHandle != INVALID_HANDLE_VALUE);
    ASSERT (Buffer != NULL);
    ASSERT (SizeOfBuffer != 0);

    //
    // If it's larger than we've allocated space for, fail.
    //

    Rva = StreamInfo->RvaForCurOther;

    if (Rva + SizeOfBuffer >
        StreamInfo->RvaOfOther + StreamInfo->SizeOfOther) {

        return FALSE;
    }

    //
    // Set location to point at which we want to write and write.
    //

    Succ = SetFilePointer (
                     FileHandle,
                     Rva,
                     NULL,
                     FILE_BEGIN
                     ) != INVALID_SET_FILE_POINTER;

    if ( !Succ ) {
        return FALSE;
    }

    Succ = WriteFile (FileHandle,
                      Buffer,
                      SizeOfBuffer,
                      &BytesWritten,
                      NULL
                      );

    if ( !Succ || BytesWritten != SizeOfBuffer ) {
        return FALSE;
    }


    if ( BufferRva ) {
        *BufferRva = Rva;
    }

    StreamInfo->RvaForCurOther += SizeOfBuffer;

    return TRUE;
}


BOOL
WriteMemory(
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PVOID Buffer,
    IN ULONG64 StartOfRegion,
    IN ULONG SizeOfRegion,
    OUT ULONG * MemoryDataRva OPTIONAL
    )

/*++

Routine Description:

    Write MEMORY_DATA and MEMORY_LIST entries to to the dump file for the
    memory range described by (StartOfRange, MemoryData, SizeOfMemoryData).

Arguments:

    FileHandle - Handle of the minidump file we will write to.

    StreamInfo - Pre-computed minidump size information.

    Buffer -

    StartOfRegion -

    SizeOfRegion -

    MemoryDataRva - On success, the RVA in the file where the memory
            data was written will be returned in this variable.

Return Values:

    TRUE - Success.

    FALSE - Failure.

--*/

{
    BOOL Succ;
    ULONG BytesWritten;
    ULONG DataRva;
    ULONG ListRva;
    ULONG SizeOfMemoryDescriptor;
    MINIDUMP_MEMORY_DESCRIPTOR Descriptor;

    ASSERT ( FileHandle != NULL && FileHandle != INVALID_HANDLE_VALUE );
    ASSERT ( StreamInfo != NULL );
    ASSERT ( Buffer != NULL );
    ASSERT ( StartOfRegion != 0 );
    ASSERT ( SizeOfRegion != 0 );

    //
    // Writing a memory entry is a little different. When a memory entry
    // is written we need a descriptor in the memory list describing the
    // memory written AND a variable-sized entry in the MEMORY_DATA region
    // with the actual data.
    //


    ListRva = StreamInfo->RvaForCurMemoryDescriptor;
    DataRva = StreamInfo->RvaForCurMemoryData;
    SizeOfMemoryDescriptor = sizeof (MINIDUMP_MEMORY_DESCRIPTOR);

    //
    // If we overflowed either the memory list or the memory data
    // regions, fail.
    //

    if ( ( ListRva + SizeOfMemoryDescriptor >
           StreamInfo->RvaOfMemoryDescriptors + StreamInfo->SizeOfMemoryDescriptors) ||
         ( DataRva + SizeOfRegion >
           StreamInfo->RvaOfMemoryData + StreamInfo->SizeOfMemoryData ) ) {

        return FALSE;
    }

    //
    // First, write the data to the MEMORY_DATA region.
    //

    Succ = SetFilePointer (
                    FileHandle,
                    DataRva,
                    NULL,
                    FILE_BEGIN
                    ) != INVALID_SET_FILE_POINTER;
    if (!Succ) {
        return FALSE;
    }

    Succ = WriteFile (FileHandle,
                      Buffer,
                      SizeOfRegion,
                      &BytesWritten,
                      NULL
                      );

    if (!Succ || BytesWritten != SizeOfRegion) {
        return FALSE;
    }


    //
    // Then update the memory descriptor in the MEMORY_LIST region.
    //

    Descriptor.StartOfMemoryRange = StartOfRegion;
    Descriptor.Memory.DataSize = SizeOfRegion;
    Descriptor.Memory.Rva = DataRva;

    Succ = SetFilePointer (
                    FileHandle,
                    ListRva,
                    NULL,
                    FILE_BEGIN
                    ) != INVALID_SET_FILE_POINTER;

    if ( !Succ ) {
        return FALSE;
    }

    Succ = WriteFile (
                    FileHandle,
                    &Descriptor,
                    SizeOfMemoryDescriptor,
                    &BytesWritten,
                    NULL
                    );

    if ( !Succ || BytesWritten != SizeOfMemoryDescriptor) {
        return FALSE;
    }

    //
    // Update both the List Rva and the Data Rva and return the
    // the Data Rva.
    //

    StreamInfo->RvaForCurMemoryDescriptor += SizeOfMemoryDescriptor;
    StreamInfo->RvaForCurMemoryData += SizeOfRegion;

    if ( MemoryDataRva ) {
        *MemoryDataRva = DataRva;
    }

    return TRUE;
}


BOOL
WriteMemoryFromProcess(
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process,
    IN PVOID BaseOfRegion,
    IN ULONG SizeOfRegion,
    IN BOOL FilterContent,
    IN MEMBLOCK_TYPE TypeOfMemory,
    OUT ULONG * MemoryDataRva OPTIONAL
    )
{
    BOOL Ret = FALSE;
    BOOL Succ;
    PVOID Buffer;
    SIZE_T BytesRead = 0;

    Buffer = AllocMemory ( SizeOfRegion );

    if (Buffer) {
    
        Succ = ReadProcessMemory (
                            Process->ProcessHandle,
                            BaseOfRegion,
                            Buffer,
                            SizeOfRegion,
                            &BytesRead);

        if (Succ && (BytesRead == SizeOfRegion)) {

            if (FilterContent) {
                ScanMemoryForModuleRefs(Process, NULL,
                                        SIGN_EXTEND(BaseOfRegion),
                                        SizeOfRegion, Buffer, TypeOfMemory,
                                        TRUE);
            }
            
            Ret = WriteMemory (
                            FileHandle,
                            StreamInfo,
                            Buffer,
                            SIGN_EXTEND (BaseOfRegion),
                            SizeOfRegion,
                            MemoryDataRva);
        }

        FreeMemory(Buffer);
    }

    return Ret;
}




BOOL
WriteThread(
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN LPVOID ThreadData,
    IN ULONG SizeOfThreadData,
    OUT ULONG * ThreadDataRva OPTIONAL
    )
{
    BOOL Succ;
    ULONG Rva;
    ULONG BytesWritten;

    ASSERT (FileHandle && FileHandle != INVALID_HANDLE_VALUE);
    ASSERT (StreamInfo);
    ASSERT (ThreadData);


    Rva = StreamInfo->RvaForCurThread;

    if ( Rva + SizeOfThreadData >
         StreamInfo->RvaOfThreadList + StreamInfo->SizeOfThreadList ) {

         return FALSE;
    }

    Succ = SetFilePointer (
                    FileHandle,
                    Rva,
                    NULL,
                    FILE_BEGIN
                    ) != INVALID_SET_FILE_POINTER;

    if ( !Succ ) {
        return FALSE;
    }

    Succ = WriteFile (
                    FileHandle,
                    ThreadData,
                    SizeOfThreadData,
                    &BytesWritten,
                    NULL
                    );

    if ( !Succ || BytesWritten != SizeOfThreadData ) {
        return FALSE;
    }

    if ( ThreadDataRva ) {
        *ThreadDataRva = Rva;
    }
    StreamInfo->RvaForCurThread += SizeOfThreadData;

    return TRUE;
}


BOOL
WriteStringToPool(
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PWSTR String,
    OUT ULONG * StringRva
    )
{
    BOOL Succ;
    ULONG BytesWritten;
    ULONG32 StringLen;
    ULONG SizeOfString;
    ULONG Rva;

    ASSERT (FileHandle && FileHandle != INVALID_HANDLE_VALUE);
    ASSERT (String);
    ASSERT (sizeof (ULONG32) == sizeof (MINIDUMP_STRING));


    StringLen = lstrlenW ( String ) * sizeof (WCHAR);
    SizeOfString = sizeof (MINIDUMP_STRING) + StringLen + sizeof (WCHAR);
    Rva = StreamInfo->RvaForCurString;

    if ( Rva + SizeOfString >
         StreamInfo->RvaOfStringPool + StreamInfo->SizeOfStringPool ) {

        return FALSE;
    }

    Succ = SetFilePointer (
                    FileHandle,
                    Rva,
                    NULL,
                    FILE_BEGIN
                    ) != INVALID_SET_FILE_POINTER;

    if ( !Succ ) {
        return FALSE;
    }

    Succ = WriteFile (
                    FileHandle,
                    &StringLen,
                    sizeof (StringLen),
                    &BytesWritten,
                    NULL
                    );

    if ( !Succ || BytesWritten != sizeof (StringLen) ) {
        return FALSE;
    }

    //
    // Possible alignment problems on 64-bit machines??
    //

    //
    // Include the trailing '\000'.
    //

    StringLen += sizeof (WCHAR);
    Succ = WriteFile (
                    FileHandle,
                    String,
                    StringLen,
                    &BytesWritten,
                    NULL
                    );

    if ( !Succ || BytesWritten != StringLen ) {
        return FALSE;
    }

    if ( StringRva ) {
        *StringRva = Rva;
    }

    StreamInfo->RvaForCurString += SizeOfString;

    return TRUE;
}


BOOL
WriteModule (
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PMINIDUMP_MODULE Module,
    OUT ULONG * ModuleRva
    )
{
    BOOL Succ;
    ULONG Rva;
    ULONG BytesWritten;
    ULONG SizeOfModule;

    ASSERT (FileHandle && FileHandle != INVALID_HANDLE_VALUE);
    ASSERT (StreamInfo);
    ASSERT (Module);


    SizeOfModule = sizeof (MINIDUMP_MODULE);
    Rva = StreamInfo->RvaForCurModule;

    if ( Rva + SizeOfModule >
         StreamInfo->RvaOfModuleList + StreamInfo->SizeOfModuleList ) {

        return FALSE;
    }

    Succ = SetFilePointer (FileHandle,
                           Rva,
                           NULL,
                           FILE_BEGIN
                           ) != INVALID_SET_FILE_POINTER;

    if ( !Succ ) {
        return FALSE;
    }

    Succ = WriteFile (FileHandle,
                      Module,
                      SizeOfModule,
                      &BytesWritten,
                      NULL
                      );

    if ( !Succ || BytesWritten != SizeOfModule ) {
        return FALSE;
    }

    if ( ModuleRva ) {
        *ModuleRva = Rva;
    }

    StreamInfo->RvaForCurModule += SizeOfModule;

    return TRUE;
}

BOOL
WriteUnloadedModule (
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PMINIDUMP_UNLOADED_MODULE Module,
    OUT ULONG * ModuleRva
    )
{
    BOOL Succ;
    ULONG Rva;
    ULONG BytesWritten;
    ULONG SizeOfModule;

    ASSERT (FileHandle && FileHandle != INVALID_HANDLE_VALUE);
    ASSERT (StreamInfo);
    ASSERT (Module);


    SizeOfModule = sizeof (*Module);
    Rva = StreamInfo->RvaForCurUnloadedModule;

    if ( Rva + SizeOfModule >
         StreamInfo->RvaOfUnloadedModuleList +
         StreamInfo->SizeOfUnloadedModuleList ) {

        return FALSE;
    }

    Succ = SetFilePointer (FileHandle,
                           Rva,
                           NULL,
                           FILE_BEGIN
                           ) != INVALID_SET_FILE_POINTER;

    if ( !Succ ) {
        return FALSE;
    }

    Succ = WriteFile (FileHandle,
                      Module,
                      SizeOfModule,
                      &BytesWritten,
                      NULL
                      );

    if ( !Succ || BytesWritten != SizeOfModule ) {
        return FALSE;
    }

    if ( ModuleRva ) {
        *ModuleRva = Rva;
    }

    StreamInfo->RvaForCurUnloadedModule += SizeOfModule;

    return TRUE;
}


BOOL
WriteThreadList(
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process,
    IN ULONG DumpType
    )

/*++

Routine Description:

    Write the thread list to the dump file. This includes the thread, and
    optionally the context and memory for the thread.

Return Values:

    TRUE - The thread list was successfully written.

    FALSE - There was an error writing the thread list.

--*/

{
    BOOL Succ;
    ULONG StackMemoryRva;
    ULONG StoreMemoryRva;
    ULONG ContextRva;
    MINIDUMP_THREAD_EX DumpThread;
    PINTERNAL_THREAD Thread;
    ULONG NumberOfThreads;
    ULONG BytesWritten;
    PLIST_ENTRY Entry;

    ASSERT (FileHandle && FileHandle != INVALID_HANDLE_VALUE);
    ASSERT (Process);
    ASSERT (StreamInfo);

    //
    // Write the thread count.
    //

    NumberOfThreads = Process->NumberOfThreadsToWrite;

    Succ = SetFilePointer (
                    FileHandle,
                    StreamInfo->RvaOfThreadList,
                    NULL,
                    FILE_BEGIN
                    ) != INVALID_SET_FILE_POINTER;

    if ( !Succ ) {
        return FALSE;
    }

    Succ = WriteFile ( FileHandle,
                       &NumberOfThreads,
                       sizeof (NumberOfThreads),
                       &BytesWritten,
                       NULL
                       );

    if ( !Succ || BytesWritten != sizeof (NumberOfThreads) ) {
        return FALSE;
    }

    StreamInfo->RvaForCurThread += BytesWritten;

    //
    // Iterate over the thread list writing the description,
    // context and memory for each thread.
    //

    Entry = Process->ThreadList.Flink;
    while ( Entry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (Entry,
                                    INTERNAL_THREAD,
                                    ThreadsLink);
        Entry = Entry->Flink;


        //
        // Only write the threads that have been flagged to be written.
        //

        if (IsFlagClear (Thread->WriteFlags, ThreadWriteThread)) {
            continue;
        }


        //
        // Write the context if it was flagged to be written.
        //

        if (IsFlagSet (Thread->WriteFlags, ThreadWriteContext)) {

            //
            // Write the thread context to the OTHER stream.
            //

            Succ = WriteOther (
                        FileHandle,
                        StreamInfo,
                        &Thread->Context,
                        Thread->SizeOfContext,
                        &ContextRva
                        );

            if ( !Succ ) {
                return FALSE;
            }

        } else {

            ContextRva = 0;
        }


        //
        // Write the stack if it was flagged to be written.
        //

        if (IsFlagSet (Thread->WriteFlags, ThreadWriteStack)) {

            //
            // Write the stack memory data; write it directly from the image.
            //

            Succ = WriteMemoryFromProcess(
                            FileHandle,
                            StreamInfo,
                            Process,
                            (PVOID) Thread->StackEnd,
                            (ULONG) (Thread->StackBase - Thread->StackEnd),
                            IsFlagSet(DumpType, MiniDumpFilterMemory),
                            MEMBLOCK_STACK,
                            &StackMemoryRva
                            );

            if ( !Succ ) {
                return FALSE;
            }

        } else {

            StackMemoryRva = 0;
        }


        //
        // Write the backing store if it was flagged to be written.
        // A newly created thread's backing store may be empty
        // so handle the case of zero size.
        //

        if (IsFlagSet (Thread->WriteFlags, ThreadWriteBackingStore) &&
            Thread->BackingStoreSize) {

            //
            // Write the store memory data; write it directly from the image.
            //

            Succ = WriteMemoryFromProcess(
                            FileHandle,
                            StreamInfo,
                            Process,
                            (PVOID) Thread->BackingStoreBase,
                            Thread->BackingStoreSize,
                            IsFlagSet(DumpType, MiniDumpFilterMemory),
                            MEMBLOCK_STORE,
                            &StoreMemoryRva
                            );

            if ( !Succ ) {
                return FALSE;
            }

        } else {

            StoreMemoryRva = 0;
        }

        //
        // Build the dump thread.
        //

        DumpThread.ThreadId = Thread->ThreadId;
        DumpThread.SuspendCount = Thread->SuspendCount;
        DumpThread.PriorityClass = Thread->PriorityClass;
        DumpThread.Priority = Thread->Priority;
        DumpThread.Teb = Thread->Teb;

        //
        // Stack offset and size.
        //

        DumpThread.Stack.StartOfMemoryRange = Thread->StackEnd;
        DumpThread.Stack.Memory.DataSize =
                    (ULONG) ( Thread->StackBase - Thread->StackEnd );
        DumpThread.Stack.Memory.Rva = StackMemoryRva;

        //
        // Backing store offset and size.
        //

        DumpThread.BackingStore.StartOfMemoryRange = Thread->BackingStoreBase;
        DumpThread.BackingStore.Memory.DataSize = Thread->BackingStoreSize;
        DumpThread.BackingStore.Memory.Rva = StoreMemoryRva;

        //
        // Context offset and size.
        //

        DumpThread.ThreadContext.DataSize = Thread->SizeOfContext;
        DumpThread.ThreadContext.Rva = ContextRva;


        //
        // Write the dump thread to the threads region.
        //

        Succ = WriteThread (
                        FileHandle,
                        StreamInfo,
                        &DumpThread,
                        StreamInfo->ThreadStructSize,
                        NULL
                        );
    }

    return TRUE;
}


BOOL
WriteModuleList(
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process
    )
{
    BOOL Succ;
    MINIDUMP_MODULE DumpModule;
    ULONG StringRva;
    ULONG CvRecordRva;
    ULONG MiscRecordRva;
    PLIST_ENTRY Entry;
    PINTERNAL_MODULE Module;
    ULONG32 NumberOfModules;
    ULONG BytesWritten;


    ASSERT (FileHandle && FileHandle != INVALID_HANDLE_VALUE);
    ASSERT (Process);
    ASSERT (StreamInfo);

    NumberOfModules = Process->NumberOfModulesToWrite;

    Succ = SetFilePointer (
                    FileHandle,
                    StreamInfo->RvaForCurModule,
                    NULL,
                    FILE_BEGIN
                    ) != INVALID_SET_FILE_POINTER;

    if ( !Succ ) {
        return FALSE;
    }

    Succ = WriteFile ( FileHandle,
                       &NumberOfModules,
                       sizeof (NumberOfModules),
                       &BytesWritten,
                       NULL
                       );

    if ( !Succ || BytesWritten != sizeof (NumberOfModules) ) {
        return FALSE;
    }

    StreamInfo->RvaForCurModule += sizeof (NumberOfModules);

    //
    // Iterate through the module list writing the module name, module entry
    // and module debug info to the dump file.
    //

    Entry = Process->ModuleList.Flink;
    while ( Entry != &Process->ModuleList ) {

        Module = CONTAINING_RECORD (Entry,
                                    INTERNAL_MODULE,
                                    ModulesLink);
        Entry = Entry->Flink;

        //
        // If we are not to write information for this module, just continue.
        //

        if (IsFlagClear (Module->WriteFlags, ModuleWriteModule)) {
            continue;
        }

        //
        // Write module name.
        //

        Succ = WriteStringToPool (
                     FileHandle,
                     StreamInfo,
                     Module->SavePath,
                     &StringRva
                     );

        if ( !Succ ) {
            return FALSE;
        }

        //
        // Write CvRecord for a module into the OTHER region.
        //

        if ( IsFlagSet (Module->WriteFlags, ModuleWriteCvRecord) &&
             Module->CvRecord != NULL && Module->SizeOfCvRecord != 0 ) {

            Succ = WriteOther (
                        FileHandle,
                        StreamInfo,
                        Module->CvRecord,
                        Module->SizeOfCvRecord,
                        &CvRecordRva
                        );


            if ( !Succ) {
                return FALSE;
            }

        } else {

            CvRecordRva = 0;
        }

        if ( IsFlagSet (Module->WriteFlags, ModuleWriteMiscRecord) &&
             Module->MiscRecord != NULL && Module->SizeOfMiscRecord != 0 ) {

            Succ = WriteOther (
                        FileHandle,
                        StreamInfo,
                        Module->MiscRecord,
                        Module->SizeOfMiscRecord,
                        &MiscRecordRva
                        );

            if ( !Succ ) {
                return FALSE;
            }

        } else {

            MiscRecordRva = 0;
        }

        DumpModule.BaseOfImage = Module->BaseOfImage;
        DumpModule.SizeOfImage = Module->SizeOfImage;
        DumpModule.CheckSum = Module->CheckSum;
        DumpModule.TimeDateStamp = Module->TimeDateStamp;
        DumpModule.VersionInfo = Module->VersionInfo;
        DumpModule.CvRecord.Rva = CvRecordRva;
        DumpModule.CvRecord.DataSize = Module->SizeOfCvRecord;
        DumpModule.MiscRecord.Rva = MiscRecordRva;
        DumpModule.MiscRecord.DataSize = Module->SizeOfMiscRecord;
        DumpModule.ModuleNameRva = StringRva;
        DumpModule.Reserved0 = 0;
        DumpModule.Reserved1 = 0;

        //
        // Write the module entry itself.
        //

        Succ = WriteModule (
                         FileHandle,
                         StreamInfo,
                         &DumpModule,
                         NULL
                         );

        if ( !Succ ) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
WriteUnloadedModuleList(
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process
    )
{
    BOOL Succ;
    MINIDUMP_UNLOADED_MODULE_LIST DumpModuleList;
    MINIDUMP_UNLOADED_MODULE DumpModule;
    ULONG StringRva;
    PLIST_ENTRY Entry;
    PINTERNAL_UNLOADED_MODULE Module;
    ULONG32 NumberOfModules;
    ULONG BytesWritten;


    ASSERT (FileHandle && FileHandle != INVALID_HANDLE_VALUE);
    ASSERT (Process);
    ASSERT (StreamInfo);

    if (IsListEmpty(&Process->UnloadedModuleList)) {
        // Nothing to write.
        return TRUE;
    }
    
    NumberOfModules = Process->NumberOfUnloadedModules;

    Succ = SetFilePointer (
                    FileHandle,
                    StreamInfo->RvaForCurUnloadedModule,
                    NULL,
                    FILE_BEGIN
                    ) != INVALID_SET_FILE_POINTER;

    if ( !Succ ) {
        return FALSE;
    }

    DumpModuleList.SizeOfHeader = sizeof(DumpModuleList);
    DumpModuleList.SizeOfEntry = sizeof(DumpModule);
    DumpModuleList.NumberOfEntries = NumberOfModules;
    
    Succ = WriteFile ( FileHandle,
                       &DumpModuleList,
                       sizeof (DumpModuleList),
                       &BytesWritten,
                       NULL
                       );

    if ( !Succ || BytesWritten != sizeof (DumpModuleList) ) {
        return FALSE;
    }

    StreamInfo->RvaForCurUnloadedModule += sizeof (DumpModuleList);

    //
    // Iterate through the module list writing the module name, module entry
    // and module debug info to the dump file.
    //

    Entry = Process->UnloadedModuleList.Flink;
    while ( Entry != &Process->UnloadedModuleList ) {

        Module = CONTAINING_RECORD (Entry,
                                    INTERNAL_UNLOADED_MODULE,
                                    ModulesLink);
        Entry = Entry->Flink;

        //
        // Write module name.
        //

        Succ = WriteStringToPool (
                     FileHandle,
                     StreamInfo,
                     Module->Path,
                     &StringRva
                     );

        if ( !Succ ) {
            return FALSE;
        }

        DumpModule.BaseOfImage = Module->BaseOfImage;
        DumpModule.SizeOfImage = Module->SizeOfImage;
        DumpModule.CheckSum = Module->CheckSum;
        DumpModule.TimeDateStamp = Module->TimeDateStamp;
        DumpModule.ModuleNameRva = StringRva;

        //
        // Write the module entry itself.
        //

        Succ = WriteUnloadedModule(FileHandle,
                                   StreamInfo,
                                   &DumpModule,
                                   NULL);
        if ( !Succ ) {
            return FALSE;
        }
    }

    return TRUE;
}

#define FUNCTION_TABLE_ALIGNMENT 8

BOOL
WriteFunctionTableList(
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process
    )
{
    BOOL Succ;
    MINIDUMP_FUNCTION_TABLE_STREAM TableStream;
    MINIDUMP_FUNCTION_TABLE_DESCRIPTOR DumpTable;
    PLIST_ENTRY Entry;
    PINTERNAL_FUNCTION_TABLE Table;
    ULONG BytesWritten;
    RVA PrevRva, Rva;


    ASSERT (FileHandle && FileHandle != INVALID_HANDLE_VALUE);
    ASSERT (Process);
    ASSERT (StreamInfo);

    if (IsListEmpty(&Process->FunctionTableList)) {
        // Nothing to write.
        return TRUE;
    }
    
    Rva = StreamInfo->RvaOfFunctionTableList;
    
    Succ = SetFilePointer (
                    FileHandle,
                    Rva,
                    NULL,
                    FILE_BEGIN
                    ) != INVALID_SET_FILE_POINTER;

    if ( !Succ ) {
        return FALSE;
    }

    TableStream.SizeOfHeader = sizeof(TableStream);
    TableStream.SizeOfDescriptor = sizeof(DumpTable);
    TableStream.SizeOfNativeDescriptor = sizeof(DYNAMIC_FUNCTION_TABLE);
    TableStream.SizeOfFunctionEntry = sizeof(RUNTIME_FUNCTION);
    TableStream.NumberOfDescriptors = Process->NumberOfFunctionTables;
    // Ensure that the actual descriptors are 8-byte aligned in
    // the overall file.
    Rva += sizeof(TableStream);
    PrevRva = Rva;
    Rva = (Rva + FUNCTION_TABLE_ALIGNMENT - 1) &
        ~(FUNCTION_TABLE_ALIGNMENT - 1);
    TableStream.SizeOfAlignPad = Rva - PrevRva;
    
    Succ = WriteFile ( FileHandle,
                       &TableStream,
                       sizeof (TableStream),
                       &BytesWritten,
                       NULL
                       );

    if ( !Succ || BytesWritten != sizeof (TableStream) ) {
        return FALSE;
    }

    //
    // Iterate through the function table list
    // and write out the table data.
    //

    Entry = Process->FunctionTableList.Flink;
    while ( Entry != &Process->FunctionTableList ) {

        Table = CONTAINING_RECORD (Entry,
                                   INTERNAL_FUNCTION_TABLE,
                                   TableLink);
        Entry = Entry->Flink;

        // Move to aligned RVA.
        Succ = SetFilePointer (FileHandle,
                               Rva,
                               NULL,
                               FILE_BEGIN
                               ) != INVALID_SET_FILE_POINTER;
        if ( !Succ ) {
            return FALSE;
        }

        DumpTable.MinimumAddress = Table->MinimumAddress;
        DumpTable.MaximumAddress = Table->MaximumAddress;
        DumpTable.BaseAddress = Table->BaseAddress;
        DumpTable.EntryCount = Table->EntryCount;
        Rva += sizeof(DumpTable) + sizeof(DYNAMIC_FUNCTION_TABLE) +
               sizeof(RUNTIME_FUNCTION) * Table->EntryCount;
        PrevRva = Rva;
        Rva = (Rva + FUNCTION_TABLE_ALIGNMENT - 1) &
            ~(FUNCTION_TABLE_ALIGNMENT - 1);
        DumpTable.SizeOfAlignPad = Rva - PrevRva;
        
        Succ = WriteFile ( FileHandle,
                           &DumpTable,
                           sizeof (DumpTable),
                           &BytesWritten,
                           NULL
                           );
        if ( !Succ || BytesWritten != sizeof (DumpTable) ) {
            return FALSE;
        }
        Succ = WriteFile ( FileHandle,
                           &Table->RawTable,
                           sizeof (Table->RawTable),
                           &BytesWritten,
                           NULL
                           );
        if ( !Succ || BytesWritten != sizeof (Table->RawTable) ) {
            return FALSE;
        }
        Succ = WriteFile ( FileHandle,
                           Table->RawEntries,
                           sizeof (RUNTIME_FUNCTION) * Table->EntryCount,
                           &BytesWritten,
                           NULL
                           );
        if ( !Succ ||
             BytesWritten != sizeof (RUNTIME_FUNCTION) * Table->EntryCount ) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
WriteMemoryBlocks(
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process
    )
{
    PLIST_ENTRY ScanEntry;
    PVA_RANGE Scan;

    ScanEntry = Process->MemoryBlocks.Flink;
    while (ScanEntry != &Process->MemoryBlocks) {
        Scan = CONTAINING_RECORD(ScanEntry, VA_RANGE, NextLink);
        ScanEntry = Scan->NextLink.Flink;
        
        if (!WriteMemoryFromProcess(FileHandle,
                                    StreamInfo,
                                    Process,
                                    (PVOID)(ULONG_PTR)Scan->Start,
                                    Scan->Size,
                                    FALSE,
                                    Scan->Type,
                                    NULL)) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
CalculateSizeForThreads(
    IN PINTERNAL_PROCESS Process,
    IN OUT MINIDUMP_STREAM_INFO * StreamInfo
    )
{
    ULONG SizeOfContexts;
    ULONG SizeOfMemRegions;
    ULONG SizeOfThreads;
    ULONG SizeOfMemoryDescriptors;
    ULONG NumberOfThreads;
    ULONG NumberOfMemRegions;
    PINTERNAL_THREAD Thread;
    PLIST_ENTRY Entry;

    ASSERT (Process);
    ASSERT (StreamInfo);


    NumberOfThreads = 0;
    NumberOfMemRegions = 0;
    SizeOfContexts = 0;
    SizeOfMemRegions = 0;

    // If no backing store information is written a normal
    // MINIDUMP_THREAD can be used, otherwise a MINIDUMP_THREAD_EX
    // is required.
    StreamInfo->ThreadStructSize = sizeof(MINIDUMP_THREAD);

    Entry = Process->ThreadList.Flink;
    while ( Entry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (Entry,
                                    INTERNAL_THREAD,
                                    ThreadsLink);
        Entry = Entry->Flink;


        //
        // Do we need to write any information for this thread at all?
        //

        if (IsFlagClear (Thread->WriteFlags, ThreadWriteThread)) {
            continue;
        }

        NumberOfThreads++;

        //
        // Write a context for this thread?
        //

        if (IsFlagSet (Thread->WriteFlags, ThreadWriteContext)) {
            SizeOfContexts += Thread->SizeOfContext;
        }

        //
        // Write a stack for this thread?
        //

        if (IsFlagSet (Thread->WriteFlags, ThreadWriteStack)) {
            NumberOfMemRegions++;
            SizeOfMemRegions += (ULONG) (Thread->StackBase - Thread->StackEnd);
        }
        
        //
        // Write the backing store for this thread?
        //

        if (IsFlagSet (Thread->WriteFlags, ThreadWriteBackingStore)) {
            // A newly created thread's backing store may be empty
            // so handle the case of zero size.
            if (Thread->BackingStoreSize) {
                NumberOfMemRegions++;
                SizeOfMemRegions += Thread->BackingStoreSize;
            }
            // We still need a THREAD_EX as this is a platform
            // which supports backing store.
            StreamInfo->ThreadStructSize = sizeof(MINIDUMP_THREAD_EX);
        }

        // Write an instruction window for this thread?
        if (IsFlagSet (Thread->WriteFlags, ThreadWriteInstructionWindow)) {
            GenGetThreadInstructionWindow(Process, Thread);
        }

        // Write thread data for this thread?
        if (IsFlagSet (Thread->WriteFlags, ThreadWriteThreadData) &&
            Thread->SizeOfTeb) {
            GenAddMemoryBlock(Process, MEMBLOCK_TEB,
                              Thread->Teb, Thread->SizeOfTeb);
        }
    }

    Process->NumberOfThreadsToWrite = NumberOfThreads;
    
    //
    // Nobody should have allocated memory from the thread list region yet.
    //

    ASSERT (StreamInfo->SizeOfThreadList == 0);

    SizeOfThreads = NumberOfThreads * StreamInfo->ThreadStructSize;
    SizeOfMemoryDescriptors = NumberOfMemRegions *
        sizeof (MINIDUMP_MEMORY_DESCRIPTOR);

    StreamInfo->SizeOfThreadList += sizeof (ULONG32);
    StreamInfo->SizeOfThreadList += SizeOfThreads;

    StreamInfo->SizeOfOther += SizeOfContexts;
    StreamInfo->SizeOfMemoryData += SizeOfMemRegions;
    StreamInfo->SizeOfMemoryDescriptors += SizeOfMemoryDescriptors;

    return TRUE;
}

BOOL
CalculateSizeForModules(
    IN PINTERNAL_PROCESS Process,
    IN OUT MINIDUMP_STREAM_INFO * StreamInfo
    )

/*++

Routine Description:

    Calculate amount of space needed in the string pool, the memory table and
    the module list table for module information.

Arguments:

    Process - Minidump process information.

    StreamInfo - The stream size information for this dump.

Return Values:

    TRUE - Success.

    FALSE - Failure.

--*/

{
    ULONG NumberOfModules;
    ULONG SizeOfDebugInfo;
    ULONG SizeOfStringData;
    PINTERNAL_MODULE Module;
    PLIST_ENTRY Entry;

    ASSERT (Process);
    ASSERT (StreamInfo);


    NumberOfModules = 0;
    SizeOfDebugInfo = 0;
    SizeOfStringData = 0;

    Entry = Process->ModuleList.Flink;
    while ( Entry != &Process->ModuleList ) {

        Module = CONTAINING_RECORD (Entry, INTERNAL_MODULE, ModulesLink);
        Entry = Entry->Flink;

        if (IsFlagClear (Module->WriteFlags, ModuleWriteModule)) {
            continue;
        }

        NumberOfModules++;
        SizeOfStringData += ( lstrlenW ( Module->SavePath ) + 1 ) * sizeof (WCHAR);
        SizeOfStringData += sizeof ( MINIDUMP_STRING );

        //
        // Add in the sizes of both the CV and MISC records.
        //

        if (IsFlagSet (Module->WriteFlags, ModuleWriteCvRecord)) {
            SizeOfDebugInfo += Module->SizeOfCvRecord;
        }
        
        if (IsFlagSet (Module->WriteFlags, ModuleWriteMiscRecord)) {
            SizeOfDebugInfo += Module->SizeOfMiscRecord;
        }

        //
        // Add the module data sections if requested.
        //

        if (IsFlagSet (Module->WriteFlags, ModuleWriteDataSeg)) {
            GenGetDataContributors(Process, Module);
        }
    }

    Process->NumberOfModulesToWrite = NumberOfModules;
    
    ASSERT (StreamInfo->SizeOfModuleList == 0);

    StreamInfo->SizeOfModuleList += sizeof (MINIDUMP_MODULE_LIST);
    StreamInfo->SizeOfModuleList += (NumberOfModules * sizeof (MINIDUMP_MODULE));

    StreamInfo->SizeOfStringPool += SizeOfStringData;
    StreamInfo->SizeOfOther += SizeOfDebugInfo;

    return TRUE;
}

BOOL
CalculateSizeForUnloadedModules(
    IN PINTERNAL_PROCESS Process,
    IN OUT MINIDUMP_STREAM_INFO * StreamInfo
    )

{
    ULONG SizeOfStringData;
    PINTERNAL_UNLOADED_MODULE Module;
    PLIST_ENTRY Entry;

    ASSERT (Process);
    ASSERT (StreamInfo);


    SizeOfStringData = 0;

    Entry = Process->UnloadedModuleList.Flink;
    while ( Entry != &Process->UnloadedModuleList ) {

        Module = CONTAINING_RECORD (Entry, INTERNAL_UNLOADED_MODULE,
                                    ModulesLink);
        Entry = Entry->Flink;

        SizeOfStringData += ( lstrlenW ( Module->Path ) + 1 ) * sizeof (WCHAR);
        SizeOfStringData += sizeof ( MINIDUMP_STRING );
    }

    ASSERT (StreamInfo->SizeOfUnloadedModuleList == 0);

    StreamInfo->SizeOfUnloadedModuleList +=
        sizeof (MINIDUMP_UNLOADED_MODULE_LIST);
    StreamInfo->SizeOfUnloadedModuleList +=
        (Process->NumberOfUnloadedModules * sizeof (MINIDUMP_UNLOADED_MODULE));

    StreamInfo->SizeOfStringPool += SizeOfStringData;

    return TRUE;
}

BOOL
CalculateSizeForFunctionTables(
    IN PINTERNAL_PROCESS Process,
    IN OUT MINIDUMP_STREAM_INFO * StreamInfo
    )
{
    ULONG SizeOfTableData;
    PINTERNAL_FUNCTION_TABLE Table;
    PLIST_ENTRY Entry;

    ASSERT (Process);
    ASSERT (StreamInfo);


    SizeOfTableData = 0;

    Entry = Process->FunctionTableList.Flink;
    while ( Entry != &Process->FunctionTableList ) {

        Table = CONTAINING_RECORD (Entry, INTERNAL_FUNCTION_TABLE, TableLink);
        Entry = Entry->Flink;

        // Alignment space is required as the structures
        // in the stream must be properly aligned.
        SizeOfTableData += FUNCTION_TABLE_ALIGNMENT +
            sizeof(MINIDUMP_FUNCTION_TABLE_DESCRIPTOR) +
            sizeof(DYNAMIC_FUNCTION_TABLE) +
            Table->EntryCount * sizeof(RUNTIME_FUNCTION);
    }

    ASSERT (StreamInfo->SizeOfFunctionTableList == 0);

    StreamInfo->SizeOfFunctionTableList +=
        sizeof (MINIDUMP_FUNCTION_TABLE_STREAM) + SizeOfTableData;

    return TRUE;
}



BOOL
WriteDirectoryEntry(
    IN HANDLE hFile,
    IN ULONG StreamType,
    IN ULONG RvaOfDir,
    IN SIZE_T SizeOfDir
    )
{
    BOOL Succ;
    ULONG BytesWritten;
    MINIDUMP_DIRECTORY Dir;

    //
    // Do not write empty streams.
    //

    if (SizeOfDir == 0) {
        return TRUE;
    }

    //
    // The maximum size of a directory is a ULONG.
    //

    if (SizeOfDir > _UI32_MAX) {
        return FALSE;
    }

    Dir.StreamType = StreamType;
    Dir.Location.Rva = RvaOfDir;
    Dir.Location.DataSize = (ULONG) SizeOfDir;

    Succ = WriteFile ( hFile,
                       &Dir,
                       sizeof (Dir),
                       &BytesWritten,
                       NULL
                       );

    if ( !Succ || BytesWritten != sizeof (Dir) ) {
        return FALSE;
    }

    return TRUE;
}

VOID
ScanContextForModuleRefs(
    IN PINTERNAL_PROCESS Process,
    IN PINTERNAL_THREAD Thread
    )
{
    ULONG NumReg;
    PULONG_PTR Reg;
    PINTERNAL_MODULE Module;

#if defined(_X86_)
    Reg = (PULONG_PTR)&Thread->Context.Edi;
    NumReg = 11;
#elif defined(_IA64_)
    Reg = (PULONG_PTR)&Thread->Context.IntGp;
    NumReg = 41;
#elif defined(_AMD64_)
    Reg = (PULONG_PTR)&Thread->Context.Rax;
    NumReg = 17;
#elif defined(ARM)
    Reg = (PULONG_PTR)&Thread->Context.R0;
    NumReg = 16;
#else
#error "Unknown processor"
#endif

    while (NumReg-- > 0) {
        if (Module = ModuleContainingAddress(Process, SIGN_EXTEND(*Reg))) {
            Module->WriteFlags |= ModuleReferencedByMemory;
        }

        Reg++;
    }
}
    
BOOL
FilterOrScanMemory(
    IN PINTERNAL_PROCESS Process,
    IN PVOID MemBuffer
    )
{
    PINTERNAL_THREAD Thread;
    PLIST_ENTRY ThreadEntry;

    //
    // Scan the stack and backing store
    // memory for every thread.
    //
    
    ThreadEntry = Process->ThreadList.Flink;
    while ( ThreadEntry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (ThreadEntry, INTERNAL_THREAD, ThreadsLink);
        ThreadEntry = ThreadEntry->Flink;

        ScanContextForModuleRefs(Process, Thread);
        
        ScanMemoryForModuleRefs(Process, Process->ProcessHandle,
                                Thread->StackEnd,
                                (ULONG)(Thread->StackBase - Thread->StackEnd),
                                MemBuffer, MEMBLOCK_STACK, FALSE);
        ScanMemoryForModuleRefs(Process, Process->ProcessHandle,
                                Thread->BackingStoreBase,
                                Thread->BackingStoreSize,
                                MemBuffer, MEMBLOCK_STORE, FALSE);
    }

    return TRUE;
}

#define IND_CAPTURE_SIZE (PAGE_SIZE / 4)
#define PRE_IND_CAPTURE_SIZE (IND_CAPTURE_SIZE / 4)

BOOL
AddIndirectMemory(
    IN PINTERNAL_PROCESS Process,
    IN ULONG64 Base,
    IN ULONG Size,
    IN PVOID MemBuffer
    )
{
    PULONG_PTR CurMem;
    SIZE_T Done;
    BOOL Succ = TRUE;

    // If the base address is not pointer-size aligned
    // we can't easily assume that this is a meaningful
    // area of memory to scan for references.  Normal
    // stack and store addresses will always be pointer
    // size aligned so this should only reject invalid
    // addresses.
    if (!Base || !Size || (Base & (sizeof(PVOID) - 1))) {
        return TRUE;
    }

    if (!ReadProcessMemory(Process->ProcessHandle, (PVOID)(ULONG_PTR)Base,
                           MemBuffer, Size, &Done)) {
        return FALSE;
    }

    CurMem = (PULONG_PTR)MemBuffer;
    Done /= sizeof(PVOID);
    while (Done-- > 0) {

        ULONG64 Start;
        
        //
        // How much memory to save behind the pointer is an
        // interesting question.  The reference could be to
        // an arbitrary amount of data, so we want to save
        // a good chunk, but we don't want to end up saving
        // full memory.
        // Instead, pick an arbitrary size -- 1/4 of a page --
        // and save some before and after the pointer.
        //

        Start = SIGN_EXTEND(*CurMem);
        // If it's a pointer into an image assume doesn't
        // need to be stored via this mechanism as it's either
        // code, which will be mapped later; or data, which can
        // be saved with MiniDumpWithDataSegs.
        if (!ModuleContainingAddress(Process, Start)) {
            if (Start < PRE_IND_CAPTURE_SIZE) {
                Start = 0;
            } else {
                Start -= PRE_IND_CAPTURE_SIZE;
            }
            if (!GenAddMemoryBlock(Process, MEMBLOCK_INDIRECT,
                                   Start, IND_CAPTURE_SIZE)) {
                Succ = FALSE;
            }
        }

        CurMem++;
    }

    return Succ;
}

BOOL
AddIndirectlyReferencedMemory(
    IN PINTERNAL_PROCESS Process,
    IN PVOID MemBuffer
    )
{
    PINTERNAL_THREAD Thread;
    PLIST_ENTRY ThreadEntry;

    //
    // Scan the stack and backing store
    // memory for every thread.
    //
    
    ThreadEntry = Process->ThreadList.Flink;
    while ( ThreadEntry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (ThreadEntry, INTERNAL_THREAD, ThreadsLink);
        ThreadEntry = ThreadEntry->Flink;

        if (!AddIndirectMemory(Process,
                               Thread->StackEnd,
                               (ULONG)(Thread->StackBase - Thread->StackEnd),
                               MemBuffer)) {
            return FALSE;
        }
        if (!AddIndirectMemory(Process,
                               Thread->BackingStoreBase,
                               Thread->BackingStoreSize,
                               MemBuffer)) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
PostProcessInfo(
    IN ULONG DumpType,
    IN PINTERNAL_PROCESS Process
    )
{
    PVOID MemBuffer;
    BOOL Succ = TRUE;

    MemBuffer = AllocMemory(Process->MaxStackOrStoreSize);
    if (!MemBuffer) {
        return FALSE;
    }
    
    if (DumpType & (MiniDumpFilterMemory | MiniDumpScanMemory)) {
        if (!FilterOrScanMemory(Process, MemBuffer)) {
            Succ = FALSE;
        }
    }

    if (Succ &&
        (DumpType & MiniDumpWithIndirectlyReferencedMemory)) {
        // Indirect memory is not crucial to the dump so
        // ignore any failures.
        AddIndirectlyReferencedMemory(Process, MemBuffer);
    }

    FreeMemory(MemBuffer);
    return Succ;
}


BOOL
ExecuteCallbacks(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN PINTERNAL_PROCESS Process,
    IN MINIDUMP_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID CallbackParam
    )
{
    BOOL Succ;
    PINTERNAL_MODULE Module;
    PINTERNAL_THREAD Thread;
    PLIST_ENTRY Entry;
    MINIDUMP_CALLBACK_INPUT CallbackInput;
    MINIDUMP_CALLBACK_OUTPUT CallbackOutput;


    ASSERT ( hProcess != NULL );
    ASSERT ( ProcessId != 0 );
    ASSERT ( Process != NULL );

    Thread = NULL;
    Module = NULL;

    //
    // If there are no callbacks to call, then we are done.
    //

    if ( CallbackRoutine == NULL ) {
        return TRUE;
    }

    CallbackInput.ProcessHandle = hProcess;
    CallbackInput.ProcessId = ProcessId;


    //
    // Call callbacks for each module.
    //

    CallbackInput.CallbackType = ModuleCallback;

    Entry = Process->ModuleList.Flink;
    while ( Entry != &Process->ModuleList ) {

        Module = CONTAINING_RECORD (Entry, INTERNAL_MODULE, ModulesLink);
        Entry = Entry->Flink;

        CallbackInput.Module.FullPath = Module->FullPath;
        CallbackInput.Module.BaseOfImage = Module->BaseOfImage;
        CallbackInput.Module.SizeOfImage = Module->SizeOfImage;
        CallbackInput.Module.CheckSum = Module->CheckSum;
        CallbackInput.Module.TimeDateStamp = Module->TimeDateStamp;
        CopyMemory (&CallbackInput.Module.VersionInfo,
                    &Module->VersionInfo,
                    sizeof (CallbackInput.Module.VersionInfo)
                    );
        CallbackInput.Module.CvRecord = Module->CvRecord;
        CallbackInput.Module.SizeOfCvRecord = Module->SizeOfCvRecord;
        CallbackInput.Module.MiscRecord = Module->MiscRecord;
        CallbackInput.Module.SizeOfMiscRecord = Module->SizeOfMiscRecord;

        CallbackOutput.ModuleWriteFlags = Module->WriteFlags;

        Succ = CallbackRoutine (
                    CallbackParam,
                    &CallbackInput,
                    &CallbackOutput
                    );

        //
        // If the callback returned FALSE, quit now.
        //

        if ( !Succ ) {
            return FALSE;
        }

        // Don't turn on any flags that weren't originally set.
        Module->WriteFlags &= CallbackOutput.ModuleWriteFlags;
    }

    Module = NULL;

    //
    // Call callbacks for each thread.
    //

#if !defined (DUMP_BACKING_STORE)
    CallbackInput.CallbackType = ThreadCallback;
#else
    CallbackInput.CallbackType = ThreadExCallback;
#endif

    Entry = Process->ThreadList.Flink;
    while ( Entry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (Entry, INTERNAL_THREAD, ThreadsLink);
        Entry = Entry->Flink;

        CallbackInput.ThreadEx.ThreadId = Thread->ThreadId;
        CallbackInput.ThreadEx.ThreadHandle = Thread->ThreadHandle;
        CallbackInput.ThreadEx.Context = Thread->Context;
        CallbackInput.ThreadEx.SizeOfContext = Thread->SizeOfContext;
        CallbackInput.ThreadEx.StackBase = Thread->StackBase;
        CallbackInput.ThreadEx.StackEnd = Thread->StackEnd;
        CallbackInput.ThreadEx.BackingStoreBase = Thread->BackingStoreBase;
        CallbackInput.ThreadEx.BackingStoreEnd =
            Thread->BackingStoreBase + Thread->BackingStoreSize;

        CallbackOutput.ThreadWriteFlags = Thread->WriteFlags;

        Succ = CallbackRoutine (
                    CallbackParam,
                    &CallbackInput,
                    &CallbackOutput
                    );

        //
        // If the callback returned FALSE, quit now.
        //

        if ( !Succ ) {
            return FALSE;
        }

        // Don't turn on any flags that weren't originally set.
        Thread->WriteFlags &= CallbackOutput.ThreadWriteFlags;
    }

    Thread = NULL;

    return TRUE;
}

#if defined (i386)


BOOL
X86CpuId(
    IN ULONG32 SubFunction,
    OUT PULONG32 EaxRegister, OPTIONAL
    OUT PULONG32 EbxRegister, OPTIONAL
    OUT PULONG32 EcxRegister, OPTIONAL
    OUT PULONG32 EdxRegister  OPTIONAL
    )
{
    BOOL Succ;
    ULONG32 _Eax;
    ULONG32 _Ebx;
    ULONG32 _Ecx;
    ULONG32 _Edx;

    _try {
        _asm {
            mov eax, SubFunction

            _emit 0x0F
            _emit 0xA2  ;; CPUID

            mov _Eax, eax
            mov _Ebx, ebx
            mov _Ecx, ecx
            mov _Edx, edx
        }

        if ( EaxRegister ) {
            *EaxRegister = _Eax;
        }

        if ( EbxRegister ) {
            *EbxRegister = _Ebx;
        }

        if ( EcxRegister ) {
            *EcxRegister = _Ecx;
        }

        if ( EdxRegister ) {
            *EdxRegister = _Edx;
        }

        Succ = TRUE;
    }

    _except ( EXCEPTION_EXECUTE_HANDLER ) {

        Succ = FALSE;
    }

    return Succ;
}



VOID
GetCpuInformation(
    PCPU_INFORMATION Cpu
    )

/*++

Routine Description:

    Get X86 specific CPU information using the CPUID opcode.

Arguments:

    Cpu - A buffer where the CPU information will be copied. If CPUID is
        not supported on this processor (pre pentium processors) we will
        fill in all zeros.

Return Value:

    None.

--*/

{
    BOOL Succ;

    //
    // Get the VendorID
    //

    Succ = X86CpuId ( CPUID_VENDOR_ID,
                      NULL,
                      &Cpu->X86CpuInfo.VendorId [0],
                      &Cpu->X86CpuInfo.VendorId [2],
                      &Cpu->X86CpuInfo.VendorId [1]
                      );

    if ( !Succ ) {

        //
        // CPUID is not supported on this processor.
        //

        ZeroMemory (&Cpu->X86CpuInfo, sizeof (Cpu->X86CpuInfo));
    }

    //
    // Get the feature information.
    //

    Succ = X86CpuId ( CPUID_VERSION_FEATURES,
                      &Cpu->X86CpuInfo.VersionInformation,
                      NULL,
                      NULL,
                      &Cpu->X86CpuInfo.FeatureInformation
                      );

    if ( !Succ ) {
        Cpu->X86CpuInfo.VersionInformation = 0;
        Cpu->X86CpuInfo.FeatureInformation = 0;
    }

    //
    // Get the AMD specific information if this is an AMD processor.
    //

    if ( Cpu->X86CpuInfo.VendorId [0] == AMD_VENDOR_ID_0 &&
         Cpu->X86CpuInfo.VendorId [1] == AMD_VENDOR_ID_1 &&
         Cpu->X86CpuInfo.VendorId [2] == AMD_VENDOR_ID_2 ) {

        Succ = X86CpuId ( CPUID_AMD_EXTENDED_FEATURES,
                          NULL,
                          NULL,
                          NULL,
                          &Cpu->X86CpuInfo.AMDExtendedCpuFeatures
                          );

        if ( !Succ ) {
            Cpu->X86CpuInfo.AMDExtendedCpuFeatures = 0;
        }
    }
}

#else

VOID
GetCpuInformation(
    PCPU_INFORMATION Cpu
    )

/*++

Routine Description:

    Get CPU information for non-X86 platform using the
    IsProcessorFeaturePresent() API call.

Arguments:

    Cpu - A buffer where the processor feature information will be copied.
        Note: we copy the processor features as a set of bits or'd together.
        Also, we only allow for the first 128 processor feature flags.

Return Value:

    None.

--*/

{
    ULONG64 i;
    DWORD j;

    for (i = 0; i < ARRAY_COUNT (Cpu->OtherCpuInfo.ProcessorFeatures); i++) {

        Cpu->OtherCpuInfo.ProcessorFeatures[i] = 0;
        for (j = 0; j < 64; j++) {
            if (IsProcessorFeaturePresent ( j )) {
                Cpu->OtherCpuInfo.ProcessorFeatures[i] |= 1 << j;
            }
        }
    }
}

#endif


BOOL
WriteSystemInfo(
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo
    )
{
    BOOL Succ;
    MINIDUMP_SYSTEM_INFO SystemInfo;
    SYSTEM_INFO SysInfo;
    OSVERSIONINFOEX Version;
    WCHAR CSDVersionW [128];
    RVA StringRva;
    ULONG Length;

    StringRva = 0;

    //
    // First, get the system information.
    //

    GetSystemInfo (&SysInfo);

    SystemInfo.ProcessorArchitecture = SysInfo.wProcessorArchitecture;
    SystemInfo.ProcessorLevel = SysInfo.wProcessorLevel;
    SystemInfo.ProcessorRevision = SysInfo.wProcessorRevision;
    SystemInfo.NumberOfProcessors = (UCHAR)SysInfo.dwNumberOfProcessors;

    //
    // Next get OS Information.
    //

    // Try first with the EX struct.
    Version.dwOSVersionInfoSize = sizeof (Version);

    Succ = GetVersionEx ( (LPOSVERSIONINFO)&Version );

    if ( !Succ ) {
        // EX struct didn't work, try with the basic struct.
        ZeroMemory(&Version, sizeof(Version));
        Version.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if (!GetVersionEx ( (LPOSVERSIONINFO)&Version )) {
            return FALSE;
        }
    }

    SystemInfo.ProductType = Version.wProductType;
    SystemInfo.MajorVersion = Version.dwMajorVersion;
    SystemInfo.MinorVersion = Version.dwMinorVersion;
    SystemInfo.BuildNumber = Version.dwBuildNumber;
    SystemInfo.PlatformId = Version.dwPlatformId;
    SystemInfo.SuiteMask = Version.wSuiteMask;
    SystemInfo.Reserved2 = 0;

    if (!MultiByteToWideChar (CP_ACP,
                              0,
                              Version.szCSDVersion,
                              -1,
                              CSDVersionW,
                              sizeof (CSDVersionW) / sizeof(WCHAR)
                              )) {
        return FALSE;
    }

    Length = ( lstrlenW (CSDVersionW) + 1 ) * sizeof (WCHAR);


    if ( Length != StreamInfo->VersionStringLength ) {

        //
        // If this fails it means that since the OS lied to us about the
        // size of the string. Very bad, we should investigate.
        //

        ASSERT ( FALSE );
        return FALSE;
    }

    Succ = WriteStringToPool (
                FileHandle,
                StreamInfo,
                CSDVersionW,
                &StringRva
                );

    if ( !Succ ) {
        return FALSE;
    }

    SystemInfo.CSDVersionRva = StringRva;

    //
    // Finally, get CPU information.
    //

    GetCpuInformation ( &SystemInfo.Cpu );

    ASSERT ( sizeof (SystemInfo) == StreamInfo->SizeOfSystemInfo );

    Succ = WriteAtOffset (
                FileHandle,
                StreamInfo->RvaOfSystemInfo,
                &SystemInfo,
                sizeof (SystemInfo)
                );

    return Succ;
}

BOOL
CalculateSizeForSystemInfo(
    IN PINTERNAL_PROCESS Process,
    IN OUT MINIDUMP_STREAM_INFO * StreamInfo
    )
{
    BOOL Succ;
    OSVERSIONINFO Version;
    WCHAR CSDVersionW [128];
    ULONG Length;

    Version.dwOSVersionInfoSize = sizeof (Version);

    Succ = GetVersionEx ( &Version );

    if ( !Succ ) {
        return FALSE;
    }

    if (!MultiByteToWideChar (CP_ACP,
                              0,
                              Version.szCSDVersion,
                              -1,
                              CSDVersionW,
                              sizeof (CSDVersionW) / sizeof(WCHAR)
                              )) {
        return FALSE;
    }

    Length = ( lstrlenW (CSDVersionW) + 1 ) * sizeof (WCHAR);

    StreamInfo->SizeOfSystemInfo = sizeof (MINIDUMP_SYSTEM_INFO);
    StreamInfo->SizeOfStringPool += Length;
    StreamInfo->SizeOfStringPool += sizeof (MINIDUMP_STRING);
    StreamInfo->VersionStringLength = Length;

    return TRUE;
}

BOOL
WriteMiscInfo(
    IN HANDLE FileHandle,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process
    )
{
    MINIDUMP_MISC_INFO MiscInfo;

    ZeroMemory(&MiscInfo, sizeof(MiscInfo));
    MiscInfo.SizeOfInfo = sizeof(MiscInfo);
    
    MiscInfo.Flags1 |= MINIDUMP_MISC1_PROCESS_ID;
    MiscInfo.ProcessId = Process->ProcessId;

    if (Process->TimesValid) {
        MiscInfo.Flags1 |= MINIDUMP_MISC1_PROCESS_TIMES;
        MiscInfo.ProcessCreateTime = Process->CreateTime;
        MiscInfo.ProcessUserTime = Process->UserTime;
        MiscInfo.ProcessKernelTime = Process->KernelTime;
    }
    
    return WriteAtOffset(FileHandle,
                         StreamInfo->RvaOfMiscInfo,
                         &MiscInfo,
                         sizeof(MiscInfo));
}

void
PostProcessMemoryBlocks(
    IN PINTERNAL_PROCESS Process
    )
{
    PINTERNAL_THREAD Thread;
    PLIST_ENTRY ThreadEntry;

    //
    // Remove any overlap with thread stacks and backing stores.
    //
    
    ThreadEntry = Process->ThreadList.Flink;
    while ( ThreadEntry != &Process->ThreadList ) {

        Thread = CONTAINING_RECORD (ThreadEntry, INTERNAL_THREAD, ThreadsLink);
        ThreadEntry = ThreadEntry->Flink;

        GenRemoveMemoryRange(Process, 
                             Thread->StackEnd,
                             (ULONG)(Thread->StackBase - Thread->StackEnd));
        GenRemoveMemoryRange(Process,
                             Thread->BackingStoreBase,
                             Thread->BackingStoreSize);
    }
}

BOOL
CalculateStreamInfo(
    IN PINTERNAL_PROCESS Process,
    IN ULONG DumpType,
    OUT PMINIDUMP_STREAM_INFO StreamInfo,
    IN BOOL ExceptionPresent,
    IN PMINIDUMP_USER_STREAM UserStreamArray,
    IN ULONG UserStreamCount
    )
{
    ULONG i;
    BOOL Succ;
    ULONG NumberOfStreams;
    ULONG SizeOfDirectory;
    ULONG SizeOfUserStreams;


    ASSERT ( Process != NULL );
    ASSERT ( StreamInfo != NULL );


    ZeroMemory (StreamInfo, sizeof (*StreamInfo));

    if ( ExceptionPresent ) {
        NumberOfStreams = NUMBER_OF_STREAMS + UserStreamCount;
    } else {
        NumberOfStreams = NUMBER_OF_STREAMS + UserStreamCount - 1;
    }
    if (DumpType & MiniDumpWithHandleData) {
        NumberOfStreams++;
    }
    if (!IsListEmpty(&Process->UnloadedModuleList)) {
        NumberOfStreams++;
    }
    // Add a stream for dynamic function tables if some were found.
    if (!IsListEmpty(&Process->FunctionTableList)) {
        NumberOfStreams++;
    }

    SizeOfDirectory = sizeof (MINIDUMP_DIRECTORY) * NumberOfStreams;

    StreamInfo->NumberOfStreams = NumberOfStreams;

    StreamInfo->RvaOfHeader = 0;

    StreamInfo->SizeOfHeader = sizeof (MINIDUMP_HEADER);

    StreamInfo->RvaOfDirectory =
        StreamInfo->RvaOfHeader + StreamInfo->SizeOfHeader;

    StreamInfo->SizeOfDirectory = SizeOfDirectory;

    StreamInfo->RvaOfSystemInfo =
        StreamInfo->RvaOfDirectory + StreamInfo->SizeOfDirectory;

    Succ = CalculateSizeForSystemInfo ( Process, StreamInfo );

    if ( !Succ ) {
        return FALSE;
    }

    StreamInfo->RvaOfMiscInfo =
        StreamInfo->RvaOfSystemInfo + StreamInfo->SizeOfSystemInfo;
    
    StreamInfo->RvaOfException =
        StreamInfo->RvaOfMiscInfo + sizeof(MINIDUMP_MISC_INFO);

    //
    // If an exception is present, reserve enough space for the exception
    // and for the excepting thread's context in the Other stream.
    //

    if ( ExceptionPresent ) {
        StreamInfo->SizeOfException = sizeof (MINIDUMP_EXCEPTION_STREAM);
        StreamInfo->SizeOfOther += sizeof (CONTEXT);
    }

    StreamInfo->RvaOfThreadList =
        StreamInfo->RvaOfException + StreamInfo->SizeOfException;
    StreamInfo->RvaForCurThread = StreamInfo->RvaOfThreadList;

    Succ = CalculateSizeForThreads ( Process, StreamInfo );

    if ( !Succ ) {
        return FALSE;
    }

    Succ = CalculateSizeForModules ( Process, StreamInfo );

    if ( !Succ ) {
        return FALSE;
    }

    if (!IsListEmpty(&Process->UnloadedModuleList)) {
        Succ = CalculateSizeForUnloadedModules ( Process, StreamInfo );
        if ( !Succ ) {
            return FALSE;
        }
    }

    if (!IsListEmpty(&Process->FunctionTableList)) {
        Succ = CalculateSizeForFunctionTables ( Process, StreamInfo );
    }

    if ((DumpType & MiniDumpWithProcessThreadData) &&
        Process->SizeOfPeb) {
        GenAddMemoryBlock(Process, MEMBLOCK_PEB,
                          Process->Peb, Process->SizeOfPeb);
    }
        
    PostProcessMemoryBlocks(Process);
    
    // Add in any extra memory blocks.
    StreamInfo->SizeOfMemoryData += Process->SizeOfMemoryBlocks;
    StreamInfo->SizeOfMemoryDescriptors += Process->NumberOfMemoryBlocks *
        sizeof(MINIDUMP_MEMORY_DESCRIPTOR);

    StreamInfo->RvaOfModuleList =
            StreamInfo->RvaOfThreadList + StreamInfo->SizeOfThreadList;
    StreamInfo->RvaForCurModule = StreamInfo->RvaOfModuleList;

    StreamInfo->RvaOfUnloadedModuleList =
            StreamInfo->RvaOfModuleList + StreamInfo->SizeOfModuleList;
    StreamInfo->RvaForCurUnloadedModule = StreamInfo->RvaOfUnloadedModuleList;

    // If there aren't any function tables the size will be zero
    // and the RVA will just end up being the RVA after
    // the module list.
    StreamInfo->RvaOfFunctionTableList =
        StreamInfo->RvaOfUnloadedModuleList +
        StreamInfo->SizeOfUnloadedModuleList;

    
    StreamInfo->RvaOfStringPool =
        StreamInfo->RvaOfFunctionTableList +
        StreamInfo->SizeOfFunctionTableList;
    StreamInfo->RvaForCurString = StreamInfo->RvaOfStringPool;
    StreamInfo->RvaOfOther =
            StreamInfo->RvaOfStringPool + StreamInfo->SizeOfStringPool;
    StreamInfo->RvaForCurOther = StreamInfo->RvaOfOther;


    SizeOfUserStreams = 0;

    for (i = 0; i < UserStreamCount; i++) {

        SizeOfUserStreams += (ULONG) UserStreamArray[i].BufferSize;
    }

    StreamInfo->RvaOfUserStreams =
            StreamInfo->RvaOfOther + StreamInfo->SizeOfOther;
    StreamInfo->SizeOfUserStreams = SizeOfUserStreams;


    //
    // Minidumps with full memory must put the raw memory
    // data at the end of the dump so that it's easy to
    // avoid mapping it when the dump is mapped.  There's
    // no problem with putting the memory data at the end
    // of the dump in all the other cases so just always
    // put the memory data at the end of the dump.
    //
    // One other benefit of having the raw data at the end
    // is that we can safely assume that everything except
    // the raw memory data will fit in the first 4GB of
    // the file so we don't need to use 64-bit file offsets
    // for everything.
    //
    // In the full memory case no other memory should have
    // been saved so far as stacks, data segs and so on
    // will automatically be included in the full memory
    // information.  If something was saved it'll throw off
    // the dump writing as full memory descriptors are generated
    // on the fly at write time rather than being precached.
    // If other descriptors and memory blocks have been written
    // out everything will be wrong.
    // Full-memory descriptors are also 64-bit and do not
    // match the 32-bit descriptors written elsewhere.
    //

    if ((DumpType & MiniDumpWithFullMemory) &&
        (StreamInfo->SizeOfMemoryDescriptors > 0 ||
         StreamInfo->SizeOfMemoryData > 0)) {
        return FALSE;
    }
    
    StreamInfo->SizeOfMemoryDescriptors +=
        (DumpType & MiniDumpWithFullMemory) ?
        sizeof (MINIDUMP_MEMORY64_LIST) : sizeof (MINIDUMP_MEMORY_LIST);
    StreamInfo->RvaOfMemoryDescriptors =
        StreamInfo->RvaOfUserStreams + StreamInfo->SizeOfUserStreams;
    StreamInfo->RvaForCurMemoryDescriptor =
        StreamInfo->RvaOfMemoryDescriptors;

    StreamInfo->RvaOfMemoryData =
        StreamInfo->RvaOfMemoryDescriptors +
        StreamInfo->SizeOfMemoryDescriptors;
    StreamInfo->RvaForCurMemoryData = StreamInfo->RvaOfMemoryData;

    //
    // Handle data cannot easily be sized beforehand so it's
    // also streamed in at write time.  In a partial dump
    // it'll come after the memory data.  In a full dump
    // it'll come before it.
    //

    StreamInfo->RvaOfHandleData = StreamInfo->RvaOfMemoryData +
        StreamInfo->SizeOfMemoryData;
    
    return TRUE;
}



BOOL
WriteHeader(
    IN HANDLE hFile,
    IN ULONG DumpType,
    IN PMINIDUMP_STREAM_INFO StreamInfo
    )
{
    BOOL Succ;
    MINIDUMP_HEADER Header;

    Header.Signature = MINIDUMP_SIGNATURE;
    // Encode an implementation-specific version into the high word
    // of the version to make it clear what version of the code
    // was used to generate a dump.
    Header.Version =
        (MINIDUMP_VERSION & 0xffff) |
        ((VER_PRODUCTMAJORVERSION & 0xf) << 28) |
        ((VER_PRODUCTMINORVERSION & 0xf) << 24) |
        ((VER_PRODUCTBUILD & 0xff) << 16);
    Header.NumberOfStreams = StreamInfo->NumberOfStreams;
    Header.StreamDirectoryRva = StreamInfo->RvaOfDirectory;
    // If there were any partial failures during the
    // dump generation set the checksum to indicate that.
    // The checksum field was never used before so
    // we're stealing it for a somewhat related purpose.
    Header.CheckSum = GenGetAccumulatedStatus();
    Header.Flags = DumpType;

    //
    // Store the time of dump generation.
    //

#ifdef _WIN32_WCE
    Header.TimeDateStamp = time(NULL);
#else
    {
       FILETIME FileTime;
       
       GetSystemTimeAsFileTime(&FileTime);
       Header.TimeDateStamp = FileTimeToTimeDate(&FileTime);
    }
#endif

    ASSERT (sizeof (Header) == StreamInfo->SizeOfHeader);

    Succ = WriteAtOffset (
                       hFile,
                       StreamInfo->RvaOfHeader,
                       &Header,
                       sizeof (Header)
                       );

    return Succ;
}


BOOL
WriteDirectoryTable(
    IN HANDLE hFile,
    IN ULONG DumpType,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process,
    IN PMINIDUMP_USER_STREAM UserStreamArray,
    IN ULONG UserStreamCount
    )
{
    ULONG i;
    BOOL Succ;
    ULONG Offset;

    Succ = WriteDirectoryEntry (
                            hFile,
                            StreamInfo->ThreadStructSize ==
                                sizeof(MINIDUMP_THREAD_EX) ?
                                ThreadExListStream : ThreadListStream,
                            StreamInfo->RvaOfThreadList,
                            StreamInfo->SizeOfThreadList
                            );

    if ( !Succ ) {
        return FALSE;
    }

    Succ = WriteDirectoryEntry (
                          hFile,
                          ModuleListStream,
                          StreamInfo->RvaOfModuleList,
                          StreamInfo->SizeOfModuleList
                          );

    if ( !Succ ) {
        return FALSE;
    }

    if (!IsListEmpty(&Process->UnloadedModuleList)) {
        Succ = WriteDirectoryEntry (hFile,
                                    UnloadedModuleListStream,
                                    StreamInfo->RvaOfUnloadedModuleList,
                                    StreamInfo->SizeOfUnloadedModuleList);
        if ( !Succ ) {
            return FALSE;
        }
    }

    if (!IsListEmpty(&Process->FunctionTableList)) {
        Succ = WriteDirectoryEntry (hFile,
                                    FunctionTableStream,
                                    StreamInfo->RvaOfFunctionTableList,
                                    StreamInfo->SizeOfFunctionTableList);
        if ( !Succ ) {
            return FALSE;
        }
    }

    Succ = WriteDirectoryEntry (
                          hFile,
                          (DumpType & MiniDumpWithFullMemory) ?
                              Memory64ListStream : MemoryListStream,
                          StreamInfo->RvaOfMemoryDescriptors,
                          StreamInfo->SizeOfMemoryDescriptors
                          );

    if ( !Succ ) {
        return FALSE;
    }

    //
    // Write exception directory entry.
    //

    Succ = WriteDirectoryEntry (
                         hFile,
                         ExceptionStream,
                         StreamInfo->RvaOfException,
                         StreamInfo->SizeOfException
                         );

    if ( !Succ ) {
        return FALSE;
    }

    //
    // Write system info entry.
    //

    Succ = WriteDirectoryEntry (
                        hFile,
                        SystemInfoStream,
                        StreamInfo->RvaOfSystemInfo,
                        StreamInfo->SizeOfSystemInfo
                        );

    if ( !Succ ) {
        return FALSE;
    }

    //
    // Write misc info entry.
    //

    if (!WriteDirectoryEntry(hFile,
                             MiscInfoStream,
                             StreamInfo->RvaOfMiscInfo,
                             sizeof(MINIDUMP_MISC_INFO))) {
        return FALSE;
    }

    if (DumpType & MiniDumpWithHandleData) {
        
        //
        // Write handle data entry.
        //

        Succ = WriteDirectoryEntry (hFile,
                                    HandleDataStream,
                                    StreamInfo->RvaOfHandleData,
                                    StreamInfo->SizeOfHandleData);
        if ( !Succ ) {
            return FALSE;
        }
    }
    
    Offset = StreamInfo->RvaOfUserStreams;

    for (i = 0; i < UserStreamCount; i++) {

        Succ = WriteDirectoryEntry (hFile,
                                    UserStreamArray[i].Type,
                                    Offset,
                                    UserStreamArray [i].BufferSize
                                    );
        if ( !Succ ) {
            return FALSE;
        }

        Offset += UserStreamArray[i].BufferSize;
    }

    return TRUE;
}



BOOL
WriteException(
    IN HANDLE hFile,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN CONST PEXCEPTION_INFO ExceptionInfo
    )
{
    BOOL Succ;
    ULONG i;
    ULONG ContextRva;
    PEXCEPTION_RECORD ExceptionRecord;
    PMINIDUMP_EXCEPTION DumpExceptionRecord;
    MINIDUMP_EXCEPTION_STREAM ExceptionStream;


    if (ExceptionInfo == NULL ) {
        return TRUE;
    }

    Succ = WriteOther (
                hFile,
                StreamInfo,
                ExceptionInfo->ExceptionPointers.ContextRecord,
                sizeof (CONTEXT),
                &ContextRva
                );


    ZeroMemory (&ExceptionStream, sizeof (ExceptionStream));

    ExceptionStream.ThreadId = ExceptionInfo->ThreadId;

    ExceptionRecord = ExceptionInfo->ExceptionPointers.ExceptionRecord;
    DumpExceptionRecord = &ExceptionStream.ExceptionRecord;

    DumpExceptionRecord->ExceptionCode = ExceptionRecord->ExceptionCode;
    DumpExceptionRecord->ExceptionFlags = ExceptionRecord->ExceptionFlags;

    DumpExceptionRecord->ExceptionRecord =
            SIGN_EXTEND (ExceptionRecord->ExceptionRecord);

    DumpExceptionRecord->ExceptionAddress =
            SIGN_EXTEND (ExceptionRecord->ExceptionAddress);

    DumpExceptionRecord->NumberParameters =
            ExceptionRecord->NumberParameters;

    //
    // We've seen some cases where the exception record has
    // a bogus number of parameters, causing stack corruption here.
    // We could fail such cases but in the spirit of try to
    // allow dumps to generated as often as possible we just
    // limit the number to the maximum.
    //
    if (DumpExceptionRecord->NumberParameters > EXCEPTION_MAXIMUM_PARAMETERS) {
        DumpExceptionRecord->NumberParameters = EXCEPTION_MAXIMUM_PARAMETERS;
    }
    
    for (i = 0; i < DumpExceptionRecord->NumberParameters; i++) {

        DumpExceptionRecord->ExceptionInformation [ i ] =
                SIGN_EXTEND (ExceptionRecord->ExceptionInformation [ i ]);
    }

    ExceptionStream.ThreadContext.DataSize = sizeof (CONTEXT);
    ExceptionStream.ThreadContext.Rva = ContextRva;

    Succ = WriteAtOffset(
                hFile,
                StreamInfo->RvaOfException,
                &ExceptionStream,
                StreamInfo->SizeOfException
                );

    return Succ;
}


BOOL
WriteUserStreams(
    IN HANDLE hFile,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PMINIDUMP_USER_STREAM UserStreamArray,
    IN ULONG UserStreamCount
    )
{
    BOOL Succ;
    ULONG i;
    ULONG Offset;


    Succ = TRUE;
    Offset = StreamInfo->RvaOfUserStreams;

    for (i = 0; i < UserStreamCount; i++) {

        Succ = WriteAtOffset(
                    hFile,
                    Offset,
                    UserStreamArray[i].Buffer,
                    UserStreamArray[i].BufferSize
                    );

        if ( !Succ ) {
            break;
        }

        Offset += UserStreamArray[ i ].BufferSize;
    }

    return Succ;
}

BOOL
WriteMemoryListHeader(
    IN HANDLE hFile,
    IN PMINIDUMP_STREAM_INFO StreamInfo
    )
{
    BOOL Succ;
    ULONG Size;
    ULONG Count;
    MINIDUMP_MEMORY_LIST MemoryList;

    ASSERT ( StreamInfo->RvaOfMemoryDescriptors == StreamInfo->RvaForCurMemoryDescriptor );

    Size = StreamInfo->SizeOfMemoryDescriptors;
    Size -= sizeof (MINIDUMP_MEMORY_LIST);
    ASSERT ( (Size % sizeof (MINIDUMP_MEMORY_DESCRIPTOR)) == 0);
    Count = Size / sizeof (MINIDUMP_MEMORY_DESCRIPTOR);

    MemoryList.NumberOfMemoryRanges = Count;

    Succ = WriteAtOffset (
                    hFile,
                    StreamInfo->RvaOfMemoryDescriptors,
                    &MemoryList,
                    sizeof (MemoryList)
                    );

    if (Succ) {
        StreamInfo->RvaForCurMemoryDescriptor += sizeof (MemoryList);
    }

    return Succ;
}

#define FULL_MEMORY_BUFFER 65536

BOOL
WriteFullMemory(
    IN HANDLE ProcessHandle,
    IN HANDLE hFile,
    IN PMINIDUMP_STREAM_INFO StreamInfo
    )
{
    PVOID Buffer;
    BOOL Succ;
    ULONG_PTR Offset;
    MEMORY_BASIC_INFORMATION Info;
    MINIDUMP_MEMORY64_LIST List;
    MINIDUMP_MEMORY_DESCRIPTOR64 Desc;
    ULONG Done;

    //
    // Pick up the current offset for the RVA as
    // variable data may have been written in previously.
    //

    if ((Done = SetFilePointer(hFile, 0, NULL, FILE_CURRENT)) ==
        INVALID_SET_FILE_POINTER) {
        return FALSE;
    }

    StreamInfo->RvaOfMemoryDescriptors = Done;
    
    Buffer = AllocMemory(FULL_MEMORY_BUFFER);
    if (Buffer == NULL) {
        return FALSE;
    }

    Succ = FALSE;

    //
    // First pass: count and write descriptors.
    // Only accessible, available memory is saved.
    //

    // Write placeholder list header.
    ZeroMemory(&List, sizeof(List));
    if (!WriteFile(hFile, &List, sizeof(List), &Done, NULL) ||
        Done != sizeof(List)) {
        goto Exit;
    }
    
    Offset = 0;
    for (;;) {
        if (!VirtualQueryEx(ProcessHandle, (LPCVOID)Offset,
                            &Info, sizeof(Info))) {
            break;
        }

        Offset = (ULONG_PTR)Info.BaseAddress + Info.RegionSize;
            
        if (((Info.Protect & PAGE_GUARD) ||
             (Info.Protect & PAGE_NOACCESS) ||
             (Info.State & MEM_FREE) ||
             (Info.State & MEM_RESERVE))) {
            continue;
        }

        // The size of a stream is a ULONG32 so we can't store
        // any more than that.
        if (List.NumberOfMemoryRanges ==
            (_UI32_MAX - sizeof(MINIDUMP_MEMORY64_LIST)) / sizeof(Desc)) {
            goto Exit;
        }

        List.NumberOfMemoryRanges++;
        
        Desc.StartOfMemoryRange = SIGN_EXTEND((ULONG_PTR)Info.BaseAddress);
        Desc.DataSize = Info.RegionSize;
        if (!WriteFile(hFile, &Desc, sizeof(Desc), &Done, NULL) ||
            Done != sizeof(Desc)) {
            goto Exit;
        }
    }

    StreamInfo->SizeOfMemoryDescriptors +=
        (ULONG)List.NumberOfMemoryRanges * sizeof(Desc);
    List.BaseRva = (RVA64)StreamInfo->RvaOfMemoryDescriptors +
        StreamInfo->SizeOfMemoryDescriptors;
    
    //
    // Second pass: write memory contents.
    //

    Offset = 0;
    for (;;) {
        ULONG_PTR ChunkOffset;
        SIZE_T ChunkSize;
        SIZE_T MemDone;

        if (!VirtualQueryEx(ProcessHandle, (LPCVOID)Offset,
                            &Info, sizeof(Info))) {
            break;
        }

        Offset = (ULONG_PTR)Info.BaseAddress + Info.RegionSize;
            
        if (((Info.Protect & PAGE_GUARD) ||
             (Info.Protect & PAGE_NOACCESS) ||
             (Info.State & MEM_FREE) ||
             (Info.State & MEM_RESERVE))) {
            continue;
        }

        ChunkOffset = (ULONG_PTR)Info.BaseAddress;
        while (Info.RegionSize > 0) {
            if (Info.RegionSize > FULL_MEMORY_BUFFER) {
                ChunkSize = FULL_MEMORY_BUFFER;
            } else {
                ChunkSize = Info.RegionSize;
            }

            if (!ReadProcessMemory(ProcessHandle, (LPVOID)ChunkOffset,
                                   Buffer, ChunkSize, &MemDone) ||
                MemDone != ChunkSize ||
                !WriteFile(hFile, Buffer, (DWORD)ChunkSize, &Done, NULL) ||
                Done != ChunkSize) {
                goto Exit;
            }

            ChunkOffset += ChunkSize;
            Info.RegionSize -= ChunkSize;
        }
    }

    // Write correct list header.
    if (!WriteAtOffset(hFile, StreamInfo->RvaOfMemoryDescriptors,
                       &List, sizeof(List))) {
        goto Exit;
    }
    
    Succ = TRUE;
    
 Exit:
    FreeMemory(Buffer);
    return Succ;
}

BOOL
WriteDumpData(
    IN HANDLE hFile,
    IN ULONG DumpType,
    IN PMINIDUMP_STREAM_INFO StreamInfo,
    IN PINTERNAL_PROCESS Process,
    IN CONST PEXCEPTION_INFO ExceptionInfo,
    IN CONST PMINIDUMP_USER_STREAM UserStreamArray,
    IN ULONG UserStreamCount
    )
{
    BOOL Succ;

    Succ = WriteHeader ( hFile, DumpType, StreamInfo );

    if ( !Succ ) {
        return FALSE;
    }

    Succ = WriteSystemInfo ( hFile, StreamInfo );

    if ( !Succ ) {
        return FALSE;
    }

    if (!WriteMiscInfo(hFile, StreamInfo, Process)) {
        return FALSE;
    }

    //
    // Optionally, write the exception to the file.
    //

    Succ = WriteException ( hFile, StreamInfo, ExceptionInfo );

    if ( !Succ ) {
        return FALSE;
    }

    if (!(DumpType & MiniDumpWithFullMemory)) {
        //
        // WriteMemoryList initializes the memory list header (count).
        // The actual writing of the entries is done by WriteThreadList
        // and WriteModuleList.
        //

        Succ = WriteMemoryListHeader ( hFile, StreamInfo );

        if ( !Succ ) {
            return FALSE;
        }

        if (!WriteMemoryBlocks(hFile, StreamInfo, Process)) {
            return FALSE;
        }
    }

    //
    // Write the threads list. This will also write the contexts, and
    // stacks for each thread.
    //

    Succ = WriteThreadList ( hFile, StreamInfo, Process, DumpType );

    if ( !Succ ) {
        return FALSE;
    }

    //
    // Write the module list. This will also write the debug information and
    // module name to the file.
    //

    Succ = WriteModuleList ( hFile, StreamInfo, Process );

    if ( !Succ ) {
        return FALSE;
    }

    //
    // Write the unloaded module list.
    //

    Succ = WriteUnloadedModuleList ( hFile, StreamInfo, Process );

    if ( !Succ ) {
        return FALSE;
    }

    //
    // Write the function table list.
    //

    Succ = WriteFunctionTableList ( hFile, StreamInfo, Process );

    if ( !Succ ) {
        return FALSE;
    }


    Succ = WriteUserStreams ( hFile,
                              StreamInfo,
                              UserStreamArray,
                              UserStreamCount
                              );

    if ( !Succ ) {
        return FALSE;
    }


    // Put the file pointer at the end of the dump so
    // we can accumulate write-streamed data.
    if (SetFilePointer(hFile, StreamInfo->RvaOfHandleData, NULL,
                       FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
        return FALSE;
    }
    

    if (DumpType & MiniDumpWithHandleData) {
        Succ = GenWriteHandleData(Process->ProcessHandle, hFile, StreamInfo);
        if ( !Succ ) {
            return FALSE;
        }
    }

    
    if (DumpType & MiniDumpWithFullMemory) {
        Succ = WriteFullMemory(Process->ProcessHandle, hFile, StreamInfo);
        if ( !Succ ) {
            return FALSE;
        }
    }

    
    if (SetFilePointer(hFile, StreamInfo->RvaOfDirectory, NULL,
                       FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
        return FALSE;
    }

    Succ = WriteDirectoryTable ( hFile,
                                 DumpType,
                                 StreamInfo,
                                 Process,
                                 UserStreamArray,
                                 UserStreamCount
                                 );

    if ( !Succ ) {
        return FALSE;
    }

    return TRUE;
}


BOOL
MarshalExceptionPointers(
    IN HANDLE hProcess,
    IN PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
    IN OUT PEXCEPTION_POINTERS ExceptionPointers
    )
{
    BOOL Succ;
    SIZE_T BytesRead;
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ExceptionContext;
    EXCEPTION_POINTERS ExceptionPointersBuffer;

    //
    // Is there any marshaling work to be done.
    //

    if (ExceptionParam == NULL) {
        return TRUE;
    }

    ExceptionRecord = (PEXCEPTION_RECORD) AllocMemory ( sizeof (EXCEPTION_RECORD) );
    ExceptionContext = (PCONTEXT) AllocMemory ( sizeof (CONTEXT) );

    if (ExceptionRecord == NULL ||
        ExceptionContext == NULL) {

        Succ = FALSE;
        goto Exit;
    }

    Succ = ReadProcessMemory (
                hProcess,
                ExceptionParam->ExceptionPointers,
                &ExceptionPointersBuffer,
                sizeof (ExceptionPointersBuffer),
                &BytesRead
                );

    if ( !Succ || BytesRead != sizeof (ExceptionPointersBuffer) ) {
        Succ = FALSE;
        goto Exit;
    }

    Succ = ReadProcessMemory (
                hProcess,
                ExceptionPointersBuffer.ExceptionRecord,
                ExceptionRecord,
                sizeof (*ExceptionRecord),
                &BytesRead
                );

    if ( !Succ || BytesRead != sizeof (*ExceptionRecord) ) {
        Succ = FALSE;
        goto Exit;
    }


#if defined (i386)

    {
        OSVERSIONINFO OSVersionInfo;

        OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVersionInfo);
        GetVersionEx(&OSVersionInfo);

        // If this is Win9x don't read the Extended Registers

        if ( OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ) {
            
            Succ = ReadProcessMemory (hProcess,
                                      ExceptionPointersBuffer.ContextRecord,
                                      ExceptionContext,
                                      FIELD_OFFSET( CONTEXT, ExtendedRegisters),
                                      &BytesRead);

            if ( !Succ || BytesRead != FIELD_OFFSET( CONTEXT, ExtendedRegisters) ) {
                Succ = FALSE;
                goto Exit;
            }

        } else {

            Succ = ReadProcessMemory (
                                      hProcess,
                                      ExceptionPointersBuffer.ContextRecord,
                                      ExceptionContext,
                                      sizeof(CONTEXT),
                                      &BytesRead
                                      );

            if ( !Succ || BytesRead != sizeof (CONTEXT) ) {
                Succ = FALSE;
                goto Exit;
            }

        }
    }

#else

    Succ = ReadProcessMemory (
            hProcess,
            ExceptionPointersBuffer.ContextRecord,
            ExceptionContext,
            sizeof(CONTEXT),
            &BytesRead
            );
    if ( !Succ || BytesRead != sizeof (CONTEXT) ) {
        Succ = FALSE;
        goto Exit;
    }

#endif

    ExceptionPointers->ExceptionRecord = ExceptionRecord;
    ExceptionPointers->ContextRecord = ExceptionContext;

Exit:

    if ( !Succ ) {

        FreeMemory ( ExceptionRecord );
        ExceptionRecord = NULL;
        FreeMemory ( ExceptionContext );
        ExceptionContext = NULL;
    }

    return Succ;
}

VOID
FreeExceptionPointers(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )
{
    if ( ExceptionPointers ) {
        FreeMemory ( ExceptionPointers->ExceptionRecord );
        FreeMemory ( ExceptionPointers->ContextRecord );
    }
}


BOOL
GetExceptionInfo(
    IN HANDLE hProcess,
    IN PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
    OUT PEXCEPTION_INFO * ExceptionInfoBuffer
    )
{
    BOOL Succ;
    PEXCEPTION_INFO ExceptionInfo;

    if ( ExceptionParam == NULL ) {
        *ExceptionInfoBuffer = NULL;
        return TRUE;
    }

    ExceptionInfo = AllocMemory ( sizeof (EXCEPTION_INFO) );
    if ( ExceptionInfo == NULL ) {
        *ExceptionInfoBuffer = NULL;
        return FALSE;
    }

    if ( !ExceptionParam->ClientPointers ) {

        ExceptionInfo->ExceptionPointers.ExceptionRecord =
                ExceptionParam->ExceptionPointers->ExceptionRecord;

        ExceptionInfo->ExceptionPointers.ContextRecord =
                ExceptionParam->ExceptionPointers->ContextRecord;

        ExceptionInfo->FreeExceptionPointers = FALSE;
        Succ = TRUE;

    } else {

        Succ = MarshalExceptionPointers (
                        hProcess,
                        ExceptionParam,
                        &ExceptionInfo->ExceptionPointers
                        );

        ExceptionInfo->FreeExceptionPointers = TRUE;
    }

    ExceptionInfo->ThreadId = ExceptionParam->ThreadId;

    if ( !Succ ) {
        FreeMemory (ExceptionInfo);
        ExceptionInfo = NULL;
        *ExceptionInfoBuffer = NULL;
    } else {
        *ExceptionInfoBuffer = ExceptionInfo;
    }

    return Succ;
}

VOID
FreeExceptionInfo(
    IN PEXCEPTION_INFO ExceptionInfo
    )
{
    if ( ExceptionInfo && ExceptionInfo->FreeExceptionPointers ) {
        FreeExceptionPointers ( &ExceptionInfo->ExceptionPointers );
        FreeMemory ( ExceptionInfo );
    }
}


BOOL
WINAPI
MiniDumpWriteDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    )
{
    BOOL Succ;
    PINTERNAL_PROCESS Process;
    MINIDUMP_STREAM_INFO StreamInfo;
    PEXCEPTION_INFO ExceptionInfo;
    PMINIDUMP_USER_STREAM UserStreamArray;
    ULONG UserStreamCount;
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackVoidParam;


    if ((DumpType & ~(MiniDumpNormal |
                      MiniDumpWithDataSegs |
                      MiniDumpWithFullMemory |
                      MiniDumpWithHandleData |
                      MiniDumpFilterMemory |
                      MiniDumpScanMemory |
                      MiniDumpWithUnloadedModules |
                      MiniDumpWithIndirectlyReferencedMemory |
                      MiniDumpFilterModulePaths |
                      MiniDumpWithProcessThreadData |
                      MiniDumpWithPrivateReadWriteMemory))) {

        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Full memory by definition includes data segments,
    // so turn off data segments if full memory is requested.
    if (DumpType & MiniDumpWithFullMemory) {
        DumpType &= ~(MiniDumpWithDataSegs | MiniDumpFilterMemory |
                      MiniDumpScanMemory |
                      MiniDumpWithIndirectlyReferencedMemory |
                      MiniDumpWithProcessThreadData |
                      MiniDumpWithPrivateReadWriteMemory);
    }
    
    //
    // Initialization
    //

    Process = NULL;
    UserStreamArray = NULL;
    UserStreamCount = 0;
    CallbackRoutine = NULL;
    CallbackVoidParam = NULL;

    if (!MiniDumpSetup ()) {
        return FALSE;
    }

#if !defined (_DBGHELP_SOURCE_)
    //
    // Try to call dbghelp.dll do to the work.
    // If that fails, then we use the code in this lib.
    //

    if (xxxWriteDump(hProcess, ProcessId, hFile, DumpType, ExceptionParam, UserStreamParam, CallbackParam)) {
        return TRUE;
    }

#endif

    GenClearAccumulatedStatus();

    //
    // Marshal exception pointers into our process space if necessary.
    //

    Succ = GetExceptionInfo (
                    hProcess,
                    ExceptionParam,
                    &ExceptionInfo
                    );

    if ( !Succ ) {
        goto Exit;
    }

    if ( UserStreamParam ) {
        UserStreamArray = UserStreamParam->UserStreamArray;
        UserStreamCount = UserStreamParam->UserStreamCount;
    }

    if ( CallbackParam ) {
        CallbackRoutine = CallbackParam->CallbackRoutine;
        CallbackVoidParam = CallbackParam->CallbackParam;
    }

    //
    // Gather information about the process we are dumping.
    //

    Succ = GenGetProcessInfo (hProcess, ProcessId, DumpType,
                              CallbackRoutine, CallbackVoidParam,
                              &Process);

    if ( !Succ ) {
        goto Exit;
    }

    //
    // Process gathered information.
    //

    Succ = PostProcessInfo(DumpType, Process);
    if (!Succ) {
        goto Exit;
    }
    
    //
    // Execute user callbacks to filter out unwanted data.
    //

    Succ = ExecuteCallbacks ( hProcess,
                              ProcessId,
                              Process,
                              CallbackRoutine,
                              CallbackVoidParam
                              );

    if ( !Succ ) {
        goto Exit;
    }

    //
    // Pass 1: Fill in the StreamInfo structure.
    //

    Succ = CalculateStreamInfo ( Process,
                                 DumpType,
                                 &StreamInfo,
                                 ( ExceptionInfo != NULL ) ? TRUE : FALSE,
                                 UserStreamArray,
                                 UserStreamCount
                                 );

    if ( !Succ ) {
        goto Exit;
    }

    //
    // Pass 2: Write the minidump data to disk.
    //

    Succ = WriteDumpData ( hFile,
                           DumpType,
                           &StreamInfo,
                           Process,
                           ExceptionInfo,
                           UserStreamArray,
                           UserStreamCount
                           );

Exit:

    //
    // Free up any memory marshalled for the exception pointers.
    //

    FreeExceptionInfo ( ExceptionInfo );

    //
    // Free the process objects.
    //

    if ( Process ) {
        GenFreeProcessObject ( Process );
        Process = NULL;
    }

    MiniDumpFree ();

    return Succ;
}

BOOL
WINAPI
MiniDumpReadDumpStream(
    IN PVOID Base,
    ULONG StreamNumber,
    OUT PMINIDUMP_DIRECTORY * Dir, OPTIONAL
    OUT PVOID * Stream, OPTIONAL
    OUT ULONG * StreamSize OPTIONAL
    )
{
    ULONG i;
    BOOL Found;
    PMINIDUMP_DIRECTORY Dirs;
    PMINIDUMP_HEADER Header;

    if (!MiniDumpSetup ()) {
        return FALSE;
    }

#if !defined (_DBGHELP_SOURCE_)
    //
    // Try to call dbghelp.dll do to the work.
    // If that fails, then we use the code in this lib.
    //

    if (xxxReadDumpStream(Base, StreamNumber, Dir, Stream, StreamSize)) {
        return TRUE;
    }

#endif

    //
    // Initialization
    //

    Found = FALSE;
    Header = (PMINIDUMP_HEADER) Base;

    if ( Header->Signature != MINIDUMP_SIGNATURE ||
         (Header->Version & 0xffff) != MINIDUMP_VERSION ) {

        //
        // Invalid Minidump file.
        //

        return FALSE;
    }

    Dirs = (PMINIDUMP_DIRECTORY) RVA_TO_ADDR (Header, Header->StreamDirectoryRva);

    for (i = 0; i < Header->NumberOfStreams; i++) {
        if (Dirs [i].StreamType == StreamNumber) {
            Found = TRUE;
            break;
        }
    }

    if ( !Found ) {
        return FALSE;
    }

    if ( Dir ) {
        *Dir = &Dirs [i];
    }

    if ( Stream ) {
        *Stream = RVA_TO_ADDR (Base, Dirs [i].Location.Rva);
    }

    if ( StreamSize ) {
        *StreamSize = Dirs[i].Location.DataSize;
    }

    return TRUE;
}




#if 0

    if (!Succ || BytesWritten != SizeOfRegion) {
        return FALSE;
    }


    //
    // Then update the memory descriptor in the MEMORY_LIST region.
    //

    Descriptor.StartOfMemoryRange = StartOfRegion;
    Descriptor.Memory.DataSize = SizeOfRegion;
    Descriptor.Memory.Rva = DataRva;

    Succ = SetFilePointer (
                    FileHandle,
                    ListRva,
                    NULL,
                    FILE_BEGIN
                    ) != INVALID_SET_FILE_POINTER;

    if ( !Succ ) {
        return FALSE;
    }

    Succ = WriteFile (
                    FileHandle,
                    &Descriptor,
                    SizeOfMemoryDescriptor,
                    &BytesWritten,
                    NULL
                    );

    if ( !Succ || BytesWritten != SizeOfMemoryDescriptor) {
        return FALSE;
    }

    //
    // Update both the List Rva and the Data Rva and return the
    // the Data Rva.
    //

    StreamInfo->RvaForCurMemoryDescriptor += SizeOfMemoryDescriptor;
    StreamInfo->RvaForCurMemoryData += SizeOfRegion;
    *MemoryDataRva = DataRva;

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\minidump.h ===
/*++ 

Copyright (c) 1990-2002  Microsoft Corporation

Module Name:

    minidump.h

Abstract:

    This module defines the prototypes and constants required for the image
    help routines.

    Contains debugging support routines that are redistributable.

Revision History:

--*/

#if _MSC_VER > 1020
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


#include <pshpack4.h>

#pragma warning(disable:4200) // Zero length array


#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef unsigned char UINT8;
typedef unsigned short UINT16;
typedef DWORD RVA;
typedef ULONG64 RVA64;

C_ASSERT (sizeof (UINT8) == 1);
C_ASSERT (sizeof (UINT16) == 2);

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR {
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64 {
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR {
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64 {
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER {
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to 
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY {
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING {
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE {

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,
    FunctionTableStream         = 13,
    UnloadedModuleListStream    = 14,
    MiscInfoStream              = 15,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
// 
    
typedef struct _MINIDUMP_SYSTEM_INFO {

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //
    
    UINT16 ProcessorArchitecture;
    UINT16 ProcessorLevel;
    UINT16 ProcessorRevision;

    union {
        UINT16 Reserved0;
        struct {
            UINT8 NumberOfProcessors;
            UINT8 ProductType;
        };
    };

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //
    
    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //
    
    RVA CSDVersionRva;

    union {
        ULONG32 Reserved1;
        struct {
            UINT16 SuiteMask;
            UINT16 Reserved2;
        };
    };

    //
    // CPU information is obtained from one of two places.
    //
    //  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
    //     instruction. You must use the X86 portion of the union for X86
    //     computers.
    //
    //  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
    //     IsProcessorFeatureSupported().
    //
    
    union _CPU_INFORMATION {

        //
        // X86 platforms use CPUID function to obtain processor information.
        //
        
        struct {

            //
            // CPUID Subfunction 0, register EAX (VendorId [0]),
            // EBX (VendorId [1]) and ECX (VendorId [2]).
            //
            
            ULONG32 VendorId [ 3 ];
            
            //
            // CPUID Subfunction 1, register EAX
            //
            
            ULONG32 VersionInformation;

            //
            // CPUID Subfunction 1, register EDX
            //
            
            ULONG32 FeatureInformation;
            

            //
            // CPUID, Subfunction 80000001, register EBX. This will only
            // be obtained if the vendor id is "AuthenticAMD".
            //
            
            ULONG32 AMDExtendedCpuFeatures;
    
        } X86CpuInfo;

        //
        // Non-x86 platforms use processor feature flags.
        //
        
        struct {

            ULONG64 ProcessorFeatures [ 2 ];
            
        } OtherCpuInfo;
        
    } Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;

typedef union _CPU_INFORMATION CPU_INFORMATION, *PCPU_INFORMATION;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this 
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT (sizeof ( ((LPPROCESS_INFORMATION)0)->dwThreadId ) == 4);

typedef struct _MINIDUMP_THREAD {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION  {
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM {
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE {
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;   


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST {
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST {
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST {
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION {
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;


//
// Support for capturing system handle state at the time of the dump.
//

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR {
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 NumberOfDescriptors;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;


//
// Support for capturing dynamic function table state at the time of the dump.
//

typedef struct _MINIDUMP_FUNCTION_TABLE_DESCRIPTOR {
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG32 EntryCount;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_DESCRIPTOR, *PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR;

typedef struct _MINIDUMP_FUNCTION_TABLE_STREAM {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 SizeOfNativeDescriptor;
    ULONG32 SizeOfFunctionEntry;
    ULONG32 NumberOfDescriptors;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_STREAM, *PMINIDUMP_FUNCTION_TABLE_STREAM;


//
// The MINIDUMP_UNLOADED_MODULE contains information about a
// a specific module that was previously loaded but no
// longer is.  This can help with diagnosing problems where
// callers attempt to call code that is no longer loaded.
//

typedef struct _MINIDUMP_UNLOADED_MODULE {
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
} MINIDUMP_UNLOADED_MODULE, *PMINIDUMP_UNLOADED_MODULE;


//
// The minidump unloaded module list is a container for unloaded modules.
//

typedef struct _MINIDUMP_UNLOADED_MODULE_LIST {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
} MINIDUMP_UNLOADED_MODULE_LIST, *PMINIDUMP_UNLOADED_MODULE_LIST;


//
// The miscellaneous information stream contains a variety
// of small pieces of information.  A member is valid if
// it's within the available size and its corresponding
// bit is set.
//

#define MINIDUMP_MISC1_PROCESS_ID    0x00000001
#define MINIDUMP_MISC1_PROCESS_TIMES 0x00000002

typedef struct _MINIDUMP_MISC_INFO {
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
} MINIDUMP_MISC_INFO, *PMINIDUMP_MISC_INFO;


//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD {
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM {
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION {
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE {
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback,
    IncludeThreadCallback,
    IncludeModuleCallback,
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_THREAD_CALLBACK {
    ULONG ThreadId;
} MINIDUMP_INCLUDE_THREAD_CALLBACK, *PMINIDUMP_INCLUDE_THREAD_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS {
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010,
    ThreadWriteThreadData        = 0x0020,
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK {
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord; 
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_MODULE_CALLBACK {
    ULONG64 BaseOfImage;
} MINIDUMP_INCLUDE_MODULE_CALLBACK, *PMINIDUMP_INCLUDE_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS {
    ModuleWriteModule        = 0x0001,
    ModuleWriteDataSeg       = 0x0002,
    ModuleWriteMiscRecord    = 0x0004,
    ModuleWriteCvRecord      = 0x0008,
    ModuleReferencedByMemory = 0x0010
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_CALLBACK_INPUT {
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union {
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
        MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
        MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT {
    union {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;

        
//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//
// Stack and backing store memory can be filtered to remove
// data unnecessary for stack walking.  This can improve
// compression of stacks and also deletes data that may
// be private and should not be stored in a dump.
// Memory can also be scanned to see what modules are
// referenced by stack and backing store memory to allow
// omission of other modules to reduce dump size.
// In either of these modes the ModuleReferencedByMemory flag
// is set for all modules referenced before the base
// module callbacks occur.
//
// On some operating systems a list of modules that were
// recently unloaded is kept in addition to the currently
// loaded module list.  This information can be saved in
// the dump if desired.
//
// Stack and backing store memory can be scanned for referenced
// pages in order to pick up data referenced by locals or other
// stack memory.  This can increase the size of a dump significantly.
//
// Module paths may contain undesired information such as user names
// or other important directory names so they can be stripped.  This
// option reduces the ability to locate the proper image later
// and should only be used in certain situations.
//
// Complete operating system per-process and per-thread information can
// be gathered and stored in the dump.
//
// The virtual address space can be scanned for various types
// of memory to be included in the dump.
//

typedef enum _MINIDUMP_TYPE {
    MiniDumpNormal                         = 0x0000,
    MiniDumpWithDataSegs                   = 0x0001,
    MiniDumpWithFullMemory                 = 0x0002,
    MiniDumpWithHandleData                 = 0x0004,
    MiniDumpFilterMemory                   = 0x0008,
    MiniDumpScanMemory                     = 0x0010,
    MiniDumpWithUnloadedModules            = 0x0020,
    MiniDumpWithIndirectlyReferencedMemory = 0x0040,
    MiniDumpFilterModulePaths              = 0x0080,
    MiniDumpWithProcessThreadData          = 0x0100,
    MiniDumpWithPrivateReadWriteMemory     = 0x0200,
} MINIDUMP_TYPE;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI * MINIDUMP_CALLBACK_ROUTINE) (
    IN PVOID CallbackParam,
    IN CONST PMINIDUMP_CALLBACK_INPUT CallbackInput,
    IN OUT PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
    );

typedef struct _MINIDUMP_CALLBACK_INFORMATION {
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    );

BOOL
WINAPI
MiniDumpReadDumpStream(
    IN PVOID BaseOfDump,
    IN ULONG StreamNumber,
    OUT PMINIDUMP_DIRECTORY * Dir, OPTIONAL
    OUT PVOID * StreamPointer, OPTIONAL
    OUT ULONG * StreamSize OPTIONAL
    );

#include <poppack.h>

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\nt4.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    nt4.h

Abstract:

    NT4 specific routines exported by nt4.c

Author:

    Matthew D Hendel (math) 20-Oct-1999

Revision History:

--*/

#pragma once

#if !defined (_X86_)

#define Nt4OpenThread(_a,_i,_tid) (NULL)
#define Nt4GetProcessInfo(_h,_pid,_dump,_call,_param,_pr) (FALSE)
#define Nt4EnumProcessModules(_h,_m,_cb,_n) (FALSE)
#define Nt4GetModuleFileNameExW(_h,_hm,_f,_s) (0)

#else // X86

HANDLE
WINAPI
Nt4OpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    );

BOOL
Nt4GetProcessInfo(
    IN HANDLE hProcess,
    IN ULONG ProcessId,
    IN ULONG DumpType,
    IN MINIDUMP_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID CallbackParam,
    OUT struct _INTERNAL_PROCESS ** ProcessRet
    );

BOOL
WINAPI
Nt4EnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    );

DWORD
WINAPI
Nt4GetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\mdump.h ===
/*++

Copyright(c) 1999-2002 Microsoft Corporation

Module Name:

    mdump.h

Abstract:

    Private header for minidump user-mode crashdump support.
    
Author:

    Matthew D Hendel (math) 20-Aug-1999

--*/


#pragma once

#include "platform.h"

#define IsFlagSet(_var, _flag) ( ((_var) & (_flag)) != 0 )

#define IsFlagClear(_var, _flag) ( !IsFlagSet(_var, _flag) )


//
// StartOfStack gives the lowest address of the stack. SizeOfStack gives
// the size of the stack. Used together, they will give the memory region
// used by the stack.
//

#define StartOfStack(_thread) ((_thread)->StackEnd)

#define SizeOfStack(_thread) ((ULONG)((_thread)->StackBase - (_thread)->StackEnd)))


// Types of memory regions.
typedef enum
{
    MEMBLOCK_OTHER,
    MEMBLOCK_MERGED,
    MEMBLOCK_STACK,
    MEMBLOCK_STORE,
    MEMBLOCK_DATA_SEG,
    MEMBLOCK_UNWIND_INFO,
    MEMBLOCK_INSTR_WINDOW,
    MEMBLOCK_PEB,
    MEMBLOCK_TEB,
    MEMBLOCK_INDIRECT,
    MEMBLOCK_PRIVATE_RW,
} MEMBLOCK_TYPE;

//
// A VA_RANGE is a range of addresses that represents Size bytes beginning
// at Start.
//

typedef struct _VA_RANGE {
    ULONG64 Start;
    ULONG Size;
    MEMBLOCK_TYPE Type;
    LIST_ENTRY NextLink;
} VA_RANGE, *PVA_RANGE;


//
// INTERNAL_MODULE is the structure minidump uses internally to manage modules.
// A linked list of INTERNAL_MODULE structures are built up when
// GenGetProcessInfo is called.
//
//

typedef struct _INTERNAL_MODULE {

    //
    // File handle to the image.
    //
    
    HANDLE FileHandle;

    //
    // Base address, size, CheckSum, and TimeDateStamp for the image.
    //
    
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;

    //
    // Version information for the image.
    //
    
    VS_FIXEDFILEINFO VersionInfo;


    //
    // Buffer and size containing NB10 record for given module.
    //
    
    PVOID CvRecord;
    ULONG SizeOfCvRecord;

    //
    // Buffer and size of MISC debug record. We only get this with
    // images that have been split.
    //

    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;

    //
    // Full path to the image.
    //
    
    WCHAR FullPath [ MAX_PATH + 1];
    // Portion of full path to write in the module list.  This
    // allows paths to be filtered out for privacy reasons.
    PWSTR SavePath;

    //
    // What sections of the module does the client want written.
    //
    
    ULONG WriteFlags;
    
    //
    // Next image pointer.
    //

    LIST_ENTRY ModulesLink;

} INTERNAL_MODULE, *PINTERNAL_MODULE;


//
// INTERNAL_UNLOADED_MODULE is the structure minidump uses
// internally to manage unloaded modules.
// A linked list of INTERNAL_UNLOADED_MODULE structures are built up when
// GenGetProcessInfo is called.
//
//

typedef struct _INTERNAL_UNLOADED_MODULE {

    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;

    //
    // As much of the path to the image as can be recovered.
    //
    
    WCHAR Path[MAX_PATH + 1];

    //
    // Next image pointer.
    //

    LIST_ENTRY ModulesLink;

} INTERNAL_UNLOADED_MODULE, *PINTERNAL_UNLOADED_MODULE;



//
// INTERNAL_THREAD is the structure the minidump uses internally to
// manage threads. A list of INTERNAL_THREAD structures is built when
// GenGetProcessInfo is called.
//

typedef struct _INTERNAL_THREAD {

    //
    // The Win32 thread id of the thread an an open handle for the
    // thread.
    //
    
    ULONG ThreadId;
    HANDLE ThreadHandle;

    //
    // Suspend count, priority, priority class for the thread.
    //
    
    ULONG SuspendCount;
    ULONG PriorityClass;
    ULONG Priority;

    //
    // Thread TEB, Context and Size of Context.
    //
    
    ULONG64 Teb;
    ULONG SizeOfTeb;
    CONTEXT Context;
    ULONG SizeOfContext;

    //
    // Stack variables. Remember, the stack grows down, so StackBase is
    // the highest stack address and StackEnd is the lowest.
    //
    
    ULONG64 StackBase;
    ULONG64 StackEnd;

    //
    // Backing store variables.
    //

    ULONG64 BackingStoreBase;
    ULONG BackingStoreSize;

    //
    // What sections of the module we should actually write to the file.
    //
    
    ULONG WriteFlags;
    
    //
    // Link to next thread.
    //
    
    LIST_ENTRY ThreadsLink;

} INTERNAL_THREAD, *PINTERNAL_THREAD;

//
// INTERNAL_FUNCTION_TABLE is the structure minidump uses
// internally to manage function tables.
// A linked list of INTERNAL_FUNCTION_TABLE structures is built up when
// GenGetProcessInfo is called.
//

typedef struct _INTERNAL_FUNCTION_TABLE {

    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG EntryCount;
    DYNAMIC_FUNCTION_TABLE RawTable;
    PVOID RawEntries;

    LIST_ENTRY TableLink;

} INTERNAL_FUNCTION_TABLE, *PINTERNAL_FUNCTION_TABLE;


typedef struct _INTERNAL_PROCESS {

    //
    // The process id for the process.
    //

    ULONG ProcessId;

    //
    // Process data.
    //

    ULONG64 Peb;
    ULONG SizeOfPeb;

    //
    // Process run time information.
    //

    BOOL TimesValid;
    ULONG CreateTime;
    ULONG UserTime;
    ULONG KernelTime;

    //
    // An open handle to the process with read permissions.
    //
    
    HANDLE ProcessHandle;

    //
    // Number of threads for the process.
    //
    
    ULONG NumberOfThreads;
    ULONG NumberOfThreadsToWrite;
    ULONG MaxStackOrStoreSize;

    //
    // Number of modules for the process.
    //
    
    ULONG NumberOfModules;
    ULONG NumberOfModulesToWrite;

    //
    // Number of unloaded modules for the process.
    //
    
    ULONG NumberOfUnloadedModules;

    //
    // Number of function tables for the process.
    //
    
    ULONG NumberOfFunctionTables;

    //
    // Thread, module and function table lists for the process.
    //
    
    LIST_ENTRY ThreadList;
    LIST_ENTRY ModuleList;
    LIST_ENTRY UnloadedModuleList;
    LIST_ENTRY FunctionTableList;

    //
    // List of memory blocks to include for the process.
    //

    LIST_ENTRY MemoryBlocks;
    ULONG NumberOfMemoryBlocks;
    ULONG SizeOfMemoryBlocks;

} INTERNAL_PROCESS, *PINTERNAL_PROCESS;


//
// The visible streams are: (1) machine info, (2) exception, (3) thread list,
// (4) module list (5) memory list (6) misc info.
// We also add two extra for post-processing tools that want to add data later.
//

#define NUMBER_OF_STREAMS   (8)

//
// MINIDUMP_STREAM_INFO is the structure used by the minidump to manage
// it's internal data streams.
//

typedef struct _MINIDUMP_STREAM_INFO {

    //
    // How many streams we have.
    //
    
    ULONG NumberOfStreams;
    
    //
    // Reserved space for header.
    //
    
    ULONG RvaOfHeader;
    ULONG SizeOfHeader;

    //
    // Reserved space for directory.
    //

    ULONG RvaOfDirectory;
    ULONG SizeOfDirectory;

    //
    // Reserved space for system info.
    //

    ULONG RvaOfSystemInfo;
    ULONG SizeOfSystemInfo;
    ULONG VersionStringLength;

    //
    // Reserved space for misc info.
    //

    ULONG RvaOfMiscInfo;

    //
    // Reserved space for exception list.
    //
    
    ULONG RvaOfException;
    ULONG SizeOfException;

    //
    // Reserved space for thread list.
    //
    
    ULONG RvaOfThreadList;
    ULONG SizeOfThreadList;
    ULONG RvaForCurThread;
    ULONG ThreadStructSize;

    //
    // Reserved space for module list.
    //
    
    ULONG RvaOfModuleList;
    ULONG SizeOfModuleList;
    ULONG RvaForCurModule;

    //
    // Reserved space for unloaded module list.
    //
    
    ULONG RvaOfUnloadedModuleList;
    ULONG SizeOfUnloadedModuleList;
    ULONG RvaForCurUnloadedModule;

    //
    // Reserved space for function table list.
    //
    
    ULONG RvaOfFunctionTableList;
    ULONG SizeOfFunctionTableList;

    //
    // Reserved space for memory descriptors.
    //
    
    ULONG RvaOfMemoryDescriptors;
    ULONG SizeOfMemoryDescriptors;
    ULONG RvaForCurMemoryDescriptor;

    //
    // Reserved space for actual memory data.
    //
    
    ULONG RvaOfMemoryData;
    ULONG SizeOfMemoryData;
    ULONG RvaForCurMemoryData;

    //
    // Reserved space for strings.
    //
    
    ULONG RvaOfStringPool;
    ULONG SizeOfStringPool;
    ULONG RvaForCurString;

    //
    // Reserved space for other data like contexts, debug info records,
    // etc.
    //
    
    ULONG RvaOfOther;
    ULONG SizeOfOther;
    ULONG RvaForCurOther;

    //
    // Reserved space for user streams.
    //
    
    ULONG RvaOfUserStreams;
    ULONG SizeOfUserStreams;

    //
    // Reserved space for handle data.
    //

    ULONG RvaOfHandleData;
    ULONG SizeOfHandleData;

} MINIDUMP_STREAM_INFO, *PMINIDUMP_STREAM_INFO;


typedef struct _EXCEPTION_INFO {
    DWORD ThreadId;
    EXCEPTION_POINTERS ExceptionPointers;
    BOOL FreeExceptionPointers;
} EXCEPTION_INFO, *PEXCEPTION_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\nt4.c ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    nt4.c

Abstract:

    NT 4 specific routines.

    The following routine are exported from this file:

        o Nt4OpenThread

        o Nt4GetProcessInfo

        o Nt4EnumProcessModules

        o Nt4GetModuleFileNameExW

Author:

    Matthew D Hendel (math) 10-Sept-1999

Revision History:


Environment:

    NT 4.0 only.
    
--*/

#include "pch.h"

#include "ntx.h"
#include "nt4.h"
#include "nt4p.h"
#include "impl.h"

BOOL
WINAPI
Nt4EnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    );


HANDLE
WINAPI
Nt4OpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    )
{
    NTSTATUS Status;
    NT4_OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    NT4_CLIENT_ID ClientId;

    ClientId.UniqueThread = (HANDLE)LongToHandle(dwThreadId);
    ClientId.UniqueProcess = (HANDLE)NULL;

    Nt4InitializeObjectAttributes(
        &Obja,
        NULL,
        (bInheritHandle ? NT4_OBJ_INHERIT : 0),
        NULL,
        NULL
        );

    Status = NtOpenThread(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess,
                (POBJECT_ATTRIBUTES)&Obja,
                (PCLIENT_ID)&ClientId
                );
    if ( NT_SUCCESS(Status) ) {
        return Handle;
        }
    else {
        return NULL;
        }
}


BOOL
Nt4GetProcessInfo(
    IN HANDLE hProcess,
    IN ULONG ProcessId,
    IN ULONG DumpType,
    IN MINIDUMP_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID CallbackParam,
    OUT PINTERNAL_PROCESS * ProcessRet
    )
{
    BOOL Succ;
    ULONG i;
    NTSTATUS Status;
    ULONG BufferSize;
    LPVOID Buffer;
    PNT4_SYSTEM_PROCESS_INFORMATION ProcessInfo;
    PNT4_SYSTEM_THREAD_INFORMATION ThreadInfo;
    PINTERNAL_THREAD Thread;
    PINTERNAL_MODULE Module;
    PINTERNAL_PROCESS Process;
    HMODULE Modules [ 512 ];
    ULONG ModulesSize;
    ULONG NumberOfModules;
    ULONG_PTR Next;


    BufferSize = 64 * KBYTE;
    Buffer = NULL;

    do {

        if (Buffer) {
            FreeMemory (Buffer);
        }
        Buffer = AllocMemory ( BufferSize );

        if ( Buffer == NULL) {
            return FALSE;
        }
    
        Status = NtQuerySystemInformation (
                            Nt4SystemProcessInformation,
                            Buffer,
                            BufferSize,
                            NULL
                            );

        if (!NT_SUCCESS (Status) && Status != STATUS_INFO_LENGTH_MISMATCH) {
            GenAccumulateStatus(MDSTATUS_CALL_FAILED);
            return FALSE;
        }

        BufferSize += (8 * KBYTE);

    } while (Status == STATUS_INFO_LENGTH_MISMATCH);

    //
    // Find the correct process in the process list.
    //
    
    ProcessInfo = (PNT4_SYSTEM_PROCESS_INFORMATION) Buffer;

    while (ProcessInfo->NextEntryOffset &&
           ProcessInfo->UniqueProcessId != (HANDLE) ProcessId) {

        Next = ((ULONG_PTR)ProcessInfo + ProcessInfo->NextEntryOffset);
        ProcessInfo = (PNT4_SYSTEM_PROCESS_INFORMATION) Next;
    }

    //
    // Could not find a matching process in the process list.
    //
    
    if (ProcessInfo->UniqueProcessId != (HANDLE) ProcessId) {
        Succ = FALSE;
        GenAccumulateStatus(MDSTATUS_INTERNAL_ERROR);
        goto Exit;
    }

    //
    // Create an INTERNAL_PROCESS object and copy the process information
    // into it.
    //
    
    Process = GenAllocateProcessObject ( hProcess, ProcessId );
                                
    if ( Process == NULL ) {
        return FALSE;
    }

    //
    // Walk the thread list for this process, copying thread information
    // for each thread. Walking the thread list also suspends all the threads
    // in the process. This should be done before walking the module list
    // to minimize the number of race conditions.
    //
    
    ThreadInfo = (PNT4_SYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
    Process->NumberOfThreads = 0;

    for (i = 0; i < ProcessInfo->NumberOfThreads; i++) {

        ULONG WriteFlags;

        if (!GenExecuteIncludeThreadCallback(hProcess,
                                             ProcessId,
                                             DumpType,
                                             (ULONG)ThreadInfo->ClientId.UniqueThread,
                                             CallbackRoutine,
                                             CallbackParam,
                                             &WriteFlags) ||
            IsFlagClear(WriteFlags, ThreadWriteThread)) {
            ThreadInfo++;
            continue;
        }
        
        Status = GenAllocateThreadObject (
                                Process,
                                hProcess,
                                (ULONG) ThreadInfo->ClientId.UniqueThread,
                                DumpType,
                                WriteFlags,
                                &Thread
                                );
        if (FAILED(Status)) {
            Succ = FALSE;
            goto Exit;
        }

        // If Status is S_FALSE it means that the thread
        // couldn't be opened and probably exited before
        // we got to it.  Just continue on.
        if (Status == S_OK) {
            InsertTailList (&Process->ThreadList, &Thread->ThreadsLink);
            Process->NumberOfThreads++;
        }
        
        ThreadInfo++;
    }


    //
    // Get the module information. Use PSAPI since it actually works.
    //

    ModulesSize = 0;
    Succ = Nt4EnumProcessModules (
                    Process->ProcessHandle,
                    Modules,
                    sizeof (Modules),
                    &ModulesSize
                    );
    
    if ( !Succ ) {
        GenAccumulateStatus(MDSTATUS_CALL_FAILED);
        goto Exit;
    }

    NumberOfModules = ModulesSize / sizeof (HMODULE);
    for (i = 0; i < NumberOfModules; i++) {
        ULONG WriteFlags;

        if (!GenExecuteIncludeModuleCallback(hProcess,
                                             ProcessId,
                                             DumpType,
                                             (LONG_PTR)Modules[i],
                                             CallbackRoutine,
                                             CallbackParam,
                                             &WriteFlags) ||
            IsFlagClear(WriteFlags, ModuleWriteModule)) {
            continue;
        }

        Module = NtxAllocateModuleObject (
                                Process,
                                Process->ProcessHandle,
                                (LONG_PTR) Modules [ i ],
                                DumpType,
                                WriteFlags,
				NULL
                                );

        if ( Module == NULL ) {
            Succ = FALSE;
            goto Exit;
        }
        
        InsertTailList (&Process->ModuleList, &Module->ModulesLink);
    }

    Process->NumberOfModules = NumberOfModules;

    Succ = TRUE;

Exit:

    if ( Buffer ) {
        FreeMemory ( Buffer );
        Buffer = NULL;
    }
    
    if ( !Succ && Process != NULL ) {
        GenFreeProcessObject ( Process );
        Process = NULL;
    }
    
    *ProcessRet = Process;

    return Succ;
}
    

//
// From PSAPI
//

BOOL
Nt4FindModule(
    IN HANDLE hProcess,
    IN HMODULE hModule,
    OUT PNT4_LDR_DATA_TABLE_ENTRY LdrEntryData
    )

/*++

Routine Description:

    This function retrieves the loader table entry for the specified
    module.  The function copies the entry into the buffer pointed to
    by the LdrEntryData parameter.

Arguments:

    hProcess - Supplies the target process.

    hModule - Identifies the module whose loader entry is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    LdrEntryData - Returns the requested table entry.

Return Value:

    TRUE if a matching entry was found.

--*/

{
    NT4_PROCESS_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    PNT4_PEB Peb;
    PNT4_PEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;

    Status = NtQueryInformationProcess(
                hProcess,
                Nt4ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        return(FALSE);
    }

    Peb = BasicInfo.PebBaseAddress;


    if ( hModule == NULL ) {
        if (!ReadProcessMemory(hProcess, &Peb->ImageBaseAddress, &hModule, sizeof(hModule), NULL)) {
            return(FALSE);
        }
    }

    //
    // Ldr = Peb->Ldr
    //

    if (!ReadProcessMemory(hProcess, &Peb->Ldr, &Ldr, sizeof(Ldr), NULL)) {
        return (FALSE);
    }

    if (!Ldr) {
        // Ldr might be null (for instance, if the process hasn't started yet).
        SetLastError(ERROR_INVALID_HANDLE);
        return (FALSE);
    }


    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    if (!ReadProcessMemory(hProcess, &LdrHead->Flink, &LdrNext, sizeof(LdrNext), NULL)) {
        return(FALSE);
    }

    while (LdrNext != LdrHead) {

        PNT4_LDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(
                                LdrNext,
                                NT4_LDR_DATA_TABLE_ENTRY,
                                InMemoryOrderLinks);

        if (!ReadProcessMemory(hProcess, LdrEntry, LdrEntryData, sizeof(*LdrEntryData), NULL)) {
            return(FALSE);
        }

        if ((HMODULE) LdrEntryData->DllBase == hModule) {
            return(TRUE);
        }

        LdrNext = LdrEntryData->InMemoryOrderLinks.Flink;
    }

    SetLastError(ERROR_INVALID_HANDLE);
    return(FALSE);
}


BOOL
WINAPI
Nt4EnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    )
{
    NT4_PROCESS_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    PNT4_PEB Peb;
    PNT4_PEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    DWORD chMax;
    DWORD ch;

    Status = NtQueryInformationProcess(
                hProcess,
                Nt4ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        return(FALSE);
        }

    Peb = BasicInfo.PebBaseAddress;

    //
    // Ldr = Peb->Ldr
    //

    if (!ReadProcessMemory(hProcess, &Peb->Ldr, &Ldr, sizeof(Ldr), NULL)) {
        return(FALSE);
        }

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    if (!ReadProcessMemory(hProcess, &LdrHead->Flink, &LdrNext, sizeof(LdrNext), NULL)) {
        return(FALSE);
        }

    chMax = cb / sizeof(HMODULE);
    ch = 0;

    while (LdrNext != LdrHead) {
        PNT4_LDR_DATA_TABLE_ENTRY LdrEntry;
        NT4_LDR_DATA_TABLE_ENTRY LdrEntryData;

        LdrEntry = CONTAINING_RECORD(
                            LdrNext,
                            NT4_LDR_DATA_TABLE_ENTRY,
                            InMemoryOrderLinks);

        if (!ReadProcessMemory(hProcess, LdrEntry, &LdrEntryData, sizeof(LdrEntryData), NULL)) {
            return(FALSE);
            }

        if (ch < chMax) {
            try {
                   lphModule[ch] = (HMODULE) LdrEntryData.DllBase;
                }
            except (EXCEPTION_EXECUTE_HANDLER) {
                return(FALSE);
                }
            }

        ch++;

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
        }

    try {
        *lpcbNeeded = ch * sizeof(HMODULE);
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return(FALSE);
        }

    return(TRUE);
}


DWORD
WINAPI
Nt4GetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    hModule - Identifies the module whose executable file name is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    NT4_LDR_DATA_TABLE_ENTRY LdrEntryData;
    DWORD cb;

    if (!Nt4FindModule(hProcess, hModule, &LdrEntryData)) {
        return(0);
        }

    nSize *= sizeof(WCHAR);

    cb = LdrEntryData.FullDllName.MaximumLength;
    if ( nSize < cb ) {
        cb = nSize;
        }

    if (!ReadProcessMemory(hProcess, LdrEntryData.FullDllName.Buffer, lpFilename, cb, NULL)) {
        return(0);
        }

    if (cb == LdrEntryData.FullDllName.MaximumLength) {
        cb -= sizeof(WCHAR);
        }

    return(cb / sizeof(WCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\nt4p.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    nt4p.h

Abstract:

    NT 4.0 specific headers. The structures and defines in this header were
    stolen from the relevant places in the NT4 header files so certian
    NtXXXX calls will continue to work when called from NT > version 4.

Author:

    Matthew D Hendel (math) 10-Sept-1999

Revision History:


--*/

#pragma once

//
// From ntdef.h
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
typedef LONG NTSTATUS;

typedef struct _NT4_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} NT4_UNICODE_STRING;
typedef NT4_UNICODE_STRING *PNT4_UNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

//
// Valid values for the Attributes field
//

#define NT4_OBJ_INHERIT             0x00000002L
#define NT4_OBJ_PERMANENT           0x00000010L
#define NT4_OBJ_EXCLUSIVE           0x00000020L
#define NT4_OBJ_CASE_INSENSITIVE    0x00000040L
#define NT4_OBJ_OPENIF              0x00000080L
#define NT4_OBJ_OPENLINK            0x00000100L
#define NT4_OBJ_VALID_ATTRIBUTES    0x000001F2L

//
// Object Attributes structure
//

typedef struct _NT4_OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PNT4_UNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} NT4_OBJECT_ATTRIBUTES;
typedef NT4_OBJECT_ATTRIBUTES *PNT4_OBJECT_ATTRIBUTES;

//++
//
// VOID
// InitializeObjectAttributes(
//     OUT PNT4_OBJECT_ATTRIBUTES p,
//     IN PNT4_UNICODE_STRING n,
//     IN ULONG a,
//     IN HANDLE r,
//     IN PSECURITY_DESCRIPTOR s
//     )
//
//--

#define Nt4InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( NT4_OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

//
// From ntpsapi.h
//

typedef struct _NT4_CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} NT4_CLIENT_ID;
typedef NT4_CLIENT_ID *PNT4_CLIENT_ID;


//
// From ntkeapi.h
//

typedef LONG KPRIORITY;
typedef ULONG KAFFINITY;

//
// From ntpsapi.h
//

//
// System Information Classes.
//

typedef enum _NT4_SYSTEM_INFORMATION_CLASS {
    Nt4SystemBasicInformation,
    Nt4SystemProcessorInformation,             // obsolete...delete
    Nt4SystemPerformanceInformation,
    Nt4SystemTimeOfDayInformation,
    Nt4SystemPathInformation,
    Nt4SystemProcessInformation,
    Nt4SystemCallCountInformation,
    Nt4SystemDeviceInformation,
    Nt4SystemProcessorPerformanceInformation,
    Nt4SystemFlagsInformation,
    Nt4SystemCallTimeInformation,
    Nt4SystemModuleInformation,
    Nt4SystemLocksInformation,
    Nt4SystemStackTraceInformation,
    Nt4SystemPagedPoolInformation,
    Nt4SystemNonPagedPoolInformation,
    Nt4SystemHandleInformation,
    Nt4SystemObjectInformation,
    Nt4SystemPageFileInformation,
    Nt4SystemVdmInstemulInformation,
    Nt4SystemVdmBopInformation,
    Nt4SystemFileCacheInformation,
    Nt4SystemPoolTagInformation,
    Nt4SystemInterruptInformation,
    Nt4SystemDpcBehaviorInformation,
    Nt4SystemFullMemoryInformation,
    Nt4SystemLoadGdiDriverInformation,
    Nt4SystemUnloadGdiDriverInformation,
    Nt4SystemTimeAdjustmentInformation,
    Nt4SystemSummaryMemoryInformation,
    Nt4SystemNextEventIdInformation,
    Nt4SystemEventIdsInformation,
    Nt4SystemCrashDumpInformation,
    Nt4SystemExceptionInformation,
    Nt4SystemCrashDumpStateInformation,
    Nt4SystemKernelDebuggerInformation,
    Nt4SystemContextSwitchInformation,
    Nt4SystemRegistryQuotaInformation,
    Nt4SystemExtendServiceTableInformation,
    Nt4SystemPrioritySeperation,
    Nt4SystemPlugPlayBusInformation,
    Nt4SystemDockInformation,
    NT4SystemPowerInformation,
    Nt4SystemProcessorSpeedInformation,
    Nt4SystemCurrentTimeZoneInformation,
    Nt4SystemLookasideInformation
} NT4_SYSTEM_INFORMATION_CLASS;

typedef struct _NT4_SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    NT4_UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SpareUl2;
    ULONG SpareUl3;
    ULONG PeakVirtualSize;
    ULONG VirtualSize;
    ULONG PageFaultCount;
    ULONG PeakWorkingSetSize;
    ULONG WorkingSetSize;
    ULONG QuotaPeakPagedPoolUsage;
    ULONG QuotaPagedPoolUsage;
    ULONG QuotaPeakNonPagedPoolUsage;
    ULONG QuotaNonPagedPoolUsage;
    ULONG PagefileUsage;
    ULONG PeakPagefileUsage;
    ULONG PrivatePageCount;
} NT4_SYSTEM_PROCESS_INFORMATION, *PNT4_SYSTEM_PROCESS_INFORMATION;

typedef struct _NT4_SYSTEM_THREAD_INFORMATION {
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    NT4_CLIENT_ID ClientId;
    KPRIORITY Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} NT4_SYSTEM_THREAD_INFORMATION, *PNT4_SYSTEM_THREAD_INFORMATION;

typedef enum _NT4_PROCESSINFOCLASS {
    Nt4ProcessBasicInformation,
    Nt4ProcessQuotaLimits,
    Nt4ProcessIoCounters,
    Nt4ProcessVmCounters,
    Nt4ProcessTimes,
    Nt4ProcessBasePriority,
    Nt4ProcessRaisePriority,
    Nt4ProcessDebugPort,
    Nt4ProcessExceptionPort,
    Nt4ProcessAccessToken,
    Nt4ProcessLdtInformation,
    Nt4ProcessLdtSize,
    Nt4ProcessDefaultHardErrorMode,
    Nt4ProcessIoPortHandlers,          // Note: this is kernel mode only
    Nt4ProcessPooledUsageAndLimits,
    Nt4ProcessWorkingSetWatch,
    Nt4ProcessUserModeIOPL,
    Nt4ProcessEnableAlignmentFaultFixup,
    Nt4ProcessPriorityClass,
    Nt4ProcessWx86Information,
    Nt4ProcessHandleCount,
    Nt4ProcessAffinityMask,
    Nt4ProcessPriorityBoost,
    MaxNt4ProcessInfoClass
} NT4_PROCESSINFOCLASS;


//
// From ntpsapi.h
//

//
// Process Environment Block
//

typedef struct _NT4_PEB_LDR_DATA {
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
} NT4_PEB_LDR_DATA, *PNT4_PEB_LDR_DATA;

#define NT4_GDI_HANDLE_BUFFER_SIZE      34

typedef struct _NT4_PEB_FREE_BLOCK {
    struct _PEB_FREE_BLOCK *Next;
    ULONG Size;
} NT4_PEB_FREE_BLOCK, *PNT4_PEB_FREE_BLOCK;

#if 0
typedef struct _NT4_CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} NT4_CLIENT_ID;
typedef NT4_CLIENT_ID *PNT4_CLIENT_ID;
#endif


typedef struct _NT4_PEB {
    BOOLEAN InheritedAddressSpace;      // These four fields cannot change unless the
    BOOLEAN ReadImageFileExecOptions;   //
    BOOLEAN BeingDebugged;              //
    BOOLEAN SpareBool;                  //
    HANDLE Mutant;                      // INITIAL_PEB structure is also updated.

    PVOID ImageBaseAddress;
    PNT4_PEB_LDR_DATA Ldr;
    struct _RTL_USER_PROCESS_PARAMETERS *ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PVOID FastPebLock;
    PVOID FastPebLockRoutine;
    PVOID FastPebUnlockRoutine;
    ULONG EnvironmentUpdateCount;
    PVOID KernelCallbackTable;
    HANDLE EventLogSection;
    PVOID EventLog;
    PNT4_PEB_FREE_BLOCK FreeList;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];         // relates to TLS_MINIMUM_AVAILABLE
    PVOID ReadOnlySharedMemoryBase;
    PVOID ReadOnlySharedMemoryHeap;
    PVOID *ReadOnlyStaticServerData;
    PVOID AnsiCodePageData;
    PVOID OemCodePageData;
    PVOID UnicodeCaseTableData;

    //
    // Useful information for LdrpInitialize
    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    //
    // Passed up from MmCreatePeb from Session Manager registry key
    //

    LARGE_INTEGER CriticalSectionTimeout;
    ULONG HeapSegmentReserve;
    ULONG HeapSegmentCommit;
    ULONG HeapDeCommitTotalFreeThreshold;
    ULONG HeapDeCommitFreeBlockThreshold;

    //
    // Where heap manager keeps track of all heaps created for a process
    // Fields initialized by MmCreatePeb.  ProcessHeaps is initialized
    // to point to the first free byte after the PEB and MaximumNumberOfHeaps
    // is computed from the page size used to hold the PEB, less the fixed
    // size of this data structure.
    //

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID *ProcessHeaps;

    //
    //
    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    PVOID GdiDCAttributeList;
    PVOID LoaderLock;

    //
    // Following fields filled in by MmCreatePeb from system values and/or
    // image header.
    //

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    ULONG OSBuildNumber;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    ULONG ImageProcessAffinityMask;
    ULONG GdiHandleBuffer[NT4_GDI_HANDLE_BUFFER_SIZE];
} NT4_PEB, *PNT4_PEB;


//
// From ntldr.h
//

typedef struct _NT4_LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    NT4_UNICODE_STRING FullDllName;
    NT4_UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    union {
        LIST_ENTRY HashLinks;
        struct {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    };
    ULONG   TimeDateStamp;
} NT4_LDR_DATA_TABLE_ENTRY, *PNT4_LDR_DATA_TABLE_ENTRY;


//
// From ntpsapi.h.
//

typedef struct _NT4_PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PNT4_PEB PebBaseAddress;
    KAFFINITY AffinityMask;
    KPRIORITY BasePriority;
    ULONG UniqueProcessId;
    ULONG InheritedFromUniqueProcessId;
} NT4_PROCESS_BASIC_INFORMATION;
typedef NT4_PROCESS_BASIC_INFORMATION *PNT4_PROCESS_BASIC_INFORMATION;


#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)

#define NTAPI __stdcall

typedef DWORD ACCESS_MASK;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\sources.inc ===
INCLUDES = ..\..\dbg-common;..

USE_LIBCMT=1
NO_NTDLL=1

TARGETLIBS=\
    $(SDK_LIB_PATH)\kernel32.lib\
    $(SDK_LIB_PATH)\version.lib

PRECOMPILED_INCLUDE = ..\pch.h

SOURCES=\
    ..\gen.c       \
    ..\impl.c      \
    ..\ntx.c       \
    ..\minidump.c  \
    ..\wce.c       \
    ..\minidump.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\ntx.h ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    ntx.h

Abstract:

    Generic routines for NT operating system.

Author:

    Matthew D Hendel (math) 20-Oct-1999

Revision History:

--*/


#pragma once

BOOL
NtxGetProcessInfo(
    IN HANDLE hProcess,
    IN ULONG ProcessId,
    IN ULONG DumpType,
    IN MINIDUMP_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID CallbackParam,
    OUT PINTERNAL_PROCESS * Process
    );

PINTERNAL_MODULE
NtxAllocateModuleObject(
    IN PINTERNAL_PROCESS Process,
    IN HANDLE ProcessHandle,
    IN ULONG_PTR BaseOfModule,
    IN ULONG DumpType,
    IN ULONG WriteFlags,
    IN PWSTR Module OPTIONAL
    );

LPVOID
NtxGetTebAddress(
    IN HANDLE Thread,
    OUT PULONG SizeOfTeb
    );

HRESULT
TibGetThreadInfo(
    IN HANDLE Process,
    IN LPVOID TibBase,
    OUT PULONG64 StackBase,
    OUT PULONG64 StackLimit,
    OUT PULONG64 StoreBase,
    OUT PULONG64 StoreLimit
    );

LPVOID
NtxGetPebAddress(
    IN HANDLE Process,
    OUT PULONG SizeOfPeb
    );

BOOL
NtxWriteHandleData(
    IN HANDLE ProcessHandle,
    IN HANDLE hFile,
    IN struct _MINIDUMP_STREAM_INFO * StreamInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\pch.h ===
//----------------------------------------------------------------------------
//
// Precompiled header.
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#ifndef _WIN32_WCE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <winver.h>
#include <tlhelp32.h>

#include <wcecompat.h>

#ifndef _WIN32_WCE
#define _IMAGEHLP_SOURCE_
#include <dbghelp.h>
#else

#include "minidump.h"

struct _IMAGE_NT_HEADERS*
ImageNtHeader (
    IN PVOID Base
    );

PVOID
ImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );

#endif

#include "mdump.h"
#include "gen.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\ntx.c ===
/*++

Copyright(c) 1999-2002 Microsoft Corporation

Module Name:

    ntx.c

Abstract:

    Minidump user-mode crashdump NT specific functions. These routines work on
    NT-based operating systems from NT5 on.
    
Author:

    Matthew D Hendel (math) 20-Aug-1999

--*/

#include "pch.h"

#include "impl.h"



PINTERNAL_MODULE
NtxAllocateModuleObject(
    IN PINTERNAL_PROCESS Process,
    IN HANDLE ProcessHandle,
    IN ULONG_PTR BaseOfModule,
    IN ULONG DumpType,
    IN ULONG WriteFlags,
    IN PWSTR ModuleName OPTIONAL
    )
{
    WCHAR FullPath [ MAX_PATH + 10 ];

    //
    // The basic LdrQueryProcessModule API that toolhelp uses
    // always returns ANSI strings for module paths.  This
    // means that even if you use the wide toolhelp calls
    // you still lose Unicode information because the original
    // Unicode path was converted to ANSI and then back to Unicode.
    // To avoid this problem, always try and look up the true
    // Unicode path first.  This doesn't work for 32-bit modules
    // in WOW64, though, so if there's a failure just use the
    // incoming string.
    //
    
    if (GetModuleFileNameExW(ProcessHandle,
                             (HMODULE) BaseOfModule,
                             FullPath,
                             sizeof (FullPath))) {
        ModuleName = FullPath;
    } else if (!ModuleName) {
        GenAccumulateStatus(MDSTATUS_CALL_FAILED);
        return NULL;
    }
                    
    //
    // Translate funky \??\... module name.
    //

    return GenAllocateModuleObject (Process, ModuleName, BaseOfModule,
                                    DumpType, WriteFlags);
}

typedef
PLIST_ENTRY
(*FN_RtlGetFunctionTableListHead) (
    VOID
    );

BOOL
NtxGetFunctionTables(
    IN HANDLE hProcess,
    IN PINTERNAL_PROCESS Process,
    IN ULONG DumpType
    )
{
#ifdef _WIN32_WCE
    return FALSE;
#else
    HMODULE NtDll;
    FN_RtlGetFunctionTableListHead GetHead = NULL;
    PLIST_ENTRY HeadAddr;
    LIST_ENTRY Head;
    PVOID Next;
    SIZE_T Done;
    DYNAMIC_FUNCTION_TABLE Table;

    //
    // On systems that support dynamic function tables
    // ntdll exports a function called RtlGetFunctionTableListHead
    // to retrieve the head of a process's function table list.
    // Currently this is always a global LIST_ENTRY in ntdll
    // and so is at the same address in all processes since ntdll
    // is mapped at the same address in every process.  This
    // means we can call it in our process and get a pointer
    // that's valid in the process being dumped.
    //
    // We also use the presence of RGFTLH as a signal of
    // whether dynamic function tables are supported or not.
    //
    
    NtDll = GetModuleHandle("ntdll");
    if (NtDll) {
        GetHead = (FN_RtlGetFunctionTableListHead)
            GetProcAddress(NtDll, "RtlGetFunctionTableListHead");
    }
    if (!GetHead) {
        // Dynamic function tables are not supported.
        return TRUE;
    }

    HeadAddr = GetHead();
    if (!ReadProcessMemory(hProcess, HeadAddr, &Head, sizeof(Head),
                           &Done) || Done != sizeof(Head)) {
        GenAccumulateStatus(MDSTATUS_UNABLE_TO_READ_MEMORY);
        return FALSE;
    }

    Next = Head.Flink;
    while (Next && Next != HeadAddr) {

        PINTERNAL_FUNCTION_TABLE IntTable;
        PVOID HeapEntries;
        PVOID TableAddr;
        ULONG EntryCount;

        TableAddr = Next;
        
        if (!ReadProcessMemory(hProcess, TableAddr, &Table, sizeof(Table),
                               &Done) || Done != sizeof(Table)) {
            GenAccumulateStatus(MDSTATUS_UNABLE_TO_READ_MEMORY);
            return FALSE;
        }

#ifdef _AMD64_
        Next = Table.ListEntry.Flink;
#else
        Next = Table.Links.Flink;
#endif

        HeapEntries = NULL;
        
#if defined(_AMD64_) || defined(_IA64_)

        //
        // AMD64 and IA64 support a type of function table
        // where the data is retrieved via a callback rather
        // than being is a plain data table.  In order to
        // get at the data from out-of-process the table
        // must have an out-of-process access DLL registered.
        //
        
        if (Table.Type == RF_CALLBACK) {

            WCHAR DllName[MAX_PATH];
            HMODULE OopDll;
            POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK OopCb;

            if (!Table.OutOfProcessCallbackDll) {
                // No out-of-process access is possible.
                continue;
            }

            if (!ReadProcessMemory(hProcess, Table.OutOfProcessCallbackDll,
                                   DllName, sizeof(DllName) - sizeof(WCHAR),
                                   &Done)) {
                GenAccumulateStatus(MDSTATUS_UNABLE_TO_READ_MEMORY);
                return FALSE;
            }

            DllName[Done / sizeof(WCHAR)] = 0;

            OopDll = LoadLibraryW(DllName);
            if (!OopDll) {
                GenAccumulateStatus(MDSTATUS_CALL_FAILED);
                return FALSE;
            }

            OopCb = (POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK)GetProcAddress
                (OopDll, OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME);
            if (OopCb == NULL) {
                FreeLibrary(OopDll);
                GenAccumulateStatus(MDSTATUS_CALL_FAILED);
                return FALSE;
            }

            if (!NT_SUCCESS(OopCb(hProcess, TableAddr,
                                  &EntryCount,
                                  (PRUNTIME_FUNCTION*)&HeapEntries))) {
                FreeLibrary(OopDll);
                GenAccumulateStatus(MDSTATUS_CALL_FAILED);
                return FALSE;
            }

            FreeLibrary(OopDll);
        } else {
            EntryCount = Table.EntryCount;
        }

#else
        EntryCount = Table.EntryCount;
#endif

        IntTable = GenAllocateFunctionTableObject(Table.MinimumAddress,
                                                  Table.MaximumAddress,
#ifdef _ALPHA_
                                                  Table.MinimumAddress,
#else
                                                  Table.BaseAddress,
#endif
                                                  EntryCount,
                                                  &Table);
        if (IntTable) {
            
#if defined(_AMD64_) || defined(_IA64_)

            if (Table.Type == RF_CALLBACK) {
                memcpy(IntTable->RawEntries, HeapEntries,
                       EntryCount * sizeof(RUNTIME_FUNCTION));
            } else
#endif
            {
                if (!ReadProcessMemory(hProcess, Table.FunctionTable,
                                       IntTable->RawEntries,
                                       EntryCount * sizeof(RUNTIME_FUNCTION),
                                       &Done) ||
                    Done != EntryCount * sizeof(RUNTIME_FUNCTION)) {
                    GenFreeFunctionTableObject(IntTable);
                    IntTable = NULL;
                }
            }
        }

        if (HeapEntries) {
            RtlFreeHeap(RtlProcessHeap(), 0, HeapEntries);
        }

        if (!IntTable) {
            return FALSE;
        }

        if (!GenIncludeUnwindInfoMemory(hProcess, DumpType, IntTable)) {
            return FALSE;
        }
        
        Process->NumberOfFunctionTables++;
        InsertTailList(&Process->FunctionTableList, &IntTable->TableLink);
    }

    return TRUE;
#endif // _WIN32_WCE
}

#ifdef RTL_UNLOAD_EVENT_TRACE_NUMBER

typedef
PRTL_UNLOAD_EVENT_TRACE
(*FN_RtlGetUnloadEventTrace) (
    VOID
    );

#endif

BOOL
NtxGetUnloadedModules(
    IN HANDLE hProcess,
    IN PINTERNAL_PROCESS Process,
    IN ULONG DumpType
    )
{
#if defined(_WIN32_WCE) || !defined(RTL_UNLOAD_EVENT_TRACE_NUMBER)
    return FALSE;
#else
    HMODULE NtDll;
    FN_RtlGetUnloadEventTrace GetTrace = NULL;
    PRTL_UNLOAD_EVENT_TRACE TraceAddr;
    PRTL_UNLOAD_EVENT_TRACE TraceArray;
    SIZE_T Done;
    ULONG Entries;
    PRTL_UNLOAD_EVENT_TRACE Oldest;
    ULONG i;
    PINTERNAL_UNLOADED_MODULE IntModule;

    if (!(DumpType & MiniDumpWithUnloadedModules)) {
        // No unloaded module info requested.
        return TRUE;
    }
    
    //
    // On systems that support unload traces
    // ntdll exports a function called RtlGetUnloadEventTrace
    // to retrieve the base of an unload trace array.
    // Currently this is always a global in ntdll
    // and so is at the same address in all processes since ntdll
    // is mapped at the same address in every process.  This
    // means we can call it in our process and get a pointer
    // that's valid in the process being dumped.
    //
    // We also use the presence of RGUET as a signal of
    // whether unload traces are supported or not.
    //
    
    NtDll = GetModuleHandle("ntdll");
    if (NtDll) {
        GetTrace = (FN_RtlGetUnloadEventTrace)
            GetProcAddress(NtDll, "RtlGetUnloadEventTrace");
    }
    if (!GetTrace) {
        // Unload traces are not supported.
        return TRUE;
    }

    TraceAddr = GetTrace();

    // Currently there are always 16 entries.
    Entries = 16;

    TraceArray = (PRTL_UNLOAD_EVENT_TRACE)
        AllocMemory(sizeof(*TraceArray) * Entries);
    if (!TraceArray) {
        return FALSE;
    }
    
    if (!ReadProcessMemory(hProcess, TraceAddr,
                           TraceArray, sizeof(*TraceArray) * Entries,
                           &Done) ||
        Done != sizeof(*TraceArray) * Entries) {
        GenAccumulateStatus(MDSTATUS_UNABLE_TO_READ_MEMORY);
        return FALSE;
    }

    //
    // Find the true number of entries in use and sort.
    // The sequence numbers of the trace records increase with
    // time and we want to have the head of the list be the
    // most recent record, so sort by decreasing sequence number.
    // We know that the array is a circular buffer, so things
    // are already in order except there may be a transition
    // of sequence after the newest record.  Find that transition
    // and sorting becomes trivial.
    //

    Oldest = TraceArray;
    for (i = 0; i < Entries; i++) {

        if (!TraceArray[i].BaseAddress || !TraceArray[i].SizeOfImage) {
            // Unused entry, no need to continue.
            Entries = i;
            break;
        }

        if (TraceArray[i].Sequence < Oldest->Sequence) {
            Oldest = TraceArray + i;
        }
    }

    //
    // Now push the entries on from the oldest to the youngest.
    //
    
    for (i = 0; i < Entries; i++) {
        IntModule =
            GenAllocateUnloadedModuleObject(Oldest->ImageName,
                                            (ULONG_PTR)Oldest->BaseAddress,
                                            (ULONG)Oldest->SizeOfImage,
                                            Oldest->CheckSum,
                                            Oldest->TimeDateStamp);
        if (!IntModule) {
            return FALSE;
        }

        Process->NumberOfUnloadedModules++;

        InsertHeadList(&Process->UnloadedModuleList, &IntModule->ModulesLink);

        if (Oldest == TraceArray + (Entries - 1)) {
            Oldest = TraceArray;
        } else {
            Oldest++;
        }
    }

    return TRUE;
#endif // _WIN32_WCE || !RTL_UNLOAD_EVENT_TRACE_NUMBER
}

BOOL
NtxGetProcessInfo(
    IN HANDLE hProcess,
    IN ULONG ProcessId,
    IN ULONG DumpType,
    IN MINIDUMP_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID CallbackParam,
    OUT PINTERNAL_PROCESS * ProcessRet
    )

/*++

Routine Description:

    Using toolhelp, obtain the process information for this process.

Return Values:

    TRUE - Success.

    FALSE - Failure:

Environment:

    Win9x/Win2k+ only.

--*/

{
    BOOL Succ;
    ULONG i;
    BOOL MoreThreads;
    HANDLE Snapshot, ModuleSnapshot = INVALID_HANDLE_VALUE;
    THREADENTRY32 ThreadInfo;
    PINTERNAL_THREAD Thread;
    PINTERNAL_PROCESS Process;
    PINTERNAL_MODULE Module;
    HMODULE Modules [ 512 ];
    ULONG ModulesSize;
    ULONG NumberOfModules;
    ULONG BuildNumber;    

    ASSERT ( hProcess );
    ASSERT ( ProcessId != 0 );
    ASSERT ( ProcessRet );

    Process = NULL;
    Thread = NULL;
    Module = NULL;
    Snapshot = NULL;
    ThreadInfo.dwSize = sizeof (THREADENTRY32);
    
    Process = GenAllocateProcessObject ( hProcess, ProcessId );

    if ( Process == NULL ) {
        return FALSE;
    }

    Snapshot = CreateToolhelp32Snapshot (
                            TH32CS_SNAPTHREAD,
                            ProcessId
                            );

    if ( Snapshot == INVALID_HANDLE_VALUE ) {
        Succ = FALSE;
        GenAccumulateStatus(MDSTATUS_CALL_FAILED);
        goto Exit;
    }

    //
    // Walk thread list, suspending all threads and getting thread info.
    //

    for (MoreThreads = ProcessThread32First (Snapshot, ProcessId, &ThreadInfo );
         MoreThreads;
         MoreThreads = ProcessThread32Next ( Snapshot, ProcessId, &ThreadInfo ) ) {
        HRESULT Status;
        ULONG WriteFlags;

        if (!GenExecuteIncludeThreadCallback(hProcess,
                                             ProcessId,
                                             DumpType,
                                             ThreadInfo.th32ThreadID,
                                             CallbackRoutine,
                                             CallbackParam,
                                             &WriteFlags) ||
            IsFlagClear(WriteFlags, ThreadWriteThread)) {
            continue;
        }
                                             
        Status = GenAllocateThreadObject (
                                        Process,
                                        hProcess,
                                        ThreadInfo.th32ThreadID,
                                        DumpType,
                                        WriteFlags,
                                        &Thread
                                        );

        if ( FAILED(Status) ) {
            Succ = FALSE;
            goto Exit;
        }

        // If Status is S_FALSE it means that the thread
        // couldn't be opened and probably exited before
        // we got to it.  Just continue on.
        if (Status == S_OK) {
            Process->NumberOfThreads++;
            InsertTailList (&Process->ThreadList, &Thread->ThreadsLink);
        }
    }

    GenGetSystemType (NULL, NULL, NULL, NULL, &BuildNumber);
    if (BuildNumber > 2468) {
    
        // 
        // toolhelp had been changed to perform noninvasive 
        // module enumeration
        //
        
        MODULEENTRY32W ModuleEntry;  
        BOOL ModuleFound;
        
        NumberOfModules = 0;
        Succ = TRUE;
          
        ModuleSnapshot = CreateToolhelp32Snapshot( 
                                    TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32,
                                    ProcessId
                                    );
    
        if (ModuleSnapshot == INVALID_HANDLE_VALUE) {
            Succ = FALSE;
            GenAccumulateStatus(MDSTATUS_CALL_FAILED);
            goto Exit;
        }
        
        ZeroMemory(&ModuleEntry, sizeof(ModuleEntry)); 
        ModuleEntry.dwSize = sizeof(ModuleEntry);
        
        ModuleFound = Module32FirstW(ModuleSnapshot, &ModuleEntry);
        while (ModuleFound) {
            ULONG WriteFlags;

            if (GenExecuteIncludeModuleCallback(hProcess,
                                                ProcessId,
                                                DumpType,
                                                (LONG_PTR)ModuleEntry.modBaseAddr,
                                                CallbackRoutine,
                                                CallbackParam,
                                                &WriteFlags) &&
                IsFlagSet(WriteFlags, ModuleWriteModule)) {

                Module = NtxAllocateModuleObject (Process,
                                                  Process->ProcessHandle,
                                                  (LONG_PTR)ModuleEntry.modBaseAddr,
                                                  DumpType,
                                                  WriteFlags,
                                                  ModuleEntry.szExePath);
                if ( Module == NULL ) {
                    Succ = FALSE;
                    goto Exit;
                }
            
                InsertTailList (&Process->ModuleList, &Module->ModulesLink);
                ++NumberOfModules;
            }

            ModuleFound = Module32NextW(ModuleSnapshot, &ModuleEntry);
        }
    }
    else {
    
        //
        // Walk module list, getting module information. Use PSAPI instead of
        // toolhelp since it it does not exhibit the deadlock issues with
        // the loader lock. ( on old versions of os )
        //
    
        ModulesSize = 0;
        Succ = EnumProcessModules (
                        Process->ProcessHandle,
                        Modules,
                        sizeof (Modules),
                        &ModulesSize
                        );
        
        if ( !Succ ) {
            GenAccumulateStatus(MDSTATUS_CALL_FAILED);
            goto Exit;
        }
    
        NumberOfModules = ModulesSize / sizeof (HMODULE);
        for (i = 0; i < NumberOfModules; i++) {
            ULONG WriteFlags;

            if (!GenExecuteIncludeModuleCallback(hProcess,
                                                 ProcessId,
                                                 DumpType,
                                                 (LONG_PTR)Modules[i],
                                                 CallbackRoutine,
                                                 CallbackParam,
                                                 &WriteFlags) ||
                IsFlagClear(WriteFlags, ModuleWriteModule)) {
                continue;
            }
            
            Module = NtxAllocateModuleObject (
                                    Process,
                                    Process->ProcessHandle,
                                    (LONG_PTR) Modules [ i ],
                                    DumpType,
                                    WriteFlags,
                                    NULL
                                    );
    
            if ( Module == NULL ) {
                Succ = FALSE;
                goto Exit;
            }
            InsertTailList (&Process->ModuleList, &Module->ModulesLink);
        }
    }
    
    Process->NumberOfModules = NumberOfModules;

    Succ = NtxGetFunctionTables(hProcess, Process, DumpType);

    // If we can't get unloaded modules that's not a critical problem.
    NtxGetUnloadedModules(hProcess, Process, DumpType);
    
Exit:

    if ( Snapshot && (Snapshot != INVALID_HANDLE_VALUE) ) {
        CloseHandle ( Snapshot );
        Snapshot = NULL;
    }
    
    if ( ModuleSnapshot && (ModuleSnapshot != INVALID_HANDLE_VALUE) ) {
        CloseHandle ( ModuleSnapshot );
        ModuleSnapshot = NULL;
    }

    if ( !Succ && Process != NULL ) {
        GenFreeProcessObject ( Process );
        Process = NULL;
    }

    *ProcessRet = Process;

    return Succ;
}

LPVOID
NtxGetTebAddress(
    IN HANDLE Thread,
    OUT PULONG SizeOfTeb
    )
{
#ifdef _WIN32_WCE
    *SizeOfTeb = 0;
    return NULL;
#else
    THREAD_BASIC_INFORMATION ThreadInformation;
    NTSTATUS NtStatus;

    NtStatus = NtQueryInformationThread(Thread,
                                        ThreadBasicInformation,
                                        &ThreadInformation,
                                        sizeof(ThreadInformation),
                                        NULL);
    if (NT_SUCCESS(NtStatus)) {
        // The TEB is a little smaller than a page but
        // save the entire page so that adjacent TEB
        // pages get coalesced into a single region.
        // As TEBs are normally adjacent this is a common case.
        *SizeOfTeb = PAGE_SIZE;
        return ThreadInformation.TebBaseAddress;
    } else {
        *SizeOfTeb = 0;
        return NULL;
    }
#endif
}

HRESULT
TibGetThreadInfo(
    IN HANDLE Process,
    IN LPVOID TibBase,
    OUT PULONG64 StackBase,
    OUT PULONG64 StackLimit,
    OUT PULONG64 StoreBase,
    OUT PULONG64 StoreLimit
    )
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    TEB Teb;
    HRESULT Succ;
    SIZE_T BytesRead;

#if defined (DUMP_BACKING_STORE)
    
    Succ = ReadProcessMemory(Process,
                             TibBase,
                             &Teb,
                             sizeof (Teb),
                             &BytesRead) ? S_OK : E_FAIL;
    if ( Succ != S_OK || BytesRead != sizeof (Teb) ) {
        return E_FAIL;
    }

    *StoreBase = SIGN_EXTEND(BSTORE_BASE(&Teb));
    *StoreLimit = SIGN_EXTEND(BSTORE_LIMIT(&Teb));
    
#else
    
    Succ = ReadProcessMemory(Process,
                             TibBase,
                             &Teb,
                             sizeof (Teb.NtTib),
                             &BytesRead) ? S_OK : E_FAIL;
    if ( Succ != S_OK || BytesRead != sizeof (Teb.NtTib) ) {
        return E_FAIL;
    }

    *StoreBase = 0;
    *StoreLimit = 0;
    
#endif

    *StackBase = SIGN_EXTEND((LONG_PTR)Teb.NtTib.StackBase);
    *StackLimit = SIGN_EXTEND((LONG_PTR)Teb.NtTib.StackLimit);
    
    return S_OK;
#endif // #ifdef _WIN32_WCE
}

LPVOID
NtxGetPebAddress(
    IN HANDLE Process,
    OUT PULONG SizeOfPeb
    )
{
#ifdef _WIN32_WCE
    *SizeOfPeb = 0;
    return NULL;
#else
    PROCESS_BASIC_INFORMATION Information;
    NTSTATUS NtStatus;

    NtStatus = NtQueryInformationProcess(Process,
                                         ProcessBasicInformation,
                                         &Information,
                                         sizeof(Information),
                                         NULL);
    if (NT_SUCCESS(NtStatus)) {
        *SizeOfPeb = sizeof(PEB);
        return Information.PebBaseAddress;
    } else {
        *SizeOfPeb = 0;
        return NULL;
    }
#endif
}

BOOL
NtxWriteHandleData(
    IN HANDLE ProcessHandle,
    IN HANDLE hFile,
    IN struct _MINIDUMP_STREAM_INFO * StreamInfo
    )
{
#ifdef _WIN32_WCE
    return FALSE;
#else
    NTSTATUS NtStatus;
    ULONG HandleCount;
    ULONG Hits;
    ULONG Handle;
    ULONG64 Buffer[1024 / sizeof(ULONG64)];
    POBJECT_TYPE_INFORMATION TypeInfo =
        (POBJECT_TYPE_INFORMATION)Buffer;
    POBJECT_NAME_INFORMATION NameInfo =
        (POBJECT_NAME_INFORMATION)Buffer;
    OBJECT_BASIC_INFORMATION BasicInfo;
    HANDLE Dup;
    PMINIDUMP_HANDLE_DESCRIPTOR Descs, Desc;
    RVA Rva;
    ULONG32 Len;
    ULONG Done;
    MINIDUMP_HANDLE_DATA_STREAM DataStream;
    BOOL Succ;
    
    NtStatus = NtQueryInformationProcess(ProcessHandle,
                                         ProcessHandleCount,
                                         &HandleCount,
                                         sizeof(HandleCount),
                                         NULL);
    if (!NT_SUCCESS(NtStatus)) {
        return FALSE;
    }

    Descs = AllocMemory(HandleCount * sizeof(*Desc));
    if (Descs == NULL) {
        return FALSE;
    }
    
    Hits = 0;
    Handle = 0;
    Desc = Descs;
    Rva = StreamInfo->RvaOfHandleData;
    
    while (Hits < HandleCount && Handle < (1 << 24)) {
        if (!DuplicateHandle(ProcessHandle, (HANDLE)(ULONG_PTR)Handle,
                             GetCurrentProcess(), &Dup,
                             0, FALSE, DUPLICATE_SAME_ACCESS)) {
            Handle += 4;
            continue;
        }

        // Successfully got a handle, so consider this a hit.
        Hits++;

        if (!NT_SUCCESS(NtQueryObject(Dup, ObjectBasicInformation,
                                      &BasicInfo, sizeof(BasicInfo), NULL)) ||
            !NT_SUCCESS(NtQueryObject(Dup, ObjectTypeInformation,
                                      TypeInfo, sizeof(Buffer), NULL))) {
            // If we can't get the basic info and type there isn't much
            // point in writing anything out so skip the handle.
            goto CloseDup;
        }
        
        Len = TypeInfo->TypeName.Length;
        TypeInfo->TypeName.Buffer[Len / sizeof(WCHAR)] = 0;

        Desc->TypeNameRva = Rva;
        
        if (!WriteFile(hFile, &Len, sizeof(Len), &Done, NULL) ||
            Done != sizeof(Len)) {
            goto ExitCloseDup;
        }
            
        Len += sizeof(WCHAR);
        if (!WriteFile(hFile, TypeInfo->TypeName.Buffer, Len, &Done, NULL) ||
            Done != Len) {
            goto ExitCloseDup;
        }
            
        Rva += Len + sizeof(Len);
            
        // Don't get the name of file objects as it
        // can cause deadlocks.  If we fail getting the
        // name just leave it out and don't consider it fatal.
        if (lstrcmpW(TypeInfo->TypeName.Buffer, L"File") &&
            NT_SUCCESS(NtQueryObject(Dup, ObjectNameInformation,
                                     NameInfo, sizeof(Buffer), NULL)) &&
            NameInfo->Name.Buffer != NULL) {

            Len = NameInfo->Name.Length;
            NameInfo->Name.Buffer[Len / sizeof(WCHAR)] = 0;

            Desc->ObjectNameRva = Rva;
        
            if (!WriteFile(hFile, &Len, sizeof(Len), &Done, NULL) ||
                Done != sizeof(Len)) {
                goto ExitCloseDup;
            }

            Len += sizeof(WCHAR);
            if (!WriteFile(hFile, NameInfo->Name.Buffer, Len, &Done, NULL) ||
                Done != Len) {
                goto ExitCloseDup;
            }

            Rva += Len + sizeof(Len);
            
        } else {
            Desc->ObjectNameRva = 0;
        }

        Desc->Handle = Handle;
        Desc->Attributes = BasicInfo.Attributes;
        Desc->GrantedAccess = BasicInfo.GrantedAccess;
        Desc->HandleCount = BasicInfo.HandleCount;
        Desc->PointerCount = BasicInfo.PointerCount;

        Desc++;
        
    CloseDup:
        CloseHandle(Dup);
        Handle += 4;
    }

    DataStream.SizeOfHeader = sizeof(DataStream);
    DataStream.SizeOfDescriptor = sizeof(*Descs);
    DataStream.NumberOfDescriptors = (ULONG)(Desc - Descs);
    DataStream.Reserved = 0;
    
    StreamInfo->RvaOfHandleData = Rva;
    StreamInfo->SizeOfHandleData = sizeof(DataStream) +
        DataStream.NumberOfDescriptors * sizeof(*Descs);
    
    Succ =
        WriteFile(hFile, &DataStream, sizeof(DataStream), &Done, NULL) &&
        Done == sizeof(DataStream) &&
        WriteFile(hFile, Descs, DataStream.NumberOfDescriptors *
                  sizeof(*Descs), &Done, NULL) &&
        Done == DataStream.NumberOfDescriptors * sizeof(*Descs);
        
    FreeMemory(Descs);
    return Succ;

 ExitCloseDup:
    CloseHandle(Dup);
    FreeMemory(Descs);
    return FALSE;
#endif // #ifdef _WIN32_WCE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\wce.c ===
//----------------------------------------------------------------------------
//
// Windows CE specific functions.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#include "pch.h"

HRESULT
WceGetThreadInfo(
    IN HANDLE Process,
    IN HANDLE Thread,
    OUT PULONG64 Teb,
    OUT PULONG SizeOfTeb,
    OUT PULONG64 StackBase,
    OUT PULONG64 StackLimit,
    OUT PULONG64 StoreBase,
    OUT PULONG64 StoreLimit
    )
{
    return E_NOTIMPL;
}

LPVOID
WceGetPebAddress(
    IN HANDLE Process,
    OUT PULONG SizeOfPeb
    )
{
    *SizeOfPeb = 0;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\platform.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    platform.h

Abstract:

    Platform specific macros and functions.

Author:

    Matthew D Hendel (math) 28-Aug-1999

Revision History:

--*/

// Some processors use both a stack and a backing store.
// If a particular processor supports backing store add
// DUMP_BACKING_STORE.

#if defined (i386)

#define PROGRAM_COUNTER(_context)   ((_context)->Eip)
#define STACK_POINTER(_context)     ((_context)->Esp)
#define INSTRUCTION_WINDOW_SIZE     256
#define PAGE_SIZE                   4096

//
// The CONTEXT_FULL definition on x86 doesn't really get all
// the registers. Use ALL_REGISTERS to get the compelte
// context.
//

#define ALL_REGISTERS   (CONTEXT_CONTROL    |\
                         CONTEXT_INTEGER    |\
                         CONTEXT_SEGMENTS   |\
                         CONTEXT_FLOATING_POINT |\
                         CONTEXT_DEBUG_REGISTERS    |\
                         CONTEXT_EXTENDED_REGISTERS)

//
// The following are flags specific to the CPUID instruction on x86 only.
//

#define CPUID_VENDOR_ID             (0)
#define CPUID_VERSION_FEATURES      (1)
#define CPUID_AMD_EXTENDED_FEATURES (0x80000001)

// X86 doesn't have function entries but it makes the code
// cleaner to provide placeholder types to avoid some ifdefs in the code
// itself.
typedef struct _DYNAMIC_FUNCTION_TABLE {
    LIST_ENTRY Links;
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG EntryCount;
    PVOID FunctionTable;
} DYNAMIC_FUNCTION_TABLE, *PDYNAMIC_FUNCTION_TABLE;

typedef struct _RUNTIME_FUNCTION {
    ULONG64 Unused;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

typedef struct _UNWIND_INFO {
    ULONG64 Unused;
} UNWIND_INFO, *PUNWIND_INFO;

#elif defined(_AMD64_)

#define PROGRAM_COUNTER(_context)   ((_context)->Rip)
#define STACK_POINTER(_context)     ((_context)->Rsp)
#define INSTRUCTION_WINDOW_SIZE     256
#define PAGE_SIZE                   4096

#define ALL_REGISTERS (CONTEXT_FULL | CONTEXT_SEGMENTS | CONTEXT_DEBUG_REGISTERS)

#elif defined (ALPHA)

#define PROGRAM_COUNTER(_context)   ((_context)->Fir)
#define STACK_POINTER(_context)     ((_context)->IntSp)
#define INSTRUCTION_WINDOW_SIZE     512
#define PAGE_SIZE                   8192
#define ALL_REGISTERS               (CONTEXT_FULL)

#elif defined (_IA64_)

#define PROGRAM_COUNTER(_context)   ((_context)->StIIP)
#define STACK_POINTER(_context)     ((_context)->IntSp)
#define INSTRUCTION_WINDOW_SIZE     768
#define PAGE_SIZE                   8192
#define ALL_REGISTERS               (CONTEXT_FULL | CONTEXT_DEBUG)

#define DUMP_BACKING_STORE
#if 1
// XXX drewb - The TEB bstore values don't seem to point to
// the actual base of the backing store.  Just
// assume it's contiguous with the stack.
#define BSTORE_BASE(_teb)           ((_teb)->NtTib.StackBase)
#else
#define BSTORE_BASE(_teb)           ((_teb)->DeallocationBStore)
#endif
#define BSTORE_LIMIT(_teb)           ((_teb)->BStoreLimit)
// The BSP points to the bottom of the current frame's
// storage area.  We need to add on the size of the
// current frame to get the amount of memory that
// really needs to be stored.  When computing the
// size of the current frame space for NAT bits
// must be figured in properly based on the number
// of entries in the frame.  The NAT collection
// is spilled on every 63'rd spilled register to
// make each block an every 64 ULONG64s long.
// On NT the backing store base is always 9-bit aligned
// so we can tell when exactly the next NAT spill
// will occur by looking for when the 9-bit spill
// region will overflow.
__inline ULONG64
BSTORE_POINTER(CONTEXT* Context)
{
    ULONG64 Limit = Context->RsBSP;
    ULONG Count = (ULONG)(Context->StIFS & 0x7f);

    // Add in a ULONG64 for every register in the
    // current frame.  While doing so, check for
    // spill entries.
    while (Count-- > 0)
    {
        Limit += sizeof(ULONG64);
        if ((Limit & 0x1f8) == 0x1f8)
        {
            // Spill will be placed at this address so
            // account for it.
            Limit += sizeof(ULONG64);
        }
    }

    return Limit;
}

#elif defined (ARM)

#define PROGRAM_COUNTER(_context)   ((_context)->Pc)
#define STACK_POINTER(_context)     ((_context)->Sp)
#define INSTRUCTION_WINDOW_SIZE     512
#define PAGE_SIZE                   4096
#define ALL_REGISTERS               (CONTEXT_CONTROL | CONTEXT_INTEGER)

// ARM doesn't have function entries but it makes the code
// cleaner to provide placeholder types to avoid some ifdefs in the code
// itself.
typedef struct _DYNAMIC_FUNCTION_TABLE {
    LIST_ENTRY Links;
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG EntryCount;
    PVOID FunctionTable;
} DYNAMIC_FUNCTION_TABLE, *PDYNAMIC_FUNCTION_TABLE;

typedef struct _RUNTIME_FUNCTION {
    ULONG64 Unused;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

typedef struct _UNWIND_INFO {
    ULONG64 Unused;
} UNWIND_INFO, *PUNWIND_INFO;

#else

#error ("unknown processor type")

#endif

#define AMD_VENDOR_ID_0     ('htuA')
#define AMD_VENDOR_ID_1     ('itne')
#define AMD_VENDOR_ID_2     ('DMAc')

#define INTEL_VENDOR_ID_0   ('uneG')
#define INTEL_VENDOR_ID_1   ('Ieni')
#define INTEL_VENDOR_ID_2   ('letn')
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\win.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    win.h

Abstract:

    Routines publicly exported from win.c; windows-specific functions.x

Author:

    Matthew D Hendel (math) 20-Oct-1999

Revision History:

--*/

#pragma once

//
// Win9x related APIs are not necessary on Win64.
//

#if !defined (_X86_)

#define WinOpenThread(_a,_i,_tid) (FALSE)

#else // X86

HANDLE
WINAPI
WinOpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    );

//
// Init must be called before calling WinOpenThread().
//

BOOL
WinInitialize(
    );

VOID
WinFree(
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\wce.h ===
//----------------------------------------------------------------------------
//
// Windows CE specific functions.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#ifndef __WCE_H__
#define __WCE_H__

HRESULT
WceGetThreadInfo(
    IN HANDLE Process,
    IN HANDLE Thread,
    OUT PULONG64 Teb,
    OUT PULONG SizeOfTeb,
    OUT PULONG64 StackBase,
    OUT PULONG64 StackLimit,
    OUT PULONG64 StoreBase,
    OUT PULONG64 StoreLimit
    );

LPVOID
WceGetPebAddress(
    IN HANDLE Process,
    OUT PULONG SizeOfPeb
    );

#endif // #ifndef __WCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\dbghelp\mprivate.h ===
/* By defining DBGHELP_SOURCE we prevent circular
   logic.  This way dbghelp won't try to call minidump.lib and then
   have minidump.lib try to load dbghelp for the minidump functions
*/

#define _DBGHELP_SOURCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\win.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    win.c

Abstract:

    This module exports windows specific apis

Algorithm:

    Unfortunately, implementing OpenThread cannot be done in a simple
    manner. What follows is a very system dependent hack. If the structure
    of the TDB or the implementation of OpenProcess change very much, this
    function will break.

    To have any idea of what we are doing here, you should be familiar with
    Win9x internals. If you are not familiar with the Win9x source, consult
    the book "Windows 95 System Programming SECRETS" by Matt Pietrek. Things
    are not exactly the same for Win98 -- but pretty close.

    OpenThread is a very simple function. If we were compiled withing the
    Win9x source code base, the code would be simple:

    OpenThread:

            pObj = TidToTDB (dwThreadId);

            return AllocHandle (GetCurrentPdb(), pObj, Flags);

    Since we are not, the challenge is implementing the functions TidToTDB()
    and AllocHandle().

    Our approach is as follows:

        1) We reverse-engineer TidToTDB since it is simple. TidToTDB is just
           the thread-id xor'd with the Win9x Obfuscator.

        2) We search through the code of OpenProcess until we find the address
           of AllocHandle. We use this to allocate new handles in the
           process's handle database.

        3) OpenThread is then implemented in terms of the above primitives.

Author:

    Matthew D Hendel (math) 01-Sept-1999

Revision History:


--*/

#include "pch.h"

#include "impl.h"

//
// Windows 9x support is x86 only.
//

#ifdef _X86_

typedef struct _MATCH_BUFFER {
    ULONG Offset;
    BYTE Byte;
} MATCH_BUFFER, *PMATCH_BUFFER;

typedef struct _OS_INFORMATION {
    PMATCH_BUFFER MatchBuffer;
    ULONG AllocHandleOffset;
} OS_INFORMATION, POS_INFORMATION;


/*++

Operating System:

    Win95

Description:

    This is the disasm of the OpenProcess routine on Win95. We attempt to
    match this routine and pull out the value for AllocHandle from the code
    for this routine. In this case, AllocHande is called by the third call in
    this function.

    The instructions marked by '*' are those we use for matching.

OpenProcess:

    * BFF9404C: FF 74 24 0C        push        dword ptr [esp+0Ch]
    * BFF94050: E8 2D 87 FE FF     call        BFF7C782
      BFF94055: 85 C0              test        eax,eax
      BFF94057: 75 04              jne         BFF9405D
      BFF94059: 33 C0              xor         eax,eax
      BFF9405B: EB 56              jmp         BFF940B3
      BFF9405D: 83 38 05           cmp         dword ptr [eax],5
      BFF94060: 74 0E              je          BFF94070
      BFF94062: 6A 57              push        57h
    * BFF94064: E8 BC 68 FE FF     call        BFF7A925
      BFF94069: B9 FF FF FF FF     mov         ecx,0FFFFFFFFh
      BFF9406E: EB 33              jmp         BFF940A3
      BFF94070: B9 00 00 00 00     mov         ecx,0
      BFF94075: 8B 54 24 04        mov         edx,dword ptr [esp+4]
      BFF94079: 83 7C 24 08 01     cmp         dword ptr [esp+8],1
      BFF9407E: 83 D1 FF           adc         ecx,0FFFFFFFFh
      BFF94081: 81 E2 BF FF 1F 00  and         edx,1FFFBFh
      BFF94087: 81 E1 00 00 00 80  and         ecx,80000000h
      BFF9408D: 0B CA              or          ecx,edx
      BFF9408F: 8B 15 7C C2 FB BF  mov         edx,dword ptr ds:[BFFBC27Ch]
      BFF94095: 80 C9 40           or          cl,40h
      BFF94098: 51                 push        ecx
      BFF94099: 50                 push        eax
      BFF9409A: FF 32              push        dword ptr [edx]
    * BFF9409C: E8 6E 76 FE FF     call        BFF7B70F
      BFF940A1: 8B C8              mov         ecx,eax
      BFF940A3: 8D 41 01           lea         eax,[ecx+1]
      BFF940A6: 83 F8 01           cmp         eax,1
      BFF940A9: B8 00 00 00 00     mov         eax,0
      BFF940AE: 83 D0 FF           adc         eax,0FFFFFFFFh
      BFF940B1: 23 C1              and         eax,ecx
      BFF940B3: C2 0C 00           ret         0Ch

--*/

MATCH_BUFFER Win95AllocHandleMatch [] = {

    //
    // ret 0x0C at offset 103
    //

    { 103, 0xC2 },
    { 104, 0x0C },
    { 105, 0x00 },

    //
    // push dword ptr [exp 0x0C] at offset 0
    //

    { 0, 0xFF },
    { 1, 0x74 },
    { 2, 0x24 },
    { 3, 0x0C },

    //
    // call at offset 4
    //

    { 4, 0xE8 },

    //
    // call     at offset 24
    //

    { 24, 0xE8 },

    //
    // call at offset 80
    //

    { 80, 0xE8 },

    //
    // End of match list.
    //

    { -1, -1 }
};


/*++

Operating system:

    Win98

Description:

    See comments above regarding OpenProcess.

OpenProcess:

    * BFF95C4D: FF 74 24 0C        push        dword ptr [esp+0Ch]
    * BFF95C51: E8 C9 8E FE FF     call        BFF7EB1F
      BFF95C56: 85 C0              test        eax,eax
      BFF95C58: 75 04              jne         BFF95C5E
      BFF95C5A: 33 C0              xor         eax,eax
      BFF95C5C: EB 53              jmp         BFF95CB1
      BFF95C5E: 80 38 06           cmp         byte ptr [eax],6
      BFF95C61: 74 0E              je          BFF95C71
      BFF95C63: 6A 57              push        57h
    * BFF95C65: E8 27 6D FE FF     call        BFF7C991
      BFF95C6A: B9 FF FF FF FF     mov         ecx,0FFFFFFFFh
      BFF95C6F: EB 30              jmp         BFF95CA1
      BFF95C71: B9 00 00 00 00     mov         ecx,0
      BFF95C76: 8B 54 24 04        mov         edx,dword ptr [esp+4]
      BFF95C7A: 83 7C 24 08 01     cmp         dword ptr [esp+8],1
      BFF95C7F: 83 D1 FF           adc         ecx,0FFFFFFFFh
      BFF95C82: 81 E2 FF 0F 1F 00  and         edx,1F0FFFh
      BFF95C88: 81 E1 00 00 00 80  and         ecx,80000000h
      BFF95C8E: 0B CA              or          ecx,edx
      BFF95C90: 8B 15 DC 9C FC BF  mov         edx,dword ptr ds:[BFFC9CDCh]
      BFF95C96: 51                 push        ecx
      BFF95C97: 50                 push        eax
      BFF95C98: FF 32              push        dword ptr [edx]
    * BFF95C9A: E8 5A 7E FE FF     call        BFF7DAF9
      BFF95C9F: 8B C8              mov         ecx,eax
      BFF95CA1: 8D 41 01           lea         eax,[ecx+1]
      BFF95CA4: 83 F8 01           cmp         eax,1
      BFF95CA7: B8 00 00 00 00     mov         eax,0
      BFF95CAC: 83 D0 FF           adc         eax,0FFFFFFFFh
      BFF95CAF: 23 C1              and         eax,ecx
    * BFF95CB1: C2 0C 00           ret         0Ch

--*/

MATCH_BUFFER Win98AllocHandleMatch [] = {

    //
    // ret 0x0C at offset 100
    //

    { 100, 0xC2 },
    { 101, 0x0C },
    { 102, 0x00 },

    //
    // push dword ptr [exp 0x0C] at offset 0
    //

    { 0, 0xFF },
    { 1, 0x74 },
    { 2, 0x24 },
    { 3, 0x0C },

    //
    // call at offset 4
    //

    { 4, 0xE8 },

    //
    // call     at offset 24
    //

    { 24, 0xE8 },

    //
    // call at offset 77
    //

    { 77, 0xE8 },

    //
    // End of match list.
    //

    { -1, -1 }
};


OS_INFORMATION SupportedSystems [] =
{
    { Win95AllocHandleMatch, 81 },
    { Win98AllocHandleMatch, 78 }
};

typedef
HANDLE
(__stdcall * ALLOC_HANDLE_ROUTINE) (
    PVOID Pdb,
    PVOID Obj,
    DWORD Flags
    );

//
// Global variables
//

ALLOC_HANDLE_ROUTINE WinpAllocHandle = NULL;
DWORD WinpObfuscator = 0;


#pragma warning (disable:4035)

//
// OffsetTib is NOT dependent on the OS. The compiler uses this value.
//

#define OffsetTib 0x18

_inline
PVOID
WinpGetCurrentTib(
    )
{
#if defined(_X86_)
    __asm mov eax, fs:[OffsetTib]
#else
    return NULL;
#endif
}

#pragma warning (default:4035)


BOOL
WinpGetAllocHandleFromStream(
    IN PBYTE Buffer,
    IN PVOID BaseOfBuffer,
    IN PMATCH_BUFFER MatchBuffer,
    IN ULONG Offset,
    IN ULONG * Val
    )

/*++

Routine Description:

    Find the address of the AllocHandle routine. This is done by searching
    through the code of the OpenProcess routine, looking for the third
    call instruction in that function. The third call calls AllocHandle().

Arguments:

    Buffer - Buffer of instructions to search through.

    BaseOfBuffer - The base address of the buffer.

    MatchBuffer - The match buffer to compare against.

    Offset - The offset of call destination.

    Val - A buffer to return the value of AllocHandle.


Return Values:

    TRUE - Success.

    FALSE - Failure.

--*/


{
    UINT i;

    for (i = 0; MatchBuffer [i].Offset != -1; i++) {

        if (Buffer [MatchBuffer[i].Offset] != MatchBuffer[i].Byte) {
            return FALSE;
        }
    }

    //
    // This assumes that the call instruction is a near, relative call (E8).
    // If this is not the case, the calculation below is incorrect.
    //
    // The calculation gives us the destination relative to the next
    // instruction after the call.
    //

    *Val = (ULONG) BaseOfBuffer + Offset + *(PLONG) &Buffer [Offset] + 4;

    return TRUE;
}



ULONG
WinGetModuleSize(
    PVOID Base
    )

/*++

Routine Description:

    Get the SizeOfImage field given the base address of a module.

Return Values:

    SizeOfImage field of the specified module on success.

    NULL on failure.

--*/

{
    ULONG Size;
    PIMAGE_NT_HEADERS NtHeaders;

    NtHeaders = ImageNtHeader ( Base );
    if ( NtHeaders ) {
        Size = NtHeaders->OptionalHeader.SizeOfImage;
    } else {
        Size = 0;
    }

    return Size;
}


BOOL
WinpInitAllocHandle (
    )

/*++

Routine Description:

    Initialize the global variable WxAllocHandle to the value of the Win9x
    internal routine, AllocHandle.

Arguments:

    None

Return Values:

    TRUE - If we were able to successfully obtain a pointer to AllocHandle.

    FALSE - Otherwise.

Comments:

    The client of this routine should verify that this handle is correct by
    calling WxCheckOpenThread() before blindly assuming the pointer is
    correct.

--*/

{
    ULONG i;
    BOOL Succ;
    PVOID OpenProcessPtr;
    ULONG Kernel32Base;
    ULONG Kernel32Size;
    ULONG AllocHandle;
    BYTE Buffer [ 200 ];

    if ( WinpAllocHandle ) {
        return TRUE;
    }

    Kernel32Base = (ULONG) GetModuleHandle ( "kernel32.dll" );
    ASSERT ( Kernel32Base );
    if (!Kernel32Base)
    {
        return FALSE;
    }

    Kernel32Size = WinGetModuleSize ( (PVOID) Kernel32Base );
    ASSERT ( Kernel32Size != 0 );

    OpenProcessPtr = GetProcAddress (
                            (HINSTANCE) Kernel32Base,
                            "OpenProcess"
                            );
    if (!OpenProcessPtr)
    {
        return FALSE;
    }


    //
    // Win9x thunks out functions when a debugger is present. To work around
    // this we undo the thunk when it looks like its been thunked.
    //

    if ( (ULONG) OpenProcessPtr < Kernel32Base ||
         (ULONG) OpenProcessPtr > Kernel32Base + Kernel32Size ) {

        OpenProcessPtr = (PVOID) *(PULONG)( (PBYTE)OpenProcessPtr + 1 );
    }

    if ( (ULONG) OpenProcessPtr < Kernel32Base ||
         (ULONG) OpenProcessPtr > Kernel32Base + Kernel32Size ) {

        return FALSE;
    }


    CopyMemory (Buffer, OpenProcessPtr, sizeof (Buffer));

    //
    // Check the buffer
    //

    for ( i = 0; i < ARRAY_COUNT (SupportedSystems); i++) {

        Succ = WinpGetAllocHandleFromStream (
                            Buffer,
                            OpenProcessPtr,
                            SupportedSystems[i].MatchBuffer,
                            SupportedSystems[i].AllocHandleOffset,
                            &AllocHandle
                            );

        if ( Succ ) {

            //
            // Verify WinpAllocHandle within range of Kernel32.
            //

            if (AllocHandle > Kernel32Base &&
                AllocHandle < Kernel32Base + Kernel32Size) {

                WinpAllocHandle = (ALLOC_HANDLE_ROUTINE) AllocHandle;
                break;
            }
        }
    }

    if ( !Succ ) {
        WinpAllocHandle = NULL;
    }

    return Succ;
}


//
// This value is basically FIELD_OFFSET (TDB, Tib). It is dependent on the
// specific version of the OS (95, 98).
//

#define WIN95_TDB_OFFSET    (0x10)
#define WIN98_TDB_OFFSET    (0x08)

DWORD
WinpGetObfuscator(
    )

/*++

Routine Description:

    Get the Obfuscator DWORD.

Arguments:

    None.

Return Values:

    The Obfuscator or 0 on failure.

Comments:

    This routine depends on internal structures from the Win9x sources. If
    another major revision of windows changes many of these structures, this
    function may break.

--*/

{
    ULONG Tib;
    ULONG Type;
    ULONG Major;


    if (WinpObfuscator != 0) {
        return WinpObfuscator;
    }

    GenGetSystemType (&Type, &Major, NULL, NULL, NULL);

    ASSERT ( Type == Win9x );

    Tib = (DWORD)WinpGetCurrentTib ();

    if ( Major == 95 ) {

        WinpObfuscator = (GetCurrentThreadId () ^ (Tib - WIN95_TDB_OFFSET));

    } else {

        //
        // If a windows-based system that is not 95 or 98 comes along,
        // we should make sure the WINxx_TDB_OFFSET is correct.
        //

        ASSERT ( Major == 98 );
        WinpObfuscator = (GetCurrentThreadId () ^ (Tib - WIN98_TDB_OFFSET));
    }

    return WinpObfuscator;
}


LPVOID
WinpTidToTDB(
    IN DWORD ThreadId
    )
{
    return (PVOID) (ThreadId ^ WinpGetObfuscator ());
}

LPVOID
WinpGetCurrentPdb(
    )
{
    return (LPVOID) (GetCurrentProcessId () ^ WinpGetObfuscator ());
}

HANDLE
WinpOpenThreadInternal(
    DWORD dwAccess,
    BOOL bInheritHandle,
    DWORD ThreadId
    )
{
    HANDLE hThread;
    PVOID ThreadObj;

    ASSERT (WinpAllocHandle);

    //
    // Convert the ThreadId to a Thread Object
    //

    ThreadObj = WinpTidToTDB (ThreadId);

    if (ThreadObj == NULL) {
        return NULL;
    }

    //
    // NB: we do not check that the handle really is a thread handle.
    // The type varies from version to version of the OS, so it is not
    // correct to check it.
    //

    try {

        hThread = WinpAllocHandle (
                            WinpGetCurrentPdb (),
                            ThreadObj,
                            dwAccess
                            );
    }

    except (EXCEPTION_EXECUTE_HANDLER) {

        hThread = NULL;
    }

    if (hThread == (HANDLE) (-1)) {
        hThread = NULL;
    }

    return hThread;
}


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
WINAPI
WinpCheckThread(
    PVOID unused
    )
{
    for (;;) {
    }

    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif



BOOL
WinpCheckOpenThread(
    )

/*++

Routine Description:

    Check that WxOpenThread actually works.

Arguments:

    None.

Return Values:

    TRUE - If WxOpenThread works properly.

    FALSE - Otherwise.

--*/

{

    BOOL Succ;
    HANDLE hThread1;
    HANDLE hThread2;
    DWORD ThreadId;
    CONTEXT Context1;
    CONTEXT Context2;
    LONG SuspendCount;


    SuspendCount = 0;
    hThread1 = NULL;
    hThread2 = NULL;


    hThread1 = CreateThread (NULL,
                      0,
                      WinpCheckThread,
                      0,
                      0,
                      &ThreadId
                      );

    if ( hThread1 == NULL ) {
        return FALSE;
    }

    hThread2 = WinpOpenThreadInternal (
                        THREAD_ALL_ACCESS,
                        FALSE,
                        ThreadId
                        );

    if ( hThread2 == NULL ) {
        Succ = FALSE;
        goto Exit;
    }

    Succ = TRUE;
    try {

        //
        // First we check that we can suspend the thread. If that is
        // successful, then get the context using the read thread
        // handle and the newly opened thread handle and check that
        // they are the same.
        //

        SuspendCount = SuspendThread ( hThread2 );

        if ( SuspendCount == -1 ) {
            Succ = FALSE;
            leave;
        }

        Context1.ContextFlags = CONTEXT_FULL;
        Succ = GetThreadContext ( hThread2, &Context1 );

        if ( !Succ ) {
            leave;
        }

        Context2.ContextFlags = CONTEXT_FULL;
        Succ = GetThreadContext ( hThread1, &Context2 );

        if ( !Succ ) {
            leave;
        }

        if ( Context1.Eip != Context2.Eip ) {
            Succ = FALSE;
            leave;
        }
    }

    except ( EXCEPTION_EXECUTE_HANDLER ) {

        Succ = FALSE;
    }

Exit:

    if ( SuspendCount > 0 ) {
        ResumeThread ( hThread2 );
    }

    TerminateThread ( hThread1, 0xDEAD );

    if ( hThread1 ) {
        CloseHandle ( hThread1 );
    }

    if ( hThread2 ) {
        CloseHandle ( hThread2 );
    }

    return Succ;
}


BOOL
WinInitialize(
    )
{
    if ( WinpAllocHandle == NULL ) {

        if (!WinpInitAllocHandle ()) {
            SetLastError (ERROR_NOT_SUPPORTED);
            return FALSE;
        }

        if (!WinpCheckOpenThread ()) {
            SetLastError (ERROR_NOT_SUPPORTED);
            return FALSE;
        }
    }

    return TRUE;

}

VOID
WinFree(
    )
{
    WinpAllocHandle = NULL;
    WinpObfuscator = 0;

}

HANDLE
WINAPI
WinOpenThread(
    DWORD dwAccess,
    BOOL bInheritHandle,
    DWORD ThreadId
    )

/*++

Routine Description:

    Obtain a thread handle from a thread id on Win9x platform.x

Arguments:

    dwAccess - Thread access requested.

    bInheritHandle - ALWAYS IGNORED.

    ThreadId - The identifier of the thread for which a handle is to
            be returned.

Return Values:

    A handle to the open thread on success or NULL on failure.

--*/

{
    HANDLE Handle;

    //
    // It is necessary to call WinInitialize() before calling this function.
    // If this was not called, return failure.
    //

    if ( WinpAllocHandle == NULL ) {

        SetLastError ( ERROR_DLL_INIT_FAILED );
        return FALSE;
    }

    Handle = WinpOpenThreadInternal (
                    dwAccess,
                    bInheritHandle,
                    ThreadId
                    );

    return Handle;
}

#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\minidump\libonly\mprivate.h ===
/* By defining DBGHELP_SOURCE we prevent circular
   logic.  This way dbghelp won't try to call minidump.lib and then
   have minidump.lib try to load dbghelp for the minidump functions
*/

// #define _DBGHELP_SOURCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\msi\makefile.inc ===
i386\dbgx.msi: dbgx_idts\*.idt dbgx_idts\binary\* dbgx_idts\i386\*.idt 
    createdbgxmsi.cmd dbgx.msi

ia64\dbgx.msi: dbgx_idts\*.idt dbgx_idts\binary\* dbgx_idts\ia64\*.idt
    createdbgxmsi.cmd dbgx.msi

i386\dbgemx.msm: dbgemx_idts\*.idt
    createdbgxmsi.cmd dbgemx.msm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\addr.cpp ===
//----------------------------------------------------------------------------
//
// General ADDR routines.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

SHORT g_LastSelector = -1;
ULONG64 g_LastBaseOffset;

void
dprintAddr(
    PADDR paddr
    )
{
    switch (paddr->type & (~(FLAT_COMPUTED | INSTR_POINTER)))
    {
    case ADDR_V86:
    case ADDR_16:
        dprintf("%04x:%04x ", paddr->seg, (USHORT)paddr->off);
        break;
    case ADDR_1632:
        dprintf("%04x:%08lx ", paddr->seg, (ULONG)paddr->off);
        break;
    case ADDR_1664:
        dprintf("%04x:%s ", paddr->seg, FormatAddr64(paddr->off));
        break;
    case ADDR_FLAT:
        dprintf("%s ", FormatAddr64(paddr->off));
        break;
    }
}

void
sprintAddr(
    PSTR *buffer,
    PADDR paddr
    )
{
    switch (paddr->type & (~(FLAT_COMPUTED | INSTR_POINTER)))
    {
    case ADDR_V86:
    case ADDR_16:
        sprintf(*buffer,"%04x:%04x ", paddr->seg, (USHORT)paddr->off);
        break;
    case ADDR_1632:
        sprintf(*buffer,"%04x:%08lx ", paddr->seg, (ULONG)paddr->off);
        break;
    case ADDR_1664:
        sprintf(*buffer,"%04x:%s ",
                paddr->seg, FormatAddr64(paddr->off));
        break;
    case ADDR_FLAT:
        sprintf(*buffer,"%s ", FormatAddr64(paddr->off));
        break;
    }
    while (**buffer)
    {
        (*buffer)++;
    }
}

void
MaskOutAddr(ULONG Mask, PADDR Addr)
{
    switch(Addr->type & (~(FLAT_COMPUTED | INSTR_POINTER)))
    {
    case ADDR_V86:
    case ADDR_16:
        MaskOut(Mask, "%04x:%04x ", Addr->seg, (USHORT)Addr->off);
        break;
    case ADDR_1632:
        MaskOut(Mask, "%04x:%08lx ", Addr->seg, (ULONG)Addr->off);
        break;
    case ADDR_1664:
        MaskOut(Mask, "%04x:%s ", Addr->seg, FormatAddr64(Addr->off));
        break;
    case ADDR_FLAT:
        MaskOut(Mask, "%s ", FormatAddr64(Addr->off));
        break;
    }
}

void
ComputeNativeAddress (
    PADDR paddr
    )
{
    switch (paddr->type & (~(FLAT_COMPUTED | INSTR_POINTER)))
    {
    case ADDR_V86:
        paddr->off = Flat(*paddr) - ((ULONG)paddr->seg << 4);
        if (paddr->off > 0xffff)
        {
            ULONG64 excess = 1 + ((paddr->off - 0xffffL) >> 4);
            paddr->seg  += (USHORT)excess;
            paddr->off  -= excess << 4;
        }
        break;

    case ADDR_16:
    case ADDR_1632:
    case ADDR_1664:
        DESCRIPTOR64 desc;

        if (paddr->seg != g_LastSelector)
        {
            g_LastSelector = paddr->seg;
            g_Target->GetSelDescriptor
                (g_Machine, g_CurrentProcess->CurrentThread->Handle,
                 paddr->seg, &desc);
            g_LastBaseOffset = desc.Base;
        }
        paddr->off = Flat(*paddr) - g_LastBaseOffset;
        break;

    case ADDR_FLAT:
        paddr->off = Flat(*paddr);
        break;

    default:
        return;
    }
}

void
ComputeFlatAddress (
    PADDR paddr,
    PDESCRIPTOR64 pdesc
    )
{
    if (paddr->type & FLAT_COMPUTED)
    {
        return;
    }

    switch (paddr->type & (~INSTR_POINTER))
    {
    case ADDR_V86:
        paddr->off &= 0xffff;
        Flat(*paddr) = ((ULONG)paddr->seg << 4) + paddr->off;
        break;

    case ADDR_16:
        paddr->off &= 0xffff;

    case ADDR_1632:
    case ADDR_1664:
        DESCRIPTOR64 desc;
        ULONG64 Base;

        if (pdesc != NULL)
        {
            Base = pdesc->Base;
        }
        else
        {
            if (paddr->seg != g_LastSelector)
            {
                g_LastSelector = paddr->seg;
                g_Target->GetSelDescriptor
                    (g_Machine, g_CurrentProcess->CurrentThread->Handle,
                     paddr->seg, pdesc = &desc);
                g_LastBaseOffset = pdesc->Base;
            }

            Base = g_LastBaseOffset;
        }
        
        if ((paddr->type & (~INSTR_POINTER)) != ADDR_1664)
        {
            Flat(*paddr) = EXTEND64((ULONG)paddr->off + (ULONG)Base);
        }
        else
        {
            Flat(*paddr) = paddr->off + Base;
        }
        break;

    case ADDR_FLAT:
        Flat(*paddr) = paddr->off;
        break;

    default:
        return;
    }

    paddr->type |= FLAT_COMPUTED;
}

PADDR
AddrAdd(
    PADDR paddr,
    ULONG64 scalar
    )
{
    if (fnotFlat(*paddr))
    {
        ComputeFlatAddress(paddr, NULL);
    }

    Flat(*paddr) += scalar;
    paddr->off += scalar;
    
    switch (paddr->type & (~(FLAT_COMPUTED | INSTR_POINTER)))
    {
    case ADDR_V86:
        paddr->off = Flat(*paddr) - EXTEND64((ULONG)paddr->seg << 4);
        if (paddr->off > 0xffff)
        {
            ULONG64 excess = 1 + ((paddr->off - 0x10000) >> 4);
            paddr->seg += (USHORT)excess;
            paddr->off -= excess << 4;
        }
        break;

    case ADDR_16:
        if (paddr->off > 0xffff)
        {
            Flat(*paddr) -= paddr->off & ~0xffff;
            paddr->off &= 0xffff;
        }
        break;
        
    case ADDR_1632:
        if (paddr->off > 0xffffffff)
        {
            Flat(*paddr) -= paddr->off & ~0xffffffff;
            paddr->off &= 0xffffffff;
        }
        break;
    }
    
    return paddr;
}

PADDR
AddrSub(
    PADDR paddr,
    ULONG64 scalar
    )
{
    if (fnotFlat(*paddr))
    {
        ComputeFlatAddress(paddr, NULL);
    }

    Flat(*paddr) -= scalar;
    paddr->off -= scalar;

    switch (paddr->type & (~(FLAT_COMPUTED | INSTR_POINTER)))
    {
    case ADDR_V86:
        paddr->off = Flat(*paddr) - EXTEND64((ULONG)paddr->seg << 4);
        if (paddr->off > 0xffff)
        {
            ULONG64 excess = 1 + ((0xffffffffffffffffUI64 - paddr->off) >> 4);
            paddr->seg -= (USHORT)excess;
            paddr->off += excess << 4;
        }
        break;

    case ADDR_16:
        if (paddr->off > 0xffff)
        {
            Flat(*paddr) -= paddr->off & ~0xffff;
            paddr->off &= 0xffff;
        }
        break;
        
    case ADDR_1632:
        if (paddr->off > 0xffffffff)
        {
            Flat(*paddr) -= paddr->off & ~0xffffffff;
            paddr->off &= 0xffffffff;
        }
        break;
    }
    
    return paddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\addr.h ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef _ADDR_H_
#define _ADDR_H_

typedef struct _ADDR
{
    USHORT    type;
    USHORT    seg;
    ULONG64   off;
    ULONG64   flat;
} ADDR, *PADDR;

#define ADDRFLAT(paddr, x) {           \
    (paddr)->type = ADDR_FLAT;         \
    (paddr)->seg  = 0;                 \
    (paddr)->off  = (x);               \
    ComputeFlatAddress((paddr), NULL); \
}


#define ADDR_NONE       ((USHORT)0)
#define ADDR_UNKNOWN    ((USHORT)0x0001)
#define ADDR_V86        ((USHORT)0x0002)
#define ADDR_16         ((USHORT)0x0004)
#define ADDR_FLAT       ((USHORT)0x0008)
#define ADDR_1632       ((USHORT)0x0010)
#define FLAT_COMPUTED   ((USHORT)0x0020)
#define INSTR_POINTER   ((USHORT)0x0040)
#define ADDR_1664       ((USHORT)0x0080)
#define NO_DEFAULT      0xFFFF
#define fnotFlat(x)     (!(((x).type)&FLAT_COMPUTED))
#define fFlat(x)        (((x).type)&FLAT_COMPUTED)
#define fInstrPtr(x)    (((x).type)&INSTR_POINTER)
#define AddrEqu(x,y)    ((x).flat == (y).flat)
#define AddrLt(x,y)     ((x).flat < (y).flat)
#define AddrGt(x,y)     ((x).flat > (y).flat)
#define AddrDiff(x,y)   ((x).flat - (y).flat)
#define Flat(x)         ((x).flat)
#define Off(x)          ((x).off)
#define Type(x)         ((x).type)
#define NotFlat(x)      ((x).type&=~FLAT_COMPUTED)

extern SHORT g_LastSelector;
extern ULONG64 g_LastBaseOffset;

extern void  ComputeFlatAddress(PADDR, PDESCRIPTOR64);
extern void  ComputeNativeAddress(PADDR);

extern PADDR AddrAdd(PADDR, ULONG64);
extern PADDR AddrSub(PADDR, ULONG64);

extern
void dprintAddr(
    IN PADDR paddr
    );

void
sprintAddr(
    IN OUT PSTR *buffer,
    IN PADDR paddr
    );

void MaskOutAddr(ULONG Mask, PADDR Addr);

#endif // #ifndef _ADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntdbgsrv\dbgsrv.cpp ===
//----------------------------------------------------------------------------
//
// Starts a process server and sleeps forever.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _ADVAPI32_
#define _KERNEL32_
#include <windows.h>
#define INITGUID
#include <objbase.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>

#include <cmnutil.hpp>
#include <dllimp.h>
#include <dbgrpc.hpp>
#include <dbgsvc.h>
#include <dbgsvc.hpp>

// The .CRT section is generated when static intializers,
// such as global class instances, exist.  It needs to
// be merged into .data to avoid a linker warning.
#pragma comment(linker, "/merge:.CRT=.data")

void DECLSPEC_NORETURN
PanicVa(HRESULT Status, char* Format, va_list Args)
{
    char Msg[256];

    _vsnprintf(Msg, sizeof(Msg), Format, Args);
    DbgPrint("Error 0x%08X: %s\n", Status, Msg);
    NtTerminateProcess(NtCurrentProcess(), (NTSTATUS)Status);
}

void DECLSPEC_NORETURN
Panic(HRESULT Status, char* Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    PanicVa(Status, Format, Args);
    va_end(Args);
}

#if DBG
void
DbgAssertionFailed(PCSTR File, int Line, PCSTR Str)
{
    Panic(E_FAIL, "Assertion failed: %s(%d)\n  %s\n",
          File, Line, Str);
}
#endif

//----------------------------------------------------------------------------
//
// Proxy and stub support.
//
//----------------------------------------------------------------------------

// Generated headers.
#include "dbgsvc_p.hpp"
#include "dbgsvc_s.hpp"

void
DbgRpcInitializeClient(void)
{
    DbgRpcInitializeStubTables_dbgsvc(DBGRPC_SIF_DBGSVC_FIRST);
}
    
DbgRpcStubFunction
DbgRpcGetStub(USHORT StubIndex)
{
    USHORT If = (USHORT) DBGRPC_STUB_INDEX_INTERFACE(StubIndex);
    USHORT Mth = (USHORT) DBGRPC_STUB_INDEX_METHOD(StubIndex);
    DbgRpcStubFunctionTable* Table;

    if (If >= DBGRPC_SIF_DBGSVC_FIRST &&
        If >= DBGRPC_SIF_DBGSVC_LAST)
    {
        Table = g_DbgRpcStubs_dbgsvc;
        If -= DBGRPC_SIF_DBGSVC_FIRST;
    }
    else
    {
        return NULL;
    }
    if (Mth >= Table[If].Count)
    {
        return NULL;
    }

    return Table[If].Functions[Mth];
}

#if DBG
PCSTR
DbgRpcGetStubName(USHORT StubIndex)
{
    USHORT If = (USHORT) DBGRPC_STUB_INDEX_INTERFACE(StubIndex);
    USHORT Mth = (USHORT) DBGRPC_STUB_INDEX_METHOD(StubIndex);
    DbgRpcStubFunctionTable* Table;
    PCSTR** Names;

    if (If >= DBGRPC_SIF_DBGSVC_FIRST &&
        If >= DBGRPC_SIF_DBGSVC_LAST)
    {
        Table = g_DbgRpcStubs_dbgsvc;
        Names = g_DbgRpcStubNames_dbgsvc;
        If -= DBGRPC_SIF_DBGSVC_FIRST;
    }
    else
    {
        return "!InvalidInterface!";
    }
    if (Mth >= Table[If].Count)
    {
        return "!InvalidStubIndex!";
    }

    return Names[If][Mth];
}
#endif // #if DBG

HRESULT
DbgRpcPreallocProxy(REFIID InterfaceId, PVOID* Interface,
                    DbgRpcProxy** Proxy, PULONG IfUnique)
{
    return DbgRpcPreallocProxy_dbgsvc(InterfaceId, Interface,
                                      Proxy, IfUnique);
}

void
DbgRpcDeleteProxy(class DbgRpcProxy* Proxy)
{
    // All proxies used here are similar simple single
    // vtable proxy objects so IDebugClient can represent them all.
    delete (ProxyIUserDebugServices*)Proxy;
}

HRESULT
DbgRpcServerThreadInitialize(void)
{
    // Nothing to do.
    return S_OK;
}

void
DbgRpcServerThreadUninitialize(void)
{
    // Nothing to do.
}

void
DbgRpcError(char* Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    PanicVa(E_FAIL, Format, Args);
    va_end(Args);
}

DBGRPC_SIMPLE_FACTORY(LiveUserDebugServices, __uuidof(IUserDebugServices), \
                      "Remote Process Server", (TRUE))
LiveUserDebugServicesFactory g_LiveUserDebugServicesFactory;

#ifdef  _M_IA64

#pragma section(".CRT$XCA",long,read)
#pragma section(".CRT$XCZ",long,read)
#pragma section(".CRT$XIA",long,read)
#pragma section(".CRT$XIZ",long,read)

#define _CRTALLOC(x) __declspec(allocate(x))

#else   /* ndef _M_IA64 */

#define _CRTALLOC(x)

#endif  /* ndef _M_IA64 */

typedef void (__cdecl *_PVFV)(void);

extern "C"
{

// C initializers collect here.
#pragma data_seg(".CRT$XIA")
_CRTALLOC(".CRT$XIA") _PVFV __xi_a[] = { NULL };
#pragma data_seg(".CRT$XIZ")
_CRTALLOC(".CRT$XIZ") _PVFV __xi_z[] = { NULL };
    
// C++ initializers collect here.
#pragma data_seg(".CRT$XCA")
_CRTALLOC(".CRT$XCA") _PVFV __xc_a[] = { NULL };
#pragma data_seg(".CRT$XCZ")
_CRTALLOC(".CRT$XCZ") _PVFV __xc_z[] = { NULL };

};

void __cdecl
_initterm (_PVFV * pfbegin, _PVFV * pfend)
{
    /*
     * walk the table of function pointers from the bottom up, until
     * the end is encountered.  Do not skip the first entry.  The initial
     * value of pfbegin points to the first valid entry.  Do not try to
     * execute what pfend points to.  Only entries before pfend are valid.
     */
    while ( pfbegin < pfend )
    {
        /*
         * if current table entry is non-NULL, call thru it.
         */
        if ( *pfbegin != NULL )
        {
            (**pfbegin)();
        }
        ++pfbegin;
    }
}

void __cdecl
main(int Argc, char** Argv)
{
    PSTR AppName;
    PSTR Options;
    HRESULT Status;

    // Manually invoke C and C++ initializers.
    _initterm( __xi_a, __xi_z );
    _initterm( __xc_a, __xc_z );

    AppName = Argv[0];
    
    while (--Argc > 0)
    {
        Argv++;

        break;
    }

    if (Argc != 1)
    {
        Panic(E_INVALIDARG, "Usage: dbgsrv <transport>");
    }

    Options = *Argv;

    DbgPrint("Running %s with '%s'\n", AppName, Options);

    if ((Status = InitDynamicCalls(&g_NtDllCallsDesc)) != S_OK)
    {
        Panic(Status, "InitDynamicCalls");
    }
    
    ULONG Flags;
    
    if ((Status = g_LiveUserDebugServices.Initialize(&Flags)) != S_OK)
    {
        Panic(Status, "LiveUserDebugServices::Initialize");
    }
    
    if ((Status = DbgRpcCreateServer(Options,
                                     &g_LiveUserDebugServicesFactory)) != S_OK)
    {
        Panic(Status, "StartProcessServer");
    }

    for (;;)
    {
        Sleep(1000);
            
        if (g_UserServicesUninitialized)
        {
            break;
        }
    }

    DbgRpcDeregisterServers();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\alpha_asm.cpp ===
//----------------------------------------------------------------------------
//
// Assembe Alpha machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include "alpha_dis.h"
#include "alpha_optable.h"
#include "alpha_strings.h"

#define OPSIZE 16

BOOL TestCharacter (PSTR inString, PSTR *outString, CHAR ch);
ULONG GetIntReg(PSTR, PSTR *);
ULONG GetFltReg(PSTR, PSTR *);

LONG
GetValue (
    PSTR inString,
    PSTR *outString,
    BOOL fSigned,
    ULONG bitsize
    );

PSTR SkipWhite(PSTR *);
ULONG GetToken(PSTR, PSTR *, PSTR, ULONG);


ULONG ParseIntMemory(PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseFltMemory(PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseMemSpec(PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseJump(PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseIntBranch(PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseFltBranch(PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseIntOp(PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParsePal(PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseUnknown(PSTR, PSTR *, POPTBLENTRY, PULONG64);




/*** assem - assemble instruction
*
*   Purpose:
*       To assemble the instruction pointed by *poffset.
*
*   Input:
*       pchInput - pointer to string to assemble
*
*   Output:
*       *poffset - pointer to ADDR at which to assemble
*
*   Exceptions:
*       error exit:
*               BADOPCODE - unknown or bad opcode
*               OPERAND - bad operand
*               ALIGNMENT - bad byte alignment in operand
*               DISPLACEMENT - overflow in displacement computation
*               BADREG - bad register name
*               EXTRACHARS - extra characters after legal instruction
*               MEMORY - write failure on assembled instruction
*
*   Notes:
*       errors are handled by the calling program by outputting
*       the error string and reprompting the user for the same
*       instruction.
*
*************************************************************************/

void
AlphaMachineInfo::Assemble (PADDR poffset, PSTR pchInput)
{
    CHAR    szOpcode[OPSIZE];
    ULONG   instruction;

    POPTBLENTRY pEntry;

//
// Using the mnemonic token, find the entry in the assembler's
// table for the associated instruction.
//

    if (GetToken(pchInput, &pchInput, szOpcode, OPSIZE) == 0)
        error(BADOPCODE);


    if ((pEntry = findStringEntry(szOpcode)) == (POPTBLENTRY) -1)
        error(BADOPCODE);

    if (pEntry->eType == INVALID_ETYPE) {
        error(BADOPCODE);
    }
//
// Use the instruction format specific parser to encode the
// instruction plus its operands.
//

    instruction = (*pEntry->parsFunc)
        (pchInput, &pchInput, pEntry, &(Flat(*poffset)));

//
// Store the instruction into the target memory location and
// increment the instruction pointer.
//

    if (SetMemString(poffset, &instruction, 4) != 4) {
        error(MEMORY);
    }

    Flat(*poffset) += sizeof(ULONG);
    Off(*poffset) += sizeof(ULONG);
}


BOOL
TestCharacter (PSTR inString, PSTR *outString, CHAR ch)
{

    inString = SkipWhite(&inString);
    if (ch == *inString) {
        *outString = inString+1;
        return TRUE;
        }
    else {
        *outString = inString;
        return FALSE;
        }
}


/*** GetIntReg - get integer register number
 *** GetFltReg - get floating register number
*
*   Purpose:
*       From reading the input stream, return the register number.
*
*   Input:
*       inString - pointer to input string
*
*   Output:
*       *outString - pointer to character after register token in input stream
*
*   Returns:
*       register number
*
*   Exceptions:
*       error(BADREG) - bad register name
*
*************************************************************************/

PCHAR regNums[] = {
         "$0",  "$1",  "$2",  "$3",  "$4",  "$5",  "$6",  "$7",
         "$8",  "$9", "$10", "$11", "$12", "$13", "$14", "$15",
        "$16", "$17", "$18", "$19", "$20", "$21", "$22", "$23",
        "$24", "$25", "$26", "$27", "$28", "$29", "$30", "$31"
        };

PCHAR intRegNames[] = {
         g_R0,  g_R1,  g_R2,  g_R3,  g_R4,  g_R5,  g_R6,  g_R7,
         g_R8,  g_R9, g_R10, g_R11, g_R12, g_R13, g_R14, g_R15,
        g_R16, g_R17, g_R18, g_R19, g_R20, g_R21, g_R22, g_R23,
        g_R24, g_R25, g_R26, g_R27, g_R28, g_R29, g_R30, g_R31
        };

PCHAR fltRegNames[] = {
         g_F0,  g_F1,  g_F2,  g_F3,  g_F4,  g_F5,  g_F6,  g_F7,
         g_F8,  g_F9, g_F10, g_F11, g_F12, g_F13, g_F14, g_F15,
        g_F16, g_F17, g_F18, g_F19, g_F20, g_F21, g_F22, g_F23,
        g_F24, g_F25, g_F26, g_F27, g_F28, g_F29, g_F30, g_F31
        };

ULONG
GetIntReg (PSTR inString, PSTR *outString)
{
    CHAR   szRegOp[5];
    ULONG   index;

    if (!GetToken(inString, outString, szRegOp, sizeof(szRegOp)))
        error(BADREG);

    if (szRegOp[0] == '$') {
        //
        // use numbers
        //
        for (index = 0; index < 32; index++) {
            if (!strcmp(szRegOp, regNums[index]))
                return index;
        }
    } else {
        //
        // use names
        //
        for (index = 0; index < 32; index++) {
            if (!strcmp(szRegOp, intRegNames[index]))
                return index;
        }
    }
    error(BADREG);
    return 0;
}

ULONG
GetFltReg (PSTR inString, PSTR *outString)
{
    CHAR   szRegOp[5];
    ULONG   index;

    if (!GetToken(inString, outString, szRegOp, sizeof(szRegOp)))
        error(BADREG);

    if (szRegOp[0] == '$') {
        //
        // use numbers
        //
        for (index = 0; index < 32; index++) {
            if (!strcmp(szRegOp, regNums[index]))
                return index;
        }
    } else {
        //
        // use names
        //
        for (index = 0; index < 32; index++) {
            if (!strcmp(szRegOp, fltRegNames[index]))
                return index;
        }
    }

    error(BADREG);
    return 0;
}


/*** GetValue - get value from command line
*
*   Purpose:
*       Use GetExpression to evaluate the next expression in the input
*       stream.
*
*   Input:
*       inString - pointer to input stream
*       fSigned - TRUE if signed value
*                 FALSE if unsigned value
*       bitsize - size of value allowed
*
*   Output:
*       outString - character after the last character of the expression
*
*   Returns:
*       value computed from input stream
*
*   Exceptions:
*       error exit: OVERFLOW - value too large for bitsize
*
*************************************************************************/

LONG
GetValue (
    PSTR inString,
    PSTR *outString,
    BOOL fSigned,
    ULONG bitsize
    )
{
    ULONGLONG   value;

    inString = SkipWhite(&inString);
    g_CurCmd = inString;
    value = GetExpression();
    *outString = g_CurCmd;

    if ((value > (ULONG)(1L << bitsize) - 1) &&
            (!fSigned || (value < (ULONG)(-1L << (bitsize - 1))))) {
        error(OVERFLOW);
    }

    return (LONG)value;
}


/*** SkipWhite - skip white-space
*
*   Purpose:
*       To advance g_CurCmd over any spaces or tabs.
*
*   Input:
*       *g_CurCmd - present command line position
*
*************************************************************************/

PSTR
SkipWhite (PSTR * string)
{
    while (**string == ' ' || **string == '\t')
        (*string)++;

    return(*string);
}


/*** GetToken - get token from command line
*
*   Purpose:
*       Build a lower-case mapped token of maximum size maxcnt
*       at the string pointed by *psz.  Token consist of the
*       set of characters a-z, A-Z, 0-9, $, and underscore.
*
*   Input:
*       *inString - present command line position
*       maxcnt - maximum size of token allowed
*
*   Output:
*       *outToken - token in lower case
*       *outString - pointer to first character beyond token in input
*
*   Returns:
*       size of token if under maximum else 0
*
*   Notes:
*       if string exceeds maximum size, the extra characters
*       are still processed, but ignored.
*
*************************************************************************/

ULONG
GetToken (PSTR inString, PSTR *outString, PSTR outToken, ULONG maxcnt)
{
    CHAR   ch;
    ULONG   count = 0;

    inString = SkipWhite(&inString);

    while (count < maxcnt) {
        ch = (CHAR)tolower(*inString);

        if (!((ch >= '0' && ch <= '9') ||
              (ch >= 'a' && ch <= 'z') ||
              (ch == '$') ||
              (ch == '_') ||
              (ch == '#')))
                break;

        count++;
        *outToken++ = ch;
        inString++;
        }

    *outToken = '\0';
    *outString = inString;

    return (count >= maxcnt ? 0 : count);
}


/*** ParseIntMemory - parse integer memory instruction
*
*   Purpose:
*       Given the users input, create the memory instruction.
*
*   Input:
*       *inString - present input position
*       pEntry - pointer into the asmTable for this instr type
*
*   Output:
*       *outstring - update input position
*
*   Returns:
*       the instruction.
*
*   Format:
*       op Ra, disp(Rb)
*
*************************************************************************/

ULONG
ParseIntMemory(
    PSTR inString,
    PSTR *outString,
    POPTBLENTRY pEntry,
    PULONG64 poffset
    )
{
    ULONG instruction;
    ULONG Ra;
    ULONG Rb;
    ULONG disp;

    Ra = GetIntReg(inString, &inString);

    if (!TestCharacter(inString, &inString, ','))
        error(OPERAND);

    disp = GetValue(inString, &inString, TRUE, WIDTH_MEM_DISP);

    if (!TestCharacter(inString, &inString, '('))
        error(OPERAND);

    Rb = GetIntReg(inString, &inString);

    if (!TestCharacter(inString, &inString, ')'))
        error(OPERAND);

    if (!TestCharacter(inString, &inString, '\0'))
        error(EXTRACHARS);

    instruction = OPCODE(pEntry->opCode) +
                  REG_A(Ra) +
                  REG_B(Rb) +
                  MEM_DISP(disp);

    return(instruction);
}

/*** ParseFltMemory - parse floating point memory instruction
*
*   Purpose:
*       Given the users input, create the memory instruction.
*
*   Input:
*       *inString - present input position
*       pEntry - pointer into the asmTable for this instr type
*
*   Output:
*       *outstring - update input position
*
*   Returns:
*       the instruction.
*
*   Format:
*       op Fa, disp(Rb)
*
*************************************************************************/

ULONG
ParseFltMemory(PSTR inString,
               PSTR *outString,
               POPTBLENTRY pEntry,
               PULONG64 poffset)
{
    ULONG instruction;
    ULONG Fa;
    ULONG Rb;
    ULONG disp;

    Fa = GetFltReg(inString, &inString);

    if (!TestCharacter(inString, &inString, ','))
        error(OPERAND);

    disp = (ULONG)GetValue(inString, &inString, TRUE, WIDTH_MEM_DISP);

    if (!TestCharacter(inString, &inString, '('))
        error(OPERAND);

    Rb = GetIntReg(inString, &inString);

    if (!TestCharacter(inString, &inString, ')'))
        error(OPERAND);

    if (!TestCharacter(inString, &inString, '\0'))
        error(EXTRACHARS);

    instruction = OPCODE(pEntry->opCode) +
                  REG_A(Fa) +
                  REG_B(Rb) +
                  MEM_DISP(disp);

    return(instruction);
}

/*** ParseMemSpec - parse special memory instruction
*
*   Purpose:
*       Given the users input, create the memory instruction.
*
*   Input:
*       *inString - present input position
*       pEntry - pointer into the asmTable for this instr type
*
*   Output:
*       *outstring - update input position
*
*   Returns:
*       the instruction.
*
*   Format:
*       op
*
*************************************************************************/
ULONG ParseMemSpec(PSTR inString,
                   PSTR *outString,
                   POPTBLENTRY pEntry,
                   PULONG64 poffset)
{
    return(OPCODE(pEntry->opCode) +
           MEM_FUNC(pEntry->funcCode));
}

/*** ParseJump - parse jump instruction
*
*   Purpose:
*       Given the users input, create the memory instruction.
*
*   Input:
*       *inString - present input position
*       pEntry - pointer into the asmTable for this instr type
*
*   Output:
*       *outstring - update input position
*
*   Returns:
*       the instruction.
*
*   Format:
*       op Ra,(Rb),hint
*       op Ra,(Rb)       - not really - we just support it in ntsd
*
*************************************************************************/

ULONG ParseJump(PSTR inString,
                PSTR *outString,
                POPTBLENTRY pEntry,
                PULONG64 poffset)
{
    ULONG instruction;
    ULONG Ra;
    ULONG Rb;
    ULONG hint;

    Ra = GetIntReg(inString, &inString);

    if (!TestCharacter(inString, &inString, ','))
        error(OPERAND);

    if (!TestCharacter(inString, &inString, '('))
        error(OPERAND);

    Rb = GetIntReg(inString, &inString);

    if (!TestCharacter(inString, &inString, ')'))
        error(OPERAND);

    if (TestCharacter(inString, &inString, ',')) {
        //
        // User is giving us a hint
        //
        hint = GetValue(inString, &inString, TRUE, WIDTH_HINT);
    } else {
        hint = 0;
    }

    if (!TestCharacter(inString, &inString, '\0'))
        error(EXTRACHARS);

    instruction = OPCODE(pEntry->opCode) +
                  JMP_FNC(pEntry->funcCode) +
                  REG_A(Ra) +
                  REG_B(Rb) +
                  HINT(hint);

    return(instruction);
}

/*** ParseIntBranch - parse integer branch instruction
*
*   Purpose:
*       Given the users input, create the memory instruction.
*
*   Input:
*       *inString - present input position
*       pEntry - pointer into the asmTable for this instr type
*
*   Output:
*       *outstring - update input position
*
*   Returns:
*       the instruction.
*
*   Format:
*       op Ra,disp
*
*************************************************************************/

ULONG ParseIntBranch(PSTR inString,
                     PSTR *outString,
                     POPTBLENTRY pEntry,
                     PULONG64 poffset)
{
    ULONG instruction;
    ULONG Ra;
    LONG disp;

    Ra = GetIntReg(inString, &inString);

    if (!TestCharacter(inString, &inString, ','))
        error(OPERAND);

    //
    // the user gives an absolute address; we convert
    // that to a displacement, which is computed as a
    // difference off of (pc+1)
    // GetValue handles both numerics and symbolics
    //
    disp = GetValue(inString, &inString, TRUE, 32);

    // get the relative displacement from the updated pc
    disp = disp - (LONG)((*poffset)+4);

    // divide by four
    disp = disp >> 2;

    if (!TestCharacter(inString, &inString, '\0'))
        error(EXTRACHARS);

    instruction = OPCODE(pEntry->opCode) +
                  REG_A(Ra) +
                  BR_DISP(disp);

    return(instruction);
}


/*** ParseFltBranch - parse floating point branch instruction
*
*   Purpose:
*       Given the users input, create the memory instruction.
*
*   Input:
*       *inString - present input position
*       pEntry - pointer into the asmTable for this instr type
*
*   Output:
*       *outstring - update input position
*
*   Returns:
*       the instruction.
*
*   Format:
*       op Fa,disp
*
*************************************************************************/
ULONG ParseFltBranch(PSTR inString,
                     PSTR *outString,
                     POPTBLENTRY pEntry,
                     PULONG64 poffset)
{
    ULONG instruction;
    ULONG Ra;
    LONG disp;

    Ra = GetFltReg(inString, &inString);

    if (!TestCharacter(inString, &inString, ','))
        error(OPERAND);

    //
    // the user gives an absolute address; we convert
    // that to a displacement, which is computed as a
    // difference off of (pc+1)
    // GetValue handles both numerics and symbolics
    //
    disp = GetValue(inString, &inString, TRUE, 32);

    // get the relative displacement from the updated pc
    disp = disp - (LONG)((*poffset)+4);

    // divide by four
    disp = disp >> 2;

    if (!TestCharacter(inString, &inString, '\0'))
        error(EXTRACHARS);

    instruction = OPCODE(pEntry->opCode) +
                  REG_A(Ra) +
                  BR_DISP(disp);

    return(instruction);
}


/*** ParseIntOp - parse integer operation
*
*   Purpose:
*       Given the users input, create the memory instruction.
*
*   Input:
*       *inString - present input position
*       pEntry - pointer into the asmTable for this instr type
*
*   Output:
*       *outstring - update input position
*
*   Returns:
*       the instruction.
*
*   Format:
*       op Ra, Rb, Rc
*       op Ra, #lit, Rc
*
*************************************************************************/

ULONG ParseIntOp(PSTR inString,
                 PSTR *outString,
                 POPTBLENTRY pEntry,
                 PULONG64 poffset)
{
    ULONG instruction;
    ULONG Ra, Rb, Rc;
    ULONG lit;
    ULONG Format;       // Whether there is a literal or 3rd reg

    instruction = OPCODE(pEntry->opCode) +
                  OP_FNC(pEntry->funcCode);

    if (pEntry->opCode != SEXT_OP) {
        Ra = GetIntReg(inString, &inString);
        if (!TestCharacter(inString, &inString, ','))
            error(OPERAND);

    } else {
        Ra = 31;
    }

    if (TestCharacter(inString, &inString, '#')) {

        //
        // User is giving us a literal value

        lit = GetValue(inString, &inString, TRUE, WIDTH_LIT);
        Format = RBV_LITERAL_FORMAT;

    } else {

        //
        // using a third register value

        Rb = GetIntReg(inString, &inString);
        Format = RBV_REGISTER_FORMAT;
    }

    if (!TestCharacter(inString, &inString, ','))
        error(OPERAND);

    Rc = GetIntReg(inString, &inString);

    if (!TestCharacter(inString, &inString, '\0'))
        error(EXTRACHARS);

    instruction = instruction +
                  REG_A(Ra) +
                  RBV_TYPE(Format) +
                  REG_C(Rc);

    if (Format == RBV_REGISTER_FORMAT) {
        instruction = instruction + REG_B(Rb);
    } else {
        instruction = instruction + LIT(lit);
    }

    return(instruction);
}

ULONG ParsePal(PSTR inString,
               PSTR *outString,
               POPTBLENTRY pEntry,
               PULONG64 poffset)
{
    if (!TestCharacter(inString, &inString, '\0'))
        error(EXTRACHARS);

    return(OPCODE(pEntry->opCode) +
           PAL_FNC(pEntry->funcCode));
}

ULONG ParseUnknown(PSTR inString,
                   PSTR *outString,
                   POPTBLENTRY pEntry,
                   PULONG64 poffset)
{
    dprintf("Unable to assemble %s\n", inString);
    error(BADOPCODE);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\alpha_dis.h ===
#ifndef _ALPHA_DIS_
#define _ALPHA_DIS_


//
// Bit manipulations for Alpha instructions
//

#define SHFT_OPCODE     26
#define SHFT_RA         21
#define SHFT_RB         16
#define SHFT_JMP_FNC    14
#define SHFT_OP_FNC     5
#define SHFT_RBV_TYPE   12
#define SHFT_LIT        13
#define SHFT_FP_FNC     5

#define WIDTH_OPCODE    6
#define WIDTH_REG       5
#define WIDTH_MEM_DISP  16
#define WIDTH_HINT      14
#define WIDTH_JMP_FNC   2
#define WIDTH_BR_DISP   21
#define WIDTH_OP_FNC    7
#define WIDTH_LIT       8
#define WIDTH_FP_FNC    11
#define WIDTH_PAL_FNC   26

#define BITS_OPCODE     ~(-1 << WIDTH_OPCODE)
#define BITS_REG        ~(-1 << WIDTH_REG)
#define BITS_MEM_DISP   ~(-1 << WIDTH_MEM_DISP)
#define BITS_HINT       ~(-1 << WIDTH_HINT)
#define BITS_JMP_FNC    ~(-1 << WIDTH_JMP_FNC)
#define BITS_BR_DISP    ~(-1 << WIDTH_BR_DISP)
#define BITS_OP_FNC     ~(-1 << WIDTH_OP_FNC)
#define BITS_LIT        ~(-1 << WIDTH_LIT)
#define BITS_FP_FNC     ~(-1 << WIDTH_FP_FNC)
#define BITS_PAL_FNC    ~(-1 << WIDTH_PAL_FNC)

#define OPCODE(a)       ((BITS_OPCODE & (a)) << SHFT_OPCODE)
#define REG_A(a)           ((BITS_REG & (a)) << SHFT_RA)
#define REG_B(a)           ((BITS_REG & (a)) << SHFT_RB)
#define REG_C(a)           (BITS_REG & (a))
#define MEM_DISP(a)     (BITS_MEM_DISP & (a))
#define MEM_FUNC(a)	MEM_DISP(a)
#define HINT(a)         (BITS_HINT & (a))
#define JMP_FNC(a)      ((BITS_JMP_FNC & (a)) << SHFT_JMP_FNC)
#define BR_DISP(a)      (BITS_BR_DISP & (a))
#define OP_FNC(a)       ((BITS_OP_FNC & (a)) << SHFT_OP_FNC)
#define RBV_TYPE(a)     ((1 & (a)) << SHFT_RBV_TYPE)
#define LIT(a)          ((BITS_LIT & (a)) << SHFT_LIT)
#define FP_FNC(a)       ((BITS_FP_FNC & (a)) << SHFT_FP_FNC)
#define PAL_FNC(a)      (BITS_PAL_FNC & (a))

#define MSK_OPCODE      OPCODE(BITS_OPCODE)
#define MSK_RA          GET_RA(BITS_REG)
#define MSK_RB          REG_B(BITS_REG)
#define MSK_RC          REG_C(BITS_REG)
#define MSK_MEM_DISP    DISP(BITS_MEM_DISP)
#define MSK_HINT        HINT(BITS_HINT)
#define MSK_JMP_FNC     JMP_FNC(BITS_JMP_FNC)
#define MSK_BR_DISP     BR_DISP(BITS_BR_DISP)
#define MSK_RBV_TYPE    RBV_TYPE(1)
#define MSK_LIT         LIT(BITS_LIT)
#define MSK_FP_FNC      FP_FNC(BITS_FP_FNC)
#define MSK_PAL_FNC     PAL_FNC(BITS_PAL_FNC)

#define EXTR_OPCODE(a)   (((a) & MSK_OPCODE) >> SHFT_OPCODE)
#define EXTR_RA(a)       (((a) & MSK_RA) >> SHFT_RA)
#define EXTR_RB(a)       (((a) & MSK_RB) >> SHFT_RA)
#define EXTR_RC(a)        ((a) & MSK_RC)
#define EXTR_MEM_DISP(a)  ((a) & MSK_MEM_DISP)
#define EXTR_HINT(a)      ((a) & MSK_HINT)
#define EXTR_JMP_FNC(a)  (((a) & MSK_JMP_FNC) >> SHFT_JMP_FNC)
#define EXTR_BR_DISP(a)   ((a) & MSK_BR_DISP)
#define EXTR_RBV_TYPE(a) (((a) & MSK_RBV_TYPE) >> SHFT_RBV_TYPE)
#define EXTR_LIT(a)      (((a) & MSK_LIT) >> SHFT_LIT)
#define EXTR_FP_FNC(a)   (((a) & MSK_FP_FNC) >> SHFT_FP_FNC)
#define EXTR_PAL_FNC(a)  ((a) & MSK_PAL_FNC)



//
// Bit manipulations for EV4 PAL mode instructions
//

#define SHFT_EV4_IBOX      5
#define SHFT_EV4_ABOX      6
#define SHFT_EV4_PALTEMP   7
#define SHFT_EV4_QWORD     12
#define SHFT_EV4_RWCHECK   13
#define SHFT_EV4_ALT       14
#define SHFT_EV4_PHYSICAL  15

#define WIDTH_EV4_INDEX    5
#define WIDTH_EV4_IBOX     1
#define WIDTH_EV4_ABOX     1
#define WIDTH_EV4_PALTEMP  1
#define WIDTH_EV4_DISP     12
#define WIDTH_EV4_QWORD    1
#define WIDTH_EV4_RWCHECK  1
#define WIDTH_EV4_ALT      1
#define WIDTH_EV4_PHYSICAL 1

#define BITS_EV4_INDEX     ~(-1 << WIDTH_EV4_INDEX)
#define BITS_EV4_IBOX      ~(-1 << WIDTH_EV4_IBOX)
#define BITS_EV4_ABOX      ~(-1 << WIDTH_EV4_ABOX)
#define BITS_EV4_PALTEMP   ~(-1 << WIDTH_EV4_PALTEMP)
#define BITS_EV4_DISP      ~(-1 << WIDTH_EV4_DISP)
#define BITS_EV4_QWORD     ~(-1 << WIDTH_EV4_QWORD)
#define BITS_EV4_RWCHECK   ~(-1 << WIDTH_EV4_RWCHECK)
#define BITS_EV4_ALT       ~(-1 << WIDTH_EV4_ALT)
#define BITS_EV4_PHYSICAL  ~(-1 << WIDTH_EV4_PHYSICAL)

#define EV4_INDEX(a)     (BITS_EV4_INDEX & (a))
#define EV4_IBOX(a)     ((BITS_EV4_IBOX & (a)) << SHFT_EV4_IBOX)
#define EV4_ABOX(a)     ((BITS_EV4_ABOX & (a)) << SHFT_EV4_ABOX)
#define EV4_PALTEMP(a)  ((BITS_EV4_PALTEMP & (a)) << SHFT_EV4_PALTEMP)
#define EV4_DISP(a)      (BITS_EV4_DISP & (a))
#define EV4_QWORD(a)    ((BITS_EV4_QWORD & (a)) << SHFT_EV4_QWORD)
#define EV4_RWCHECK(a)  ((BITS_EV4_RWCHECK & (a)) << SHFT_EV4_RWCHECK)
#define EV4_ALT(a)      ((BITS_EV4_ALT & (a)) << SHFT_EV4_ALT)
#define EV4_PHYSICAL(a) ((BITS_EV4_PHYSICAL & (a)) << SHFT_EV4_PHYSICAL)

#define MSK_EV4_INDEX       EV4_INDEX(BITS_EV4_INDEX)
#define MSK_EV4_IBOX        EV4_IBOX(BITS_EV4_IBOX)
#define MSK_EV4_ABOX        EV4_ABOX(BITS_EV4_ABOX)
#define MSK_EV4_PALTEMP     EV4_PALTEMP(BITS_EV4_PALTEMP)
#define MSK_EV4_PR          (MSK_EV4_INDEX | MSK_EV4_IBOX | MSK_EV4_ABOX | MSK_EV4_PALTEMP)
#define MSK_EV4_DISP        EV4_DISP(BITS_EV4_DISP)
#define MSK_EV4_QWORD       EV4_QWORD(BITS_EV4_QWORD)
#define MSK_EV4_RWCHECK     EV4_RWCHECK(BITS_EV4_RWCHECK)
#define MSK_EV4_ALT         EV4_ALT(BITS_EV4_ALT)
#define MSK_EV4_PHYSICAL    EV4_PHYSICAL(BITS_EV4_PHYSICAL)

#define EXTR_EV4_INDEX(a)        (MSK_EV4_INDEX & (a))
#define EXTR_EV4_IBOX(a)        ((MSK_EV4_IBOX & (a)) >> SHFT_EV4_IBOX)
#define EXTR_EV4_ABOX(a)        ((MSK_EV4_ABOX & (a)) >> SHFT_EV4_ABOX)
#define EXTR_EV4_PALTEMP(a)     ((MSK_EV4_PALTEMP & (a)) >> SHFT_EV4_PALTEMP)
#define EXTR_EV4_DISP(a)         (MSK_EV4_DISP & (a))
#define EXTR_EV4_QWORD(a)       ((MSK_EV4_QWORD & (a)) >> SHFT_EV4_QWORD)
#define EXTR_EV4_RWCHECK(a)     ((MSK_EV4_RWCHECK & (a)) >> SHFT_EV4_RWCHECK)
#define EXTR_EV4_ALT(a)         ((MSK_EV4_ALT & (a)) >> SHFT_EV4_ALT)
#define EXTR_EV4_PHYSICAL(a)    ((MSK_EV4_PHYSICAL & (a)) >> SHFT_EV4_PHYSICAL)

#define EV4_TB_TAG        (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(0))
#define EV4_ITB_PTE       (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(1))
#define EV4_ICCSR         (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(2))
#define EV4_ITM_PTE_TEMP  (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(3))
#define EV4_EXC_ADDR      (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(4))
#define EV4_SL_RCV        (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(5))
#define EV4_ITBZAP        (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(6))
#define EV4_ITBASM        (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(7))
#define EV4_ITBIS         (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(8))
#define EV4_PS            (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(9))
#define EV4_EXC_SUM       (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(10))
#define EV4_PAL_BASE      (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(11))
#define EV4_HIRR          (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(12))
#define EV4_SIRR          (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(13))
#define EV4_ASTRR         (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(14))
#define EV4_HIER          (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(16))
#define EV4_SIER          (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(17))
#define EV4_ASTER         (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(18))
#define EV4_SL_CLR        (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(19))
#define EV4_SL_XMIT       (EV4_PALTEMP(0) | EV4_ABOX(0) | EV4_IBOX(1) | EV4_INDEX(22))
#define EV4_DTB_CTL       (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(0))
#define EV4_DTB_PTE       (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(2))
#define EV4_DTB_PTE_TEMP  (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(3))
#define EV4_MMCSR         (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(4))
#define EV4_VA            (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(5))
#define EV4_DTBZAP        (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(6))
#define EV4_DTASM         (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(7))
#define EV4_DTBIS         (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(8))
#define EV4_BIU_ADDR      (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(9))
#define EV4_BIU_STAT      (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(10))
#define EV4_DC_ADDR       (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(11))
#define EV4_DC_STAT       (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(12))
#define EV4_FILL_ADDR     (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(13))
#define EV4_ABOX_CTL      (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(14))
#define EV4_ALT_MODE      (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(15))
#define EV4_CC            (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(16))
#define EV4_CC_CTL        (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(17))
#define EV4_BIU_CTL       (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(18))
#define EV4_FILL_SYNDROME (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(19))
#define EV4_BC_TAG        (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(20))
#define EV4_FLUSH_IC      (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(21))
#define EV4_FLUSH_IC_ASM  (EV4_PALTEMP(0) | EV4_ABOX(1) | EV4_IBOX(0) | EV4_INDEX(23))
#define EV4_PAL_TEMP(x)   (EV4_PALTEMP(1) | EV4_ABOX(0) | EV4_IBOX(0) | EV4_INDEX(x))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\alpha_dis.cpp ===
//----------------------------------------------------------------------------
//
// Disassembly portions of Alpha machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

// TODO:
//      (3) Should registers be treated as 64 or 32bit?  Note that Fregs are
//          64bits only.  -- All registers should be treated as 64bit values
//          since LDQ/EXTB is done for byte fetches (stores); the intermediate
//          values could be hidden.

#include "ntsdp.hpp"

#include "alpha_dis.h"
#include "alpha_optable.h"

// See Get/SetRegVal comments in machine.hpp.
#define RegValError Do_not_use_GetSetRegVal_in_machine_implementations
#define GetRegVal(index, val)   RegValError
#define GetRegVal32(index)      RegValError
#define GetRegVal64(index)      RegValError
#define SetRegVal(index, val)   RegValError
#define SetRegVal32(index, val) RegValError
#define SetRegVal64(index, val) RegValError

ADDR g_AlphaEffAddr;
ALPHA_INSTRUCTION g_AlphaDisinstr;

// these are defined in alphaops.h
#define NUMBER_OF_BREAK_INSTRUCTIONS 3
#define ALPHA_BP_LEN 4
ULONG g_AlphaTrapInstr = CALLPAL_OP | BPT_FUNC;
ULONG g_AlphaBreakInstrs[NUMBER_OF_BREAK_INSTRUCTIONS] =
{
    CALLPAL_OP | BPT_FUNC,
    CALLPAL_OP | KBPT_FUNC,
    CALLPAL_OP | CALLKD_FUNC
};

#define OPRNDCOL  27            // Column for first operand
#define EACOL     40            // column for effective address
#define FPTYPECOL 40            // .. for the type of FP instruction


BOOL
AlphaMachineInfo::Disassemble (
    PADDR poffset,
    PSTR bufptr,
    BOOL fEAout
    )

{

    ULONG       opcode;
    ULONG64     Ea;                     // Effective Address
    POPTBLENTRY pEntry;

    m_BufStart = m_Buf = bufptr;
    sprintAddr(&m_Buf, poffset);
    *m_Buf++ = ':';
    *m_Buf++ = ' ';

    if (!GetMemDword(poffset, &g_AlphaDisinstr.Long)) {
        BufferString("???????? ????\n");
        *m_Buf = '\0';
        return(FALSE);
    }

    BufferHex(g_AlphaDisinstr.Long, 8, FALSE); // Output instruction in Hex
    *m_Buf++ = ' ';

    opcode = g_AlphaDisinstr.Memory.Opcode;    // Select disassembly procedure from

    pEntry = findOpCodeEntry(opcode);   // Get non-func entry for this code


    switch (pEntry->iType) {
    case ALPHA_UNKNOWN:
        BufferString(pEntry->pszAlphaName);
        break;

    case ALPHA_MEMORY:
        BufferString(pEntry->pszAlphaName);
        BufferBlanks(OPRNDCOL);
        BufferReg(g_AlphaDisinstr.Memory.Ra);
        *m_Buf++ = ',';
        BufferHex(g_AlphaDisinstr.Memory.MemDisp, (WIDTH_MEM_DISP + 3)/4, TRUE );
        *m_Buf++ = '(';
        BufferReg(g_AlphaDisinstr.Memory.Rb);
        *m_Buf++ = ')';

        break;

    case ALPHA_FP_MEMORY:
        BufferString(pEntry->pszAlphaName);
        BufferBlanks(OPRNDCOL);
        BufferFReg(g_AlphaDisinstr.Memory.Ra);
        *m_Buf++ = ',';
        BufferHex(g_AlphaDisinstr.Memory.MemDisp, (WIDTH_MEM_DISP + 3)/4, TRUE );
        *m_Buf++ = '(';
        BufferReg(g_AlphaDisinstr.Memory.Rb);
        *m_Buf++ = ')';

        break;

    case ALPHA_MEMSPC:
        BufferString(findFuncName(pEntry, g_AlphaDisinstr.Memory.MemDisp & BITS_MEM_DISP));

        //
        // Some memory special instructions have an operand
        //

        switch (g_AlphaDisinstr.Memory.MemDisp & BITS_MEM_DISP) {
        case FETCH_FUNC:
        case FETCH_M_FUNC:
             // one operand, in Rb
             BufferBlanks(OPRNDCOL);
             *m_Buf++ = '0';
             *m_Buf++ = '(';
             BufferReg(g_AlphaDisinstr.Memory.Rb);
             *m_Buf++ = ')';
             break;

        case RS_FUNC:
        case RC_FUNC:
        case RPCC_FUNC:
             // one operand, in Ra
             BufferBlanks(OPRNDCOL);
             BufferReg(g_AlphaDisinstr.Memory.Ra);
             break;

        case MB_FUNC:
        case WMB_FUNC:
        case MB2_FUNC:
        case MB3_FUNC:
        case TRAPB_FUNC:
        case EXCB_FUNC:
             // no operands
             break;

        default:
             printf("we shouldn't get here \n");
             break;
        }

        break;

    case ALPHA_JUMP:
        BufferString(findFuncName(pEntry, g_AlphaDisinstr.Jump.Function));
        BufferBlanks(OPRNDCOL);
        BufferReg(g_AlphaDisinstr.Jump.Ra);
        *m_Buf++ = ',';
        *m_Buf++ = '(';
        BufferReg(g_AlphaDisinstr.Jump.Rb);
        *m_Buf++ = ')';
        *m_Buf++ = ',';
        BufferHex(g_AlphaDisinstr.Jump.Hint, (WIDTH_HINT + 3)/4, TRUE);

        Ea = GetReg64(GetIntRegNumber(g_AlphaDisinstr.Jump.Rb)) & (~3);
        BufferEffectiveAddress(Ea);
        break;

    case ALPHA_BRANCH:
        BufferString(pEntry->pszAlphaName);
        BufferBlanks(OPRNDCOL);
        BufferReg(g_AlphaDisinstr.Branch.Ra);
        *m_Buf++ = ',';

        //
        // The next line might be a call to GetNextOffset, but
        // GetNextOffset assumes that it should work from FIR.
        //

        Ea = Flat(*poffset) +
             sizeof(ULONG) +
             (g_AlphaDisinstr.Branch.BranchDisp * 4);
        BufferHex(Ea, 16, FALSE);
        BufferEffectiveAddress(Ea);

        break;

    case ALPHA_FP_BRANCH:
        BufferString(pEntry->pszAlphaName);
        BufferBlanks(OPRNDCOL);
        BufferFReg(g_AlphaDisinstr.Branch.Ra);
        *m_Buf++ = ',';

        //
        // The next line might be a call to GetNextOffset, but
        // GetNextOffset assumes that it should work from FIR.
        //

        Ea = Flat(*poffset) +
             sizeof(ULONG) +
             (g_AlphaDisinstr.Branch.BranchDisp * 4);
        BufferHex(Ea, 16, FALSE);
        BufferEffectiveAddress(Ea);

        break;

    case ALPHA_OPERATE:
        BufferString(findFuncName(pEntry, g_AlphaDisinstr.OpReg.Function));
        BufferBlanks(OPRNDCOL);
        if (g_AlphaDisinstr.OpReg.Opcode != SEXT_OP) {
            BufferReg(g_AlphaDisinstr.OpReg.Ra);
            *m_Buf++ = ',';
        }
        if (g_AlphaDisinstr.OpReg.RbvType) {
            *m_Buf++ = '#';
            BufferHex(g_AlphaDisinstr.OpLit.Literal, (WIDTH_LIT + 3)/4, TRUE);
        } else {
            BufferReg(g_AlphaDisinstr.OpReg.Rb);
        }
        *m_Buf++ = ',';
        BufferReg(g_AlphaDisinstr.OpReg.Rc);
        break;

    case ALPHA_FP_OPERATE:

      {
        ULONG Function;
        ULONG Flags;

        Flags = g_AlphaDisinstr.FpOp.Function & MSK_FP_FLAGS;
        Function = g_AlphaDisinstr.FpOp.Function & MSK_FP_OP;

#if 0
        if (fVerboseBuffer) {
           dprintf("In FP_OPERATE: Flags %08x Function %08x\n",
                    Flags, Function);
           dprintf("opcode %d \n", opcode);
        }
#endif

        //
        // CVTST and CVTST/S are different: they look like
        // CVTTS with some flags set
        //
        if (Function == CVTTS_FUNC) {
            if (g_AlphaDisinstr.FpOp.Function == CVTST_S_FUNC) {
                Function = CVTST_S_FUNC;
                Flags = NONE_FLAGS;
            }
            if (g_AlphaDisinstr.FpOp.Function == CVTST_FUNC) {
                Function = CVTST_FUNC;
                Flags = NONE_FLAGS;
            }
        }

        BufferString(findFuncName(pEntry, Function));

        //
        // Append the opcode qualifier, if any, to the opcode name.
        //

        if ( (opcode == IEEEFP_OP) || (opcode == VAXFP_OP)
                                   || (Function == CVTQL_FUNC) ) {
            BufferString(findFlagName(Flags, Function));
        }

        BufferBlanks(OPRNDCOL);
        //
        // If this is a convert instruction, only Rb and Rc are used
        //
        if (strncmp("cvt", findFuncName(pEntry, Function), 3) != 0) {
            BufferFReg(g_AlphaDisinstr.FpOp.Fa);
            *m_Buf++ = ',';
        }

        BufferFReg(g_AlphaDisinstr.FpOp.Fb);
        *m_Buf++ = ',';
        BufferFReg(g_AlphaDisinstr.FpOp.Fc);

        break;
      }

    case ALPHA_FP_CONVERT:
        BufferString(pEntry->pszAlphaName);
        BufferBlanks(OPRNDCOL);
        BufferFReg(g_AlphaDisinstr.FpOp.Fa);
        *m_Buf++ = ',';
        BufferFReg(g_AlphaDisinstr.FpOp.Fb);
        break;

    case ALPHA_CALLPAL:
        BufferString(findFuncName(pEntry, g_AlphaDisinstr.Pal.Function));
        break;

    case ALPHA_EV4_PR:
        if ((g_AlphaDisinstr.Long & MSK_EV4_PR) == 0)
        {
            BufferString("NOP");
        }
        else
        {
            BufferString(pEntry->pszAlphaName);
            BufferBlanks(OPRNDCOL);
            BufferReg(g_AlphaDisinstr.EV4_PR.Ra);
            *m_Buf++ = ',';
            if(g_AlphaDisinstr.EV4_PR.Ra != g_AlphaDisinstr.EV4_PR.Rb)
            {
                BufferReg(g_AlphaDisinstr.EV4_PR.Rb);
                *m_Buf++ = ',';
            }
            BufferString(findFuncName(pEntry, (g_AlphaDisinstr.Long & MSK_EV4_PR)));
        }
        break;
    case ALPHA_EV4_MEM:
        BufferString(pEntry->pszAlphaName);
        BufferBlanks(OPRNDCOL);
        BufferReg(g_AlphaDisinstr.EV4_MEM.Ra);
        *m_Buf++ = ',';
        BufferReg(g_AlphaDisinstr.EV4_MEM.Rb);
        break;
    case ALPHA_EV4_REI:
        BufferString(pEntry->pszAlphaName);
        break;
    default:
        BufferString("Invalid type");
        break;
    }

    Off(*poffset) += sizeof(ULONG);
    NotFlat(*poffset);
    ComputeFlatAddress(poffset, NULL);
    *m_Buf++ = '\n';
    *m_Buf = '\0';
    return(TRUE);
}

void
AlphaMachineInfo::BufferReg (ULONG regnum)
{
    BufferString(RegNameFromIndex(GetIntRegNumber(regnum)));
}

void
AlphaMachineInfo::BufferFReg (ULONG regnum)
{
    *m_Buf++ = 'f';
    if (regnum > 9)
        *m_Buf++ = (UCHAR)('0' + regnum / 10);
    *m_Buf++ = (UCHAR)('0' + regnum % 10);
}


/*** BufferEffectiveAddress - Print EA symbolically
*
*   Purpose:
*       Given the effective address (for a branch, jump or
*       memory instruction, print it symbolically, if
*       symbols are available.
*
*   Input:
*       offset - computed by the caller as
*               for jumps, the value in Rb
*               for branches, func(PC, displacement)
*               for memory, func(PC, displacement)
*
*   Returns:
*       None
*
*************************************************************************/
void
AlphaMachineInfo::BufferEffectiveAddress(
    ULONG64 offset
    )
{
    CHAR   chAddrBuffer[MAX_SYMBOL_LEN];
    ULONG64 displacement;
    PCHAR  pszTemp;
    UCHAR   ch;

    //
    // MBH - i386 compiler bug with fast calling standard.
    // If "chAddrBuffer is used as a calling argument to
    // GetSymbol, it believes (here, but not in the other
    // uses of GetSymbol that the size is 60+8=68.
    //
    PCHAR pch = chAddrBuffer;

    BufferBlanks(EACOL);
    GetSymbolStdCall(offset, pch, sizeof(chAddrBuffer), &displacement, NULL);

    if (chAddrBuffer[0])
    {
        pszTemp = chAddrBuffer;
        while (ch = *pszTemp++)
        {
            *m_Buf++ = ch;
        }
        if (displacement)
        {
            *m_Buf++ = '+';
            BufferHex(displacement, 8, TRUE);
        }
    }
    else
    {
        BufferHex(offset, 16, FALSE);
    }

    // Save EA.
    ADDRFLAT(&g_AlphaEffAddr, offset);
}

BOOL
AlphaMachineInfo::IsBreakpointInstruction(PADDR Addr)
{
    UCHAR Instr[ALPHA_BP_LEN];

    if (GetMemString(Addr, Instr, ALPHA_BP_LEN) != ALPHA_BP_LEN)
    {
        return FALSE;
    }
    
    LONG index;

    //
    // ALPHA has several breakpoint instructions - see
    // if we have hit any of them.
    //

    index = 0;
    do
    {
        if (!memcmp(Instr, (PUCHAR)&g_AlphaBreakInstrs[index], ALPHA_BP_LEN))
        {
            return TRUE;
        }
    }
    while (++index < NUMBER_OF_BREAK_INSTRUCTIONS);

    return FALSE;
}

HRESULT
AlphaMachineInfo::InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                              ULONG64 Process,
                                              ULONG64 Offset,
                                              PUCHAR SaveInstr,
                                              PULONG64 ChangeStart,
                                              PULONG ChangeLen)
{
    *ChangeStart = Offset;
    *ChangeLen = ALPHA_BP_LEN;
    
    ULONG Done;
    HRESULT Status;
    
    Status = Services->ReadVirtual(Process, Offset, SaveInstr,
                                   ALPHA_BP_LEN, &Done);
    if (Status == S_OK && Done != ALPHA_BP_LEN)
    {
        Status = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

    if (Status == S_OK)
    {
        Status = Services->WriteVirtual(Process, Offset, &g_AlphaTrapInstr,
                                        ALPHA_BP_LEN, &Done);
        if (Status == S_OK && Done != ALPHA_BP_LEN)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
        }
    }
    
    return Status;
}

HRESULT
AlphaMachineInfo::RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                              ULONG64 Process,
                                              ULONG64 Offset,
                                              PUCHAR SaveInstr,
                                              PULONG64 ChangeStart,
                                              PULONG ChangeLen)
{
    *ChangeStart = Offset;
    *ChangeLen = ALPHA_BP_LEN;
    
    ULONG Done;
    HRESULT Status;
    
    Status = Services->WriteVirtual(Process, Offset, SaveInstr,
                                    ALPHA_BP_LEN, &Done);
    if (Status == S_OK && Done != ALPHA_BP_LEN)
    {
        Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }
    return Status;
}

void
AlphaMachineInfo::AdjustPCPastBreakpointInstruction(PADDR Addr,
                                                    ULONG BreakType)
{
    DBG_ASSERT(BreakType == DEBUG_BREAKPOINT_CODE);
    
    SetPC(AddrAdd(Addr, ALPHA_BP_LEN));
}

BOOL
AlphaMachineInfo::IsCallDisasm(PCSTR Disasm)
{
    return strstr(Disasm, " jsr") != NULL;
}

BOOL
AlphaMachineInfo::IsReturnDisasm(PCSTR Disasm)
{
    return strstr(Disasm, " ret ") != NULL && strstr(Disasm, " ra") != NULL;
}

BOOL
AlphaMachineInfo::IsSystemCallDisasm(PCSTR Disasm)
{
    return strstr(Disasm, " CallSys") != NULL;
}
    
BOOL
AlphaMachineInfo::IsDelayInstruction(PADDR Addr)
{
    return(FALSE);
}

void
AlphaMachineInfo::GetEffectiveAddr(PADDR Addr)
{
    *Addr = g_AlphaEffAddr;
}

void
AlphaMachineInfo::GetNextOffset(BOOL StepOver,
                                PADDR NextAddr, PULONG NextMachine)
{
    ULONG64 rv;
    ULONG   opcode;
    ULONG64 firaddr;
    ULONG64 updatedpc;
    ULONG64 branchTarget;
    ADDR    fir;

    // Canonical form to shorten tests; Abs is absolute value

    LONG    Can, Abs;

    LARGE_INTEGER    Rav;
    LARGE_INTEGER    Rbv;
    LARGE_INTEGER    Fav;

    // NextMachine is always the same.
    *NextMachine = m_ExecTypes[0];
        
    //
    // Get current address
    //

    firaddr = GetReg64(ALPHA_FIR);

    //
    // relative addressing updates PC first
    // Assume next sequential instruction is next offset
    //

    updatedpc = firaddr + sizeof(ULONG);
    rv = updatedpc;

    ADDRFLAT( &fir, firaddr);
    GetMemDword(&fir, &(g_AlphaDisinstr.Long));  // Get current instruction
    opcode = g_AlphaDisinstr.Memory.Opcode;

    switch(findOpCodeEntry(opcode)->iType)
    {
    case ALPHA_JUMP:
        switch(g_AlphaDisinstr.Jump.Function)
        {
        case JSR_FUNC:
        case JSR_CO_FUNC:
            if (StepOver)
            {
                //
                // Step over the subroutine call;
                //

                break;
            }

            //
            // fall through
            //

        case JMP_FUNC:
        case RET_FUNC:
            Rbv.QuadPart = GetReg64(GetIntRegNumber(g_AlphaDisinstr.Jump.Rb));
            if (m_Ptr64)
            {
                rv = (Rbv.QuadPart & (~3));
            }
            else
            {
                rv = EXTEND64(Rbv.LowPart & (~3));
            }
            break;
        }
        break;

    case ALPHA_BRANCH:
        branchTarget = (updatedpc + (g_AlphaDisinstr.Branch.BranchDisp * 4));

        Rav.QuadPart = GetReg64(GetIntRegNumber(g_AlphaDisinstr.Branch.Ra));

        //
        // set up a canonical value for computing the branch test
        // - works with ALPHA, MIPS and 386 hosts
        //

        Can = Rav.LowPart & 1;

        if ((LONG)Rav.HighPart < 0)
        {
            Can |= 0x80000000;
        }

        if ((Rav.LowPart & 0xfffffffe) || (Rav.HighPart & 0x7fffffff))
        {
            Can |= 2;
        }

#if 0
        VerbOut("Rav High %08lx Low %08lx Canonical %08lx\n",
                Rav.HighPart, Rav.LowPart, Can);
        VerbOut("returnvalue %08lx branchTarget %08lx\n",
                rv, branchTarget);
#endif

        switch(opcode)
        {
        case BR_OP:                         rv = branchTarget; break;
        case BSR_OP:  if (!StepOver)        rv = branchTarget; break;
        case BEQ_OP:  if (Can == 0)         rv = branchTarget; break;
        case BLT_OP:  if (Can <  0)         rv = branchTarget; break;
        case BLE_OP:  if (Can <= 0)         rv = branchTarget; break;
        case BNE_OP:  if (Can != 0)         rv = branchTarget; break;
        case BGE_OP:  if (Can >= 0)         rv = branchTarget; break;
        case BGT_OP:  if (Can >  0)         rv = branchTarget; break;
        case BLBC_OP: if ((Can & 0x1) == 0) rv = branchTarget; break;
        case BLBS_OP: if ((Can & 0x1) == 1) rv = branchTarget; break;
        }
        break;

    case ALPHA_FP_BRANCH:
        branchTarget = (updatedpc + (g_AlphaDisinstr.Branch.BranchDisp * 4));

        Fav.QuadPart = GetReg64(g_AlphaDisinstr.Branch.Ra);

        //
        // Set up a canonical value for computing the branch test
        //

        Can = Fav.HighPart & 0x80000000;

        //
        // The absolute value is needed -0 and non-zero computation
        //

        Abs = Fav.LowPart || (Fav.HighPart & 0x7fffffff);

        if (Can && (Abs == 0x0))
        {
            //
            // negative 0 should be considered as zero
            //

            Can = 0x0;
        }
        else
        {
            Can |= Abs;
        }

#if 0
        VerbOut("Fav High %08lx Low %08lx Canonical %08lx Absolute %08lx\n",
                Fav.HighPart, Fav.LowPart, Can, Abs);
        VerbOut("returnvalue %08lx branchTarget %08lx\n",
                rv, branchTarget);
#endif

        switch(opcode)
        {
        case FBEQ_OP: if (Can == 0)  rv =  branchTarget; break;
        case FBLT_OP: if (Can <  0)  rv =  branchTarget; break;
        case FBNE_OP: if (Can != 0)  rv =  branchTarget; break;
        case FBLE_OP: if (Can <= 0)  rv =  branchTarget; break;
        case FBGE_OP: if (Can >= 0)  rv =  branchTarget; break;
        case FBGT_OP: if (Can >  0)  rv =  branchTarget; break;
        }

        break;
    }

#if 0
    VerbOut("GetNextOffset returning %08lx\n", rv);
#endif

    ADDRFLAT( NextAddr, rv );
}

void
AlphaMachineInfo::IncrementBySmallestInstruction(PADDR Addr)
{
    AddrAdd(Addr, 4);
}

void
AlphaMachineInfo::DecrementBySmallestInstruction(PADDR Addr)
{
    AddrSub(Addr, 4);
}

void 
AlphaMachineInfo::PrintStackFrameAddresses(ULONG Flags, 
                                           PDEBUG_STACK_FRAME StackFrame)
{
    //
    // this is pure hack...
    //  Alpha's "return address" is really the address of the
    //  instruction where control left the frame.  Show the address of
    //  the next instruction, to make it easy to set a BP on the
    //  return site.  It will still be wrong sometimes, but it will
    //  be right more often this way.
    //

    DEBUG_STACK_FRAME AlphaStackFrame = *StackFrame;
    if (AlphaStackFrame.ReturnOffset) 
    {
        AlphaStackFrame.ReturnOffset += 4;
    }
    MachineInfo::PrintStackFrameAddresses(Flags, &AlphaStackFrame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\alpha_mach.hpp ===
//----------------------------------------------------------------------------
//
// Alpha machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#ifndef __ALPHA_MACH_HPP__
#define __ALPHA_MACH_HPP__

//
// NOTE: Be very careful when using machine-specific header files
// such as nt<plat>.h.  The machine implementation class is
// compiled for all platforms so the nt<plat>.h file will be the
// one for the build platform, not necessarily the platform
// of the machine implementation.  ntdbg.h contains many cross-platform
// types and definitions that can be used to avoid problems.
//

class AlphaMachineInfo : public MachineInfo
{
public:
    // MachineInfo.
    virtual HRESULT InitializeConstants(void);
    
    virtual void InitializeContext
        (ULONG64 Pc, PDBGKD_ANY_CONTROL_REPORT ControlReport);
    virtual HRESULT KdGetContextState(ULONG State);
    virtual HRESULT KdSetContext(void);
    virtual HRESULT ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                       ULONG FromSver,
                                       ULONG FromSize, PVOID From);
    virtual HRESULT ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                     ULONG ToSver, ULONG ToSize, PVOID To);
    virtual void InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                        ULONG Version);
    
    virtual int  GetType(ULONG index);
    virtual BOOL GetVal(ULONG index, REGVAL *val);
    virtual BOOL SetVal(ULONG index, REGVAL *val);

    virtual void OutputAll(ULONG Mask, ULONG OutMask);

    virtual TRACEMODE GetTraceMode(void);
    virtual void SetTraceMode(TRACEMODE Mode);
    virtual BOOL IsStepStatusSupported(ULONG Status);

    virtual ULONG ExecutingMachine(void);

    virtual void Assemble(PADDR Addr, PSTR Input);
    virtual BOOL Disassemble(PADDR Addr, PSTR Buffer, BOOL EffAddr);

    virtual BOOL IsBreakpointInstruction(PADDR Addr);
    virtual HRESULT InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen);
    virtual HRESULT RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen);
    virtual void AdjustPCPastBreakpointInstruction(PADDR Addr,
                                                   ULONG BreakType);
    
    virtual BOOL IsCallDisasm(PCSTR Disasm);
    virtual BOOL IsReturnDisasm(PCSTR Disasm);
    virtual BOOL IsSystemCallDisasm(PCSTR Disasm);
    
    virtual BOOL IsDelayInstruction(PADDR Addr);
    virtual void GetEffectiveAddr(PADDR Addr);
    virtual void GetNextOffset(BOOL StepOver,
                               PADDR NextAddr, PULONG NextMachine);

    virtual void IncrementBySmallestInstruction(PADDR Addr);
    virtual void DecrementBySmallestInstruction(PADDR Addr);
    virtual BOOL DisplayTrapFrame(ULONG64 FrameAddress,
                                  OUT PCROSS_PLATFORM_CONTEXT Context);
    virtual void ValidateCxr(PCROSS_PLATFORM_CONTEXT Context);

    virtual void PrintStackFrameAddresses(ULONG Flags, 
                                          PDEBUG_STACK_FRAME StackFrame);
   
    virtual HRESULT ReadKernelProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id);

    // AlphaMachineInfo.

    void OutputFunctionEntry64(PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY Entry);

    ULONG GetIntRegNumber(ULONG Index)
    {
        return ALPHA_INT64_BASE + Index;
    }

    void BufferEffectiveAddress(ULONG64);
    void BufferReg(ULONG);
    void BufferFReg(ULONG);
};

class Axp32MachineInfo : public AlphaMachineInfo
{
public:
    virtual HRESULT InitializeConstants(void);
    virtual HRESULT InitializeForTarget(void);

    virtual HRESULT GetContextFromThreadStack(ULONG64 ThreadBase,
                                              PCROSS_PLATFORM_THREAD Thread,
                                              PCROSS_PLATFORM_CONTEXT Context,
                                              PDEBUG_STACK_FRAME Frame,
                                              PULONG RunningOnProc);

    virtual void GetPC(PADDR Address);
    virtual void SetPC(PADDR Address);
    virtual void GetFP(PADDR Address);
    virtual void GetSP(PADDR Address);
    virtual ULONG64 GetArgReg(void);

    virtual HRESULT SetPageDirectory(ULONG Idx, ULONG64 PageDir,
                                     PULONG NextIdx);
    virtual HRESULT GetVirtualTranslationPhysicalOffsets
        (ULONG64 Virt, PULONG64 Offsets, ULONG OffsetsSize,
         PULONG Levels, PULONG PfIndex, PULONG64 LastPhys);
    virtual HRESULT GetBaseTranslationVirtualOffset(PULONG64 Offset);

    virtual void OutputFunctionEntry(PVOID RawEntry);
    virtual HRESULT ReadDynamicFunctionTable(ULONG64 Table,
                                             PULONG64 NextTable,
                                             PULONG64 MinAddress,
                                             PULONG64 MaxAddress,
                                             PULONG64 BaseAddress,
                                             PULONG64 TableData,
                                             PULONG TableSize,
                                             PWSTR OutOfProcessDll,
                                             PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable);
    virtual PVOID FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                           ULONG64 Address,
                                           PVOID TableData,
                                           ULONG TableSize);
};

class Axp64MachineInfo : public AlphaMachineInfo
{
public:
    virtual HRESULT InitializeConstants(void);
    virtual HRESULT InitializeForTarget(void);

    virtual HRESULT GetContextFromThreadStack(ULONG64 ThreadBase,
                                              PCROSS_PLATFORM_THREAD Thread,
                                              PCROSS_PLATFORM_CONTEXT Context,
                                              PDEBUG_STACK_FRAME Frame,
                                              PULONG RunningOnProc);

    virtual void GetPC(PADDR Address);
    virtual void SetPC(PADDR Address);
    virtual void GetFP(PADDR Address);
    virtual void GetSP(PADDR Address);
    virtual ULONG64 GetArgReg(void);

    virtual HRESULT SetPageDirectory(ULONG Idx, ULONG64 PageDir,
                                     PULONG NextIdx);
    virtual HRESULT GetVirtualTranslationPhysicalOffsets
        (ULONG64 Virt, PULONG64 Offsets, ULONG OffsetsSize,
         PULONG Levels, PULONG PfIndex, PULONG64 LastVal);
    virtual HRESULT GetBaseTranslationVirtualOffset(PULONG64 Offset);

    virtual void OutputFunctionEntry(PVOID RawEntry);
    virtual HRESULT ReadDynamicFunctionTable(ULONG64 Table,
                                             PULONG64 NextTable,
                                             PULONG64 MinAddress,
                                             PULONG64 MaxAddress,
                                             PULONG64 BaseAddress,
                                             PULONG64 TableData,
                                             PULONG TableSize,
                                             PWSTR OutOfProcessDll,
                                             PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable);
    virtual PVOID FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                           ULONG64 Address,
                                           PVOID TableData,
                                           ULONG TableSize);
};

extern Axp32MachineInfo g_Axp32Machine;
extern Axp64MachineInfo g_Axp64Machine;

#endif // #ifndef __ALPHA_MACH_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\alpha_optable.cpp ===
/*++

Copyright (c) 1993  Digital Equipment Corporation
Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    alpha_optable.c

Abstract:

    Declaration for -
    Table of operations, their names and charactersitics
    Used by ntsd, windbg and acc's dissassembler

Author:

    Miche Baker-Harvey (mbh) 10-Jan-1993

Revision History:

--*/

#include "ntsdp.hpp"

#define DEFINE_STRINGS
#include "alpha_strings.h"
#include "alpha_optable.h"

//
// These are the parsing functions.  In ntsd, they are defined
// in alpha_asm.c.  In windbg, they are defined in MBH - WHERE????
//

ULONG ParseIntMemory (PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseFltMemory (PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseMemSpec   (PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseJump      (PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseIntBranch (PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseFltBranch (PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseIntOp     (PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParsePal       (PSTR, PSTR *, POPTBLENTRY, PULONG64);
ULONG ParseUnknown   (PSTR, PSTR *, POPTBLENTRY, PULONG64);


#define NOFNCTBL NULL
#define NOSIZE   NULL


//
// These fields are used to find the beginning of the sections
// containing different "ENTRY_TYPE"s
//

POPTBLENTRY InvalidTab;
POPTBLENTRY NonTerminalTab;
POPTBLENTRY TerminalTab;
POPTBLENTRY FunctionTab;

ULONG        InvalidTabSize;
ULONG        NonTerminalTabSize;
ULONG        TerminalTabSize;
ULONG        FunctionTabSize;


//
// THE OPCODE TABLE ITSELF
//
// The opcode table "opTable" describes each opcode and function.
// There is an entry for each opcode, and for each function.
//
// The table is organized as follows:
//                invalid-ops,
//                non-terminal-ops,
//                terminal-ops,
//                functions,
//
//    This organization is NOT required:
//           no assumptions are made on it.
//
//    Searches based on opcode must search
//             INVALID, TERMINAL and NON_TERMINAL
//
//    Searches based on instruction name must search
//             TERMINAL and FUNCTION
//
//

OPTBLENTRY opTable[] = {


      //
      // First, the INVALID_ETYPE section.
      // (opcode searches begin here)
      //


{ "?Opc01", ParseUnknown, _01_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE},
{ "?Opc02", ParseUnknown, _02_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE},
{ "?Opc03", ParseUnknown, _03_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE},
{ "?Opc04", ParseUnknown, _04_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE},
{ "?Opc05", ParseUnknown, _05_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE},
{ "?Opc06", ParseUnknown, _06_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE},
{ "?Opc07", ParseUnknown, _07_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE},
{ "?Opc0A", ParseUnknown, _0A_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE},
{ "?Opc0C", ParseUnknown, _0C_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE},
{ "?Opc0D", ParseUnknown, _0D_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE},
{ "?Opc0E", ParseUnknown, _0E_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE},
{ "?Opc14", ParseUnknown, _14_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE},


//
//         This is what hasn't been done yet -
//  the EV4 stuff - there are no names for it
//  in the alphaops.h header file.  Should we
//  put them there?  Should they be elsewhere?
//  Do we want to assemble them?
//
// For the moment, just pretend they are invalid.  They never
// come up for all practical purposes, anyway.
//


{ "MFPR", ParseUnknown, MFPR_OP, NO_FUNC,
                                      ALPHA_EV4_PR, INVALID_ETYPE },
{ "MTPR", ParseUnknown, MTPR_OP, NO_FUNC,
                                      ALPHA_EV4_PR, INVALID_ETYPE },



      //
      // Secondly, the NON_TERMINAL_ETYPE section
      //



{  NOFNCTBL, NOSIZE, CALLPAL_OP, NO_FUNC, ALPHA_CALLPAL, NON_TERMINAL_ETYPE },
{  NOFNCTBL, NOSIZE, ARITH_OP,   NO_FUNC, ALPHA_OPERATE, NON_TERMINAL_ETYPE },
{  NOFNCTBL, NOSIZE, BIT_OP,     NO_FUNC, ALPHA_OPERATE, NON_TERMINAL_ETYPE },
{  NOFNCTBL, NOSIZE, BYTE_OP,    NO_FUNC, ALPHA_OPERATE, NON_TERMINAL_ETYPE },
{  NOFNCTBL, NOSIZE, MUL_OP,     NO_FUNC, ALPHA_OPERATE, NON_TERMINAL_ETYPE },
{  NOFNCTBL, NOSIZE, SEXT_OP,    NO_FUNC, ALPHA_OPERATE, NON_TERMINAL_ETYPE },
{  NOFNCTBL, NOSIZE, MEMSPC_OP,  NO_FUNC, ALPHA_MEMSPC,  NON_TERMINAL_ETYPE },
{  NOFNCTBL, NOSIZE, JMP_OP,     NO_FUNC, ALPHA_JUMP,    NON_TERMINAL_ETYPE },
{  NOFNCTBL, NOSIZE, VAXFP_OP,   NO_FUNC, ALPHA_FP_OPERATE, NON_TERMINAL_ETYPE },
{  NOFNCTBL, NOSIZE, IEEEFP_OP,  NO_FUNC, ALPHA_FP_OPERATE, NON_TERMINAL_ETYPE },
{  NOFNCTBL, NOSIZE, FPOP_OP,    NO_FUNC, ALPHA_FP_OPERATE, NON_TERMINAL_ETYPE },


      //
      // Thirdly, the TERMINAL_ETYPE section
      // (everything from here on has an instruction name)
      //



{ szLda,   ParseIntMemory, LDA_OP,  NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szLdah,  ParseIntMemory, LDAH_OP, NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szLdbu,  ParseIntMemory, LDBU_OP, NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szLdwu,  ParseIntMemory, LDWU_OP, NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szLdl,   ParseIntMemory, LDL_OP,  NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szLdq,   ParseIntMemory, LDQ_OP,  NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szLdf,   ParseFltMemory, LDF_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE },
{ szLdg,   ParseFltMemory, LDG_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE },
{ szLds,   ParseFltMemory, LDS_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE },
{ szLdt,   ParseFltMemory, LDT_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE },
{ szLdq_u, ParseIntMemory, LDQ_U_OP,NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szLdl_l, ParseIntMemory, LDL_L_OP,NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szLdq_l, ParseIntMemory, LDQ_L_OP,NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },

{ szStb,   ParseIntMemory, STB_OP,  NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szStw,   ParseIntMemory, STW_OP,  NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szStl,   ParseIntMemory, STL_OP,  NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szStq,   ParseIntMemory, STQ_OP,  NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szStf,   ParseFltMemory, STF_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE },
{ szStg,   ParseFltMemory, STG_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE },
{ szSts,   ParseFltMemory, STS_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE },
{ szStt,   ParseFltMemory, STT_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE },
{ szStq_u, ParseIntMemory, STQ_U_OP,NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szStl_c, ParseIntMemory, STL_C_OP,NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },
{ szStq_c, ParseIntMemory, STQ_C_OP,NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE },

{ szBeq,   ParseIntBranch, BEQ_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE },
{ szBne,   ParseIntBranch, BNE_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE },
{ szBlt,   ParseIntBranch, BLT_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE },
{ szBle,   ParseIntBranch, BLE_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE },
{ szBgt,   ParseIntBranch, BGT_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE },
{ szBge,   ParseIntBranch, BGE_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE },
{ szBlbc,  ParseIntBranch, BLBC_OP, NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE },
{ szBlbs,  ParseIntBranch, BLBS_OP, NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE },
{ szBr,    ParseIntBranch, BR_OP,   NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE },
{ szBsr,   ParseIntBranch, BSR_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE },

{ szFbeq,  ParseFltBranch, FBEQ_OP, NO_FUNC, ALPHA_FP_BRANCH, TERMINAL_ETYPE },
{ szFbne,  ParseFltBranch, FBNE_OP, NO_FUNC, ALPHA_FP_BRANCH, TERMINAL_ETYPE },
{ szFblt,  ParseFltBranch, FBLT_OP, NO_FUNC, ALPHA_FP_BRANCH, TERMINAL_ETYPE },
{ szFble,  ParseFltBranch, FBLE_OP, NO_FUNC, ALPHA_FP_BRANCH, TERMINAL_ETYPE },
{ szFbgt,  ParseFltBranch, FBGT_OP, NO_FUNC, ALPHA_FP_BRANCH, TERMINAL_ETYPE },
{ szFbge,  ParseFltBranch, FBGE_OP, NO_FUNC, ALPHA_FP_BRANCH, TERMINAL_ETYPE },


{ "REI",   ParseUnknown, PAL1B_OP, NO_FUNC, ALPHA_EV4_REI, TERMINAL_ETYPE},
{ "HW_LD", ParseUnknown, PAL1E_OP, NO_FUNC, ALPHA_EV4_MEM, TERMINAL_ETYPE},
{ "HW_ST", ParseUnknown, PAL1F_OP, NO_FUNC, ALPHA_EV4_MEM, TERMINAL_ETYPE},


      //
      // Fourthly, (and finally) the FUNCTION_ETYPE section
      // (opcode searches needn't include this section)
      //

           //
           // The memory-special functions
           //

{ szMb,   ParseMemSpec, MEMSPC_OP, MB_FUNC,    ALPHA_MEMSPC, FUNCTION_ETYPE },
{ szWmb,  ParseMemSpec, MEMSPC_OP, WMB_FUNC,   ALPHA_MEMSPC, FUNCTION_ETYPE },
{ szMb2,  ParseMemSpec, MEMSPC_OP, MB2_FUNC,   ALPHA_MEMSPC, FUNCTION_ETYPE },
{ szMb3,  ParseMemSpec, MEMSPC_OP, MB3_FUNC,   ALPHA_MEMSPC, FUNCTION_ETYPE },
{ szFetch,ParseMemSpec, MEMSPC_OP, FETCH_FUNC, ALPHA_MEMSPC, FUNCTION_ETYPE },
{ szFetch_m,ParseMemSpec,MEMSPC_OP,FETCH_M_FUNC,ALPHA_MEMSPC,FUNCTION_ETYPE },
{ szRs,   ParseMemSpec, MEMSPC_OP, RS_FUNC,    ALPHA_MEMSPC, FUNCTION_ETYPE },
{ szTrapb,ParseMemSpec, MEMSPC_OP, TRAPB_FUNC, ALPHA_MEMSPC, FUNCTION_ETYPE },
{ szExcb, ParseMemSpec, MEMSPC_OP, EXCB_FUNC,  ALPHA_MEMSPC, FUNCTION_ETYPE },
{ szRpcc, ParseMemSpec, MEMSPC_OP, RPCC_FUNC,  ALPHA_MEMSPC, FUNCTION_ETYPE },
{ szRc,   ParseMemSpec, MEMSPC_OP, RC_FUNC,    ALPHA_MEMSPC, FUNCTION_ETYPE },

           //
           // The jump functions
           //

{ szJmp,  ParseJump,  JMP_OP, JMP_FUNC, ALPHA_JUMP, FUNCTION_ETYPE },
{ szJsr,  ParseJump,  JMP_OP, JSR_FUNC, ALPHA_JUMP, FUNCTION_ETYPE },
{ szRet,  ParseJump,  JMP_OP, RET_FUNC, ALPHA_JUMP, FUNCTION_ETYPE },
{ szJsr_co,  ParseJump,  JMP_OP, JSR_CO_FUNC, ALPHA_JUMP, FUNCTION_ETYPE },

           //
           // The arithmetic ops, which are ALPHA_OPERATE
           //

{ szAddl,   ParseIntOp, ARITH_OP, ADDL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szAddlv,  ParseIntOp, ARITH_OP, ADDLV_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szAddq,   ParseIntOp, ARITH_OP, ADDQ_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szAddqv,  ParseIntOp, ARITH_OP, ADDQV_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szSubl,   ParseIntOp, ARITH_OP, SUBL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szSublv,  ParseIntOp, ARITH_OP, SUBLV_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szSubq,   ParseIntOp, ARITH_OP, SUBQ_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szSubqv,  ParseIntOp, ARITH_OP, SUBQV_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },


{ szCmpeq,  ParseIntOp, ARITH_OP, CMPEQ_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCmplt,  ParseIntOp, ARITH_OP, CMPLT_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCmple,  ParseIntOp, ARITH_OP, CMPLE_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCmpult, ParseIntOp, ARITH_OP, CMPULT_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCmpule, ParseIntOp, ARITH_OP, CMPULE_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCmpbge, ParseIntOp, ARITH_OP, CMPBGE_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },


{ szS4addl, ParseIntOp, ARITH_OP, S4ADDL_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szS4addq, ParseIntOp, ARITH_OP, S4ADDQ_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szS4subl, ParseIntOp, ARITH_OP, S4SUBL_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szS4subq, ParseIntOp, ARITH_OP, S4SUBQ_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szS8addl, ParseIntOp, ARITH_OP, S8ADDL_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szS8addq, ParseIntOp, ARITH_OP, S8ADDQ_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szS8subl, ParseIntOp, ARITH_OP, S8SUBL_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szS8subq, ParseIntOp, ARITH_OP, S8SUBQ_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },

           //
           // The bit ops, which are ALPHA_OPERATE
           //

{ szAnd,   ParseIntOp, BIT_OP, AND_FUNC,   ALPHA_OPERATE, FUNCTION_ETYPE },
{ szBic,   ParseIntOp, BIT_OP, BIC_FUNC,   ALPHA_OPERATE, FUNCTION_ETYPE },
{ szBis,   ParseIntOp, BIT_OP, BIS_FUNC,   ALPHA_OPERATE, FUNCTION_ETYPE },
{ szOrnot, ParseIntOp, BIT_OP, ORNOT_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szXor,   ParseIntOp, BIT_OP, XOR_FUNC,   ALPHA_OPERATE, FUNCTION_ETYPE },
{ szEqv,   ParseIntOp, BIT_OP, EQV_FUNC,   ALPHA_OPERATE, FUNCTION_ETYPE },

{ szCmoveq,  ParseIntOp, BIT_OP, CMOVEQ_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCmovne,  ParseIntOp, BIT_OP, CMOVNE_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCmovlbs, ParseIntOp, BIT_OP, CMOVLBS_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCmovlt,  ParseIntOp, BIT_OP, CMOVLT_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCmovge,  ParseIntOp, BIT_OP, CMOVGE_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCmovlbc, ParseIntOp, BIT_OP, CMOVLBC_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCmovle,  ParseIntOp, BIT_OP, CMOVLE_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCmovgt,  ParseIntOp, BIT_OP, CMOVGT_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },

           //
           // The byte ops, which are ALPHA_OPERATE
           //

{ szSll,    ParseIntOp, BYTE_OP, SLL_FUNC,    ALPHA_OPERATE, FUNCTION_ETYPE },
{ szSra,    ParseIntOp, BYTE_OP, SRA_FUNC,    ALPHA_OPERATE, FUNCTION_ETYPE },
{ szSrl,    ParseIntOp, BYTE_OP, SRL_FUNC,    ALPHA_OPERATE, FUNCTION_ETYPE },
{ szExtbl,  ParseIntOp, BYTE_OP, EXTBL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szExtwl,  ParseIntOp, BYTE_OP, EXTWL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szExtll,  ParseIntOp, BYTE_OP, EXTLL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szExtql,  ParseIntOp, BYTE_OP, EXTQL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szExtwh,  ParseIntOp, BYTE_OP, EXTWH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szExtlh,  ParseIntOp, BYTE_OP, EXTLH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szExtqh,  ParseIntOp, BYTE_OP, EXTQH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szInsbl,  ParseIntOp, BYTE_OP, INSBL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szInswl,  ParseIntOp, BYTE_OP, INSWL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szInsll,  ParseIntOp, BYTE_OP, INSLL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szInsql,  ParseIntOp, BYTE_OP, INSQL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szInswh,  ParseIntOp, BYTE_OP, INSWH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szInslh,  ParseIntOp, BYTE_OP, INSLH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szInsqh,  ParseIntOp, BYTE_OP, INSQH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szMskbl,  ParseIntOp, BYTE_OP, MSKBL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szMskwl,  ParseIntOp, BYTE_OP, MSKWL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szMskll,  ParseIntOp, BYTE_OP, MSKLL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szMskql,  ParseIntOp, BYTE_OP, MSKQL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szMskwh,  ParseIntOp, BYTE_OP, MSKWH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szMsklh,  ParseIntOp, BYTE_OP, MSKLH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szMskqh,  ParseIntOp, BYTE_OP, MSKQH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szZap,    ParseIntOp, BYTE_OP, ZAP_FUNC,    ALPHA_OPERATE, FUNCTION_ETYPE },
{ szZapnot, ParseIntOp, BYTE_OP, ZAPNOT_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },

           //
           // The multiply ops, which are ALPHA_OPERATE
           //

{ szMull,   ParseIntOp,  MUL_OP, MULL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szMulqv,  ParseIntOp,  MUL_OP, MULQV_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szMullv,  ParseIntOp,  MUL_OP, MULLV_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szUmulh,  ParseIntOp,  MUL_OP, UMULH_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szMulq,   ParseIntOp,  MUL_OP, MULQ_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },

           //
           // The sign extend ops, which are ALPHA_OPERATE, but only have an
           // rb and rc field.
           //

{ szSextb,  ParseIntOp,  SEXT_OP, SEXTB_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szSextw,  ParseIntOp,  SEXT_OP, SEXTW_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCtpop,  ParseIntOp,  SEXT_OP, CTPOP_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCtlz,   ParseIntOp,  SEXT_OP, CTLZ_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },
{ szCttz,   ParseIntOp,  SEXT_OP, CTTZ_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE },

           //
           // The call pal functions
           //


{ szBpt,       ParsePal, CALLPAL_OP,  BPT_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szCallsys,   ParsePal, CALLPAL_OP, CALLSYS_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szImb,       ParsePal, CALLPAL_OP, IMB_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRdteb,     ParsePal, CALLPAL_OP, RDTEB_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szGentrap,   ParsePal, CALLPAL_OP, GENTRAP_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szKbpt,      ParsePal, CALLPAL_OP, KBPT_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szCallKD,    ParsePal, CALLPAL_OP, CALLKD_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRdteb64,   ParsePal, CALLPAL_OP, RDTEB64_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szHalt, ParsePal, CALLPAL_OP, HALT_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRestart, ParsePal, CALLPAL_OP, RESTART_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szDraina, ParsePal, CALLPAL_OP, DRAINA_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szInitpal, ParsePal, CALLPAL_OP, INITPAL_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szWrentry, ParsePal, CALLPAL_OP, WRENTRY_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szSwpirql, ParsePal, CALLPAL_OP, SWPIRQL_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRdirql, ParsePal, CALLPAL_OP, RDIRQL_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szDi, ParsePal, CALLPAL_OP, DI_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szEi, ParsePal, CALLPAL_OP, EI_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szSwppal, ParsePal, CALLPAL_OP, SWPPAL_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szSsir, ParsePal, CALLPAL_OP, SSIR_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szCsir, ParsePal, CALLPAL_OP, CSIR_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRfe, ParsePal, CALLPAL_OP, RFE_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRetsys, ParsePal, CALLPAL_OP, RETSYS_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szSwpctx, ParsePal, CALLPAL_OP, SWPCTX_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szSwpprocess, ParsePal, CALLPAL_OP, SWPPROCESS_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRdmces, ParsePal, CALLPAL_OP, RDMCES_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szWrmces, ParsePal, CALLPAL_OP, WRMCES_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szTbia, ParsePal, CALLPAL_OP, TBIA_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szTbis, ParsePal, CALLPAL_OP, TBIS_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szDtbis, ParsePal, CALLPAL_OP, DTBIS_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRdksp, ParsePal, CALLPAL_OP, RDKSP_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szSwpksp, ParsePal, CALLPAL_OP, SWPKSP_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRdpsr, ParsePal, CALLPAL_OP, RDPSR_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRdpcr, ParsePal, CALLPAL_OP, RDPCR_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRdthread, ParsePal, CALLPAL_OP, RDTHREAD_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRdcounters, ParsePal, CALLPAL_OP, RDCOUNTERS_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRdstate, ParsePal, CALLPAL_OP, RDSTATE_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szInitpcr, ParsePal, CALLPAL_OP, INITPCR_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szWrperfmon, ParsePal, CALLPAL_OP, WRPERFMON_FUNC,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szMt, ParsePal, CALLPAL_OP, MTPR_OP,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szMf, ParsePal, CALLPAL_OP, MFPR_OP,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szHwld, ParsePal, CALLPAL_OP, HWLD_OP,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szHwst, ParsePal, CALLPAL_OP, HWST_OP,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },
{ szRei, ParsePal, CALLPAL_OP, REI_OP,
                                  ALPHA_CALLPAL, FUNCTION_ETYPE },


           //
           // The VAX Floating point functions
           //

{ szAddf,   ParseUnknown, VAXFP_OP, ADDF_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvtdg,  ParseUnknown, VAXFP_OP, CVTDG_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szAddg,   ParseUnknown, VAXFP_OP, ADDG_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCmpgeq, ParseUnknown, VAXFP_OP, CMPGEQ_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCmpglt, ParseUnknown, VAXFP_OP, CMPGLT_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCmpgle, ParseUnknown, VAXFP_OP, CMPGLE_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvtgf,  ParseUnknown, VAXFP_OP, CVTGF_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvtgd,  ParseUnknown, VAXFP_OP, CVTGD_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvtqf,  ParseUnknown, VAXFP_OP, CVTQF_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvtqg,  ParseUnknown, VAXFP_OP, CVTQG_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szDivf,   ParseUnknown, VAXFP_OP, DIVF_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szDivg,   ParseUnknown, VAXFP_OP, DIVG_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szMulf,   ParseUnknown, VAXFP_OP, MULF_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szMulg,   ParseUnknown, VAXFP_OP, MULG_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szSubf,   ParseUnknown, VAXFP_OP, SUBF_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szSubg,   ParseUnknown, VAXFP_OP, SUBG_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvtgq,  ParseUnknown, VAXFP_OP, CVTGQ_FUNC,
                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE },
           //
           // The IEEE Floating point functions
           //

{ szAdds,   ParseUnknown, IEEEFP_OP, ADDS_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szSubs,   ParseUnknown, IEEEFP_OP, SUBS_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szMuls,   ParseUnknown, IEEEFP_OP, MULS_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szDivs,   ParseUnknown, IEEEFP_OP, DIVS_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szAddt,   ParseUnknown, IEEEFP_OP, ADDT_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szSubt,   ParseUnknown, IEEEFP_OP, SUBT_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szMult,   ParseUnknown, IEEEFP_OP, MULT_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szDivt,   ParseUnknown, IEEEFP_OP, DIVT_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCmptun, ParseUnknown, IEEEFP_OP, CMPTUN_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCmpteq, ParseUnknown, IEEEFP_OP, CMPTEQ_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCmptlt, ParseUnknown, IEEEFP_OP, CMPTLT_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCmptle, ParseUnknown, IEEEFP_OP, CMPTLE_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvtts,  ParseUnknown, IEEEFP_OP, CVTTS_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvttq,  ParseUnknown, IEEEFP_OP, CVTTQ_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvtqs,  ParseUnknown, IEEEFP_OP, CVTQS_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvtqt,  ParseUnknown, IEEEFP_OP, CVTQT_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvtst,  ParseUnknown, IEEEFP_OP, CVTST_FUNC,
                                     ALPHA_FP_CONVERT, FUNCTION_ETYPE },
{ szCvtsts, ParseUnknown, IEEEFP_OP, CVTST_S_FUNC,
                                     ALPHA_FP_CONVERT, FUNCTION_ETYPE },
           //
           // The Common Floating point functions
           //


{ szCvtlq,    ParseUnknown,  FPOP_OP, CVTLQ_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCpys,     ParseUnknown,  FPOP_OP, CPYS_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCpysn,    ParseUnknown,  FPOP_OP, CPYSN_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCpyse,    ParseUnknown,  FPOP_OP, CPYSE_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szMt_fpcr,  ParseUnknown,  FPOP_OP, MT_FPCR_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szMf_fpcr,  ParseUnknown,  FPOP_OP, MF_FPCR_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szFcmoveq,  ParseUnknown,  FPOP_OP, FCMOVEQ_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szFcmovne,  ParseUnknown,  FPOP_OP, FCMOVNE_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szFcmovlt,  ParseUnknown,  FPOP_OP, FCMOVLT_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szFcmovge,  ParseUnknown,  FPOP_OP, FCMOVGE_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szFcmovle,  ParseUnknown,  FPOP_OP, FCMOVLE_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szFcmovgt,  ParseUnknown,  FPOP_OP, FCMOVGT_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvtql,    ParseUnknown,  FPOP_OP, CVTQL_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvtqlv,   ParseUnknown,  FPOP_OP, CVTQLV_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },
{ szCvtqlsv,  ParseUnknown,  FPOP_OP, CVTQLSV_FUNC,
                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE },

};       // end of opTable


#define SEARCHNUM  sizeof(opTable) / sizeof(OPTBLENTRY)



//
// Here are the tables of Floating Point flags.
//

FPFLAGS ConvertFlags[] = {
    { NONE_FLAGS, NONE_FLAGS_STR },
    { C_FLAGS, C_FLAGS_STR },
    { V_FLAGS, V_FLAGS_STR },
    { VC_FLAGS, VC_FLAGS_STR },
    { SV_FLAGS, SV_FLAGS_STR },
    { SVC_FLAGS, SVC_FLAGS_STR },
    { SVI_FLAGS, SVI_FLAGS_STR },
    { SVIC_FLAGS, SVIC_FLAGS_STR },

    { D_FLAGS, D_FLAGS_STR },
    { VD_FLAGS, VD_FLAGS_STR },
    { SVD_FLAGS, SVD_FLAGS_STR },
    { SVID_FLAGS, SVID_FLAGS_STR },
    { M_FLAGS, M_FLAGS_STR },
    { VM_FLAGS, VM_FLAGS_STR },
    { SVM_FLAGS, SVM_FLAGS_STR },
    { SVIM_FLAGS, SVIM_FLAGS_STR },

    { S_FLAGS, S_FLAGS_STR },
    { SC_FLAGS, SC_FLAGS_STR },
    { FPFLAGS_NOT_AN_ENTRY, "" }
};

FPFLAGS FloatOpFlags[] = {
    { C_FLAGS, C_FLAGS_STR },
    { M_FLAGS, M_FLAGS_STR },
    { NONE_FLAGS, NONE_FLAGS_STR },
    { D_FLAGS, D_FLAGS_STR },
    { UC_FLAGS, UC_FLAGS_STR },
    { UM_FLAGS, UM_FLAGS_STR },
    { U_FLAGS, U_FLAGS_STR },
    { UD_FLAGS, UD_FLAGS_STR },
    { SC_FLAGS, SC_FLAGS_STR },
    { S_FLAGS, S_FLAGS_STR },
    { SUC_FLAGS, SUC_FLAGS_STR },
    { SUM_FLAGS, SUM_FLAGS_STR },
    { SU_FLAGS, SU_FLAGS_STR },
    { SUD_FLAGS, SUD_FLAGS_STR },
    { SUIC_FLAGS, SUIC_FLAGS_STR },
    { SUIM_FLAGS, SUIM_FLAGS_STR },
    { SUI_FLAGS, SUI_FLAGS_STR },
    { SUID_FLAGS, SUID_FLAGS_STR },
    { FPFLAGS_NOT_AN_ENTRY, "" }
};



/*** findNameEntry - find POPTBLENTRY based on name
*
*   Purpose:
*       Search the opTable for a match with the token
*       pointed by *pszOp.  Must search through the
*       TERMINAL and the FUNCTION tables
*
*   Input:
*       *pszOp - string to search as mnemonic
*
*   Returns:
*       Pointer to entry in the opTable
*
*************************************************************************/

POPTBLENTRY
findStringEntry (PSTR pszOp)
{

    POPTBLENTRY pEntry;

    for (pEntry = TerminalTab;
         pEntry < &TerminalTab[TerminalTabSize];
         pEntry++) {

        if (!strcmp(pszOp, pEntry->pszAlphaName))
                return(pEntry);
    }

    for (pEntry = FunctionTab;
         pEntry < &FunctionTab[FunctionTabSize];
         pEntry++) {

        if (!strcmp(pszOp, pEntry->pszAlphaName))
                return(pEntry);
    }

    return((POPTBLENTRY)-1);
}


/* findOpCodeEntry - find POPTBLENTRY based on opcode
*
*   Purpose:
*       Search the opTable for a match with the token
*       pointed by *pszOp.  Must search through the
*       INVALID, TERMINAL and NON_TERMINAL tables
*
*   Input:
*       pOpEntry - pointer to NON_TERMINAL_ETYPE in opTable
*       function - the function value to be looked up
*
*   Output:
*       pointer to string mnemonic for the function
*
***********************************************************************/

POPTBLENTRY
findOpCodeEntry(ULONG opcode)
{
    POPTBLENTRY pEntry;

    for (pEntry = TerminalTab;
         pEntry < &TerminalTab[TerminalTabSize];
         pEntry++) {

        if (pEntry->opCode == opcode)
                return(pEntry);
    }

    for (pEntry = NonTerminalTab;
         pEntry < &NonTerminalTab[NonTerminalTabSize];
         pEntry++) {

        if (pEntry->opCode == opcode)
                return(pEntry);
    }

    for (pEntry = InvalidTab;
         pEntry < &InvalidTab[InvalidTabSize];
         pEntry++) {

        if (pEntry->opCode == opcode)
                return(pEntry);
    }

    return((POPTBLENTRY)-1);
}


/*** findNonTerminalEntry - find pointer to set of functions
*
*   Purpose:
*       This routine finds the entry in the table which the is
*       nonterminal entry for an opcode.
*
*   Input:
*       The type of function that is interesting
*
*   Output:
*       Pointer to the nonterminal entry in opTable
*
*   Errors:
*       If the entry is not found, a message is printed, and the
*       routine exits.
*
*   Exceptions:
*       None.
*
*   Note:
*       This routine is called BEFORE NonTerminalTable is established!
*       (it's used to set up these tables, in fact).
*
*************************************************************************/

POPTBLENTRY
findNonTerminalEntry(ULONG opCode)
{
    ULONG index;

    for ( index = 0 ; index < SEARCHNUM; index++ ) {

        if ( ( opTable[index].eType == NON_TERMINAL_ETYPE ) &&
             ( opTable[index].opCode == opCode ) ) {

                 return(&opTable[index]);
        }
    }

    dprintf("NonTerminalEntry for opCode %d\n not found in opTable\n",
             opCode);
    return NULL;
}



/* findFuncName - get string name for a function
*
*   Purpose:
*       to get function name, given the function number, and a
*       pointer to the opTable entry for the NON_TERMINAL_ETYPE
*       opcode associated with the function
*
*   Input:
*       pOpEntry - pointer to NON_TERMINAL_ETYPE in opTable
*       function - the function value to be looked up
*
*   Output:
*       pointer to string mnemonic for the function
*
***********************************************************************/

char *
findFuncName(POPTBLENTRY pEntry, ULONG function)
{
    int cIndex;
    POPTBLENTRY pFncEntry;

    pFncEntry = pEntry->funcTable;
    cIndex = (int)pEntry->funcTableSize;

    //
    // make sure that this entry pts to a function table
    //

    if (pEntry->eType != NON_TERMINAL_ETYPE) {
        VerbOut("pEntry %N invalid in getFuncName\n", pEntry);
        return("???");
    }

#if 0
    VerbOut("getFuncName: pOpEntry %N function %08x\n",
            pEntry, function);
    VerbOut("pFncEntry %N cIndex %08x\n",
            pFncEntry, function);
#endif

    while(cIndex-- > 0) {
        if (function == pFncEntry->funcCode)
            return(pFncEntry->pszAlphaName);
        pFncEntry++;
    };

    return("???");
}

/** findFlagName - get the string associated with a flag
*
*    Purpose - return a string associated with the flags for a
*              floating point instruction
*
*    Input:
*      flag    - the flags on the opcode
*      opcode  - the opcode; if it's Cvt*, we use different flags
*
*    Output:
*      pointer to string describing flags, or "/???"
*
***************/

char *
findFlagName(ULONG flag, ULONG function)
{

     PFPFLAGS table;

     if (function == CVTQL_FUNC) {
         switch (flag) {
         case C_FLAGS:
              return "";
         case VC_FLAGS:
              return "/v";
         case SVC_FLAGS:
              return "/sv";
         }
     }

     if ((function == CVTTQ_FUNC) || (function == CVTGQ_FUNC)) {
         table = ConvertFlags;
     } else {
         table = FloatOpFlags;
     }

     while (table->flags != FPFLAGS_NOT_AN_ENTRY) {

         if (table->flags == flag) {
              return(table->flagname);
         }
         table++;
    }

    // no match found
    //

    return("/???");
}


/*** opTableInit - initialize fields used in and with the opTable
*
*   Purpose:
*       This routine is called once, and sets up pointers to the
*       subtables embedded in the opTable, such as AddOpTab, and
*       sizes for these subtables.  It also checks that all like
*       instructions are grouped together in the table, which is
*       the only requirement on it.
*
*   Input:
*       None.
*
*   Output:
*       None.
*
*   Errors:
*       If the table is not properly organized (four types separated,
*       and the functions for a single opcode grouped), this prints a
*       messages and fails
*
*   Exceptions:
*       None.
*
*************************************************************************/


HRESULT
opTableInit(void)
{

    ULONG typesDone[4] = {0,0,0,0};

    ULONG palDone, arithDone, bitDone, byteDone, jmpDone;
    ULONG fpopDone, vaxDone, IEEEDone, mulDone, sextDone, memSpcDone;

    ULONG        index;

    POPTBLENTRY  entry;

    ENTRY_TYPE   curType = NOT_AN_ETYPE;
    ULONG        curFunc = NO_FUNC;    // OPCODE field in func entry

    //
    // To set the end of the table, and its size, without having
    // nested case statements, maintain pointers to the entry and
    // function tables we are currently walking through
    //

    PULONG        curTypeSize,       curFuncSize;
    POPTBLENTRY * curTypeTable,    * curFuncTable;


    //
    // these will be reset before they are needed, but not before
    // they are used.
    //

    curTypeTable = (POPTBLENTRY *)&curTypeTable;
    curTypeSize  = (PULONG)&curTypeSize;
    curFuncTable = (POPTBLENTRY *)&curFuncTable;
    curFuncSize  = (PULONG)&curFuncSize;

    palDone = arithDone = bitDone = byteDone = jmpDone = 0;
    fpopDone = vaxDone = IEEEDone = mulDone = sextDone = memSpcDone = 0;

    for (index = 0 ; index < SEARCHNUM; index++) {

        entry = &opTable[index];

        switch(entry->eType) {

         case INVALID_ETYPE:

             if (curType == entry->eType)
                 continue;

             //
             // The entries must be together; if this is a
             // new type, we must never have seen it before
             //

             if (typesDone[INVALID_ETYPE]) {
                 ErrOut("Invalid table format: duplicate start of ");
                 ErrOut("INVALID_ETYPE at index %d\n", index);
                 return E_FAIL;
             }

             //
             // Finish off the old tables
             //

             *curTypeSize = (ULONG)(entry - *curTypeTable);
             if (curType == FUNCTION_ETYPE) {
                 *curFuncSize = (ULONG)(entry - *curFuncTable);
             }

             //
             // Set up the new table
             //

             InvalidTab = entry;
             curTypeSize = &InvalidTabSize;
             curTypeTable = &InvalidTab;
             curType = INVALID_ETYPE;
             typesDone[INVALID_ETYPE] = 1;
             break;

         case NON_TERMINAL_ETYPE:

             if (curType == entry->eType)
                 continue;

             if (typesDone[NON_TERMINAL_ETYPE]) {
                 ErrOut("Invalid table format: duplicate start of ");
                 ErrOut("NON_TERMINAL_ETYPE at index %d\n", index);
                 return E_FAIL;
             }

             *curTypeSize = (ULONG)(entry - *curTypeTable);
             if (curType == FUNCTION_ETYPE) {
                 *curFuncSize = (ULONG)(entry - *curFuncTable);
             }

             NonTerminalTab = entry;
             curTypeSize = &NonTerminalTabSize;
             curTypeTable = &NonTerminalTab;
             curType = NON_TERMINAL_ETYPE;
             typesDone[NON_TERMINAL_ETYPE] = 1;
             break;

         case TERMINAL_ETYPE:

             if (curType == entry->eType)
                 continue;

             if (typesDone[TERMINAL_ETYPE]) {
                 ErrOut("Invalid table format: duplicate start of ");
                 ErrOut("TERMINAL_ETYPE at index %d\n", index);
                 return E_FAIL;
             }

             *curTypeSize = (ULONG)(entry - *curTypeTable);
             if (curType == FUNCTION_ETYPE) {
                 *curFuncSize = (ULONG)(entry - *curFuncTable);
             }

             TerminalTab = entry;
             curTypeSize = &TerminalTabSize;
             curTypeTable = &TerminalTab;
             curType = TERMINAL_ETYPE;
             typesDone[TERMINAL_ETYPE] = 1;
             break;


         case FUNCTION_ETYPE:

             if (entry->opCode == curFunc)
                      continue;

             //
             // Take care of a new eType table; this exactly
             // parallels the three cases above (*_ETYPE)
             //

             if (curType != FUNCTION_ETYPE) {

                 if (typesDone[FUNCTION_ETYPE]) {
                     ErrOut("Invalid table format: duplicate start of ");
                     ErrOut("FUNCTION_ETYPE at index %d\n", index);
                     return E_FAIL;
                 }

                 *curTypeSize = (ULONG)(entry - *curTypeTable);

                 FunctionTab = entry;
                 curTypeSize = &FunctionTabSize;
                 curTypeTable = &FunctionTab;
                 curType = FUNCTION_ETYPE;
                 typesDone[FUNCTION_ETYPE] = 1;

             }

             //
             // Next, handle a new function table when this is a new
             // function (==> when this is the first entry in the
             // FunctionTab)
             //


             switch(entry->opCode) {

             POPTBLENTRY e;

             case CALLPAL_OP:

                 if (palDone) {
                     ErrOut("Invalid table format: duplicate start of ");
                     ErrOut("CALLPAL_OP at index %d\n", index);
                     return E_FAIL;
                 }

                 *curFuncSize = (ULONG)(entry - *curFuncTable);

                 e = findNonTerminalEntry(CALLPAL_OP);
                 if (e == NULL) {
                     return E_FAIL;
                 }
                 e->funcTable = entry;
                 curFuncSize = &(e->funcTableSize);
                 curFuncTable = &(e->funcTable);

                 curFunc = CALLPAL_OP;
                 palDone = 1;

                 break;

             case ARITH_OP:

                 if (arithDone) {
                     ErrOut("Invalid table format: duplicate start of ");
                     ErrOut("ARITH_OP at index %d\n", index);
                     return E_FAIL;
                 }

                 *curFuncSize = (ULONG)(entry - *curFuncTable);

                 e = findNonTerminalEntry(ARITH_OP);
                 if (e == NULL) {
                     return E_FAIL;
                 }
                 e->funcTable = entry;
                 curFuncSize = &(e->funcTableSize);
                 curFuncTable = &(e->funcTable);

                 curFunc = ARITH_OP;
                 arithDone = 1;

                 break;

             case BIT_OP:

                 if (bitDone) {
                     ErrOut("Invalid table format: duplicate start of ");
                     ErrOut("BIT_OP at index %d\n", index);
                     return E_FAIL;
                 }

                 *curFuncSize = (ULONG)(entry - *curFuncTable);

                 e = findNonTerminalEntry(BIT_OP);
                 if (e == NULL) {
                     return E_FAIL;
                 }
                 e->funcTable = entry;
                 curFuncSize = &(e->funcTableSize);
                 curFuncTable = &(e->funcTable);

                 curFunc = BIT_OP;
                 bitDone = 1;

                 break;

             case BYTE_OP:

                 if (byteDone) {
                     ErrOut("Invalid table format: duplicate start of ");
                     ErrOut("BYTE_OP at index %d\n", index);
                     return E_FAIL;
                 }

                 *curFuncSize = (ULONG)(entry - *curFuncTable);

                 e = findNonTerminalEntry(BYTE_OP);
                 if (e == NULL) {
                     return E_FAIL;
                 }
                 e->funcTable = entry;
                 curFuncSize = &(e->funcTableSize);
                 curFuncTable = &(e->funcTable);

                 curFunc = BYTE_OP;
                 byteDone = 1;

                 break;

             case MUL_OP:

                 if (mulDone) {
                     ErrOut("Invalid table format: duplicate start of ");
                     ErrOut("MUL_OP at index %d\n", index);
                     return E_FAIL;
                 }

                 *curFuncSize = (ULONG)(entry - *curFuncTable);

                 e = findNonTerminalEntry(MUL_OP);
                 if (e == NULL) {
                     return E_FAIL;
                 }
                 e->funcTable = entry;
                 curFuncSize = &(e->funcTableSize);
                 curFuncTable = &(e->funcTable);

                 curFunc = MUL_OP;
                 mulDone = 1;

                 break;

             case SEXT_OP:

                 if (sextDone) {
                     ErrOut("Invalid table format: duplicate start of ");
                     ErrOut("SEXT_OP at index %d\n", index);
                     return E_FAIL;
                 }

                 *curFuncSize = (ULONG)(entry - *curFuncTable);

                 e = findNonTerminalEntry(SEXT_OP);
                 if (e == NULL) {
                     return E_FAIL;
                 }
                 e->funcTable = entry;
                 curFuncSize = &(e->funcTableSize);
                 curFuncTable = &(e->funcTable);

                 curFunc = SEXT_OP;
                 sextDone = 1;

                 break;

             case MEMSPC_OP:

                 if (memSpcDone) {
                     ErrOut("Invalid table format: duplicate start of ");
                     ErrOut("MEMSPC_OP at index %d\n", index);
                     return E_FAIL;
                 }

                 *curFuncSize = (ULONG)(entry - *curFuncTable);

                 e = findNonTerminalEntry(MEMSPC_OP);
                 if (e == NULL) {
                     return E_FAIL;
                 }
                 e->funcTable = entry;
                 curFuncSize = &(e->funcTableSize);
                 curFuncTable = &(e->funcTable);

                 curFunc = MEMSPC_OP;
                 memSpcDone = 1;

                 break;

             case JMP_OP:

                 if (jmpDone) {
                     ErrOut("Invalid table format: duplicate start of ");
                     ErrOut("JMP_OP at index %d\n", index);
                     return E_FAIL;
                 }

                 *curFuncSize = (ULONG)(entry - *curFuncTable);

                 e = findNonTerminalEntry(JMP_OP);
                 if (e == NULL) {
                     return E_FAIL;
                 }
                 e->funcTable = entry;
                 curFuncSize = &(e->funcTableSize);
                 curFuncTable = &(e->funcTable);

                 curFunc = JMP_OP;
                 jmpDone = 1;

                 break;

             case VAXFP_OP:

                 if (vaxDone) {
                     ErrOut("Invalid table format: duplicate start of ");
                     ErrOut("VAXFP_OP at index %d\n", index);
                     return E_FAIL;
                 }

                 *curFuncSize = (ULONG)(entry - *curFuncTable);

                 e = findNonTerminalEntry(VAXFP_OP);
                 if (e == NULL) {
                     return E_FAIL;
                 }
                 e->funcTable = entry;
                 curFuncSize = &(e->funcTableSize);
                 curFuncTable = &(e->funcTable);

                 curFunc = VAXFP_OP;
                 vaxDone = 1;

                 break;

             case IEEEFP_OP:

                 if (IEEEDone) {
                     ErrOut("Invalid table format: duplicate start of ");
                     ErrOut("IEEEFP_OP at index %d\n", index);
                     return E_FAIL;
                 }

                 *curFuncSize = (ULONG)(entry - *curFuncTable);

                 e = findNonTerminalEntry(IEEEFP_OP);
                 if (e == NULL) {
                     return E_FAIL;
                 }
                 e->funcTable = entry;
                 curFuncSize = &(e->funcTableSize);
                 curFuncTable = &(e->funcTable);

                 curFunc = IEEEFP_OP;
                 IEEEDone = 1;

                 break;

             case FPOP_OP:

                 if (fpopDone) {
                     ErrOut("Invalid table format: duplicate start of ");
                     ErrOut("FPOP_OP at index %d\n", index);
                     return E_FAIL;
                 }

                 *curFuncSize = (ULONG)(entry - *curFuncTable);

                 e = findNonTerminalEntry(FPOP_OP);
                 if (e == NULL) {
                     return E_FAIL;
                 }
                 e->funcTable = entry;
                 curFuncSize = &(e->funcTableSize);
                 curFuncTable = &(e->funcTable);

                 curFunc = FPOP_OP;
                 fpopDone = 1;

                 break;

             default:

                 ErrOut("Unexpected function type %d at %08x for %s\n",
                        entry->eType, entry, entry->pszAlphaName);
                 return E_FAIL;

            }  // end of Function table switch

            break;

        default:

            ErrOut("Unexpected entry type %d at %08x for %s\n",
                   entry->eType, entry, entry->pszAlphaName);
            return E_FAIL;

        }      // end of etype table switch
    }          // end of For switch

    //
    // close out the size of the last tables
    //

    if (curType == FUNCTION_ETYPE) {
        *curFuncSize = (ULONG)(&opTable[SEARCHNUM] - *curFuncTable);
    }
    *curTypeSize = (ULONG)(&opTable[SEARCHNUM] - *curTypeTable);

#if 0
    if (fVerboseOutput) {
        printTable();
    }
#endif

    return S_OK;
}              // end of opTableInit

void printTable(void)
{
   ULONG i;
   POPTBLENTRY e;

   for (i = 0 ; i < SEARCHNUM; i++) {
       e = &opTable[i];
       switch (e->eType) {
       case INVALID_ETYPE:
           dprintf("%12s %08x op: %4d %8d %2d INVALID\n",
              e->pszAlphaName, e->parsFunc, e->opCode, e->funcCode, e->iType);
           break;

       case TERMINAL_ETYPE:
           dprintf("%12s %08x op: %4d %8d %2d TERMINAL\n",
              e->pszAlphaName, e->parsFunc, e->opCode, e->funcCode, e->iType);
           break;

       case FUNCTION_ETYPE:
           dprintf("%12s %08x op: %4d %8d %2d FUNCTION\n",
              e->pszAlphaName, e->parsFunc, e->opCode, e->funcCode, e->iType);
           break;

       case NON_TERMINAL_ETYPE:
           dprintf("%12x %08x op: %4d %8d %2d NON_TERMINAL\n",
              e->funcTable, e->funcTableSize,
              e->opCode, e->funcCode, e->iType);
           break;
       }
   }

   dprintf("InvalidTab     %08x  InvalidTabSize     %03x\n",
            InvalidTab, InvalidTabSize);

   dprintf("TerminalTab    %08x  TerminalTabSize    %03x\n",
            TerminalTab, TerminalTabSize);

   dprintf("NonTerminalTab %08x  NonTerminalTabSize %03x\n",
            NonTerminalTab, NonTerminalTabSize);

   dprintf("FunctionTab    %08x  FunctionTabSize    %03x\n",
            FunctionTab, FunctionTabSize);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\alpha_optable.h ===
/*++

Copyright (c) 1993  Digital Equipment Corporation
Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    alpha_optable.h

Abstract:

    Definitions for -
    Table of operations, their names and charactersitics
    Used by ntsd, windbg and acc's dissassembler

Author:

    Miche Baker-Harvey (mbh) 10-Jan-1993

Revision History:

--*/

#ifndef _ALPHA_OPTABLE_
#define _ALPHA_OPTABLE_

//
// Each entry in the opTable is either for a
// +  function - one option on a particular opcode
// +  terminal opcode - an opcode without a function field
//      the above two can both appear directly in disassembly
//
// +  non terminal opcode - an opcode with a function field:
//      these entries do not represent values which can be
//      executed directly:  they require a function entry.
//
// + invalid opcode - this is an opcode reserved to digital
//

typedef enum ENTRY_TYPE {

   INVALID_ETYPE,
   NON_TERMINAL_ETYPE,
   TERMINAL_ETYPE,
   FUNCTION_ETYPE,
   NOT_AN_ETYPE

} ENTRY_TYPE;


#define NO_FUNC   (ULONG)-1

typedef ULONG (* PFOPPARSE)(PSTR, PSTR *, struct _OPTBLENTRY *, PULONG64);

typedef struct _OPTBLENTRY {

    union {

        struct {

            PCHAR      _pszName;                // Name of the instruction
            PFOPPARSE  _parsFunc;               // Function to parse operands

        } s0;                  // functions and terminal opcodes

        struct {

            struct _OPTBLENTRY * _funcTable;    // Describes funcs for opcode
            ULONG            _funcTableSize;    // Number of possible funcs

        } s1;                  // non-terminal opcodes

    } u;

    //
    // These fields describe the instruction
    //

    ULONG opCode;       // Top 6 bits of a 32-bit alpha instr
    ULONG funcCode;     // Function; meaning is opcode dependent
    ULONG iType;        // type of the instr: branch, fp, mem...
                        // values are ALPHA_* in alphaops.h

    ENTRY_TYPE eType;   // type of this entry in the opTable

} OPTBLENTRY, * POPTBLENTRY;

//
// MBH - hack workaround:
// I tried to do this with nameless functions and structures;
// it works just fine on ALPHA, but dies on 386, so use this
// ugly hack instead.
// The name "pszAlphaName" is used instead of the more obvious
// "pszName" because other structures contain pszName.
//
#define pszAlphaName  u.s0._pszName
#define parsFunc      u.s0._parsFunc
#define funcTable     u.s1._funcTable
#define funcTableSize u.s1._funcTableSize

POPTBLENTRY findNonTerminalEntry(ULONG);
POPTBLENTRY findStringEntry(PSTR Str);
POPTBLENTRY findOpCodeEntry(ULONG);
char * findFuncName(POPTBLENTRY, ULONG);
char * findFlagName(ULONG, ULONG);

HRESULT opTableInit(void);

//
// This structure is used for the floating point flag names.
//

#define FPFLAGS_NOT_AN_ENTRY 0xffffffff

typedef struct _FPFLAGS {

    ULONG flags;        // the flags on the opcode
    PCHAR flagname;    // the string mnemonic for the flags

} FPFLAGS, * PFPFLAGS;


#endif   // _ALPHA_OPTABLE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\alpha_reg.h ===
enum
{
    ALPHA_F0, ALPHA_F1, ALPHA_F2, ALPHA_F3,
    ALPHA_F4, ALPHA_F5, ALPHA_F6, ALPHA_F7,
    ALPHA_F8, ALPHA_F9, ALPHA_F10, ALPHA_F11,
    ALPHA_F12, ALPHA_F13, ALPHA_F14, ALPHA_F15,
    ALPHA_F16, ALPHA_F17, ALPHA_F18, ALPHA_F19,
    ALPHA_F20, ALPHA_F21, ALPHA_F22, ALPHA_F23,
    ALPHA_F24, ALPHA_F25, ALPHA_F26, ALPHA_F27,
    ALPHA_F28, ALPHA_F29, ALPHA_F30, ALPHA_F31,
        
    ALPHA_V0, ALPHA_T0, ALPHA_T1, ALPHA_T2,
    ALPHA_T3, ALPHA_T4, ALPHA_T5, ALPHA_T6,
    ALPHA_T7, ALPHA_S0, ALPHA_S1, ALPHA_S2,
    ALPHA_S3, ALPHA_S4, ALPHA_S5, ALPHA_FP,
    ALPHA_A0, ALPHA_A1, ALPHA_A2, ALPHA_A3,
    ALPHA_A4, ALPHA_A5, ALPHA_T8, ALPHA_T9,
    ALPHA_T10, ALPHA_T11, ALPHA_RA, ALPHA_T12,
    ALPHA_AT, ALPHA_GP, ALPHA_SP, ALPHA_ZERO,
        
    ALPHA_FPCR, ALPHA_SFTFPCR, ALPHA_FIR,

    ALPHA_PSR,

    ALPHA_MODE, ALPHA_IE, ALPHA_IRQL,
};

#define ALPHA_FLT_BASE ALPHA_F0
#define ALPHA_FLT_LAST ALPHA_F31
#define ALPHA_INT64_BASE ALPHA_V0
#define ALPHA_INT64_LAST ALPHA_FIR
#define ALPHA_INT32_BASE ALPHA_PSR
#define ALPHA_INT32_LAST ALPHA_PSR
#define ALPHA_FLAG_BASE ALPHA_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\alpha_strings.h ===
/*++

Copyright (c) 1993  Digital Equipment Corporation

Module Name:

    alpha_strings.h

Abstract:

    strings to be used in windbg, ntsd, disassembler;
    these strings are generated into tables in optable.c.

Author:

    Miche Baker-Harvey (mbh) 10-Jan-1993

Revision History:
    modified from strings.h in windbg.

--*/

/*
**  alpha_optable.c should define DEFINE_STRINGS before including this file,
**  so that the strings will be defined rather than just declared.
*/

#ifdef DEFINE_STRINGS
#define DECL_STR(name, value)   char name[] = value
#undef  DEFINE_STRINGS
#else
#define DECL_STR(name, value)   extern char name[]
#endif


//
// The integer registers
//

DECL_STR(   g_AlphaV0   , V0_REG_STR);
DECL_STR(   g_AlphaT0   , T0_REG_STR);
DECL_STR(   g_AlphaT1   , T1_REG_STR);
DECL_STR(   g_AlphaT2   , T2_REG_STR);
DECL_STR(   g_AlphaT3   , T3_REG_STR);
DECL_STR(   g_AlphaT4   , T4_REG_STR);
DECL_STR(   g_AlphaT5   , T5_REG_STR);
DECL_STR(   g_AlphaT6   , T6_REG_STR);
DECL_STR(   g_AlphaT7   , T7_REG_STR);
DECL_STR(   g_AlphaS0   , S0_REG_STR);
DECL_STR(   g_AlphaS1   , S1_REG_STR);
DECL_STR(   g_AlphaS2   , S2_REG_STR);
DECL_STR(   g_AlphaS3   , S3_REG_STR);
DECL_STR(   g_AlphaS4   , S4_REG_STR);
DECL_STR(   g_AlphaS5   , S5_REG_STR);
DECL_STR(   g_AlphaFP   , FP_REG_STR);
DECL_STR(   g_AlphaA0   , A0_REG_STR);
DECL_STR(   g_AlphaA1   , A1_REG_STR);
DECL_STR(   g_AlphaA2   , A2_REG_STR);
DECL_STR(   g_AlphaA3   , A3_REG_STR);
DECL_STR(   g_AlphaA4   , A4_REG_STR);
DECL_STR(   g_AlphaA5   , A5_REG_STR);
DECL_STR(   g_AlphaT8   , T8_REG_STR);
DECL_STR(   g_AlphaT9   , T9_REG_STR);
DECL_STR(   g_AlphaT10  , T10_REG_STR);
DECL_STR(   g_AlphaT11  , T11_REG_STR);
DECL_STR(   g_AlphaRA   , RA_REG_STR);
DECL_STR(   g_AlphaT12  , T12_REG_STR);
DECL_STR(   g_AlphaAT   , AT_REG_STR);
DECL_STR(   g_AlphaGP   , GP_REG_STR);
DECL_STR(   g_AlphaSP   , SP_REG_STR);
DECL_STR(   g_AlphaZero , ZERO_REG_STR);

//
// ALPHA other accessible registers
//

DECL_STR(   szFpcr , "fpcr");      // floating point control register
DECL_STR(   szSoftFpcr , "softfpcr");      // floating point control register
DECL_STR(   szFir  , "fir");       // fetched/faulting instruction: nextPC
DECL_STR(   szPsr  , "psr");       // processor status register: see flags

//
// these flags are associated with the psr);
// defined in ntalpha.h.
DECL_STR(   szFlagMode  , "mode");        // mode: 1? user : system
DECL_STR(   szFlagIe    , "ie");          // interrupt enable
DECL_STR(   szFlagIrql  , "irql");        // IRQL level: 3 bits
DECL_STR(   szFlagInt5  , "int5");
DECL_STR(   szFlagInt4  , "int4");
DECL_STR(   szFlagInt3  , "int3");
DECL_STR(   szFlagInt2  , "int2");
DECL_STR(   szFlagInt1  , "int1");
DECL_STR(   szFlagInt0  , "int0");

DECL_STR(    szGPReg    , "$gp");


//
// Thread states
//


DECL_STR(SzFrozen,      "Frozen");
DECL_STR(SzSuspended,   "Suspended");
DECL_STR(SzBlocked,     "Blocked");

DECL_STR(SzRunnable,    "Runnable");
DECL_STR(SzRunning,     "Running");
DECL_STR(SzStopped,     "Stopped");
DECL_STR(SzExiting,     "Exiting");
DECL_STR(SzDead,        "Dead");
DECL_STR(SzUnknown,     "UNKNOWN");

DECL_STR(SzExcept1st,   "Except1st");
DECL_STR(SzExcept2nd,   "Except2nd");
DECL_STR(SzRipped,      "RIP");

DECL_STR(SzCritSec,     "CritSec");

DECL_STR(SzStandard,    "Standard");

//
// taken from alphaops.h, and munged with emacs
//

DECL_STR( szLda, LDA_OP_STR );
DECL_STR( szLdah, LDAH_OP_STR );
DECL_STR( szLdq_u, LDQ_U_OP_STR );
DECL_STR( szStq_u, STQ_U_OP_STR );
DECL_STR( szLdf, LDF_OP_STR );
DECL_STR( szLdg, LDG_OP_STR );
DECL_STR( szLds, LDS_OP_STR );
DECL_STR( szLdt, LDT_OP_STR );
DECL_STR( szStf, STF_OP_STR );
DECL_STR( szStg, STG_OP_STR );
DECL_STR( szSts, STS_OP_STR );
DECL_STR( szStt, STT_OP_STR );
DECL_STR( szLdbu, LDBU_OP_STR );
DECL_STR( szLdwu, LDWU_OP_STR );
DECL_STR( szLdl, LDL_OP_STR );
DECL_STR( szLdq, LDQ_OP_STR );
DECL_STR( szLdl_l, LDL_L_OP_STR );
DECL_STR( szLdq_l, LDQ_L_OP_STR );
DECL_STR( szStb, STB_OP_STR );
DECL_STR( szStw, STW_OP_STR );
DECL_STR( szStl, STL_OP_STR );
DECL_STR( szStq, STQ_OP_STR );
DECL_STR( szStl_c, STL_C_OP_STR );
DECL_STR( szStq_c, STQ_C_OP_STR );
DECL_STR( szBr, BR_OP_STR );
DECL_STR( szFbeq, FBEQ_OP_STR );
DECL_STR( szFblt, FBLT_OP_STR );
DECL_STR( szFble, FBLE_OP_STR );
DECL_STR( szBsr, BSR_OP_STR );
DECL_STR( szFbne, FBNE_OP_STR );
DECL_STR( szFbge, FBGE_OP_STR );
DECL_STR( szFbgt, FBGT_OP_STR );
DECL_STR( szBlbc, BLBC_OP_STR );
DECL_STR( szBeq, BEQ_OP_STR );
DECL_STR( szBlt, BLT_OP_STR );
DECL_STR( szBle, BLE_OP_STR );
DECL_STR( szBlbs, BLBS_OP_STR );
DECL_STR( szBne, BNE_OP_STR );
DECL_STR( szBge, BGE_OP_STR );
DECL_STR( szBgt, BGT_OP_STR );
DECL_STR( szMb, MB_FUNC_STR );
DECL_STR( szWmb, MB1_FUNC_STR );
DECL_STR( szMb2, MB2_FUNC_STR );
DECL_STR( szMb3, MB3_FUNC_STR );
DECL_STR( szFetch, FETCH_FUNC_STR );
DECL_STR( szRs, RS_FUNC_STR );
DECL_STR( szTrapb, TRAPB_FUNC_STR );
DECL_STR( szExcb, EXCB_FUNC_STR );
DECL_STR( szFetch_m, FETCH_M_FUNC_STR );
DECL_STR( szRpcc, RPCC_FUNC_STR );
DECL_STR( szRc, RC_FUNC_STR );
DECL_STR( szJmp, JMP_FUNC_STR );
DECL_STR( szJsr, JSR_FUNC_STR );
DECL_STR( szRet, RET_FUNC_STR );
DECL_STR( szJsr_co, JSR_CO_FUNC_STR );

DECL_STR( szAddl, ADDL_FUNC_STR );
DECL_STR( szAddlv, ADDLV_FUNC_STR );
DECL_STR( szS4addl, S4ADDL_FUNC_STR );
DECL_STR( szS8addl, S8ADDL_FUNC_STR );
DECL_STR( szAddq, ADDQ_FUNC_STR );
DECL_STR( szAddqv, ADDQV_FUNC_STR );
DECL_STR( szS4addq, S4ADDQ_FUNC_STR );
DECL_STR( szS8addq, S8ADDQ_FUNC_STR );
DECL_STR( szSubl, SUBL_FUNC_STR );
DECL_STR( szSublv, SUBLV_FUNC_STR );
DECL_STR( szS4subl, S4SUBL_FUNC_STR );
DECL_STR( szS8subl, S8SUBL_FUNC_STR );
DECL_STR( szSubq, SUBQ_FUNC_STR );
DECL_STR( szSubqv, SUBQV_FUNC_STR );
DECL_STR( szS4subq, S4SUBQ_FUNC_STR );
DECL_STR( szS8subq, S8SUBQ_FUNC_STR );


DECL_STR( szCmpeq, CMPEQ_FUNC_STR );
DECL_STR( szCmplt, CMPLT_FUNC_STR );
DECL_STR( szCmple, CMPLE_FUNC_STR );
DECL_STR( szCmpult, CMPULT_FUNC_STR );
DECL_STR( szCmpule, CMPULE_FUNC_STR );
DECL_STR( szCmpbge, CMPBGE_FUNC_STR );
DECL_STR( szAnd, AND_FUNC_STR );
DECL_STR( szBic, BIC_FUNC_STR );
DECL_STR( szBis, BIS_FUNC_STR );
DECL_STR( szEqv, EQV_FUNC_STR );
DECL_STR( szOrnot, ORNOT_FUNC_STR );
DECL_STR( szXor, XOR_FUNC_STR );
DECL_STR( szCmoveq, CMOVEQ_FUNC_STR );
DECL_STR( szCmovge, CMOVGE_FUNC_STR );
DECL_STR( szCmovgt, CMOVGT_FUNC_STR );
DECL_STR( szCmovlbc, CMOVLBC_FUNC_STR );
DECL_STR( szCmovlbs, CMOVLBS_FUNC_STR );
DECL_STR( szCmovle, CMOVLE_FUNC_STR );
DECL_STR( szCmovlt, CMOVLT_FUNC_STR );
DECL_STR( szCmovne, CMOVNE_FUNC_STR );
DECL_STR( szSll, SLL_FUNC_STR );
DECL_STR( szSrl, SRL_FUNC_STR );
DECL_STR( szSra, SRA_FUNC_STR );
DECL_STR( szExtbl, EXTBL_FUNC_STR );
DECL_STR( szExtwl, EXTWL_FUNC_STR );
DECL_STR( szExtll, EXTLL_FUNC_STR );
DECL_STR( szExtql, EXTQL_FUNC_STR );
DECL_STR( szExtwh, EXTWH_FUNC_STR );
DECL_STR( szExtlh, EXTLH_FUNC_STR );
DECL_STR( szExtqh, EXTQH_FUNC_STR );
DECL_STR( szInsbl, INSBL_FUNC_STR );
DECL_STR( szInswl, INSWL_FUNC_STR );
DECL_STR( szInsll, INSLL_FUNC_STR );
DECL_STR( szInsql, INSQL_FUNC_STR );
DECL_STR( szInswh, INSWH_FUNC_STR );
DECL_STR( szInslh, INSLH_FUNC_STR );
DECL_STR( szInsqh, INSQH_FUNC_STR );
DECL_STR( szMskbl, MSKBL_FUNC_STR );
DECL_STR( szMskwl, MSKWL_FUNC_STR );
DECL_STR( szMskll, MSKLL_FUNC_STR );
DECL_STR( szMskql, MSKQL_FUNC_STR );
DECL_STR( szMskwh, MSKWH_FUNC_STR );
DECL_STR( szMsklh, MSKLH_FUNC_STR );
DECL_STR( szMskqh, MSKQH_FUNC_STR );
DECL_STR( szZap, ZAP_FUNC_STR );
DECL_STR( szZapnot, ZAPNOT_FUNC_STR );
DECL_STR( szMull, MULL_FUNC_STR );
DECL_STR( szMullv, MULLV_FUNC_STR );
DECL_STR( szMulq, MULQ_FUNC_STR );
DECL_STR( szMulqv, MULQV_FUNC_STR );
DECL_STR( szUmulh, UMULH_FUNC_STR );
DECL_STR( szSextb, SEXTB_FUNC_STR );
DECL_STR( szSextw, SEXTW_FUNC_STR );
DECL_STR( szCtpop, CTPOP_FUNC_STR );
DECL_STR( szCtlz, CTLZ_FUNC_STR );
DECL_STR( szCttz, CTTZ_FUNC_STR );
DECL_STR( szCvtlq, CVTLQ_FUNC_STR );
DECL_STR( szCpys, CPYS_FUNC_STR );
DECL_STR( szCpysn, CPYSN_FUNC_STR );
DECL_STR( szCpyse, CPYSE_FUNC_STR );
DECL_STR( szMt_fpcr, MT_FPCR_FUNC_STR );
DECL_STR( szMf_fpcr, MF_FPCR_FUNC_STR );
DECL_STR( szFcmoveq, FCMOVEQ_FUNC_STR );
DECL_STR( szFcmovne, FCMOVNE_FUNC_STR );
DECL_STR( szFcmovlt, FCMOVLT_FUNC_STR );
DECL_STR( szFcmovge, FCMOVGE_FUNC_STR );
DECL_STR( szFcmovle, FCMOVLE_FUNC_STR );
DECL_STR( szFcmovgt, FCMOVGT_FUNC_STR );
DECL_STR( szCvtql, CVTQL_FUNC_STR );
DECL_STR( szCvtqlv, CVTQLV_FUNC_STR );
DECL_STR( szCvtqlsv, CVTQLSV_FUNC_STR );
DECL_STR( szAdds, ADDS_FUNC_STR );
DECL_STR( szSubs, SUBS_FUNC_STR );
DECL_STR( szMuls, MULS_FUNC_STR );
DECL_STR( szDivs, DIVS_FUNC_STR );
DECL_STR( szAddt, ADDT_FUNC_STR );
DECL_STR( szSubt, SUBT_FUNC_STR );
DECL_STR( szMult, MULT_FUNC_STR );
DECL_STR( szDivt, DIVT_FUNC_STR );
DECL_STR( szCmptun, CMPTUN_FUNC_STR );
DECL_STR( szCmpteq, CMPTEQ_FUNC_STR );
DECL_STR( szCmptlt, CMPTLT_FUNC_STR );
DECL_STR( szCmptle, CMPTLE_FUNC_STR );
DECL_STR( szCvtts, CVTTS_FUNC_STR );
DECL_STR( szCvttq, CVTTQ_FUNC_STR );
DECL_STR( szCvtqs, CVTQS_FUNC_STR );
DECL_STR( szCvtqt, CVTQT_FUNC_STR );
DECL_STR( szCvtst, CVTST_FUNC_STR );
DECL_STR( szCvtsts, CVTST_S_FUNC_STR );

DECL_STR( szAddf, ADDF_FUNC_STR );
DECL_STR( szCvtdg, CVTDG_FUNC_STR );
DECL_STR( szAddg, ADDG_FUNC_STR );
DECL_STR( szCmpgeq, CMPGEQ_FUNC_STR );
DECL_STR( szCmpglt, CMPGLT_FUNC_STR );
DECL_STR( szCmpgle, CMPGLE_FUNC_STR );
DECL_STR( szCvtgf, CVTGF_FUNC_STR );
DECL_STR( szCvtgd, CVTGD_FUNC_STR );
DECL_STR( szCvtqf, CVTQF_FUNC_STR );
DECL_STR( szCvtqg, CVTQG_FUNC_STR );
DECL_STR( szDivf, DIVF_FUNC_STR );
DECL_STR( szDivg, DIVG_FUNC_STR );
DECL_STR( szMulf, MULF_FUNC_STR );
DECL_STR( szMulg, MULG_FUNC_STR );
DECL_STR( szSubf, SUBF_FUNC_STR );
DECL_STR( szSubg, SUBG_FUNC_STR );
DECL_STR( szCvtgq, CVTGQ_FUNC_STR );
DECL_STR( szC, C_FLAGS_STR );
DECL_STR( szM, M_FLAGS_STR );
DECL_STR( szNone, NONE_FLAGS_STR );
DECL_STR( szD, D_FLAGS_STR );
DECL_STR( szUc, UC_FLAGS_STR );
DECL_STR( szVc, VC_FLAGS_STR );
DECL_STR( szUm, UM_FLAGS_STR );
DECL_STR( szVm, VM_FLAGS_STR );
DECL_STR( szU, U_FLAGS_STR );
DECL_STR( szV, V_FLAGS_STR );
DECL_STR( szUd, UD_FLAGS_STR );
DECL_STR( szVd, VD_FLAGS_STR );
DECL_STR( szSc, SC_FLAGS_STR );
DECL_STR( szS, S_FLAGS_STR );
DECL_STR( szSuc, SUC_FLAGS_STR );
DECL_STR( szSvc, SVC_FLAGS_STR );
DECL_STR( szSum, SUM_FLAGS_STR );
DECL_STR( szSvm, SVM_FLAGS_STR );
DECL_STR( szSu, SU_FLAGS_STR );
DECL_STR( szSv, SV_FLAGS_STR );
DECL_STR( szSud, SUD_FLAGS_STR );
DECL_STR( szSvd, SVD_FLAGS_STR );
DECL_STR( szSuic, SUIC_FLAGS_STR );
DECL_STR( szSvic, SVIC_FLAGS_STR );
DECL_STR( szSuim, SUIM_FLAGS_STR );
DECL_STR( szSvim, SVIM_FLAGS_STR );
DECL_STR( szSui, SUI_FLAGS_STR );
DECL_STR( szSvi, SVI_FLAGS_STR );
DECL_STR( szSuid, SUID_FLAGS_STR );
DECL_STR( szSvid, SVID_FLAGS_STR );

DECL_STR( szBpt, BPT_FUNC_STR );
DECL_STR( szCallsys, CALLSYS_FUNC_STR );
DECL_STR( szImb, IMB_FUNC_STR );
DECL_STR( szRdteb, RDTEB_FUNC_STR );
DECL_STR( szRdteb64, RDTEB64_FUNC_STR );
DECL_STR( szGentrap, GENTRAP_FUNC_STR );
DECL_STR( szKbpt, KBPT_FUNC_STR );
DECL_STR( szCallKD, CALLKD_FUNC_STR );
DECL_STR( szHalt, HALT_FUNC_STR );
DECL_STR( szRestart, RESTART_FUNC_STR );
DECL_STR( szDraina, DRAINA_FUNC_STR );
DECL_STR( szInitpal, INITPAL_FUNC_STR );
DECL_STR( szWrentry, WRENTRY_FUNC_STR );
DECL_STR( szSwpirql, SWPIRQL_FUNC_STR );
DECL_STR( szRdirql, RDIRQL_FUNC_STR );
DECL_STR( szDi, DI_FUNC_STR );
DECL_STR( szEi, EI_FUNC_STR );
DECL_STR( szSwppal, SWPPAL_FUNC_STR );
DECL_STR( szSsir, SSIR_FUNC_STR );
DECL_STR( szCsir, CSIR_FUNC_STR );
DECL_STR( szRfe, RFE_FUNC_STR );
DECL_STR( szRetsys, RETSYS_FUNC_STR );
DECL_STR( szSwpctx, SWPCTX_FUNC_STR );
DECL_STR( szSwpprocess, SWPPROCESS_FUNC_STR );
DECL_STR( szRdmces, RDMCES_FUNC_STR );
DECL_STR( szWrmces, WRMCES_FUNC_STR );
DECL_STR( szTbia, TBIA_FUNC_STR );
DECL_STR( szTbis, TBIS_FUNC_STR );
DECL_STR( szDtbis, DTBIS_FUNC_STR );
DECL_STR( szRdksp, RDKSP_FUNC_STR );
DECL_STR( szSwpksp, SWPKSP_FUNC_STR );
DECL_STR( szRdpsr, RDPSR_FUNC_STR );
DECL_STR( szRdpcr, RDPCR_FUNC_STR );
DECL_STR( szRdthread, RDTHREAD_FUNC_STR );
DECL_STR( szRdcounters, RDCOUNTERS_FUNC_STR );
DECL_STR( szRdstate, RDSTATE_FUNC_STR );
DECL_STR( szInitpcr, INITPCR_FUNC_STR );
DECL_STR( szWrperfmon, WRPERFMON_FUNC_STR );
DECL_STR( szMt, MTPR_OP_STR );
DECL_STR( szMf, MFPR_OP_STR );
DECL_STR( szHwld, HWLD_OP_STR );
DECL_STR( szHwst, HWST_OP_STR );
DECL_STR( szRei, REI_OP_STR );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\alpha_reg.cpp ===
/*** alpha_reg.c - processor-specific register structures
*
*   Copyright <C> 1990-2001, Microsoft Corporation
*   Copyright <C> 1992, Digital Equipment Corporation
*
*   Purpose:
*       Structures used to parse and access register and flag
*       fields.
*
*   Revision History:
*
*   [-]  08-Aug-1992 Miche Baker-Harvey Created for Alpha
*   [-]  01-Jul-1990 Richk      Created.
*
*************************************************************************/

#include "ntsdp.hpp"

#include "alpha_strings.h"
#include "alpha_optable.h"

// See Get/SetRegVal comments in machine.hpp.
#define RegValError Do_not_use_GetSetRegVal_in_machine_implementations
#define GetRegVal(index, val)   RegValError
#define GetRegVal32(index)      RegValError
#define GetRegVal64(index)      RegValError
#define SetRegVal(index, val)   RegValError
#define SetRegVal32(index, val) RegValError
#define SetRegVal64(index, val) RegValError

#define IS_FLOATING_SAVED(Register) ((SAVED_FLOATING_MASK >> Register) & 1L)
#define IS_INTEGER_SAVED(Register) ((SAVED_INTEGER_MASK >> Register) & 1L)


//
// Define saved register masks.

#define SAVED_FLOATING_MASK 0xfff00000  // saved floating registers
#define SAVED_INTEGER_MASK 0xf3ffff02   // saved integer registers


//
// Instruction opcode values are defined in alphaops.h
//

REGDEF AlphaRegs[] =
{
    g_F0, ALPHA_F0, g_F1, ALPHA_F1, g_F2, ALPHA_F2, g_F3, ALPHA_F3,
    g_F4, ALPHA_F4, g_F5, ALPHA_F5, g_F6, ALPHA_F6, g_F7, ALPHA_F7,
    g_F8, ALPHA_F8, g_F9, ALPHA_F9, g_F10, ALPHA_F10, g_F11, ALPHA_F11,
    g_F12, ALPHA_F12, g_F13, ALPHA_F13, g_F14, ALPHA_F14, g_F15, ALPHA_F15,
    g_F16, ALPHA_F16, g_F17, ALPHA_F17, g_F18, ALPHA_F18, g_F19, ALPHA_F19,
    g_F20, ALPHA_F20, g_F21, ALPHA_F21, g_F22, ALPHA_F22, g_F23, ALPHA_F23,
    g_F24, ALPHA_F24, g_F25, ALPHA_F25, g_F26, ALPHA_F26, g_F27, ALPHA_F27,
    g_F28, ALPHA_F28, g_F29, ALPHA_F29, g_F30, ALPHA_F30, g_F31, ALPHA_F31,

    g_AlphaV0, ALPHA_V0, g_AlphaT0, ALPHA_T0, g_AlphaT1, ALPHA_T1, g_AlphaT2, ALPHA_T2,
    g_AlphaT3, ALPHA_T3, g_AlphaT4, ALPHA_T4, g_AlphaT5, ALPHA_T5, g_AlphaT6, ALPHA_T6,
    g_AlphaT7, ALPHA_T7, g_AlphaS0, ALPHA_S0, g_AlphaS1, ALPHA_S1, g_AlphaS2, ALPHA_S2,
    g_AlphaS3, ALPHA_S3, g_AlphaS4, ALPHA_S4, g_AlphaS5, ALPHA_S5, g_AlphaFP, ALPHA_FP,
    g_AlphaA0, ALPHA_A0, g_AlphaA1, ALPHA_A1, g_AlphaA2, ALPHA_A2, g_AlphaA3, ALPHA_A3,
    g_AlphaA4, ALPHA_A4, g_AlphaA5, ALPHA_A5, g_AlphaT8, ALPHA_T8, g_AlphaT9, ALPHA_T9,
    g_AlphaT10, ALPHA_T10, g_AlphaT11, ALPHA_T11, g_AlphaRA, ALPHA_RA,
    g_AlphaT12, ALPHA_T12, g_AlphaAT, ALPHA_AT, g_AlphaGP, ALPHA_GP,
    g_AlphaSP, ALPHA_SP, g_AlphaZero, ALPHA_ZERO,

    szFpcr, ALPHA_FPCR, szSoftFpcr, ALPHA_SFTFPCR, szFir, ALPHA_FIR,

    szPsr, ALPHA_PSR,

    szFlagMode, ALPHA_MODE, szFlagIe, ALPHA_IE, szFlagIrql, ALPHA_IRQL,

    NULL, 0,
};

//
// PSR & IE definitions are from ksalpha.h
// which is generated automatically.
// Steal from \\bbox2\alphado\nt\public\sdk\inc\ksalpha.h
// NB: our masks are already shifted:
//
REGSUBDEF AlphaSubRegs[] =
{
    { ALPHA_MODE, ALPHA_PSR,   ALPHA_PSR_MODE,  ALPHA_PSR_MODE_MASK },
    { ALPHA_IE,   ALPHA_PSR,   ALPHA_PSR_IE,    ALPHA_PSR_IE_MASK   },
    { ALPHA_IRQL, ALPHA_PSR,   ALPHA_PSR_IRQL,  ALPHA_PSR_IRQL_MASK },
    { REG_ERROR, REG_ERROR, 0, 0 },
};

RegisterGroup g_AlphaGroup =
{
    NULL, 0, AlphaRegs, AlphaSubRegs, NULL
};

// First ExecTypes entry must be the actual processor type.
ULONG g_Axp32ExecTypes[] =
{
    IMAGE_FILE_MACHINE_ALPHA
};

// First ExecTypes entry must be the actual processor type.
ULONG g_Axp64ExecTypes[] =
{
    IMAGE_FILE_MACHINE_AXP64
};

Axp32MachineInfo g_Axp32Machine;
Axp64MachineInfo g_Axp64Machine;

HRESULT
AlphaMachineInfo::InitializeConstants(void)
{
    HRESULT Status;
    
    m_Groups = &g_AlphaGroup;
    m_AllMask = REGALL_INT64;
    m_MaxDataBreakpoints = 0;
    m_SymPrefix = NULL;

    // 32/64-bit values are set in the specific Initialize.
    // Alpha-generic values are here.
    
    C_ASSERT(sizeof(ALPHA_CONTEXT) == sizeof(ALPHA_NT5_CONTEXT));
    
    m_SizeTargetContext = sizeof(ALPHA_NT5_CONTEXT);
    m_OffsetTargetContextFlags = FIELD_OFFSET(ALPHA_NT5_CONTEXT, ContextFlags);
    m_SizeCanonicalContext = sizeof(ALPHA_NT5_CONTEXT);
    m_SverCanonicalContext = NT_SVER_NT4;
    m_SizeControlReport = sizeof(ALPHA_DBGKD_CONTROL_REPORT);
    m_OffsetSpecialRegisters = 0;
    m_SizeKspecialRegisters = 0;

    if ((Status = opTableInit()) != S_OK)
    {
        return Status;
    }
    
    return MachineInfo::InitializeConstants();
}

void
AlphaMachineInfo::
InitializeContext(ULONG64 Pc,
                  PDBGKD_ANY_CONTROL_REPORT ControlReport)
{
    m_Context.AlphaNt5Context.Fir = Pc;
    m_ContextState = Pc ? MCTX_PC : MCTX_NONE;

    if (Pc && ControlReport != NULL)
    {
        CacheReportInstructions
            (Pc, ControlReport->AlphaControlReport.InstructionCount,
             ControlReport->AlphaControlReport.InstructionStream);
    }
}

HRESULT
AlphaMachineInfo::KdGetContextState(ULONG State)
{
    // MCTX_CONTEXT and MCTX_FULL are the same for Alpha.
    if (State >= MCTX_CONTEXT && m_ContextState < MCTX_FULL)
    {
        HRESULT Status;
            
        Status = g_Target->GetContext(g_RegContextThread->Handle, &m_Context);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_FULL;
    }

    return S_OK;
}

HRESULT
AlphaMachineInfo::KdSetContext(void)
{
    return g_Target->SetContext(g_RegContextThread->Handle, &m_Context);
}

HRESULT
AlphaMachineInfo::ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                     ULONG FromSver,
                                     ULONG FromSize, PVOID From)
{
    if (FromSize < sizeof(ALPHA_NT5_CONTEXT))
    {
        return E_INVALIDARG;
    }
        
    PALPHA_CONTEXT Ctx = (PALPHA_CONTEXT)From;

    // ALPHA_CONTEXT has been floating around for a while
    // for use by the debugger.  The system hasn't used it
    // so they shouldn't ever end up here but go ahead
    // and try and detect them based on the flags.
    if (Ctx->ContextFlags != ALPHA_CONTEXT_FULL)
    {
        // This doesn't look like an ALPHA_CONTEXT, check
        // ALPHA_NT5_CONTEXT.
        if (((PALPHA_NT5_CONTEXT)From)->ContextFlags !=
            ALPHA_CONTEXT_FULL)
        {
            return E_INVALIDARG;
        }

        // It looks like an ALPHA_NT5_CONTEXT so don't convert.
        memcpy(Context, From, sizeof(ALPHA_NT5_CONTEXT));
    }
    else
    {
        PULONG High;
        PULONG Low;
        PULONGLONG Full;
        int Count;
    
        Low = &Ctx->FltF0;
        High = &Ctx->HighFltF0;
        Full = &Context->AlphaNt5Context.FltF0;
        for (Count = 0; Count < 32; Count++)
        {
            Full[Count] = Low[Count] + ((ULONGLONG)High[Count] << 32);
        }
        
        Low = &Ctx->IntV0;
        High = &Ctx->HighIntV0;
        Full = &Context->AlphaNt5Context.IntV0;
        for (Count = 0; Count < 32; Count++)
        {
            Full[Count] = Low[Count] + ((ULONGLONG)High[Count] << 32);
        }

        Context->AlphaNt5Context.ContextFlags = Ctx->ContextFlags;
        Context->AlphaNt5Context.Psr = Ctx->Psr;
        Context->AlphaNt5Context.Fpcr =
            Ctx->Fpcr + ((ULONGLONG)Ctx->HighFpcr << 32);
        Context->AlphaNt5Context.SoftFpcr =
            Ctx->SoftFpcr + ((ULONGLONG)Ctx->HighSoftFpcr << 32);
        Context->AlphaNt5Context.Fir =
            Ctx->Fir + ((ULONGLONG)Ctx->HighFir << 32);
    }

    return S_OK;
}

HRESULT
AlphaMachineInfo::ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                   ULONG ToSver, ULONG ToSize, PVOID To)
{
    if (ToSize < sizeof(ALPHA_NT5_CONTEXT))
    {
        return E_INVALIDARG;
    }
        
    memcpy(To, Context, sizeof(ALPHA_NT5_CONTEXT));

    return S_OK;
}

void
AlphaMachineInfo::InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                         ULONG Version)
{
    Context->AlphaNt5Context.ContextFlags = ALPHA_CONTEXT_FULL;
}

int
AlphaMachineInfo::GetType(ULONG index)
{
    if (
#if ALPHA_FLT_BASE > 0
        index >= ALPHA_FLT_BASE &&
#endif
        index <= ALPHA_FLT_LAST)
    {
        return REGVAL_FLOAT8;
    }
    else if (index >= ALPHA_INT64_BASE && index <= ALPHA_INT64_LAST)
    {
        return REGVAL_INT64;
    }
    else if (index >= ALPHA_INT32_BASE && index <= ALPHA_INT32_LAST)
    {
        return REGVAL_INT32;
    }
    else
    {
        return REGVAL_SUB32;
    }
}

/*** RegGetVal - get register value
*
*   Purpose:
*       Returns the value of the register from the processor
*       context structure.
*
*   Input:
*       regnum - register specification
*
*   Returns:
*       value of the register from the context structure
*
*************************************************************************/

BOOL
AlphaMachineInfo::GetVal (
    ULONG regnum,
    REGVAL *val
    )
{
    if (GetContextState(MCTX_FULL) != S_OK)
    {
        return FALSE;
    }

    val->type = GetType(regnum);
    // All registers except PSR are 64 bits and PSR is followed by
    // ContextFlags so it's safe to always just grab 64 bits for
    // the value.
    val->i64 = *(&m_Context.AlphaNt5Context.FltF0 + regnum);

    return TRUE;
}

/*** RegSetVal - set register value
*
*   Purpose:
*       Set the value of the register in the processor context
*       structure.
*
*   Input:
*       regnum - register specification
*       regvalue - new value to set the register
*
*   Output:
*       None.
*
*************************************************************************/

BOOL
AlphaMachineInfo::SetVal (
    ULONG regnum,
    REGVAL *val
    )
{
    if (m_ContextIsReadOnly)
    {
        return FALSE;
    }
    
    // Optimize away some common cases where registers are
    // set to their current value.
    if (m_ContextState >= MCTX_PC && regnum == ALPHA_FIR &&
        val->i64 == m_Context.AlphaNt5Context.Fir)
    {
        return TRUE;
    }
    
    if (GetContextState(MCTX_DIRTY) != S_OK)
    {
        return FALSE;
    }

    if (regnum == ALPHA_PSR)
    {
        // Be careful to only write 32 bits for PSR to preserve
        // ContextFlags.
        *(ULONG *)(&m_Context.AlphaNt5Context.FltF0 + regnum) = val->i32;
    }
    else
    {
        *(&m_Context.AlphaNt5Context.FltF0 + regnum) = val->i64;
    }

    NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS,
                              RegCountFromIndex(regnum));
    return TRUE;
}

/*** RegOutputAll - output all registers and present instruction
*
*   Purpose:
*       Function of "r" command.
*
*       To output the current register state of the processor.
*       All integer registers are output as well as processor status
*       registers.  Important flag fields are also output separately.
*       OutDisCurrent is called to output the current instruction(s).
*
*   Input:
*       None.
*
*   Output:
*       None.
*
*************************************************************************/

VOID
AlphaMachineInfo::OutputAll(ULONG Mask, ULONG OutMask)
{
    int     regindex;
    int     regnumber;
    ULONGLONG regvalue;

    if (GetContextState(MCTX_FULL) != S_OK)
    {
        ErrOut("Unable to retrieve register information\n");
        return;
    }
    
    if (Mask & (REGALL_INT32 | REGALL_INT64))
    {
        for (regindex = 0; regindex < 34; regindex++)
        {
            regnumber = GetIntRegNumber(regindex);
            regvalue = GetReg64(regnumber);

            if ( (Mask & REGALL_INT64) || regindex == 32 || regindex == 33)
            {
                MaskOut(OutMask, "%4s=%08lx %08lx",
                        RegNameFromIndex(regnumber),
                        (ULONG)(regvalue >> 32),
                        (ULONG)(regvalue & 0xffffffff));
                if (regindex % 3 == 2)
                {
                    MaskOut(OutMask, "\n");
                }
                else
                {
                    MaskOut(OutMask, " ");
                }
            }
            else
            {
                MaskOut(OutMask, "%4s=%08lx%c",
                        RegNameFromIndex(regnumber),
                        (ULONG)(regvalue & 0xffffffff),
                        NeedUpper(regvalue) ? '*' : ' ' );
                if (regindex % 5 == 4)
                {
                    MaskOut(OutMask, "\n");
                }
                else
                {
                    MaskOut(OutMask, " ");
                }
            }
        }

        //
        // print out the fpcr as 64 bits regardless,
        // and the FIR and Fpcr's - assuming we know they follow
        // the floating and integer registers.
        //

        if (m_Ptr64)
        {
            regnumber = ALPHA_FIR;
            MaskOut(OutMask, "%4s=%s\n",
                    RegNameFromIndex(regnumber),
                    FormatAddr64(GetReg64(regnumber)));
        }
        else
        {
            regnumber = ALPHA_FIR;
            MaskOut(OutMask, "%4s=%08lx\n",
                    RegNameFromIndex(regnumber),
                    GetReg32(regnumber));
        }

        regnumber = ALPHA_PSR;
        MaskOut(OutMask, "%4s=%08lx\n",
                RegNameFromIndex(regnumber), GetReg32(regnumber));
        
        MaskOut(OutMask, "mode=%1lx ie=%1lx irql=%1lx \n",
                GetSubReg32(ALPHA_MODE),
                GetSubReg32(ALPHA_IE),
                GetSubReg32(ALPHA_IRQL));
    }

    if (Mask & REGALL_FLOAT)
    {
        ULONG i;
        REGVAL val;

        //
        // Print them all out
        //
        for (i = 0 ; i < 16; i ++)
        {
            GetVal(i + ALPHA_FLT_BASE, &val);
            MaskOut(OutMask, "%4s = %16e\t",
                    RegNameFromIndex(i), val.f8);

            GetVal(i + ALPHA_FLT_BASE + 16, &val);
            MaskOut(OutMask, "%4s = %16e\n",
                    RegNameFromIndex(i+16), val.f8);
        }
    }
}

TRACEMODE
AlphaMachineInfo::GetTraceMode (void)
{
    return TRACE_NONE;
}

void
AlphaMachineInfo::SetTraceMode (TRACEMODE Mode)
{
    ;
}

BOOL
AlphaMachineInfo::IsStepStatusSupported(ULONG Status)
{
    switch (Status) 
    {
    case DEBUG_STATUS_STEP_INTO:
    case DEBUG_STATUS_STEP_OVER:
        return TRUE;
    default:
        return FALSE;
    }
}

ULONG
AlphaMachineInfo::ExecutingMachine(void)
{
    return g_TargetMachineType;
}

void
AlphaMachineInfo::ValidateCxr(PCROSS_PLATFORM_CONTEXT Context)
{
    return;
}
 

BOOL 
AlphaMachineInfo::DisplayTrapFrame(ULONG64 FrameAddress,
                                   OUT PCROSS_PLATFORM_CONTEXT Context)
{
#define HIGH(x) ((ULONG) ((x>>32) & 0xFFFFFFFF))
#define LOW(x) ((ULONG) (x & 0xFFFFFFFF))

#define HIGHANDLOW(x) HIGH(x), LOW(x)
    
    ALPHA_KTRAP_FRAME TrapContents;
    ULONG64 Address=FrameAddress;
    ULONG   result;
    ULONG64 DisasmAddr;
    ULONG64 Displacement;
    CHAR    Buffer[80];
    ULONG64 IntSp, IntFp;

    if (!FrameAddress || 
        g_Target->ReadVirtual(Address, &TrapContents, 
        sizeof(ALPHA_KTRAP_FRAME), &result) != S_OK)
    {
        dprintf("USAGE: !trap base_of_trap_frame\n");
        return FALSE;
    }

    dprintf("v0 = %08lx %08lx     a0 = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntV0),HIGHANDLOW(TrapContents.IntA0));
    dprintf("t0 = %08lx %08lx     a1 = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntT0),HIGHANDLOW(TrapContents.IntA1));
    dprintf("t1 = %08lx %08lx     a2 = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntT1),HIGHANDLOW(TrapContents.IntA2));
    dprintf("t2 = %08lx %08lx     a3 = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntT2),HIGHANDLOW(TrapContents.IntA3));
    dprintf("t3 = %08lx %08lx     a4 = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntT3),HIGHANDLOW(TrapContents.IntA4));
    dprintf("t4 = %08lx %08lx     a5 = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntT4),HIGHANDLOW(TrapContents.IntA5));
    dprintf("t5 = %08lx %08lx     t8 = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntT5),HIGHANDLOW(TrapContents.IntT8));
    dprintf("t6 = %08lx %08lx     t9 = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntT6),HIGHANDLOW(TrapContents.IntT9));
    dprintf("t7 = %08lx %08lx    t10 = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntT7),HIGHANDLOW(TrapContents.IntT10));
    dprintf("                          t11 = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntT11));
    dprintf("                           ra = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntRa));
    dprintf("                          t12 = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntT12));
    dprintf("                           at = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntAt));
    dprintf("                           gp = %08lx %08lx\n" ,
        HIGHANDLOW(TrapContents.IntGp));
    dprintf("fp = %08lx %08lx     sp = %08lx %08lx\n",
        HIGHANDLOW(IntFp = TrapContents.IntFp),HIGHANDLOW(IntSp = TrapContents.IntSp));
    dprintf("fir= %08lx %08lx\n",
        HIGHANDLOW(TrapContents.Fir));

    DisasmAddr = (TrapContents.Fir);
    g_LastRegFrame.InstructionOffset = DisasmAddr;
    g_LastRegFrame.StackOffset       = IntSp;
    g_LastRegFrame.FrameOffset       = IntFp;

    GetSymbolStdCall(DisasmAddr, Buffer, sizeof(Buffer), &Displacement, NULL);
    dprintf("%s+0x%I64lx\n",Buffer,Displacement);
    
    ADDR tempAddr;
    Type(tempAddr) = ADDR_FLAT | FLAT_COMPUTED;
    Off(tempAddr) = Flat(tempAddr) = DisasmAddr;

    if (Disassemble(&tempAddr, Buffer, FALSE))
    {

        dprintf(Buffer);

    }
    else
    {

        dprintf("%08I64lx ???????????????\n", DisasmAddr);

    }
    
    if (Context) 
    {
        // Fill up the context struct
        if (g_EffMachine == IMAGE_FILE_MACHINE_ALPHA) 
        {
#define COPY(fld) Context->AlphaContext.fld = (ULONG) TrapContents.fld
        COPY(IntSp); COPY(IntFp); COPY(Fir);
        COPY(IntRa); COPY(IntAt); COPY(IntGp);
        COPY(IntV0); COPY(IntA0); COPY(IntT0); COPY(IntA1); COPY(IntA2);
        COPY(IntT1); COPY(IntT2); COPY(IntT3); COPY(IntT4); COPY(IntT5);
        COPY(IntT6); COPY(IntT6); COPY(IntT7); COPY(IntT8); COPY(IntT9);
        COPY(IntT10); COPY(IntT11); COPY(IntT12);
        COPY(IntA3); COPY(IntA4); COPY(IntA5);
#undef COPY
        }
        else
        {
        }

    }
    return TRUE;

#undef HIGHANDLOW
#undef HIGH
#undef LOW
}
    
HRESULT
AlphaMachineInfo::ReadKernelProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    HRESULT Status;
    ULONG64 Pcr;
    ULONG Data[2];

    if ((Status = g_Target->
         GetProcessorSystemDataOffset(Processor, DEBUG_DATA_KPCR_OFFSET,
                                      &Pcr)) != S_OK)
    {
        return Status;
    }

    Pcr += m_Ptr64 ?
        FIELD_OFFSET(AXP64_PARTIAL_KPCR, ProcessorType) :
        FIELD_OFFSET(ALPHA_PARTIAL_KPCR, ProcessorType);

    if ((Status = g_Target->
         ReadAllVirtual(Pcr, Data, sizeof(Data))) != S_OK)
    {
        return Status;
    }

    Id->Alpha.Type = Data[0];
    Id->Alpha.Revision = Data[1];
    return S_OK;
}

#define MAXENTRYTYPE 2
const char *g_AlphaEntryTypeName[] =
{
    "ALPHA_RF_NOT_CONTIGUOUS", // 0
    "ALPHA_RF_ALT_ENT_PROLOG", // 1
    "ALPHA_RF_NULL_CONTEXT",   // 2
    "***INVALID***"
};

#define ALPHA_RF_ALT_PROLOG64(RF)   (((ULONG64)(RF)->ExceptionHandler) & (~3))

void
AlphaMachineInfo::OutputFunctionEntry64
    (PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY Entry)
{
    BOOL Secondary = FALSE;
    BOOL FixedReturn = FALSE;
    ULONG EntryType = 0;
    ULONG NullCount = 0;

    if ((ALPHA_RF_PROLOG_END_ADDRESS(Entry) < ALPHA_RF_BEGIN_ADDRESS(Entry)) ||
        (ALPHA_RF_PROLOG_END_ADDRESS(Entry) > ALPHA_RF_END_ADDRESS(Entry)))
    {
        Secondary = TRUE;
        EntryType = ALPHA_RF_ENTRY_TYPE(Entry);
        if (EntryType > MAXENTRYTYPE)
        {
            EntryType = MAXENTRYTYPE;
        }
    }
    else if (ALPHA_RF_IS_FIXED_RETURN(Entry))
    {
        FixedReturn = TRUE;
    }
    NullCount = ALPHA_RF_NULL_CONTEXT_COUNT(Entry);

    dprintf("BeginAddress     = %s\n", FormatAddr64(Entry->BeginAddress));
    dprintf("EndAddress       = %s", FormatAddr64(Entry->EndAddress));
    if (NullCount)
    {
        dprintf(" %d null-context instructions", NullCount);
    }
    dprintf("\n");
    dprintf("ExceptionHandler = %s",
            FormatAddr64(Entry->ExceptionHandler));
    if (Entry->ExceptionHandler != 0)
    {
        if (Secondary)
        {
            ULONG64 AlternateProlog = ALPHA_RF_ALT_PROLOG64(Entry);

            switch(EntryType)
            {
            case ALPHA_RF_NOT_CONTIGUOUS:
            case ALPHA_RF_ALT_ENT_PROLOG:
                if ((AlternateProlog >=
                     ALPHA_RF_BEGIN_ADDRESS(Entry)) &&
                    (AlternateProlog <= Entry->EndAddress))
                {
                    dprintf(" alternate PrologEndAddress");
                }
                break;
            case ALPHA_RF_NULL_CONTEXT:
                dprintf(" stack adjustment");
                break;
            }
        }
        else if (FixedReturn)
        {
            dprintf(" fixed return address");
        }
    }
    dprintf("\n");
    dprintf("HandlerData      = %s", FormatAddr64(Entry->HandlerData));
    if (Secondary)
    {
        dprintf(" type %d: %s", EntryType, g_AlphaEntryTypeName[EntryType]);
    }
    dprintf("\n");
    dprintf("PrologEndAddress = %s\n",
            FormatAddr64(Entry->PrologEndAddress));
}

HRESULT
Axp32MachineInfo::InitializeConstants(void)
{
    m_FullName = "Alpha 32-bit";
    m_AbbrevName = "alpha";
    m_PageSize = ALPHA_PAGE_SIZE;
    m_PageShift = ALPHA_PAGE_SHIFT;
    m_NumExecTypes = 1;
    m_ExecTypes = g_Axp32ExecTypes;
    m_Ptr64 = FALSE;
    
    return AlphaMachineInfo::InitializeConstants();
}

HRESULT
Axp32MachineInfo::InitializeForTarget(void)
{
    m_OffsetPrcbProcessorState =
        FIELD_OFFSET(ALPHA_PARTIAL_KPRCB, ProcessorState);
    m_OffsetPrcbNumber =
        FIELD_OFFSET(ALPHA_PARTIAL_KPRCB, Number);
    m_TriagePrcbOffset = EXTEND64(ALPHA_TRIAGE_PRCB_ADDRESS);
    m_SizePrcb = ALPHA_KPRCB_SIZE;
    m_OffsetKThreadApcProcess =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, AlphaThread.ApcState.Process);
    m_OffsetKThreadTeb =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, AlphaThread.Teb);
    m_OffsetKThreadInitialStack =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, AlphaThread.InitialStack);
    m_OffsetEprocessPeb = g_SystemVersion > NT_SVER_W2K ?
        ALPHA_NT51_PEB_IN_EPROCESS : ALPHA_NT5_PEB_IN_EPROCESS;
    m_OffsetEprocessDirectoryTableBase =
        ALPHA_DIRECTORY_TABLE_BASE_IN_EPROCESS;
    m_SizeEThread = ALPHA_ETHREAD_SIZE;
    m_SizeEProcess = g_SystemVersion > NT_SVER_W2K ?
        ALPHA_NT51_EPROCESS_SIZE : ALPHA_NT5_EPROCESS_SIZE;
    m_SizePartialKThread = sizeof(ALPHA_THREAD);
    m_SharedUserDataOffset = IS_KERNEL_TARGET() ?
        EXTEND64(ALPHA_KI_USER_SHARED_DATA) : MM_SHARED_USER_DATA_VA;

    return MachineInfo::InitializeForTarget();
}

HRESULT
Axp32MachineInfo::GetContextFromThreadStack(ULONG64 ThreadBase,
                                            PCROSS_PLATFORM_THREAD Thread,
                                            PCROSS_PLATFORM_CONTEXT Context,
                                            PDEBUG_STACK_FRAME Frame,
                                            PULONG RunningOnProc)
{
    if (Thread->AlphaThread.State == 2) 
    {
        return E_NOTIMPL;
    }

    HRESULT Status;
    ALPHA_KEXCEPTION_FRAME ExFrame;

    if ((Status = g_Target->ReadAllVirtual(Thread->AlphaThread.KernelStack,
                                           &ExFrame, sizeof(ExFrame))) != S_OK)
    {
        return Status;
    }
    
    //      
    // Successfully read an exception frame from the stack.
    //
        
    Context->AlphaNt5Context.IntSp =
        Thread->AlphaThread.KernelStack;
    Context->AlphaNt5Context.Fir   = ExFrame.SwapReturn;
    Context->AlphaNt5Context.IntRa = ExFrame.SwapReturn;
    Context->AlphaNt5Context.IntS0 = ExFrame.IntS0;
    Context->AlphaNt5Context.IntS1 = ExFrame.IntS1;
    Context->AlphaNt5Context.IntS2 = ExFrame.IntS2;
    Context->AlphaNt5Context.IntS3 = ExFrame.IntS3;
    Context->AlphaNt5Context.IntS4 = ExFrame.IntS4;
    Context->AlphaNt5Context.IntS5 = ExFrame.IntS5;
    Context->AlphaNt5Context.Psr   = ExFrame.Psr;

    Frame->FrameOffset = Context->AlphaNt5Context.IntSp;
    Frame->StackOffset = Context->AlphaNt5Context.IntSp;
    Frame->InstructionOffset = ExFrame.SwapReturn;

    return S_OK;
}

VOID
Axp32MachineInfo::GetPC (
    PADDR Address
    )
{
    // sign extend the address!
    ADDRFLAT(Address, EXTEND64(GetReg32(ALPHA_FIR)));
}

VOID
Axp32MachineInfo::SetPC (
    PADDR paddr
    )
{
    // sign extend the address!
    SetReg64(ALPHA_FIR, EXTEND64(Flat(*paddr)));
}

VOID
Axp32MachineInfo::GetFP (
    PADDR Address
    )
{
    ADDRFLAT(Address, GetReg32(FP_REG));
}

void
Axp32MachineInfo::GetSP(PADDR Address)
{
    ADDRFLAT(Address, GetReg32(SP_REG));
}

ULONG64
Axp32MachineInfo::GetArgReg(void)
{
    return GetReg32(ALPHA_INT64_BASE + A0_REG);
}

HRESULT
Axp32MachineInfo::SetPageDirectory(ULONG Idx, ULONG64 PageDir,
                                   PULONG NextIdx)
{
    *NextIdx = PAGE_DIR_COUNT;
    
    if (PageDir == 0)
    {
        HRESULT Status;
        
        if ((Status = g_Target->ReadImplicitProcessInfoPointer
             (m_OffsetEprocessDirectoryTableBase, &PageDir)) != S_OK)
        {
            return Status;
        }
    }

    // DirectoryTableBase values on Alpha are the raw PTE entries
    // so turn it into a clean physical address.
    PageDir = ((ULONG)PageDir >> ALPHA_VALID_PFN_SHIFT) <<
        ALPHA_PAGE_SHIFT;
    
    // There is only one page directory so update all the slots.
    m_PageDirectories[PAGE_DIR_USER] = PageDir;
    m_PageDirectories[PAGE_DIR_SESSION] = PageDir;
    m_PageDirectories[PAGE_DIR_KERNEL] = PageDir;
    
    return S_OK;
}

#define ALPHA_PAGE_FILE_INDEX(Entry) \
    (((ULONG)(Entry) >> 8) & MAX_PAGING_FILE_MASK)
#define ALPHA_PAGE_FILE_OFFSET(Entry) \
    ((ULONG64)((Entry) >> 12) << ALPHA_PAGE_SHIFT)

HRESULT
Axp32MachineInfo::GetVirtualTranslationPhysicalOffsets(ULONG64 Virt,
                                                       PULONG64 Offsets,
                                                       ULONG OffsetsSize,
                                                       PULONG Levels,
                                                       PULONG PfIndex,
                                                       PULONG64 LastVal)
{
    HRESULT Status;

    *Levels = 0;
    
    if (m_Translating)
    {
        return E_UNEXPECTED;
    }
    m_Translating = TRUE;
    
    //
    // Reset the page directory in case it was 0
    //
    if (m_PageDirectories[PAGE_DIR_SINGLE] == 0)
    {
        if ((Status = SetDefaultPageDirectories(1 << PAGE_DIR_SINGLE)) != S_OK)
        {
            m_Translating = FALSE;
            return Status;
        }
    }

    KdOut("Axp32VtoP: Virt %s, pagedir %s\n",
          FormatAddr64(Virt),
          FormatAddr64(m_PageDirectories[PAGE_DIR_SINGLE]));
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = m_PageDirectories[PAGE_DIR_SINGLE];
        OffsetsSize--;
    }
        
    //
    // Certain ranges of the system are mapped directly.
    //

    if ((Virt >= EXTEND64(ALPHA_PHYSICAL_START)) &&
        (Virt <= EXTEND64(ALPHA_PHYSICAL_END)))
    {
        *LastVal = Virt - EXTEND64(ALPHA_PHYSICAL_START);

        KdOut("Axp32VtoP: Direct phys %s\n", FormatAddr64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }
        
        m_Translating = FALSE;
        return S_OK;
    }

    ULONG64 Addr;
    ULONG Entry;
    
    Addr = (((ULONG)Virt >> ALPHA_PDE_SHIFT) * sizeof(Entry)) +
        m_PageDirectories[PAGE_DIR_SINGLE];

    KdOut("Axp32VtoP: PDE %s\n", FormatAddr64(Addr));
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = Addr;
        OffsetsSize--;
    }
        
    if ((Status = g_Target->
         ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
    {
        KdOut("Axp32VtoP: PDE read error 0x%X\n", Status);
        m_Translating = FALSE;
        return Status;
    }
    
    if (Entry == 0)
    {
        KdOut("Axp32VtoP: zero PDE\n");
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
    else if (!(Entry & 1))
    {
        Addr = ((((ULONG)Virt >> ALPHA_PTE_SHIFT) & ALPHA_PTE_MASK) *
                sizeof(Entry)) + ALPHA_PAGE_FILE_OFFSET(Entry);

        KdOut("Axp32VtoP: pagefile PTE %d:%s\n",
              ALPHA_PAGE_FILE_INDEX(Entry), FormatAddr64(Addr));
        
        if ((Status = g_Target->
             ReadPageFile(ALPHA_PAGE_FILE_INDEX(Entry), Addr,
                          &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Axp32VtoP: PDE not present, 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    else
    {
        Addr = ((((ULONG)Virt >> ALPHA_PTE_SHIFT) & ALPHA_PTE_MASK) *
                sizeof(Entry)) +
            ((Entry >> ALPHA_VALID_PFN_SHIFT) << ALPHA_PAGE_SHIFT);

        KdOut("Axp32VtoP: PTE %s\n", FormatAddr64(Addr));
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }
        
        if ((Status = g_Target->
             ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Axp32VtoP: PTE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    
    if (!(Entry & 0x1) &&
        ((Entry & ALPHA_MM_PTE_PROTOTYPE_MASK) ||
         !(Entry & ALPHA_MM_PTE_TRANSITION_MASK)))
    {
        if (Entry == 0)
        {
            KdOut("Axp32VtoP: zero PTE\n");
            Status = HR_PAGE_NOT_AVAILABLE;
        }
        else if (Entry & ALPHA_MM_PTE_PROTOTYPE_MASK)
        {
            KdOut("Axp32VtoP: prototype PTE\n");
            Status = HR_PAGE_NOT_AVAILABLE;
        }
        else
        {
            *PfIndex = ALPHA_PAGE_FILE_INDEX(Entry);
            *LastVal = (Virt & (ALPHA_PAGE_SIZE - 1)) +
                ALPHA_PAGE_FILE_OFFSET(Entry);
            KdOut("Axp32VtoP: PTE not present, pagefile %d:%s\n",
                  *PfIndex, FormatAddr64(*LastVal));
            Status = HR_PAGE_IN_PAGE_FILE;
        }
        m_Translating = FALSE;
        return Status;
    }

    //
    // This is a page which is either present or in transition.
    // Return the physical address for the request virtual address.
    //

    *LastVal = ((Entry >> ALPHA_VALID_PFN_SHIFT) << ALPHA_PAGE_SHIFT) |
        (Virt & (ALPHA_PAGE_SIZE - 1));
    
    KdOut("Axp32VtoP: Mapped phys %s\n", FormatAddr64(*LastVal));

    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = *LastVal;
        OffsetsSize--;
    }
        
    m_Translating = FALSE;
    return S_OK;
}

HRESULT
Axp32MachineInfo::GetBaseTranslationVirtualOffset(PULONG64 Offset)
{
    *Offset = EXTEND64(ALPHA_BASE_VIRT);
    return S_OK;
}

void
Axp32MachineInfo::OutputFunctionEntry(PVOID RawEntry)
{
    // Assume Alpha function entries are always kept as
    // 64-bit entries.  That's what imagehlp does right now.
    OutputFunctionEntry64((PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)RawEntry);
}

HRESULT
Axp32MachineInfo::ReadDynamicFunctionTable(ULONG64 Table,
                                           PULONG64 NextTable,
                                           PULONG64 MinAddress,
                                           PULONG64 MaxAddress,
                                           PULONG64 BaseAddress,
                                           PULONG64 TableData,
                                           PULONG TableSize,
                                           PWSTR OutOfProcessDll,
                                           PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable)
{
    HRESULT Status;

    if ((Status = g_Target->
         ReadAllVirtual(Table, &RawTable->AlphaTable,
                        sizeof(RawTable->AlphaTable))) != S_OK)
    {
        return Status;
    }

    *NextTable = EXTEND64(RawTable->AlphaTable.Links.Flink);
    *MinAddress = EXTEND64(RawTable->AlphaTable.MinimumAddress);
    *MaxAddress = EXTEND64(RawTable->AlphaTable.MaximumAddress);
    *BaseAddress = EXTEND64(RawTable->AlphaTable.MinimumAddress);
    *TableData = EXTEND64(RawTable->AlphaTable.FunctionTable);
    *TableSize = RawTable->AlphaTable.EntryCount *
        sizeof(IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY);
    OutOfProcessDll[0] = 0;
    return S_OK;
}

PVOID
Axp32MachineInfo::FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                           ULONG64 Address,
                                           PVOID TableData,
                                           ULONG TableSize)
{
    ULONG i;
    PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY Func;
    // Always return AXP64 function entries.
    static IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY s_RetFunc;

    Func = (PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)TableData;
    for (i = 0; i < TableSize / sizeof(IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY); i++)
    {
        if (Address >= ALPHA_RF_BEGIN_ADDRESS(Func) &&
            Address < ALPHA_RF_END_ADDRESS(Func))
        {
            // The table data is temporary so copy the data into
            // a static buffer for longer-term storage.
            s_RetFunc.BeginAddress     = EXTEND64(Func->BeginAddress);
            s_RetFunc.EndAddress       = EXTEND64(Func->EndAddress);
            s_RetFunc.ExceptionHandler = EXTEND64(Func->ExceptionHandler);
            s_RetFunc.HandlerData      = EXTEND64(Func->HandlerData);
            s_RetFunc.PrologEndAddress = EXTEND64(Func->PrologEndAddress);
            return (PVOID)&s_RetFunc;
        }

        Func++;
    }

    return NULL;
}

HRESULT
Axp64MachineInfo::InitializeConstants(void)
{
    m_FullName = "Alpha 64-bit";
    m_AbbrevName = "axp64";
    m_PageSize = AXP64_PAGE_SIZE;
    m_PageShift = AXP64_PAGE_SHIFT;
    m_NumExecTypes = 1;
    m_ExecTypes = g_Axp64ExecTypes;
    m_Ptr64 = TRUE;

    return AlphaMachineInfo::InitializeConstants();
}

HRESULT
Axp64MachineInfo::InitializeForTarget(void)
{
    m_OffsetPrcbProcessorState =
        FIELD_OFFSET(AXP64_PARTIAL_KPRCB, ProcessorState);
    m_OffsetPrcbNumber =
        FIELD_OFFSET(AXP64_PARTIAL_KPRCB, Number);
    m_TriagePrcbOffset = AXP64_TRIAGE_PRCB_ADDRESS;
    m_SizePrcb = AXP64_KPRCB_SIZE;
    m_OffsetKThreadApcProcess =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, Axp64Thread.ApcState.Process);
    m_OffsetKThreadTeb =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, Axp64Thread.Teb);
    m_OffsetKThreadInitialStack =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, Axp64Thread.InitialStack);
    m_OffsetEprocessPeb = AXP64_PEB_IN_EPROCESS;
    m_OffsetEprocessDirectoryTableBase =
        AXP64_DIRECTORY_TABLE_BASE_IN_EPROCESS;
    m_SizeEThread = AXP64_ETHREAD_SIZE;
    m_SizeEProcess = AXP64_EPROCESS_SIZE;
    m_SizePartialKThread = sizeof(AXP64_THREAD);
    m_SharedUserDataOffset = IS_KERNEL_TARGET() ?
        AXP64_KI_USER_SHARED_DATA : MM_SHARED_USER_DATA_VA;

    return MachineInfo::InitializeForTarget();
}

HRESULT
Axp64MachineInfo::GetContextFromThreadStack(ULONG64 ThreadBase,
                                            PCROSS_PLATFORM_THREAD Thread,
                                            PCROSS_PLATFORM_CONTEXT Context,
                                            PDEBUG_STACK_FRAME Frame,
                                            PULONG RunningOnProc)
{
    if (Thread->Axp64Thread.State == 2) 
    {
        return E_NOTIMPL;
    }

    HRESULT Status;
    ALPHA_KEXCEPTION_FRAME ExFrame;

    if ((Status = g_Target->ReadAllVirtual(Thread->Axp64Thread.KernelStack,
                                           &ExFrame, sizeof(ExFrame))) != S_OK)
    {
        return Status;
    }
    
    //      
    // Successfully read an exception frame from the stack.
    //
        
    Context->AlphaNt5Context.IntSp =
        Thread->Axp64Thread.KernelStack;
    Context->AlphaNt5Context.Fir   = ExFrame.SwapReturn;
    Context->AlphaNt5Context.IntRa = ExFrame.SwapReturn;
    Context->AlphaNt5Context.IntS0 = ExFrame.IntS0;
    Context->AlphaNt5Context.IntS1 = ExFrame.IntS1;
    Context->AlphaNt5Context.IntS2 = ExFrame.IntS2;
    Context->AlphaNt5Context.IntS3 = ExFrame.IntS3;
    Context->AlphaNt5Context.IntS4 = ExFrame.IntS4;
    Context->AlphaNt5Context.IntS5 = ExFrame.IntS5;
    Context->AlphaNt5Context.Psr   = ExFrame.Psr;

    Frame->FrameOffset = Context->AlphaNt5Context.IntSp;
    Frame->StackOffset = Context->AlphaNt5Context.IntSp;
    Frame->InstructionOffset = ExFrame.SwapReturn;

    return S_OK;
}

VOID
Axp64MachineInfo::GetPC (
    PADDR Address
    )
{
    ADDRFLAT(Address, GetReg64(ALPHA_FIR));
}

VOID
Axp64MachineInfo::SetPC (
    PADDR paddr
    )
{
    SetReg64(ALPHA_FIR, Flat(*paddr));
}

VOID
Axp64MachineInfo::GetFP (
    PADDR Address
    )
{
    ADDRFLAT(Address, GetReg64(FP_REG));
}

void
Axp64MachineInfo::GetSP(PADDR Address)
{
    ADDRFLAT(Address, GetReg64(SP_REG));
}

ULONG64
Axp64MachineInfo::GetArgReg(void)
{
    return GetReg64(ALPHA_INT64_BASE + A0_REG);
}

HRESULT
Axp64MachineInfo::SetPageDirectory(ULONG Idx, ULONG64 PageDir,
                                   PULONG NextIdx)
{
    if (PageDir == 0)
    {
        HRESULT Status;
        
        if ((Status = g_Target->ReadImplicitProcessInfoPointer
             (m_OffsetEprocessDirectoryTableBase, &PageDir)) != S_OK)
        {
            return Status;
        }
    }

    // DirectoryTableBase values on Alpha are the raw PTE entries
    // so turn it into a clean physical address.
    PageDir = (PageDir >> AXP64_VALID_PFN_SHIFT) <<
        AXP64_PAGE_SHIFT;
    
    // There is only one page directory so update all the slots.
    m_PageDirectories[PAGE_DIR_USER] = PageDir;
    m_PageDirectories[PAGE_DIR_SESSION] = PageDir;
    m_PageDirectories[PAGE_DIR_KERNEL] = PageDir;
    
    return S_OK;
}

#define AXP64_PAGE_FILE_INDEX(Entry) \
    (((ULONG)(Entry) >> 28) & MAX_PAGING_FILE_MASK)
#define AXP64_PAGE_FILE_OFFSET(Entry) \
    (((Entry) >> 32) << AXP64_PAGE_SHIFT)

HRESULT
Axp64MachineInfo::GetVirtualTranslationPhysicalOffsets(ULONG64 Virt,
                                                       PULONG64 Offsets,
                                                       ULONG OffsetsSize,
                                                       PULONG Levels,
                                                       PULONG PfIndex,
                                                       PULONG64 LastVal)
{
    HRESULT Status;

    *Levels = 0;
    
    if (m_Translating)
    {
        return E_UNEXPECTED;
    }
    m_Translating = TRUE;
    
    //
    // Reset the page directory in case it was 0
    //
    if (m_PageDirectories[PAGE_DIR_SINGLE] == 0)
    {
        if ((Status = SetDefaultPageDirectories(1 << PAGE_DIR_SINGLE)) != S_OK)
        {
            m_Translating = FALSE;
            return Status;
        }
    }

    KdOut("Axp64VtoP: Virt %s, pagedir %s\n",
          FormatAddr64(Virt),
          FormatAddr64(m_PageDirectories[PAGE_DIR_SINGLE]));
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = m_PageDirectories[PAGE_DIR_SINGLE];
        OffsetsSize--;
    }
        
    //
    // Certain ranges of the system are mapped directly.
    //

    if ((Virt >= AXP64_PHYSICAL1_START) && (Virt <= AXP64_PHYSICAL1_END))
    {
        *LastVal = Virt - AXP64_PHYSICAL1_START;

        KdOut("Axp64VtoP: Direct phys 1 %s\n", FormatAddr64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }
        
        m_Translating = FALSE;
        return S_OK;
    }
    if ((Virt >= AXP64_PHYSICAL2_START) && (Virt <= AXP64_PHYSICAL2_END))
    {
        *LastVal = Virt - AXP64_PHYSICAL2_START;

        KdOut("Axp64VtoP: Direct phys 2 %s\n", FormatAddr64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }
        
        m_Translating = FALSE;
        return S_OK;
    }

    ULONG64 Addr;
    ULONG64 Entry;
    
    Addr = (((Virt >> AXP64_PDE1_SHIFT) & AXP64_PDE_MASK) * sizeof(Entry)) +
        m_PageDirectories[PAGE_DIR_SINGLE];

    KdOut("Axp64VtoP: PDE1 %s\n", FormatAddr64(Addr));
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = Addr;
        OffsetsSize--;
    }
        
    if ((Status = g_Target->
         ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
    {
        KdOut("Axp64VtoP: PDE1 read error 0x%X\n", Status);
        m_Translating = FALSE;
        return Status;
    }

    if (Entry == 0)
    {
        KdOut("Axp64VtoP: zero PDE1\n");
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
    else if (!(Entry & 1))
    {
        Addr = (((Virt >> AXP64_PDE2_SHIFT) & AXP64_PDE_MASK) *
                sizeof(Entry)) + AXP64_PAGE_FILE_OFFSET(Entry);

        KdOut("Axp64VtoP: pagefile PDE2 %d:%s\n",
              AXP64_PAGE_FILE_INDEX(Entry), FormatAddr64(Addr));
        
        if ((Status = g_Target->
             ReadPageFile(AXP64_PAGE_FILE_INDEX(Entry), Addr,
                          &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Axp64VtoP: PDE1 not present, 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    else
    {
        Addr = (((Virt >> AXP64_PDE2_SHIFT) & AXP64_PDE_MASK) *
                sizeof(Entry)) +
            ((Entry >> AXP64_VALID_PFN_SHIFT) << AXP64_PAGE_SHIFT);

        KdOut("Axp64VtoP: PDE2 %s\n", FormatAddr64(Addr));
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }
        
        if ((Status = g_Target->
             ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Axp64VtoP: PDE2 read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    
    if (Entry == 0)
    {
        KdOut("Axp64VtoP: zero PDE2\n");
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
    else if (!(Entry & 1))
    {
        Addr = (((Virt >> AXP64_PTE_SHIFT) & AXP64_PTE_MASK) *
                sizeof(Entry)) + AXP64_PAGE_FILE_OFFSET(Entry);

        KdOut("Axp64VtoP: pagefile PTE %d:%s\n",
              AXP64_PAGE_FILE_INDEX(Entry), FormatAddr64(Addr));
        
        if ((Status = g_Target->
             ReadPageFile(AXP64_PAGE_FILE_INDEX(Entry), Addr,
                          &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Axp64VtoP: PDE2 not present, 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    else
    {
        Addr = (((Virt >> AXP64_PTE_SHIFT) & AXP64_PTE_MASK) * sizeof(Entry)) +
            ((Entry >> AXP64_VALID_PFN_SHIFT) << AXP64_PAGE_SHIFT);

        KdOut("Axp64VtoP: PTE %s\n", FormatAddr64(Addr));
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }
        
        if ((Status = g_Target->
             ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Axp64VtoP: PTE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    
    if (!(Entry & 0x1) &&
        ((Entry & AXP64_MM_PTE_PROTOTYPE_MASK) ||
         !(Entry & AXP64_MM_PTE_TRANSITION_MASK)))
    {
        if (Entry == 0)
        {
            KdOut("Axp64VtoP: zero PTE\n");
            Status = HR_PAGE_NOT_AVAILABLE;
        }
        else if (Entry & AXP64_MM_PTE_PROTOTYPE_MASK)
        {
            KdOut("Axp64VtoP: prototype PTE\n");
            Status = HR_PAGE_NOT_AVAILABLE;
        }
        else
        {
            *PfIndex = AXP64_PAGE_FILE_INDEX(Entry);
            *LastVal = (Virt & (AXP64_PAGE_SIZE - 1)) +
                AXP64_PAGE_FILE_OFFSET(Entry);
            KdOut("Axp64VtoP: PTE not present, pagefile %d:%s\n",
                  *PfIndex, FormatAddr64(*LastVal));
            Status = HR_PAGE_IN_PAGE_FILE;
        }
        m_Translating = FALSE;
        return Status;
    }

    //
    // This is a page which is either present or in transition.
    // Return the physical address for the request virtual address.
    //

    *LastVal = ((Entry >> AXP64_VALID_PFN_SHIFT) << AXP64_PAGE_SHIFT) |
        (Virt & (AXP64_PAGE_SIZE - 1));
    
    KdOut("Axp64VtoP: Mapped phys %s\n", FormatAddr64(*LastVal));

    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = *LastVal;
        OffsetsSize--;
    }
        
    m_Translating = FALSE;
    return S_OK;
}

HRESULT
Axp64MachineInfo::GetBaseTranslationVirtualOffset(PULONG64 Offset)
{
    *Offset = AXP64_BASE_VIRT;
    return S_OK;
}

void
Axp64MachineInfo::OutputFunctionEntry(PVOID RawEntry)
{
    OutputFunctionEntry64((PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)RawEntry);
}

HRESULT
Axp64MachineInfo::ReadDynamicFunctionTable(ULONG64 Table,
                                           PULONG64 NextTable,
                                           PULONG64 MinAddress,
                                           PULONG64 MaxAddress,
                                           PULONG64 BaseAddress,
                                           PULONG64 TableData,
                                           PULONG TableSize,
                                           PWSTR OutOfProcessDll,
                                           PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable)
{
    HRESULT Status;

    if ((Status = g_Target->
         ReadAllVirtual(Table, &RawTable->Axp64Table,
                        sizeof(RawTable->Axp64Table))) != S_OK)
    {
        return Status;
    }

    *NextTable = RawTable->Axp64Table.Links.Flink;
    *MinAddress = RawTable->Axp64Table.MinimumAddress;
    *MaxAddress = RawTable->Axp64Table.MaximumAddress;
    *BaseAddress = RawTable->Axp64Table.MinimumAddress;
    *TableData = RawTable->Axp64Table.FunctionTable;
    *TableSize = RawTable->Axp64Table.EntryCount *
        sizeof(IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY);
    OutOfProcessDll[0] = 0;
    return S_OK;
}

PVOID
Axp64MachineInfo::FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                           ULONG64 Address,
                                           PVOID TableData,
                                           ULONG TableSize)
{
    ULONG i;
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY Func;
    static IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY s_RetFunc;

    Func = (PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)TableData;
    for (i = 0; i < TableSize / sizeof(IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY); i++)
    {
        if (Address >= ALPHA_RF_BEGIN_ADDRESS(Func) &&
            Address < ALPHA_RF_END_ADDRESS(Func))
        {
            // The table data is temporary so copy the data into
            // a static buffer for longer-term storage.
            s_RetFunc.BeginAddress     = Func->BeginAddress;
            s_RetFunc.EndAddress       = Func->EndAddress;
            s_RetFunc.ExceptionHandler = Func->ExceptionHandler;
            s_RetFunc.HandlerData      = Func->HandlerData;
            s_RetFunc.PrologEndAddress = Func->PrologEndAddress;
            return (PVOID)&s_RetFunc;
        }

        Func++;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\amd64_reg.cpp ===
//----------------------------------------------------------------------------
//
// Register portions of AMD64 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

// See Get/SetRegVal comments in machine.hpp.
#define RegValError Do_not_use_GetSetRegVal_in_machine_implementations
#define GetRegVal(index, val)   RegValError
#define GetRegVal32(index)      RegValError
#define GetRegVal64(index)      RegValError
#define SetRegVal(index, val)   RegValError
#define SetRegVal32(index, val) RegValError
#define SetRegVal64(index, val) RegValError

#define REGALL_SEGREG   REGALL_EXTRA0
#define REGALL_MMXREG   REGALL_EXTRA1
#define REGALL_DREG     REGALL_EXTRA2

REGALLDESC g_Amd64AllExtraDesc[] =
{
    REGALL_SEGREG, "Segment registers",
    REGALL_MMXREG, "MMX registers",
    REGALL_DREG,   "Debug registers and, in kernel, CR4",
    REGALL_XMMREG, "SSE XMM registers",
    0,             NULL,
};

#define REGALL_CREG     REGALL_EXTRA4
#define REGALL_DESC     REGALL_EXTRA5
REGALLDESC g_Amd64KernelExtraDesc[] =
{
    REGALL_CREG,   "CR0, CR2 and CR3",
    REGALL_DESC,   "Descriptor and task state",
    0,             NULL,
};

char g_Rax[] = "rax";
char g_Rcx[] = "rcx";
char g_Rdx[] = "rdx";
char g_Rbx[] = "rbx";
char g_Rsp[] = "rsp";
char g_Rbp[] = "rbp";
char g_Rsi[] = "rsi";
char g_Rdi[] = "rdi";
char g_Rip[] = "rip";

char g_Xmm8[] = "xmm8";
char g_Xmm9[] = "xmm9";
char g_Xmm10[] = "xmm10";
char g_Xmm11[] = "xmm11";
char g_Xmm12[] = "xmm12";
char g_Xmm13[] = "xmm13";
char g_Xmm14[] = "xmm14";
char g_Xmm15[] = "xmm15";

char g_Cr8[] = "cr8";

char g_Spl[] = "spl";
char g_Bpl[] = "bpl";
char g_Sil[] = "sil";
char g_Dil[] = "dil";

char g_R8d[] = "r8d";
char g_R9d[] = "r9d";
char g_R10d[] = "r10d";
char g_R11d[] = "r11d";
char g_R12d[] = "r12d";
char g_R13d[] = "r13d";
char g_R14d[] = "r14d";
char g_R15d[] = "r15d";

char g_R8w[] = "r8w";
char g_R9w[] = "r9w";
char g_R10w[] = "r10w";
char g_R11w[] = "r11w";
char g_R12w[] = "r12w";
char g_R13w[] = "r13w";
char g_R14w[] = "r14w";
char g_R15w[] = "r15w";

char g_R8b[] = "r8b";
char g_R9b[] = "r9b";
char g_R10b[] = "r10b";
char g_R11b[] = "r11b";
char g_R12b[] = "r12b";
char g_R13b[] = "r13b";
char g_R14b[] = "r14b";
char g_R15b[] = "r15b";

REGDEF g_Amd64Defs[] =
{
    { g_Rax,   AMD64_RAX   },
    { g_Rcx,   AMD64_RCX   },
    { g_Rdx,   AMD64_RDX   },
    { g_Rbx,   AMD64_RBX   },
    { g_Rsp,   AMD64_RSP   },
    { g_Rbp,   AMD64_RBP   },
    { g_Rsi,   AMD64_RSI   },
    { g_Rdi,   AMD64_RDI   },
    { g_R8,    AMD64_R8    },
    { g_R9,    AMD64_R9    },
    { g_R10,   AMD64_R10   },
    { g_R11,   AMD64_R11   },
    { g_R12,   AMD64_R12   },
    { g_R13,   AMD64_R13   },
    { g_R14,   AMD64_R14   },
    { g_R15,   AMD64_R15   },
    
    { g_Rip,   AMD64_RIP   },
    { g_Efl,   AMD64_EFL   },
    
    { g_Cs,    AMD64_CS    },
    { g_Ds,    AMD64_DS    },
    { g_Es,    AMD64_ES    },
    { g_Fs,    AMD64_FS    },
    { g_Gs,    AMD64_GS    },
    { g_Ss,    AMD64_SS    },
    
    { g_Dr0,   AMD64_DR0   },
    { g_Dr1,   AMD64_DR1   },
    { g_Dr2,   AMD64_DR2   },
    { g_Dr3,   AMD64_DR3   },
    { g_Dr6,   AMD64_DR6   },
    { g_Dr7,   AMD64_DR7   },
    
    { g_Fpcw,  AMD64_FPCW  },
    { g_Fpsw,  AMD64_FPSW  },
    { g_Fptw,  AMD64_FPTW  },
    
    { g_St0,   AMD64_ST0   },
    { g_St1,   AMD64_ST1   },
    { g_St2,   AMD64_ST2   },
    { g_St3,   AMD64_ST3   },
    { g_St4,   AMD64_ST4   },
    { g_St5,   AMD64_ST5   },
    { g_St6,   AMD64_ST6   },
    { g_St7,   AMD64_ST7   },
    
    { g_Mm0,   AMD64_MM0   },
    { g_Mm1,   AMD64_MM1   },
    { g_Mm2,   AMD64_MM2   },
    { g_Mm3,   AMD64_MM3   },
    { g_Mm4,   AMD64_MM4   },
    { g_Mm5,   AMD64_MM5   },
    { g_Mm6,   AMD64_MM6   },
    { g_Mm7,   AMD64_MM7   },
    
    { g_Mxcsr, AMD64_MXCSR },
    
    { g_Xmm0,  AMD64_XMM0  },
    { g_Xmm1,  AMD64_XMM1  },
    { g_Xmm2,  AMD64_XMM2  },
    { g_Xmm3,  AMD64_XMM3  },
    { g_Xmm4,  AMD64_XMM4  },
    { g_Xmm5,  AMD64_XMM5  },
    { g_Xmm6,  AMD64_XMM6  },
    { g_Xmm7,  AMD64_XMM7  },
    { g_Xmm8,  AMD64_XMM8  },
    { g_Xmm9,  AMD64_XMM9  },
    { g_Xmm10, AMD64_XMM10 },
    { g_Xmm11, AMD64_XMM11 },
    { g_Xmm12, AMD64_XMM12 },
    { g_Xmm13, AMD64_XMM13 },
    { g_Xmm14, AMD64_XMM14 },
    { g_Xmm15, AMD64_XMM15 },
    
    { g_Eax,   AMD64_EAX   },
    { g_Ecx,   AMD64_ECX   },
    { g_Edx,   AMD64_EDX   },
    { g_Ebx,   AMD64_EBX   },
    { g_Esp,   AMD64_ESP   },
    { g_Ebp,   AMD64_EBP   },
    { g_Esi,   AMD64_ESI   },
    { g_Edi,   AMD64_EDI   },
    { g_R8d,   AMD64_R8D   },
    { g_R9d,   AMD64_R9D   },
    { g_R10d,  AMD64_R10D  },
    { g_R11d,  AMD64_R11D  },
    { g_R12d,  AMD64_R12D  },
    { g_R13d,  AMD64_R13D  },
    { g_R14d,  AMD64_R14D  },
    { g_R15d,  AMD64_R15D  },
    { g_Eip,   AMD64_EIP   },
    
    { g_Ax,    AMD64_AX    },
    { g_Cx,    AMD64_CX    },
    { g_Dx,    AMD64_DX    },
    { g_Bx,    AMD64_BX    },
    { g_Sp,    AMD64_SP    },
    { g_Bp,    AMD64_BP    },
    { g_Si,    AMD64_SI    },
    { g_Di,    AMD64_DI    },
    { g_R8w,   AMD64_R8W   },
    { g_R9w,   AMD64_R9W   },
    { g_R10w,  AMD64_R10W  },
    { g_R11w,  AMD64_R11W  },
    { g_R12w,  AMD64_R12W  },
    { g_R13w,  AMD64_R13W  },
    { g_R14w,  AMD64_R14W  },
    { g_R15w,  AMD64_R15W  },
    { g_Ip,    AMD64_IP    },
    { g_Fl,    AMD64_FL    },
    
    { g_Al,    AMD64_AL    },
    { g_Cl,    AMD64_CL    },
    { g_Dl,    AMD64_DL    },
    { g_Bl,    AMD64_BL    },
    { g_Spl,   AMD64_SPL   },
    { g_Bpl,   AMD64_BPL   },
    { g_Sil,   AMD64_SIL   },
    { g_Dil,   AMD64_DIL   },
    { g_R8b,   AMD64_R8B   },
    { g_R9b,   AMD64_R9B   },
    { g_R10b,  AMD64_R10B  },
    { g_R11b,  AMD64_R11B  },
    { g_R12b,  AMD64_R12B  },
    { g_R13b,  AMD64_R13B  },
    { g_R14b,  AMD64_R14B  },
    { g_R15b,  AMD64_R15B  },
    
    { g_Ah,    AMD64_AH    },
    { g_Ch,    AMD64_CH    },
    { g_Dh,    AMD64_DH    },
    { g_Bh,    AMD64_BH    },
    
    { g_Iopl,  AMD64_IOPL },
    { g_Of,    AMD64_OF   },
    { g_Df,    AMD64_DF   },
    { g_If,    AMD64_IF   },
    { g_Tf,    AMD64_TF   },
    { g_Sf,    AMD64_SF   },
    { g_Zf,    AMD64_ZF   },
    { g_Af,    AMD64_AF   },
    { g_Pf,    AMD64_PF   },
    { g_Cf,    AMD64_CF   },
    { g_Vip,   AMD64_VIP  },
    { g_Vif,   AMD64_VIF  },
    
    { NULL,    REG_ERROR },
};

REGDEF g_Amd64KernelReg[] =
{
    { g_Cr0,   AMD64_CR0   },
    { g_Cr2,   AMD64_CR2   },
    { g_Cr3,   AMD64_CR3   },
    { g_Cr4,   AMD64_CR4   },
#ifdef HAVE_AMD64_CR8
    { g_Cr8,   AMD64_CR8   },
#endif
    { g_Gdtr,  AMD64_GDTR  },
    { g_Gdtl,  AMD64_GDTL  },
    { g_Idtr,  AMD64_IDTR  },
    { g_Idtl,  AMD64_IDTL  },
    { g_Tr,    AMD64_TR    },
    { g_Ldtr,  AMD64_LDTR  },
    { NULL,    REG_ERROR },
};

REGSUBDEF g_Amd64SubDefs[] =
{
    { AMD64_EAX,    AMD64_RAX,  0, 0xffffffff }, //  EAX register
    { AMD64_ECX,    AMD64_RCX,  0, 0xffffffff }, //  ECX register
    { AMD64_EDX,    AMD64_RDX,  0, 0xffffffff }, //  EDX register
    { AMD64_EBX,    AMD64_RBX,  0, 0xffffffff }, //  EBX register
    { AMD64_ESP,    AMD64_RSP,  0, 0xffffffff }, //  ESP register
    { AMD64_EBP,    AMD64_RBP,  0, 0xffffffff }, //  EBP register
    { AMD64_ESI,    AMD64_RSI,  0, 0xffffffff }, //  ESI register
    { AMD64_EDI,    AMD64_RDI,  0, 0xffffffff }, //  EDI register
    { AMD64_R8D,    AMD64_R8,   0, 0xffffffff }, //  R8D register
    { AMD64_R9D,    AMD64_R9,   0, 0xffffffff }, //  R9D register
    { AMD64_R10D,   AMD64_R10,  0, 0xffffffff }, //  R10D register
    { AMD64_R11D,   AMD64_R11,  0, 0xffffffff }, //  R11D register
    { AMD64_R12D,   AMD64_R12,  0, 0xffffffff }, //  R12D register
    { AMD64_R13D,   AMD64_R13,  0, 0xffffffff }, //  R13D register
    { AMD64_R14D,   AMD64_R14,  0, 0xffffffff }, //  R14D register
    { AMD64_R15D,   AMD64_R15,  0, 0xffffffff }, //  R15D register
    { AMD64_EIP,    AMD64_RIP,  0, 0xffffffff }, //  EIP register
    
    { AMD64_AX,     AMD64_RAX,  0, 0xffff }, //  AX register
    { AMD64_CX,     AMD64_RCX,  0, 0xffff }, //  CX register
    { AMD64_DX,     AMD64_RDX,  0, 0xffff }, //  DX register
    { AMD64_BX,     AMD64_RBX,  0, 0xffff }, //  BX register
    { AMD64_SP,     AMD64_RSP,  0, 0xffff }, //  SP register
    { AMD64_BP,     AMD64_RBP,  0, 0xffff }, //  BP register
    { AMD64_SI,     AMD64_RSI,  0, 0xffff }, //  SI register
    { AMD64_DI,     AMD64_RDI,  0, 0xffff }, //  DI register
    { AMD64_R8W,    AMD64_R8,   0, 0xffff }, //  R8W register
    { AMD64_R9W,    AMD64_R9,   0, 0xffff }, //  R9W register
    { AMD64_R10W,   AMD64_R10,  0, 0xffff }, //  R10W register
    { AMD64_R11W,   AMD64_R11,  0, 0xffff }, //  R11W register
    { AMD64_R12W,   AMD64_R12,  0, 0xffff }, //  R12W register
    { AMD64_R13W,   AMD64_R13,  0, 0xffff }, //  R13W register
    { AMD64_R14W,   AMD64_R14,  0, 0xffff }, //  R14W register
    { AMD64_R15W,   AMD64_R15,  0, 0xffff }, //  R15W register
    { AMD64_IP,     AMD64_RIP,  0, 0xffff }, //  IP register
    { AMD64_FL,     AMD64_EFL,  0, 0xffff }, //  FL register
    
    { AMD64_AL,     AMD64_RAX,  0, 0xff }, //  AL register
    { AMD64_CL,     AMD64_RCX,  0, 0xff }, //  CL register
    { AMD64_DL,     AMD64_RDX,  0, 0xff }, //  DL register
    { AMD64_BL,     AMD64_RBX,  0, 0xff }, //  BL register
    { AMD64_SPL,    AMD64_RSP,  0, 0xff }, //  SPL register
    { AMD64_BPL,    AMD64_RBP,  0, 0xff }, //  BPL register
    { AMD64_SIL,    AMD64_RSI,  0, 0xff }, //  SIL register
    { AMD64_DIL,    AMD64_RDI,  0, 0xff }, //  DIL register
    { AMD64_R8B,    AMD64_R8,   0, 0xff }, //  R8B register
    { AMD64_R9B,    AMD64_R9,   0, 0xff }, //  R9B register
    { AMD64_R10B,   AMD64_R10,  0, 0xff }, //  R10B register
    { AMD64_R11B,   AMD64_R11,  0, 0xff }, //  R11B register
    { AMD64_R12B,   AMD64_R12,  0, 0xff }, //  R12B register
    { AMD64_R13B,   AMD64_R13,  0, 0xff }, //  R13B register
    { AMD64_R14B,   AMD64_R14,  0, 0xff }, //  R14B register
    { AMD64_R15B,   AMD64_R15,  0, 0xff }, //  R15B register
    
    { AMD64_AH,     AMD64_RAX,  8, 0xff }, //  AH register
    { AMD64_CH,     AMD64_RCX,  8, 0xff }, //  CH register
    { AMD64_DH,     AMD64_RDX,  8, 0xff }, //  DH register
    { AMD64_BH,     AMD64_RBX,  8, 0xff }, //  BH register
    
    { AMD64_IOPL,  AMD64_EFL, 12,     3 }, //  IOPL level value
    { AMD64_OF,    AMD64_EFL, 11,     1 }, //  OF (overflow flag)
    { AMD64_DF,    AMD64_EFL, 10,     1 }, //  DF (direction flag)
    { AMD64_IF,    AMD64_EFL,  9,     1 }, //  IF (interrupt enable flag)
    { AMD64_TF,    AMD64_EFL,  8,     1 }, //  TF (trace flag)
    { AMD64_SF,    AMD64_EFL,  7,     1 }, //  SF (sign flag)
    { AMD64_ZF,    AMD64_EFL,  6,     1 }, //  ZF (zero flag)
    { AMD64_AF,    AMD64_EFL,  4,     1 }, //  AF (aux carry flag)
    { AMD64_PF,    AMD64_EFL,  2,     1 }, //  PF (parity flag)
    { AMD64_CF,    AMD64_EFL,  0,     1 }, //  CF (carry flag)
    { AMD64_VIP,   AMD64_EFL, 20,     1 }, //  VIP (virtual interrupt pending)
    { AMD64_VIF,   AMD64_EFL, 19,     1 }, //  VIF (virtual interrupt flag)
    
    { REG_ERROR, REG_ERROR, 0, 0    }
};

RegisterGroup g_Amd64BaseGroup =
{
    NULL, 0, g_Amd64Defs, g_Amd64SubDefs, g_Amd64AllExtraDesc
};
RegisterGroup g_Amd64KernelGroup =
{
    NULL, 0, g_Amd64KernelReg, NULL, g_Amd64KernelExtraDesc
};

// First ExecTypes entry must be the actual processor type.
ULONG g_Amd64ExecTypes[] =
{
    IMAGE_FILE_MACHINE_AMD64
};

Amd64MachineInfo g_Amd64Machine;

BOOL g_Amd64InCode64;

HRESULT
Amd64MachineInfo::InitializeConstants(void)
{
    m_FullName = "AMD x86-64";
    m_AbbrevName = "AMD64";
    m_PageSize = AMD64_PAGE_SIZE;
    m_PageShift = AMD64_PAGE_SHIFT;
    m_NumExecTypes = 1;
    m_ExecTypes = g_Amd64ExecTypes;
    m_Ptr64 = TRUE;
    
    m_AllMask = REGALL_INT64 | REGALL_SEGREG;
    
    m_MaxDataBreakpoints = 4;
    m_SymPrefix = NULL;

    return MachineInfo::InitializeConstants();
}

HRESULT
Amd64MachineInfo::InitializeForTarget(void)
{
    m_Groups = &g_Amd64BaseGroup;
    g_Amd64BaseGroup.Next = NULL;
    if (IS_KERNEL_TARGET())
    {
        g_Amd64BaseGroup.Next = &g_Amd64KernelGroup;
    }
    
    m_OffsetPrcbProcessorState =
        FIELD_OFFSET(AMD64_PARTIAL_KPRCB, ProcessorState);
    m_OffsetPrcbNumber =
        FIELD_OFFSET(AMD64_PARTIAL_KPRCB, Number);
    m_TriagePrcbOffset = AMD64_TRIAGE_PRCB_ADDRESS;
    m_SizePrcb = AMD64_KPRCB_SIZE;
    m_OffsetKThreadApcProcess =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, Amd64Thread.ApcState.Process);
    m_OffsetKThreadTeb =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, Amd64Thread.Teb);
    m_OffsetKThreadInitialStack =
        FIELD_OFFSET(CROSS_PLATFORM_THREAD, Amd64Thread.InitialStack);
    m_OffsetKThreadNextProcessor = AMD64_KTHREAD_NEXTPROCESSOR_OFFSET;
    m_OffsetEprocessPeb = AMD64_PEB_IN_EPROCESS;
    m_OffsetEprocessDirectoryTableBase =
        AMD64_DIRECTORY_TABLE_BASE_IN_EPROCESS;
    m_SizeTargetContext = sizeof(AMD64_CONTEXT);
    m_OffsetTargetContextFlags = FIELD_OFFSET(AMD64_CONTEXT, ContextFlags);
    m_SizeCanonicalContext = sizeof(AMD64_CONTEXT);
    m_SverCanonicalContext = NT_SVER_W2K;
    m_SizeControlReport = sizeof(AMD64_DBGKD_CONTROL_REPORT);
    m_SizeEThread = AMD64_ETHREAD_SIZE;
    m_SizeEProcess = AMD64_EPROCESS_SIZE;
    m_OffsetSpecialRegisters = AMD64_DEBUG_CONTROL_SPACE_KSPECIAL;
    m_SizeKspecialRegisters = sizeof(AMD64_KSPECIAL_REGISTERS);
    m_SizePartialKThread = sizeof(AMD64_THREAD);
    m_SharedUserDataOffset = IS_KERNEL_TARGET() ?
        AMD64_KI_USER_SHARED_DATA : MM_SHARED_USER_DATA_VA;

    return MachineInfo::InitializeForTarget();
}

void
Amd64MachineInfo::
InitializeContext(ULONG64 Pc,
                  PDBGKD_ANY_CONTROL_REPORT ControlReport)
{
    m_Context.Amd64Context.Rip = Pc;
    m_ContextState = Pc ? MCTX_PC : MCTX_NONE;

    if (ControlReport != NULL)
    {
        BpOut("InitializeContext(%d) DR6 %I64X DR7 %I64X\n",
              g_RegContextProcessor, ControlReport->Amd64ControlReport.Dr6,
              ControlReport->Amd64ControlReport.Dr7);
        
        m_Context.Amd64Context.Dr6 = ControlReport->Amd64ControlReport.Dr6;
        m_Context.Amd64Context.Dr7 = ControlReport->Amd64ControlReport.Dr7;
        m_ContextState = MCTX_DR67_REPORT;

        if (ControlReport->Amd64ControlReport.ReportFlags &
            AMD64_REPORT_INCLUDES_SEGS)
        {
            m_Context.Amd64Context.SegCs =
                ControlReport->Amd64ControlReport.SegCs;
            m_Context.Amd64Context.SegDs =
                ControlReport->Amd64ControlReport.SegDs;
            m_Context.Amd64Context.SegEs =
                ControlReport->Amd64ControlReport.SegEs;
            m_Context.Amd64Context.SegFs =
                ControlReport->Amd64ControlReport.SegFs;
            m_Context.Amd64Context.EFlags =
                ControlReport->Amd64ControlReport.EFlags;
            m_ContextState = MCTX_REPORT;
        }
    }

    g_X86InVm86 = FALSE;
    g_X86InCode16 = FALSE;
    // In the absence of other information, assume we're
    // executing 64-bit code.
    g_Amd64InCode64 = TRUE;

    if (IS_CONTEXT_POSSIBLE())
    {
        if (ControlReport == NULL ||
            (ControlReport->Amd64ControlReport.ReportFlags &
             AMD64_REPORT_STANDARD_CS) == 0)
        {
            DESCRIPTOR64 Desc;
            
            // Check what kind of code segment we're in.
            if (GetSegRegDescriptor(SEGREG_CODE, &Desc) != S_OK)
            {
                WarnOut("CS descriptor lookup failed\n");
            }
            else if ((Desc.Flags & X86_DESC_LONG_MODE) == 0)
            {
                g_Amd64InCode64 = FALSE;
                g_X86InVm86 = X86_IS_VM86(GetReg32(X86_EFL));
                g_X86InCode16 = (Desc.Flags & X86_DESC_DEFAULT_BIG) == 0;
            }
        }
        else
        {
            // We're in a standard code segment so cache
            // a default descriptor for CS to avoid further
            // CS lookups.
            EmulateNtSelDescriptor(this, m_Context.Amd64Context.SegCs,
                                   &m_SegRegDesc[SEGREG_CODE]);
        }
    }

    // Add instructions to cache only if we're in flat mode.
    if (Pc && ControlReport != NULL &&
        !g_X86InVm86 && !g_X86InCode16 && g_Amd64InCode64)
    {
        CacheReportInstructions
            (Pc, ControlReport->Amd64ControlReport.InstructionCount,
             ControlReport->Amd64ControlReport.InstructionStream);
    }
}

HRESULT
Amd64MachineInfo::KdGetContextState(ULONG State)
{
    HRESULT Status;
        
    if (State >= MCTX_CONTEXT && m_ContextState < MCTX_CONTEXT)
    {
        Status = g_Target->GetContext(g_RegContextThread->Handle, &m_Context);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_CONTEXT;
    }

    if (State >= MCTX_FULL && m_ContextState < MCTX_FULL)
    {
        Status = g_Target->GetTargetSpecialRegisters
            (g_RegContextThread->Handle, (PCROSS_PLATFORM_KSPECIAL_REGISTERS)
             &m_SpecialRegContext);
        if (Status != S_OK)
        {
            return Status;
        }
        
        Status = g_Target->GetTargetSegRegDescriptors
            (g_RegContextThread->Handle, 0, SEGREG_COUNT, m_SegRegDesc);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_FULL;
        KdSetSpecialRegistersInContext();

        BpOut("GetContextState(%d) DR6 %I64X DR7 %I64X\n",
              g_RegContextProcessor, m_SpecialRegContext.KernelDr6,
              m_SpecialRegContext.KernelDr7);
    }

    return S_OK;
}

HRESULT
Amd64MachineInfo::KdSetContext(void)
{
    HRESULT Status;
    
    Status = g_Target->SetContext(g_RegContextThread->Handle, &m_Context);
    if (Status != S_OK)
    {
        return Status;
    }

    KdGetSpecialRegistersFromContext();
    Status = g_Target->SetTargetSpecialRegisters
        (g_RegContextThread->Handle, (PCROSS_PLATFORM_KSPECIAL_REGISTERS)
         &m_SpecialRegContext);
    
    BpOut("SetContext(%d) DR6 %I64X DR7 %I64X\n",
          g_RegContextProcessor, m_SpecialRegContext.KernelDr6,
          m_SpecialRegContext.KernelDr7);
    
    return S_OK;
}

HRESULT
Amd64MachineInfo::ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                     ULONG FromSver, ULONG FromSize,
                                     PVOID From)
{
    if (FromSize >= sizeof(AMD64_CONTEXT))
    {
        memcpy(Context, From, sizeof(AMD64_CONTEXT));
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

HRESULT
Amd64MachineInfo::ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                   ULONG ToSver, ULONG ToSize, PVOID To)
{
    if (ToSize >= sizeof(AMD64_CONTEXT))
    {
        memcpy(To, Context, sizeof(AMD64_CONTEXT));
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

void
Amd64MachineInfo::InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                         ULONG Version)
{
    ULONG ContextFlags;
    
    ContextFlags = AMD64_CONTEXT_FULL | AMD64_CONTEXT_SEGMENTS;
    if (IS_USER_TARGET())
    {
        ContextFlags |= AMD64_CONTEXT_DEBUG_REGISTERS;
    }
    
    Context->Amd64Context.ContextFlags = ContextFlags;
}

HRESULT
Amd64MachineInfo::GetContextFromThreadStack(ULONG64 ThreadBase,
                                            PCROSS_PLATFORM_THREAD Thread,
                                            PCROSS_PLATFORM_CONTEXT Context,
                                            PDEBUG_STACK_FRAME Frame,
                                            PULONG RunningOnProc)
{
    HRESULT Status;
    UCHAR Proc;

    //
    // Check to see if the thread is currently running.
    //
    
    if (Thread->Amd64Thread.State == 2) 
    {
        if ((Status = g_Target->ReadAllVirtual
             (ThreadBase + m_OffsetKThreadNextProcessor, 
              &Proc, sizeof(Proc))) != S_OK)
        {
            return Status;
        }

        *RunningOnProc = Proc;
        return S_FALSE;
    }

    //
    // The thread isn't running so read its stored context information.
    //
    
    AMD64_KSWITCH_FRAME SwitchFrame;

    if ((Status = g_Target->ReadAllVirtual(Thread->Amd64Thread.KernelStack,
                                           &SwitchFrame,
                                           sizeof(SwitchFrame))) != S_OK)
    {
        return Status;
    }
    
    Context->Amd64Context.Rbp = SwitchFrame.Rbp;
    Context->Amd64Context.Rsp = 
        Thread->Amd64Thread.KernelStack + sizeof(SwitchFrame);
    Context->Amd64Context.Rip = SwitchFrame.Return;

    Frame->StackOffset = Context->Amd64Context.Rsp;
    Frame->FrameOffset = Context->Amd64Context.Rbp;
    Frame->InstructionOffset = Context->Amd64Context.Rip;

    return S_OK;
}

HRESULT
Amd64MachineInfo::GetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context)
{
    // Always ask for everything.
    Context->Amd64Context.RegGroupSelection.fSegmentRegs = TRUE;
    Context->Amd64Context.RegGroupSelection.fControlRegs = TRUE;
    Context->Amd64Context.RegGroupSelection.fIntegerRegs = TRUE;
    Context->Amd64Context.RegGroupSelection.fFloatingPointRegs = TRUE;
    Context->Amd64Context.RegGroupSelection.fDebugRegs = TRUE;
    Context->Amd64Context.RegGroupSelection.fSegmentDescriptors = TRUE;
    Context->Amd64Context.RegGroupSelection.fSSERegisters = TRUE;
    Context->Amd64Context.RegGroupSelection.fSystemRegisters = TRUE;
    return ((IeXdiX86_64Context*)Exdi)->GetContext(&Context->Amd64Context);
}

HRESULT
Amd64MachineInfo::SetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context)
{
    // Don't change the existing group selections on the assumption
    // that there was a full get prior to any modifications so
    // all groups are valid.
    return ((IeXdiX86_64Context*)Exdi)->SetContext(Context->Amd64Context);
}

void
Amd64MachineInfo::ConvertExdiContextFromContext
    (PCROSS_PLATFORM_CONTEXT Context, PEXDI_CONTEXT ExdiContext)
{
    if (Context->Amd64Context.ContextFlags & AMD64_CONTEXT_SEGMENTS)
    {
        ExdiContext->Amd64Context.SegDs = Context->Amd64Context.SegDs;
        ExdiContext->Amd64Context.SegEs = Context->Amd64Context.SegEs;
        ExdiContext->Amd64Context.SegFs = Context->Amd64Context.SegFs;
        ExdiContext->Amd64Context.SegGs = Context->Amd64Context.SegGs;
    }
    
    if (Context->Amd64Context.ContextFlags & AMD64_CONTEXT_CONTROL)
    {
        ExdiContext->Amd64Context.SegCs = Context->Amd64Context.SegCs;
        ExdiContext->Amd64Context.Rip = Context->Amd64Context.Rip;
        ExdiContext->Amd64Context.SegSs = Context->Amd64Context.SegSs;
        ExdiContext->Amd64Context.Rsp = Context->Amd64Context.Rsp;
        ExdiContext->Amd64Context.EFlags = Context->Amd64Context.EFlags;
    }

    if (Context->Amd64Context.ContextFlags & AMD64_CONTEXT_DEBUG_REGISTERS)
    {
        ExdiContext->Amd64Context.Dr0 = Context->Amd64Context.Dr0;
        ExdiContext->Amd64Context.Dr1 = Context->Amd64Context.Dr1;
        ExdiContext->Amd64Context.Dr2 = Context->Amd64Context.Dr2;
        ExdiContext->Amd64Context.Dr3 = Context->Amd64Context.Dr3;
        ExdiContext->Amd64Context.Dr6 = Context->Amd64Context.Dr6;
        ExdiContext->Amd64Context.Dr7 = Context->Amd64Context.Dr7;
    }
    
    if (Context->Amd64Context.ContextFlags & AMD64_CONTEXT_INTEGER)
    {
        ExdiContext->Amd64Context.Rax = Context->Amd64Context.Rax;
        ExdiContext->Amd64Context.Rcx = Context->Amd64Context.Rcx;
        ExdiContext->Amd64Context.Rdx = Context->Amd64Context.Rdx;
        ExdiContext->Amd64Context.Rbx = Context->Amd64Context.Rbx;
        ExdiContext->Amd64Context.Rbp = Context->Amd64Context.Rbp;
        ExdiContext->Amd64Context.Rsi = Context->Amd64Context.Rsi;
        ExdiContext->Amd64Context.Rdi = Context->Amd64Context.Rdi;
        ExdiContext->Amd64Context.R8 = Context->Amd64Context.R8;
        ExdiContext->Amd64Context.R9 = Context->Amd64Context.R9;
        ExdiContext->Amd64Context.R10 = Context->Amd64Context.R10;
        ExdiContext->Amd64Context.R11 = Context->Amd64Context.R11;
        ExdiContext->Amd64Context.R12 = Context->Amd64Context.R12;
        ExdiContext->Amd64Context.R13 = Context->Amd64Context.R13;
        ExdiContext->Amd64Context.R14 = Context->Amd64Context.R14;
        ExdiContext->Amd64Context.R15 = Context->Amd64Context.R15;
    }

    if (Context->Amd64Context.ContextFlags & AMD64_CONTEXT_FLOATING_POINT)
    {
        ExdiContext->Amd64Context.ControlWord =
            Context->Amd64Context.FltSave.ControlWord;
        ExdiContext->Amd64Context.StatusWord =
            Context->Amd64Context.FltSave.StatusWord;
        ExdiContext->Amd64Context.TagWord =
            Context->Amd64Context.FltSave.TagWord;
        ExdiContext->Amd64Context.ErrorOffset =
            Context->Amd64Context.FltSave.ErrorOffset;
        ExdiContext->Amd64Context.ErrorSelector =
            Context->Amd64Context.FltSave.ErrorSelector;
        ExdiContext->Amd64Context.DataOffset =
            Context->Amd64Context.FltSave.DataOffset;
        ExdiContext->Amd64Context.DataSelector =
            Context->Amd64Context.FltSave.DataSelector;
        ExdiContext->Amd64Context.RegMXCSR =
            Context->Amd64Context.MxCsr;
        for (ULONG i = 0; i < 8; i++)
        {
            memcpy(ExdiContext->Amd64Context.RegisterArea + i * 10,
                   Context->Amd64Context.FltSave.FloatRegisters + i * 10,
                   10);
        }
        memcpy(ExdiContext->Amd64Context.RegSSE,
               &Context->Amd64Context.Xmm0, 16 * sizeof(AMD64_M128));
    }
}

void
Amd64MachineInfo::ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                              PCROSS_PLATFORM_CONTEXT Context)
{
    Context->Amd64Context.SegCs = (USHORT)ExdiContext->Amd64Context.SegCs;
    Context->Amd64Context.SegDs = (USHORT)ExdiContext->Amd64Context.SegDs;
    Context->Amd64Context.SegEs = (USHORT)ExdiContext->Amd64Context.SegEs;
    Context->Amd64Context.SegFs = (USHORT)ExdiContext->Amd64Context.SegFs;
    Context->Amd64Context.SegGs = (USHORT)ExdiContext->Amd64Context.SegGs;
    Context->Amd64Context.SegSs = (USHORT)ExdiContext->Amd64Context.SegSs;
    Context->Amd64Context.EFlags = (ULONG)ExdiContext->Amd64Context.EFlags;

    Context->Amd64Context.Dr0 = ExdiContext->Amd64Context.Dr0;
    Context->Amd64Context.Dr1 = ExdiContext->Amd64Context.Dr1;
    Context->Amd64Context.Dr2 = ExdiContext->Amd64Context.Dr2;
    Context->Amd64Context.Dr3 = ExdiContext->Amd64Context.Dr3;
    Context->Amd64Context.Dr6 = ExdiContext->Amd64Context.Dr6;
    Context->Amd64Context.Dr7 = ExdiContext->Amd64Context.Dr7;
    
    Context->Amd64Context.Rax = ExdiContext->Amd64Context.Rax;
    Context->Amd64Context.Rcx = ExdiContext->Amd64Context.Rcx;
    Context->Amd64Context.Rdx = ExdiContext->Amd64Context.Rdx;
    Context->Amd64Context.Rbx = ExdiContext->Amd64Context.Rbx;
    Context->Amd64Context.Rsp = ExdiContext->Amd64Context.Rsp;
    Context->Amd64Context.Rbp = ExdiContext->Amd64Context.Rbp;
    Context->Amd64Context.Rsi = ExdiContext->Amd64Context.Rsi;
    Context->Amd64Context.Rdi = ExdiContext->Amd64Context.Rdi;
    Context->Amd64Context.R8 = ExdiContext->Amd64Context.R8;
    Context->Amd64Context.R9 = ExdiContext->Amd64Context.R9;
    Context->Amd64Context.R10 = ExdiContext->Amd64Context.R10;
    Context->Amd64Context.R11 = ExdiContext->Amd64Context.R11;
    Context->Amd64Context.R12 = ExdiContext->Amd64Context.R12;
    Context->Amd64Context.R13 = ExdiContext->Amd64Context.R13;
    Context->Amd64Context.R14 = ExdiContext->Amd64Context.R14;
    Context->Amd64Context.R15 = ExdiContext->Amd64Context.R15;

    Context->Amd64Context.Rip = ExdiContext->Amd64Context.Rip;

    Context->Amd64Context.FltSave.ControlWord =
        (USHORT)ExdiContext->Amd64Context.ControlWord;
    Context->Amd64Context.FltSave.StatusWord =
        (USHORT)ExdiContext->Amd64Context.StatusWord;
    Context->Amd64Context.FltSave.TagWord =
        (USHORT)ExdiContext->Amd64Context.TagWord;
    // XXX drewb - No ErrorOpcode in x86_64.
    Context->Amd64Context.FltSave.ErrorOpcode = 0;
    Context->Amd64Context.FltSave.ErrorOffset =
        ExdiContext->Amd64Context.ErrorOffset;
    Context->Amd64Context.FltSave.ErrorSelector =
        (USHORT)ExdiContext->Amd64Context.ErrorSelector;
    Context->Amd64Context.FltSave.DataOffset =
        ExdiContext->Amd64Context.DataOffset;
    Context->Amd64Context.FltSave.DataSelector =
        (USHORT)ExdiContext->Amd64Context.DataSelector;
    Context->Amd64Context.MxCsr =
        ExdiContext->Amd64Context.RegMXCSR;
    for (ULONG i = 0; i < 8; i++)
    {
        memcpy(Context->Amd64Context.FltSave.FloatRegisters + i * 10,
               ExdiContext->Amd64Context.RegisterArea + i * 10, 10);
    }
    memcpy(&Context->Amd64Context.Xmm0, ExdiContext->Amd64Context.RegSSE,
           16 * sizeof(AMD64_M128));
}

void
Amd64MachineInfo::ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                               ULONG Start, ULONG Count,
                                               PDESCRIPTOR64 Descs)
{
    while (Count-- > 0)
    {
        SEG64_DESC_INFO* Desc;

        switch(Start)
        {
        case SEGREG_CODE:
            Desc = &ExdiContext->Amd64Context.DescriptorCs;
            break;
        case SEGREG_DATA:
            Desc = &ExdiContext->Amd64Context.DescriptorDs;
            break;
        case SEGREG_STACK:
            Desc = &ExdiContext->Amd64Context.DescriptorSs;
            break;
        case SEGREG_ES:
            Desc = &ExdiContext->Amd64Context.DescriptorEs;
            break;
        case SEGREG_FS:
            Desc = &ExdiContext->Amd64Context.DescriptorFs;
            break;
        case SEGREG_GS:
            Desc = &ExdiContext->Amd64Context.DescriptorGs;
            break;
        case SEGREG_GDT:
            Descs->Base = ExdiContext->Amd64Context.GDTBase;
            Descs->Limit = ExdiContext->Amd64Context.GDTLimit;
            Descs->Flags = X86_DESC_PRESENT;
            Desc = NULL;
            break;
        case SEGREG_LDT:
            Desc = &ExdiContext->Amd64Context.SegLDT;
            break;
        default:
            Descs->Flags = SEGDESC_INVALID;
            Desc = NULL;
            break;
        }

        if (Desc != NULL)
        {
            Descs->Base = Desc->SegBase;
            Descs->Limit = Desc->SegLimit;
            Descs->Flags =
                ((Desc->SegFlags >> 4) & 0xf00) |
                (Desc->SegFlags & 0xff);
        }

        Descs++;
        Start++;
    }
}

void
Amd64MachineInfo::ConvertExdiContextFromSpecial
    (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
     PEXDI_CONTEXT ExdiContext)
{
    ExdiContext->Amd64Context.RegCr0 = Special->Amd64Special.Cr0;
    ExdiContext->Amd64Context.RegCr2 = Special->Amd64Special.Cr2;
    ExdiContext->Amd64Context.RegCr3 = Special->Amd64Special.Cr3;
    ExdiContext->Amd64Context.RegCr4 = Special->Amd64Special.Cr4;
#ifdef HAVE_AMD64_CR8
    ExdiContext->Amd64Context.RegCr8 = Special->Amd64Special.Cr8;
#endif
    ExdiContext->Amd64Context.Dr0 = Special->Amd64Special.KernelDr0;
    ExdiContext->Amd64Context.Dr1 = Special->Amd64Special.KernelDr1;
    ExdiContext->Amd64Context.Dr2 = Special->Amd64Special.KernelDr2;
    ExdiContext->Amd64Context.Dr3 = Special->Amd64Special.KernelDr3;
    ExdiContext->Amd64Context.Dr6 = Special->Amd64Special.KernelDr6;
    ExdiContext->Amd64Context.Dr7 = Special->Amd64Special.KernelDr7;
    ExdiContext->Amd64Context.GDTLimit = Special->Amd64Special.Gdtr.Limit;
    ExdiContext->Amd64Context.GDTBase = Special->Amd64Special.Gdtr.Base;
    ExdiContext->Amd64Context.IDTLimit = Special->Amd64Special.Idtr.Limit;
    ExdiContext->Amd64Context.IDTBase = Special->Amd64Special.Idtr.Base;
    ExdiContext->Amd64Context.SelTSS = Special->Amd64Special.Tr;
    ExdiContext->Amd64Context.SelLDT = Special->Amd64Special.Ldtr;
}

void
Amd64MachineInfo::ConvertExdiContextToSpecial
    (PEXDI_CONTEXT ExdiContext,
     PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    Special->Amd64Special.Cr0 = ExdiContext->Amd64Context.RegCr0;
    Special->Amd64Special.Cr2 = ExdiContext->Amd64Context.RegCr2;
    Special->Amd64Special.Cr3 = ExdiContext->Amd64Context.RegCr3;
    Special->Amd64Special.Cr4 = ExdiContext->Amd64Context.RegCr4;
#ifdef HAVE_AMD64_CR8
    Special->Amd64Special.Cr8 = ExdiContext->Amd64Context.RegCr8;
#endif
    Special->Amd64Special.KernelDr0 = ExdiContext->Amd64Context.Dr0;
    Special->Amd64Special.KernelDr1 = ExdiContext->Amd64Context.Dr1;
    Special->Amd64Special.KernelDr2 = ExdiContext->Amd64Context.Dr2;
    Special->Amd64Special.KernelDr3 = ExdiContext->Amd64Context.Dr3;
    Special->Amd64Special.KernelDr6 = ExdiContext->Amd64Context.Dr6;
    Special->Amd64Special.KernelDr7 = ExdiContext->Amd64Context.Dr7;
    Special->Amd64Special.Gdtr.Limit =
        (USHORT)ExdiContext->Amd64Context.GDTLimit;
    Special->Amd64Special.Gdtr.Base = ExdiContext->Amd64Context.GDTBase;
    Special->Amd64Special.Idtr.Limit =
        (USHORT)ExdiContext->Amd64Context.IDTLimit;
    Special->Amd64Special.Idtr.Base = ExdiContext->Amd64Context.IDTBase;
    Special->Amd64Special.Tr = (USHORT)ExdiContext->Amd64Context.SelTSS;
    Special->Amd64Special.Ldtr = (USHORT)ExdiContext->Amd64Context.SelLDT;
}

int
Amd64MachineInfo::GetType(ULONG RegNum)
{
    if (RegNum >= AMD64_MM_FIRST && RegNum <= AMD64_MM_LAST)
    {
        return REGVAL_VECTOR64;
    }
    else if (RegNum >= AMD64_XMM_FIRST && RegNum <= AMD64_XMM_LAST)
    {
        return REGVAL_VECTOR128;
    }
    else if (RegNum >= AMD64_ST_FIRST && RegNum <= AMD64_ST_LAST)
    {
        return REGVAL_FLOAT10;
    }
    else if ((RegNum >= AMD64_SEG_FIRST && RegNum <= AMD64_SEG_LAST) ||
             (RegNum >= AMD64_FPCTRL_FIRST && RegNum <= AMD64_FPCTRL_LAST) ||
             RegNum == AMD64_TR || RegNum == AMD64_LDTR ||
             RegNum == AMD64_GDTL || RegNum == AMD64_IDTL)
    {
        return REGVAL_INT16;
    }
    else if (RegNum == AMD64_EFL || RegNum == AMD64_MXCSR)
    {
        return REGVAL_INT32;
    }
    else if (RegNum < AMD64_SUBREG_BASE)
    {
        return REGVAL_INT64;
    }
    else
    {
        return REGVAL_SUB64;
    }
}

BOOL
Amd64MachineInfo::GetVal(ULONG RegNum, REGVAL* Val)
{
    // The majority of the registers are 64-bit so default
    // to that type.
    Val->type = REGVAL_INT64;
    
    switch(m_ContextState)
    {
    case MCTX_PC:
        if (RegNum == AMD64_RIP)
        {
            Val->i64 = m_Context.Amd64Context.Rip;
            return TRUE;
        }
        goto MctxContext;
        
    case MCTX_DR67_REPORT:
        switch(RegNum)
        {
        case AMD64_DR6:
            Val->i64 = m_Context.Amd64Context.Dr6;
            break;
        case AMD64_DR7:
            Val->i64 = m_Context.Amd64Context.Dr7;
            break;
        default:
            goto MctxContext;
        }
        return TRUE;

    case MCTX_REPORT:
        switch(RegNum)
        {
        case AMD64_RIP:
            Val->i64 = m_Context.Amd64Context.Rip;
            break;
        case AMD64_EFL:
            Val->type = REGVAL_INT32;
            Val->i64 = m_Context.Amd64Context.EFlags;
            break;
        case AMD64_CS:
            Val->type = REGVAL_INT16;
            Val->i64 = m_Context.Amd64Context.SegCs;
            break;
        case AMD64_DS:
            Val->type = REGVAL_INT16;
            Val->i64 = m_Context.Amd64Context.SegDs;
            break;
        case AMD64_ES:
            Val->type = REGVAL_INT16;
            Val->i64 = m_Context.Amd64Context.SegEs;
            break;
        case AMD64_FS:
            Val->type = REGVAL_INT16;
            Val->i64 = m_Context.Amd64Context.SegFs;
            break;
        case AMD64_DR6:
            Val->i64 = m_Context.Amd64Context.Dr6;
            break;
        case AMD64_DR7:
            Val->i64 = m_Context.Amd64Context.Dr7;
            break;
        default:
            goto MctxContext;
        }
        return TRUE;
        
    case MCTX_NONE:
    MctxContext:
        if (GetContextState(MCTX_CONTEXT) != S_OK)
        {
            return FALSE;
        }
        // Fall through.
        
    case MCTX_CONTEXT:
        switch(RegNum)
        {
        case AMD64_RIP:
            Val->i64 = m_Context.Amd64Context.Rip;
            return TRUE;
        case AMD64_EFL:
            Val->type = REGVAL_INT32;
            Val->i64 = m_Context.Amd64Context.EFlags;
            return TRUE;
        case AMD64_CS:
            Val->type = REGVAL_INT16;
            Val->i64 = m_Context.Amd64Context.SegCs;
            return TRUE;
        case AMD64_DS:
            Val->type = REGVAL_INT16;
            Val->i64 = m_Context.Amd64Context.SegDs;
            return TRUE;
        case AMD64_ES:
            Val->type = REGVAL_INT16;
            Val->i64 = m_Context.Amd64Context.SegEs;
            return TRUE;
        case AMD64_FS:
            Val->type = REGVAL_INT16;
            Val->i64 = m_Context.Amd64Context.SegFs;
            return TRUE;

        case AMD64_RAX:
            Val->i64 = m_Context.Amd64Context.Rax;
            return TRUE;
        case AMD64_RCX:
            Val->i64 = m_Context.Amd64Context.Rcx;
            return TRUE;
        case AMD64_RDX:
            Val->i64 = m_Context.Amd64Context.Rdx;
            return TRUE;
        case AMD64_RBX:
            Val->i64 = m_Context.Amd64Context.Rbx;
            return TRUE;
        case AMD64_RSP:
            Val->i64 = m_Context.Amd64Context.Rsp;
            return TRUE;
        case AMD64_RBP:
            Val->i64 = m_Context.Amd64Context.Rbp;
            return TRUE;
        case AMD64_RSI:
            Val->i64 = m_Context.Amd64Context.Rsi;
            return TRUE;
        case AMD64_RDI:
            Val->i64 = m_Context.Amd64Context.Rdi;
            return TRUE;
        case AMD64_R8:
            Val->i64 = m_Context.Amd64Context.R8;
            return TRUE;
        case AMD64_R9:
            Val->i64 = m_Context.Amd64Context.R9;
            return TRUE;
        case AMD64_R10:
            Val->i64 = m_Context.Amd64Context.R10;
            return TRUE;
        case AMD64_R11:
            Val->i64 = m_Context.Amd64Context.R11;
            return TRUE;
        case AMD64_R12:
            Val->i64 = m_Context.Amd64Context.R12;
            return TRUE;
        case AMD64_R13:
            Val->i64 = m_Context.Amd64Context.R13;
            return TRUE;
        case AMD64_R14:
            Val->i64 = m_Context.Amd64Context.R14;
            return TRUE;
        case AMD64_R15:
            Val->i64 = m_Context.Amd64Context.R15;
            return TRUE;
            
        case AMD64_GS:
            Val->type = REGVAL_INT16;
            Val->i64 = m_Context.Amd64Context.SegGs;
            return TRUE;
        case AMD64_SS:
            Val->type = REGVAL_INT16;
            Val->i64 = m_Context.Amd64Context.SegSs;
            return TRUE;

        case AMD64_FPCW:
            Val->type = REGVAL_INT16;
            Val->i64 = m_Context.Amd64Context.FltSave.ControlWord;
            return TRUE;
        case AMD64_FPSW:
            Val->type = REGVAL_INT16;
            Val->i64 = m_Context.Amd64Context.FltSave.StatusWord;
            return TRUE;
        case AMD64_FPTW:
            Val->type = REGVAL_INT16;
            Val->i64 = m_Context.Amd64Context.FltSave.TagWord;
            return TRUE;
        
        case AMD64_MXCSR:
            Val->type = REGVAL_INT32;
            Val->i64 = m_Context.Amd64Context.MxCsr;
            return TRUE;
        }
        
        if (RegNum >= AMD64_MM_FIRST && RegNum <= AMD64_MM_LAST)
        {
            Val->type = REGVAL_VECTOR64;
            Val->i64 = *(PULONG64)&m_Context.Amd64Context.FltSave.
                FloatRegisters[GetMmxRegOffset(RegNum - AMD64_MM_FIRST,
                                               GetReg32(AMD64_FPSW)) * 10];
            return TRUE;
        }
        else if (RegNum >= AMD64_XMM_FIRST && RegNum <= AMD64_XMM_LAST)
        {
            Val->type = REGVAL_VECTOR128;
            memcpy(Val->bytes, (PUCHAR)&m_Context.Amd64Context.Xmm0 +
                   (RegNum - AMD64_XMM_FIRST) * 16, 16);
            return TRUE;
        }
        else if (RegNum >= AMD64_ST_FIRST && RegNum <= AMD64_ST_LAST)
        {
            Val->type = REGVAL_FLOAT10;
            memcpy(Val->f10, &m_Context.Amd64Context.FltSave.
                   FloatRegisters[(RegNum - AMD64_ST_FIRST) * 10],
                   sizeof(Val->f10));
            return TRUE;
        }
        
        //
        // The requested register is not in our current context, load up
        // a complete context
        //

        if (GetContextState(MCTX_FULL) != S_OK)
        {
            return FALSE;
        }
        break;
    }

    //
    // We must have a complete context...
    //

    switch(RegNum)
    {
    case AMD64_RAX:
        Val->i64 = m_Context.Amd64Context.Rax;
        return TRUE;
    case AMD64_RCX:
        Val->i64 = m_Context.Amd64Context.Rcx;
        return TRUE;
    case AMD64_RDX:
        Val->i64 = m_Context.Amd64Context.Rdx;
        return TRUE;
    case AMD64_RBX:
        Val->i64 = m_Context.Amd64Context.Rbx;
        return TRUE;
    case AMD64_RSP:
        Val->i64 = m_Context.Amd64Context.Rsp;
        return TRUE;
    case AMD64_RBP:
        Val->i64 = m_Context.Amd64Context.Rbp;
        return TRUE;
    case AMD64_RSI:
        Val->i64 = m_Context.Amd64Context.Rsi;
        return TRUE;
    case AMD64_RDI:
        Val->i64 = m_Context.Amd64Context.Rdi;
        return TRUE;
    case AMD64_R8:
        Val->i64 = m_Context.Amd64Context.R8;
        return TRUE;
    case AMD64_R9:
        Val->i64 = m_Context.Amd64Context.R9;
        return TRUE;
    case AMD64_R10:
        Val->i64 = m_Context.Amd64Context.R10;
        return TRUE;
    case AMD64_R11:
        Val->i64 = m_Context.Amd64Context.R11;
        return TRUE;
    case AMD64_R12:
        Val->i64 = m_Context.Amd64Context.R12;
        return TRUE;
    case AMD64_R13:
        Val->i64 = m_Context.Amd64Context.R13;
        return TRUE;
    case AMD64_R14:
        Val->i64 = m_Context.Amd64Context.R14;
        return TRUE;
    case AMD64_R15:
        Val->i64 = m_Context.Amd64Context.R15;
        return TRUE;
        
    case AMD64_RIP:
        Val->i64 = m_Context.Amd64Context.Rip;
        return TRUE;
    case AMD64_EFL:
        Val->type = REGVAL_INT32;
        Val->i64 = m_Context.Amd64Context.EFlags;
        return TRUE;

    case AMD64_CS:
        Val->type = REGVAL_INT16;
        Val->i64 = m_Context.Amd64Context.SegCs;
        return TRUE;
    case AMD64_DS:
        Val->type = REGVAL_INT16;
        Val->i64 = m_Context.Amd64Context.SegDs;
        return TRUE;
    case AMD64_ES:
        Val->type = REGVAL_INT16;
        Val->i64 = m_Context.Amd64Context.SegEs;
        return TRUE;
    case AMD64_FS:
        Val->type = REGVAL_INT16;
        Val->i64 = m_Context.Amd64Context.SegFs;
        return TRUE;
    case AMD64_GS:
        Val->type = REGVAL_INT16;
        Val->i64 = m_Context.Amd64Context.SegGs;
        return TRUE;
    case AMD64_SS:
        Val->type = REGVAL_INT16;
        Val->i64 = m_Context.Amd64Context.SegSs;
        return TRUE;
        
    case AMD64_DR0:
        Val->i64 = m_Context.Amd64Context.Dr0;
        return TRUE;
    case AMD64_DR1:
        Val->i64 = m_Context.Amd64Context.Dr1;
        return TRUE;
    case AMD64_DR2:
        Val->i64 = m_Context.Amd64Context.Dr2;
        return TRUE;
    case AMD64_DR3:
        Val->i64 = m_Context.Amd64Context.Dr3;
        return TRUE;
    case AMD64_DR6:
        Val->i64 = m_Context.Amd64Context.Dr6;
        return TRUE;
    case AMD64_DR7:
        Val->i64 = m_Context.Amd64Context.Dr7;
        return TRUE;

    case AMD64_FPCW:
        Val->type = REGVAL_INT16;
        Val->i64 = m_Context.Amd64Context.FltSave.ControlWord;
        return TRUE;
    case AMD64_FPSW:
        Val->type = REGVAL_INT16;
        Val->i64 = m_Context.Amd64Context.FltSave.StatusWord;
        return TRUE;
    case AMD64_FPTW:
        Val->type = REGVAL_INT16;
        Val->i64 = m_Context.Amd64Context.FltSave.TagWord;
        return TRUE;
        
    case AMD64_MXCSR:
        Val->type = REGVAL_INT32;
        Val->i64 = m_Context.Amd64Context.MxCsr;
        return TRUE;
    }

    if (RegNum >= AMD64_MM_FIRST && RegNum <= AMD64_MM_LAST)
    {
        Val->type = REGVAL_VECTOR64;
        Val->i64 = *(PULONG64)&m_Context.Amd64Context.FltSave.
            FloatRegisters[GetMmxRegOffset(RegNum - AMD64_MM_FIRST,
                                           GetReg32(AMD64_FPSW)) * 10];
        return TRUE;
    }
    else if (RegNum >= AMD64_XMM_FIRST && RegNum <= AMD64_XMM_LAST)
    {
        Val->type = REGVAL_VECTOR128;
        memcpy(Val->bytes, (PUCHAR)&m_Context.Amd64Context.Xmm0 +
               (RegNum - AMD64_XMM_FIRST) * 16, 16);
        return TRUE;
    }
    else if (RegNum >= AMD64_ST_FIRST && RegNum <= AMD64_ST_LAST)
    {
        Val->type = REGVAL_FLOAT10;
        memcpy(Val->f10, &m_Context.Amd64Context.FltSave.
               FloatRegisters[(RegNum - AMD64_ST_FIRST) * 10],
               sizeof(Val->f10));
        return TRUE;
    }
        
    if (IS_KERNEL_TARGET())
    {
        switch(RegNum)
        {
        case AMD64_CR0:
            Val->i64 = m_SpecialRegContext.Cr0;
            return TRUE;
        case AMD64_CR2:
            Val->i64 = m_SpecialRegContext.Cr2;
            return TRUE;
        case AMD64_CR3:
            Val->i64 = m_SpecialRegContext.Cr3;
            return TRUE;
        case AMD64_CR4:
            Val->i64 = m_SpecialRegContext.Cr4;
            return TRUE;
#ifdef HAVE_AMD64_CR8
        case AMD64_CR8:
            Val->i64 = m_SpecialRegContext.Cr8;
            return TRUE;
#endif
            
        case AMD64_GDTR:
            Val->i64 = m_SpecialRegContext.Gdtr.Base;
            return TRUE;
        case AMD64_GDTL:
            Val->type = REGVAL_INT16;
            Val->i64 = m_SpecialRegContext.Gdtr.Limit;
            return TRUE;
        case AMD64_IDTR:
            Val->i64 = m_SpecialRegContext.Idtr.Base;
            return TRUE;
        case AMD64_IDTL:
            Val->type = REGVAL_INT16;
            Val->i64 = m_SpecialRegContext.Idtr.Limit;
            return TRUE;
        case AMD64_TR:
            Val->type = REGVAL_INT16;
            Val->i64 = m_SpecialRegContext.Tr;
            return TRUE;
        case AMD64_LDTR:
            Val->type = REGVAL_INT16;
            Val->i64 = m_SpecialRegContext.Ldtr;
            return TRUE;
        }
    }

    ErrOut("Amd64MachineInfo::GetVal: "
           "unknown register %lx requested\n", RegNum);
    return REG_ERROR;
}

BOOL
Amd64MachineInfo::SetVal(ULONG RegNum, REGVAL* Val)
{
    if (RegNum >= AMD64_SUBREG_BASE)
    {
        return FALSE;
    }

    // Optimize away some common cases where registers are
    // set to their current value.
    if ((m_ContextState >= MCTX_PC && RegNum == AMD64_RIP &&
         Val->i64 == m_Context.Amd64Context.Rip) ||
        (((m_ContextState >= MCTX_DR67_REPORT &&
           m_ContextState <= MCTX_REPORT) ||
          m_ContextState >= MCTX_FULL) && RegNum == AMD64_DR7 &&
         Val->i64 == m_Context.Amd64Context.Dr7))
    {
        return TRUE;
    }
    
    if (GetContextState(MCTX_DIRTY) != S_OK)
    {
        return FALSE;
    }

    if (RegNum >= AMD64_MM_FIRST && RegNum <= AMD64_MM_LAST)
    {
        *(PULONG64)&m_Context.Amd64Context.FltSave.
            FloatRegisters[GetMmxRegOffset(RegNum - AMD64_MM_FIRST,
                                           GetReg32(AMD64_FPSW)) * 10] =
            Val->i64;
        goto Notify;
    }
    else if (RegNum >= AMD64_XMM_FIRST && RegNum <= AMD64_XMM_LAST)
    {
        memcpy((PUCHAR)&m_Context.Amd64Context.Xmm0 +
               (RegNum - AMD64_XMM_FIRST) * 16, Val->bytes, 16);
        goto Notify;
    }
    else if (RegNum >= AMD64_ST_FIRST && RegNum <= AMD64_ST_LAST)
    {
        memcpy(&m_Context.Amd64Context.FltSave.
               FloatRegisters[(RegNum - AMD64_ST_FIRST) * 10],
               Val->f10, sizeof(Val->f10));
        goto Notify;
    }
        
    BOOL Recognized;

    Recognized = TRUE;
    
    switch(RegNum)
    {
    case AMD64_RAX:
        m_Context.Amd64Context.Rax = Val->i64;
        break;
    case AMD64_RCX:
        m_Context.Amd64Context.Rcx = Val->i64;
        break;
    case AMD64_RDX:
        m_Context.Amd64Context.Rdx = Val->i64;
        break;
    case AMD64_RBX:
        m_Context.Amd64Context.Rbx = Val->i64;
        break;
    case AMD64_RSP:
        m_Context.Amd64Context.Rsp = Val->i64;
        break;
    case AMD64_RBP:
        m_Context.Amd64Context.Rbp = Val->i64;
        break;
    case AMD64_RSI:
        m_Context.Amd64Context.Rsi = Val->i64;
        break;
    case AMD64_RDI:
        m_Context.Amd64Context.Rdi = Val->i64;
        break;
    case AMD64_R8:
        m_Context.Amd64Context.R8 = Val->i64;
        break;
    case AMD64_R9:
        m_Context.Amd64Context.R9 = Val->i64;
        break;
    case AMD64_R10:
        m_Context.Amd64Context.R10 = Val->i64;
        break;
    case AMD64_R11:
        m_Context.Amd64Context.R11 = Val->i64;
        break;
    case AMD64_R12:
        m_Context.Amd64Context.R12 = Val->i64;
        break;
    case AMD64_R13:
        m_Context.Amd64Context.R13 = Val->i64;
        break;
    case AMD64_R14:
        m_Context.Amd64Context.R14 = Val->i64;
        break;
    case AMD64_R15:
        m_Context.Amd64Context.R15 = Val->i64;
        break;
        
    case AMD64_RIP:
        m_Context.Amd64Context.Rip = Val->i64;
        break;
    case AMD64_EFL:
        if (IS_KERNEL_TARGET())
        {
            // leave TF clear
            m_Context.Amd64Context.EFlags = Val->i32 & ~0x100;
        }
        else
        {
            // allow TF set
            m_Context.Amd64Context.EFlags = Val->i32;
        }
        break;
        
    case AMD64_CS:
        m_Context.Amd64Context.SegCs = Val->i16;
        m_SegRegDesc[SEGREG_CODE].Flags = SEGDESC_INVALID;
        break;
    case AMD64_DS:
        m_Context.Amd64Context.SegDs = Val->i16;
        m_SegRegDesc[SEGREG_DATA].Flags = SEGDESC_INVALID;
        break;
    case AMD64_ES:
        m_Context.Amd64Context.SegEs = Val->i16;
        m_SegRegDesc[SEGREG_ES].Flags = SEGDESC_INVALID;
        break;
    case AMD64_FS:
        m_Context.Amd64Context.SegFs = Val->i16;
        m_SegRegDesc[SEGREG_FS].Flags = SEGDESC_INVALID;
        break;
    case AMD64_GS:
        m_Context.Amd64Context.SegGs = Val->i16;
        m_SegRegDesc[SEGREG_GS].Flags = SEGDESC_INVALID;
        break;
    case AMD64_SS:
        m_Context.Amd64Context.SegSs = Val->i16;
        m_SegRegDesc[SEGREG_STACK].Flags = SEGDESC_INVALID;
        break;

    case AMD64_DR0:
        m_Context.Amd64Context.Dr0 = Val->i64;
        break;
    case AMD64_DR1:
        m_Context.Amd64Context.Dr1 = Val->i64;
        break;
    case AMD64_DR2:
        m_Context.Amd64Context.Dr2 = Val->i64;
        break;
    case AMD64_DR3:
        m_Context.Amd64Context.Dr3 = Val->i64;
        break;
    case AMD64_DR6:
        m_Context.Amd64Context.Dr6 = Val->i64;
        break;
    case AMD64_DR7:
        m_Context.Amd64Context.Dr7 = Val->i64;
        break;

    case AMD64_FPCW:
        m_Context.Amd64Context.FltSave.ControlWord = Val->i16;
        break;
    case AMD64_FPSW:
        m_Context.Amd64Context.FltSave.StatusWord = Val->i16;
        break;
    case AMD64_FPTW:
        m_Context.Amd64Context.FltSave.TagWord = Val->i16;
        break;

    case AMD64_MXCSR:
        m_Context.Amd64Context.MxCsr = Val->i32;
        break;
        
    default:
        Recognized = FALSE;
        break;
    }
        
    if (!Recognized && IS_KERNEL_TARGET())
    {
        Recognized = TRUE;
        
        switch(RegNum)
        {
        case AMD64_CR0:
            m_SpecialRegContext.Cr0 = Val->i64;
            break;
        case AMD64_CR2:
            m_SpecialRegContext.Cr2 = Val->i64;
            break;
        case AMD64_CR3:
            m_SpecialRegContext.Cr3 = Val->i64;
            break;
        case AMD64_CR4:
            m_SpecialRegContext.Cr4 = Val->i64;
            break;
#ifdef HAVE_AMD64_CR8
        case AMD64_CR8:
            m_SpecialRegContext.Cr8 = Val->i64;
            break;
#endif
        case AMD64_GDTR:
            m_SpecialRegContext.Gdtr.Base = Val->i64;
            break;
        case AMD64_GDTL:
            m_SpecialRegContext.Gdtr.Limit = Val->i16;
            break;
        case AMD64_IDTR:
            m_SpecialRegContext.Idtr.Base = Val->i64;
            break;
        case AMD64_IDTL:
            m_SpecialRegContext.Idtr.Limit = Val->i16;
            break;
        case AMD64_TR:
            m_SpecialRegContext.Tr = Val->i16;
            break;
        case AMD64_LDTR:
            m_SpecialRegContext.Ldtr = Val->i16;
            break;

        default:
            Recognized = FALSE;
            break;
        }
    }

    if (!Recognized)
    {
        ErrOut("Amd64MachineInfo::SetVal: "
               "unknown register %lx requested\n", RegNum);
        return FALSE;
    }

 Notify:
    NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS,
                              RegCountFromIndex(RegNum));
    return TRUE;
}

void
Amd64MachineInfo::GetPC(PADDR Address)
{
    FormAddr(SEGREG_CODE, GetReg64(AMD64_RIP),
             FORM_CODE | FORM_SEGREG | X86_FORM_VM86(GetReg32(AMD64_EFL)),
             Address);
}

void
Amd64MachineInfo::SetPC(PADDR paddr)
{
    // We set RIP to the offset (the non-translated value),
    // because we may not be in "flat" mode.
    SetReg64(AMD64_RIP, Off(*paddr));
}

void
Amd64MachineInfo::GetFP(PADDR Addr)
{
    FormAddr(SEGREG_STACK, GetReg64(AMD64_RBP),
             FORM_SEGREG | X86_FORM_VM86(GetReg32(AMD64_EFL)), Addr);
}

void
Amd64MachineInfo::GetSP(PADDR Addr)
{
    FormAddr(SEGREG_STACK, GetReg64(AMD64_RSP),
             FORM_SEGREG | X86_FORM_VM86(GetReg32(AMD64_EFL)), Addr);
}

ULONG64
Amd64MachineInfo::GetArgReg(void)
{
    return GetReg64(AMD64_RAX);
}

ULONG
Amd64MachineInfo::GetSegRegNum(ULONG SegReg)
{
    switch(SegReg)
    {
    case SEGREG_CODE:
        return AMD64_CS;
    case SEGREG_DATA:
        return AMD64_DS;
    case SEGREG_STACK:
        return AMD64_SS;
    case SEGREG_ES:
        return AMD64_ES;
    case SEGREG_FS:
        return AMD64_FS;
    case SEGREG_GS:
        return AMD64_GS;
    case SEGREG_LDT:
        return AMD64_LDTR;
    }

    return 0;
}

HRESULT
Amd64MachineInfo::GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc)
{
    if (SegReg == SEGREG_GDT)
    {
        Desc->Base = GetReg64(AMD64_GDTR);
        Desc->Limit = GetReg32(AMD64_GDTL);
        Desc->Flags = 0;
        return S_OK;
    }

    // Check and see if we already have a cached descriptor.
    if (m_SegRegDesc[SegReg].Flags != SEGDESC_INVALID)
    {
        *Desc = m_SegRegDesc[SegReg];
        return S_OK;
    }

    HRESULT Status;

    // Attempt to retrieve segment descriptors directly.
    if ((Status = GetContextState(MCTX_FULL)) != S_OK)
    {
        return Status;
    }

    // Check and see if we now have a cached descriptor.
    if (m_SegRegDesc[SegReg].Flags != SEGDESC_INVALID)
    {
        *Desc = m_SegRegDesc[SegReg];
        return S_OK;
    }

    //
    // Direct information is not available so look things up
    // in the descriptor tables.
    //
    
    ULONG RegNum = GetSegRegNum(SegReg);
    if (RegNum == 0)
    {
        return E_INVALIDARG;
    }

    // Do a quick sanity test to prevent bad values
    // from causing problems.
    ULONG Selector = GetReg32(RegNum);
    if (SegReg == SEGREG_LDT && (Selector & 4))
    {
        // The ldtr selector says that it's an LDT selector,
        // which is invalid.  An LDT selector should always
        // reference the GDT.
        ErrOut("Invalid LDTR contents: %04X\n", Selector);
        return E_FAIL;
    }
        
    return g_Target->GetSelDescriptor(this, g_RegContextThread->Handle,
                                      Selector, Desc);
}

void
Amd64MachineInfo::OutputAll(ULONG Mask, ULONG OutMask)
{
    if (GetContextState(MCTX_FULL) != S_OK)
    {
        ErrOut("Unable to retrieve register information\n");
        return;
    }
    
    if (Mask & (REGALL_INT32 | REGALL_INT64))
    {
        ULONG Efl;

        MaskOut(OutMask, "rax=%016I64x rbx=%016I64x rcx=%016I64x\n",
                GetReg64(AMD64_RAX), GetReg64(AMD64_RBX),
                GetReg64(AMD64_RCX));
        MaskOut(OutMask, "rdx=%016I64x rsi=%016I64x rdi=%016I64x\n",
                GetReg64(AMD64_RDX), GetReg64(AMD64_RSI),
                GetReg64(AMD64_RDI));
        MaskOut(OutMask, "rip=%016I64x rsp=%016I64x rbp=%016I64x\n",
                GetReg64(AMD64_RIP), GetReg64(AMD64_RSP),
                GetReg64(AMD64_RBP));
        MaskOut(OutMask, " r8=%016I64x  r9=%016I64x r10=%016I64x\n",
                GetReg64(AMD64_R8), GetReg64(AMD64_R9),
                GetReg64(AMD64_R10));
        MaskOut(OutMask, "r11=%016I64x r12=%016I64x r13=%016I64x\n",
                GetReg64(AMD64_R11), GetReg64(AMD64_R12),
                GetReg64(AMD64_R13));
        MaskOut(OutMask, "r14=%016I64x r15=%016I64x\n",
                GetReg64(AMD64_R14), GetReg64(AMD64_R15));

        Efl = GetReg32(AMD64_EFL);
        MaskOut(OutMask, "iopl=%1lx %s %s %s %s %s %s %s %s %s %s\n",
                ((Efl >> X86_SHIFT_FLAGIOPL) & X86_BIT_FLAGIOPL),
                (Efl & X86_BIT_FLAGVIP) ? "vip" : "   ",
                (Efl & X86_BIT_FLAGVIF) ? "vif" : "   ",
                (Efl & X86_BIT_FLAGOF) ? "ov" : "nv",
                (Efl & X86_BIT_FLAGDF) ? "dn" : "up",
                (Efl & X86_BIT_FLAGIF) ? "ei" : "di",
                (Efl & X86_BIT_FLAGSF) ? "ng" : "pl",
                (Efl & X86_BIT_FLAGZF) ? "zr" : "nz",
                (Efl & X86_BIT_FLAGAF) ? "ac" : "na",
                (Efl & X86_BIT_FLAGPF) ? "po" : "pe",
                (Efl & X86_BIT_FLAGCF) ? "cy" : "nc");
    }

    if (Mask & REGALL_SEGREG)
    {
        MaskOut(OutMask, "cs=%04lx  ss=%04lx  ds=%04lx  es=%04lx  fs=%04lx  "
                "gs=%04lx             efl=%08lx\n",
                GetReg32(AMD64_CS),
                GetReg32(AMD64_SS),
                GetReg32(AMD64_DS),
                GetReg32(AMD64_ES),
                GetReg32(AMD64_FS),
                GetReg32(AMD64_GS),
                GetReg32(AMD64_EFL));
    }

    if (Mask & REGALL_FLOAT)
    {
        ULONG i;
        REGVAL Val;
        char Buf[32];

        MaskOut(OutMask, "fpcw=%04X    fpsw=%04X    fptw=%04X\n",
                GetReg32(AMD64_FPCW),
                GetReg32(AMD64_FPSW),
                GetReg32(AMD64_FPTW));

        for (i = AMD64_ST_FIRST; i <= AMD64_ST_LAST; i++)
        {
            GetVal(i, &Val);
            _uldtoa((_ULDOUBLE *)&Val.f10, sizeof(Buf), Buf);
            MaskOut(OutMask, "st%d=%s  ", i - AMD64_ST_FIRST, Buf);
            i++;
            GetVal(i, &Val);
            _uldtoa((_ULDOUBLE *)&Val.f10, sizeof(Buf), Buf);
            MaskOut(OutMask, "st%d=%s\n", i - AMD64_ST_FIRST, Buf);
        }
    }

    if (Mask & REGALL_MMXREG)
    {
        ULONG i;
        REGVAL Val;

        for (i = AMD64_MM_FIRST; i <= AMD64_MM_LAST; i++)
        {
            GetVal(i, &Val);
            MaskOut(OutMask, "mm%d=%016I64x  ", i - AMD64_MM_FIRST, Val.i64);
            i++;
            GetVal(i, &Val);
            MaskOut(OutMask, "mm%d=%016I64x\n", i - AMD64_MM_FIRST, Val.i64);
        }
    }

    if (Mask & REGALL_XMMREG)
    {
        ULONG i;
        REGVAL Val;

        for (i = AMD64_XMM_FIRST; i <= AMD64_XMM_LAST; i++)
        {
            GetVal(i, &Val);
            MaskOut(OutMask, "xmm%d=%hg %hg %hg %hg\n", i - AMD64_XMM_FIRST,
                    *(float *)&Val.bytes[3 * sizeof(float)],
                    *(float *)&Val.bytes[2 * sizeof(float)],
                    *(float *)&Val.bytes[1 * sizeof(float)],
                    *(float *)&Val.bytes[0 * sizeof(float)]);
        }
    }

    if (Mask & REGALL_CREG)
    {
        MaskOut(OutMask, "cr0=%016I64x cr2=%016I64x cr3=%016I64x\n",
                GetReg64(AMD64_CR0),
                GetReg64(AMD64_CR2),
                GetReg64(AMD64_CR3));
#ifdef HAVE_AMD64_CR8
        MaskOut(OutMask, "cr8=%016I64x\n",
                GetReg64(AMD64_CR8));
#endif
    }

    if (Mask & REGALL_DREG)
    {
        MaskOut(OutMask, "dr0=%016I64x dr1=%016I64x dr2=%016I64x\n",
                GetReg64(AMD64_DR0),
                GetReg64(AMD64_DR1),
                GetReg64(AMD64_DR2));
        MaskOut(OutMask, "dr3=%016I64x dr6=%016I64x dr7=%016I64x",
                GetReg64(AMD64_DR3),
                GetReg64(AMD64_DR6),
                GetReg64(AMD64_DR7));
        if (IS_USER_TARGET())
        {
            MaskOut(OutMask, "\n");
        }
        else
        {
            MaskOut(OutMask, " cr4=%016I64x\n", GetReg64(AMD64_CR4));
        }
    }

    if (Mask & REGALL_DESC)
    {
        MaskOut(OutMask, "gdtr=%016I64x   gdtl=%04lx idtr=%016I64x   "
                "idtl=%04lx tr=%04lx  ldtr=%04x\n",
                GetReg64(AMD64_GDTR),
                GetReg32(AMD64_GDTL),
                GetReg64(AMD64_IDTR),
                GetReg32(AMD64_IDTL),
                GetReg32(AMD64_TR),
                GetReg32(AMD64_LDTR));
    }
}

TRACEMODE
Amd64MachineInfo::GetTraceMode (void)
{
    if (IS_KERNEL_TARGET())
    {
        return m_TraceMode;
    }
    else
    {
        return ((GetReg32(AMD64_EFL) & X86_BIT_FLAGTF) != 0) ? 
                   TRACE_INSTRUCTION : TRACE_NONE;
    }
}

void 
Amd64MachineInfo::SetTraceMode (TRACEMODE Mode)
{
    // (XXX olegk - review for TRACE_TAKEN_BRANCH)
    DBG_ASSERT(Mode != TRACE_TAKEN_BRANCH);

    if (IS_KERNEL_TARGET())
    {
        m_TraceMode = Mode;
    }
    else
    {
        ULONG Efl = GetReg32(AMD64_EFL);
        switch (Mode)
        {
        case TRACE_NONE:
            Efl &= ~X86_BIT_FLAGTF;
            break;
        case TRACE_INSTRUCTION:
            Efl |= X86_BIT_FLAGTF;
            break;
        }   
        SetReg32(AMD64_EFL, Efl);
    }
}

BOOL
Amd64MachineInfo::IsStepStatusSupported(ULONG Status)
{
    switch (Status) 
    {
    case DEBUG_STATUS_STEP_INTO:
    case DEBUG_STATUS_STEP_OVER:
        return TRUE;
    default:
        return FALSE;
    }
}

void
Amd64MachineInfo::KdUpdateControlSet
    (PDBGKD_ANY_CONTROL_SET ControlSet)
{
    ControlSet->Amd64ControlSet.TraceFlag = 
        (GetTraceMode() == TRACE_INSTRUCTION);
    ControlSet->Amd64ControlSet.Dr7 = GetReg64(AMD64_DR7);

    BpOut("UpdateControlSet(%d) trace %d, DR7 %I64X\n",
          g_RegContextProcessor, ControlSet->Amd64ControlSet.TraceFlag,
          ControlSet->Amd64ControlSet.Dr7);
    
    if (!g_WatchFunctions.IsStarted() && g_WatchBeginCurFunc != 1)
    {
        ControlSet->Amd64ControlSet.CurrentSymbolStart = 0;
        ControlSet->Amd64ControlSet.CurrentSymbolEnd = 0;
    }
    else
    {
        ControlSet->Amd64ControlSet.CurrentSymbolStart = g_WatchBeginCurFunc;
        ControlSet->Amd64ControlSet.CurrentSymbolEnd = g_WatchEndCurFunc;
    }
}

void
Amd64MachineInfo::KdSaveProcessorState(void)
{
    MachineInfo::KdSaveProcessorState();
    m_SavedSpecialRegContext = m_SpecialRegContext;
}

void
Amd64MachineInfo::KdRestoreProcessorState(void)
{
    MachineInfo::KdRestoreProcessorState();
    m_SpecialRegContext = m_SavedSpecialRegContext;
}

ULONG
Amd64MachineInfo::ExecutingMachine(void)
{
    return IMAGE_FILE_MACHINE_AMD64;
}

HRESULT
Amd64MachineInfo::SetPageDirectory(ULONG Idx, ULONG64 PageDir,
                                   PULONG NextIdx)
{
    HRESULT Status;
    
    *NextIdx = PAGE_DIR_COUNT;
    
    if (PageDir == 0)
    {
        if ((Status = g_Target->ReadImplicitProcessInfoPointer
             (m_OffsetEprocessDirectoryTableBase, &PageDir)) != S_OK)
        {
            return Status;
        }
    }

    // Sanitize the value.
    PageDir &= AMD64_PDBR_MASK;

    // There is only one page directory so update all the slots.
    m_PageDirectories[PAGE_DIR_USER] = PageDir;
    m_PageDirectories[PAGE_DIR_SESSION] = PageDir;
    m_PageDirectories[PAGE_DIR_KERNEL] = PageDir;
    
    return S_OK;
}

#define AMD64_PAGE_FILE_INDEX(Entry) \
    (((ULONG)(Entry) >> 28) & MAX_PAGING_FILE_MASK)
#define AMD64_PAGE_FILE_OFFSET(Entry) \
    (((Entry) >> 32) << AMD64_PAGE_SHIFT)

HRESULT
Amd64MachineInfo::GetVirtualTranslationPhysicalOffsets(ULONG64 Virt,
                                                       PULONG64 Offsets,
                                                       ULONG OffsetsSize,
                                                       PULONG Levels,
                                                       PULONG PfIndex,
                                                       PULONG64 LastVal)
{
    HRESULT Status;
    
    *Levels = 0;
    
    if (m_Translating)
    {
        return E_UNEXPECTED;
    }
    m_Translating = TRUE;
    
    //
    // Reset the page directory in case it was 0
    //
    if (m_PageDirectories[PAGE_DIR_SINGLE] == 0)
    {
        if ((Status = SetDefaultPageDirectories(1 << PAGE_DIR_SINGLE)) != S_OK)
        {
            m_Translating = FALSE;
            return Status;
        }
    }
    
    KdOut("Amd64VtoP: Virt %s, pagedir %s\n",
          FormatAddr64(Virt),
          FormatDisp64(m_PageDirectories[PAGE_DIR_SINGLE]));
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = m_PageDirectories[PAGE_DIR_SINGLE];
        OffsetsSize--;
    }
        
    //
    // Certain ranges of the system are mapped directly.
    //

    if ((Virt >= AMD64_PHYSICAL_START) && (Virt <= AMD64_PHYSICAL_END))
    {
        *LastVal = Virt - AMD64_PHYSICAL_START;

        KdOut("Amd64VtoP: Direct phys %s\n", FormatAddr64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }

        m_Translating = FALSE;
        return S_OK;
    }
    
    ULONG64 Addr;
    ULONG64 Entry;

    // Read the Page Map Level 4 entry.
    
    Addr = (((Virt >> AMD64_PML4E_SHIFT) & AMD64_PML4E_MASK) *
            sizeof(Entry)) + m_PageDirectories[PAGE_DIR_SINGLE];

    KdOut("Amd64VtoP: PML4E %s\n", FormatAddr64(Addr));
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = Addr;
        OffsetsSize--;
    }

    if ((Status = g_Target->
         ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
    {
        KdOut("Amd64VtoP: PML4E read error 0x%X\n", Status);
        m_Translating = FALSE;
        return Status;
    }

    // Read the Page Directory Pointer entry.
    
    if (Entry == 0)
    {
        KdOut("Amd64VtoP: zero PML4E\n");
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
    else if (!(Entry & 1))
    {
        Addr = (((Virt >> AMD64_PDPE_SHIFT) & AMD64_PDPE_MASK) *
                sizeof(Entry)) + AMD64_PAGE_FILE_OFFSET(Entry);

        KdOut("Amd64VtoP: pagefile PDPE %d:%s\n",
              AMD64_PAGE_FILE_INDEX(Entry), FormatAddr64(Addr));
        
        if ((Status = g_Target->
             ReadPageFile(AMD64_PAGE_FILE_INDEX(Entry), Addr,
                          &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Amd64VtoP: PML4E not present, 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    else
    {
        Addr = (((Virt >> AMD64_PDPE_SHIFT) & AMD64_PDPE_MASK) *
                sizeof(Entry)) + (Entry & AMD64_VALID_PFN_MASK);

        KdOut("Amd64VtoP: PDPE %s\n", FormatAddr64(Addr));
        
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }

        if ((Status = g_Target->
             ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Amd64VtoP: PDPE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    
    // Read the Page Directory entry.
        
    if (Entry == 0)
    {
        KdOut("Amd64VtoP: zero PDPE\n");
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
    else if (!(Entry & 1))
    {
        Addr = (((Virt >> AMD64_PDE_SHIFT) & AMD64_PDE_MASK) *
                sizeof(Entry)) + AMD64_PAGE_FILE_OFFSET(Entry);

        KdOut("Amd64VtoP: pagefile PDE %d:%s\n",
              AMD64_PAGE_FILE_INDEX(Entry), FormatAddr64(Addr));
        
        if ((Status = g_Target->
             ReadPageFile(AMD64_PAGE_FILE_INDEX(Entry), Addr,
                          &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Amd64VtoP: PDPE not present, 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    else
    {
        Addr = (((Virt >> AMD64_PDE_SHIFT) & AMD64_PDE_MASK) *
                sizeof(Entry)) + (Entry & AMD64_VALID_PFN_MASK);

        KdOut("Amd64VtoP: PDE %s\n", FormatAddr64(Addr));
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }

        if ((Status = g_Target->
             ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Amd64VtoP: PDE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    
    // Check for a large page.  Large pages can
    // never be paged out so also check for the present bit.
    if ((Entry & (AMD64_LARGE_PAGE_MASK | 1)) == (AMD64_LARGE_PAGE_MASK | 1))
    {
        *LastVal = ((Entry & ~(AMD64_LARGE_PAGE_SIZE - 1)) |
                     (Virt & (AMD64_LARGE_PAGE_SIZE - 1)));
            
        KdOut("Amd64VtoP: Large page mapped phys %s\n",
              FormatAddr64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }

        m_Translating = FALSE;
        return S_OK;
    }
        
    // Read the Page Table entry.

    if (Entry == 0)
    {
        KdOut("Amd64VtoP: zero PDE\n");
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
    else if (!(Entry & 1))
    {
        Addr = (((Virt >> AMD64_PTE_SHIFT) & AMD64_PTE_MASK) *
                sizeof(Entry)) + AMD64_PAGE_FILE_OFFSET(Entry);

        KdOut("Amd64VtoP: pagefile PTE %d:%s\n",
              AMD64_PAGE_FILE_INDEX(Entry), FormatAddr64(Addr));
        
        if ((Status = g_Target->
             ReadPageFile(AMD64_PAGE_FILE_INDEX(Entry), Addr,
                          &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Amd64VtoP: PDE not present, 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    else
    {
        Addr = (((Virt >> AMD64_PTE_SHIFT) & AMD64_PTE_MASK) *
                sizeof(Entry)) + (Entry & AMD64_VALID_PFN_MASK);

        KdOut("Amd64VtoP: PTE %s\n", FormatAddr64(Addr));
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }

        if ((Status = g_Target->
             ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Amd64VtoP: PTE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    
    if (!(Entry & 0x1) &&
        ((Entry & AMD64_MM_PTE_PROTOTYPE_MASK) ||
         !(Entry & AMD64_MM_PTE_TRANSITION_MASK)))
    {
        if (Entry == 0)
        {
            KdOut("Amd64VtoP: zero PTE\n");
            Status = HR_PAGE_NOT_AVAILABLE;
        }
        else if (Entry & AMD64_MM_PTE_PROTOTYPE_MASK)
        {
            KdOut("Amd64VtoP: prototype PTE\n");
            Status = HR_PAGE_NOT_AVAILABLE;
        }
        else
        {
            *PfIndex = AMD64_PAGE_FILE_INDEX(Entry);
            *LastVal = (Virt & (AMD64_PAGE_SIZE - 1)) +
                AMD64_PAGE_FILE_OFFSET(Entry);
            KdOut("Amd64VtoP: PTE not present, pagefile %d:%s\n",
                  *PfIndex, FormatAddr64(*LastVal));
            Status = HR_PAGE_IN_PAGE_FILE;
        }
        m_Translating = FALSE;
        return Status;
    }

    *LastVal = ((Entry & AMD64_VALID_PFN_MASK) |
                 (Virt & (AMD64_PAGE_SIZE - 1)));
    
    KdOut("Amd64VtoP: Mapped phys %s\n", FormatAddr64(*LastVal));

    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = *LastVal;
        OffsetsSize--;
    }

    m_Translating = FALSE;
    return S_OK;
}

HRESULT
Amd64MachineInfo::GetBaseTranslationVirtualOffset(PULONG64 Offset)
{
    *Offset = AMD64_BASE_VIRT;
    return S_OK;
}
 
BOOL 
Amd64MachineInfo::DisplayTrapFrame(ULONG64 FrameAddress,
                                   PCROSS_PLATFORM_CONTEXT Context)
{
    ErrOut("DisplayTrapFrame not implemented\n");
    return FALSE;
}

void
Amd64MachineInfo::ValidateCxr(PCROSS_PLATFORM_CONTEXT Context)
{
    // XXX drewb - Not implemented.
}

void
Amd64MachineInfo::OutputFunctionEntry(PVOID RawEntry)
{
    _PIMAGE_RUNTIME_FUNCTION_ENTRY Entry =
        (_PIMAGE_RUNTIME_FUNCTION_ENTRY)RawEntry;
    
    dprintf("BeginAddress      = %s\n",
            FormatAddr64(Entry->BeginAddress));
    dprintf("EndAddress        = %s\n",
            FormatAddr64(Entry->EndAddress));
    dprintf("UnwindInfoAddress = %s\n",
            FormatAddr64(Entry->UnwindInfoAddress));
}

HRESULT
Amd64MachineInfo::ReadDynamicFunctionTable(ULONG64 Table,
                                           PULONG64 NextTable,
                                           PULONG64 MinAddress,
                                           PULONG64 MaxAddress,
                                           PULONG64 BaseAddress,
                                           PULONG64 TableData,
                                           PULONG TableSize,
                                           PWSTR OutOfProcessDll,
                                           PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable)
{
    HRESULT Status;

    if ((Status = g_Target->
         ReadAllVirtual(Table, &RawTable->Amd64Table,
                        sizeof(RawTable->Amd64Table))) != S_OK)
    {
        return Status;
    }

    *NextTable = RawTable->Amd64Table.ListEntry.Flink;
    *MinAddress = RawTable->Amd64Table.MinimumAddress;
    *MaxAddress = RawTable->Amd64Table.MaximumAddress;
    *BaseAddress = RawTable->Amd64Table.BaseAddress;
    if (RawTable->Amd64Table.Type == AMD64_RF_CALLBACK)
    {
        ULONG Done;
        
        *TableData = 0;
        *TableSize = 0;
        if ((Status = g_Target->
             ReadVirtual(RawTable->Amd64Table.OutOfProcessCallbackDll,
                         OutOfProcessDll, (MAX_PATH - 1) * sizeof(WCHAR),
                         &Done)) != S_OK)
        {
            return Status;
        }

        OutOfProcessDll[Done / sizeof(WCHAR)] = 0;
    }
    else
    {
        *TableData = RawTable->Amd64Table.FunctionTable;
        *TableSize = RawTable->Amd64Table.EntryCount *
            sizeof(_IMAGE_RUNTIME_FUNCTION_ENTRY);
        OutOfProcessDll[0] = 0;
    }
    return S_OK;
}

PVOID
Amd64MachineInfo::FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                           ULONG64 Address,
                                           PVOID TableData,
                                           ULONG TableSize)
{
    ULONG i;
    _PIMAGE_RUNTIME_FUNCTION_ENTRY Func;
    static _IMAGE_RUNTIME_FUNCTION_ENTRY s_RetFunc;

    Func = (_PIMAGE_RUNTIME_FUNCTION_ENTRY)TableData;
    for (i = 0; i < TableSize / sizeof(_IMAGE_RUNTIME_FUNCTION_ENTRY); i++)
    {
        if (Address >= Table->Amd64Table.BaseAddress + Func->BeginAddress &&
            Address < Table->Amd64Table.BaseAddress + Func->EndAddress)
        {
            // The table data is temporary so copy the data into
            // a static buffer for longer-term storage.
            s_RetFunc.BeginAddress = Func->BeginAddress;
            s_RetFunc.EndAddress = Func->EndAddress;
            s_RetFunc.UnwindInfoAddress = Func->UnwindInfoAddress;
            return (PVOID)&s_RetFunc;
        }

        Func++;
    }

    return NULL;
}

HRESULT
Amd64MachineInfo::ReadKernelProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    HRESULT Status;
    ULONG64 Prcb, PrcbMember;
    ULONG Data;

    if ((Status = g_Target->
         GetProcessorSystemDataOffset(Processor, DEBUG_DATA_KPRCB_OFFSET,
                                      &Prcb)) != S_OK)
    {
        return Status;
    }

    PrcbMember = Prcb + FIELD_OFFSET(AMD64_PARTIAL_KPRCB, CpuType);

    if ((Status = g_Target->
         ReadAllVirtual(PrcbMember, &Data, sizeof(Data))) != S_OK)
    {
        return Status;
    }

    Id->Amd64.Family = Data & 0xf;
    Id->Amd64.Model = (Data >> 24) & 0xf;
    Id->Amd64.Stepping = (Data >> 16) & 0xf;
    
    PrcbMember = Prcb + FIELD_OFFSET(AMD64_PARTIAL_KPRCB, VendorString);

    if ((Status = g_Target->
         ReadAllVirtual(PrcbMember, Id->Amd64.VendorString,
                        sizeof(Id->Amd64.VendorString))) != S_OK)
    {
        return Status;
    }

    return S_OK;
}

void
Amd64MachineInfo::KdGetSpecialRegistersFromContext(void)
{
    DBG_ASSERT(m_ContextState >= MCTX_FULL);
    
    m_SpecialRegContext.KernelDr0 = m_Context.Amd64Context.Dr0;
    m_SpecialRegContext.KernelDr1 = m_Context.Amd64Context.Dr1;
    m_SpecialRegContext.KernelDr2 = m_Context.Amd64Context.Dr2;
    m_SpecialRegContext.KernelDr3 = m_Context.Amd64Context.Dr3;
    m_SpecialRegContext.KernelDr6 = m_Context.Amd64Context.Dr6;
    m_SpecialRegContext.KernelDr7 = m_Context.Amd64Context.Dr7;
}

void
Amd64MachineInfo::KdSetSpecialRegistersInContext(void)
{
    DBG_ASSERT(m_ContextState >= MCTX_FULL);
    
    m_Context.Amd64Context.Dr0 = m_SpecialRegContext.KernelDr0;
    m_Context.Amd64Context.Dr1 = m_SpecialRegContext.KernelDr1;
    m_Context.Amd64Context.Dr2 = m_SpecialRegContext.KernelDr2;
    m_Context.Amd64Context.Dr3 = m_SpecialRegContext.KernelDr3;
    m_Context.Amd64Context.Dr6 = m_SpecialRegContext.KernelDr6;
    m_Context.Amd64Context.Dr7 = m_SpecialRegContext.KernelDr7;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\amd64_reg.h ===
//----------------------------------------------------------------------------
//
// AMD64 register definitions.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#ifndef __AMD64_REG_H__
#define __AMD64_REG_H__

//
// x86 common registers.
//

#define	AMD64_RAX		X86_NAX
#define	AMD64_RCX	        X86_NCX
#define	AMD64_RDX		X86_NDX
#define	AMD64_RBX		X86_NBX
#define	AMD64_RSP		X86_NSP
#define	AMD64_RBP		X86_NBP
#define	AMD64_RSI		X86_NSI
#define	AMD64_RDI	        X86_NDI
#define	AMD64_RIP		X86_NIP

#define	AMD64_EFL		X86_NFL

#define	AMD64_CS		X86_NCS
#define	AMD64_DS		X86_NDS
#define	AMD64_ES		X86_NES
#define	AMD64_FS		X86_NFS
#define	AMD64_GS	        X86_NGS
#define	AMD64_SS		X86_NSS

#define AMD64_SEG_FIRST         X86_NSEG_FIRST
#define AMD64_SEG_LAST          X86_NSEG_LAST

//
// AMD64 registers.
//

#define AMD64_R8                17
#define AMD64_R9                18
#define AMD64_R10               19
#define AMD64_R11               20
#define AMD64_R12               21
#define AMD64_R13               22
#define AMD64_R14               23
#define AMD64_R15               24

#define AMD64_CR0		25
#define AMD64_CR2		26
#define AMD64_CR3		27
#define AMD64_CR4               28
#define AMD64_CR8               29

#define AMD64_DR0               30
#define AMD64_DR1               31
#define AMD64_DR2               32
#define AMD64_DR3               33
#define AMD64_DR6               34
#define AMD64_DR7               35

#define AMD64_GDTR              36
#define AMD64_GDTL              37
#define AMD64_IDTR              38
#define AMD64_IDTL              39
#define AMD64_TR                40
#define AMD64_LDTR              41

// Floating-point registers:
#define AMD64_FPCW              50
#define AMD64_FPSW              51
#define AMD64_FPTW              52

#define AMD64_FPCTRL_FIRST      AMD64_FPCW
#define AMD64_FPCTRL_LAST       AMD64_FPTW

#define AMD64_ST0               53
#define AMD64_ST1               54
#define AMD64_ST2               55
#define AMD64_ST3               56
#define AMD64_ST4               57
#define AMD64_ST5               58
#define AMD64_ST6               59
#define AMD64_ST7               60

#define AMD64_ST_FIRST          AMD64_ST0
#define AMD64_ST_LAST           AMD64_ST7

// MMX registers:
#define AMD64_MM0               61
#define AMD64_MM1               62
#define AMD64_MM2               63
#define AMD64_MM3               64
#define AMD64_MM4               65
#define AMD64_MM5               66
#define AMD64_MM6               67
#define AMD64_MM7               68

#define AMD64_MM_FIRST          AMD64_MM0
#define AMD64_MM_LAST           AMD64_MM7

// SSE registers:
#define AMD64_MXCSR             69

#define AMD64_XMM0              70
#define AMD64_XMM1              71
#define AMD64_XMM2              72
#define AMD64_XMM3              73
#define AMD64_XMM4              74
#define AMD64_XMM5              75
#define AMD64_XMM6              76
#define AMD64_XMM7              77
#define AMD64_XMM8              78
#define AMD64_XMM9              79
#define AMD64_XMM10             80
#define AMD64_XMM11             81
#define AMD64_XMM12             82
#define AMD64_XMM13             83
#define AMD64_XMM14             84
#define AMD64_XMM15             85

#define AMD64_XMM_FIRST         AMD64_XMM0
#define AMD64_XMM_LAST          AMD64_XMM15

#define	AMD64_EAX		100
#define	AMD64_ECX		101
#define	AMD64_EDX		102
#define	AMD64_EBX		103
#define	AMD64_ESP		104
#define	AMD64_EBP		105
#define	AMD64_ESI		106
#define	AMD64_EDI		107
#define AMD64_R8D               108
#define AMD64_R9D               109
#define AMD64_R10D              110
#define AMD64_R11D              111
#define AMD64_R12D              112
#define AMD64_R13D              113
#define AMD64_R14D              114
#define AMD64_R15D              115
#define	AMD64_EIP		116

#define	AMD64_AX		117
#define	AMD64_CX		118
#define	AMD64_DX		119
#define	AMD64_BX		120
#define	AMD64_SP		121
#define	AMD64_BP		122
#define	AMD64_SI		123
#define	AMD64_DI		124
#define AMD64_R8W               125
#define AMD64_R9W               126
#define AMD64_R10W              127
#define AMD64_R11W              128
#define AMD64_R12W              129
#define AMD64_R13W              130
#define AMD64_R14W              131
#define AMD64_R15W              132
#define	AMD64_IP		133
#define	AMD64_FL		134

#define	AMD64_AL		135
#define	AMD64_CL		136
#define	AMD64_DL		137
#define	AMD64_BL		138
#define AMD64_SPL               139
#define AMD64_BPL               140
#define AMD64_SIL               141
#define AMD64_DIL               142
#define AMD64_R8B               143
#define AMD64_R9B               144
#define AMD64_R10B              145
#define AMD64_R11B              146
#define AMD64_R12B              147
#define AMD64_R13B              148
#define AMD64_R14B              149
#define AMD64_R15B              150

#define	AMD64_AH		151
#define	AMD64_CH		152
#define	AMD64_DH		153
#define	AMD64_BH		154

#define	AMD64_IOPL              200
#define	AMD64_OF		201
#define	AMD64_DF		202
#define	AMD64_IF		203
#define	AMD64_TF		204
#define	AMD64_SF		205
#define	AMD64_ZF		206
#define	AMD64_AF		207
#define AMD64_PF		208
#define AMD64_CF		209
#define AMD64_VIP               210
#define AMD64_VIF               211

#define	AMD64_SUBREG_BASE       AMD64_EAX

#endif // #ifndef __AMD64_AMD64_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\amd64_dis.cpp ===
//----------------------------------------------------------------------------
//
// Disassembly portions of AMD64 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

// See Get/SetRegVal comments in machine.hpp.
#define RegValError Do_not_use_GetSetRegVal_in_machine_implementations
#define GetRegVal(index, val)   RegValError
#define GetRegVal32(index)      RegValError
#define GetRegVal64(index)      RegValError
#define SetRegVal(index, val)   RegValError
#define SetRegVal32(index, val) RegValError
#define SetRegVal64(index, val) RegValError

#define BIT20(b) ((b) & 0x07)
#define BIT53(b) (((b) >> 3) & 0x07)
#define BIT76(b) (((b) >> 6) & 0x03)

HRESULT
Amd64MachineInfo::NewBreakpoint(DebugClient* Client, 
                                ULONG Type,
                                ULONG Id,
                                Breakpoint** RetBp)
{
    HRESULT Status;

    switch(Type & (DEBUG_BREAKPOINT_CODE | DEBUG_BREAKPOINT_DATA))
    {
    case DEBUG_BREAKPOINT_CODE:
        *RetBp = new CodeBreakpoint(Client, Id, IMAGE_FILE_MACHINE_AMD64);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;
        break;
    case DEBUG_BREAKPOINT_DATA:
        *RetBp = new X86DataBreakpoint(Client, Id, AMD64_CR4, AMD64_DR6, IMAGE_FILE_MACHINE_AMD64);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;
        break;
    default:
        // Unknown breakpoint type.
        Status = E_NOINTERFACE;
    }

    return Status;
}

void
Amd64MachineInfo::InsertAllDataBreakpoints(void)
{
    PPROCESS_INFO ProcessSave = g_CurrentProcess;
    PTHREAD_INFO Thread;

    // Update thread context for every thread.

    g_CurrentProcess = g_ProcessHead;
    while (g_CurrentProcess != NULL)
    {
        Thread = g_CurrentProcess->ThreadHead;
        while (Thread != NULL)
        {
            ULONG64 Dr7Value;

            BpOut("Thread %d data breaks %d\n",
                  Thread->UserId, Thread->NumDataBreaks);

            ChangeRegContext(Thread);
            
            // Start with all breaks turned off.
            Dr7Value = GetReg64(AMD64_DR7) & ~X86_DR7_CTRL_03_MASK;
    
            if (Thread->NumDataBreaks > 0)
            {
                ULONG i;
                
                for (i = 0; i < Thread->NumDataBreaks; i++)
                {
                    X86DataBreakpoint* Bp =
                        (X86DataBreakpoint *)Thread->DataBreakBps[i];
                    
                    ULONG64 Addr = Flat(*Bp->GetAddr());
                    BpOut("  dbp %d at %I64x\n", i, Addr);
                    if (g_DataBreakpointsChanged)
                    {
                        SetReg64(AMD64_DR0 + i, Addr);
                    }
                    // There are two enable bits per breakpoint
                    // and four len/rw bits so split up enables
                    // and len/rw when shifting into place.
                    Dr7Value |=
                        ((Bp->m_Dr7Bits & 0xffff0000) << (i * 4)) |
                        ((Bp->m_Dr7Bits & X86_DR7_ALL_ENABLES) << (i * 2));
                }

                // The kernel automatically clears DR6 when it
                // processes a DBGKD_CONTROL_SET.
                if (IS_USER_TARGET())
                {
                    SetReg64(AMD64_DR6, 0);
                }
                
                // Set local exact match, which is effectively global on NT.
                Dr7Value |= X86_DR7_LOCAL_EXACT_ENABLE;
            }

            BpOut("  thread %d DR7 %I64X\n", Thread->UserId, Dr7Value);
            SetReg64(AMD64_DR7, Dr7Value);

            Thread = Thread->Next;
        }
        
        g_CurrentProcess = g_CurrentProcess->Next;
    }
    
    g_CurrentProcess = ProcessSave;
    if (g_CurrentProcess != NULL)
    {
        ChangeRegContext(g_CurrentProcess->CurrentThread);
    }
    else
    {
        ChangeRegContext(NULL);
    }
}

void
Amd64MachineInfo::RemoveAllDataBreakpoints(void)
{
    SetReg64(AMD64_DR7, 0);
}

ULONG
Amd64MachineInfo::IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                              ULONG FirstChance,
                                              PADDR BpAddr,
                                              PADDR RelAddr)
{
    if (Record->ExceptionCode == STATUS_BREAKPOINT)
    {
        // Data breakpoints hit as STATUS_SINGLE_STEP so
        // this can only be a code breakpoint.
        if (IS_USER_TARGET() && FirstChance)
        {
            // Back up to the actual breakpoint instruction.
            AddrSub(BpAddr, X86_INT3_LEN);
            SetPC(BpAddr);
        }
        return EXBS_BREAKPOINT_CODE;
    }
    else if (Record->ExceptionCode == STATUS_SINGLE_STEP)
    {
        ULONG64 Dr6 = GetReg64(AMD64_DR6);
        ULONG64 Dr7 = GetReg64(AMD64_DR7);

        BpOut("Amd64 step: DR6 %I64X, DR7 %I64X\n", Dr6, Dr7);

        // The single step bit should always be set if a data breakpoint
        // is hit but also check the DR7 enables just in case.
        if ((Dr6 & X86_DR6_SINGLE_STEP) || (Dr7 & X86_DR7_ALL_ENABLES) == 0)
        {
            // This is a true single step exception, not
            // a data breakpoint.
            return EXBS_STEP_INSTRUCTION;
        }
        else
        {
            // Some data breakpoint must be hit.
            DBG_ASSERT(Dr6 & X86_DR6_BREAK_03);
            // There doesn't appear to be any way
            // to get the faulting address so just leave the PC.
            return EXBS_BREAKPOINT_DATA;
        }
    }

    return EXBS_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\amd64_mach.hpp ===
//----------------------------------------------------------------------------
//
// AMD64 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#ifndef __AMD64_MACH_HPP__
#define __AMD64_MACH_HPP__

//
// NOTE: Be very careful when using machine-specific header files
// such as nt<plat>.h.  The machine implementation class is
// compiled for all platforms so the nt<plat>.h file will be the
// one for the build platform, not necessarily the platform
// of the machine implementation.  ntdbg.h contains many cross-platform
// types and definitions that can be used to avoid problems.
//

#define AMD64_MAX_INSTRUCTION_LEN 16

class Amd64MachineInfo : public BaseX86MachineInfo
{
public:
    // MachineInfo.
    virtual HRESULT InitializeConstants(void);
    virtual HRESULT InitializeForTarget(void);
    
    virtual void InitializeContext
        (ULONG64 Pc, PDBGKD_ANY_CONTROL_REPORT ControlReport);
    virtual HRESULT KdGetContextState(ULONG State);
    virtual HRESULT KdSetContext(void);
    virtual HRESULT ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                       ULONG FromSver,
                                       ULONG FromSize, PVOID From);
    virtual HRESULT ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                     ULONG ToSver, ULONG ToSize, PVOID To);
    virtual void InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                        ULONG Version);
    virtual HRESULT GetContextFromThreadStack(ULONG64 ThreadBase,
                                              PCROSS_PLATFORM_THREAD Thread,
                                              PCROSS_PLATFORM_CONTEXT Context,
                                              PDEBUG_STACK_FRAME Frame,
                                              PULONG RunningOnProc);
    
    virtual HRESULT GetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context);
    virtual HRESULT SetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context);
    virtual void ConvertExdiContextFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                               PEXDI_CONTEXT ExdiContext);
    virtual void ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                             PCROSS_PLATFORM_CONTEXT Context);
    virtual void ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                              ULONG Start, ULONG Count,
                                              PDESCRIPTOR64 Descs);
    virtual void ConvertExdiContextFromSpecial
        (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
         PEXDI_CONTEXT ExdiContext);
    virtual void ConvertExdiContextToSpecial
        (PEXDI_CONTEXT ExdiContext,
         PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
    
    virtual int  GetType(ULONG index);
    virtual BOOL GetVal(ULONG index, REGVAL *val);
    virtual BOOL SetVal(ULONG index, REGVAL *val);

    virtual void GetPC(PADDR Address);
    virtual void SetPC(PADDR Address);
    virtual void GetFP(PADDR Address);
    virtual void GetSP(PADDR Address);
    virtual ULONG64 GetArgReg(void);
    virtual ULONG GetSegRegNum(ULONG SegReg);
    virtual HRESULT GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc);

    virtual void OutputAll(ULONG Mask, ULONG OutMask);

    virtual TRACEMODE GetTraceMode(void);
    virtual void SetTraceMode(TRACEMODE Mode);
    virtual BOOL IsStepStatusSupported(ULONG Status);

    virtual void KdUpdateControlSet
        (PDBGKD_ANY_CONTROL_SET ControlSet);

    virtual void KdSaveProcessorState(void);
    virtual void KdRestoreProcessorState(void);

    virtual ULONG ExecutingMachine(void);

    virtual HRESULT SetPageDirectory(ULONG Idx, ULONG64 PageDir,
                                     PULONG NextIdx);
    virtual HRESULT GetVirtualTranslationPhysicalOffsets
        (ULONG64 Virt, PULONG64 Offsets, ULONG OffsetsSize,
         PULONG Levels, PULONG PfIndex, PULONG64 LastVal);
    virtual HRESULT GetBaseTranslationVirtualOffset(PULONG64 Offset);

    virtual HRESULT NewBreakpoint(DebugClient* Client, 
                                  ULONG Type, 
                                  ULONG Id, 
                                  Breakpoint** RetBp);

    virtual void InsertAllDataBreakpoints(void);
    virtual void RemoveAllDataBreakpoints(void);
    virtual ULONG IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                              ULONG FirstChance,
                                              PADDR BpAddr, 
                                              PADDR RelAddr);
    
    virtual BOOL DisplayTrapFrame(ULONG64 FrameAddress,
                                  PCROSS_PLATFORM_CONTEXT Context);
    virtual void ValidateCxr(PCROSS_PLATFORM_CONTEXT Context);

    virtual void OutputFunctionEntry(PVOID RawEntry);
    virtual HRESULT ReadDynamicFunctionTable(ULONG64 Table,
                                             PULONG64 NextTable,
                                             PULONG64 MinAddress,
                                             PULONG64 MaxAddress,
                                             PULONG64 BaseAddress,
                                             PULONG64 TableData,
                                             PULONG TableSize,
                                             PWSTR OutOfProcessDll,
                                             PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable);
    virtual PVOID FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                           ULONG64 Address,
                                           PVOID TableData,
                                           ULONG TableSize);

    virtual HRESULT ReadKernelProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id);

    // Amd64MachineInfo.
protected:
    AMD64_KSPECIAL_REGISTERS m_SpecialRegContext, m_SavedSpecialRegContext;

    void KdGetSpecialRegistersFromContext(void);
    void KdSetSpecialRegistersInContext(void);
};

extern Amd64MachineInfo g_Amd64Machine;

extern BOOL g_Amd64InCode64;

#endif // #ifndef __AMD64_MACH_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\brkpt.cpp ===
//----------------------------------------------------------------------------
//
// Breakpoint handling functions.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

// Currently used only to watch for list changes when
// doing callbacks for breakpoint hit notifications.
BOOL g_BreakpointListChanged;

// Always update data breakpoints the very first time in
// order to flush out any stale data breakpoints.
BOOL g_UpdateDataBreakpoints = TRUE;
BOOL g_DataBreakpointsChanged;
BOOL g_BreakpointsSuspended;

Breakpoint* g_StepTraceBp;      // Trace breakpoint.
CHAR g_StepTraceCmdState;
Breakpoint* g_DeferBp;          // Deferred breakpoint.
BOOL g_DeferDefined;            // TRUE if deferred breakpoint is active.

Breakpoint* g_LastBreakpointHit;
ADDR g_LastBreakpointHitPc;
ADDR g_PrevRelatedPc;

HRESULT
BreakpointInit(void)
{
    // These breakpoints are never put in any list so their
    // IDs can be anything.  Pick unusual numbers to make them
    // easy to identify when debugging the debugger.
    g_StepTraceBp = new
        CodeBreakpoint(NULL, 0xffff0000, IMAGE_FILE_MACHINE_UNKNOWN);
    g_StepTraceCmdState = 't';
    g_DeferBp = new
        CodeBreakpoint(NULL, 0xffff0001, IMAGE_FILE_MACHINE_UNKNOWN);
    if (g_StepTraceBp == NULL ||
        g_DeferBp == NULL)
    {
        ErrOut("Unable to allocate private breakpoints\n");
        delete g_StepTraceBp;
        g_StepTraceBp = NULL;
        delete g_DeferBp;
        g_DeferBp = NULL;
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
// Breakpoint.
//
//----------------------------------------------------------------------------

Breakpoint::Breakpoint(DebugClient* Adder, ULONG Id, ULONG Type,
                       ULONG ProcType)
{
    m_Next = NULL;
    m_Prev = NULL;
    m_Id = Id;
    m_BreakType = Type;
    // Breakpoints are always created disabled since they
    // are not initialized at the time of creation.
    m_Flags = 0;
    ADDRFLAT(&m_Addr, 0);
    // Initial data parameters must be set to something
    // valid so that Validate calls will allow the offset
    // to be changed.
    m_DataSize = 1;
    m_DataAccessType = DEBUG_BREAK_EXECUTE;
    m_PassCount = 1;
    m_CurPassCount = 1;
    m_CommandLen = 0;
    m_Command = NULL;
    m_MatchThread = NULL;
    m_Process = g_CurrentProcess;
    m_OffsetExprLen = 0;
    m_OffsetExpr = NULL;
    m_Adder = Adder;
    m_MatchThreadData = 0;
    m_MatchProcessData = 0;

    SetProcType(ProcType);

    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        g_DataBreakpointsChanged = TRUE;
    }
}

Breakpoint::~Breakpoint(void)
{
    // There used to be an assert here checking that
    // the inserted flag wasn't set before a breakpoint
    // structure was deleted.  However, the inserted flag
    // might still be set at this point if a breakpoint
    // restore failed, so the assert is not valid.

    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        g_DataBreakpointsChanged = TRUE;
    }

    if (this == g_LastBreakpointHit) 
    {
        g_LastBreakpointHit = NULL;
    }

    // Take this item out of the list if necessary.
    if (m_Flags & BREAKPOINT_IN_LIST)
    {
        UnlinkFromList();
    }

    delete [] (PSTR)m_Command;
    delete [] (PSTR)m_OffsetExpr;
}

STDMETHODIMP
Breakpoint::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    // Interface specific casts are necessary in order to
    // get the right vtable pointer in our multiple
    // inheritance scheme.
    if (DbgIsEqualIID(InterfaceId, IID_IUnknown) ||
        DbgIsEqualIID(InterfaceId, IID_IDebugBreakpoint))
    {
        *Interface = (IDebugBreakpoint *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
Breakpoint::AddRef(
    THIS
    )
{
    // This object's lifetime is not controlled by
    // the interface.
    return 1;
}

STDMETHODIMP_(ULONG)
Breakpoint::Release(
    THIS
    )
{
    // This object's lifetime is not controlled by
    // the interface.
    return 0;
}

STDMETHODIMP
Breakpoint::GetId(
    THIS_
    OUT PULONG Id
    )
{
    ENTER_ENGINE();

    *Id = m_Id;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::GetType(
    THIS_
    OUT PULONG BreakType,
    OUT PULONG ProcType
    )
{
    ENTER_ENGINE();

    *BreakType = m_BreakType;
    *ProcType = m_ProcType;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::GetAdder(
    THIS_
    OUT PDEBUG_CLIENT* Adder
    )
{
    ENTER_ENGINE();

    *Adder = (PDEBUG_CLIENT)m_Adder;
    m_Adder->AddRef();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::GetFlags(
    THIS_
    OUT PULONG Flags
    )
{
    ENTER_ENGINE();

    *Flags = m_Flags & BREAKPOINT_EXTERNAL_FLAGS;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::AddFlags(
    THIS_
    IN ULONG Flags
    )
{
    if (Flags & ~BREAKPOINT_EXTERNAL_MODIFY_FLAGS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    m_Flags |= Flags;

    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        g_DataBreakpointsChanged = TRUE;
    }

    UpdateInternal();
    NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, m_Id, TRUE);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::RemoveFlags(
    THIS_
    IN ULONG Flags
    )
{
    if (Flags & ~BREAKPOINT_EXTERNAL_MODIFY_FLAGS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    m_Flags &= ~Flags;

    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        g_DataBreakpointsChanged = TRUE;
    }

    UpdateInternal();
    NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, m_Id, TRUE);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::SetFlags(
    THIS_
    IN ULONG Flags
    )
{
    if (Flags & ~BREAKPOINT_EXTERNAL_MODIFY_FLAGS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    m_Flags = (m_Flags & ~BREAKPOINT_EXTERNAL_MODIFY_FLAGS) |
        (Flags & BREAKPOINT_EXTERNAL_MODIFY_FLAGS);

    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        g_DataBreakpointsChanged = TRUE;
    }

    UpdateInternal();
    NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, m_Id, TRUE);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::GetOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    if (m_Flags & DEBUG_BREAKPOINT_DEFERRED)
    {
        return E_NOINTERFACE;
    }

    ENTER_ENGINE();

    *Offset = Flat(m_Addr);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::SetOffset(
    THIS_
    IN ULONG64 Offset
    )
{
    if (m_Flags & DEBUG_BREAKPOINT_DEFERRED)
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    ADDR Addr;
    HRESULT Status;

    ADDRFLAT(&Addr, Offset);
    Status = SetAddr(&Addr, BREAKPOINT_WARN_MATCH);
    if (Status == S_OK)
    {
        NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, m_Id, TRUE);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::GetDataParameters(
    THIS_
    OUT PULONG Size,
    OUT PULONG AccessType
    )
{
    if (m_BreakType != DEBUG_BREAKPOINT_DATA)
    {
        return E_NOINTERFACE;
    }

    ENTER_ENGINE();

    *Size = m_DataSize;
    *AccessType = m_DataAccessType;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::SetDataParameters(
    THIS_
    IN ULONG Size,
    IN ULONG AccessType
    )
{
    if (m_BreakType != DEBUG_BREAKPOINT_DATA)
    {
        return E_NOINTERFACE;
    }

    ENTER_ENGINE();

    ULONG OldSize = m_DataSize;
    ULONG OldAccess = m_DataAccessType;
    HRESULT Status;

    m_DataSize = Size;
    m_DataAccessType = AccessType;
    Status = Validate();
    if (Status != S_OK)
    {
        m_DataSize = OldSize;
        m_DataAccessType = OldAccess;
    }
    else
    {
        g_DataBreakpointsChanged = TRUE;
        NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, m_Id, TRUE);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::GetPassCount(
    THIS_
    OUT PULONG Count
    )
{
    ENTER_ENGINE();

    *Count = m_PassCount;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::SetPassCount(
    THIS_
    IN ULONG Count
    )
{
    ENTER_ENGINE();

    m_PassCount = Count;
    m_CurPassCount = Count;
    NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, m_Id, TRUE);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::GetCurrentPassCount(
    THIS_
    OUT PULONG Count
    )
{
    ENTER_ENGINE();

    *Count = m_CurPassCount;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
Breakpoint::GetMatchThreadId(
    THIS_
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (m_MatchThread)
    {
        *Id = m_MatchThread->UserId;
        Status = S_OK;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::SetMatchThreadId(
    THIS_
    IN ULONG Id
    )
{
    if (IS_KERNEL_TARGET() &&
        m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        ErrOut("Kernel data breakpoints cannot be limited to a processor\n");
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    PTHREAD_INFO Thread = FindThreadByUserId(NULL, Id);
    if (Thread != NULL)
    {
        m_MatchThread = Thread;
        NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, m_Id, TRUE);
        Status = S_OK;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::GetCommand(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG CommandSize
    )
{
    ENTER_ENGINE();

    HRESULT Status = FillStringBuffer(m_Command, m_CommandLen,
                                      Buffer, BufferSize, CommandSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::SetCommand(
    THIS_
    IN PCSTR Command
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = ChangeString((PSTR*)&m_Command, &m_CommandLen, Command);
    if (Status == S_OK)
    {
        NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, m_Id, TRUE);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::GetOffsetExpression(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG ExpressionSize
    )
{
    ENTER_ENGINE();

    HRESULT Status = FillStringBuffer(m_OffsetExpr, m_OffsetExprLen,
                                      Buffer, BufferSize, ExpressionSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::SetOffsetExpression(
    THIS_
    IN PCSTR Expression
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = ChangeString((PSTR*)&m_OffsetExpr, &m_OffsetExprLen, Expression);
    if (Status == S_OK)
    {
        if (Expression != NULL)
        {
            // Do initial evaluation in case the expression can be
            // resolved right away.  This will also set the deferred
            // flag if the expression can't be evaluated.
            EvalOffsetExpr();
        }
        else
        {
            // This breakpoint is no longer deferred since there's
            // no way to activate it later any more.
            m_Flags &= ~DEBUG_BREAKPOINT_DEFERRED;
            UpdateInternal();
        }

        NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, m_Id, TRUE);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
Breakpoint::GetParameters(
    THIS_
    OUT PDEBUG_BREAKPOINT_PARAMETERS Params
    )
{
    ENTER_ENGINE();

    if (m_Flags & DEBUG_BREAKPOINT_DEFERRED)
    {
        Params->Offset = DEBUG_INVALID_OFFSET;
    }
    else
    {
        Params->Offset = Flat(m_Addr);
    }
    Params->Id = m_Id;
    Params->BreakType = m_BreakType;
    Params->ProcType = m_ProcType;
    Params->Flags = m_Flags & BREAKPOINT_EXTERNAL_FLAGS;
    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        Params->DataSize = m_DataSize;
        Params->DataAccessType = m_DataAccessType;
    }
    else
    {
        Params->DataSize = 0;
        Params->DataAccessType = 0;
    }
    Params->PassCount = m_PassCount;
    Params->CurrentPassCount = m_CurPassCount;
    Params->MatchThread = m_MatchThread != NULL ?
        m_MatchThread->UserId : DEBUG_ANY_ID;
    Params->CommandSize = m_CommandLen;
    Params->OffsetExpressionSize = m_OffsetExprLen;

    LEAVE_ENGINE();
    return S_OK;
}

void
Breakpoint::LinkIntoList(void)
{
    Breakpoint* NextBp;
    Breakpoint* PrevBp;

    DBG_ASSERT((m_Flags & BREAKPOINT_IN_LIST) == 0);

    // Link into list sorted by ID.
    PrevBp = NULL;
    for (NextBp = m_Process->Breakpoints;
         NextBp != NULL;
         NextBp = NextBp->m_Next)
    {
        if (m_Id < NextBp->m_Id)
        {
            break;
        }

        PrevBp = NextBp;
    }

    m_Prev = PrevBp;
    if (PrevBp == NULL)
    {
        m_Process->Breakpoints = this;
    }
    else
    {
        PrevBp->m_Next = this;
    }
    m_Next = NextBp;
    if (NextBp == NULL)
    {
        m_Process->BreakpointsTail = this;
    }
    else
    {
        NextBp->m_Prev = this;
    }

    m_Flags |= BREAKPOINT_IN_LIST;
    m_Process->NumBreakpoints++;
    g_BreakpointListChanged = TRUE;
}

void
Breakpoint::UnlinkFromList(void)
{
    DBG_ASSERT(m_Flags & BREAKPOINT_IN_LIST);

    if (m_Prev == NULL)
    {
        m_Process->Breakpoints = m_Next;
    }
    else
    {
        m_Prev->m_Next = m_Next;
    }
    if (m_Next == NULL)
    {
        m_Process->BreakpointsTail = m_Prev;
    }
    else
    {
        m_Next->m_Prev = m_Prev;
    }

    m_Flags &= ~BREAKPOINT_IN_LIST;
    m_Process->NumBreakpoints--;
    g_BreakpointListChanged = TRUE;
}

void
Breakpoint::UpdateInternal(void)
{
    // This only has an effect with internal breakpoints.
    if ((m_Flags & BREAKPOINT_KD_INTERNAL) == 0)
    {
        return;
    }

    // If the breakpoint is ready turn it on, otherwise
    // turn it off.
    ULONG Flags;

    if ((m_Flags & (DEBUG_BREAKPOINT_ENABLED |
                    DEBUG_BREAKPOINT_DEFERRED)) == DEBUG_BREAKPOINT_ENABLED)
    {
        Flags = (m_Flags & BREAKPOINT_KD_COUNT_ONLY) ?
            DBGKD_INTERNAL_BP_FLAG_COUNTONLY : 0;
    }
    else
    {
        Flags = DBGKD_INTERNAL_BP_FLAG_INVALID;
    }

    BpOut("Set internal bp at %s to %X\n",
          FormatAddr64(Flat(m_Addr)), Flags);

    DbgKdSetInternalBp(Flat(m_Addr), Flags);
}

enum
{
    EVAL_RESOLVED,
    EVAL_RESOLVED_NO_MODULE,
    EVAL_UNRESOLVED,
    EVAL_ERROR
};

ULONG
EvalAddrExpression(PPROCESS_INFO Process, ULONG Machine, PADDR Addr)
{
    BOOL Error = FALSE;

    // This function can be reentered if evaluating an
    // expression causes symbol changes which provoke
    // reevaluation of existing address expressions.
    // Save away current settings to support nesting.
    BOOL OldAllow = g_AllowUnresolvedSymbols;
    ULONG OldNum = g_NumUnresolvedSymbols;
    ULONG NumUn;
    PPROCESS_INFO OldProcess = g_CurrentProcess;
    
    // Evaluate the expression in the context of the breakpoint's
    // machine type so that registers and such are available.
    ULONG OldMachine = g_EffMachine;
    SetEffMachine(Machine, FALSE);
    
    g_AllowUnresolvedSymbols = TRUE;
    g_NumUnresolvedSymbols = 0;
    g_CurrentProcess = Process;

    __try
    {
        GetAddrExpression(SEGREG_CODE, Addr);
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        Error = TRUE;
    }

    NumUn = g_NumUnresolvedSymbols;
    SetEffMachine(OldMachine, FALSE);
    g_AllowUnresolvedSymbols = OldAllow;
    g_NumUnresolvedSymbols = OldNum;
    g_CurrentProcess = OldProcess;

    if (Error)
    {
        return EVAL_ERROR;
    }
    else if (NumUn > 0)
    {
        return EVAL_UNRESOLVED;
    }
    else
    {
        PDEBUG_IMAGE_INFO Image;

        // Check if this address falls within an existing module.
        for (Image = Process->ImageHead;
             Image != NULL;
             Image = Image->Next)
        {
            if (Flat(*Addr) >= Image->BaseOfImage &&
                Flat(*Addr) < Image->BaseOfImage + Image->SizeOfImage)
            {
                return EVAL_RESOLVED;
            }
        }

        return EVAL_RESOLVED_NO_MODULE;
    }
}

BOOL
Breakpoint::EvalOffsetExpr(void)
{
    ADDR Addr;
    PSTR CurCommand = g_CurCmd;
    ULONG OldFlags = m_Flags;
    ULONG Valid;

    DBG_ASSERT(m_OffsetExpr != NULL);

    g_CurCmd = (PSTR)m_OffsetExpr;
    g_DisableErrorPrint = TRUE;
    g_PrefixSymbols = TRUE;

    Valid = EvalAddrExpression(m_Process, m_ProcType, &Addr);

    g_PrefixSymbols = FALSE;
    g_DisableErrorPrint = FALSE;
    g_CurCmd = CurCommand;

    // Silently allow matching breakpoints when resolving
    // as it is difficult for the expression setter to know
    // whether there'll be matches or not at the time
    // the expression is set.
    if (Valid == EVAL_RESOLVED)
    {
        m_Flags &= ~DEBUG_BREAKPOINT_DEFERRED;

        if (SetAddr(&Addr, BREAKPOINT_ALLOW_MATCH) != S_OK)
        {
            m_Flags |= DEBUG_BREAKPOINT_DEFERRED;
        }
    }
    else
    {
        m_Flags |= DEBUG_BREAKPOINT_DEFERRED;
        // The module containing the breakpoint is being
        // unloaded so just mark this breakpoint as not-inserted.
        m_Flags &= ~BREAKPOINT_INSERTED;
    }

    if ((OldFlags ^ m_Flags) & DEBUG_BREAKPOINT_DEFERRED)
    {
        // Update internal BP status.
        UpdateInternal();

        if (m_Flags & DEBUG_BREAKPOINT_DEFERRED)
        {
            BpOut("Deferring %d '%s'\n", m_Id, m_OffsetExpr);
        }
        else
        {
            BpOut("Enabling deferred %d '%s' at %s\n",
                  m_Id, m_OffsetExpr, FormatAddr64(Flat(m_Addr)));
        }

        return TRUE;
    }

    return FALSE;
}

HRESULT
Breakpoint::SetAddr(PADDR Addr, BreakpointMatchAction MatchAction)
{
    if (m_Flags & DEBUG_BREAKPOINT_DEFERRED)
    {
        // Address is unknown.
        return S_OK;
    }

    // Lock the breakpoint processor type to the
    // type of the module containing it.
    ULONG ProcType = m_ProcType;
    if (m_BreakType == DEBUG_BREAKPOINT_CODE)
    {
        ProcType = ModuleMachineType(m_Process, Flat(*Addr));
        if (ProcType == IMAGE_FILE_MACHINE_UNKNOWN)
        {
            ProcType = m_ProcType;
        }
    }
    
    if (m_Flags & BREAKPOINT_VIRT_ADDR)
    {
        if (ProcType == IMAGE_FILE_MACHINE_AXP64)
        {
            PIMAGE_FUNCTION_ENTRY64 FunctionEntry;
            FunctionEntry = (PIMAGE_FUNCTION_ENTRY64)
                SymFunctionTableAccess64( m_Process->Handle,
                                          Flat(*Addr) );
            if (FunctionEntry != NULL)
            {
                if ( (Flat(*Addr) >= FunctionEntry->StartingAddress) &&
                     (Flat(*Addr) < FunctionEntry->EndOfPrologue))
                {
                    ADDRFLAT(Addr, FunctionEntry->EndOfPrologue & -4I64 );
                }
            }
        }
        else if (ProcType == IMAGE_FILE_MACHINE_ALPHA)
        {
            PIMAGE_FUNCTION_ENTRY FunctionEntry;
            FunctionEntry = (PIMAGE_FUNCTION_ENTRY)
                SymFunctionTableAccess64( m_Process->Handle,
                                          Flat(*Addr) );
            if (FunctionEntry != NULL)
            {
                if ( (Flat(*Addr) >= FunctionEntry->StartingAddress) &&
                     (Flat(*Addr) < FunctionEntry->EndOfPrologue))
                {
                    ADDRFLAT(Addr, FunctionEntry->EndOfPrologue & -4);
                }
            }
        }
    }

    ADDR OldAddr = m_Addr;
    HRESULT Valid;

    m_Addr = *Addr;

    Valid = Validate();
    if (Valid != S_OK)
    {
        m_Addr = OldAddr;
        return Valid;
    }

    if (ProcType != m_ProcType)
    {
        SetProcType(ProcType);
    }
    
    if (m_BreakType == DEBUG_BREAKPOINT_DATA)
    {
        g_DataBreakpointsChanged = TRUE;
    }

    if (MatchAction == BREAKPOINT_ALLOW_MATCH)
    {
        return S_OK;
    }

    for (;;)
    {
        Breakpoint* MatchBp;

        MatchBp = CheckMatchingBreakpoints(this, TRUE, 0xffffffff);
        if (MatchBp == NULL)
        {
            break;
        }

        if (MatchAction == BREAKPOINT_REMOVE_MATCH)
        {
            ULONG MoveId;

            WarnOut("breakpoint %ld redefined\n", MatchBp->m_Id);
            // Move breakpoint towards lower IDs.
            if (MatchBp->m_Id < m_Id)
            {
                MoveId = MatchBp->m_Id;
            }
            else
            {
                MoveId = DEBUG_ANY_ID;
            }

            RemoveBreakpoint(MatchBp);

            if (MoveId != DEBUG_ANY_ID)
            {
                // Take over the removed ID.
                UnlinkFromList();
                m_Id = MoveId;
                LinkIntoList();
            }
        }
        else
        {
            WarnOut("Breakpoints %d and %d match\n",
                    m_Id, MatchBp->m_Id);
            break;
        }
    }

    return S_OK;
}

#define INSERTION_MATCH_FLAGS \
    (BREAKPOINT_KD_INTERNAL | BREAKPOINT_VIRT_ADDR)

BOOL
Breakpoint::IsInsertionMatch(Breakpoint* Match)
{
    if ((m_Flags & DEBUG_BREAKPOINT_DEFERRED) ||
        (Match->m_Flags & DEBUG_BREAKPOINT_DEFERRED) ||
        m_BreakType != Match->m_BreakType ||
        ((m_Flags ^ Match->m_Flags) & INSERTION_MATCH_FLAGS) ||
        !AddrEqu(m_Addr, Match->m_Addr) ||
        m_Process != Match->m_Process ||
        (m_BreakType == DEBUG_BREAKPOINT_DATA &&
         m_MatchThread != Match->m_MatchThread))
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

#define PUBLIC_MATCH_FLAGS \
    (BREAKPOINT_HIDDEN | DEBUG_BREAKPOINT_ADDER_ONLY)

BOOL
Breakpoint::IsPublicMatch(Breakpoint* Match)
{
    if (!IsInsertionMatch(Match) ||
        m_ProcType != Match->m_ProcType ||
        ((m_Flags ^ Match->m_Flags) & PUBLIC_MATCH_FLAGS) ||
        ((m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) &&
         m_Adder != Match->m_Adder) ||
        m_MatchThread != Match->m_MatchThread ||
        m_MatchThreadData != Match->m_MatchThreadData ||
        m_MatchProcessData != Match->m_MatchProcessData)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL
Breakpoint::MatchesCurrentState(void)
{
    HRESULT Status;
    ULONG64 ThreadData = 0, ProcData = 0;

    // If querying the current state fails go ahead
    // and return a match so that the breakpoint will
    // break as often as possible.
    if (m_MatchThreadData)
    {
        if ((Status = g_Target->
             GetThreadInfoDataOffset(g_EventThread, 0, &ThreadData)) != S_OK)
        {
            ErrOut("Unable to determine current thread data, %s\n",
                   FormatStatusCode(Status));
            return TRUE;
        }
    }
    if (m_MatchProcessData)
    {
        if ((Status = g_Target->
             GetProcessInfoDataOffset(g_EventThread, 0, 0, &ProcData)) != S_OK)
        {
            ErrOut("Unable to determine current process data, %s\n",
                   FormatStatusCode(Status));
            return TRUE;
        }
    }
    
    return
        (m_MatchThread == NULL ||
         m_MatchThread == g_EventThread) &&
        m_MatchThreadData == ThreadData &&
        m_MatchProcessData == ProcData;
}

//----------------------------------------------------------------------------
//
// CodeBreakpoint.
//
//----------------------------------------------------------------------------

HRESULT
CodeBreakpoint::Validate(void)
{
    // No easy way to check for validity of offset.
    return S_OK;
}

HRESULT
CodeBreakpoint::Insert(void)
{
    if (m_Flags & BREAKPOINT_INSERTED)
    {
        // Nothing to insert.  This can happen in cases where
        // the breakpoint remove failed.
        return S_OK;
    }

    HRESULT Status;

    DBG_ASSERT((m_Flags & (DEBUG_BREAKPOINT_DEFERRED |
                           BREAKPOINT_KD_INTERNAL)) == 0);

    // Force recomputation of flat address.
    NotFlat(m_Addr);
    ComputeFlatAddress(&m_Addr, NULL);

    Status = g_Target->InsertCodeBreakpoint(m_Process,
                                            g_AllMachines[m_ProcIndex],
                                            &m_Addr,
                                            m_InsertStorage);
    if (Status == S_OK)
    {
        BpOut("  inserted bp %d at %s\n",
              m_Id, FormatAddr64(Flat(m_Addr)));

        m_Flags |= BREAKPOINT_INSERTED;
        return S_OK;
    }
    else
    {
        ErrOut("Unable to write breakpoint %d at %s, 0x%X\n",
               m_Id, FormatAddr64(Flat(m_Addr)), Status);
        return Status;
    }
}

HRESULT
CodeBreakpoint::Remove(void)
{
    if ((m_Flags & BREAKPOINT_INSERTED) == 0)
    {
        // Nothing to remove.  This can happen in cases where
        // the breakpoint insertion failed.
        return S_OK;
    }

    HRESULT Status;

    DBG_ASSERT((m_Flags & (DEBUG_BREAKPOINT_DEFERRED |
                           BREAKPOINT_KD_INTERNAL)) == 0);

    // Force recomputation of flat address.
    NotFlat(m_Addr);
    ComputeFlatAddress(&m_Addr, NULL);

    Status = g_Target->RemoveCodeBreakpoint(m_Process,
                                            g_AllMachines[m_ProcIndex],
                                            &m_Addr,
                                            m_InsertStorage);
    if (Status == S_OK)
    {
        BpOut("  removed bp %d from %s\n",
              m_Id, FormatAddr64(Flat(m_Addr)));

        m_Flags &= ~BREAKPOINT_INSERTED;
        return S_OK;
    }
    else
    {
        ErrOut("Unable to restore breakpoint %d at %s, 0x%X\n",
               m_Id, FormatAddr64(Flat(m_Addr)), Status);
        return Status;
    }
}

ULONG
CodeBreakpoint::IsHit(PADDR Addr)
{
    // Code breakpoints are code modifications and
    // therefore aren't restricted to a particular
    // thread.
    // If this breakpoint can only match hits on
    // a particular thread this is a partial hit
    // because the exception occurred but it's
    // being ignored.
    if (AddrEqu(m_Addr, *Addr))
    {
        if (MatchesCurrentState())
        {
            return BREAKPOINT_HIT;
        }
        else
        {
            return BREAKPOINT_HIT_IGNORED;
        }
    }
    else
    {
        return BREAKPOINT_NOT_HIT;
    }
}

//----------------------------------------------------------------------------
//
// DataBreakpoint.
//
//----------------------------------------------------------------------------

HRESULT
DataBreakpoint::Insert(void)
{
    PTHREAD_INFO Thread;

    DBG_ASSERT((m_Flags & (BREAKPOINT_INSERTED |
                           DEBUG_BREAKPOINT_DEFERRED)) == 0);

    // Force recomputation of flat address for non-I/O breakpoints.
    if (m_Flags & BREAKPOINT_VIRT_ADDR)
    {
        NotFlat(m_Addr);
        ComputeFlatAddress(&m_Addr, NULL);
    }

    // If this breakpoint is restricted to a thread
    // only modify that thread's state.  Otherwise
    // update all threads in the process.
    Thread = m_Process->ThreadHead;
    while (Thread)
    {
        if (Thread->NumDataBreaks >= g_Machine->m_MaxDataBreakpoints)
        {
            ErrOut("Too many data breakpoints for %s %d\n",
                   IS_KERNEL_TARGET() ? "processor" : "thread",
                   Thread->UserId);
            return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        }
        else if (m_MatchThread == NULL || m_MatchThread == Thread)
        {
            BpOut("Add %s data bp %d to thread %d\n",
                  g_AllMachines[m_ProcIndex]->m_AbbrevName,
                  m_Id, Thread->UserId);

            AddToThread(Thread);
        }

        Thread = Thread->Next;
    }

    g_UpdateDataBreakpoints = TRUE;
    m_Flags |= BREAKPOINT_INSERTED;

    return S_OK;
}

HRESULT
DataBreakpoint::Remove(void)
{
    if ((m_Flags & BREAKPOINT_INSERTED) == 0)
    {
        // Nothing to remove.  This can happen in cases where
        // the breakpoint insertion failed.
        return S_OK;
    }
    
    DBG_ASSERT((m_Flags & DEBUG_BREAKPOINT_DEFERRED) == 0);

    // When breakpoints are inserted the data breakpoint state
    // is always started completely empty to no special
    // work needs to be done when removing.
    g_UpdateDataBreakpoints = TRUE;
    m_Flags &= ~BREAKPOINT_INSERTED;
    return S_OK;
}

void
DataBreakpoint::ClearThreadDataBreaks(PTHREAD_INFO Thread)
{
    Thread->NumDataBreaks = 0;
    memset(Thread->DataBreakBps, 0, sizeof(Thread->DataBreakBps));
}

void
DataBreakpoint::AddToThread(PTHREAD_INFO Thread)
{
    DBG_ASSERT(Thread->NumDataBreaks < g_Machine->m_MaxDataBreakpoints);

    Thread->DataBreakBps[Thread->NumDataBreaks] = this;
    Thread->NumDataBreaks++;
}

//----------------------------------------------------------------------------
//
// X86DataBreakpoint.
//
//----------------------------------------------------------------------------

HRESULT
X86DataBreakpoint::Validate(void)
{
    ULONG Dr7Bits;
    ULONG Align;

    if (!IsPow2(m_DataSize) || m_DataSize == 0 || m_DataSize > 4)
    {
        ErrOut("Unsupported data breakpoint size\n");
        return E_INVALIDARG;
    }

    Align = (ULONG)(Flat(m_Addr) & (m_DataSize - 1));
    if (Align != 0)
    {
        ErrOut("Data breakpoint must be aligned\n");
        return E_INVALIDARG;
    }

    Dr7Bits = (m_DataSize - 1) << X86_DR7_LEN0_SHIFT;
    switch(m_DataAccessType)
    {
    case DEBUG_BREAK_EXECUTE:
        Dr7Bits |= X86_DR7_RW0_EXECUTE;
        // Code execution breakpoints must have a
        // size of one.
        // They must also be at the beginning
        // of an instruction.  This could be checked via
        // examining the instructions but it doesn't seem
        // that worth the trouble.
        if (m_DataSize > 1)
        {
            ErrOut("Execution data breakpoint too large\n");
            return E_INVALIDARG;
        }
        break;
    case DEBUG_BREAK_WRITE:
        Dr7Bits |= X86_DR7_RW0_WRITE;
        break;
    case DEBUG_BREAK_IO:
        if (IS_USER_TARGET() ||
            !(GetRegVal32(m_Cr4Reg) & X86_CR4_DEBUG_EXTENSIONS))
        {
            ErrOut("I/O breakpoints not enabled\n");
            return E_INVALIDARG;
        }
        if (Flat(m_Addr) > 0xffff)
        {
            ErrOut("I/O breakpoint port too large\n");
            return E_INVALIDARG;
        }

        Dr7Bits |= X86_DR7_RW0_IO;
        break;
    case DEBUG_BREAK_READ:
    case DEBUG_BREAK_READ | DEBUG_BREAK_WRITE:
        // There is no pure read-only option so
        // lump it in with read-write.
        Dr7Bits |= X86_DR7_RW0_READ_WRITE;
        break;
    default:
        ErrOut("Unsupported data breakpoint access type\n");
        return E_INVALIDARG;
    }

    m_Dr7Bits = Dr7Bits | X86_DR7_L0_ENABLE;
    if (m_DataAccessType == DEBUG_BREAK_IO)
    {
        m_Flags &= ~BREAKPOINT_VIRT_ADDR;
    }
    else
    {
        m_Flags |= BREAKPOINT_VIRT_ADDR;
    }

    return S_OK;
}

ULONG
X86DataBreakpoint::IsHit(PADDR Addr)
{
    ULONG i;
    PTHREAD_INFO Thread = g_EventThread;

    // Data breakpoints are only active on particular
    // threads so if the event thread doesn't match
    // the breakpoint can't be hit.
    if (!MatchesCurrentState())
    {
        return BREAKPOINT_NOT_HIT;
    }

    // Locate this breakpoint in the thread's data breakpoints
    // if possible.
    for (i = 0; i < Thread->NumDataBreaks; i++)
    {
        // Check for match in addition to equality to handle
        // multiple identical data breakpoints.
        if (Thread->DataBreakBps[i] == this ||
            IsInsertionMatch(Thread->DataBreakBps[i]))
        {
            // Is this breakpoint's index set in the debug status register?
            // Address is not meaningful so this is the only way to check.
            if ((GetRegVal32(m_Dr6Reg) >> i) & 1)
            {
                return BREAKPOINT_HIT;
            }
            else
            {
                // Breakpoint can't be listed in more than one slot
                // so there's no need to finish the loop.
                return BREAKPOINT_NOT_HIT;
            }
        }
    }

    return BREAKPOINT_NOT_HIT;
}

//----------------------------------------------------------------------------
//
// Ia64DataBreakpoint.
//
//----------------------------------------------------------------------------

HRESULT
Ia64DataBreakpoint::Validate(void)
{
    if (!IsPow2(m_DataSize)) 
    {
        ErrOut("Hardware breakpoint size must be power of 2\n");
        return E_INVALIDARG;
    }

    if (Flat(m_Addr) & (m_DataSize - 1))
    {
        ErrOut("Hardware breakpoint must be size aligned\n");
        return E_INVALIDARG;
    }

    switch (m_DataAccessType)
    {
    case DEBUG_BREAK_WRITE: 
    case DEBUG_BREAK_READ:
    case DEBUG_BREAK_READ | DEBUG_BREAK_WRITE:
        break;
    case DEBUG_BREAK_EXECUTE:
        if (m_DataSize & 0xf) 
        {
            if (m_DataSize > 0xf)
            {
                ErrOut("Execution breakpoint size must be bundle aligned.\n");
                return E_INVALIDARG;
            }
            else
            {
                WarnOut("Execution breakpoint size extended to bundle size "
                          "(16 bytes).\n");
                m_DataSize = 0x10;
            }
        }
        break;
    default:
        ErrOut("Unsupported data breakpoint access type\n");
        return E_INVALIDARG;
    } 

    m_Control = GetControl(m_DataAccessType, m_DataSize);
    m_Flags |= BREAKPOINT_VIRT_ADDR;

    return S_OK;
}

ULONG
Ia64DataBreakpoint::IsHit(PADDR Addr)
{
    ULONG i;
    PTHREAD_INFO Thread = g_EventThread;

    // Data breakpoints are only active on particular
    // threads so if the event thread doesn't match
    // the breakpoint can't be hit.
    if (m_MatchThread != NULL && m_MatchThread != Thread)
    {
        return BREAKPOINT_NOT_HIT;
    }

    // Locate this breakpoint in the thread's data breakpoints
    // if possible.
    for (i = 0; i < Thread->NumDataBreaks; i++)
    {
        // Check for match in addition to equality to handle
        // multiple identical data breakpoints.
        if (Thread->DataBreakBps[i] == this ||
            IsInsertionMatch(Thread->DataBreakBps[i]))
        {
            if ((Flat(*Thread->DataBreakBps[i]->GetAddr()) ^ 
                 Flat(*Addr)) & 
                (m_Control & IA64_DBG_MASK_MASK))
            {
                // Breakpoint can't be listed in more than one slot
                // so there's no need to finish the loop.
                return BREAKPOINT_NOT_HIT;
            }
            else
            {
                return BREAKPOINT_HIT;
            }
        }
    }

    return BREAKPOINT_NOT_HIT;
}

ULONG64 
Ia64DataBreakpoint::GetControl(ULONG AccessType, ULONG Size)
{
    ULONG64 Control = (ULONG64(IA64_DBG_REG_PLM_ALL) | 
                       ULONG64(IA64_DBG_MASK_MASK)) & 
                      ~ULONG64(Size - 1);

    switch (AccessType)
    {
    case DEBUG_BREAK_WRITE:
        Control |= IA64_DBR_WR;
        break;
    case DEBUG_BREAK_READ:
        Control |= IA64_DBR_RD;
        break;
    case DEBUG_BREAK_READ | DEBUG_BREAK_WRITE:
        Control |= IA64_DBR_RDWR;
        break;
    case DEBUG_BREAK_EXECUTE:
        Control |= IA64_DBR_EXEC;
        break;
    } 

    return Control;
}

//----------------------------------------------------------------------------
//
// X86OnIa64DataBreakpoint.
//
//----------------------------------------------------------------------------

X86OnIa64DataBreakpoint::X86OnIa64DataBreakpoint(DebugClient* Adder, ULONG Id)
    : X86DataBreakpoint(Adder, Id, X86_CR4, X86_DR6, IMAGE_FILE_MACHINE_I386)
{
    m_Control = 0;
}

HRESULT
X86OnIa64DataBreakpoint::Validate(void)
{
    HRESULT Status = X86DataBreakpoint::Validate();
    if (Status != S_OK) 
    {
        return Status;
    }

    switch (m_DataAccessType)
    {
    case DEBUG_BREAK_WRITE: 
    case DEBUG_BREAK_READ:
    case DEBUG_BREAK_READ | DEBUG_BREAK_WRITE:
    case DEBUG_BREAK_EXECUTE:
        break;
    default:
        ErrOut("Unsupported data breakpoint access type\n");
        return E_INVALIDARG;
    } 

    m_Control = Ia64DataBreakpoint::GetControl(m_DataAccessType, m_DataSize);

    return S_OK;
}


// XXX olegk -This is pure hack
// (see X86OnIa64MachineInfo::IsBreakpointOrStepException implementation 
// for more info)

ULONG
X86OnIa64DataBreakpoint::IsHit(PADDR Addr)
{
    ULONG i;
    PTHREAD_INFO Thread = g_EventThread;

    // Data breakpoints are only active on particular
    // threads so if the event thread doesn't match
    // the breakpoint can't be hit.
    if (m_MatchThread != NULL && m_MatchThread != Thread)
    {
        return BREAKPOINT_NOT_HIT;
    }

    // Locate this breakpoint in the thread's data breakpoints
    // if possible.
    for (i = 0; i < Thread->NumDataBreaks; i++)
    {
        // Check for match in addition to equality to handle
        // multiple identical data breakpoints.
        if (Thread->DataBreakBps[i] == this ||
            IsInsertionMatch(Thread->DataBreakBps[i]))
        {
            if (((ULONG)Flat(*Thread->DataBreakBps[i]->GetAddr()) ^ 
                 (ULONG)Flat(*Addr)) & 
                (ULONG)(m_Control & IA64_DBG_MASK_MASK))
            {
                // Breakpoint can't be listed in more than one slot
                // so there's no need to finish the loop.
                return BREAKPOINT_NOT_HIT;
            }
            else
            {
                return BREAKPOINT_HIT;
            }
        }
    }

    return BREAKPOINT_NOT_HIT;
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------


BOOL 
BreakpointNeedsToBeDeferred(Breakpoint* Bp, PADDR PcAddr)
{
    if (IS_CONTEXT_POSSIBLE() &&
        (Bp->m_Process == g_CurrentProcess))
    {
        if (AddrEqu(*Bp->GetAddr(), *PcAddr) && 
            (Bp->m_Flags & BREAKPOINT_VIRT_ADDR))
        {
            return TRUE;
        }

        if ((Bp == g_LastBreakpointHit) && Bp->PcAtHit() && 
            AddrEqu(g_LastBreakpointHitPc, *PcAddr)) 
        {
            if (g_ContextChanged)
            {
                WarnOut("Breakpoint %ld will not be deferred because "
                        "changes in the context. Breakpoint may hit again.\n", 
                        Bp->m_Id);
                return FALSE;
            }
            return TRUE;
        }                     
    }
    return FALSE;
}

//----------------------------------------------------------------------------
//
// Modify debuggee to activate current breakpoints.
//
//----------------------------------------------------------------------------

HRESULT
InsertBreakpoints(void)
{
    HRESULT Status = S_OK;
    ADDR PcAddr;
    BOOL DeferredData = FALSE;
    PTHREAD_INFO OldThread;
    MachineInfo* Machine;

    if (g_CurrentProcess != NULL &&
        g_CurrentProcess->CurrentThread != NULL)
    {
        // Aggressively clear this flag always in order to be
        // as conservative as possible when recognizing
        // trace events.  We would rather misrecognize
        // single-step events and break in instead of
        // misrecognizing an app-generated single-step and
        // ignoring it.
        g_CurrentProcess->CurrentThread->Flags &= ~ENG_THREAD_DEFER_BP_TRACE;
    }
    
    if ((g_EngStatus & ENG_STATUS_BREAKPOINTS_INSERTED) ||
        (g_EngStatus & ENG_STATUS_SUSPENDED) == 0 ||
        IS_DUMP_TARGET())
    {
        return Status;
    }

    g_DeferDefined = FALSE;

    // Switch to the event thread to get the event thread's
    // PC so we can see if we need to defer breakpoints in
    // order to allow the event thread to keep running.
    OldThread = g_RegContextThread;
    ChangeRegContext(g_EventThread);

    Machine = g_Machine;
    
    if (g_BreakpointsSuspended)
    {
        goto StepTraceOnly;
    }

    //
    // Turn off all data breakpoints.  (We will turn the enabled ones back
    // on when we restart execution).
    //

    PTHREAD_INFO Thread;
    PPROCESS_INFO Process;

    // Clear each thread in each process.

    Process = g_ProcessHead;
    while (Process)
    {
        Thread = Process->ThreadHead;
        while (Thread)
        {
            DataBreakpoint::ClearThreadDataBreaks(Thread);
            Thread = Thread->Next;
        }
        Process = Process->Next;
    }

    if (IS_CONTEXT_POSSIBLE())
    {
        Machine->GetPC(&PcAddr);
    }

    BpOut("InsertBreakpoints PC ");
    if (IS_CONTEXT_POSSIBLE())
    {
        MaskOutAddr(DEBUG_IOUTPUT_BREAKPOINT, &PcAddr);
        BpOut("\n");
    }
    else
    {
        BpOut("?\n");
    }
    
    //
    // Set any appropriate permanent breakpoints.
    //

    Breakpoint* Bp;

    for (Process = g_ProcessHead; Process; Process = Process->Next)
    {
        BpOut("  Process %d with %d bps\n", Process->UserId,
              Process->NumBreakpoints);
        
        for (Bp = Process->Breakpoints; Bp != NULL; Bp = Bp->m_Next)
        {
            if (Bp->IsNormalEnabled() &&
                (g_CmdState == 'g' ||
                 (Bp->m_Flags & DEBUG_BREAKPOINT_GO_ONLY) == 0))
            {
                Bp->ForceFlatAddr();

                // Check if this breakpoint matches a previously
                // inserted breakpoint.  If so there's no need
                // to insert this one.
                Breakpoint* MatchBp;

                for (MatchBp = Bp->m_Prev;
                     MatchBp != NULL;
                     MatchBp = MatchBp->m_Prev)
                {
                    if ((MatchBp->m_Flags & BREAKPOINT_INSERTED) &&
                        Bp->IsInsertionMatch(MatchBp))
                    {
                        break;
                    }
                }
                if (MatchBp != NULL)
                {
                    // Skip this breakpoint.  It won't be marked as
                    // inserted so Remove is automatically handled.
                    continue;
                }
            
                if (BreakpointNeedsToBeDeferred(Bp, &PcAddr))
                {
                    g_DeferDefined = TRUE;
                    if (Bp->m_BreakType == DEBUG_BREAKPOINT_DATA)
                    {
                        DeferredData = TRUE;
                    }
                }
                else
                {
                    HRESULT InsertStatus;

                    InsertStatus = Bp->Insert();
                    if (InsertStatus != S_OK)
                    {
                        if (Bp->m_Flags & DEBUG_BREAKPOINT_GO_ONLY)
                        {
                            ErrOut("go ");
                        }
                        ErrOut("bp%d at ", Bp->m_Id);
                        MaskOutAddr(DEBUG_OUTPUT_ERROR, Bp->GetAddr());
                        ErrOut("failed\n");

                        Status = InsertStatus;
                    }
                }
            }
        }
    }

    // Enable data breakpoints if necessary.
    if (g_UpdateDataBreakpoints)
    {
        // It's the target machine's responsibility to manage
        // all data breakpoints for all machines, so always
        // force the usage of the target machine here. 
        g_TargetMachine->InsertAllDataBreakpoints();

        // If we deferred a data breakpoint we haven't
        // fully updated the data breakpoint state
        // so leave the update flags set.
        if (!DeferredData)
        {
            g_UpdateDataBreakpoints = FALSE;
            g_DataBreakpointsChanged = FALSE;
        }
    }

 StepTraceOnly:

    //  set the step/trace breakpoint if appropriate

    if (g_StepTraceBp->m_Flags & DEBUG_BREAKPOINT_ENABLED)
    {
        BpOut("Step/trace addr = ");
        MaskOutAddr(DEBUG_IOUTPUT_BREAKPOINT, g_StepTraceBp->GetAddr());
        BpOut("\n");

        if (Flat(*g_StepTraceBp->GetAddr()) == OFFSET_TRACE)
        {
            if (IS_USER_TARGET())
            {
                ChangeRegContext(g_StepTraceBp->m_MatchThread);
            }
            
            BpOut("Setting trace flag for step/trace thread %d:%x\n",
                  g_RegContextThread ? g_RegContextThread->UserId : 0,
                  g_RegContextThread ? g_RegContextThread->SystemId : 0);
            Machine->QuietSetTraceMode(g_StepTraceCmdState == 'b' ?
                                       TRACE_TAKEN_BRANCH :
                                       TRACE_INSTRUCTION);

            if (IS_USER_TARGET())
            {
                ChangeRegContext(g_EventThread);
            }
        }
        else if (IS_CONTEXT_POSSIBLE() &&
                 AddrEqu(*g_StepTraceBp->GetAddr(), PcAddr))
        {
            BpOut("Setting defer flag for step/trace\n");

            g_DeferDefined = TRUE;
        }
        else if (CheckMatchingBreakpoints(g_StepTraceBp, FALSE,
                                          BREAKPOINT_INSERTED))
        {
            // There's already a breakpoint inserted at the
            // step/trace address so we don't need to set another.
            BpOut("Trace bp matches existing bp\n");
        }
        else
        {
            if (g_StepTraceBp->Insert() != S_OK)
            {
                ErrOut("Trace bp at addr ");
                MaskOutAddr(DEBUG_OUTPUT_ERROR, g_StepTraceBp->GetAddr());
                ErrOut("failed\n");

                Status = E_FAIL;
            }
            else
            {
                BpOut("Trace bp at addr ");
                MaskOutAddr(DEBUG_IOUTPUT_BREAKPOINT,
                            g_StepTraceBp->GetAddr());
                BpOut("succeeded\n");
            }
        }
    }

    // Process deferred breakpoint.
    // If a deferred breakpoint is active it means that
    // the debugger needs to do some work on the current instruction
    // so it wants to step forward one instruction and then
    // get control back.  The deferred breakpoint forces a break
    // back to the debugger as soon as possible so that it
    // can carry out any deferred work.

    if (g_DeferDefined)
    {
        ULONG NextMachine;
        
        g_DeferBp->m_Process = g_CurrentProcess;
        Machine->GetNextOffset(FALSE, g_DeferBp->GetAddr(), &NextMachine);
        g_DeferBp->SetProcType(NextMachine);

        BpOut("Defer addr = ");
        MaskOutAddr(DEBUG_IOUTPUT_BREAKPOINT, g_DeferBp->GetAddr());
        BpOut("\n");

        if ((g_EngOptions & DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS) &&
            IS_USER_TARGET() &&
            g_SelectExecutionThread == SELTHREAD_ANY &&
            g_SelectedThread == NULL)
        {
            // The user wants breakpoint management to occur
            // precisely in order to properly handle breakpoints
            // in code executed by multiple threads.  Force
            // the defer thread to be the only thread executing
            // in order to avoid other threads running through
            // the breakpoint location or generating events.
            g_SelectExecutionThread = SELTHREAD_INTERNAL_THREAD;
            g_SelectedThread = g_EventThread;
        }
        
        if (Flat(*g_DeferBp->GetAddr()) == OFFSET_TRACE)
        {
            BpOut("Setting trace flag for defer thread %d:%x\n",
                  g_RegContextThread ? g_RegContextThread->UserId : 0,
                  g_RegContextThread ? g_RegContextThread->SystemId : 0);
            Machine->QuietSetTraceMode(TRACE_INSTRUCTION);
            
            if (IS_USER_TARGET() &&
                g_CurrentProcess != NULL &&
                g_CurrentProcess->CurrentThread != NULL)
            {
                // If the debugger is setting the trace flag
                // for the current thread remember that it
                // did so in order to properly recognize
                // debugger-provoked single-step events even
                // when events occur on other threads before
                // the single-step event comes back.
                g_CurrentProcess->CurrentThread->Flags |=
                    ENG_THREAD_DEFER_BP_TRACE;
            }
        }
        else
        {
            // If an existing breakpoint or the step/trace breakpoint
            // isn't already set on the next offset, insert the deferred
            // breakpoint.
            if (CheckMatchingBreakpoints(g_DeferBp, FALSE,
                                         BREAKPOINT_INSERTED) == NULL &&
                ((g_StepTraceBp->m_Flags & BREAKPOINT_INSERTED) == 0 ||
                 !AddrEqu(*g_StepTraceBp->GetAddr(), *g_DeferBp->GetAddr())))
            {
                if (g_DeferBp->Insert() != S_OK)
                {
                    ErrOut("Deferred bp at addr ");
                    MaskOutAddr(DEBUG_OUTPUT_ERROR, g_DeferBp->GetAddr());
                    ErrOut("failed\n");

                    Status = E_FAIL;
                }
                else
                {
                    BpOut("Deferred bp at addr ");
                    MaskOutAddr(DEBUG_IOUTPUT_BREAKPOINT,
                                g_DeferBp->GetAddr());
                    BpOut("succeeded\n");
                }
            }
            else
            {
                BpOut("Defer bp matches existing bp\n");
            }
        }
    }

    ChangeRegContext(OldThread);
    
    // Always consider breakpoints inserted since some
    // of them may have been inserted even if some failed.
    g_EngStatus |= ENG_STATUS_BREAKPOINTS_INSERTED;

    return Status;
}

//----------------------------------------------------------------------------
//
// Reverse any debuggee changes caused by breakpoint insertion.
//
//----------------------------------------------------------------------------

BOOL
RemoveBreakpoints(void)
{
    if ((g_EngStatus & ENG_STATUS_BREAKPOINTS_INSERTED) == 0 ||
        (g_EngStatus & ENG_STATUS_SUSPENDED) == 0 ||
        IS_DUMP_TARGET())
    {
        return FALSE; // do nothing
    }

    BpOut("RemoveBreakpoints\n");

    //  restore the deferred breakpoint if set
    g_DeferBp->Remove();

    //  restore the step/trace breakpoint if set
    g_StepTraceBp->Remove();

    if (!g_BreakpointsSuspended)
    {
        //
        // Restore any appropriate permanent breakpoints (reverse order).
        //

        PPROCESS_INFO Process;
        Breakpoint* Bp;

        for (Process = g_ProcessHead; Process; Process = Process->Next)
        {
            BpOut("  Process %d with %d bps\n", Process->UserId,
                  Process->NumBreakpoints);
        
            for (Bp = Process->BreakpointsTail; Bp != NULL; Bp = Bp->m_Prev)
            {
                Bp->Remove();
            }
        }
    }

    g_EngStatus &= ~ENG_STATUS_BREAKPOINTS_INSERTED;
    return TRUE;
}

//----------------------------------------------------------------------------
//
// Create a new breakpoint object.
//
//----------------------------------------------------------------------------

HRESULT
AddBreakpoint(DebugClient* Client,
              ULONG Type,
              ULONG DesiredId,
              Breakpoint** RetBp)
{
    Breakpoint* Bp;
    ULONG Id;
    PPROCESS_INFO Process;

    if (!IS_MACHINE_SET() || !g_CurrentProcess)
    {
        return E_UNEXPECTED;
    }

    if (DesiredId == DEBUG_ANY_ID)
    {
        // Find the lowest unused ID across all processes.
        // Breakpoint IDs are kept unique across all
        // breakpoints to prevent user confusion and also
        // to give extensions a unique ID for breakpoints.
        Id = 0;
        for (;;)
        {
            // Search all bps to see if the current ID is in use.
            for (Process = g_ProcessHead; Process; Process = Process->Next)
            {
                for (Bp = Process->Breakpoints; Bp; Bp = Bp->m_Next)
                {
                    if (Bp->m_Id == Id)
                    {
                        break;
                    }
                }
            
                if (Bp != NULL)
                {
                    break;
                }
            }

            if (Process != NULL)
            {
                // A breakpoint is already using the current ID.
                // Try the next one.
                Id++;
            }
            else
            {
                break;
            }
        }
    }
    else
    {
        // Check to see if the desired ID is in use.
        for (Process = g_ProcessHead; Process; Process = Process->Next)
        {
            for (Bp = Process->Breakpoints; Bp != NULL; Bp = Bp->m_Next)
            {
                if (Bp->m_Id == DesiredId)
                {
                    return E_INVALIDARG;
                }
            }
        }

        Id = DesiredId;
    }

    HRESULT Status = g_Machine->NewBreakpoint(Client, Type, Id, &Bp);
    if (Status != S_OK) 
    {
        return Status;
    }

    *RetBp = Bp;
    Bp->LinkIntoList();
    
    // If this is an internal, hidden breakpoint set
    // the flag immediately and do not notify.
    if (Type & BREAKPOINT_HIDDEN)
    {
        Bp->m_Flags |= BREAKPOINT_HIDDEN;
    }
    else
    {
        NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, Id, TRUE);
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
// Delete a breakpoint object.
//
//----------------------------------------------------------------------------

void
DiscardBreakpoint(Breakpoint* Bp)
{
    ULONG i;

    // Make sure stale pointers aren't left in the
    // go breakpoints array.  This can happen if
    // a process exits or the target reboots while
    // go breakpoints are active.
    for (i = 0; i < g_NumGoBreakpoints; i++)
    {
        if (g_GoBreakpoints[i] == Bp)
        {
            g_GoBreakpoints[i] = NULL;
        }
    }

    delete Bp;
}

void
RemoveBreakpoint(Breakpoint* Bp)
{
    ULONG Id = Bp->m_Id;
    ULONG Flags = Bp->m_Flags;

    DiscardBreakpoint(Bp);

    if ((Flags & BREAKPOINT_HIDDEN) == 0)
    {
        NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, Id, TRUE);
    }
}

//----------------------------------------------------------------------------
//
// Clean up breakpoints owned by a particular process or thread.
//
//----------------------------------------------------------------------------

void
RemoveProcessBreakpoints(PPROCESS_INFO Process)
{
    g_EngNotify++;

    Breakpoint* Bp;
    Breakpoint* NextBp;
    BOOL NeedNotify = FALSE;

    for (Bp = Process->Breakpoints; Bp != NULL; Bp = NextBp)
    {
        NextBp = Bp->m_Next;

        DBG_ASSERT(Bp->m_Process == Process);
        
        RemoveBreakpoint(Bp);
        NeedNotify = TRUE;
    }

    g_EngNotify--;
    if (NeedNotify)
    {
        NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, DEBUG_ANY_ID, TRUE);
    }
}

void
RemoveThreadBreakpoints(PTHREAD_INFO Thread)
{
    g_EngNotify++;

    Breakpoint* Bp;
    Breakpoint* NextBp;
    BOOL NeedNotify = FALSE;

    DBG_ASSERT(Thread->Process);
    
    for (Bp = Thread->Process->Breakpoints; Bp != NULL; Bp = NextBp)
    {
        NextBp = Bp->m_Next;

        DBG_ASSERT(Bp->m_Process == Thread->Process);
        
        if (Bp->m_MatchThread == Thread)
        {
            RemoveBreakpoint(Bp);
            NeedNotify = TRUE;
        }
    }

    g_EngNotify--;
    if (NeedNotify)
    {
        NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, DEBUG_ANY_ID, TRUE);
    }
}

//----------------------------------------------------------------------------
//
// Forces the target machine to remove all kernel breakpoints.
//
//----------------------------------------------------------------------------

void
RemoveAllKernelBreakpoints(void)
{
    ULONG i;

    // Indices are array index plus one.
    for (i = 1; i <= BREAKPOINT_TABLE_SIZE; i++)
    {
        DbgKdRestoreBreakPoint(i);
    }

    // This API was added for Whistler so it fails against
    // any previous OS.  Ignore any failure return.
    DbgKdClearAllInternalBreakpoints();
}

//----------------------------------------------------------------------------
//
// Remove all breakpoints and reset breakpoint state.
//
//----------------------------------------------------------------------------

void
RemoveAllBreakpoints(ULONG Reason)
{
    PPROCESS_INFO Process;
    
    g_EngNotify++;

    for (Process = g_ProcessHead; Process; Process = Process->Next)
    {
        while (Process->Breakpoints != NULL)
        {
            RemoveBreakpoint(Process->Breakpoints);
        }
    }

    g_EngNotify--;
    NotifyChangeEngineState(DEBUG_CES_BREAKPOINTS, DEBUG_ANY_ID, TRUE);

    g_NumGoBreakpoints = 0;

    // If the machine is shutting down we can't
    // remove breakpoints.
    if (Reason != DEBUG_SESSION_REBOOT &&
        Reason != DEBUG_SESSION_HIBERNATE &&
        Reason != DEBUG_SESSION_FAILURE &&
        IS_CONN_KERNEL_TARGET() &&
        g_DbgKdTransport->m_WaitingThread == 0)
    {
        RemoveAllKernelBreakpoints();

        // If there were any data breakpoints active
        // remove them from all processors.  This can't be in
        // RemoveAllKernelBreakpoints as that
        // code is called in the middle of state
        // change processing when the context hasn't
        // been initialized.
        if (g_UpdateDataBreakpoints)
        {
            ULONG Proc;

            SetEffMachine(g_TargetMachineType, FALSE);

            g_EngNotify++;
            for (Proc = 0; Proc < g_TargetNumberProcessors; Proc++)
            {
                SetCurrentProcessorThread(Proc, TRUE);

                // Force the context to be dirty so it
                // gets written back.
                g_Machine->GetContextState(MCTX_DIRTY);
                g_Machine->RemoveAllDataBreakpoints();
            }
            g_EngNotify--;

            // Flush final context.
            ChangeRegContext(NULL);
        }
    }

    // Always update data breakpoints the very first time in
    // order to flush out any stale data breakpoints.
    g_UpdateDataBreakpoints = TRUE;

    g_DataBreakpointsChanged = FALSE;
    g_BreakpointsSuspended = FALSE;
    
    delete g_StepTraceBp;
    g_StepTraceBp = NULL;
    delete g_DeferBp;
    g_DeferBp = NULL;
    g_DeferDefined = FALSE;
}

//----------------------------------------------------------------------------
//
// Look up breakpoints.
//
//----------------------------------------------------------------------------

Breakpoint*
GetBreakpointByIndex(DebugClient* Client, ULONG Index)
{
    Breakpoint* Bp;

    DBG_ASSERT(g_CurrentProcess);
    
    for (Bp = g_CurrentProcess->Breakpoints;
         Bp != NULL && Index > 0;
         Bp = Bp->m_Next)
    {
        Index--;
    }

    if (Bp != NULL &&
        (Bp->m_Flags & BREAKPOINT_HIDDEN) == 0 &&
        ((Bp->m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) == 0 ||
         Bp->m_Adder == Client))
    {
        return Bp;
    }

    return NULL;
}

Breakpoint*
GetBreakpointById(DebugClient* Client, ULONG Id)
{
    Breakpoint* Bp;

    DBG_ASSERT(g_CurrentProcess);
    
    for (Bp = g_CurrentProcess->Breakpoints; Bp != NULL; Bp = Bp->m_Next)
    {
        if (Bp->m_Id == Id)
        {
            if ((Bp->m_Flags & BREAKPOINT_HIDDEN) == 0 &&
                ((Bp->m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) == 0 ||
                 Bp->m_Adder == Client))
            {
                return Bp;
            }

            break;
        }
    }

    return NULL;
}

//----------------------------------------------------------------------------
//
// Check to see if two breakpoints refer to the same breakpoint
// conditions.
//
//----------------------------------------------------------------------------

Breakpoint*
CheckMatchingBreakpoints(Breakpoint* Match, BOOL Public, ULONG IncFlags)
{
    Breakpoint* Bp;

    for (Bp = Match->m_Process->Breakpoints; Bp != NULL; Bp = Bp->m_Next)
    {
        if (Bp == Match || (Bp->m_Flags & IncFlags) == 0)
        {
            continue;
        }

        if ((Public && Bp->IsPublicMatch(Match)) ||
            (!Public && Bp->IsInsertionMatch(Match)))
        {
            return Bp;
        }
    }

    return NULL;
}

//----------------------------------------------------------------------------
//
// Starting at the given breakpoint, check to see if a breakpoint
// is hit with the current processor state.  Breakpoint types
// can be included or excluded by flags.
//
//----------------------------------------------------------------------------

Breakpoint*
CheckBreakpointHit(PPROCESS_INFO Process, Breakpoint* Start, PADDR Addr,
                   ULONG ExbsType, ULONG IncFlags, ULONG ExcFlags,
                   PULONG HitType,
                   BOOL SetLastBreakpointHit)
{
    DBG_ASSERT(ExbsType & EXBS_BREAKPOINT_ANY);

    ULONG BreakType;
    
    switch(ExbsType)
    {
    case EXBS_BREAKPOINT_CODE:
        BreakType = DEBUG_BREAKPOINT_CODE;
        break;
    case EXBS_BREAKPOINT_DATA:
        BreakType = DEBUG_BREAKPOINT_DATA;
        break;
    default:
        ExbsType = EXBS_BREAKPOINT_ANY;
        break;
    }

    Breakpoint* Bp;

    BpOut("CheckBp addr ");
    MaskOutAddr(DEBUG_IOUTPUT_BREAKPOINT, Addr);
    BpOut("\n");

    for (Bp = (Start == NULL ? Process->Breakpoints : Start);
         Bp != NULL;
         Bp = Bp->m_Next)
    {
        // Allow different kinds of breakpoints to be scanned
        // separately if desired.
            
        if ((ExbsType != EXBS_BREAKPOINT_ANY &&
             Bp->m_BreakType != BreakType) ||
            (Bp->m_Flags & IncFlags) == 0 ||
            (Bp->m_Flags & ExcFlags) != 0)
        {
            continue;
        }

        // Common code is inlined here rather than in the
        // base class because both pre- and post-derived
        // checks are necessary.

        // Force recomputation of flat address.
        if (Bp->m_Flags & BREAKPOINT_VIRT_ADDR)
        {
            NotFlat(*Bp->GetAddr());
            ComputeFlatAddress(Bp->GetAddr(), NULL);
        }

        if (Bp->IsNormalEnabled())
        {
            // We've got a partial match.  Further checks
            // depend on what kind of breakpoint it is.
            *HitType = Bp->IsHit(Addr);
            if (*HitType != BREAKPOINT_NOT_HIT)
            {
                // Do a final check for the pass count.  If the
                // pass count is nonzero this will become a partial hit.
                if (*HitType == BREAKPOINT_HIT &&
                    !Bp->PassHit())
                {
                    *HitType = BREAKPOINT_HIT_IGNORED;
                }

                BpOut("  hit %d\n", Bp->m_Id);

                if (SetLastBreakpointHit) 
                {
                    g_LastBreakpointHit = Bp;
                    g_Machine->GetPC(&g_LastBreakpointHitPc);
                }

                return Bp;
            }
        }
    }

    BpOut("  no hit\n");

    *HitType = BREAKPOINT_NOT_HIT;

    if (SetLastBreakpointHit) 
    {
        g_LastBreakpointHit = NULL;
        ZeroMemory(&g_LastBreakpointHitPc, sizeof(g_LastBreakpointHitPc));
    }

    return NULL;
}

//----------------------------------------------------------------------------
//
// Walk the breakpoint list and invoke event callbacks for
// any breakpoints that need it.  Watch for and handle list changes
// caused by callbacks.
//
//----------------------------------------------------------------------------

ULONG
NotifyHitBreakpoints(ULONG EventStatus)
{
    Breakpoint* Bp;
    PPROCESS_INFO Process;

    for (;;)
    {
        g_BreakpointListChanged = FALSE;
        
        for (Process = g_ProcessHead; Process; Process = Process->Next)
        {
            for (Bp = Process->Breakpoints; Bp != NULL; Bp = Bp->m_Next)
            {
                if (Bp->m_Flags & BREAKPOINT_NOTIFY)
                {
                    Bp->m_Flags &= ~BREAKPOINT_NOTIFY;
                    EventStatus = NotifyBreakpointEvent(EventStatus, Bp);

                    // If the callback caused the breakpoint list to
                    // change we can no longer rely on the pointer
                    // we have and we need to restart the iteration.
                    if (g_BreakpointListChanged)
                    {
                        break;
                    }
                }
            }

            if (Bp)
            {
                break;
            }
        }

        if (Process == NULL)
        {
            break;
        }
    }

    return EventStatus;
}

//----------------------------------------------------------------------------
//
// A module load/unload event has occurred so go through every
// breakpoint with an offset expression and reevaluate it.
//
//----------------------------------------------------------------------------

void
EvaluateOffsetExpressions(PPROCESS_INFO Process, ULONG Flags)
{
    static BOOL s_Evaluating;
    
    // Don't reevaluate when not notifying because
    // lack of notification usually means that a group
    // of operations is being done and that notify/reevaluate
    // will be done later after all of them are finished.
    // It is also possible to have nested evaluations as
    // evaluation may provoke symbol loads on deferred
    // modules, which leads to a symbol notification and
    // thus another evaluation.  If we're already evaluating
    // there's no need to evaluate again.
    if (g_EngNotify > 0 || s_Evaluating)
    {
        return;
    }
    s_Evaluating = TRUE;

    Breakpoint* Bp;
    BOOL AnyEnabled = FALSE;

    for (Bp = Process->Breakpoints; Bp != NULL; Bp = Bp->m_Next)
    {
        // Optimize evaluation somewhat.
        // If a module is added then deferred breakpoints
        // can become active.  If a module is removed then
        // active breakpoints can become deferred.
        // XXX drewb - This doesn't hold up with general
        // conditional expressions but currently the
        // only thing that is officially supported is a simple symbol.
        if (Bp->m_OffsetExpr != NULL &&
            (((Flags & DEBUG_CSS_LOADS) &&
              (Bp->m_Flags & DEBUG_BREAKPOINT_DEFERRED)) ||
             ((Flags & DEBUG_CSS_UNLOADS) &&
              (Bp->m_Flags & DEBUG_BREAKPOINT_DEFERRED) == 0)))
        {
            if (Bp->EvalOffsetExpr() &&
                (Bp->m_Flags & DEBUG_BREAKPOINT_DEFERRED) == 0)
            {
                // No need to update on newly disabled breakpoints
                // as the module is being unloaded so they'll
                // go away anyway.  The disabled breakpoint
                // is simply marked not-inserted in EvalOffsetExpr.
                AnyEnabled = TRUE;
            }
        }

        if (g_EngStatus & (ENG_STATUS_USER_INTERRUPT |
                           ENG_STATUS_PENDING_BREAK_IN))
        {
            // Leave the interrupt set as this may be
            // called in the middle of a symbol operation
            // and we want the interrupt to interrupt
            // the entire symbol operation.
            break;
        }
    }

    if (AnyEnabled)
    {
        // A deferred breakpoint has become enabled.
        // Force a refresh of the breakpoints so
        // that the newly enabled breakpoints get inserted.
        SuspendExecution();
        RemoveBreakpoints();
    }

    s_Evaluating = FALSE;
}

//----------------------------------------------------------------------------
//
// Alters breakpoint state for b[cde]<idlist>.
//
//----------------------------------------------------------------------------

void
ChangeBreakpointState(DebugClient* Client, PPROCESS_INFO ForProcess,
                      ULONG Id, UCHAR StateChange)
{
    Breakpoint* Bp;
    Breakpoint* NextBp;
    PPROCESS_INFO Process;

    for (Process = g_ProcessHead; Process; Process = Process->Next)
    {
        if (ForProcess != NULL && Process != ForProcess)
        {
            continue;
        }
        
        for (Bp = Process->Breakpoints; Bp != NULL; Bp = NextBp)
        {
            // Prefetch the next breakpoint in case we remove
            // the current breakpoint from the list.
            NextBp = Bp->m_Next;

            if ((Id == ALL_ID_LIST || Bp->m_Id == Id) &&
                (Bp->m_Flags & BREAKPOINT_HIDDEN) == 0 &&
                ((Bp->m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) == 0 ||
                 Bp->m_Adder == Client))
            {
                if (StateChange == 'c')
                {
                    RemoveBreakpoint(Bp);
                }
                else
                {
                    if (StateChange == 'e')
                    {
                        Bp->AddFlags(DEBUG_BREAKPOINT_ENABLED);
                    }
                    else
                    {
                        Bp->RemoveFlags(DEBUG_BREAKPOINT_ENABLED);
                    }
                }
            }
        }
    }
}

//----------------------------------------------------------------------------
//
// Lists current breakpoints for bl.
//
//----------------------------------------------------------------------------

void
ListBreakpoints(DebugClient* Client, PPROCESS_INFO ForProcess,
                ULONG Id)
{
    PPROCESS_INFO ProcessSaved = g_CurrentProcess;
    Breakpoint* Bp;
    PPROCESS_INFO Process;

    for (Process = g_ProcessHead; Process; Process = Process->Next)
    {
        if (ForProcess != NULL && Process != ForProcess)
        {
            continue;
        }
        
        for (Bp = Process->Breakpoints; Bp != NULL; Bp = Bp->m_Next)
        {
            char StatusChar;

            if ((Bp->m_Flags & BREAKPOINT_HIDDEN) ||
                ((Bp->m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) &&
                 Client != Bp->m_Adder) ||
                (Id != ALL_ID_LIST && Bp->m_Id != Id))
            {
                continue;
            }

            if (Bp->m_Flags & DEBUG_BREAKPOINT_ENABLED)
            {
                if (Bp->m_Flags & BREAKPOINT_KD_INTERNAL)
                {
                    StatusChar =
                        (Bp->m_Flags & BREAKPOINT_KD_COUNT_ONLY) ? 'i' : 'w';
                }
                else
                {
                    StatusChar = 'e';
                }
            }
            else
            {
                StatusChar = 'd';
            }

            dprintf("%2ld %c", Bp->m_Id, StatusChar);

            if (Bp->GetProcType() != g_TargetMachineType)
            {
                dprintf("%s ",
                        g_AllMachines[Bp->GetProcIndex()]->m_AbbrevName);
            }

            if ((Bp->m_Flags & DEBUG_BREAKPOINT_DEFERRED) == 0)
            {
                dprintf(" ");
                if (Bp->m_BreakType == DEBUG_BREAKPOINT_CODE &&
                    (g_SrcOptions & SRCOPT_STEP_SOURCE))
                {
                    IMAGEHLP_LINE Line;
                    DWORD         Disp;

                    Line.SizeOfStruct = sizeof(Line);
                    if (g_CurrentProcess != NULL &&
                        SymGetLineFromAddr(g_CurrentProcess->Handle,
                                           Flat(*Bp->GetAddr()),
                                           &Disp, &Line))
                    {
                        dprintf("[%s @ %d]", Line.FileName, Line.LineNumber);
                    }
                    else
                    {
                        dprintAddr(Bp->GetAddr());
                    }
                }
                else
                {
                    dprintAddr(Bp->GetAddr());
                }
            }
            else if (g_TargetMachine->m_Ptr64)
            {
                dprintf("u                  ");
            }
            else
            {
                dprintf("u         ");
            }

            char OptionChar;

            if (Bp->m_BreakType == DEBUG_BREAKPOINT_DATA)
            {
                switch(Bp->m_DataAccessType)
                {
                case DEBUG_BREAK_EXECUTE:
                    OptionChar = 'e';
                    break;
                case DEBUG_BREAK_WRITE:
                    OptionChar = 'w';
                    break;
                case DEBUG_BREAK_IO:
                    OptionChar = 'i';
                    break;
                case DEBUG_BREAK_READ:
                case DEBUG_BREAK_READ | DEBUG_BREAK_WRITE:
                    OptionChar = 'r';
                    break;
                default:
                    OptionChar = '?';
                    break;
                }
                dprintf("%c %d", OptionChar, Bp->m_DataSize);
            }
            else
            {
                dprintf("   ");
            }

            dprintf(" %04lx (%04lx) ", Bp->m_CurPassCount, Bp->m_PassCount);

            if ((Bp->m_Flags & DEBUG_BREAKPOINT_DEFERRED) == 0)
            {
                if (IS_USER_TARGET())
                {
                    dprintf("%2ld:", Bp->m_Process->UserId);
                    if (Bp->m_MatchThread != NULL)
                    {
                        dprintf("~%03ld ", Bp->m_MatchThread->UserId);
                    }
                    else
                    {
                        dprintf("*** ");
                    }
                }

                g_CurrentProcess = Bp->m_Process;
                OutputSymAddr(Flat(*Bp->GetAddr()), SYMADDR_FORCE);

                if (Bp->m_Command != NULL)
                {
                    dprintf("\"%s\"", Bp->m_Command);
                }
            }
            else
            {
                dprintf(" (%s)", Bp->m_OffsetExpr);
            }

            dprintf("\n");

            if (Bp->m_MatchThreadData || Bp->m_MatchProcessData)
            {
                dprintf("   ");
                if (Bp->m_MatchThreadData)
                {
                    dprintf("  Match thread data %s",
                            FormatAddr64(Bp->m_MatchThreadData));
                }
                if (Bp->m_MatchProcessData)
                {
                    dprintf("  Match process data %s",
                            FormatAddr64(Bp->m_MatchProcessData));
                }
                dprintf("\n");
            }
        }
    }

    if (IS_KERNEL_TARGET())
    {
        dprintf("\n");

        for (Process = g_ProcessHead; Process; Process = Process->Next)
        {
            if (ForProcess != NULL && Process != ForProcess)
            {
                continue;
            }
        
            for (Bp = Process->Breakpoints; Bp != NULL; Bp = Bp->m_Next)
            {
                if (Bp->m_Flags & BREAKPOINT_KD_INTERNAL)
                {
                    ULONG flags, calls, minInst, maxInst, totInst, maxCPS;
                    DbgKdGetInternalBp(Flat(*Bp->GetAddr()), &flags, &calls,
                                       &minInst, &maxInst, &totInst, &maxCPS);
                    dprintf("%s %6d %8d %8d %8d %2x %4d ",
                            FormatAddr64(Flat(*Bp->GetAddr())),
                            calls, minInst, maxInst,
                            totInst, flags, maxCPS);
                    g_CurrentProcess = Bp->m_Process;
                    OutputSymAddr(Flat(*Bp->GetAddr()), SYMADDR_FORCE);
                    dprintf("\n");
                }
            }
        }
    }

    g_CurrentProcess = ProcessSaved;
}

//----------------------------------------------------------------------------
//
// Outputs commands necessary to recreate current breakpoints.
//
//----------------------------------------------------------------------------

void
ListBreakpointsAsCommands(DebugClient* Client, PPROCESS_INFO Process,
                          ULONG Flags)
{
    Breakpoint* Bp;

    if (Process == NULL)
    {
        return;
    }
    
    for (Bp = Process->Breakpoints; Bp != NULL; Bp = Bp->m_Next)
    {
        if ((Bp->m_Flags & BREAKPOINT_HIDDEN) ||
            ((Bp->m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) &&
             Client != Bp->m_Adder) ||
            ((Flags & BPCMDS_EXPR_ONLY && Bp->m_OffsetExpr == NULL)))
        {
            continue;
        }

        if (IS_USER_TARGET())
        {
            if (Bp->m_MatchThread != NULL ||
                Bp->m_MatchThreadData ||
                Bp->m_MatchProcessData)
            {
                // Ignore thread- and data-specific breakpoints
                // as the things they are specific to may
                // not exist in a new session.
                continue;
            }
        }

        if (Bp->GetProcType() != g_TargetMachineType)
        {
            dprintf(".effmach %s;%c",
                    g_AllMachines[Bp->GetProcIndex()]->m_AbbrevName,
                    (Flags & BPCMDS_ONE_LINE) ? ' ' : '\n');
        }

        if ((Flags & BPCMDS_MODULE_HINT) &&
            (Bp->m_Flags & (DEBUG_BREAKPOINT_DEFERRED |
                            BREAKPOINT_VIRT_ADDR)) == BREAKPOINT_VIRT_ADDR)
        {
            PDEBUG_IMAGE_INFO Image =
                GetImageByOffset(Bp->m_Process, Flat(*Bp->GetAddr()));
            if (Image != NULL)
            {
                dprintf("ld %s;%c", Image->ModuleName,
                    (Flags & BPCMDS_ONE_LINE) ? ' ' : '\n');
            }
        }
        
        char TypeChar;

        if (Bp->m_Flags & BREAKPOINT_KD_INTERNAL)
        {
            TypeChar = (Bp->m_Flags & BREAKPOINT_KD_COUNT_ONLY) ? 'i' : 'w';
        }
        else if (Bp->m_BreakType == DEBUG_BREAKPOINT_CODE)
        {
            TypeChar = Bp->m_OffsetExpr != NULL ? 'u' : 'p';
        }
        else
        {
            TypeChar = 'a';
        }

        dprintf("b%c%d", TypeChar, Bp->m_Id);

        char OptionChar;

        if (Bp->m_BreakType == DEBUG_BREAKPOINT_DATA)
        {
            switch(Bp->m_DataAccessType)
            {
            case DEBUG_BREAK_EXECUTE:
                OptionChar = 'e';
                break;
            case DEBUG_BREAK_WRITE:
                OptionChar = 'w';
                break;
            case DEBUG_BREAK_IO:
                OptionChar = 'i';
                break;
            case DEBUG_BREAK_READ:
            case DEBUG_BREAK_READ | DEBUG_BREAK_WRITE:
                OptionChar = 'r';
                break;
            default:
                continue;
            }
            dprintf(" %c%d", OptionChar, Bp->m_DataSize);
        }

        if (Bp->m_OffsetExpr != NULL)
        {
            dprintf(" %s", Bp->m_OffsetExpr);
        }
        else
        {
            dprintf(" 0x");
            dprintAddr(Bp->GetAddr());
        }

        if (Bp->m_PassCount > 1)
        {
            dprintf(" 0x%x", Bp->m_PassCount);
        }

        if (Bp->m_Command != NULL)
        {
            dprintf(" \"%s\"", Bp->m_Command);
        }

        dprintf(";%c", (Flags & BPCMDS_ONE_LINE) ? ' ' : '\n');

        if ((Flags & BPCMDS_FORCE_DISABLE) ||
            (Bp->m_Flags & DEBUG_BREAKPOINT_ENABLED) == 0)
        {
            dprintf("bd %d;%c", Bp->m_Id,
                    (Flags & BPCMDS_ONE_LINE) ? ' ' : '\n');
        }

        if (Bp->GetProcType() != g_TargetMachineType)
        {
            dprintf(".effmach .;%c",
                    (Flags & BPCMDS_ONE_LINE) ? ' ' : '\n');
        }
    }

    if (Flags & BPCMDS_ONE_LINE)
    {
        dprintf("\n");
    }
}

//----------------------------------------------------------------------------
//
// Parses command-line breakpoint commands for b[aipw].
//
//----------------------------------------------------------------------------

PDEBUG_BREAKPOINT
ParseBpCmd(DebugClient* Client,
           UCHAR Type,
           PTHREAD_INFO Thread)
{
    ULONG UserId = DEBUG_ANY_ID;
    UCHAR ch;
    ADDR  Addr;
    Breakpoint* Bp;

    if (IS_LOCAL_KERNEL_TARGET() || IS_DUMP_TARGET())
    {
        error(SESSIONNOTSUP);
    }
    if (!IS_CONTEXT_ACCESSIBLE())
    {
        error(BADTHREAD);
    }

    if (IS_LIVE_USER_TARGET() && Type == 'a' &&
        (g_EngStatus & ENG_STATUS_AT_INITIAL_BREAK))
    {
        ErrOut("The system resets thread contexts after the process\n");
        ErrOut("breakpoint so hardware breakpoints cannot be set.\n");
        ErrOut("Go to the executable's entry point and set it then.\n");
        *g_CurCmd = 0;
        return NULL;
    }

    //  get the breakpoint number if given

    ch = *g_CurCmd;
    if (ch == '[')
    {
        UserId = (ULONG)GetTermExprDesc("Breakpoint ID missing from");
    }
    else if (ch >= '0' && ch <= '9')
    {
        UserId = ch - '0';
        ch = *++g_CurCmd;
        while (ch >= '0' && ch <= '9')
        {
            UserId = UserId * 10 + ch - '0';
            ch = *++g_CurCmd;
        }
        
        if (ch != ' ' && ch != '\t' && ch != '\0')
        {
            error(SYNTAX);
        }
    }

    if (UserId != DEBUG_ANY_ID)
    {
        // Remove any existing breakpoint with the given ID.
        Breakpoint* IdBp;

        if ((IdBp = GetBreakpointById(Client, UserId)) != NULL)
        {
            WarnOut("breakpoint %ld exists, redefining\n", UserId);
            RemoveBreakpoint(IdBp);
        }
    }

    // Create a new breakpoint.
    if (AddBreakpoint(Client, Type == 'a' ?
                      DEBUG_BREAKPOINT_DATA : DEBUG_BREAKPOINT_CODE,
                      UserId, &Bp) != S_OK)
    {
        error(BPLISTFULL);
    }

    // Add in KD internal flags if necessary.
    if (Type == 'i' || Type == 'w')
    {
        if (IS_KERNEL_TARGET())
        {
            Bp->m_Flags = Bp->m_Flags | BREAKPOINT_KD_INTERNAL |
                (Type == 'i' ? BREAKPOINT_KD_COUNT_ONLY : 0);
            if (Type == 'w')
            {
                SetupSpecialCalls();
            }
        }
        else
        {
            // KD internal breakpoints are only supported in
            // kernel debugging.
            DiscardBreakpoint(Bp);
            error(SYNTAX);
        }
    }

    //  if data breakpoint, get option and size values

    if (Type == 'a')
    {
        ULONG64 Size;
        ULONG AccessType;

        ch = PeekChar();
        ch = (UCHAR)tolower(ch);

        if (ch == 'e')
        {
            AccessType = DEBUG_BREAK_EXECUTE;
        }
        else if (ch == 'w')
        {
            AccessType = DEBUG_BREAK_WRITE;
        }
        else if (ch == 'i')
        {
            AccessType = DEBUG_BREAK_IO;
        }
        else if (ch == 'r')
        {
            AccessType = DEBUG_BREAK_READ;
        }
        else
        {
            DiscardBreakpoint(Bp);
            error(SYNTAX);
        }

        g_CurCmd++;
        Size = GetTermExprDesc("Hardware breakpoint length missing from");
        if (Size & ~ULONG(-1))
        {
            ErrOut("Breakpoint length too big\n");
            DiscardBreakpoint(Bp);
            error(SYNTAX); 
        }

        // Validate the selections.  This assumes that
        // the default offset of zero won't cause problems.
        if (Bp->SetDataParameters((ULONG)Size, AccessType) != S_OK)
        {
            DiscardBreakpoint(Bp);
            error(SYNTAX);
        }

        g_CurCmd++;
    }

    //
    // Parse breakpoint options.
    //

    while (PeekChar() == '/')
    {
        g_CurCmd++;
        switch(*g_CurCmd++)
        {
        case 'p':
            Bp->m_MatchProcessData = GetTermExprDesc(NULL);
            break;
        case 't':
            Bp->m_MatchThreadData = GetTermExprDesc(NULL);
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            break;
        }
    }
    
    //  get the breakpoint address, if given, in addr
    //  default to PC

    ULONG AddrValid = EVAL_RESOLVED;
    
    g_Machine->GetPC(&Addr);

    ch = PeekChar();
    if (ch != '"' && ch != '\0')
    {
        PCHAR ExprStart = (PCHAR)g_CurCmd;

        g_PrefixSymbols = Type == 'p' || Type == 'u';
        
        AddrValid = EvalAddrExpression(g_CurrentProcess, g_EffMachine,
                                       &Addr);

        g_PrefixSymbols = FALSE;
        
        if (AddrValid == EVAL_ERROR)
        {
            DiscardBreakpoint(Bp);
            return NULL;
        }
        
        // If an unresolved symbol was encountered this
        // breakpoint will be deferred.  Users can also force
        // breakpoints to use expressions for cases where the
        // address could be resolved but also may become invalid
        // later.
        if (Type == 'u' || AddrValid == EVAL_UNRESOLVED)
        {
            HRESULT Status;
            UCHAR Save = *g_CurCmd;
            *g_CurCmd = 0;

            Status = Bp->SetOffsetExpression(ExprStart);

            if (Type != 'u' && Status == S_OK)
            {
                WarnOut("Bp expression '%s' could not be resolved, "
                        "adding deferred bp\n", ExprStart);
            }

            *g_CurCmd = Save;

            if (Status != S_OK)
            {
                DiscardBreakpoint(Bp);
                error(BPLISTFULL);
            }
        }

        ch = PeekChar();
    }

    if (AddrValid != EVAL_UNRESOLVED)
    {
        ULONG AddrSpace, AddrFlags;
        
        if (g_Target->
            QueryAddressInformation(Flat(Addr), DBGKD_QUERY_MEMORY_VIRTUAL,
                                    &AddrSpace, &AddrFlags) != S_OK)
        {
            ErrOut("Invalid breakpoint address\n");
            DiscardBreakpoint(Bp);
            error(MEMORY);
        }

        if (Type != 'a' &&
            !(AddrFlags & DBGKD_QUERY_MEMORY_WRITE) ||
            (AddrFlags & DBGKD_QUERY_MEMORY_FIXED))
        {
            ErrOut("Software breakpoints cannot be used on ROM code or\n"
                   "other read-only memory. "
                   "Use hardware execution breakpoints (ba e) instead.\n");
            DiscardBreakpoint(Bp);
            error(MEMORY);
        }

        if (Type != 'a' && AddrSpace == DBGKD_QUERY_MEMORY_SESSION)
        {
            WarnOut("WARNING: Software breakpoints on session "
                    "addresses can cause bugchecks.\n"
                    "Use hardware execution breakpoints (ba e) "
                    "if possible.\n");
        }
    }
    
    // The public interface only supports flat addresses
    // so use an internal method to set the true address.
    // Do not allow matching breakpoints through the parsing
    // interface as that was the previous behavior.
    if (Bp->SetAddr(&Addr, BREAKPOINT_REMOVE_MATCH) != S_OK)
    {
        DiscardBreakpoint(Bp);
        error(SYNTAX);
    }

    //  get the pass count, if given

    if (ch != '"' && ch != ';' && ch != '\0')
    {
        Bp->SetPassCount((ULONG)GetExpression());
        ch = PeekChar();
    }

    //  if next character is double quote, get the command string

    if (ch == '"')
    {
        PSTR Str;
        CHAR Save;

        Str = StringValue(STRV_ESCAPED_CHARACTERS, &Save);

        if (Bp->SetCommand(Str) != S_OK)
        {
            DiscardBreakpoint(Bp);
            error(BPLISTFULL);
        }

        *g_CurCmd = Save;
    }

    // Set some final information.
    if (Thread != NULL)
    {
        Bp->SetMatchThreadId(Thread->UserId);
    }

    // Turn breakpoint on.
    Bp->AddFlags(DEBUG_BREAKPOINT_ENABLED);

    return Bp;
}

inline BOOL
IsCodeBreakpointInsertedInRange(Breakpoint* Bp,
                                ULONG64 Start, ULONG64 End)
{
    return (Bp->m_Flags & BREAKPOINT_INSERTED) &&
        Bp->m_BreakType == DEBUG_BREAKPOINT_CODE &&
        Flat(*Bp->GetAddr()) >= Start &&
        Flat(*Bp->GetAddr()) <= End;
}

BOOL
CheckBreakpointInsertedInRange(PPROCESS_INFO Process,
                               ULONG64 Start, ULONG64 End)
{
    if ((g_EngStatus & ENG_STATUS_BREAKPOINTS_INSERTED) == 0)
    {
        return FALSE;
    }

    //
    // Check for a breakpoint that might have caused
    // a break instruction to be inserted in the given
    // offset range.  Data breakpoints don't count
    // as they don't actually modify the address they
    // break on.
    //

    Breakpoint* Bp;

    for (Bp = Process->Breakpoints; Bp != NULL; Bp = Bp->m_Next)
    {
        if (IsCodeBreakpointInsertedInRange(Bp, Start, End))
        {
            return TRUE;
        }
    }

    if ((g_DeferBp->m_Process == Process &&
         IsCodeBreakpointInsertedInRange(g_DeferBp, Start, End)) ||
        (g_StepTraceBp->m_Process == Process &&
         IsCodeBreakpointInsertedInRange(g_StepTraceBp, Start, End)))
    {
        return TRUE;
    }

    return FALSE;
}

void
DbgKdpAcquireHardwareBp(PDBGKD_CONTROL_REQUEST BpRequest)
{
    BpRequest->u.RequestBreakpoint.Available = FALSE;

    g_DbgKdTransport->WritePacket(BpRequest,
                                  sizeof(*BpRequest),
                                  PACKET_TYPE_KD_CONTROL_REQUEST,
                                  NULL,
                                  0);
}

void
DbgKdpReleaseHardwareBp(PDBGKD_CONTROL_REQUEST BpRequest)
{
    BpRequest->u.ReleaseBreakpoint.Released = TRUE;

    g_DbgKdTransport->WritePacket(BpRequest,
                                  sizeof(*BpRequest),
                                  PACKET_TYPE_KD_CONTROL_REQUEST,
                                  NULL,
                                  0);
}

//----------------------------------------------------------------------------
//
// TargetInfo methods.
//
//----------------------------------------------------------------------------

HRESULT
ConnLiveKernelTargetInfo::InsertCodeBreakpoint(PPROCESS_INFO Process,
                                               MachineInfo* Machine,
                                               PADDR Addr,
                                               PUCHAR StorageSpace)
{
    NTSTATUS Status = DbgKdWriteBreakPoint(Flat(*Addr),
                                           (PULONG_PTR)StorageSpace);
    return CONV_NT_STATUS(Status);
}

HRESULT
ConnLiveKernelTargetInfo::RemoveCodeBreakpoint(PPROCESS_INFO Process,
                                               MachineInfo* Machine,
                                               PADDR Addr,
                                               PUCHAR StorageSpace)
{
    // When the kernel fills out the CONTROL_REPORT.InstructionStream
    // array it clears any breakpoints that might fall within the
    // array.  This means that some breakpoints may already be
    // restored, so the restore call will fail.  We could do some
    // checks to try and figure out which ones might be affected
    // but it doesn't seem worthwhile.  Just ignore the return
    // value from the restore.
    DbgKdRestoreBreakPoint(*(PULONG_PTR)StorageSpace);
    return S_OK;
}

HRESULT
ExdiLiveKernelTargetInfo::InsertCodeBreakpoint(PPROCESS_INFO Process,
                                               MachineInfo* Machine,
                                               PADDR Addr,
                                               PUCHAR StorageSpace)
{
    HRESULT Status = m_Server->
        AddCodeBreakpoint(Flat(*Addr), m_CodeBpType, mtVirtual, 0, 0,
                          (IeXdiCodeBreakpoint**)StorageSpace);
    if (Status == S_OK)
    {
        // Breakpoints are created disabled so enable it.
        Status = (*(IeXdiCodeBreakpoint**)StorageSpace)->SetState(TRUE, TRUE);
        if (Status != S_OK)
        {
            m_Server->DelCodeBreakpoint(*(IeXdiCodeBreakpoint**)StorageSpace);
        }
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::RemoveCodeBreakpoint(PPROCESS_INFO Process,
                                               MachineInfo* Machine,
                                               PADDR Addr,
                                               PUCHAR StorageSpace)
{
    HRESULT Status = m_Server->
        DelCodeBreakpoint(*(IeXdiCodeBreakpoint**)StorageSpace);
    return Status;
}

HRESULT
UserTargetInfo::InsertCodeBreakpoint(PPROCESS_INFO Process,
                                     MachineInfo* Machine,
                                     PADDR Addr,
                                     PUCHAR StorageSpace)
{
    HRESULT Status;

    if (m_ServiceFlags & DBGSVC_GENERIC_CODE_BREAKPOINTS)
    {
        ULONG64 ChangeStart;
        ULONG ChangeLen;
        
        Status = Machine->
            InsertBreakpointInstruction(m_Services, Process->FullHandle,
                                        Flat(*Addr), StorageSpace,
                                        &ChangeStart, &ChangeLen);
        if ((Status == HRESULT_FROM_WIN32(ERROR_PARTIAL_COPY) ||
             Status == HRESULT_FROM_WIN32(ERROR_NOACCESS) ||
             Status == HRESULT_FROM_WIN32(ERROR_WRITE_FAULT)) &&
            (g_EngOptions & DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS))
        {
            HRESULT NewStatus;
            ULONG OldProtect;
            
            // Change the page protections to read-write and try again.
            NewStatus = m_Services->
                ProtectVirtual(Process->FullHandle, ChangeStart, ChangeLen,
                               PAGE_READWRITE, &OldProtect);
            if (NewStatus == S_OK)
            {
                // If the page was already writable there's no point in
                // retrying
                if ((OldProtect & (PAGE_READWRITE |
                                   PAGE_WRITECOPY |
                                   PAGE_EXECUTE_READWRITE |
                                   PAGE_EXECUTE_WRITECOPY)) == 0)
                {
                    NewStatus = Machine->
                        InsertBreakpointInstruction(m_Services,
                                                    Process->FullHandle,
                                                    Flat(*Addr), StorageSpace,
                                                    &ChangeStart, &ChangeLen);
                    if (NewStatus == S_OK)
                    {
                        Status = S_OK;
                    }
                }
            
                NewStatus = m_Services->
                    ProtectVirtual(Process->FullHandle, ChangeStart, ChangeLen,
                                   OldProtect, &OldProtect);
                if (NewStatus != S_OK)
                {
                    // Couldn't restore page permissions so fail.
                    if (Status == S_OK)
                    {
                        Machine->
                            RemoveBreakpointInstruction(m_Services,
                                                        Process->FullHandle,
                                                        Flat(*Addr),
                                                        StorageSpace,
                                                        &ChangeStart,
                                                        &ChangeLen);
                    }
                    
                    Status = NewStatus;
                }
            }
        }

        return Status;
    }
    else
    {
        return m_Services->
            InsertCodeBreakpoint(Process->FullHandle,
                                 Flat(*Addr), Machine->m_ExecTypes[0],
                                 StorageSpace, MAX_BREAKPOINT_LENGTH);
    }
}

HRESULT
UserTargetInfo::RemoveCodeBreakpoint(PPROCESS_INFO Process,
                                     MachineInfo* Machine,
                                     PADDR Addr,
                                     PUCHAR StorageSpace)
{
    HRESULT Status;

    if (m_ServiceFlags & DBGSVC_GENERIC_CODE_BREAKPOINTS)
    {
        ULONG64 ChangeStart;
        ULONG ChangeLen;

        Status = Machine->
            RemoveBreakpointInstruction(m_Services, Process->FullHandle,
                                        Flat(*Addr), StorageSpace,
                                        &ChangeStart, &ChangeLen);
        if ((Status == HRESULT_FROM_WIN32(ERROR_PARTIAL_COPY) ||
             Status == HRESULT_FROM_WIN32(ERROR_NOACCESS) ||
             Status == HRESULT_FROM_WIN32(ERROR_WRITE_FAULT)) &&
            (g_EngOptions & DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS))
        {
            HRESULT NewStatus;
            ULONG OldProtect;
            
            // Change the page protections to read-write and try again.
            NewStatus = m_Services->
                ProtectVirtual(Process->FullHandle, ChangeStart, ChangeLen,
                               PAGE_READWRITE, &OldProtect);
            if (NewStatus == S_OK)
            {
                // If the page was already writable there's no point in
                // retrying
                if ((OldProtect & (PAGE_READWRITE |
                                   PAGE_WRITECOPY |
                                   PAGE_EXECUTE_READWRITE |
                                   PAGE_EXECUTE_WRITECOPY)) == 0)
                {
                    NewStatus = Machine->
                        RemoveBreakpointInstruction(m_Services,
                                                    Process->FullHandle,
                                                    Flat(*Addr), StorageSpace,
                                                    &ChangeStart, &ChangeLen);
                    if (NewStatus == S_OK)
                    {
                        Status = S_OK;
                    }
                }
            
                NewStatus = m_Services->
                    ProtectVirtual(Process->FullHandle, ChangeStart, ChangeLen,
                                   OldProtect, &OldProtect);
                if (NewStatus != S_OK)
                {
                    // Couldn't restore page permissions so fail.
                    if (Status == S_OK)
                    {
                        Machine->
                            InsertBreakpointInstruction(m_Services,
                                                        Process->FullHandle,
                                                        Flat(*Addr),
                                                        StorageSpace,
                                                        &ChangeStart,
                                                        &ChangeLen);
                    }
                    
                    Status = NewStatus;
                }
            }
        }

        return Status;
    }
    else
    {
        return m_Services->
            RemoveCodeBreakpoint(Process->FullHandle,
                                 Flat(*Addr), Machine->m_ExecTypes[0],
                                 StorageSpace, MAX_BREAKPOINT_LENGTH);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\callback.h ===
//----------------------------------------------------------------------------
//
// Callback notification routines.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#ifndef __CALLBACK_H__
#define __CALLBACK_H__

//
// Notification compression support.  If the current notification
// level is above zero notifications are not actually sent
// to clients.  This allows code that knows it will be
// causing many similar notifications to bracket their operation
// with an increment/decrement, suppressing notifications
// during the bracket.
// Due to the counted nature it nests properly.
//
// This support is primarily for the Change* callbacks.
// Using it with the event callbacks is only partially supported.
//

extern ULONG g_EngNotify;

ULONG ExecuteEventCommand(ULONG EventStatus, DebugClient* Client,
                          PCSTR Command);

//
// Event callbacks.
//

HRESULT NotifyBreakpointEvent(ULONG Vote, Breakpoint* Bp);
HRESULT NotifyExceptionEvent(PEXCEPTION_RECORD64 Record,
                             ULONG FirstChance, BOOL OutputDone);
HRESULT NotifyCreateThreadEvent(ULONG64 Handle,
                                ULONG64 DataOffset,
                                ULONG64 StartOffset,
                                ULONG Flags);
HRESULT NotifyExitThreadEvent(ULONG ExitCode);
HRESULT NotifyCreateProcessEvent(ULONG64 ImageFileHandle,
                                 ULONG64 Handle,
                                 ULONG64 BaseOffset,
                                 ULONG ModuleSize,
                                 PSTR ModuleName,
                                 PSTR ImageName,
                                 ULONG CheckSum,
                                 ULONG TimeDateStamp,
                                 ULONG64 InitialThreadHandle,
                                 ULONG64 ThreadDataOffset,
                                 ULONG64 StartOffset,
                                 ULONG Flags,
                                 ULONG Options,
                                 ULONG InitialThreadFlags);
HRESULT NotifyExitProcessEvent(ULONG ExitCode);
HRESULT NotifyLoadModuleEvent(ULONG64 ImageFileHandle,
                              ULONG64 BaseOffset,
                              ULONG ModuleSize,
                              PSTR ModuleName,
                              PSTR ImageName,
                              ULONG CheckSum,
                              ULONG TimeDateStamp);
HRESULT NotifyUnloadModuleEvent(PCSTR ImageBaseName,
                                ULONG64 BaseOffset);
HRESULT NotifySystemErrorEvent(ULONG Error,
                               ULONG Level);
HRESULT NotifySessionStatus(ULONG Status);
    
void NotifyChangeDebuggeeState(ULONG Flags, ULONG64 Argument);
void NotifyChangeEngineState(ULONG Flags, ULONG64 Argument,
                             BOOL HaveEngineLock);
void NotifyChangeSymbolState(ULONG Flags, ULONG64 Argument,
                             PPROCESS_INFO Process);

//
// Input callbacks.
//

ULONG GetInput(PCSTR Prompt, PSTR Buffer, ULONG BufferSize);

//
// Output callbacks.
//

#define DEFAULT_OUT_MASK                                        \
    (DEBUG_OUTPUT_NORMAL | DEBUG_OUTPUT_ERROR |                 \
     DEBUG_OUTPUT_PROMPT | DEBUG_OUTPUT_PROMPT_REGISTERS |      \
     DEBUG_OUTPUT_WARNING | DEBUG_OUTPUT_EXTENSION_WARNING |    \
     DEBUG_OUTPUT_DEBUGGEE | DEBUG_OUTPUT_DEBUGGEE_PROMPT)

#define DEFAULT_OUT_HISTORY_MASK                                \
    (DEBUG_OUTPUT_NORMAL | DEBUG_OUTPUT_ERROR |                 \
     DEBUG_OUTPUT_PROMPT_REGISTERS |                            \
     DEBUG_OUTPUT_WARNING | DEBUG_OUTPUT_EXTENSION_WARNING |    \
     DEBUG_OUTPUT_DEBUGGEE | DEBUG_OUTPUT_DEBUGGEE_PROMPT)

#define OUT_BUFFER_SIZE (1024 * 16)

extern char g_OutBuffer[];
extern char g_FormatBuffer[];
extern char g_OutFilterPattern[MAX_IMAGE_PATH];
extern BOOL g_OutFilterResult;

// Bitwise-OR of all client's output masks for
// quick rejection of output that nobody cares about.
extern ULONG g_AllOutMask;

struct OutHistoryEntryHeader
{
    ULONG Mask;
};
typedef OutHistoryEntryHeader UNALIGNED* OutHistoryEntry;

extern PSTR g_OutHistory;
extern ULONG g_OutHistoryActualSize;
extern ULONG g_OutHistoryRequestedSize;
extern OutHistoryEntry g_OutHistRead, g_OutHistWrite;
extern ULONG g_OutHistoryMask;
extern ULONG g_OutHistoryUsed;

struct OutCtlSave
{
    ULONG OutputControl;
    DebugClient* Client;
    BOOL BufferOutput;
    ULONG OutputWidth;
    PCSTR OutputLinePrefix;
};

extern ULONG g_OutputControl;
extern DebugClient* g_OutputClient;
extern BOOL g_BufferOutput;

void CollectOutMasks(void);

BOOL PushOutCtl(ULONG OutputControl, DebugClient* Client,
                OutCtlSave* Save);
void PopOutCtl(OutCtlSave* Save);

void FlushCallbacks(void);
void TimedFlushCallbacks(void);
void SendOutputHistory(DebugClient* Client, ULONG HistoryLimit);

#define OUT_LINE_DEFAULT      0x00000000
#define OUT_LINE_NO_PREFIX    0x00000001
#define OUT_LINE_NO_TIMESTAMP 0x00000002

void StartOutLine(ULONG Mask, ULONG Flags);
BOOL TranslateFormat(LPSTR formatOut, LPCSTR format,
                     va_list args, ULONG formatOutSize);
void MaskOutVa(ULONG Mask, PCSTR Format, va_list Args, BOOL Translate);

void __cdecl dprintf(PCSTR, ...);
void __cdecl dprintf64(PCSTR, ...);
void __cdecl ErrOut(PCSTR, ...);
void __cdecl WarnOut(PCSTR, ...);
void __cdecl MaskOut(ULONG, PCSTR, ...);
void __cdecl VerbOut(PCSTR, ...);
void __cdecl BpOut(PCSTR, ...);
void __cdecl EventOut(PCSTR, ...);
void __cdecl KdOut(PCSTR, ...);

#endif // #ifndef __CALLBACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\callback.cpp ===
//----------------------------------------------------------------------------
//
// Callback notification routines.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

//----------------------------------------------------------------------------
//
// APC support for dispatching event callbacks on the proper thread.
//
//----------------------------------------------------------------------------

struct AnyApcData
{
    AnyApcData(ULONG Mask, PCSTR Name)
    {
        m_Mask = Mask;
        m_Name = Name;
    }
    
    ULONG m_Mask;
    PCSTR m_Name;

    virtual ULONG Dispatch(DebugClient* Client) = 0;
};

struct BreakpointEventApcData : public AnyApcData
{
    BreakpointEventApcData()
        : AnyApcData(DEBUG_EVENT_BREAKPOINT,
                     "IDebugEventCallbacks::Breakpoint")
    {
    }
    
    Breakpoint* m_Bp;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        if ((m_Bp->m_Flags & DEBUG_BREAKPOINT_ADDER_ONLY) == 0 ||
            Client == m_Bp->m_Adder)
        {
            return Client->m_EventCb->
                Breakpoint(m_Bp);
        }
        else
        {
            return DEBUG_STATUS_NO_CHANGE;
        }
    }
};

struct ExceptionEventApcData : public AnyApcData
{
    ExceptionEventApcData()
        : AnyApcData(DEBUG_EVENT_EXCEPTION,
                     "IDebugEventCallbacks::Exception")
    {
    }
    
    PEXCEPTION_RECORD64 m_Record;
    ULONG m_FirstChance;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            Exception(m_Record, m_FirstChance);
    }
};

struct CreateThreadEventApcData : public AnyApcData
{
    CreateThreadEventApcData()
        : AnyApcData(DEBUG_EVENT_CREATE_THREAD,
                     "IDebugEventCallbacks::CreateThread")
    {
    }
    
    ULONG64 m_Handle;
    ULONG64 m_DataOffset;
    ULONG64 m_StartOffset;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            CreateThread(m_Handle, m_DataOffset, m_StartOffset);
    }
};

struct ExitThreadEventApcData : public AnyApcData
{
    ExitThreadEventApcData()
        : AnyApcData(DEBUG_EVENT_EXIT_THREAD,
                     "IDebugEventCallbacks::ExitThread")
    {
    }
    
    ULONG m_ExitCode;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            ExitThread(m_ExitCode);
    }
};

struct CreateProcessEventApcData : public AnyApcData
{
    CreateProcessEventApcData()
        : AnyApcData(DEBUG_EVENT_CREATE_PROCESS,
                     "IDebugEventCallbacks::CreateProcess")
    {
    }
    
    ULONG64 m_ImageFileHandle;
    ULONG64 m_Handle;
    ULONG64 m_BaseOffset;
    ULONG m_ModuleSize;
    PCSTR m_ModuleName;
    PCSTR m_ImageName;
    ULONG m_CheckSum;
    ULONG m_TimeDateStamp;
    ULONG64 m_InitialThreadHandle;
    ULONG64 m_ThreadDataOffset;
    ULONG64 m_StartOffset;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            CreateProcess(m_ImageFileHandle, m_Handle, m_BaseOffset,
                          m_ModuleSize, m_ModuleName, m_ImageName,
                          m_CheckSum, m_TimeDateStamp, m_InitialThreadHandle,
                          m_ThreadDataOffset, m_StartOffset);
    }
};

struct ExitProcessEventApcData : public AnyApcData
{
    ExitProcessEventApcData()
        : AnyApcData(DEBUG_EVENT_EXIT_PROCESS,
                     "IDebugEventCallbacks::ExitProcess")
    {
    }
    
    ULONG m_ExitCode;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            ExitProcess(m_ExitCode);
    }
};

struct LoadModuleEventApcData : public AnyApcData
{
    LoadModuleEventApcData()
        : AnyApcData(DEBUG_EVENT_LOAD_MODULE,
                     "IDebugEventCallbacks::LoadModule")
    {
    }
    
    ULONG64 m_ImageFileHandle;
    ULONG64 m_BaseOffset;
    ULONG m_ModuleSize;
    PCSTR m_ModuleName;
    PCSTR m_ImageName;
    ULONG m_CheckSum;
    ULONG m_TimeDateStamp;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            LoadModule(m_ImageFileHandle, m_BaseOffset, m_ModuleSize,
                       m_ModuleName, m_ImageName, m_CheckSum,
                       m_TimeDateStamp);
    }
};

struct UnloadModuleEventApcData : public AnyApcData
{
    UnloadModuleEventApcData()
        : AnyApcData(DEBUG_EVENT_UNLOAD_MODULE,
                     "IDebugEventCallbacks::UnloadModule")
    {
    }
    
    PCSTR m_ImageBaseName;
    ULONG64 m_BaseOffset;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            UnloadModule(m_ImageBaseName, m_BaseOffset);
    }
};

struct SystemErrorEventApcData : public AnyApcData
{
    SystemErrorEventApcData()
        : AnyApcData(DEBUG_EVENT_SYSTEM_ERROR,
                     "IDebugEventCallbacks::SystemError")
    {
    }
    
    ULONG m_Error;
    ULONG m_Level;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            SystemError(m_Error, m_Level);
    }
};

struct SessionStatusApcData : public AnyApcData
{
    SessionStatusApcData()
        : AnyApcData(DEBUG_EVENT_SESSION_STATUS,
                     "IDebugEventCallbacks::SessionStatus")
    {
    }
    
    ULONG m_Status;
    
    virtual ULONG Dispatch(DebugClient* Client)
    {
        return Client->m_EventCb->
            SessionStatus(m_Status);
    }
};

ULONG
ApcDispatch(DebugClient* Client, AnyApcData* ApcData, ULONG EventStatus)
{
    DBG_ASSERT(Client->m_EventCb != NULL);

    HRESULT Vote;

    __try
    {
        Vote = ApcData->Dispatch(Client);
    }
    __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                      NULL, ApcData->m_Name))
    {
        Vote = DEBUG_STATUS_NO_CHANGE;
    }
            
    return MergeVotes(EventStatus, Vote);
}

void APIENTRY
EventApc(ULONG_PTR Param)
{
    AnyApcData* ApcData = (AnyApcData*)Param;
    ULONG Tid = GetCurrentThreadId();
    DebugClient* Client;
    ULONG EventStatus = DEBUG_STATUS_NO_CHANGE;

    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_ThreadId == Tid &&
            (Client->m_EventInterest & ApcData->m_Mask))
        {
            EventStatus = ApcDispatch(Client, ApcData, EventStatus);
        }
    }

    if (WaitForSingleObject(g_EventStatusWaiting, INFINITE) !=
        WAIT_OBJECT_0)
    {
        ErrOut("Unable to wait for StatusWaiting, %d\n",
               GetLastError());
        EventStatus = WIN32_LAST_STATUS();
    }

    g_EventStatus = EventStatus;
    
    if (!SetEvent(g_EventStatusReady))
    {
        ErrOut("Unable to set StatusReady, %d\n",
               GetLastError());
        g_EventStatus = WIN32_LAST_STATUS();
    }
}

ULONG
SendEvent(AnyApcData* ApcData, ULONG EventStatus)
{
    DebugClient* Client;
    ULONG NumQueued = 0;
    ULONG TidDone = 0;
    static ULONG s_TidSending = 0;

    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        // Only queue one APC per thread regardless of how
        // many clients.  The APC function will deliver the
        // callback to all clients on that thread.
        if (Client->m_ThreadId != TidDone &&
            (Client->m_EventInterest & ApcData->m_Mask))
        {
            // SessionStatus callbacks are made at unusual
            // times so do not do full call preparation.
            if (TidDone == 0 &&
                ApcData->m_Mask != DEBUG_EVENT_SESSION_STATUS)
            {
                PrepareForCalls(DEBUG_STATUS_INSIDE_WAIT);
            }

            if (Client->m_ThreadId == GetCurrentThreadId())
            {
                // Don't hold the engine lock while the client
                // is called.
                SUSPEND_ENGINE();
                
                EventStatus = ApcDispatch(Client, ApcData, EventStatus);

                RESUME_ENGINE();
            }
            else if (QueueUserAPC(EventApc, Client->m_Thread,
                                  (ULONG_PTR)ApcData))
            {
                TidDone = Client->m_ThreadId;
                NumQueued++;
            }
            else
            {
                ErrOut("Unable to deliver callback, %d\n", GetLastError());
            }
        }
    }

    if (NumQueued == 0)
    {
        // No APCs queued.
        return EventStatus;
    }

    // This function's use of global data is only safe as
    // long as a single send is active at once.  Synchronous
    // sends are almost exclusively sent by the session thread
    // so competition to send is very rare, therefore we
    // don't really attempt to handle it.
    if (s_TidSending != 0)
    {
        return E_FAIL;
    }
    s_TidSending = GetCurrentThreadId();

    // Leave the lock while waiting.
    SUSPEND_ENGINE();
    
    while (NumQueued-- > 0)
    {
        if (!SetEvent(g_EventStatusWaiting))
        {
            // If the event can't be set everything is hosed
            // and threads may be stuck waiting so we
            // just panic.
            ErrOut("Unable to set StatusWaiting, %d\n",
                   GetLastError());
            EventStatus = WIN32_LAST_STATUS();
            break;
        }

        for (;;)
        {
            ULONG Wait;
            
            Wait = WaitForSingleObjectEx(g_EventStatusReady,
                                         INFINITE, TRUE);
            if (Wait == WAIT_OBJECT_0)
            {
                EventStatus = MergeVotes(EventStatus, g_EventStatus);
                break;
            }
            else if (Wait != WAIT_IO_COMPLETION)
            {
                ErrOut("Unable to wait for StatusReady, %d\n",
                       GetLastError());
                EventStatus = WIN32_LAST_STATUS();
                NumQueued = 0;
                break;
            }
        }
    }

    RESUME_ENGINE();
    s_TidSending = 0;
    return EventStatus;
}

//----------------------------------------------------------------------------
//
// Event callbacks.
//
//----------------------------------------------------------------------------

ULONG g_EngNotify;

ULONG
ExecuteEventCommand(ULONG EventStatus, DebugClient* Client, PCSTR Command)
{
    if (Command == NULL)
    {
        return EventStatus;
    }
    
    // Don't output any noise while processing event
    // command strings.
    BOOL OldOutReg = g_OciOutputRegs;
    g_OciOutputRegs = FALSE;

    PrepareForCalls(DEBUG_STATUS_INSIDE_WAIT);
    // Stop execution as soon as the execution status
    // changes.
    g_EngStatus |= ENG_STATUS_NO_AUTO_WAIT;
        
    Execute(Client, Command, DEBUG_EXECUTE_NOT_LOGGED);
        
    g_EngStatus &= ~ENG_STATUS_NO_AUTO_WAIT;
    g_OciOutputRegs = OldOutReg;

    // Translate the continuation status from
    // the state the engine was left in by the command.
    if (IS_RUNNING(g_CmdState))
    {
        // If the command left the engine running override
        // the incoming event status.  This allows a user
        // to create conditional commands that can resume
        // execution even when the basic setting may be to break.
        return g_ExecutionStatusRequest;
    }
    else
    {
        return EventStatus;
    }
}

HRESULT
NotifyBreakpointEvent(ULONG Vote, Breakpoint* Bp)
{
    ULONG EventStatus;

    g_LastEventType = DEBUG_EVENT_BREAKPOINT;
    g_LastEventInfo.Breakpoint.Id = Bp->m_Id;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.Breakpoint);
    sprintf(g_LastEventDesc, "Hit breakpoint %d", Bp->m_Id);
    
    // Execute breakpoint command first if one exists.
    if (Bp->m_Command != NULL)
    {
        EventStatus = ExecuteEventCommand(DEBUG_STATUS_NO_CHANGE,
                                          Bp->m_Adder, Bp->m_Command);
    }
    else
    {
        if ((Bp->m_Flags & (BREAKPOINT_HIDDEN |
                            DEBUG_BREAKPOINT_ADDER_ONLY)) == 0)
        {
            StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_PREFIX);
            dprintf("Breakpoint %u hit\n", Bp->m_Id);
        }
        
        EventStatus = DEBUG_STATUS_NO_CHANGE;
    }

    BreakpointEventApcData ApcData;
    ApcData.m_Bp = Bp;
    EventStatus = SendEvent(&ApcData, EventStatus);

    // If there weren't any votes default to breaking in.
    if (EventStatus == DEBUG_STATUS_NO_CHANGE)
    {
        EventStatus = DEBUG_STATUS_BREAK;
    }

    // Fold command status into votes from previous breakpoints.
    return MergeVotes(Vote, EventStatus);
}

void
ProcessVcppException(PEXCEPTION_RECORD64 Record)
{
    EXCEPTION_VISUALCPP_DEBUG_INFO64 Info64;
    EXCEPTION_VISUALCPP_DEBUG_INFO64* Info;

    // If this is a 32-bit system we need to convert
    // back to a 32-bit exception record so that
    // we can properly reconstruct the info from
    // the arguments.
    if (!g_Machine->m_Ptr64)
    {
        EXCEPTION_RECORD32 Record32;
        EXCEPTION_VISUALCPP_DEBUG_INFO32* Info32;
        
        ExceptionRecord64To32(Record, &Record32);
        Info32 = (EXCEPTION_VISUALCPP_DEBUG_INFO32*)
            Record32.ExceptionInformation;
        Info = &Info64;
        Info->dwType = Info32->dwType;
        switch(Info->dwType)
        {
        case VCPP_DEBUG_SET_NAME:
            Info->SetName.szName = EXTEND64(Info32->SetName.szName);
            Info->SetName.dwThreadID = Info32->SetName.dwThreadID;
            Info->SetName.dwFlags = Info32->SetName.dwFlags;
            break;
        }
    }
    else
    {
        Info = (EXCEPTION_VISUALCPP_DEBUG_INFO64*)
            Record->ExceptionInformation;
    }

    PTHREAD_INFO Thread;
    
    switch(Info->dwType)
    {
    case VCPP_DEBUG_SET_NAME:
        if (Info->SetName.dwThreadID == -1)
        {
            Thread = g_EventThread;
        }
        else
        {
            Thread = FindThreadBySystemId(NULL, Info->SetName.dwThreadID);
        }
        if (Thread != NULL)
        {
            DWORD Read;
            
            if (g_Target->ReadVirtual(Info->SetName.szName, Thread->Name,
                                      MAX_THREAD_NAME - 1, &Read) != S_OK)
            {
                Thread->Name[0] = 0;
            }
            else
            {
                Thread->Name[Read] = 0;
            }
        }
        break;
    }
}

HRESULT
NotifyExceptionEvent(PEXCEPTION_RECORD64 Record,
                     ULONG FirstChance, BOOL OutputDone)
{
    ULONG EventStatus;
    EVENT_FILTER* Filter;
    EVENT_COMMAND* Command;
    PDEBUG_EXCEPTION_FILTER_PARAMETERS Params;

    g_LastEventType = DEBUG_EVENT_EXCEPTION;
    g_LastEventInfo.Exception.ExceptionRecord = *Record;
    g_LastEventInfo.Exception.FirstChance = FirstChance;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.Exception);
    sprintf(g_LastEventDesc, "Exception %X, %s chance",
            Record->ExceptionCode, FirstChance ? "first" : "second");

    if (Record->ExceptionCode == STATUS_VCPP_EXCEPTION)
    {
        // Handle special VC++ exceptions as they
        // pass information from the debuggee to the debugger.
        ProcessVcppException(Record);
    }
    
    Filter = GetSpecificExceptionFilter(Record->ExceptionCode);
    if (Filter == NULL)
    {
        // Use the default filter for name and handling.
        Filter = &g_EventFilters[FILTER_DEFAULT_EXCEPTION];
        GetOtherExceptionParameters(Record->ExceptionCode,
                                    &Params, &Command);
    }
    else
    {
        Params = &Filter->Params;
        Command = &Filter->Command;
    }

    g_EngDefer |= ENG_DEFER_EXCEPTION_HANDLING;
    g_EventExceptionFilter = Params;
    g_ExceptionFirstChance = FirstChance;
    
    if (Params->ExecutionOption != DEBUG_FILTER_IGNORE)
    {
        if (!OutputDone)
        {
            StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_PREFIX);
            dprintf("%s", Filter->Name);
            if (Filter->OutArgFormat != NULL)
            {
                dprintf(Filter->OutArgFormat,
                        Record->ExceptionInformation[Filter->OutArgIndex]);
            }

            dprintf(" - code %08lx (%s)\n",
                    Record->ExceptionCode,
                    FirstChance ? "first chance" : "!!! second chance !!!");
        }

        if (Params->ExecutionOption == DEBUG_FILTER_BREAK ||
            (Params->ExecutionOption == DEBUG_FILTER_SECOND_CHANCE_BREAK &&
             !FirstChance))
        {
            EventStatus = DEBUG_STATUS_BREAK;
        }
        else
        {
            EventStatus = DEBUG_STATUS_IGNORE_EVENT;
        }
    }
    else
    {
        EventStatus = DEBUG_STATUS_IGNORE_EVENT;
    }

    // If this is the initial breakpoint execute the
    // initial breakpoint command.
    if ((g_EngStatus & ENG_STATUS_AT_INITIAL_BREAK) &&
        IS_EFEXECUTION_BREAK(g_EventFilters[DEBUG_FILTER_INITIAL_BREAKPOINT].
                             Params.ExecutionOption))
    {
        EventStatus = ExecuteEventCommand
            (EventStatus,
             g_EventFilters[DEBUG_FILTER_INITIAL_BREAKPOINT].Command.Client,
             g_EventFilters[DEBUG_FILTER_INITIAL_BREAKPOINT].
             Command.Command[0]);
    }
    
    EventStatus = ExecuteEventCommand(EventStatus,
                                      Command->Client,
                                      Command->Command[FirstChance ? 0 : 1]);
    
    ExceptionEventApcData ApcData;
    ApcData.m_Record = Record;
    ApcData.m_FirstChance = FirstChance;
    return SendEvent(&ApcData, EventStatus);
}

HRESULT
NotifyCreateThreadEvent(ULONG64 Handle,
                        ULONG64 DataOffset,
                        ULONG64 StartOffset,
                        ULONG Flags)
{
    PPROCESS_INFO Process;
    
    StartOutLine(DEBUG_OUTPUT_VERBOSE, OUT_LINE_NO_PREFIX);
    VerbOut("*** Create thread %x:%x\n",
            g_EventProcessSysId, g_EventThreadSysId);

    if ((Process = FindProcessBySystemId(g_EventProcessSysId)) == NULL)
    {
        ErrOut("Unable to find system process %x\n", g_EventProcessSysId);

        if (g_EngNotify == 0)
        {
            // Put in a placeholder description to make it easy
            // to identify this case.
            g_LastEventType = DEBUG_EVENT_CREATE_THREAD;
            sprintf(g_LastEventDesc, "Create unowned thread %x for %x",
                    g_EventThreadSysId, g_EventProcessSysId);
        }
        
        // Can't really continue the notification.
        return DEBUG_STATUS_BREAK;
    }

    PTHREAD_INFO Thread;
    
    // There's a small window when attaching during process creation where
    // it's possible to get two create thread events for the
    // same thread.  Check and see if this process already has
    // a thread with the given ID and handle.
    // If a process attach times out and the process is examined,
    // there's a possibility that the attach may succeed later,
    // yielding events for processes and threads already created
    // by examination.  In that case just check for an ID match
    // as the handles will be different.

    for (Thread = Process->ThreadHead;
         Thread != NULL;
         Thread = Thread->Next)
    {
        if (((Process->Flags & ENG_PROC_EXAMINED) ||
             Thread->Handle == Handle) &&
            Thread->SystemId == g_EventThreadSysId)
        {
            // We already know about this thread, just
            // ignore the event.
            if ((Process->Flags & ENG_PROC_EXAMINED) == 0)
            {
                WarnOut("WARNING: Duplicate thread create event for %x:%x\n",
                        g_EventProcessSysId, g_EventThreadSysId);
            }
            return DEBUG_STATUS_IGNORE_EVENT;
        }
    }
    
    if (AddThread(Process, g_EventThreadSysId, Handle,
                  DataOffset, StartOffset, Flags) == NULL)
    {
        ErrOut("Unable to allocate thread record for create thread event\n");
        ErrOut("Thread %x:%x will be lost\n",
               g_EventProcessSysId, g_EventThreadSysId);

        if (g_EngNotify == 0)
        {
            // Put in a placeholder description to make it easy
            // to identify this case.
            g_LastEventType = DEBUG_EVENT_CREATE_THREAD;
            sprintf(g_LastEventDesc, "Can't create thread %x for %x",
                    g_EventThreadSysId, g_EventProcessSysId);
        }
        
        // Can't really continue the notification.
        return DEBUG_STATUS_BREAK;
    }
    
    // Look up infos now that they've been added.
    FindEventProcessThread();
    if (g_EventProcess == NULL || g_EventThread == NULL)
    {
        // This should never happen with the above failure
        // checks but handle it just in case.
        ErrOut("Create thread unable to locate process or thread %x:%x\n",
               g_EventProcessSysId, g_EventThreadSysId);
        return DEBUG_STATUS_BREAK;
    }

    VerbOut("Thread created: %lx.%lx\n",
            g_EventProcessSysId, g_EventThreadSysId);

    if (g_EngNotify > 0)
    {
        // This call is just to update internal thread state.
        // Do not make real callbacks.
        return DEBUG_STATUS_NO_CHANGE;
    }

    OutputProcessInfo("*** Create thread ***");

    g_LastEventType = DEBUG_EVENT_CREATE_THREAD;
    sprintf(g_LastEventDesc, "Create thread %d:%x",
            g_EventThread->UserId, g_EventThreadSysId);
    
    // Always update breakpoints to account for the new thread.
    SuspendExecution();
    RemoveBreakpoints();
    g_UpdateDataBreakpoints = TRUE;
    g_DataBreakpointsChanged = TRUE;
    
    ULONG EventStatus;
    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_CREATE_THREAD];

    EventStatus =
        IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) ?
        DEBUG_STATUS_BREAK : DEBUG_STATUS_IGNORE_EVENT;
    
    EventStatus = ExecuteEventCommand(EventStatus,
                                      Filter->Command.Client,
                                      Filter->Command.Command[0]);
    
    CreateThreadEventApcData ApcData;
    ApcData.m_Handle = Handle;
    ApcData.m_DataOffset = DataOffset;
    ApcData.m_StartOffset = StartOffset;
    return SendEvent(&ApcData, EventStatus);
}

HRESULT
NotifyExitThreadEvent(ULONG ExitCode)
{
    StartOutLine(DEBUG_OUTPUT_VERBOSE, OUT_LINE_NO_PREFIX);
    VerbOut("*** Exit thread\n");

    g_EngDefer |= ENG_DEFER_DELETE_EXITED;
    // There's a small possibility that exit events can
    // be delivered when the engine is not expecting them.
    // When attaching to a process that's exiting it's possible
    // to get an exit but no create.  When restarting it's
    // possible that not all events were successfully drained.
    // Protect this code from faulting in that case.
    if (g_EventThread == NULL)
    {
        WarnOut("WARNING: Unknown thread exit: %lx.%lx\n",
                g_EventProcessSysId, g_EventThreadSysId);
    }
    else
    {
        g_EventThread->Exited = TRUE;
    }
    VerbOut("Thread exited: %lx.%lx, code %X\n",
            g_EventProcessSysId, g_EventThreadSysId, ExitCode);

    g_LastEventType = DEBUG_EVENT_EXIT_THREAD;
    g_LastEventInfo.ExitThread.ExitCode = ExitCode;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.ExitThread);
    if (g_EventThread == NULL)
    {
        sprintf(g_LastEventDesc, "Exit thread ???:%x, code %X",
                g_EventThreadSysId, ExitCode);
    }
    else
    {
        sprintf(g_LastEventDesc, "Exit thread %d:%x, code %X",
                g_EventThread->UserId, g_EventThreadSysId, ExitCode);
    }
    
    ULONG EventStatus;
    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_EXIT_THREAD];

    EventStatus =
        IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) ?
        DEBUG_STATUS_BREAK : DEBUG_STATUS_IGNORE_EVENT;

    // If we were stepping on this thread then force a breakin
    // so it's clear to the user that the thread exited.
    if (g_EventThread != NULL &&
        (g_StepTraceBp->m_Flags & DEBUG_BREAKPOINT_ENABLED) &&
        (g_StepTraceBp->m_MatchThread == g_EventThread ||
         g_DeferBp->m_MatchThread == g_EventThread))
    {
        WarnOut("WARNING: Step/trace thread exited\n");
        g_WatchFunctions.End(NULL);
        EventStatus = DEBUG_STATUS_BREAK;
        // Ensure that p/t isn't repeated.
        g_LastCommand[0] = 0;
    }
    
    EventStatus = ExecuteEventCommand(EventStatus,
                                      Filter->Command.Client,
                                      Filter->Command.Command[0]);
    
    ExitThreadEventApcData ApcData;
    ApcData.m_ExitCode = ExitCode;
    return SendEvent(&ApcData, EventStatus);
}

HRESULT
NotifyCreateProcessEvent(ULONG64 ImageFileHandle,
                         ULONG64 Handle,
                         ULONG64 BaseOffset,
                         ULONG ModuleSize,
                         PSTR ModuleName,
                         PSTR ImageName,
                         ULONG CheckSum,
                         ULONG TimeDateStamp,
                         ULONG64 InitialThreadHandle,
                         ULONG64 ThreadDataOffset,
                         ULONG64 StartOffset,
                         ULONG Flags,
                         ULONG Options,
                         ULONG InitialThreadFlags)
{
    StartOutLine(DEBUG_OUTPUT_VERBOSE, OUT_LINE_NO_PREFIX);
    VerbOut("*** Create process %x\n", g_EventProcessSysId);

    PPROCESS_INFO Process;
    
    // If a process attach times out and the process is examined,
    // there's a possibility that the attach may succeed later,
    // yielding events for processes and threads already created
    // by examination.  In that case just check for an ID match
    // as the handles will be different.

    for (Process = g_ProcessHead;
         Process != NULL;
         Process = Process->Next)
    {
        if (((Process->Flags & ENG_PROC_EXAMINED) ||
             Process->FullHandle == Handle) &&
            Process->SystemId == g_EventProcessSysId)
        {
            // We already know about this process, just
            // ignore the event.
            if ((Process->Flags & ENG_PROC_EXAMINED) == 0)
            {
                WarnOut("WARNING: Duplicate process create event for %x\n",
                        g_EventProcessSysId);
            }
            return DEBUG_STATUS_IGNORE_EVENT;
        }
    }
    
    if (AddProcess(g_EventProcessSysId, Handle, g_EventThreadSysId,
                   InitialThreadHandle, ThreadDataOffset, StartOffset,
                   Flags, Options, InitialThreadFlags) == NULL)
    {
        ErrOut("Unable to allocate process record for create process event\n");
        ErrOut("Process %x will be lost\n", g_EventProcessSysId);

        if (g_EngNotify == 0)
        {
            // Put in a placeholder description to make it easy
            // to identify this case.
            g_LastEventType = DEBUG_EVENT_CREATE_PROCESS;
            sprintf(g_LastEventDesc, "Can't create process %x",
                    g_EventProcessSysId);
        }
        
        // Can't really continue the notification.
        return DEBUG_STATUS_BREAK;
    }
    
    // Look up infos now that they've been added.
    FindEventProcessThread();
    if (g_EventProcess == NULL || g_EventThread == NULL)
    {
        // This should never happen with the above failure
        // checks but handle it just in case.
        ErrOut("Create process unable to locate process or thread %x:%x\n",
               g_EventProcessSysId, g_EventThreadSysId);
        return DEBUG_STATUS_BREAK;
    }
    
    VerbOut("Process created: %lx.%lx\n",
            g_EventProcessSysId, g_EventThreadSysId);

    if (g_EngNotify > 0)
    {
        // This call is just to update internal process state.
        // Do not make real callbacks.
        g_EngStatus |= ENG_STATUS_PROCESSES_ADDED;
        return DEBUG_STATUS_NO_CHANGE;
    }
    
    OutputProcessInfo("*** Create process ***");

    g_LastEventType = DEBUG_EVENT_CREATE_PROCESS;
    sprintf(g_LastEventDesc, "Create process %d:%x",
            g_EventProcess->UserId, g_EventProcessSysId);
    
    // Simulate a load module event for the process but do
    // not send it to the client.
    g_EngNotify++;
    
    NotifyLoadModuleEvent(ImageFileHandle, BaseOffset, ModuleSize,
                          ModuleName, ImageName, CheckSum, TimeDateStamp);
    
    g_EngNotify--;

    ULONG EventStatus;
    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_CREATE_PROCESS];
    BOOL MatchesEvent;

    MatchesEvent = BreakOnThisImageTail(ImageName, Filter->Argument);

    EventStatus =
        (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
         MatchesEvent) ?
        DEBUG_STATUS_BREAK : DEBUG_STATUS_IGNORE_EVENT;

    if (MatchesEvent)
    {
        EventStatus = ExecuteEventCommand(EventStatus,
                                          Filter->Command.Client,
                                          Filter->Command.Command[0]);
    }
    
    g_EngStatus |= ENG_STATUS_PROCESSES_ADDED;
    
    CreateProcessEventApcData ApcData;
    ApcData.m_ImageFileHandle = ImageFileHandle;
    ApcData.m_Handle = Handle;
    ApcData.m_BaseOffset = BaseOffset;
    ApcData.m_ModuleSize = ModuleSize;
    ApcData.m_ModuleName = ModuleName;
    ApcData.m_ImageName = ImageName;
    ApcData.m_CheckSum = CheckSum;
    ApcData.m_TimeDateStamp = TimeDateStamp;
    ApcData.m_InitialThreadHandle = InitialThreadHandle;
    ApcData.m_ThreadDataOffset = ThreadDataOffset;
    ApcData.m_StartOffset = StartOffset;
    return SendEvent(&ApcData, EventStatus);
}

HRESULT
NotifyExitProcessEvent(ULONG ExitCode)
{
    StartOutLine(DEBUG_OUTPUT_VERBOSE, OUT_LINE_NO_PREFIX);
    VerbOut("*** Exit process\n");
    
    g_EngDefer |= ENG_DEFER_DELETE_EXITED;
    // There's a small possibility that exit events can
    // be delivered when the engine is not expecting them.
    // When attaching to a process that's exiting it's possible
    // to get an exit but no create.  When restarting it's
    // possible that not all events were successfully drained.
    // Protect this code from faulting in that case.
    if (g_EventProcess == NULL)
    {
        WarnOut("WARNING: Unknown process exit: %lx.%lx\n",
                g_EventProcessSysId, g_EventThreadSysId);
    }
    else
    {
        g_EventProcess->Exited = TRUE;
    }
    VerbOut("Process exited: %lx.%lx, code %X\n",
            g_EventProcessSysId, g_EventThreadSysId, ExitCode);

    g_LastEventType = DEBUG_EVENT_EXIT_PROCESS;
    g_LastEventInfo.ExitProcess.ExitCode = ExitCode;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.ExitProcess);
    if (g_EventProcess == NULL)
    {
        sprintf(g_LastEventDesc, "Exit process ???:%x, code %X",
                g_EventProcessSysId, ExitCode);
    }
    else
    {
        sprintf(g_LastEventDesc, "Exit process %d:%x, code %X",
                g_EventProcess->UserId, g_EventProcessSysId, ExitCode);
    }
    
    ULONG EventStatus;
    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_EXIT_PROCESS];
    BOOL MatchesEvent;

    if (g_EventProcess && g_EventProcess->ExecutableImage)
    {
        MatchesEvent =
            BreakOnThisImageTail(g_EventProcess->ExecutableImage->ImagePath,
                                 Filter->Argument);
    }
    else
    {
        // If this process doesn't have a specific name always break.
        MatchesEvent = TRUE;
    }
    
    EventStatus =
        ((g_EngOptions & DEBUG_ENGOPT_FINAL_BREAK) ||
         (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
          MatchesEvent)) ?
        DEBUG_STATUS_BREAK : DEBUG_STATUS_IGNORE_EVENT;

    if (MatchesEvent)
    {
        EventStatus = ExecuteEventCommand(EventStatus,
                                          Filter->Command.Client,
                                          Filter->Command.Command[0]);
    }
    
    ExitProcessEventApcData ApcData;
    ApcData.m_ExitCode = ExitCode;
    return SendEvent(&ApcData, EventStatus);
}

HRESULT
NotifyLoadModuleEvent(ULONG64 ImageFileHandle,
                      ULONG64 BaseOffset,
                      ULONG ModuleSize,
                      PSTR  ModuleName,
                      PSTR  ImagePathName,
                      ULONG CheckSum,
                      ULONG TimeDateStamp)
{
    MODULE_INFO_ENTRY ModEntry = {0};

    ModEntry.NamePtr       = ImagePathName;
    ModEntry.File          = (HANDLE)ImageFileHandle;
    ModEntry.Base          = BaseOffset;
    ModEntry.Size          = ModuleSize;
    ModEntry.CheckSum      = CheckSum;
    ModEntry.ModuleName    = ModuleName;
    ModEntry.TimeDateStamp = TimeDateStamp;

    AddImage(&ModEntry, FALSE);

    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_LOAD_MODULE];

    //
    // ntsd has always shown mod loads by default.
    //

    if (IS_USER_TARGET())
    {
        //if (Filter->Params.ExecutionOption == DEBUG_FILTER_OUTPUT)
        {
            StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_PREFIX);
            dprintf("ModLoad: %s %s   %-8s\n",
                    FormatAddr64(BaseOffset),
                    FormatAddr64(BaseOffset + ModuleSize),
                    ImagePathName);
        }
    }

    OutputProcessInfo("*** Load dll ***");

    if (g_EngNotify > 0)
    {
        g_EngStatus |= ENG_STATUS_MODULES_LOADED;
        return DEBUG_STATUS_IGNORE_EVENT;
    }
    
    g_LastEventType = DEBUG_EVENT_LOAD_MODULE;
    g_LastEventInfo.LoadModule.Base = BaseOffset;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.LoadModule);
    sprintf(g_LastEventDesc, "Load module %.*s at %s",
            MAX_IMAGE_PATH - 32, ImagePathName,
            FormatAddr64(BaseOffset));
    
    ULONG EventStatus;
    BOOL MatchesEvent;

    if ((g_EngStatus & ENG_STATUS_MODULES_LOADED) == 0)
    {
        g_EngStatus |= ENG_STATUS_AT_INITIAL_MODULE_LOAD;
    }
    
    MatchesEvent = BreakOnThisImageTail(ImagePathName, Filter->Argument);
    
    if ((IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
         MatchesEvent) ||
        ((g_EngOptions & DEBUG_ENGOPT_INITIAL_MODULE_BREAK) &&
         (g_EngStatus & ENG_STATUS_MODULES_LOADED) == 0))
    {
        EventStatus = DEBUG_STATUS_BREAK;
    }
    else
    {
        EventStatus = DEBUG_STATUS_IGNORE_EVENT;
    }

    // If this is the very first module load give breakpoints
    // a chance to get established.  Execute the initial
    // module command if there is one.
    if (g_EngStatus & ENG_STATUS_AT_INITIAL_MODULE_LOAD)
    {
        // On NT4 boot the breakpoint update and context management caused
        // by this seems to hit the system at a fragile time and
        // usually causes a bugcheck 50, so don't do it.  Win2K seems
        // to be able to handle it, so allow it there.
        if (IS_USER_TARGET() || g_ActualSystemVersion != NT_SVER_NT4)
        {
            SuspendExecution();
            RemoveBreakpoints();
            
            if (IS_EFEXECUTION_BREAK(g_EventFilters
                                     [DEBUG_FILTER_INITIAL_MODULE_LOAD].
                                     Params.ExecutionOption))
            {
                EventStatus = ExecuteEventCommand
                    (EventStatus,
                     g_EventFilters[DEBUG_FILTER_INITIAL_MODULE_LOAD].
                     Command.Client,
                     g_EventFilters[DEBUG_FILTER_INITIAL_MODULE_LOAD].
                     Command.Command[0]);
            }
        }
    }

    if (MatchesEvent)
    {
        EventStatus = ExecuteEventCommand(EventStatus,
                                          Filter->Command.Client,
                                          Filter->Command.Command[0]);
    }
    
    g_EngStatus |= ENG_STATUS_MODULES_LOADED;

    LoadModuleEventApcData ApcData;
    ApcData.m_ImageFileHandle = ImageFileHandle;
    ApcData.m_BaseOffset = BaseOffset;
    ApcData.m_ModuleSize = ModuleSize;
    ApcData.m_ModuleName = ModuleName;
    ApcData.m_ImageName = ImagePathName;
    ApcData.m_CheckSum = CheckSum;
    ApcData.m_TimeDateStamp = TimeDateStamp;
    EventStatus = SendEvent(&ApcData, EventStatus);

    if (EventStatus > DEBUG_STATUS_GO_NOT_HANDLED &&
        IS_KERNEL_TARGET() && g_ActualSystemVersion == NT_SVER_NT4)
    {
        WarnOut("WARNING: Any modification to state may cause bugchecks.\n");
        WarnOut("         The debugger will not write "
                "any register changes.\n");
    }
    
    return EventStatus;
}

HRESULT
NotifyUnloadModuleEvent(PCSTR ImageBaseName,
                        ULONG64 BaseOffset)
{
    PDEBUG_IMAGE_INFO Image = NULL;
    
    // First try to look up the image by the base offset
    // as that's the most reliable identifier.
    if (BaseOffset)
    {
        Image = GetImageByOffset(g_EventProcess, BaseOffset);
    }

    // Next try to look up the image by the full name given.
    if (!Image && ImageBaseName)
    {
        Image = GetImageByName(g_EventProcess, ImageBaseName,
                               INAME_IMAGE_PATH);

        // Finally try to look up the image by the tail of the name given.
        if (!Image)
        {
            Image = GetImageByName(g_EventProcess, PathTail(ImageBaseName),
                                   INAME_IMAGE_PATH_TAIL);
        }
    }

    if (Image)
    {
        ImageBaseName = Image->ImagePath;
        BaseOffset = Image->BaseOfImage;
        Image->Unloaded = TRUE;
        g_EngDefer |= ENG_DEFER_DELETE_EXITED;
    }
    
    g_LastEventType = DEBUG_EVENT_UNLOAD_MODULE;
    g_LastEventInfo.UnloadModule.Base = BaseOffset;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.UnloadModule);
    sprintf(g_LastEventDesc, "Unload module %.*s at %s",
            MAX_IMAGE_PATH - 32, ImageBaseName ? ImageBaseName : "<not found>",
            FormatAddr64(BaseOffset));
    
    ULONG EventStatus;
    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_UNLOAD_MODULE];
    BOOL MatchesEvent;

    if (Filter->Params.ExecutionOption == DEBUG_FILTER_OUTPUT)
    {
        StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_PREFIX);
        dprintf("%s\n", g_LastEventDesc);
    }

    MatchesEvent = BreakOnThisDllUnload(BaseOffset);
    
    if (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
        MatchesEvent)
    {
        EventStatus = DEBUG_STATUS_BREAK;
    }
    else
    {
        EventStatus = DEBUG_STATUS_IGNORE_EVENT;
    }

    if (MatchesEvent)
    {
        EventStatus = ExecuteEventCommand(EventStatus,
                                          Filter->Command.Client,
                                          Filter->Command.Command[0]);
    }
    
    UnloadModuleEventApcData ApcData;
    ApcData.m_ImageBaseName = ImageBaseName;
    ApcData.m_BaseOffset = BaseOffset;
    return SendEvent(&ApcData, EventStatus);
}

HRESULT
NotifySystemErrorEvent(ULONG Error,
                       ULONG Level)
{
    g_LastEventType = DEBUG_EVENT_SYSTEM_ERROR;
    g_LastEventInfo.SystemError.Error = Error;
    g_LastEventInfo.SystemError.Level = Level;
    g_LastEventExtraData = &g_LastEventInfo;
    g_LastEventExtraDataSize = sizeof(g_LastEventInfo.SystemError);
    sprintf(g_LastEventDesc, "System error %d.%d",
            Error, Level);
    
    if (Level <= g_SystemErrorOutput)
    {
        char ErrorString[_MAX_PATH];
        va_list Args;

        StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_PREFIX);
        dprintf("%s - %s: ", Level == SLE_WARNING ?
                "WARNING" : "ERROR", g_EventProcess->ImageHead->ImagePath);

        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                      FORMAT_MESSAGE_IGNORE_INSERTS,
                      NULL,
                      Error,
                      0,
                      ErrorString,
                      sizeof(ErrorString),
                      &Args);

        dprintf("%s", ErrorString);
    }
    
    ULONG EventStatus;
    EVENT_FILTER* Filter = &g_EventFilters[DEBUG_FILTER_SYSTEM_ERROR];

    if (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) ||
        Level <= g_SystemErrorBreak)
    {
        EventStatus = DEBUG_STATUS_BREAK;
    }
    else
    {
        EventStatus = DEBUG_STATUS_IGNORE_EVENT;
    }

    EventStatus = ExecuteEventCommand(EventStatus,
                                      Filter->Command.Client,
                                      Filter->Command.Command[0]);
    
    SystemErrorEventApcData ApcData;
    ApcData.m_Error = Error;
    ApcData.m_Level = Level;
    return SendEvent(&ApcData, EventStatus);
}
    
HRESULT
NotifySessionStatus(ULONG Status)
{
    SessionStatusApcData ApcData;
    ApcData.m_Status = Status;
    return SendEvent(&ApcData, DEBUG_STATUS_NO_CHANGE);
}

void
NotifyChangeDebuggeeState(ULONG Flags, ULONG64 Argument)
{
    if (g_EngNotify > 0)
    {
        // Notifications are being suppressed.
        return;
    }
    
    DebugClient* Client;

    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_EventInterest & DEBUG_EVENT_CHANGE_DEBUGGEE_STATE)
        {
            HRESULT Status;
            
            DBG_ASSERT(Client->m_EventCb != NULL);

            __try
            {
                Status = Client->m_EventCb->
                    ChangeDebuggeeState(Flags, Argument);
            }
            __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                              NULL, "IDebugEventCallbacks::"
                                              "ChangeDebuggeeState"))
            {
                Status = E_FAIL;
            }

            if (HRESULT_FACILITY(Status) == FACILITY_RPC)
            {
                Client->Destroy();
            }
        }
    }
}

void
NotifyChangeEngineState(ULONG Flags, ULONG64 Argument, BOOL HaveEngineLock)
{
    if (g_EngNotify > 0)
    {
        // Notifications are being suppressed.
        return;
    }

    DebugClient* Client;

    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_EventInterest & DEBUG_EVENT_CHANGE_ENGINE_STATE)
        {
            HRESULT Status;
            
            DBG_ASSERT(Client->m_EventCb != NULL);

            __try
            {
                Status = Client->m_EventCb->
                    ChangeEngineState(Flags, Argument);
            }
            __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                              NULL, "IDebugEventCallbacks::"
                                              "ChangeEngineState"))
            {
                Status = E_FAIL;
            }

            if (HRESULT_FACILITY(Status) == FACILITY_RPC)
            {
                Client->Destroy();
            }
        }
    }
}

void
NotifyChangeSymbolState(ULONG Flags, ULONG64 Argument, PPROCESS_INFO Process)
{
    if (g_EngNotify > 0)
    {
        // Notifications are being suppressed.
        return;
    }

    if ((Flags & (DEBUG_CSS_LOADS | DEBUG_CSS_UNLOADS)) &&
        Process)
    {
        // Reevaluate any offset expressions to account
        // for the change in symbols.
        EvaluateOffsetExpressions(Process, Flags);
    }
    
    DebugClient* Client;

    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_EventInterest & DEBUG_EVENT_CHANGE_SYMBOL_STATE)
        {
            HRESULT Status;
            
            DBG_ASSERT(Client->m_EventCb != NULL);

            __try
            {
                Status = Client->m_EventCb->
                    ChangeSymbolState(Flags, Argument);
            }
            __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                              NULL, "IDebugEventCallbacks::"
                                              "ChangeSymbolState"))
            {
                Status = E_FAIL;
            }

            if (HRESULT_FACILITY(Status) == FACILITY_RPC)
            {
                Client->Destroy();
            }
        }
    }
}

//----------------------------------------------------------------------------
//
// Input callbacks.
//
//----------------------------------------------------------------------------

ULONG
GetInput(PCSTR Prompt,
         PSTR Buffer,
         ULONG BufferSize)
{
    DebugClient* Client;
    ULONG Len;
    HRESULT Status;

    // Do not suspend the engine lock as this may be called
    // in the middle of an operation.
    
    // Start a new sequence for this input.
    g_InputSequence = 0;
    g_InputSizeRequested = BufferSize;
    
    if (Prompt != NULL && Prompt[0] != 0)
    {
        dprintf("%s", Prompt);
    }

    // Don't hold the engine locked while waiting.
    SUSPEND_ENGINE();
    
    // Begin the input process by notifying all
    // clients with input callbacks that input
    // is needed.
    
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        // Update the input sequence for all clients so that
        // clients that don't have input callbacks can still
        // return input.  This is necessary in some threading cases.
        Client->m_InputSequence = 1;
        if (Client->m_InputCb != NULL)
        {
            __try
            {
                Status = Client->m_InputCb->StartInput(BufferSize);
            }
            __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                              NULL, "IDebugInputCallbacks::"
                                              "StartInput"))
            {
                Status = E_FAIL;
            }

            if (Status != S_OK)
            {
                if (HRESULT_FACILITY(Status) == FACILITY_RPC)
                {
                    Client->Destroy();
                }
                else
                {
                    Len = 0;
                    ErrOut("Client %N refused StartInput, 0x%X\n",
                           Client, Status);
                    goto End;
                }
            }
        }
    }

    // Wait for input to be returned.
    if (WaitForSingleObject(g_InputEvent, INFINITE) != WAIT_OBJECT_0)
    {
        Len = 0;
        Status = WIN32_LAST_STATUS();
        ErrOut("Input event wait failed, 0x%X\n", Status);
    }
    else
    {
        ULONG CopyLen;
        
        Len = strlen(g_InputBuffer) + 1;
        CopyLen = min(Len, BufferSize);
        memcpy(Buffer, g_InputBuffer, CopyLen);
        Buffer[BufferSize - 1] = 0;
    }
    
 End:
    RESUME_ENGINE();
    
    g_InputSizeRequested = 0;
    
    // Notify all clients that input process is done.
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        Client->m_InputSequence = 0xffffffff;
        if (Client->m_InputCb != NULL)
        {
            __try
            {
                Client->m_InputCb->EndInput();
            }
            __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                              NULL, "IDebugInputCallbacks::"
                                              "EndInput"))
            {
            }
        }
    }

    return Len;
}

//----------------------------------------------------------------------------
//
// Output callbacks.
//
//----------------------------------------------------------------------------

char g_OutBuffer[OUT_BUFFER_SIZE], g_FormatBuffer[OUT_BUFFER_SIZE];

char g_OutFilterPattern[MAX_IMAGE_PATH];
BOOL g_OutFilterResult = TRUE;

ULONG g_AllOutMask;

// Don't split up entries if they'll result in data so
// small that the extra callbacks are worse than the wasted space.
#define MIN_HISTORY_ENTRY_SIZE (256 + sizeof(OutHistoryEntryHeader))

PSTR g_OutHistory;
ULONG g_OutHistoryActualSize;
ULONG g_OutHistoryRequestedSize = 512 * 1024;
ULONG g_OutHistWriteMask;
OutHistoryEntry g_OutHistRead, g_OutHistWrite;
ULONG g_OutHistoryMask;
ULONG g_OutHistoryUsed;

ULONG g_OutputControl = DEBUG_OUTCTL_ALL_CLIENTS;
DebugClient* g_OutputClient;
BOOL g_BufferOutput;

// The kernel silently truncates DbgPrints longer than
// 512 characters so don't buffer any more than that.
#define BUFFERED_OUTPUT_SIZE 512

// Largest delay allowed in TimedFlushCallbacks, in ticks.
#define MAX_FLUSH_DELAY 250

ULONG g_BufferedOutputMask;
char g_BufferedOutput[BUFFERED_OUTPUT_SIZE];
ULONG g_BufferedOutputUsed;
ULONG g_LastFlushTicks;

void
CollectOutMasks(void)
{
    DebugClient* Client;

    g_AllOutMask = 0;
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_OutputCb != NULL)
        {
            g_AllOutMask |= Client->m_OutMask;
        }
    }
}

BOOL
PushOutCtl(ULONG OutputControl, DebugClient* Client,
           OutCtlSave* Save)
{
    BOOL Status;

    FlushCallbacks();
    
    Save->OutputControl = g_OutputControl;
    Save->Client = g_OutputClient;
    Save->BufferOutput = g_BufferOutput;
    Save->OutputWidth = g_OutputWidth;
    Save->OutputLinePrefix = g_OutputLinePrefix;

    if (OutputControl == DEBUG_OUTCTL_AMBIENT)
    {
        // Leave settings unchanged.
        Status = TRUE;
    }
    else
    {
        ULONG SendMask = OutputControl & DEBUG_OUTCTL_SEND_MASK;
    
        if (
#if DEBUG_OUTCTL_THIS_CLIENT > 0
            SendMask < DEBUG_OUTCTL_THIS_CLIENT ||
#endif
            SendMask > DEBUG_OUTCTL_LOG_ONLY ||
            (OutputControl & ~(DEBUG_OUTCTL_SEND_MASK |
                               DEBUG_OUTCTL_NOT_LOGGED |
                               DEBUG_OUTCTL_OVERRIDE_MASK)))
        {
            Status = FALSE;
        }
        else
        {
            g_OutputControl = OutputControl;
            g_OutputClient = Client;
            g_BufferOutput = TRUE;
            if (Client != NULL)
            {
                g_OutputWidth = Client->m_OutputWidth;
                g_OutputLinePrefix = Client->m_OutputLinePrefix;
            }
            Status = TRUE;
        }
    }

    return Status;
}

void
PopOutCtl(OutCtlSave* Save)
{
    FlushCallbacks();
    g_OutputControl = Save->OutputControl;
    g_OutputClient = Save->Client;
    g_BufferOutput = Save->BufferOutput;
    g_OutputWidth = Save->OutputWidth;
    g_OutputLinePrefix = Save->OutputLinePrefix;
}

void
SendOutput(ULONG Mask, PCSTR Text)
{
    ULONG OutTo = g_OutputControl & DEBUG_OUTCTL_SEND_MASK;
    HRESULT Status;
    
    if (OutTo == DEBUG_OUTCTL_THIS_CLIENT)
    {
        if (g_OutputClient->m_OutputCb != NULL &&
            ((g_OutputControl & DEBUG_OUTCTL_OVERRIDE_MASK) ||
             (Mask & g_OutputClient->m_OutMask)))
        {
            __try
            {
                Status = g_OutputClient->m_OutputCb->Output(Mask, Text);
            }
            __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                              NULL, "IDebugOutputCallbacks::"
                                              "Output"))
            {
                Status = E_FAIL;
            }

            if (HRESULT_FACILITY(Status) == FACILITY_RPC)
            {
                g_OutputClient->Destroy();
            }
        }
    }
    else
    {
        DebugClient* Client;

        for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
        {
            if ((OutTo == DEBUG_OUTCTL_ALL_CLIENTS ||
                 Client != g_OutputClient) &&
                Client->m_OutputCb != NULL &&
                ((g_OutputControl & DEBUG_OUTCTL_OVERRIDE_MASK) ||
                 (Client->m_OutMask & Mask)))
            {
                __try
                {
                    Status = Client->m_OutputCb->Output(Mask, Text);
                }
                __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                                  NULL,
                                                  "IDebugOutputCallbacks::"
                                                  "Output"))
                {
                    Status = E_FAIL;
                }

                if (HRESULT_FACILITY(Status) == FACILITY_RPC)
                {
                    Client->Destroy();
                }
            }
        }
    }
}

void
BufferOutput(ULONG Mask, PCSTR Text, ULONG Len)
{
    EnterCriticalSection(&g_QuickLock);

    if (Mask != g_BufferedOutputMask ||
        g_BufferedOutputUsed + Len >= BUFFERED_OUTPUT_SIZE)
    {
        FlushCallbacks();

        if (Len >= BUFFERED_OUTPUT_SIZE)
        {
            SendOutput(Mask, Text);
            LeaveCriticalSection(&g_QuickLock);
            return;
        }

        g_BufferedOutputMask = Mask;
    }

    memcpy(g_BufferedOutput + g_BufferedOutputUsed, Text, Len + 1);
    g_BufferedOutputUsed += Len;
    
    LeaveCriticalSection(&g_QuickLock);
}

void
FlushCallbacks(void)
{
    EnterCriticalSection(&g_QuickLock);
    
    if (g_BufferedOutputUsed > 0)
    {
        SendOutput(g_BufferedOutputMask, g_BufferedOutput);
        g_BufferedOutputMask = 0;
        g_BufferedOutputUsed = 0;
        g_LastFlushTicks = GetTickCount();
    }

    LeaveCriticalSection(&g_QuickLock);
}

void
TimedFlushCallbacks(void)
{
    EnterCriticalSection(&g_QuickLock);

    if (g_BufferedOutputUsed > 0)
    {
        ULONG Ticks = GetTickCount();
    
        // Flush if the last flush was a "long" time ago.
        if (g_LastFlushTicks == 0 ||
            g_LastFlushTicks > Ticks ||
            (Ticks - g_LastFlushTicks) > MAX_FLUSH_DELAY)
        {
            FlushCallbacks();
        }
    }

    LeaveCriticalSection(&g_QuickLock);
}

#if 0
#define DBGHIST(Args) g_NtDllCalls.DbgPrint Args
#else
#define DBGHIST(Args)
#endif

void
WriteHistoryEntry(ULONG Mask, PCSTR Text, ULONG Len)
{
    PSTR Buf;

    DBG_ASSERT((PSTR)g_OutHistWrite + sizeof(OutHistoryEntryHeader) +
               Len + 1 <= g_OutHistory + g_OutHistoryActualSize);
    
    if (Mask != g_OutHistWriteMask)
    {
        // Start new entry.
        g_OutHistWrite->Mask = Mask;
        g_OutHistWriteMask = Mask;
        Buf = (PSTR)(g_OutHistWrite + 1);
        g_OutHistoryUsed += sizeof(OutHistoryEntryHeader);
        
        DBGHIST(("  Write new "));
    }
    else
    {
        // Merge with previous entry.
        Buf = (PSTR)g_OutHistWrite - 1;
        g_OutHistoryUsed--;

        DBGHIST(("  Merge old "));
    }

    DBGHIST(("entry %p:%X, %d\n", g_OutHistWrite, Mask, Len));
    
    // Len does not include the terminator here so
    // always append a terminator.
    memcpy(Buf, Text, Len);
    Buf += Len;
    *Buf++ = 0;

    g_OutHistWrite = (OutHistoryEntry)Buf;
    g_OutHistoryUsed += Len + 1;
    DBG_ASSERT(g_OutHistoryUsed <= g_OutHistoryActualSize);
}

void
AddToOutputHistory(ULONG Mask, PCSTR Text, ULONG Len)
{
    if (Len == 0 || g_OutHistoryRequestedSize == 0)
    {
        return;
    }

    if (g_OutHistory == NULL)
    {
        // Output history buffer hasn't been allocated yet,
        // so go ahead and do it now.
        g_OutHistory = (PSTR)malloc(g_OutHistoryRequestedSize);
        if (g_OutHistory == NULL)
        {
            return;
        }
        
        // Reserve space for a trailing header as terminator.
        g_OutHistoryActualSize = g_OutHistoryRequestedSize -
            sizeof(OutHistoryEntryHeader);
    }
 
    ULONG TotalLen = Len + sizeof(OutHistoryEntryHeader) + 1;

    DBGHIST(("Add %X, %d\n", Mask, Len));
    
    if (TotalLen > g_OutHistoryActualSize)
    {
        Text += TotalLen - g_OutHistoryActualSize;
        TotalLen = g_OutHistoryActualSize;
        Len = TotalLen - sizeof(OutHistoryEntryHeader) - 1;
    }
    
    if (g_OutHistWrite == NULL)
    {
        g_OutHistRead = (OutHistoryEntry)g_OutHistory;
        g_OutHistWrite = (OutHistoryEntry)g_OutHistory;
        g_OutHistWriteMask = 0;
    }

    while (Len > 0)
    {
        ULONG Left;

        if (g_OutHistoryUsed == 0 || g_OutHistWrite > g_OutHistRead)
        {
            Left = g_OutHistoryActualSize -
                (ULONG)((PSTR)g_OutHistWrite - g_OutHistory);

            if (TotalLen > Left)
            {
                // See if it's worth splitting this request to
                // fill the space at the end of the buffer.
                if (Left >= MIN_HISTORY_ENTRY_SIZE &&
                    (TotalLen - Left) >= MIN_HISTORY_ENTRY_SIZE)
                {
                    ULONG Used = Left - sizeof(OutHistoryEntryHeader) - 1;
                
                    // Pack as much data as possible into the
                    // end of the buffer.
                    WriteHistoryEntry(Mask, Text, Used);
                    Text += Used;
                    Len -= Used;
                    TotalLen -= Used;
                }

                // Terminate the buffer and wrap around.  A header's
                // worth of space is reserved at the buffer end so
                // there should always be enough space for this.
                DBG_ASSERT((ULONG)((PSTR)g_OutHistWrite - g_OutHistory) <=
                           g_OutHistoryActualSize);
                g_OutHistWrite->Mask = 0;
                g_OutHistWriteMask = 0;
                g_OutHistWrite = (OutHistoryEntry)g_OutHistory;
                Left = (ULONG)((PUCHAR)g_OutHistRead - (PUCHAR)g_OutHistWrite);
            }
        }
        else
        {
            Left = (ULONG)((PUCHAR)g_OutHistRead - (PUCHAR)g_OutHistWrite);
        }

        if (TotalLen > Left)
        {
            ULONG Need = TotalLen - Left;
        
            // Advance the read pointer to make room.
            while (Need > 0)
            {
                PSTR EntText = (PSTR)(g_OutHistRead + 1);
                ULONG EntTextLen = strlen(EntText);
                ULONG EntTotal =
                    sizeof(OutHistoryEntryHeader) + EntTextLen + 1;

                if (EntTotal <= Need ||
                    EntTotal - Need < MIN_HISTORY_ENTRY_SIZE)
                {
                    DBGHIST(("  Remove %p:%X, %d\n", g_OutHistRead,
                             g_OutHistRead->Mask, EntTextLen));
                    
                    // Remove the whole entry.
                    g_OutHistRead = (OutHistoryEntry)
                        ((PUCHAR)g_OutHistRead + EntTotal);
                    DBG_ASSERT((ULONG)((PSTR)g_OutHistRead - g_OutHistory) <=
                               g_OutHistoryActualSize);
                    if (g_OutHistRead->Mask == 0)
                    {
                        g_OutHistRead = (OutHistoryEntry)g_OutHistory;
                    }
                    
                    Need -= EntTotal <= Need ? EntTotal : Need;
                    DBG_ASSERT(g_OutHistoryUsed >= EntTotal);
                    g_OutHistoryUsed -= EntTotal;
                }
                else
                {
                    OutHistoryEntryHeader EntHdr = *g_OutHistRead;

                    DBGHIST(("  Trim %p:%X, %d\n", g_OutHistRead,
                             g_OutHistRead->Mask, EntTextLen));
                    
                    // Remove part of the head of the entry.
                    g_OutHistRead = (OutHistoryEntry)
                        ((PUCHAR)g_OutHistRead + Need);
                    DBG_ASSERT((ULONG)
                               ((PSTR)g_OutHistRead + (EntTotal - Need) -
                                g_OutHistory) <= g_OutHistoryActualSize);
                    *g_OutHistRead = EntHdr;
                    DBG_ASSERT(g_OutHistoryUsed >= Need);
                    g_OutHistoryUsed -= Need;
                    Need = 0;
                }

                DBGHIST(("  Advance read to %p:%X\n",
                         g_OutHistRead, g_OutHistRead->Mask));
            }
        }
        else
        {
            WriteHistoryEntry(Mask, Text, Len);
            break;
        }
    }
    
    DBGHIST(("History read %p, write %p, used %d\n",
             g_OutHistRead, g_OutHistWrite, g_OutHistoryUsed));
}

void
SendOutputHistory(DebugClient* Client, ULONG HistoryLimit)
{
    if (g_OutHistRead == NULL ||
        Client->m_OutputCb == NULL ||
        (Client->m_OutMask & g_OutHistoryMask) == 0 ||
        HistoryLimit == 0)
    {
        return;
    }

    FlushCallbacks();
    
    OutHistoryEntry Ent;
    ULONG Total;
    ULONG Len;

    Ent = g_OutHistRead;
    Total = 0;
    while (Ent != g_OutHistWrite)
    {
        if (Ent->Mask == 0)
        {
            Ent = (OutHistoryEntry)g_OutHistory;
        }

        PSTR Text = (PSTR)(Ent + 1);
        Len = strlen(Text);
        Total += Len;

        Ent = (OutHistoryEntry)(Text + Len + 1);
    }

    DBGHIST(("Total history %X\n", Total));
    
    Ent = g_OutHistRead;
    while (Ent != g_OutHistWrite)
    {
        if (Ent->Mask == 0)
        {
            Ent = (OutHistoryEntry)g_OutHistory;
        }

        PSTR Text = (PSTR)(Ent + 1);
        Len = strlen(Text);

        if (Total - Len <= HistoryLimit)
        {
            PSTR Part = Text;
            if (Total > HistoryLimit)
            {
                Part += Total - HistoryLimit;
            }
            
            DBGHIST(("Send %p:%X, %d\n",
                     Ent, Ent->Mask, strlen(Part)));

            Client->m_OutputCb->Output(Ent->Mask, Part);
        }

        Total -= Len;
        Ent = (OutHistoryEntry)(Text + Len + 1);
    }
}

void
StartOutLine(ULONG Mask, ULONG Flags)
{
    if ((Flags & OUT_LINE_NO_TIMESTAMP) == 0 &&
        g_EchoEventTimestamps)
    {
        MaskOut(Mask, "%s: ", TimeToStr((ULONG)time(NULL)));
    }
    
    if ((Flags & OUT_LINE_NO_PREFIX) == 0 &&
        g_OutputLinePrefix)
    {
        MaskOut(Mask, "%s", g_OutputLinePrefix);
    }
}

//
// Translates various printf formats to account for the target platform.
//
// This looks for %p type format and truncates the top 4 bytes of the ULONG64
// address argument if the debugee is a 32 bit machine.
// The %p is replaced by %I64x in format string.
//
BOOL
TranslateFormat(
    LPSTR formatOut,
    LPCSTR format,
    va_list args,
    ULONG formatOutSize
    )
{
#define Duplicate(j,i) (formatOut[j++] = format[i++])
    ULONG minSize = strlen(format), i = 0, j = 0;
    CHAR c;
    BOOL TypeFormat = FALSE;
    BOOL FormatChanged = FALSE;

    do
    {
        c = format[i];

        if (c=='%')
        {
            TypeFormat = !TypeFormat;
        }
        if (TypeFormat)
        {
            switch (c)
            {
            case 'c': case 'C': case 'i': case 'd':
            case 'o': case 'u': case 'x': case 'X':
                Duplicate(j,i);
                va_arg(args, int);
                TypeFormat = FALSE;
                break;
            case 'e': case 'E': case 'f': case 'g':
            case 'G':
                Duplicate(j,i);
                va_arg(args, double);
                TypeFormat = FALSE;
                break;
            case 'n':
                Duplicate(j,i);
                va_arg(args, int*);
                TypeFormat = FALSE;
                break;
            case 'N':
                // Native pointer, turns into %p.
                formatOut[j++] = 'p';
                FormatChanged = TRUE;
                i++;
                va_arg(args, void*);
                TypeFormat = FALSE;
                break;
            case 's': case 'S':
                Duplicate(j,i);
                va_arg(args, char*);
                TypeFormat = FALSE;
                break;

            case 'I':
                if ((format[i+1] == '6') && (format[i+2] == '4'))
                {
                    Duplicate(j,i);
                    Duplicate(j,i);
                    va_arg(args, ULONG64);
                    TypeFormat = FALSE;
                }
                // dprintf("I64 a0 %lx, off %lx\n", args.a0, args.offset);
                Duplicate(j,i);
                break;
            
            case 'z': case 'Z':
                // unicode string
                Duplicate(j,i);
                va_arg(args, void*);
                TypeFormat = FALSE;
                break;

            case 'p':
            case 'P':
                minSize +=3;
                if (format[i-1] == '%')
                {
                    minSize++;
                    if (g_Machine->m_Ptr64)
                    {
                        minSize += 2;
                        if (minSize > formatOutSize)
                        {
                            return FALSE;
                        }
                        formatOut[j++] = '0';
                        formatOut[j++] = '1';
                        formatOut[j++] = '6';
                    }
                    else
                    {
                        if (minSize > formatOutSize)
                        {
                            return FALSE;
                        }
                        formatOut[j++] = '0';
                        formatOut[j++] = '8';
                    }
                }

                if (minSize > formatOutSize)
                {
                    return FALSE;
                }
                formatOut[j++] = 'I';
                formatOut[j++] = '6';
                formatOut[j++] = '4';
                formatOut[j++] = (c == 'p') ? 'x' : 'X'; ++i;
                FormatChanged = TRUE;

                if (!g_Machine->m_Ptr64)
                {
                    PULONG64 Arg;

#ifdef  _M_ALPHA
                    Arg = (PULONG64) ((args.a0)+args.offset);
                    //dprintf("a0 %lx, off %lx\n", args.a0, args.offset);
#else
                    Arg = (PULONG64) (args);
#endif

                    //
                    // Truncate signextended addresses
                    //
                    *Arg = (ULONG64) (ULONG) *Arg;
                }

                va_arg(args, ULONG64);
                TypeFormat = FALSE;
                break;

            default:
                Duplicate(j,i);
            } /* switch */
        }
        else
        {
            Duplicate(j,i);
        }
    }
    while (format[i] != '\0');

    formatOut[j] = '\0';
    return FormatChanged;
#undef Duplicate
}

void
MaskOutVa(ULONG Mask, PCSTR Format, va_list Args, BOOL Translate)
{
    int Len;
    ULONG OutTo = g_OutputControl & DEBUG_OUTCTL_SEND_MASK;
    HRESULT Status;

    // Reject output as quickly as possible to avoid
    // doing the format translation and sprintf.
    if (OutTo == DEBUG_OUTCTL_IGNORE ||
        (((g_OutputControl & DEBUG_OUTCTL_NOT_LOGGED) ||
          (Mask & g_OutHistoryMask) == 0) &&
         ((g_OutputControl & DEBUG_OUTCTL_NOT_LOGGED) ||
          (Mask & g_LogMask) == 0 ||
          g_LogFile == -1) &&
         (OutTo == DEBUG_OUTCTL_LOG_ONLY ||
          ((g_OutputControl & DEBUG_OUTCTL_OVERRIDE_MASK) == 0 &&
           (OutTo == DEBUG_OUTCTL_THIS_CLIENT &&
            ((Mask & g_OutputClient->m_OutMask) == 0 ||
             g_OutputClient->m_OutputCb == NULL)) ||
           (Mask & g_AllOutMask) == 0))))
    {
        return;
    }

    // Do not suspend the engine lock as this may be called
    // in the middle of an operation.

    EnterCriticalSection(&g_QuickLock);
    
    __try
    {
        if (Translate &&
            TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1))
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                             g_FormatBuffer, Args);
        }
        else
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
        }

        // Check and see if this output is filtered away.
        if ((Mask & DEBUG_OUTPUT_DEBUGGEE) &&
            g_OutFilterPattern[0] &&
            !(MatchPattern(g_OutBuffer, g_OutFilterPattern) ==
              g_OutFilterResult))
        {
            __leave;
        }
        
        // If the caller doesn't think this output should
        // be logged it probably also shouldn't go in the
        // history.
        if ((g_OutputControl & DEBUG_OUTCTL_NOT_LOGGED) == 0 &&
            (Mask & g_OutHistoryMask))
        {
            AddToOutputHistory(Mask, g_OutBuffer, Len);
        }
        
        if ((g_OutputControl & DEBUG_OUTCTL_NOT_LOGGED) == 0 &&
            (Mask & g_LogMask) &&
            g_LogFile != -1)
        {
            _write(g_LogFile, g_OutBuffer, Len);
        }

        if (OutTo == DEBUG_OUTCTL_LOG_ONLY)
        {
            __leave;
        }

        if (g_BufferOutput)
        {
            BufferOutput(Mask, g_OutBuffer, Len);
        }
        else
        {
            SendOutput(Mask, g_OutBuffer);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        OutputDebugStringA("Exception in MaskOutVa\n");
    }

    LeaveCriticalSection(&g_QuickLock);
}

void __cdecl
MaskOut(ULONG Mask, PCSTR Format, ...)
{
    va_list Args;
    va_start(Args, Format);
    MaskOutVa(Mask, Format, Args, TRUE);
    va_end(Args);
}

void __cdecl
dprintf(PCSTR Format, ...)
{
    va_list Args;
    va_start(Args, Format);
    MaskOutVa(DEBUG_OUTPUT_NORMAL, Format, Args, FALSE);
    va_end(Args);
}

#define OUT_FN(Name, Mask)                      \
void __cdecl                                    \
Name(PCSTR Format, ...)                         \
{                                               \
    va_list Args;                               \
    va_start(Args, Format);                     \
    MaskOutVa(Mask, Format, Args, TRUE);        \
    va_end(Args);                               \
}

OUT_FN(dprintf64, DEBUG_OUTPUT_NORMAL)
OUT_FN(ErrOut,    DEBUG_OUTPUT_ERROR)
OUT_FN(WarnOut,   DEBUG_OUTPUT_WARNING)
OUT_FN(VerbOut,   DEBUG_OUTPUT_VERBOSE)
OUT_FN(BpOut,     DEBUG_IOUTPUT_BREAKPOINT)
OUT_FN(EventOut,  DEBUG_IOUTPUT_EVENT)
OUT_FN(KdOut,     DEBUG_IOUTPUT_KD_PROTOCOL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dbgadv.cpp ===
//----------------------------------------------------------------------------
//
// IDebugAdvanced implementation.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

STDMETHODIMP
DebugClient::GetThreadContext(
    THIS_
    OUT PVOID Context,
    IN ULONG ContextSize
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;
    
    ENTER_ENGINE();
    
    if ((Status = g_Machine->GetContextState(MCTX_FULL)) == S_OK)
    {
        Status = g_Machine->ConvertContextTo(&g_Machine->m_Context,
                                             g_SystemVersion, ContextSize,
                                             Context);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetThreadContext(
    THIS_
    IN PVOID Context,
    IN ULONG ContextSize
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;
    
    ENTER_ENGINE();

    if ((Status = g_Machine->GetContextState(MCTX_DIRTY)) == S_OK)
    {
        Status = g_Machine->ConvertContextFrom(&g_Machine->m_Context,
                                               g_SystemVersion, ContextSize,
                                               Context);
        if (Status == S_OK)
        {
            NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS, DEBUG_ANY_ID);
        }
    }

    LEAVE_ENGINE();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\brkpt.hpp ===
//----------------------------------------------------------------------------
//
// Breakpoint support.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef _BRKPT_HPP_
#define _BRKPT_HPP_

// Ways in which a breakpoint can be hit.  There's full
// match, hit but ignored and not hit.
#define BREAKPOINT_HIT         0
#define BREAKPOINT_HIT_IGNORED 1
#define BREAKPOINT_NOT_HIT     2

//----------------------------------------------------------------------------
//
// Breakpoint.
//
//----------------------------------------------------------------------------

#define BREAKPOINT_EXTERNAL_MODIFY_FLAGS \
    (DEBUG_BREAKPOINT_GO_ONLY | DEBUG_BREAKPOINT_ENABLED | \
     DEBUG_BREAKPOINT_ADDER_ONLY)
#define BREAKPOINT_EXTERNAL_FLAGS \
    (BREAKPOINT_EXTERNAL_MODIFY_FLAGS | DEBUG_BREAKPOINT_DEFERRED)

// Internal flags.
#define BREAKPOINT_KD_INTERNAL          0x80000000
#define BREAKPOINT_KD_COUNT_ONLY        0x40000000
#define BREAKPOINT_VIRT_ADDR            0x20000000
#define BREAKPOINT_INSERTED             0x10000000
#define BREAKPOINT_IN_LIST              0x08000000
#define BREAKPOINT_HIDDEN               0x04000000
#define BREAKPOINT_NOTIFY               0x02000000

// Internal types.
#define EXBS_NONE              0x00000000
#define EXBS_BREAKPOINT_DATA   0x00000001
#define EXBS_BREAKPOINT_CODE   0x00000002
#define EXBS_BREAKPOINT_ANY    0x00000003
#define EXBS_STEP_INSTRUCTION  0x00000004
#define EXBS_STEP_BRANCH       0x00000008
#define EXBS_STEP_ANY          0x0000000c
#define EXBS_ANY               0xffffffff

enum BreakpointMatchAction
{
    BREAKPOINT_ALLOW_MATCH,
    BREAKPOINT_WARN_MATCH,
    BREAKPOINT_REMOVE_MATCH
};
    
class Breakpoint
    : public IDebugBreakpoint
{
public:
    Breakpoint* m_Next;
    Breakpoint* m_Prev;
    ULONG m_Id;
    ULONG m_BreakType;
    ULONG m_Flags;
    ULONG m_DataSize;
    ULONG m_DataAccessType;
    ULONG m_PassCount;
    ULONG m_CurPassCount;
    PCSTR m_Command;
    PTHREAD_INFO m_MatchThread;
    PPROCESS_INFO m_Process;
    PCSTR m_OffsetExpr;
    DebugClient* m_Adder;
    ULONG64 m_MatchThreadData;
    ULONG64 m_MatchProcessData;

    Breakpoint(DebugClient* Adder, ULONG Id, ULONG Type, ULONG ProcType);
    ~Breakpoint(void);

    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
    
    // IDebugBreakpoint.
    STDMETHOD(GetId)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(GetType)(
        THIS_
        OUT PULONG BreakType,
        OUT PULONG ProcType
        );
    STDMETHOD(GetAdder)(
        THIS_
        OUT PDEBUG_CLIENT* Adder
        );
    STDMETHOD(GetFlags)(
        THIS_
        OUT PULONG Flags
        );
    STDMETHOD(AddFlags)(
        THIS_
        IN ULONG Flags
        );
    STDMETHOD(RemoveFlags)(
        THIS_
        IN ULONG Flags
        );
    STDMETHOD(SetFlags)(
        THIS_
        IN ULONG Flags
        );
    STDMETHOD(GetOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(SetOffset)(
        THIS_
        IN ULONG64 Offset
        );
    STDMETHOD(GetDataParameters)(
        THIS_
        OUT PULONG Size,
        OUT PULONG AccessType
        );
    STDMETHOD(SetDataParameters)(
        THIS_
        IN ULONG Size,
        IN ULONG AccessType
        );
    STDMETHOD(GetPassCount)(
        THIS_
        OUT PULONG Count
        );
    STDMETHOD(SetPassCount)(
        THIS_
        IN ULONG Count
        );
    STDMETHOD(GetCurrentPassCount)(
        THIS_
        OUT PULONG Count
        );
    STDMETHOD(GetMatchThreadId)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(SetMatchThreadId)(
        THIS_
        IN ULONG Id
        );
    STDMETHOD(GetCommand)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        );
    STDMETHOD(SetCommand)(
        THIS_
        IN PCSTR Command
        );
    STDMETHOD(GetOffsetExpression)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ExpressionSize
        );
    STDMETHOD(SetOffsetExpression)(
        THIS_
        IN PCSTR Expression
        );
    STDMETHOD(GetParameters)(
        THIS_
        OUT PDEBUG_BREAKPOINT_PARAMETERS Params
        );
    // Breakpoint.
    virtual HRESULT Validate(void) = 0;
    virtual HRESULT Insert(void) = 0;
    virtual HRESULT Remove(void) = 0;
    virtual ULONG IsHit(PADDR Addr) = 0;

    // Must resturn true if in case of THIS breakpoint hit
    // Pc points to the instruction caused the hit
    virtual BOOL PcAtHit() = 0;
    
    PADDR GetAddr(void)
    {
        return &m_Addr;
    }
    
    BOOL PassHit(void)
    {
        if (--m_CurPassCount == 0)
        {
            m_CurPassCount = 1;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    ULONG GetProcType(void)
    {
        return m_ProcType;
    }
    void SetProcType(ULONG ProcType)
    {
        m_ProcType = ProcType;
        m_ProcIndex = MachineTypeIndex(ProcType);
    }
    ULONG GetProcIndex(void)
    {
        return m_ProcIndex;
    }
    
    void ForceFlatAddr(void)
    {
        NotFlat(m_Addr);
        ComputeFlatAddress(&m_Addr, NULL);
    }

    // Breakpoint is enabled, not deferred, not internal.
    BOOL IsNormalEnabled(void)
    {
        return (m_Flags & (DEBUG_BREAKPOINT_ENABLED |
                           BREAKPOINT_KD_INTERNAL |
                           DEBUG_BREAKPOINT_DEFERRED)) ==
            DEBUG_BREAKPOINT_ENABLED;
    }

    void LinkIntoList(void);
    void UnlinkFromList(void);
    void UpdateInternal(void);
    BOOL EvalOffsetExpr(void);
    HRESULT SetAddr(PADDR Addr, BreakpointMatchAction MatchAction);
    // Matches breakpoints if they have the same insertion effect.
    // Used when determining whether a breakpoint needs to be
    // inserted or if another breakpoint is already covering the break.
    BOOL IsInsertionMatch(Breakpoint* Match);
    // Matches breakpoints if they have an insertion match and
    // if they match publicly, such as between flags, hiddenness
    // and so on.  Used when determining whether a user breakpoint
    // redefines an existing breakpoint.
    BOOL IsPublicMatch(Breakpoint* Match);
    // Check m_Match* fields against current state.
    BOOL MatchesCurrentState(void);

protected:
    // ProcType is private so that ProcType and ProcIndex can
    // be kept in sync.
    ULONG m_ProcType;
    MachineIndex m_ProcIndex;
    // Address is private to force users to go through SetAddr.
    ADDR m_Addr;
    ULONG m_CommandLen;
    ULONG m_OffsetExprLen;
    UCHAR m_InsertStorage[MAX_BREAKPOINT_LENGTH];
};

//----------------------------------------------------------------------------
//
// CodeBreakpoint.
//
//----------------------------------------------------------------------------

class CodeBreakpoint :
    public Breakpoint
{
public:
    CodeBreakpoint(DebugClient* Adder, ULONG Id, ULONG ProcType)
        : Breakpoint(Adder, Id, DEBUG_BREAKPOINT_CODE, ProcType)
    {
        m_Flags |= BREAKPOINT_VIRT_ADDR;
    }

    // Breakpoint.
    virtual HRESULT Validate(void);
    virtual HRESULT Insert(void);
    virtual HRESULT Remove(void);
    virtual ULONG IsHit(PADDR Addr);
    virtual BOOL PcAtHit()
    {
        return TRUE;
    }
};

//----------------------------------------------------------------------------
//
// DataBreakpoint.
//
//----------------------------------------------------------------------------

class DataBreakpoint :
    public Breakpoint
{
public:
    DataBreakpoint(DebugClient* Adder, ULONG Id, ULONG ProcType)
        : Breakpoint(Adder, Id, DEBUG_BREAKPOINT_DATA, ProcType) {}

    // Breakpoint.
    virtual HRESULT Insert(void);
    virtual HRESULT Remove(void);

    // DataBreakpoint.
    static void ClearThreadDataBreaks(PTHREAD_INFO Thread);
    void AddToThread(PTHREAD_INFO Thread);
};

//----------------------------------------------------------------------------
//
// X86DataBreakpoint.
//
//----------------------------------------------------------------------------

class X86DataBreakpoint :
    public DataBreakpoint
{
public:
    X86DataBreakpoint(DebugClient* Adder, ULONG Id,
                      ULONG Cr4Reg, ULONG Dr6Reg, ULONG ProcType)
        : DataBreakpoint(Adder, Id, ProcType)
    {
        m_Dr7Bits = 0;
        m_Cr4Reg = Cr4Reg;
        m_Dr6Reg = Dr6Reg;
    }

    // Breakpoint.
    virtual HRESULT Validate(void);
    virtual ULONG IsHit(PADDR Addr);

    virtual BOOL PcAtHit()
    {
        return FALSE;
    }

private:
    // Precomputed enable bits.
    ULONG m_Dr7Bits;
    
    // Register indices for getting breakpoint-related information.
    ULONG m_Cr4Reg;
    ULONG m_Dr6Reg;

    friend class X86MachineInfo;
    friend class Amd64MachineInfo;
};

//----------------------------------------------------------------------------
//
// Ia64DataBreakpoint.
//
//----------------------------------------------------------------------------

class Ia64DataBreakpoint :
    public DataBreakpoint
{
public:
    Ia64DataBreakpoint(DebugClient* Adder, ULONG Id)
        : DataBreakpoint(Adder, Id, IMAGE_FILE_MACHINE_IA64)
    {
        m_Control = 0;
    }

    // Breakpoint.
    virtual HRESULT Validate(void);
    virtual ULONG IsHit(PADDR Addr);
    virtual BOOL PcAtHit()
    {
        return TRUE;
    }

    static ULONG64 GetControl(ULONG AccessType, ULONG Size);

private:
    ULONG64 m_Control;

    friend class Ia64MachineInfo;
};

//----------------------------------------------------------------------------
//
// X86OnIa64DataBreakpoint.
//
//----------------------------------------------------------------------------
class X86OnIa64DataBreakpoint :
    public X86DataBreakpoint
{
public:
    X86OnIa64DataBreakpoint(DebugClient* Adder, ULONG Id);

    // Breakpoint.
    virtual HRESULT Validate(void);
    virtual ULONG IsHit(PADDR Addr);

private:
    ULONG64 m_Control;

    friend class Ia64MachineInfo;
};

extern BOOL g_BreakpointListChanged;
extern BOOL g_UpdateDataBreakpoints;
extern BOOL g_DataBreakpointsChanged;
extern BOOL g_BreakpointsSuspended;
extern BOOL g_DeferDefined;
extern Breakpoint* g_DeferBp;
extern Breakpoint* g_StepTraceBp;
extern CHAR g_StepTraceCmdState;
extern ADDR g_PrevRelatedPc;

HRESULT BreakpointInit(void);

HRESULT InsertBreakpoints(void);
BOOL RemoveBreakpoints(void);

HRESULT AddBreakpoint(DebugClient* Client,
                      ULONG Type,
                      ULONG DesiredId,
                      Breakpoint** Bp);
void RemoveBreakpoint(Breakpoint* Bp);
void RemoveProcessBreakpoints(PPROCESS_INFO Process);
void RemoveThreadBreakpoints(PTHREAD_INFO Thread);
void RemoveAllKernelBreakpoints(void);
void RemoveAllBreakpoints(ULONG Reason);

Breakpoint* GetBreakpointByIndex(DebugClient* Client, ULONG Index);
Breakpoint* GetBreakpointById(DebugClient* Client, ULONG Id);
Breakpoint* CheckMatchingBreakpoints(Breakpoint* Match, BOOL PUBLIC,
                                     ULONG IncFlags);
Breakpoint* CheckBreakpointHit(PPROCESS_INFO Process,
                               Breakpoint* Start, PADDR Addr,
                               ULONG ExbsType, ULONG IncFlags, ULONG ExcFlags,
                               PULONG HitType,
                               BOOL SetLastBreakpointHit);
ULONG NotifyHitBreakpoints(ULONG EventStatus);

void EvaluateOffsetExpressions(PPROCESS_INFO Process, ULONG Flags);

#define BPCMDS_FORCE_DISABLE 0x00000001
#define BPCMDS_ONE_LINE      0x00000002
#define BPCMDS_EXPR_ONLY     0x00000004
#define BPCMDS_MODULE_HINT   0x00000008

void ChangeBreakpointState(DebugClient* Client, PPROCESS_INFO ForProcess,
                           ULONG Id, UCHAR StateChange);
void ListBreakpoints(DebugClient* Client, PPROCESS_INFO ForProcess,
                     ULONG Id);
void ListBreakpointsAsCommands(DebugClient* Client, PPROCESS_INFO Process,
                               ULONG Flags);
PDEBUG_BREAKPOINT ParseBpCmd(DebugClient* Client, UCHAR Type,
                             PTHREAD_INFO Thread);
BOOL CheckBreakpointInsertedInRange(PPROCESS_INFO Process,
                                    ULONG64 Start, ULONG64 End);

void DbgKdpAcquireHardwareBp(PDBGKD_CONTROL_REQUEST BpRequest);
void DbgKdpReleaseHardwareBp(PDBGKD_CONTROL_REQUEST BpRequest);

#endif // #ifndef _BRKPT_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dbgctrl.cpp ===
//----------------------------------------------------------------------------
//
// IDebugControl implementation.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

ULONG g_LogMask = DEFAULT_OUT_MASK;

STDMETHODIMP
DebugClient::GetInterrupt(
    THIS
    )
{
    // This method is reentrant.
    return CheckUserInterrupt() ? S_OK : S_FALSE;
}

STDMETHODIMP
DebugClient::SetInterrupt(
    THIS_
    IN ULONG Flags
    )
{
    // This method is reentrant.

    if (
#if DEBUG_INTERRUPT_ACTIVE > 0
        Flags < DEBUG_INTERRUPT_ACTIVE ||
#endif
        Flags > DEBUG_INTERRUPT_EXIT)
    {
        return E_INVALIDARG;
    }

    if (!IS_TARGET_SET())
    {
        return E_UNEXPECTED;
    }

    // If the debuggee isn't currently running
    // we just need to set the operation-interrupt
    // flag.  If this is a passive interrupt that's
    // all that's ever done.
    if (Flags == DEBUG_INTERRUPT_PASSIVE ||
        (IS_MACHINE_SET() && g_CmdState == 'c'))
    {
        g_EngStatus |= ENG_STATUS_USER_INTERRUPT;
        return S_OK;
    }

    // If this is an exit interrupt we don't want
    // to actually interrupt the running debuggee,
    // we just want to terminate the current wait.
    if (Flags == DEBUG_INTERRUPT_EXIT)
    {
        g_EngStatus |= ENG_STATUS_EXIT_CURRENT_WAIT;
        return S_OK;
    }
    
    //
    // Force a break-in.  Don't set user-interrupt in
    // this case as that's just a marker for
    // interrupting commands.  Setting it can
    // interfere with break-in processing since commands
    // executed during break-in may be affected by it.
    //
    
    HRESULT Status = g_Target->RequestBreakIn();

    if (Status == S_OK)
    {
        g_EngStatus |= ENG_STATUS_PENDING_BREAK_IN;
    }

    return Status;
}

STDMETHODIMP
DebugClient::GetInterruptTimeout(
    THIS_
    OUT PULONG Seconds
    )
{
    ENTER_ENGINE();

    *Seconds = g_PendingBreakInTimeoutLimit;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetInterruptTimeout(
    THIS_
    IN ULONG Seconds
    )
{
    if (Seconds < 1)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    g_PendingBreakInTimeoutLimit = Seconds;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetLogFile(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG FileSize,
    OUT PBOOL Append
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_OpenLogFileName[0])
    {
        Status = E_NOINTERFACE;
        *Append = FALSE;
    }
    else
    {
        Status = FillStringBuffer(g_OpenLogFileName, 0,
                                  Buffer, BufferSize, FileSize);
        *Append = g_OpenLogFileAppended;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OpenLogFile(
    THIS_
    IN PCSTR File,
    IN BOOL Append
    )
{
    ENTER_ENGINE();

    ::OpenLogFile(File, Append);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::CloseLogFile(
    THIS
    )
{
    ENTER_ENGINE();

    fnLogClose();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetLogMask(
    THIS_
    OUT PULONG Mask
    )
{
    // This method is reentrant.
    *Mask = g_LogMask;
    return S_OK;
}

STDMETHODIMP
DebugClient::SetLogMask(
    THIS_
    IN ULONG Mask
    )
{
    // This method is reentrant.
    g_LogMask = Mask;
    return S_OK;
}

STDMETHODIMP
DebugClient::Input(
    THIS_
    OUT PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG InputSize
    )
{
    if (BufferSize < 2)
    {
        // Must have space for at least a character and a terminator.
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    ULONG Size;

    Size = GetInput(NULL, Buffer, BufferSize);
    if (Size == 0)
    {
        return E_FAIL;
    }

    if (InputSize != NULL)
    {
        *InputSize = Size;
    }

    LEAVE_ENGINE();
    return Size > BufferSize ? S_FALSE : S_OK;
}

STDMETHODIMP
DebugClient::ReturnInput(
    THIS_
    IN PCSTR Buffer
    )
{
    // This method is reentrant.

    HRESULT Status;
    ULONG Seq = (ULONG)InterlockedIncrement((PLONG)&g_InputSequence);
    if (Seq == m_InputSequence)
    {
        ULONG CopyLen = strlen(Buffer) + 1;
        CopyLen = min(CopyLen, INPUT_BUFFER_SIZE);
        memcpy(g_InputBuffer, Buffer, CopyLen);
        g_InputBuffer[INPUT_BUFFER_SIZE - 1] = 0;
        SetEvent(g_InputEvent);
        Status = S_OK;
    }
    else
    {
        Status = S_FALSE;
    }

    m_InputSequence = 0xffffffff;
    return Status;
}

STDMETHODIMPV
DebugClient::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    ENTER_ENGINE();

    va_list Args;

    va_start(Args, Format);
    MaskOutVa(Mask, Format, Args, TRUE);
    va_end(Args);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::OutputVaList(
    THIS_
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    ENTER_ENGINE();

    MaskOutVa(Mask, Format, Args, TRUE);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMPV
DebugClient::ControlledOutput(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        va_list Args;

        va_start(Args, Format);
        MaskOutVa(Mask, Format, Args, TRUE);
        va_end(Args);

        Status = S_OK;
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ControlledOutputVaList(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        MaskOutVa(Mask, Format, Args, TRUE);

        Status = S_OK;
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMPV
DebugClient::OutputPrompt(
    THIS_
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    ...
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        va_list Args;

        va_start(Args, Format);
        ::OutputPrompt(Format, Args);
        va_end(Args);

        Status = S_OK;
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OutputPromptVaList(
    THIS_
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    IN va_list Args
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        ::OutputPrompt(Format, Args);

        Status = S_OK;
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetPromptText(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG TextSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = ::GetPromptText(Buffer, BufferSize, TextSize);

    LEAVE_ENGINE();
    return Status;
}

#define CURRENT_ALL DEBUG_CURRENT_DEFAULT

STDMETHODIMP
DebugClient::OutputCurrentState(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Flags
    )
{
    if (Flags & ~CURRENT_ALL)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        ULONG Oci = 0;

        if (Flags & DEBUG_CURRENT_SYMBOL)
        {
            Oci |= OCI_SYMBOL;
        }
        if (Flags & DEBUG_CURRENT_DISASM)
        {
            Oci |= OCI_DISASM | OCI_ALLOW_EA;
        }
        if (Flags & DEBUG_CURRENT_REGISTERS)
        {
            Oci |= OCI_ALLOW_REG;
        }
        if (Flags & DEBUG_CURRENT_SOURCE_LINE)
        {
            Oci |= OCI_ALLOW_SOURCE;
        }

        OutCurInfo(Oci, g_Machine->m_AllMask, DEBUG_OUTPUT_PROMPT_REGISTERS);

        Status = S_OK;
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OutputVersionInformation(
    THIS_
    IN ULONG OutputControl
    )
{
    HRESULT Status;

    // This method is reentrant.  It uses many pieces of
    // global information, though, so try and get
    // the engine lock.

    Status = TRY_ENTER_ENGINE();
    if (Status != S_OK)
    {
        return Status;
    }

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        return E_INVALIDARG;
    }

    ::OutputVersionInformation(this);

    PopOutCtl(&OldCtl);
    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetNotifyEventHandle(
    THIS_
    OUT PULONG64 Handle
    )
{
    ENTER_ENGINE();

    *Handle = (ULONG64)g_EventToSignal;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetNotifyEventHandle(
    THIS_
    IN ULONG64 Handle
    )
{
    if ((ULONG64)(HANDLE)Handle != Handle)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    g_EventToSignal = (HANDLE)Handle;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::Assemble(
    THIS_
    IN ULONG64 Offset,
    IN PCSTR Instr,
    OUT PULONG64 EndOffset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    __try
    {
        if (!IS_CONTEXT_ACCESSIBLE())
        {
            Status = E_UNEXPECTED;
            __leave;
        }

        ADDR Addr;

        // Assume this is a code segment address so that assembly
        // picks up the appropriate type of address.
        g_Machine->FormAddr(SEGREG_CODE, Offset,
                            FORM_SEGREG | FORM_CODE, &Addr);

        g_Machine->Assemble(&Addr, (PSTR)Instr);
        *EndOffset = Flat(Addr);
        Status = S_OK;
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        Status = E_FAIL;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::Disassemble(
    THIS_
    IN ULONG64 Offset,
    IN ULONG Flags,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DisassemblySize,
    OUT PULONG64 EndOffset
    )
{
    if (Flags & ~DEBUG_DISASM_EFFECTIVE_ADDRESS)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ADDR Addr;
        CHAR Disasm[MAX_DISASM_LEN];

        // Assume this is a code segment address so that disassembly
        // picks up the appropriate type of address.
        g_Machine->FormAddr(SEGREG_CODE, Offset, FORM_SEGREG | FORM_CODE,
                            &Addr);

        g_Machine->Disassemble(&Addr, Disasm,
                               (Flags & DEBUG_DISASM_EFFECTIVE_ADDRESS));
        Status = FillStringBuffer(Disasm, 0,
                                  Buffer, BufferSize, DisassemblySize);
        *EndOffset = Flat(Addr);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetDisassembleEffectiveOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ADDR Addr;

        g_Machine->GetEffectiveAddr(&Addr);
        *Offset = Flat(Addr);
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
DoOutputDisassembly(PADDR Addr, ULONG Flags,
                    ULONG SkipLines, ULONG OutputLines,
                    PULONG LineCount)
{
    ULONG Lines = 0;
    CHAR Buffer[MAX_DISASM_LEN];
    PCHAR FirstLine;
    HRESULT Status;

    if (Flags & DEBUG_DISASM_MATCHING_SYMBOLS)
    {
        ULONG64 Disp;
        GetSymbolStdCall(Flat(*Addr), Buffer, sizeof(Buffer), &Disp, NULL);
        if (Disp == 0)
        {
            if (OutputLines > 0)
            {
                if (SkipLines == 0)
                {
                    StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_TIMESTAMP);
                    dprintf("%s:\n", Buffer);
                    OutputLines--;
                }
                else
                {
                    SkipLines--;
                }
            }

            Lines++;
        }
    }

    FirstLine = Buffer;

    if (!g_Machine->
        Disassemble(Addr, Buffer,
                    (Flags & DEBUG_DISASM_EFFECTIVE_ADDRESS) != 0))
    {
        // Return S_FALSE if the disassembly failed.
        // Output will still be produced, such as "???".
        // Update the address to the next potential instruction
        // locations so that callers that are satisfied with "???"
        // can just iterate.
        g_Machine->IncrementBySmallestInstruction(Addr);
        Lines++;
        Status = S_FALSE;
        if (SkipLines > 0 || OutputLines == 0)
        {
            *FirstLine = 0;
        }
    }
    else
    {
        PSTR Nl = Buffer;
        PSTR LastLine = Nl;

        // Count lines in output and determine line positions.
        while (*Nl)
        {
            Nl = strchr(Nl, '\n');
            DBG_ASSERT(Nl != NULL);

            Lines++;
            Nl++;
            if (SkipLines > 0)
            {
                FirstLine = Nl;
                SkipLines--;
            }
            if (OutputLines > 0)
            {
                LastLine = Nl;
                OutputLines--;
            }
        }

        *LastLine = 0;
        Status = S_OK;
    }

    if (*FirstLine)
    {
        StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_TIMESTAMP);
        dprintf("%s", FirstLine);
    }

    if (LineCount != NULL)
    {
        *LineCount = Lines;
    }

    return Status;
}

#define ALL_DISASM_FLAGS \
    (DEBUG_DISASM_EFFECTIVE_ADDRESS | DEBUG_DISASM_MATCHING_SYMBOLS)

STDMETHODIMP
DebugClient::OutputDisassembly(
    THIS_
    IN ULONG OutputControl,
    IN ULONG64 Offset,
    IN ULONG Flags,
    OUT PULONG64 EndOffset
    )
{
    if (Flags & ~ALL_DISASM_FLAGS)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    ADDR Addr;

    // Assume this is a code segment address so that disassembly
    // picks up the appropriate type of address.
    g_Machine->FormAddr(SEGREG_CODE, Offset, FORM_SEGREG | FORM_CODE, &Addr);

    Status = DoOutputDisassembly(&Addr, Flags, 0, 0xffffffff, NULL);
    *EndOffset = Flat(Addr);

    PopOutCtl(&OldCtl);
 Exit:
    LEAVE_ENGINE();
    return Status;
}

ULONG
BackUpDisassemblyLines(ULONG Lines, PADDR Addr, ULONG Flags, PADDR PcAddr)
{
    //
    // There's no easy way to predict how many lines of
    // output a particular disassembly will take so
    // just iteratively back up by the minimum amount until
    // the appropriate number of lines is reached.
    //

    ADDR BackAddr = *Addr;

    // Limit things so that failure can be detected.
    // Right now X86's maximum instruction length of 16
    // is big enough for all platforms so use that.
    ADDR LimitAddr = *Addr;
    ULONG BackBytes = X86_MAX_INSTRUCTION_LEN * Lines;
    if (BackBytes > LimitAddr.off)
    {
        LimitAddr.off = 0;
    }
    else
    {
        AddrSub(&LimitAddr, BackBytes);
    }
    
    ADDR TryAddr;
    ULONG TryLines;

    //
    // Reverse disassembly is difficult on x86 due
    // to the variable length instructions.  First
    // just locate the nearest symbol and disassemble
    // from that since this has a better chance of
    // producing a valid disassembly.
    //
    
    CHAR Buffer[MAX_DISASM_LEN];
    ULONG64 Disp;
    ADDR DisAddr, StartAddr;
    
    GetSymbolStdCall(Flat(LimitAddr), Buffer, sizeof(Buffer), &Disp, NULL);
    ADDRFLAT(&DisAddr, Disp);
    if (!AddrEqu(LimitAddr, DisAddr) &&
        Disp <= 16 * X86_MAX_INSTRUCTION_LEN)  // valid symbol
    {
        BOOL DoOneMore = FALSE;
        
        StartAddr = LimitAddr;
        AddrSub(&StartAddr, Disp);

        TryAddr = StartAddr;
        TryLines = 0;
        while (1)
        {
            ULONG DisLines;
            ULONG DisFlags;

            while (AddrLt(TryAddr, *Addr) && ((TryLines < Lines) || DoOneMore))
            {
                UCHAR MemTest;
                
                // If we can't read memory at this address there's
                // no chance of getting a valid disassembly so
                // just stop the whole process.
                if (!GetMemByte(&TryAddr, &MemTest))
                {
                    TryAddr = *Addr;
                    break;
                }
                
                DisFlags = Flags;
                if (!AddrEqu(TryAddr, *PcAddr))
                {
                    DisFlags &= ~DEBUG_DISASM_EFFECTIVE_ADDRESS;
                }
                DoOutputDisassembly(&TryAddr, DisFlags, 0, 0, &DisLines);
                TryLines += DisLines;
                DoOneMore = FALSE;
            }

            if (TryLines >= Lines && AddrEqu(TryAddr, *Addr))
            {
                *Addr = StartAddr;
                return TryLines;
            }
            else if (AddrLt(TryAddr, *Addr)) 
            {
                DisAddr = StartAddr;
                // Increase StartAddr
                DisFlags = Flags;
                if (!AddrEqu(StartAddr, *PcAddr))
                {
                    DisFlags &= ~DEBUG_DISASM_EFFECTIVE_ADDRESS;
                }
                DoOutputDisassembly(&StartAddr, DisFlags, 0, 0, &DisLines);
                if ((DisLines == 1) || ((TryLines - DisLines) >= (Lines - 1))) 
                {
                    TryLines -= DisLines;
                }
                else 
                {
                    StartAddr = DisAddr;
                    DoOneMore = TRUE;
                }
            }
            else 
            {
                // couldn't find it
                break;
            }
        }
    }

    //
    // If we couldn't do something with symbols just
    // try a brute-force search backwards.  This
    // has limited utility on variable-length instruction
    // sets but sometimes it works.
    //
    
    while (AddrGt(BackAddr, LimitAddr))
    {
        g_Machine->DecrementBySmallestInstruction(&BackAddr);

        TryAddr = BackAddr;
        TryLines = 0;

        while (AddrLt(TryAddr, *Addr))
        {
            UCHAR MemTest;
                
            // If we can't read memory at this address there's
            // no chance of getting a valid disassembly so
            // just stop the whole process.
            if (!GetMemByte(&TryAddr, &MemTest))
            {
                BackAddr = LimitAddr;
                break;
            }
                
            ULONG DisLines;
            ULONG DisFlags = Flags;
            if (!AddrEqu(TryAddr, *PcAddr))
            {
                DisFlags &= ~DEBUG_DISASM_EFFECTIVE_ADDRESS;
            }
            DoOutputDisassembly(&TryAddr, DisFlags, 0, 0, &DisLines);
            TryLines += DisLines;
        }

        if (TryLines >= Lines && AddrEqu(TryAddr, *Addr))
        {
            *Addr = BackAddr;
            return TryLines;
        }
    }

    // Couldn't find a disassembly that worked.
    return 0;
}

STDMETHODIMP
DebugClient::OutputDisassemblyLines(
    THIS_
    IN ULONG OutputControl,
    IN ULONG PreviousLines,
    IN ULONG TotalLines,
    IN ULONG64 Offset,
    IN ULONG Flags,
    OUT OPTIONAL PULONG OffsetLine,
    OUT OPTIONAL PULONG64 StartOffset,
    OUT OPTIONAL PULONG64 EndOffset,
    OUT OPTIONAL /* size_is(TotalLines) */ PULONG64 LineOffsets
    )
{
    if ((Flags & ~ALL_DISASM_FLAGS) ||
        TotalLines < 1 || PreviousLines > TotalLines)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    ULONG i;

    if (LineOffsets != NULL)
    {
        for (i = 0; i < TotalLines; i++)
        {
            LineOffsets[i] = DEBUG_INVALID_OFFSET;
        }
    }

    ULONG Line, Lines, SkipLines;
    ADDR Addr, PcAddr;

    // Assume this is a code segment address so that disassembly
    // picks up the appropriate type of address.
    g_Machine->FormAddr(SEGREG_CODE, Offset, FORM_SEGREG | FORM_CODE, &Addr);
    
    g_Machine->GetPC(&PcAddr);

    Line = 0;
    SkipLines = 0;

    if (PreviousLines > 0)
    {
        Lines = BackUpDisassemblyLines(PreviousLines, &Addr, Flags, &PcAddr);
        if (Lines == 0)
        {
            dprintf("No prior disassembly possible\n");
            Line = 1;
            Lines = 1;
            TotalLines--;
        }
        else if (Lines > PreviousLines)
        {
            SkipLines = Lines - PreviousLines;
            Lines = PreviousLines;
        }
    }
    else
    {
        Lines = 0;
    }

    if (OffsetLine != NULL)
    {
        *OffsetLine = Lines;
    }

    if (StartOffset != NULL)
    {
        *StartOffset = Flat(Addr);
    }

    while (TotalLines > 0)
    {
        if (LineOffsets != NULL)
        {
            LineOffsets[Line] = Flat(Addr);
        }

        ULONG DisFlags = Flags;
        if (!AddrEqu(Addr, PcAddr))
        {
            DisFlags &= ~DEBUG_DISASM_EFFECTIVE_ADDRESS;
        }
        DoOutputDisassembly(&Addr, DisFlags, SkipLines, TotalLines, &Lines);
        Lines -= SkipLines;

        if (TotalLines <= Lines)
        {
            break;
        }

        TotalLines -= Lines;
        Line += Lines;
        SkipLines = 0;
    }

    if (EndOffset != NULL)
    {
        *EndOffset = Flat(Addr);
    }

    Status = S_OK;

    PopOutCtl(&OldCtl);
 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNearInstruction(
    THIS_
    IN ULONG64 Offset,
    IN LONG Delta,
    OUT PULONG64 NearOffset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    Status = S_OK;

    switch(g_EffMachine)
    {
    case IMAGE_FILE_MACHINE_ALPHA:
    case IMAGE_FILE_MACHINE_AXP64:
        // Each instruction is 32 bits.
        Offset += (LONG64)Delta * 4;
        break;

    case IMAGE_FILE_MACHINE_IA64:
        ULONG Instr;

        // Each 128-bit bundle has three instructions.
        if (Delta < 0)
        {
            while (Delta++ < 0)
            {
                Instr = (ULONG)(Offset & 0xf);
                if (Instr == 0)
                {
                    Offset -= 8;
                }
                else
                {
                    Offset -= 4;
                }
            }
        }
        else
        {
            while (Delta-- > 0)
            {
                Instr = (ULONG)(Offset & 0xf);
                if (Instr == 8)
                {
                    Offset += 8;
                }
                else
                {
                    Offset += 4;
                }
            }
        }
        break;

    case IMAGE_FILE_MACHINE_I386:
    case IMAGE_FILE_MACHINE_AMD64:
        ADDR Addr;
        CHAR Buffer[MAX_DISASM_LEN];

        // Instructions are highly variable.  There isn't any
        // way to really know whether a particular disassembly
        // of a stretch of code is valid or not, so this
        // routine is inherently fragile.
        g_Machine->FormAddr(SEGREG_CODE, Offset,
                            FORM_SEGREG | FORM_CODE, &Addr);
        if (Delta < 0)
        {
            // Back up byte-by-byte and disassemble.  If the
            // post-disassembly offset matches the current offset,
            // a good-enough instruction sequence has been found.
            for (;;)
            {
                ADDR TryAddr;
                LONG TryDelta;

                AddrSub(&Addr, 1);
                TryAddr = Addr;
                TryDelta = 0;
                while (Flat(TryAddr) < Offset)
                {
                    if (!g_Machine->Disassemble(&TryAddr, Buffer, FALSE))
                    {
                        break;
                    }

                    TryDelta--;
                }

                if (Flat(TryAddr) == Offset &&
                    TryDelta == Delta)
                {
                    break;
                }

                // Limit things just as a precaution.
                if (Flat(Addr) < Offset + Delta * X86_MAX_INSTRUCTION_LEN)
                {
                    Status = E_FAIL;
                    break;
                }
            }
        }
        else
        {
            while (Delta-- > 0)
            {
                if (!g_Machine->Disassemble(&Addr, Buffer, FALSE))
                {
                    Status = E_FAIL;
                    break;
                }
            }
        }
        Offset = Flat(Addr);
        break;

    default:
        Status = E_UNEXPECTED;
        break;
    }

    if (SUCCEEDED(Status))
    {
        *NearOffset = Offset;
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetStackTrace(
    THIS_
    IN ULONG64 FrameOffset,
    IN ULONG64 StackOffset,
    IN ULONG64 InstructionOffset,
    OUT PDEBUG_STACK_FRAME Frames,
    IN ULONG FramesSize,
    OUT OPTIONAL PULONG FramesFilled
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    ULONG FramesRet;
    ULONG64 ThreadData;

    if (g_ExtThread != 0)
    {
        ThreadData = g_ExtThread;
        g_ExtThread = 0;
    }
    else
    {
        ThreadData = 0;
    }

    FramesRet = StackTrace(FrameOffset, StackOffset, InstructionOffset,
                           Frames, FramesSize, ThreadData, 0, FALSE);
    if (FramesRet > 0)
    {
        Status = S_OK;
        if (FramesFilled != NULL)
        {
            *FramesFilled = FramesRet;
        }
    }
    else
    {
        Status = E_FAIL;
    }
    if (g_ExtThreadScopeSaved)
    {
        PopScope(&g_ExtThreadSavedScope);
        g_ExtThreadScopeSaved = FALSE;
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetReturnOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ADDR Addr;

        g_Machine->GetRetAddr(&Addr);
        *Offset = Flat(Addr);
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OutputStackTrace(
    THIS_
    IN ULONG OutputControl,
    IN PDEBUG_STACK_FRAME Frames,
    IN ULONG FramesSize,
    IN ULONG Flags
    )
{
    if (Flags & ~(DEBUG_STACK_ARGUMENTS |
                  DEBUG_STACK_FUNCTION_INFO |
                  DEBUG_STACK_SOURCE_LINE |
                  DEBUG_STACK_FRAME_ADDRESSES |
                  DEBUG_STACK_COLUMN_NAMES |
                  DEBUG_STACK_NONVOLATILE_REGISTERS |
                  DEBUG_STACK_FRAME_NUMBERS |
                  DEBUG_STACK_PARAMETERS | 
                  DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY))
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    // Currently only IA64 supports nonvolatile register output.
    if (g_EffMachine != IMAGE_FILE_MACHINE_IA64)
    {
        Flags &= ~DEBUG_STACK_NONVOLATILE_REGISTERS;
    }

    PDEBUG_STACK_FRAME LocalFrames;
    LocalFrames = NULL;

    if (Frames == NULL)
    {
        ULONG FramesFilled;
        ULONG64 ThreadData;

        if (g_ExtThread != 0)
        {
            ThreadData = g_ExtThread;
            g_ExtThread = 0;
        }
        else
        {
            ThreadData = 0;
        }

        LocalFrames = new DEBUG_STACK_FRAME[FramesSize];
        if (LocalFrames == NULL)
        {
            ErrOut("Unable to allocate memory for stack trace\n");
            Status = E_OUTOFMEMORY;
            goto PopExit;
        }

        //
        // StackTrace will generate output if any flags are
        // passed in.  The only time we really require that
        // it produce output is when nonvolatile registers
        // are requested as they can only be displayed when
        // the context is available during stack walking.
        // In order to simplify later logic, we only
        // pass flags if we have the nonvolatile register flag.
        //
        
        FramesFilled = StackTrace(0, 0, 0,
                                  LocalFrames, FramesSize, ThreadData,
                                  (Flags & DEBUG_STACK_NONVOLATILE_REGISTERS) ?
                                  Flags : 0, FALSE);
        if (FramesFilled == 0)
        {
            delete [] LocalFrames;
            goto PopExit;
        }

        Frames = LocalFrames;
        FramesSize = FramesFilled;
    }
    else if (Flags & DEBUG_STACK_NONVOLATILE_REGISTERS)
    {
        // Can't dump nonvolatile registers without a full
        // context so this is not an allowable options.
        Status = E_INVALIDARG;
        goto PopExit;
    }

    if (!(Flags & DEBUG_STACK_NONVOLATILE_REGISTERS))
    {
        PrintStackTrace(FramesSize, Frames, Flags);
    }

    Status = S_OK;

    delete [] LocalFrames;
    if (g_ExtThreadScopeSaved)
    {
        PopScope(&g_ExtThreadSavedScope);
        g_ExtThreadScopeSaved = FALSE;
    }

 PopExit:
    PopOutCtl(&OldCtl);
 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetDebuggeeType(
    THIS_
    OUT PULONG Class,
    OUT PULONG Qualifier
    )
{
    ENTER_ENGINE();

    *Class = g_TargetClass;
    *Qualifier = g_TargetClassQualifier;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetActualProcessorType(
    THIS_
    OUT PULONG Type
    )
{
    ENTER_ENGINE();

    *Type = g_TargetMachineType;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetExecutingProcessorType(
    THIS_
    OUT PULONG Type
    )
{
    ENTER_ENGINE();

    *Type = g_TargetExecMachine;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetNumberPossibleExecutingProcessorTypes(
    THIS_
    OUT PULONG Number
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_SET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        MachineInfo* Machine = MachineTypeInfo(g_TargetMachineType);
        if (Machine == NULL)
        {
            Status = E_INVALIDARG;
        }
        else
        {
            *Number = Machine->m_NumExecTypes;
            Status = S_OK;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetPossibleExecutingProcessorTypes(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    OUT PULONG Types
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_SET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        MachineInfo* Machine = MachineTypeInfo(g_TargetMachineType);
        if (Machine == NULL ||
            Start >= Machine->m_NumExecTypes ||
            Start + Count > Machine->m_NumExecTypes)
        {
            Status = E_INVALIDARG;
        }
        else
        {
            Status = S_OK;
            while (Count-- > 0)
            {
                *Types++ = Machine->m_ExecTypes[Start++];
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberProcessors(
    THIS_
    OUT PULONG Number
    )
{
    ENTER_ENGINE();

    *Number = g_TargetNumberProcessors;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetSystemVersion(
    THIS_
    OUT PULONG PlatformId,
    OUT PULONG Major,
    OUT PULONG Minor,
    OUT OPTIONAL PSTR ServicePackString,
    IN ULONG ServicePackStringSize,
    OUT OPTIONAL PULONG ServicePackStringUsed,
    OUT PULONG ServicePackNumber,
    OUT OPTIONAL PSTR BuildString,
    IN ULONG BuildStringSize,
    OUT OPTIONAL PULONG BuildStringUsed
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    // This is insufficient to distinguish
    // the various system types supported but we don't
    // want to publish identifiers for every possible
    // system version family.  PlatformId is as good
    // as it gets.

    *PlatformId = g_TargetPlatformId;
    *Major = g_TargetCheckedBuild;
    *Minor = g_TargetBuildNumber;
    Status = FillStringBuffer(g_TargetServicePackString, 0,
                              ServicePackString, ServicePackStringSize,
                              ServicePackStringUsed);
    *ServicePackNumber = g_TargetServicePackNumber;
    if (FillStringBuffer(g_TargetBuildLabName, 0,
                         BuildString, BuildStringSize,
                         BuildStringUsed) == S_FALSE)
    {
        Status = S_FALSE;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetPageSize(
    THIS_
    OUT PULONG Size
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_SET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Size = g_Machine->m_PageSize;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::IsPointer64Bit(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_MACHINE_SET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Machine->m_Ptr64 ? S_OK : S_FALSE;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadBugCheckData(
    THIS_
    OUT PULONG Code,
    OUT PULONG64 Arg1,
    OUT PULONG64 Arg2,
    OUT PULONG64 Arg3,
    OUT PULONG64 Arg4
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_KERNEL_TARGET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG64 Args[4];

        Status = g_Target->ReadBugCheckData(Code, Args);
        if (Status == S_OK)
        {
            *Arg1 = Args[0];
            *Arg2 = Args[1];
            *Arg3 = Args[2];
            *Arg4 = Args[3];
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberSupportedProcessorTypes(
    THIS_
    OUT PULONG Number
    )
{
    ENTER_ENGINE();

    *Number = MACHIDX_COUNT;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetSupportedProcessorTypes(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    OUT PULONG Types
    )
{
    if (Start >= MACHIDX_COUNT ||
        Start + Count > MACHIDX_COUNT)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    if (Count > 0)
    {
        while (Count-- > 0)
        {
            // First ExecTypes entry is the actual processor
            // type so it's a convenient place to turn an
            // index into a type.
            *Types++ = g_AllMachines[Start++]->m_ExecTypes[0];
        }
    }


    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetProcessorTypeNames(
    THIS_
    IN ULONG Type,
    OUT OPTIONAL PSTR FullNameBuffer,
    IN ULONG FullNameBufferSize,
    OUT OPTIONAL PULONG FullNameSize,
    OUT OPTIONAL PSTR AbbrevNameBuffer,
    IN ULONG AbbrevNameBufferSize,
    OUT OPTIONAL PULONG AbbrevNameSize
    )
{
    MachineInfo* Machine = MachineTypeInfo(Type);
    if (Machine == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    Status = FillStringBuffer(Machine->m_FullName, 0,
                              FullNameBuffer, FullNameBufferSize,
                              FullNameSize);
    if (FillStringBuffer(Machine->m_AbbrevName, 0,
                         AbbrevNameBuffer, AbbrevNameBufferSize,
                         AbbrevNameSize) == S_FALSE)
    {
        Status = S_FALSE;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetEffectiveProcessorType(
    THIS_
    OUT PULONG Type
    )
{
    ENTER_ENGINE();

    *Type = g_EffMachine;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetEffectiveProcessorType(
    THIS_
    IN ULONG Type
    )
{
    MachineIndex Index = MachineTypeIndex(Type);
    if (Index == MACHIDX_COUNT)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_TARGET_SET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        SetEffMachine(Type, TRUE);
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

ULONG
GetExecutionStatus(void)
{
    if (!IS_MACHINE_SET() ||
        (g_EngStatus & ENG_STATUS_STOP_SESSION) ||
        g_ProcessHead == NULL)
    {
        return DEBUG_STATUS_NO_DEBUGGEE;
    }
    else if (g_CmdState == 'p')
    {
        return DEBUG_STATUS_STEP_OVER;
    }
    else if (g_CmdState == 't')
    {
        return DEBUG_STATUS_STEP_INTO;
    }
    else if (g_CmdState == 'b')
    {
        return DEBUG_STATUS_STEP_BRANCH;
    }
    else if (g_CmdState == 'g')
    {
        return DEBUG_STATUS_GO;
    }
    else
    {
        return DEBUG_STATUS_BREAK;
    }
}

STDMETHODIMP
DebugClient::GetExecutionStatus(
    THIS_
    OUT PULONG Status
    )
{
    // This method is reentrant.
    *Status = ::GetExecutionStatus();
    return S_OK;
}

HRESULT
SetExecutionStatus(ULONG Status)
{
    HRESULT Result = S_OK;

    ENTER_ENGINE();

    if (IS_RUNNING(g_CmdState))
    {
        // Already running.
        goto Exit;
    }

    ADDR PcAddr;

    g_Machine->GetPC(&PcAddr);

    // Notifications are sent in the step/go functions.
    if (Status >= DEBUG_STATUS_GO &&
        Status <= DEBUG_STATUS_GO_NOT_HANDLED)
    {
        fnGoExecution(Status, &PcAddr, 0, NULL, FALSE, NULL);
    }
    else
    {
        DBG_ASSERT(Status == DEBUG_STATUS_STEP_OVER ||
                   Status == DEBUG_STATUS_STEP_INTO ||
                   Status == DEBUG_STATUS_STEP_BRANCH);

        if (g_Machine->IsStepStatusSupported(Status))
        {
            char cmd;
            
            switch (Status) 
            {
            case DEBUG_STATUS_STEP_INTO:
                cmd = 't';
                break;
            case DEBUG_STATUS_STEP_OVER:
                cmd = 'p';
                break;
            case DEBUG_STATUS_STEP_BRANCH:
                cmd = 'b';
                break;
            }
            
            fnStepTrace(&PcAddr, 1, NULL, FALSE, cmd);
        }
        else 
        {
            char* Mode;

            switch (Status)
            {
            case DEBUG_STATUS_STEP_BRANCH:
                Mode = "Taken branch trace";
                break;
            default:
                Mode = "Trace";
                break;
            }

            ErrOut("%s mode not supported\n", Mode);

            Result = E_INVALIDARG;
        }
    }

 Exit:
    LEAVE_ENGINE();
    return Result;
}

STDMETHODIMP
DebugClient::SetExecutionStatus(
    THIS_
    IN ULONG Status
    )
{
    if ((Status <= DEBUG_STATUS_NO_CHANGE || Status >= DEBUG_STATUS_BREAK) &&
        Status != DEBUG_STATUS_STEP_BRANCH)
    {
        return E_INVALIDARG;
    }

    HRESULT RetStatus;

    ENTER_ENGINE();

    if (!IS_MACHINE_SET())
    {
        RetStatus = E_UNEXPECTED;
    }
    else
    {
        RetStatus = ::SetExecutionStatus(Status);
    }

    LEAVE_ENGINE();
    return RetStatus;
}

STDMETHODIMP
DebugClient::GetCodeLevel(
    THIS_
    OUT PULONG Level
    )
{
    ENTER_ENGINE();

    if (g_SrcOptions & SRCOPT_STEP_SOURCE)
    {
        *Level = DEBUG_LEVEL_SOURCE;
    }
    else
    {
        *Level = DEBUG_LEVEL_ASSEMBLY;
    }

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetCodeLevel(
    THIS_
    IN ULONG Level
    )
{
    ENTER_ENGINE();

    HRESULT Status = S_OK;
    ULONG OldSrcOpt = g_SrcOptions;

    switch(Level)
    {
    case DEBUG_LEVEL_ASSEMBLY:
        g_SrcOptions &= ~SRCOPT_STEP_SOURCE;
        break;
    case DEBUG_LEVEL_SOURCE:
        g_SrcOptions |= SRCOPT_STEP_SOURCE;
        break;
    default:
        Status = E_INVALIDARG;
        break;
    }

    if ((OldSrcOpt ^ g_SrcOptions) & SRCOPT_STEP_SOURCE)
    {
        NotifyChangeEngineState(DEBUG_CES_CODE_LEVEL,
                                (g_SrcOptions & SRCOPT_STEP_SOURCE) ?
                                DEBUG_LEVEL_SOURCE : DEBUG_LEVEL_ASSEMBLY,
                                TRUE);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetEngineOptions(
    THIS_
    OUT PULONG Options
    )
{
    // This method is reentrant.
    *Options = g_EngOptions;
    return S_OK;
}

HRESULT
SetEngOptions(ULONG Options)
{
    if (g_EngOptions != Options)
    {
        // Make sure allow and disallow network paths aren't both on.
        if ((Options & ~DEBUG_ENGOPT_ALL) ||
            ((Options & DEBUG_ENGOPT_NETWORK_PATHS) ==
             DEBUG_ENGOPT_NETWORK_PATHS))
        {
            return E_INVALIDARG;
        }
        
        g_EngOptions = Options;
        
        ULONG Notify = DEBUG_CES_ENGINE_OPTIONS;
        ULONG64 Arg = Options;
        
        if (SyncFiltersWithOptions())
        {
            Notify |= DEBUG_CES_EVENT_FILTERS;
            Arg = DEBUG_ANY_ID;
        }

        // XXX drewb - Notification without any lock.
        NotifyChangeEngineState(Notify, Arg, FALSE);
    }

    return S_OK;
}

STDMETHODIMP
DebugClient::AddEngineOptions(
    THIS_
    IN ULONG Options
    )
{
    // This method is reentrant.
    return SetEngOptions(g_EngOptions | Options);
}

STDMETHODIMP
DebugClient::RemoveEngineOptions(
    THIS_
    IN ULONG Options
    )
{
    // This method is reentrant.
    return SetEngOptions(g_EngOptions & ~Options);
}

STDMETHODIMP
DebugClient::SetEngineOptions(
    THIS_
    IN ULONG Options
    )
{
    // This method is reentrant.
    return SetEngOptions(Options);
}

STDMETHODIMP
DebugClient::GetSystemErrorControl(
    THIS_
    OUT PULONG OutputLevel,
    OUT PULONG BreakLevel
    )
{
    ENTER_ENGINE();

    *OutputLevel = g_SystemErrorOutput;
    *BreakLevel = g_SystemErrorBreak;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetSystemErrorControl(
    THIS_
    IN ULONG OutputLevel,
    IN ULONG BreakLevel
    )
{
    if (OutputLevel > SLE_WARNING ||
        BreakLevel > SLE_WARNING)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    g_SystemErrorOutput = OutputLevel;
    g_SystemErrorBreak = BreakLevel;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetTextMacro(
    THIS_
    IN ULONG Slot,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG MacroSize
    )
{
    if (Slot >= REG_USER_COUNT)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    Status = FillStringBuffer(GetUserReg(REG_USER_FIRST + Slot), 0,
                              Buffer, BufferSize, MacroSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetTextMacro(
    THIS_
    IN ULONG Slot,
    IN PCSTR Macro
    )
{
    if (Slot >= REG_USER_COUNT)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    Status = SetUserReg(REG_USER_FIRST + Slot, Macro) ? S_OK : E_OUTOFMEMORY;

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetRadix(
    THIS_
    OUT PULONG Radix
    )
{
    ENTER_ENGINE();

    *Radix = g_DefaultRadix;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetRadix(
    THIS_
    IN ULONG Radix
    )
{
    if (Radix != 8 && Radix != 10 && Radix != 16)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    g_DefaultRadix = Radix;
    NotifyChangeEngineState(DEBUG_CES_RADIX, g_DefaultRadix, TRUE);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::Evaluate(
    THIS_
    IN PCSTR Expression,
    IN ULONG DesiredType,
    OUT PDEBUG_VALUE Value,
    OUT OPTIONAL PULONG RemainderIndex
    )
{
    char Copy[MAX_COMMAND];

    if (Expression == NULL ||
        strlen(Expression) >= sizeof(Copy))
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    PSTR SaveCommand;
    PSTR SaveStart;

    // This Evaluate may be coming from an extension invoked
    // from a command so save all command state.
    SaveCommand = g_CurCmd;
    SaveStart = g_CommandStart;
    g_DisableErrorPrint = TRUE;

    // Copy const string to buffer to avoid read-only memory
    // AVs as the command is modified during parsing.
    strcpy(Copy, Expression);
    g_CurCmd = Copy;
    g_CommandStart = Copy;
    RemoveDelChar(g_CurCmd);
    ExpandUserRegs(Copy);

    __try
    {
        Value->I64 = GetExpression();
        Value->Type = DEBUG_VALUE_INT64;

        if (RemainderIndex != NULL)
        {
            *RemainderIndex = (ULONG)(g_CurCmd - g_CommandStart);
        }

        if (DesiredType != DEBUG_VALUE_INVALID &&
            DesiredType != Value->Type)
        {
            DEBUG_VALUE Natural = *Value;
            Status = CoerceValue(&Natural, DesiredType, Value);
        }
        else
        {
            Status = S_OK;
        }
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        Status = E_FAIL;
    }

    g_DisableErrorPrint = FALSE;
    g_CurCmd = SaveCommand;
    g_CommandStart = SaveStart;

 Exit:
    LEAVE_ENGINE();
    return Status;
}

#define IS_INT(Type) \
    ((Type) >= DEBUG_VALUE_INT8 && (Type) <= DEBUG_VALUE_INT64)
#define IS_FLOAT(Type) \
    ((Type) >= DEBUG_VALUE_FLOAT32 && (Type) <= DEBUG_VALUE_FLOAT128)
#define IS_VECTOR(Type) \
    ((Type) >= DEBUG_VALUE_VECTOR64 && (Type) <= DEBUG_VALUE_VECTOR128)

STDMETHODIMP
DebugClient::CoerceValue(
    THIS_
    IN PDEBUG_VALUE In,
    IN ULONG OutType,
    OUT PDEBUG_VALUE Out
    )
{
    if (In->Type < DEBUG_VALUE_INT8 || In->Type >= DEBUG_VALUE_TYPES ||
        OutType < DEBUG_VALUE_INT8 || OutType >= DEBUG_VALUE_TYPES)
    {
        return E_INVALIDARG;
    }

    if (In->Type == OutType)
    {
        *Out = *In;
        return S_OK;
    }

    ENTER_ENGINE();

    ZeroMemory(Out, sizeof(*Out));
    Out->Type = OutType;

    DEBUG_VALUE Inter;
    char FloatStr[64];

    ZeroMemory(&Inter, sizeof(Inter));

    // Convert the input type to the largest
    // matching type for intermediate operations.
    switch(In->Type)
    {
    case DEBUG_VALUE_INT8:
        Inter.I64 = In->I8;
        Inter.Nat = FALSE;
        break;
    case DEBUG_VALUE_INT16:
        Inter.I64 = In->I16;
        Inter.Nat = FALSE;
        break;
    case DEBUG_VALUE_INT32:
        Inter.I64 = In->I32;
        Inter.Nat = FALSE;
        break;
    case DEBUG_VALUE_INT64:
        Inter.I64 = In->I64;
        Inter.Nat = In->Nat;
        break;
    case DEBUG_VALUE_FLOAT32:
        // XXX drewb - Use direct conversion.
        sprintf(FloatStr, "%10g", In->F32);
        _atoldbl((_ULDOUBLE*)Inter.RawBytes, FloatStr);
        break;
    case DEBUG_VALUE_FLOAT64:
        // XXX drewb - Use direct conversion.
        sprintf(FloatStr, "%10lg", In->F64);
        _atoldbl((_ULDOUBLE*)Inter.RawBytes, FloatStr);
        break;
    case DEBUG_VALUE_FLOAT80:
        memcpy(Inter.RawBytes, In->F80Bytes, sizeof(In->F80Bytes));
        break;
    case DEBUG_VALUE_FLOAT82:
        FLOAT128 f82;
        memcpy(&f82, &(In->F82Bytes), 
               min(sizeof(f82), sizeof(In->F82Bytes)));
        double f; 
        f = Float82ToDouble(&f82);
        sprintf(FloatStr, "%10g", f);
        _atoldbl((_ULDOUBLE*)Inter.RawBytes, FloatStr);
        break;
    case DEBUG_VALUE_FLOAT128:
        // XXX drewb - What's the format?  How should this be supported.
        memcpy(Inter.RawBytes, In->F128Bytes, sizeof(In->F128Bytes));
        break;
    case DEBUG_VALUE_VECTOR64:
        memcpy(Inter.RawBytes, In->RawBytes, 8);
        break;
    case DEBUG_VALUE_VECTOR128:
        memcpy(Inter.RawBytes, In->RawBytes, 16);
        break;
    default:
        DBG_ASSERT(FALSE);
        break;
    }

    // Convert between float, int and vector.  There's
    // no way to know what kind of data is in a vector
    // so the raw bytes are just used directly.
    if (IS_INT(In->Type) &&
        IS_FLOAT(OutType))
    {
        // XXX drewb - Use direct conversion.
        sprintf(FloatStr, "%I64u", Inter.I64);
        _atoldbl((_ULDOUBLE*)Inter.RawBytes, FloatStr);
    }
    else if (IS_FLOAT(In->Type) &&
             IS_INT(OutType))
    {
        double TmpDbl;

        // XXX drewb - Use direct conversion.
        _uldtoa((_ULDOUBLE*)Inter.RawBytes, sizeof(FloatStr), FloatStr);
        if (sscanf(FloatStr, "%10lg", &TmpDbl) != 1)
        {
            TmpDbl = 0.0;
        }
        Inter.I64 = (ULONG64)TmpDbl;
        Inter.Nat = FALSE;
    }

    // Convert the intermediate value down to the
    // appropriate output size.
    switch(OutType)
    {
    case DEBUG_VALUE_INT8:
        Out->I8 = (UCHAR)Inter.I64;
        break;
    case DEBUG_VALUE_INT16:
        Out->I16 = (USHORT)Inter.I64;
        break;
    case DEBUG_VALUE_INT32:
        Out->I32 = (ULONG)Inter.I64;
        break;
    case DEBUG_VALUE_INT64:
        Out->I64 = Inter.I64;
        Out->Nat = Inter.Nat;
        break;
    case DEBUG_VALUE_FLOAT32:
        // XXX drewb - Use direct conversion.
        _uldtoa((_ULDOUBLE*)Inter.RawBytes, sizeof(FloatStr), FloatStr);
        if (sscanf(FloatStr, "%10g", &Out->F32) != 1)
        {
            Out->F32 = 0.0f;
        }
        break;
    case DEBUG_VALUE_FLOAT64:
        // XXX drewb - Use direct conversion.
        _uldtoa((_ULDOUBLE*)Inter.RawBytes, sizeof(FloatStr), FloatStr);
        if (sscanf(FloatStr, "%10lg", &Out->F64) != 1)
        {
            Out->F64 = 0.0;
        }
        break;
    case DEBUG_VALUE_FLOAT80:
        memcpy(Out->F80Bytes, Inter.RawBytes, sizeof(Out->F80Bytes));
        break;
    case DEBUG_VALUE_FLOAT82:
        _uldtoa((_ULDOUBLE*)Inter.RawBytes, sizeof(FloatStr), FloatStr);
        double f;
        if (sscanf(FloatStr, "%10lg", &f) != 1)
        {
            f = 0.0;
        }
        FLOAT128 f82;
        DoubleToFloat82(f, &f82);
        memcpy(&(Out->F82Bytes), &f82, 
               min(sizeof(Out->F82Bytes), sizeof(f82)));
        break;
    case DEBUG_VALUE_FLOAT128:
        // XXX drewb - What's the format?  How should this be supported.
        memcpy(Out->F128Bytes, Inter.RawBytes, sizeof(Out->F128Bytes));
        break;
    case DEBUG_VALUE_VECTOR64:
        memcpy(Out->RawBytes, Inter.RawBytes, 8);
        break;
    case DEBUG_VALUE_VECTOR128:
        memcpy(Out->RawBytes, Inter.RawBytes, 16);
        break;
    default:
        DBG_ASSERT(FALSE);
        break;
    }

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::CoerceValues(
    THIS_
    IN ULONG Count,
    IN /* size_is(Count) */ PDEBUG_VALUE In,
    IN /* size_is(Count) */ PULONG OutTypes,
    OUT /* size_is(Count) */ PDEBUG_VALUE Out
    )
{
    ENTER_ENGINE();

    ULONG i;
    HRESULT Status, SingleStatus;

    Status = S_OK;
    for (i = 0; i < Count; i++)
    {
        SingleStatus = CoerceValue(In, *OutTypes, Out);
        if (SingleStatus != S_OK)
        {
            // Accumulate error and mark failed value.
            Status = SingleStatus;
            Out->Type = DEBUG_VALUE_INVALID;
        }

        In++;
        OutTypes++;
        Out++;
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
Execute(DebugClient* Client, PCSTR Command, ULONG Flags)
{
    char Copy[MAX_COMMAND];

    ULONG Len = strlen(Command);
    BOOL AddNewLine = Len == 0 || Command[Len - 1] != '\n';

    if (Flags & DEBUG_EXECUTE_ECHO)
    {
        dprintf("%s", Command);
        if (AddNewLine)
        {
            dprintf("\n");
        }
    }
    else if ((Flags & DEBUG_EXECUTE_NOT_LOGGED) == 0)
    {
        lprintf(Command);
        if (AddNewLine)
        {
            lprintf("\n");
        }
    }

    HRESULT Status;
    PSTR SaveCommand;
    PSTR SaveStart;

    // This Execute may be coming from an extension invoked
    // from a command so save all command state.
    SaveCommand = g_CurCmd;
    SaveStart = g_CommandStart;

    // Copy const string to buffer to avoid read-only memory
    // AVs as the command is modified during parsing.
    strcpy(Copy, Command);
    g_CurCmd = Copy;
    g_CommandStart = Copy;
    RemoveDelChar(g_CurCmd);
    ExpandUserRegs(Copy);
    ReplaceAliases(g_CurCmd);

    if ((Flags & DEBUG_EXECUTE_NO_REPEAT) == 0 &&
        (g_EngOptions & DEBUG_ENGOPT_NO_EXECUTE_REPEAT) == 0)
    {
        if (Copy[0] == 0)
        {
            strcpy(Copy, g_LastCommand);
        }
        else
        {
            strcpy(g_LastCommand, Copy);
        }
    }

    for (;;)
    {
        Status = ProcessCommandsAndCatch(Client);

        // If we're switching processors (cmdState == 's')
        // we have to wait to allow the switch to occur.
        if (g_CmdState != 's' &&
            (Status != S_FALSE ||
             (g_EngStatus & ENG_STATUS_NO_AUTO_WAIT)))
        {
            break;
        }

        if ((g_CmdState != 's' || !IS_CONN_KERNEL_TARGET() ||
             g_DbgKdTransport->m_WaitingThread != 0) &&
            GetCurrentThreadId() != g_SessionThread)
        {
            ErrOut("Non-primary client caused an implicit wait\n");
            Status = E_FAIL;
            break;
        }

        Status = g_Target->WaitForEvent(DEBUG_STATUS_GO, INFINITE);
        if (Status != S_OK)
        {
            break;
        }
    }

    g_CurCmd = SaveCommand;
    g_CommandStart = SaveStart;

    return Status;
}

#define ALL_EXECUTE_FLAGS       \
    (DEBUG_EXECUTE_DEFAULT |    \
     DEBUG_EXECUTE_ECHO |       \
     DEBUG_EXECUTE_NOT_LOGGED | \
     DEBUG_EXECUTE_NO_REPEAT)

STDMETHODIMP
DebugClient::Execute(
    THIS_
    IN ULONG OutputControl,
    IN PCSTR Command,
    IN ULONG Flags
    )
{
    if ((Flags & ~ALL_EXECUTE_FLAGS) ||
        strlen(Command) >= MAX_COMMAND)
    {
        return E_INVALIDARG;
    }

    // We can't do a blanket IS_MACHINE_ACCESSIBLE check
    // here as Execute's commands have a mix of requirements.
    // Individual commands should check when necessary.

    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        Status = ::Execute(this, Command, Flags);
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
ExecuteCommandFile(DebugClient* Client, PCSTR CommandFile, ULONG Flags)
{
    HRESULT Status;
    FILE* File;

    File = fopen(CommandFile, "r");
    if (File == NULL)
    {
        Status = E_FAIL;
    }
    else
    {
        char Command[MAX_COMMAND];
        va_list VaUnused;

        // This value is only used as a placeholder so
        // it doesn't really matter what it's initialized to.
        ZeroMemory(&VaUnused, sizeof(VaUnused));

        for (;;)
        {
            Command[sizeof(Command) - 2] = '\n';
            Command[sizeof(Command) - 1] = 0;
            
            if (fgets(Command, sizeof(Command), File) == NULL)
            {
                if (feof(File))
                {
                    Status = S_OK;
                }
                else
                {
                    Status = E_FAIL;
                }
                break;
            }

            if (Command[sizeof(Command) - 2] != '\n' ||
                Command[sizeof(Command) - 1] != 0)
            {
                // Input line is too long.
                Status = E_INVALIDARG;
                break;
            }

            if (Flags & DEBUG_EXECUTE_ECHO)
            {
                OutputPrompt(" ", VaUnused);
                // Command has a new-line built in.
                dprintf("%s", Command);
            }
            else if ((Flags & DEBUG_EXECUTE_NOT_LOGGED) == 0)
            {
                ULONG OutCtl;

                // Restrict output to the log only.
                OutCtl = g_OutputControl;
                g_OutputControl = (OutCtl & ~DEBUG_OUTCTL_SEND_MASK) |
                    DEBUG_OUTCTL_LOG_ONLY;

                OutputPrompt(" ", VaUnused);
                // Command has a new-line built in.
                dprintf("%s", Command);

                g_OutputControl = OutCtl;
            }

            Status = Execute(Client, Command, DEBUG_EXECUTE_NOT_LOGGED |
                             (Flags & ~DEBUG_EXECUTE_ECHO));
            if (Status != S_OK)
            {
                break;
            }
        }

        fclose(File);
    }

    return Status;
}

STDMETHODIMP
DebugClient::ExecuteCommandFile(
    THIS_
    IN ULONG OutputControl,
    IN PCSTR CommandFile,
    IN ULONG Flags
    )
{
    if (Flags & ~ALL_EXECUTE_FLAGS)
    {
        return E_INVALIDARG;
    }

    // We can't do a blanket IS_MACHINE_ACCESSIBLE check
    // here as Execute's commands have a mix of requirements.
    // Individual commands should check when necessary.

    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        return E_INVALIDARG;
    }
    else
    {
        Status = ::ExecuteCommandFile(this, CommandFile, Flags);
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberBreakpoints(
    THIS_
    OUT PULONG Number
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Number = g_CurrentProcess->NumBreakpoints;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetBreakpointByIndex(
    THIS_
    IN ULONG Index,
    OUT PDEBUG_BREAKPOINT* RetBp
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Breakpoint* Bp = ::GetBreakpointByIndex(this, Index);
        if (Bp != NULL)
        {
            Bp->AddRef();
            *RetBp = Bp;
            Status = S_OK;
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetBreakpointById(
    THIS_
    IN ULONG Id,
    OUT PDEBUG_BREAKPOINT* RetBp
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Breakpoint* Bp = ::GetBreakpointById(this, Id);
        if (Bp != NULL)
        {
            Bp->AddRef();
            *RetBp = Bp;
            Status = S_OK;
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetBreakpointParameters(
    THIS_
    IN ULONG Count,
    IN OPTIONAL /* size_is(Count) */ PULONG Ids,
    IN ULONG Start,
    OUT /* size_is(Count) */ PDEBUG_BREAKPOINT_PARAMETERS Params
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG i;
        Breakpoint* Bp;

        Status = S_OK;
        for (i = 0; i < Count; i++)
        {
            if (Ids != NULL)
            {
                Bp = ::GetBreakpointById(this, *Ids++);
            }
            else
            {
                Bp = ::GetBreakpointByIndex(this, Start++);
            }

            if (Bp == NULL)
            {
                ZeroMemory(Params, sizeof(*Params));
                Params->Id = DEBUG_ANY_ID;
                Status = S_FALSE;
            }
            else
            {
                Bp->GetParameters(Params);
            }

            Params++;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AddBreakpoint(
    THIS_
    IN ULONG Type,
    IN ULONG DesiredId,
    OUT PDEBUG_BREAKPOINT* Bp
    )
{
    if (
#if DEBUG_BREAKPOINT_CODE > 0
        Type < DEBUG_BREAKPOINT_CODE ||
#endif
        Type > DEBUG_BREAKPOINT_DATA)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    HRESULT Status = ::AddBreakpoint(this, Type, DesiredId, (Breakpoint**)Bp);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::RemoveBreakpoint(
    THIS_
    IN PDEBUG_BREAKPOINT Bp
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ::RemoveBreakpoint((Breakpoint*)Bp);
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AddExtension(
    THIS_
    IN PCSTR Path,
    IN ULONG Flags,
    OUT PULONG64 Handle
    )
{
    if (Flags & ~(DEBUG_EXTENSION_AT_ENGINE))
    {
        return E_INVALIDARG;
    }
    // Remote extensions aren't supported at the moment.
    if (Flags != DEBUG_EXTENSION_AT_ENGINE)
    {
        return E_NOTIMPL;
    }

    HRESULT Status;

    ENTER_ENGINE();

    char* End;
    EXTDLL* Ext;

    if ((Ext = AddExtensionDll((PSTR)Path, TRUE, &End)) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        *Handle = (ULONG64)Ext;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::RemoveExtension(
    THIS_
    IN ULONG64 Handle
    )
{
    ENTER_ENGINE();

    UnloadExtensionDll((EXTDLL*)Handle);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetExtensionByPath(
    THIS_
    IN PCSTR Path,
    OUT PULONG64 Handle
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    EXTDLL* Ext;

    Status = E_NOINTERFACE;
    for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
    {
        if (!_strcmpi(Path, Ext->Name))
        {
            Status = S_OK;
            *Handle = (ULONG64)Ext;
            break;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::CallExtension(
    THIS_
    IN OPTIONAL ULONG64 Handle,
    IN PCSTR Function,
    IN OPTIONAL PCSTR Arguments
    )
{
    char LocalFunc[MAX_COMMAND];
    ULONG Len;

    // Copy function name to temp buffer because it is
    // modified.
    Len = strlen(Function) + 1;
    if (Len > sizeof(LocalFunc))
    {
        return E_INVALIDARG;
    }
    memcpy(LocalFunc, Function, Len);

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if (!CallAnyExtension(this, (EXTDLL*)Handle, LocalFunc, Arguments,
                               Handle != 0, TRUE, &Status))
    {
        Status = E_FAIL;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetExtensionFunction(
    THIS_
    IN ULONG64 Handle,
    IN PCSTR FuncName,
    OUT FARPROC* Function
    )
{
    HRESULT Status;
    char ExpName[MAX_PATH + 16];

    if (strlen(FuncName) >= MAX_PATH)
    {
        return E_INVALIDARG;
    }

    // Keep the namespace for extension function exports
    // separate from the namespace for extension commands.
    // Extension commands are exported under the same
    // name as the command, so prefix extension functions
    // to make them obviously different and to avoid
    // name conflicts.
    strcpy(ExpName, "_EFN_");
    strcat(ExpName, FuncName);
    
    ENTER_ENGINE();

    EXTDLL* Ext;
    FARPROC Routine;

    Status = E_NOINTERFACE;
    if (Handle != 0)
    {
        Ext = (EXTDLL*)(ULONG_PTR)Handle;
    }
    else
    {
        Ext = g_ExtDlls;
    }
    while (Ext!=NULL)
    {
        if (LoadExtensionDll(Ext))
        {
            Routine = GetProcAddress(Ext->Dll, ExpName);
            if (Routine != NULL)
            {
                Status = S_OK;
                *Function = Routine;
                break;
            }
        }

        // If the search was limited to a single extension stop looking.
        if (Handle != 0)
        {
            break;
        }

        Ext = Ext->Next;

    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetWindbgExtensionApis32(
    THIS_
    IN OUT PWINDBG_EXTENSION_APIS32 Api
    )
{
    if (Api->nSize != sizeof(*Api))
    {
        return E_INVALIDARG;
    }

    *Api = g_WindbgExtensions32;
    return S_OK;
}

STDMETHODIMP
DebugClient::GetWindbgExtensionApis64(
    THIS_
    IN OUT PWINDBG_EXTENSION_APIS64 Api
    )
{
    if (Api->nSize != sizeof(*Api))
    {
        return E_INVALIDARG;
    }

    *Api = g_WindbgExtensions64;
    return S_OK;
}

STDMETHODIMP
DebugClient::GetNumberEventFilters(
    THIS_
    OUT PULONG SpecificEvents,
    OUT PULONG SpecificExceptions,
    OUT PULONG ArbitraryExceptions
    )
{
    ENTER_ENGINE();

    *SpecificEvents = FILTER_SPECIFIC_LAST - FILTER_SPECIFIC_FIRST + 1;
    *SpecificExceptions = FILTER_EXCEPTION_LAST - FILTER_EXCEPTION_FIRST + 1;
    *ArbitraryExceptions = g_NumOtherExceptions;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetEventFilterText(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG TextSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (Index >= FILTER_COUNT)
    {
        Status = E_NOINTERFACE;
    }
    else
    {
        Status = FillStringBuffer(g_EventFilters[Index].Name, 0,
                                  Buffer, BufferSize, TextSize);
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
GetEitherEventFilterCommand(ULONG Index, ULONG Which,
                            PSTR Buffer, ULONG BufferSize, PULONG CommandSize)
{
    EVENT_COMMAND* EventCommand;

    if (Index < FILTER_COUNT)
    {
        EventCommand = &g_EventFilters[Index].Command;
    }
    else if ((Index - FILTER_COUNT) < g_NumOtherExceptions)
    {
        EventCommand = &g_OtherExceptionCommands[Index - FILTER_COUNT];
    }
    else
    {
        return E_NOINTERFACE;
    }

    return FillStringBuffer(EventCommand->Command[Which],
                            EventCommand->CommandSize[Which],
                            Buffer, BufferSize, CommandSize);
}

STDMETHODIMP
DebugClient::GetEventFilterCommand(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG CommandSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = GetEitherEventFilterCommand(Index, 0, Buffer, BufferSize,
                                         CommandSize);

    LEAVE_ENGINE();
    return Status;
}

HRESULT
SetEitherEventFilterCommand(DebugClient* Client, ULONG Index, ULONG Which,
                            PCSTR Command)
{
    EVENT_COMMAND* EventCommand;

    if (Index < FILTER_COUNT)
    {
        EventCommand = &g_EventFilters[Index].Command;
    }
    else if ((Index - FILTER_COUNT) < g_NumOtherExceptions)
    {
        EventCommand = &g_OtherExceptionCommands[Index - FILTER_COUNT];
    }
    else
    {
        return E_NOINTERFACE;
    }

    HRESULT Status;

    Status = ChangeString(&EventCommand->Command[Which],
                          &EventCommand->CommandSize[Which],
                          Command);
    if (Status == S_OK)
    {
        if (Index < FILTER_COUNT)
        {
            g_EventFilters[Index].Flags |= FILTER_CHANGED_COMMAND;
        }
        EventCommand->Client = Client;
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, Index, TRUE);
    }

    return Status;
}

STDMETHODIMP
DebugClient::SetEventFilterCommand(
    THIS_
    IN ULONG Index,
    IN PCSTR Command
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = SetEitherEventFilterCommand(this, Index, 0, Command);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSpecificFilterParameters(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    OUT /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
    )
{
    if (
#if FILTER_SPECIFIC_FIRST > 0
        Start < FILTER_SPECIFIC_FIRST ||
#endif
        Start > FILTER_SPECIFIC_LAST ||
        Start + Count > FILTER_SPECIFIC_LAST + 1)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    EVENT_FILTER* Filter;

    for (ULONG i = 0; i < Count; i++)
    {
        Filter = g_EventFilters + (Start + i);

        Params[i].ExecutionOption = Filter->Params.ExecutionOption;
        Params[i].ContinueOption = Filter->Params.ContinueOption;
        Params[i].TextSize = strlen(Filter->Name) + 1;
        Params[i].CommandSize = Filter->Command.CommandSize[0];
        Params[i].ArgumentSize = Filter->Argument != NULL ?
            strlen(Filter->Argument) + 1 : 0;
    }

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetSpecificFilterParameters(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    IN /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
    )
{
    if (
#if FILTER_SPECIFIC_FIRST > 0
        Start < FILTER_SPECIFIC_FIRST ||
#endif
        Start > FILTER_SPECIFIC_LAST ||
        Start + Count > FILTER_SPECIFIC_LAST + 1)
    {
        return E_INVALIDARG;
    }

    HRESULT Status = S_OK;
    ULONG Set = 0;
    ULONG SetIndex = 0;

    ENTER_ENGINE();

    for (ULONG i = 0; i < Count; i++)
    {
        if (
#if DEBUG_FILTER_BREAK > 0
            Params[i].ExecutionOption >= DEBUG_FILTER_BREAK &&
#endif
            Params[i].ExecutionOption <= DEBUG_FILTER_IGNORE &&
#if DEBUG_FILTER_GO_HANDLED > 0
            Params[i].ContinueOption >= DEBUG_FILTER_GO_HANDLED &&
#endif
            Params[i].ContinueOption <= DEBUG_FILTER_GO_NOT_HANDLED)
        {
            g_EventFilters[Start + i].Params.ExecutionOption =
                Params[i].ExecutionOption;
            g_EventFilters[Start + i].Params.ContinueOption =
                Params[i].ContinueOption;
            g_EventFilters[Start + i].Flags |=
                FILTER_CHANGED_EXECUTION | FILTER_CHANGED_CONTINUE;
            Set++;
            SetIndex = i;
        }
        else
        {
            Status = E_INVALIDARG;
        }
    }

    if (SyncOptionsWithFilters())
    {
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS |
                                DEBUG_CES_ENGINE_OPTIONS,
                                DEBUG_ANY_ID, TRUE);
    }
    else if (Set == 1)
    {
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, SetIndex, TRUE);
    }
    else if (Set > 1)
    {
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, DEBUG_ANY_ID, TRUE);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSpecificFilterArgument(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG ArgumentSize
    )
{
    if (
#if FILTER_SPECIFIC_FIRST > 0
        Index < FILTER_SPECIFIC_FIRST ||
#endif
        Index > FILTER_SPECIFIC_LAST ||
        g_EventFilters[Index].Argument == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    Status = FillStringBuffer(g_EventFilters[Index].Argument, 0,
                              Buffer, BufferSize, ArgumentSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetSpecificFilterArgument(
    THIS_
    IN ULONG Index,
    IN PCSTR Argument
    )
{
    ULONG Len;

    if (Argument == NULL)
    {
        Len = 1;
    }
    else
    {
        Len = strlen(Argument) + 1;
    }

    if (
#if FILTER_SPECIFIC_FIRST > 0
        Index < FILTER_SPECIFIC_FIRST ||
#endif
        Index > FILTER_SPECIFIC_LAST ||
        g_EventFilters[Index].Argument == NULL ||
        Len > FILTER_MAX_ARGUMENT)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    if (Argument == NULL)
    {
        g_EventFilters[Index].Argument[0] = 0;
    }
    else
    {
        memcpy(g_EventFilters[Index].Argument, Argument, Len);
    }
    if (Index == DEBUG_FILTER_UNLOAD_MODULE)
    {
        g_UnloadDllBase = ExtGetExpression(Argument);
    }

    NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, Index, TRUE);

    LEAVE_ENGINE();
    return S_OK;
}

void
GetExFilterParams(PCSTR Text,
                  PDEBUG_EXCEPTION_FILTER_PARAMETERS InParams,
                  EVENT_COMMAND* InCommand,
                  PDEBUG_EXCEPTION_FILTER_PARAMETERS OutParams)
{
    OutParams->ExecutionOption = InParams->ExecutionOption;
    OutParams->ContinueOption = InParams->ContinueOption;
    OutParams->TextSize = Text != NULL ? strlen(Text) + 1 : 0;
    OutParams->CommandSize = InCommand->CommandSize[0];
    OutParams->SecondCommandSize = InCommand->CommandSize[1];
    OutParams->ExceptionCode = InParams->ExceptionCode;
}

STDMETHODIMP
DebugClient::GetExceptionFilterParameters(
    THIS_
    IN ULONG Count,
    IN OPTIONAL /* size_is(Count) */ PULONG Codes,
    IN ULONG Start,
    OUT /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
    )
{
    HRESULT Status = S_OK;

    ENTER_ENGINE();

    ULONG i, Index;
    EVENT_FILTER* Filter;

    if (Codes != NULL)
    {
        for (i = 0; i < Count; i++)
        {
            // Is this a specific exception?
            Filter = g_EventFilters + FILTER_EXCEPTION_FIRST;
            for (Index = FILTER_EXCEPTION_FIRST;
                 Index <= FILTER_EXCEPTION_LAST;
                 Index++)
            {
                if (Filter->Params.ExceptionCode == Codes[i])
                {
                    GetExFilterParams(Filter->Name, &Filter->Params,
                                      &Filter->Command, Params + i);
                    break;
                }

                Filter++;
            }

            if (Index > FILTER_EXCEPTION_LAST)
            {
                // Is this an other exception?
                for (Index = 0; Index < g_NumOtherExceptions; Index++)
                {
                    if (g_OtherExceptionList[Index].ExceptionCode == Codes[i])
                    {
                        GetExFilterParams(NULL, g_OtherExceptionList + Index,
                                          g_OtherExceptionCommands + Index,
                                          Params + i);
                        break;
                    }
                }

                if (Index >= g_NumOtherExceptions)
                {
                    memset(Params + i, 0xff, sizeof(*Params));
                    Status = E_NOINTERFACE;
                }
            }
        }
    }
    else
    {
        for (i = 0; i < Count; i++)
        {
            Index = Start + i;

            // Is this a specific exception?
            if (Index >= FILTER_EXCEPTION_FIRST &&
                Index <= FILTER_EXCEPTION_LAST)
            {
                Filter = g_EventFilters + Index;
                GetExFilterParams(Filter->Name, &Filter->Params,
                                  &Filter->Command, Params + i);
            }
            // Is this an other exception?
            else if (Index >= FILTER_COUNT &&
                     Index < FILTER_COUNT + g_NumOtherExceptions)
            {
                GetExFilterParams(NULL, g_OtherExceptionList +
                                  (Index - FILTER_COUNT),
                                  g_OtherExceptionCommands +
                                  (Index - FILTER_COUNT),
                                  Params + i);
            }
            else
            {
                memset(Params + i, 0xff, sizeof(*Params));
                Status = E_INVALIDARG;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
SetExFilterParams(PDEBUG_EXCEPTION_FILTER_PARAMETERS InParams,
                  PDEBUG_EXCEPTION_FILTER_PARAMETERS OutParams)
{
    if (
#if DEBUG_FILTER_BREAK > 0
        InParams->ExecutionOption >= DEBUG_FILTER_BREAK &&
#endif
        InParams->ExecutionOption <= DEBUG_FILTER_IGNORE &&
#if DEBUG_FILTER_GO_HANDLED > 0
        InParams->ContinueOption >= DEBUG_FILTER_GO_HANDLED &&
#endif
        InParams->ContinueOption <= DEBUG_FILTER_GO_NOT_HANDLED)
    {
        OutParams->ExecutionOption = InParams->ExecutionOption;
        OutParams->ContinueOption = InParams->ContinueOption;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT
SetOtherExFilterParams(PDEBUG_EXCEPTION_FILTER_PARAMETERS InParams,
                       ULONG OutIndex, PULONG Set, PULONG SetIndex)
{
    HRESULT Status;

    if (OutIndex < g_NumOtherExceptions)
    {
        if (InParams->ExecutionOption == DEBUG_FILTER_REMOVE)
        {
            g_NumOtherExceptions--;
            memmove(g_OtherExceptionList + OutIndex,
                    g_OtherExceptionList + OutIndex + 1,
                    (g_NumOtherExceptions - OutIndex) *
                    sizeof(g_OtherExceptionList[0]));
            *Set += 2;
            Status = S_OK;
        }
        else
        {
            Status = SetExFilterParams(InParams,
                                       g_OtherExceptionList + OutIndex);
            if (Status == S_OK)
            {
                (*Set)++;
                *SetIndex = OutIndex + FILTER_COUNT;
            }
        }
    }
    else
    {
        if (g_NumOtherExceptions == OTHER_EXCEPTION_LIST_MAX)
        {
            Status = E_OUTOFMEMORY;
        }
        else
        {
            OutIndex = g_NumOtherExceptions;
            g_OtherExceptionList[OutIndex].ExceptionCode =
                InParams->ExceptionCode;
            Status = SetExFilterParams(InParams,
                                       g_OtherExceptionList + OutIndex);
            if (Status == S_OK)
            {
                g_NumOtherExceptions++;
                (*Set)++;
                *SetIndex = OutIndex + FILTER_COUNT;
            }
        }
    }

    return Status;
}

STDMETHODIMP
DebugClient::SetExceptionFilterParameters(
    THIS_
    IN ULONG Count,
    IN /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
    )
{
    HRESULT Status = S_OK;

    ENTER_ENGINE();

    ULONG i, Index;
    EVENT_FILTER* Filter;
    ULONG Set = 0;
    ULONG SetIndex = 0;

    for (i = 0; i < Count; i++)
    {
        // Is this a specific exception?
        Filter = g_EventFilters + FILTER_EXCEPTION_FIRST;
        for (Index = FILTER_EXCEPTION_FIRST;
             Index <= FILTER_EXCEPTION_LAST;
             Index++)
        {
            if (Filter->Params.ExceptionCode == Params[i].ExceptionCode)
            {
                Status = SetExFilterParams(Params + i, &Filter->Params);
                if (Status == S_OK)
                {
                    Filter->Flags |= FILTER_CHANGED_EXECUTION |
                        FILTER_CHANGED_CONTINUE;
                    Set++;
                    SetIndex = Index;
                }
                break;
            }

            Filter++;
        }

        if (Index > FILTER_EXCEPTION_LAST)
        {
            // Is this an other exception?
            for (Index = 0; Index < g_NumOtherExceptions; Index++)
            {
                if (g_OtherExceptionList[Index].ExceptionCode ==
                    Params[i].ExceptionCode)
                {
                    break;
                }
            }

            Status = SetOtherExFilterParams(Params + i, Index,
                                            &Set, &SetIndex);
        }
    }

    if (Set == 1)
    {
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, SetIndex, TRUE);
    }
    else if (Set > 1)
    {
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, DEBUG_ANY_ID, TRUE);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetExceptionFilterSecondCommand(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG CommandSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = GetEitherEventFilterCommand(Index, 1, Buffer, BufferSize,
                                         CommandSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetExceptionFilterSecondCommand(
    THIS_
    IN ULONG Index,
    IN PCSTR Command
    )
{
    if (Index <= FILTER_SPECIFIC_LAST)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    Status = SetEitherEventFilterCommand(this, Index, 1, Command);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WaitForEvent(
    THIS_
    IN ULONG Flags,
    IN ULONG Timeout
    )
{
    if (Flags != DEBUG_WAIT_DEFAULT ||
        ::GetCurrentThreadId() != g_SessionThread)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_TARGET_SET() ||
        (g_EngStatus & ENG_STATUS_STOP_SESSION))
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    // If the caller is trying to force the engine to
    // stop waiting return immediately.
    if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
    {
        g_EngStatus &= ~ENG_STATUS_EXIT_CURRENT_WAIT;
        Status = E_PENDING;
        goto Exit;
    }
    
    // This constitutes interesting activity.
    m_LastActivity = time(NULL);

    if (g_EngStatus & ENG_STATUS_WAITING)
    {
        Status = E_FAIL;
    }
    else
    {
        Status = g_Target->WaitForEvent(Flags, Timeout);
    }

    g_EngStatus &= ~ENG_STATUS_EXIT_CURRENT_WAIT;

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetLastEventInformation(
    THIS_
    OUT PULONG Type,
    OUT PULONG ProcessId,
    OUT PULONG ThreadId,
    OUT OPTIONAL PVOID ExtraInformation,
    IN ULONG ExtraInformationSize,
    OUT OPTIONAL PULONG ExtraInformationUsed,
    OUT OPTIONAL PSTR Description,
    IN ULONG DescriptionSize,
    OUT OPTIONAL PULONG DescriptionUsed
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    *Type = g_LastEventType;

    if (g_EventProcess != NULL)
    {
        *ProcessId = g_EventProcess->UserId;
        *ThreadId = g_EventThread->UserId;
    }
    else
    {
        *ProcessId = DEBUG_ANY_ID;
        *ThreadId = DEBUG_ANY_ID;
    }

    Status = FillDataBuffer(g_LastEventExtraData, g_LastEventExtraDataSize,
                            ExtraInformation, ExtraInformationSize,
                            ExtraInformationUsed);
    if (FillStringBuffer(g_LastEventDesc, 0,
                         Description, DescriptionSize,
                         DescriptionUsed) == S_FALSE)
    {
        Status = S_FALSE;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentTimeDate(
    THIS_
    OUT PULONG TimeDate
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_TARGET_SET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *TimeDate = FileTimeToTimeDateStamp(g_Target->GetCurrentTimeDateN());
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentSystemUpTime(
    THIS_
    OUT PULONG UpTime
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_TARGET_SET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *UpTime = FileTimeToTime(g_Target->GetCurrentSystemUpTimeN());
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetDumpFormatFlags(
    THIS_
    OUT PULONG FormatFlags
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_DUMP_TARGET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *FormatFlags = g_DumpFormatFlags;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberTextReplacements(
    THIS_
    OUT PULONG NumRepl
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    *NumRepl = g_NumAliases;
    Status = S_OK;
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetTextReplacement(
    THIS_
    IN OPTIONAL PCSTR SrcText,
    IN ULONG Index,
    OUT OPTIONAL PSTR SrcBuffer,
    IN ULONG SrcBufferSize,
    OUT OPTIONAL PULONG SrcSize,
    OUT OPTIONAL PSTR DstBuffer,
    IN ULONG DstBufferSize,
    OUT OPTIONAL PULONG DstSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    PALIAS Scan = g_AliasListHead;
    ULONG i;

    while (Scan != NULL &&
           ((SrcText != NULL && strcmp(SrcText, Scan->Name)) ||
            (SrcText == NULL && Index-- > 0)))
    {
        Scan = Scan->Next;
    }

    if (Scan != NULL)
    {
        Status = FillStringBuffer(Scan->Name, 0,
                                  SrcBuffer, SrcBufferSize, SrcSize);
        if (FillStringBuffer(Scan->Value, 0,
                             DstBuffer, DstBufferSize, DstSize) == S_FALSE)
        {
            Status = S_FALSE;
        }
    }
    else
    {
        Status = E_NOINTERFACE;
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetTextReplacement(
    THIS_
    IN PCSTR SrcText,
    IN OPTIONAL PCSTR DstText
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (DstText != NULL)
    {
        Status = SetAlias(SrcText, DstText);
    }
    else
    {
        Status = DeleteAlias(SrcText);
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::RemoveTextReplacements(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = DeleteAlias("*");
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OutputTextReplacements(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Flags
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    ListAliases();
    Status = S_OK;
    
    LEAVE_ENGINE();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dbgclt.cpp ===
//----------------------------------------------------------------------------
//
// Debug client implementation.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"
#include "dbgver.h"

#define VER_STRING(Specific)            \
"\n"                                    \
"Microsoft (R) Windows " Specific       \
"  Version " VER_PRODUCTVERSION_STR     \
"\n" VER_LEGALCOPYRIGHT_STR             \
"\n"                                    \
"\n"

PCHAR g_Win9xVersionString = VER_STRING("9x User-Mode Debugger");
PCHAR g_WinKernelVersionString = VER_STRING("Kernel Debugger");
PCHAR g_WinUserVersionString = VER_STRING("User-Mode Debugger");


BOOL g_QuietMode;

ULONG g_OutputWidth = 80;
PCSTR g_OutputLinePrefix;

// The platform ID of the machine running the debugger.  Note
// that this may be different from g_TargetPlatformId, which
// is the platform ID of the machine being debugged.
ULONG g_DebuggerPlatformId;

CRITICAL_SECTION g_QuickLock;

CRITICAL_SECTION g_EngineLock;
ULONG g_EngineNesting;

// Events and storage space for returning event callback
// status from an APC.
HANDLE g_EventStatusWaiting;
HANDLE g_EventStatusReady;
ULONG g_EventStatus;

// Named event to sleep on.
HANDLE g_SleepPidEvent;

//----------------------------------------------------------------------------
//
// DebugClient.
//
//----------------------------------------------------------------------------

// List of all clients.
DebugClient* g_Clients;

char g_InputBuffer[INPUT_BUFFER_SIZE];
ULONG g_InputSequence;
HANDLE g_InputEvent;
ULONG g_InputSizeRequested;

// The thread that created the current session.
ULONG g_SessionThread;

PPENDING_PROCESS g_ProcessPending;

ULONG g_EngOptions;
ULONG g_EngStatus;
ULONG g_EngDefer;
ULONG g_EngErr;

// Some options set through the process options apply to
// all processes and some are per-process.  The global
// options are collected here.
ULONG g_GlobalProcOptions;

#if DBG
ULONG g_EnvOutMask;
#endif

DebugClient::DebugClient(void)
{
    m_Next = NULL;
    m_Prev = NULL;

    m_Refs = 1;
    m_Flags = 0;
    m_ThreadId = ::GetCurrentThreadId();
    m_Thread = NULL;
    m_EventCb = NULL;
    m_EventInterest = 0;
    m_DispatchSema = NULL;
    m_InputCb = NULL;
    m_InputSequence = 0xffffffff;
    m_OutputCb = NULL;
#if DBG
    m_OutMask = DEFAULT_OUT_MASK | g_EnvOutMask;
#else
    m_OutMask = DEFAULT_OUT_MASK;
#endif
    m_OutputWidth = 80;
    m_OutputLinePrefix = NULL;
}

DebugClient::~DebugClient(void)
{
    // Most of the work is done in Destroy.

    if (m_Flags & CLIENT_IN_LIST)
    {
        Unlink();
    }
}

void
DebugClient::Destroy(void)
{
    // Clients cannot arbitrarily be removed from the client list
    // or their memory deleted due to the possibility of a callback
    // loop occurring at the same time.  Instead clients are left
    // in the list and zeroed out to prevent further callbacks
    // from occurring.
    // XXX drewb - This memory needs to be reclaimed at some
    // point, but there's no simple safe time to do so since
    // callbacks can occur at any time.  Clients are very small
    // right now so the leakage is negligible.

    m_Flags = (m_Flags & ~(CLIENT_REMOTE | CLIENT_PRIMARY)) |
        CLIENT_DESTROYED;

    // Remove any references from breakpoints this client
    // added.
    PPROCESS_INFO Process;
    Breakpoint* Bp;
    
    for (Process = g_ProcessHead; Process; Process = Process->Next)
    {
        for (Bp = Process->Breakpoints; Bp != NULL; Bp = Bp->m_Next)
        {
            if (Bp->m_Adder == this)
            {
                Bp->m_Adder = NULL;
            }
        }
    }

    if (m_Thread != NULL)
    {
        CloseHandle(m_Thread);
        m_Thread = NULL;
    }

    m_EventInterest = 0;
    RELEASE(m_EventCb);
    if (m_DispatchSema != NULL)
    {
        CloseHandle(m_DispatchSema);
        m_DispatchSema = NULL;
    }

    RELEASE(m_InputCb);
    m_InputSequence = 0xffffffff;

    RELEASE(m_OutputCb);
    m_OutMask = 0;
    CollectOutMasks();
}

STDMETHODIMP
DebugClient::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;

    *Interface = NULL;
    Status = S_OK;

    // Interface specific casts are necessary in order to
    // get the right vtable pointer in our multiple
    // inheritance scheme.
    if (DbgIsEqualIID(InterfaceId, IID_IUnknown) ||
        DbgIsEqualIID(InterfaceId, IID_IDebugClient) ||
        DbgIsEqualIID(InterfaceId, IID_IDebugClient2))
    {
        *Interface = (IDebugClientN *)this;
    }
    else if (DbgIsEqualIID(InterfaceId, IID_IDebugAdvanced))
    {
        *Interface = (IDebugAdvancedN *)this;
    }
    else if (DbgIsEqualIID(InterfaceId, IID_IDebugControl) ||
             DbgIsEqualIID(InterfaceId, IID_IDebugControl2))
    {
        *Interface = (IDebugControlN *)this;
    }
    else if (DbgIsEqualIID(InterfaceId, IID_IDebugDataSpaces) ||
             DbgIsEqualIID(InterfaceId, IID_IDebugDataSpaces2))
    {
        *Interface = (IDebugDataSpacesN *)this;
    }
    else if (DbgIsEqualIID(InterfaceId, IID_IDebugRegisters))
    {
        *Interface = (IDebugRegistersN *)this;
    }
    else if (DbgIsEqualIID(InterfaceId, IID_IDebugSymbols) ||
             DbgIsEqualIID(InterfaceId, IID_IDebugSymbols2))
    {
        *Interface = (IDebugSymbolsN *)this;
    }
    else if (DbgIsEqualIID(InterfaceId, IID_IDebugSystemObjects) ||
             DbgIsEqualIID(InterfaceId, IID_IDebugSystemObjects2))
    {
        *Interface = (IDebugSystemObjectsN *)this;
    }
    else if (DbgIsEqualIID(InterfaceId, IID_IDebugSymbolGroup))
    {
        *Interface = (IDebugSymbolGroupN *)this;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    if (Status == S_OK)
    {
        AddRef();
    }

    return Status;
}

STDMETHODIMP_(ULONG)
DebugClient::AddRef(
    THIS
    )
{
    return InterlockedIncrement((PLONG)&m_Refs);
}

STDMETHODIMP_(ULONG)
DebugClient::Release(
    THIS
    )
{
    LONG Refs = InterlockedDecrement((PLONG)&m_Refs);
    if (Refs == 0)
    {
        Destroy();
    }
    return Refs;
}

STDMETHODIMP
DebugClient::AttachKernel(
    THIS_
    IN ULONG Flags,
    IN OPTIONAL PCSTR ConnectOptions
    )
{
    ULONG Qual;

    if (
#if DEBUG_ATTACH_KERNEL_CONNECTION > 0
        Flags < DEBUG_ATTACH_KERNEL_CONNECTION ||
#endif
        Flags > DEBUG_ATTACH_EXDI_DRIVER)
    {
        return E_INVALIDARG;
    }

    if (Flags == DEBUG_ATTACH_LOCAL_KERNEL)
    {
        if (ConnectOptions != NULL)
        {
            return E_INVALIDARG;
        }
        if (g_DebuggerPlatformId != VER_PLATFORM_WIN32_NT)
        {
            return E_UNEXPECTED;
        }

        Qual = DEBUG_KERNEL_LOCAL;
    }
    else if (Flags == DEBUG_ATTACH_EXDI_DRIVER)
    {
        Qual = DEBUG_KERNEL_EXDI_DRIVER;
    }
    else
    {
        Qual = DEBUG_KERNEL_CONNECTION;
    }

    ENTER_ENGINE();

    HRESULT Status = LiveKernelInitialize(this, Qual, ConnectOptions);
    if (Status == S_OK)
    {
        InitializePrimary();
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetKernelConnectionOptions(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG OptionsSize
    )
{
    if (!IS_CONN_KERNEL_TARGET() ||
        g_DbgKdTransport == NULL)
    {
        return E_UNEXPECTED;
    }

    if (BufferSize == 0)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

#define MIN_BUFFER_SIZE (2 * (MAX_PARAM_NAME + MAX_PARAM_VALUE + 16))

    char MinBuf[MIN_BUFFER_SIZE];
    PSTR Buf;
    ULONG BufSize;

    if (Buffer == NULL || BufferSize < MIN_BUFFER_SIZE)
    {
        Buf = MinBuf;
        BufSize = MIN_BUFFER_SIZE;
    }
    else
    {
        Buf = Buffer;
        BufSize = BufferSize;
    }

    HRESULT Status;

    if (g_DbgKdTransport->GetParameters(Buf, BufSize))
    {
        BufSize = strlen(Buf);
        Status = S_OK;
    }
    else
    {
        // Just guess on the necessary size.
        BufSize *= 2;
        Status = S_FALSE;
    }

    if (Buffer != NULL && Buf != Buffer)
    {
        strcpy(Buffer, Buf);
    }

    if (OptionsSize != NULL)
    {
        *OptionsSize = BufSize;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetKernelConnectionOptions(
    THIS_
    IN PCSTR Options
    )
{
    if (!IS_CONN_KERNEL_TARGET() ||
        g_DbgKdTransport == NULL)
    {
        return E_UNEXPECTED;
    }

    // This method is reentrant.

    if (!_strcmpi(Options, "resync"))
    {
        g_DbgKdTransport->m_Resync = TRUE;
    }
    else if (!_strcmpi(Options, "cycle_speed"))
    {
        g_DbgKdTransport->CycleSpeed();
    }
    else
    {
        return E_NOINTERFACE;
    }

    return S_OK;
}

DBGRPC_SIMPLE_FACTORY(LiveUserDebugServices, IID_IUserDebugServices, \
                      "Remote Process Server", (TRUE))
LiveUserDebugServicesFactory g_LiveUserDebugServicesFactory;

STDMETHODIMP
DebugClient::StartProcessServer(
    THIS_
    IN ULONG Flags,
    IN PCSTR Options,
    IN PVOID Reserved
    )
{
    if (Flags <= DEBUG_CLASS_KERNEL || Flags > DEBUG_CLASS_USER_WINDOWS)
    {
        return E_INVALIDARG;
    }
    // XXX drewb - Turn reserved into public IUserDebugServices
    // parameter so that a server can be started over arbitrary services.
    if (Reserved != NULL)
    {
        return E_NOTIMPL;
    }

    HRESULT Status;

    ENTER_ENGINE();

    DbgRpcClientObjectFactory* Factory;

    switch(Flags)
    {
    case DEBUG_CLASS_USER_WINDOWS:
        Factory = &g_LiveUserDebugServicesFactory;
        break;
    default:
        DBG_ASSERT(FALSE);
        break;
    }

    Status = DbgRpcCreateServer(Options, Factory);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ConnectProcessServer(
    THIS_
    IN PCSTR RemoteOptions,
    OUT PULONG64 Server
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    PUSER_DEBUG_SERVICES Services;

    if ((Status = DbgRpcConnectServer(RemoteOptions, &IID_IUserDebugServices,
                                      (IUnknown**)&Services)) == S_OK)
    {
        *Server = (ULONG64)(ULONG_PTR)Services;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::DisconnectProcessServer(
    THIS_
    IN ULONG64 Server
    )
{
    ENTER_ENGINE();

    ((PUSER_DEBUG_SERVICES)Server)->Release();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetRunningProcessSystemIds(
    THIS_
    IN ULONG64 Server,
    OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
    IN ULONG Count,
    OUT OPTIONAL PULONG ActualCount
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = SERVER_SERVICES(Server)->
        GetProcessIds(Ids, Count, ActualCount);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetRunningProcessSystemIdByExecutableName(
    THIS_
    IN ULONG64 Server,
    IN PCSTR ExeName,
    IN ULONG Flags,
    OUT PULONG Id
    )
{
    if (Flags & ~(DEBUG_GET_PROC_DEFAULT |
                  DEBUG_GET_PROC_FULL_MATCH |
                  DEBUG_GET_PROC_ONLY_MATCH))
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    Status = SERVER_SERVICES(Server)->
        GetProcessIdByExecutableName(ExeName, Flags, Id);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetRunningProcessDescription(
    THIS_
    IN ULONG64 Server,
    IN ULONG SystemId,
    IN ULONG Flags,
    OUT OPTIONAL PSTR ExeName,
    IN ULONG ExeNameSize,
    OUT OPTIONAL PULONG ActualExeNameSize,
    OUT OPTIONAL PSTR Description,
    IN ULONG DescriptionSize,
    OUT OPTIONAL PULONG ActualDescriptionSize
    )
{
    HRESULT Status;

    if (Flags & ~(DEBUG_PROC_DESC_DEFAULT |
                  DEBUG_PROC_DESC_NO_PATHS))
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    Status = SERVER_SERVICES(Server)->
        GetProcessDescription(SystemId, Flags, ExeName, ExeNameSize,
                              ActualExeNameSize, Description, DescriptionSize,
                              ActualDescriptionSize);

    LEAVE_ENGINE();
    return Status;
}

#define ALL_ATTACH_FLAGS \
    (DEBUG_ATTACH_NONINVASIVE | DEBUG_ATTACH_EXISTING)

STDMETHODIMP
DebugClient::AttachProcess(
    THIS_
    IN ULONG64 Server,
    IN ULONG ProcessId,
    IN ULONG AttachFlags
    )
{
    HRESULT Status;

    if ((AttachFlags & ~ALL_ATTACH_FLAGS) ||
        (AttachFlags & (DEBUG_ATTACH_NONINVASIVE | DEBUG_ATTACH_EXISTING)) ==
        (DEBUG_ATTACH_NONINVASIVE | DEBUG_ATTACH_EXISTING))
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    BOOL InitTarget = FALSE;
    
    if (!IS_TARGET_SET())
    {
        Status = UserInitialize(this, Server);
        InitTarget = TRUE;
    }
    
    if (IS_LIVE_USER_TARGET())
    {
        PPENDING_PROCESS Pending;
        
        Status = StartAttachProcess(ProcessId, AttachFlags, &Pending);
        if (Status == S_OK)
        {
            InitializePrimary();
        }
        else if (InitTarget)
        {
            DiscardTarget(DEBUG_SESSION_END_SESSION_PASSIVE);
        }
    }
    else if (!InitTarget)
    {
        Status = E_UNEXPECTED;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::CreateProcess(
    THIS_
    IN ULONG64 Server,
    IN PSTR CommandLine,
    IN ULONG CreateFlags
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    BOOL InitTarget = FALSE;
    
    if (!IS_TARGET_SET())
    {
        Status = UserInitialize(this, Server);
        InitTarget = TRUE;
    }
    
    if (IS_LIVE_USER_TARGET())
    {
        PPENDING_PROCESS Pending;
        
        Status = StartCreateProcess(CommandLine, CreateFlags, &Pending);
        if (Status == S_OK)
        {
            InitializePrimary();
        }
        else if (InitTarget)
        {
            DiscardTarget(DEBUG_SESSION_END_SESSION_PASSIVE);
        }
    }
    else if (!InitTarget)
    {
        Status = E_UNEXPECTED;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::CreateProcessAndAttach(
    THIS_
    IN ULONG64 Server,
    IN OPTIONAL PSTR CommandLine,
    IN ULONG CreateFlags,
    IN ULONG ProcessId,
    IN ULONG AttachFlags
    )
{
    if ((CommandLine == NULL && ProcessId == 0) ||
        (AttachFlags & ~ALL_ATTACH_FLAGS))
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    BOOL InitTarget = FALSE;
    
    if (!IS_TARGET_SET())
    {
        Status = UserInitialize(this, Server);
        InitTarget = TRUE;
    }
    
    if (IS_LIVE_USER_TARGET())
    {
        PPENDING_PROCESS PendCreate, PendAttach;
        
        if (CommandLine != NULL)
        {
            if (ProcessId != 0)
            {
                CreateFlags |= CREATE_SUSPENDED;
            }

            if ((Status = StartCreateProcess(CommandLine, CreateFlags,
                                             &PendCreate)) != S_OK)
            {
                goto EH_Discard;
            }
        }

        if (ProcessId != 0)
        {
            if ((Status = StartAttachProcess(ProcessId, AttachFlags,
                                             &PendAttach)) != S_OK)
            {
                goto EH_Discard;
            }
            
            // If we previously created a process we need to wake
            // it up when we attach since we created it suspended.
            if (CommandLine != NULL)
            {
                g_ThreadToResume = PendCreate->InitialThreadHandle;
            }
        }

        InitializePrimary();
    }
    else if (!InitTarget)
    {
        Status = E_UNEXPECTED;
    }

    LEAVE_ENGINE();
    return Status;

 EH_Discard:
    DiscardTarget(DEBUG_SESSION_END_SESSION_PASSIVE);
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetProcessOptions(
    THIS_
    OUT PULONG Options
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_LIVE_USER_TARGET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = S_OK;
        *Options = g_GlobalProcOptions;
        if (g_CurrentProcess != NULL)
        {
            *Options |= g_CurrentProcess->Options;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

#define PROCESS_ALL \
    (DEBUG_PROCESS_DETACH_ON_EXIT | DEBUG_PROCESS_ONLY_THIS_PROCESS)
#define PROCESS_GLOBAL \
    (DEBUG_PROCESS_DETACH_ON_EXIT)

HRESULT
ChangeProcessOptions(ULONG Options, ULONG OptFn)
{
    if (Options & ~PROCESS_ALL)
    {
        return E_INVALIDARG;
    }
    if (!IS_LIVE_USER_TARGET())
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;

    ENTER_ENGINE();

    ULONG NewPer, OldPer;
    ULONG NewGlobal;

    switch(OptFn)
    {
    case OPTFN_ADD:
        if (Options & ~PROCESS_GLOBAL)
        {
            if (g_CurrentProcess == NULL)
            {
                Status = E_UNEXPECTED;
                goto Exit;
            }

            OldPer = g_CurrentProcess->Options;
            NewPer = OldPer | (Options & ~PROCESS_GLOBAL);
        }
        else
        {
            NewPer = 0;
            OldPer = 0;
        }
        NewGlobal = g_GlobalProcOptions | (Options & PROCESS_GLOBAL);
        break;
        
    case OPTFN_REMOVE:
        if (Options & ~PROCESS_GLOBAL)
        {
            if (g_CurrentProcess == NULL)
            {
                Status = E_UNEXPECTED;
                goto Exit;
            }
        
            OldPer = g_CurrentProcess->Options;
            NewPer = OldPer & ~(Options & ~PROCESS_GLOBAL);
        }
        else
        {
            NewPer = 0;
            OldPer = 0;
        }
        NewGlobal = g_GlobalProcOptions & ~(Options & PROCESS_GLOBAL);
        break;
        
    case OPTFN_SET:
        // Always require a process in this case as otherwise
        // there's no way to know whether a call to SetProcessOptions
        // is actually necessary or not.
        if (g_CurrentProcess == NULL)
        {
            Status = E_UNEXPECTED;
            goto Exit;
        }
        
        OldPer = g_CurrentProcess->Options;
        NewPer = Options & ~PROCESS_GLOBAL;
        NewGlobal = Options & PROCESS_GLOBAL;
        break;
    }
    
    PUSER_DEBUG_SERVICES Services = ((UserTargetInfo*)g_Target)->m_Services;
    BOOL Notify = FALSE;
    
    if (NewGlobal ^ g_GlobalProcOptions)
    {
        // Global options can only be changed by the session thread.
        if (::GetCurrentThreadId() != g_SessionThread)
        {
            Status = E_UNEXPECTED;
            goto Exit;
        }

        if ((Status = Services->SetDebugObjectOptions(0, NewGlobal)) != S_OK)
        {
            goto Exit;
        }
        
        Notify = TRUE;
        g_GlobalProcOptions = NewGlobal;
    }

    if (NewPer ^ OldPer)
    {
        if ((Status = Services->
             SetProcessOptions(g_CurrentProcess->FullHandle, NewPer)) != S_OK)
        {
            goto Exit;
        }

        g_CurrentProcess->Options = NewPer;
        Notify = TRUE;
    }

    if (Notify)
    {
        NotifyChangeEngineState(DEBUG_CES_PROCESS_OPTIONS,
                                NewPer | NewGlobal, FALSE);
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AddProcessOptions(
    THIS_
    IN ULONG Options
    )
{
    return ChangeProcessOptions(Options, OPTFN_ADD);
}

STDMETHODIMP
DebugClient::RemoveProcessOptions(
    THIS_
    IN ULONG Options
    )
{
    return ChangeProcessOptions(Options, OPTFN_REMOVE);
}

STDMETHODIMP
DebugClient::SetProcessOptions(
    THIS_
    IN ULONG Options
    )
{
    return ChangeProcessOptions(Options, OPTFN_SET);
}

STDMETHODIMP
DebugClient::OpenDumpFile(
    THIS_
    IN PCSTR DumpFile
    )
{
    ENTER_ENGINE();

    HRESULT Status;

    if (g_SessionThread != 0)
    {
        // A session is already active.
        Status = E_UNEXPECTED;
        goto EH_Exit;
    }

    ULONG Class, Qual;

    if ((Status = InitNtCmd(this)) != S_OK)
    {
        goto EH_Exit;
    }

    //
    // Automatically expand CAB files.
    //

    PCSTR OpenFile = DumpFile;
    char CabDumpFile[2 * MAX_PATH];
    INT_PTR CabDumpFh = -1;
    PSTR Ext;

    Ext = strrchr(DumpFile, '.');
    if (Ext != NULL && _stricmp(Ext, ".cab") == 0)
    {
        // Expand the first .dmp or .mdmp file in the CAB.
        // Mark it as delete-on-close so it always gets
        // cleaned up regardless of how the process exits.
        if (ExpandDumpCab(DumpFile, _O_CREAT | _O_EXCL | _O_TEMPORARY,
                          CabDumpFile, &CabDumpFh) == S_OK)
        {
            OpenFile = CabDumpFile;
            dprintf("Extracted %s\n", OpenFile);
        }
    }
    
    Status = DmpInitialize(OpenFile);

    if (CabDumpFh >= 0)
    {
        // We expanded a file from a CAB and can close it
        // now because it was either reopened or we need
        // to get rid of it.
        _close((int)CabDumpFh);
    }
    
    if (Status != S_OK)
    {
        ErrOut("Could not initialize dump file [%s], %s\n    \"%s\"\n",
               DumpFile, FormatStatusCode(Status),
               FormatStatusArgs(Status, &DumpFile));
        goto EH_Exit;
    }

    g_Target = g_DumpTargets[g_DumpType];

    Status = InitializeTarget();
    if (Status != S_OK)
    {
        DmpUninitialize();
    }
    else
    {
        dprintf("%s", IS_KERNEL_TARGET() ? g_WinKernelVersionString :
                g_WinUserVersionString);

        InitializePrimary();
    }

 EH_Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteDumpFile(
    THIS_
    IN PCSTR DumpFile,
    IN ULONG Qualifier
    )
{
    return WriteDumpFile2(DumpFile, Qualifier, DEBUG_FORMAT_DEFAULT, NULL);
}

#define ALL_CONNECT_SESSION_FLAGS \
    (DEBUG_CONNECT_SESSION_NO_VERSION | \
     DEBUG_CONNECT_SESSION_NO_ANNOUNCE)

STDMETHODIMP
DebugClient::ConnectSession(
    THIS_
    IN ULONG Flags,
    IN ULONG HistoryLimit
    )
{
    if (Flags & ~ALL_CONNECT_SESSION_FLAGS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    PushOutCtl(DEBUG_OUTCTL_THIS_CLIENT | DEBUG_OUTCTL_NOT_LOGGED,
               this, &OldCtl);

    if ((Flags & DEBUG_CONNECT_SESSION_NO_VERSION) == 0)
    {
        if (IS_KERNEL_TARGET())
        {
            dprintf("%s", g_WinKernelVersionString);
        }
        else if (g_TargetPlatformId != VER_PLATFORM_WIN32_NT)
        {
            dprintf("%s", g_Win9xVersionString);
        }
        else
        {
            dprintf("%s", g_WinUserVersionString);
        }
    }

    SendOutputHistory(this, HistoryLimit);

    // If we're in the middle of an input request and
    // a new client has joined immediately start
    // the input cycle for it.
    ULONG InputRequest = g_InputSizeRequested;

    if (InputRequest > 0)
    {
        m_InputSequence = 1;
        if (m_InputCb != NULL)
        {
            m_InputCb->StartInput(InputRequest);
        }
    }

    PopOutCtl(&OldCtl);

    if ((Flags & DEBUG_CONNECT_SESSION_NO_ANNOUNCE) == 0)
    {
        InitializePrimary();
        dprintf("%s connected at %s", m_Identity, ctime(&m_LastActivity));
    }

    LEAVE_ENGINE();
    return S_OK;
}

DBGRPC_SIMPLE_FACTORY(DebugClient, IID_IDebugClient, \
                      "Debugger Server", ())
DebugClientFactory g_DebugClientFactory;

STDMETHODIMP
DebugClient::StartServer(
    THIS_
    IN PCSTR Options
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = DbgRpcCreateServer(Options, &g_DebugClientFactory);
    if (Status == S_OK)
    {
        // Turn on output history collection.
        g_OutHistoryMask = DEFAULT_OUT_HISTORY_MASK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OutputServers(
    THIS_
    IN ULONG OutputControl,
    IN PCSTR Machine,
    IN ULONG Flags
    )
{
    if (Flags & ~DEBUG_SERVERS_ALL)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        LONG RegStatus;
        HKEY RegKey;
        HKEY Key;

        Status = S_OK;

        if ((RegStatus = RegConnectRegistry(Machine, HKEY_LOCAL_MACHINE,
                                            &RegKey)) != ERROR_SUCCESS)
        {
            Status = HRESULT_FROM_WIN32(RegStatus);
            goto Pop;
        }
        if ((RegStatus = RegOpenKeyEx(RegKey, DEBUG_SERVER_KEY,
                                      0, KEY_ALL_ACCESS,
                                      &Key)) != ERROR_SUCCESS)
        {
            // Don't report not-found as an error since it just
            // means there's nothing to enumerate.
            if (RegStatus != ERROR_FILE_NOT_FOUND)
            {
                Status = HRESULT_FROM_WIN32(RegStatus);
            }
            goto RegClose;
        }

        ULONG Index;
        char Name[32];
        char Value[2 * MAX_PARAM_VALUE];
        ULONG NameLen, ValueLen;
        ULONG Type;

        Index = 0;
        for (;;)
        {
            NameLen = sizeof(Name);
            ValueLen = sizeof(Value);
            if ((RegStatus = RegEnumValue(Key, Index, Name, &NameLen,
                                          NULL, &Type, (LPBYTE)Value,
                                          &ValueLen)) != ERROR_SUCCESS)
            {
                // Done with the enumeration.
                break;
            }
            if (Type != REG_SZ)
            {
                // Only string values should be present.
                Status = E_FAIL;
                break;
            }

            BOOL Output;

            Output = FALSE;
            if (!strncmp(Value, "Debugger Server", 15))
            {
                if (Flags & DEBUG_SERVERS_DEBUGGER)
                {
                    Output = TRUE;
                }
            }
            else if (Flags & DEBUG_SERVERS_PROCESS)
            {
                Output = TRUE;
            }

            if (Output)
            {
                dprintf("%s\n", Value);
            }

            Index++;
        }

        RegCloseKey(Key);
    RegClose:
        RegCloseKey(RegKey);
    Pop:
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::TerminateProcesses(
    THIS
    )
{
    if (!IS_LIVE_USER_TARGET())
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;

    ENTER_ENGINE();

    Status = ::TerminateProcesses();

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::DetachProcesses(
    THIS
    )
{
    if (!IS_LIVE_USER_TARGET())
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;

    ENTER_ENGINE();

    Status = ::DetachProcesses();

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::EndSession(
    THIS_
    IN ULONG Flags
    )
{
    if (
#if DEBUG_END_PASSIVE > 0
        Flags < DEBUG_END_PASSIVE ||
#endif
        Flags > DEBUG_END_REENTRANT)
    {
        return E_INVALIDARG;
    }

    if (Flags == DEBUG_END_REENTRANT)
    {
        // If somebody's doing a reentrant end that means
        // the process is going away so we can clean up
        // any running server registration entries.
        DbgRpcDeregisterServers();
    }

    if (!IS_TARGET_SET())
    {
        return E_UNEXPECTED;
    }

    HRESULT Status = S_OK;

    if (Flags == DEBUG_END_REENTRANT)
    {
        goto Reenter;
    }

    ENTER_ENGINE();

    if (IS_LIVE_USER_TARGET())
    {
        // If this is an active end, terminate or detach.
        if (Flags == DEBUG_END_ACTIVE_TERMINATE)
        {
            Status = ::TerminateProcesses();
            if (FAILED(Status))
            {
                goto Leave;
            }
        }
        else if (Flags == DEBUG_END_ACTIVE_DETACH)
        {
            Status = ::DetachProcesses();
            if (FAILED(Status))
            {
                goto Leave;
            }
        }
    }

 Reenter:
    if (IS_LIVE_USER_TARGET() && SYSTEM_PROCESSES() &&
        (g_GlobalProcOptions & DEBUG_PROCESS_DETACH_ON_EXIT) == 0)
    {
        //
        // If we try to quit while debugging CSRSS, raise an
        // error.
        //

        if (Flags != DEBUG_END_REENTRANT)
        {
            ErrOut("(%d): FATAL ERROR: Exiting Debugger while debugging CSR\n",
                   ::GetCurrentProcessId());
        }
        g_NtDllCalls.DbgPrint("(%d): FATAL ERROR: "
                              "Exiting Debugger while debugging CSR\n",
                              ::GetCurrentProcessId());

        if (g_DebuggerPlatformId == VER_PLATFORM_WIN32_NT)
        {
            g_NtDllCalls.NtSystemDebugControl
                (SysDbgBreakPoint, NULL, 0, NULL, 0, 0);
        }

        DebugBreak();
    }

    if (Flags != DEBUG_END_REENTRANT)
    {
        DiscardTarget(Flags == DEBUG_END_ACTIVE_TERMINATE ?
                      DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE :
                      (Flags == DEBUG_END_ACTIVE_DETACH ?
                       DEBUG_SESSION_END_SESSION_ACTIVE_DETACH :
                       DEBUG_SESSION_END_SESSION_PASSIVE));
    }

 Leave:
    if (Flags != DEBUG_END_REENTRANT)
    {
        LEAVE_ENGINE();
    }
    return Status;
}

STDMETHODIMP
DebugClient::GetExitCode(
    THIS_
    OUT PULONG Code
    )
{
    ENTER_ENGINE();

    HRESULT Status;

    if (!IS_LIVE_USER_TARGET() || g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = ((UserTargetInfo*)g_Target)->m_Services->
            GetProcessExitCode(g_CurrentProcess->FullHandle, Code);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::DispatchCallbacks(
    THIS_
    IN ULONG Timeout
    )
{
    DWORD Wait;

    // This constitutes interesting activity.
    m_LastActivity = time(NULL);

    // Do not hold the engine lock while waiting.

    for (;;)
    {
        Wait = WaitForSingleObjectEx(m_DispatchSema, Timeout, TRUE);
        if (Wait == WAIT_OBJECT_0)
        {
            return S_OK;
        }
        else if (Wait == WAIT_TIMEOUT)
        {
            return S_FALSE;
        }
        else if (Wait != WAIT_IO_COMPLETION)
        {
            return WIN32_LAST_STATUS();
        }
    }
}

STDMETHODIMP
DebugClient::ExitDispatch(
    THIS_
    IN PDEBUG_CLIENT Client
    )
{
    // This method is reentrant.

    if (!ReleaseSemaphore(((DebugClient*)(IDebugClientN*)Client)->
                          m_DispatchSema, 1, NULL))
    {
        return WIN32_LAST_STATUS();
    }
    else
    {
        return S_OK;
    }
}

STDMETHODIMP
DebugClient::CreateClient(
    THIS_
    OUT PDEBUG_CLIENT* Client
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    DebugClient* DbgClient = new DebugClient;
    if (DbgClient == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        if ((Status = DbgClient->Initialize()) == S_OK)
        {
            DbgClient->Link();
            *Client = (PDEBUG_CLIENT)(IDebugClientN*)DbgClient;
        }
        else
        {
            DbgClient->Release();
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetInputCallbacks(
    THIS_
    OUT PDEBUG_INPUT_CALLBACKS* Callbacks
    )
{
    ENTER_ENGINE();

    *Callbacks = m_InputCb;
    m_InputCb->AddRef();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetInputCallbacks(
    THIS_
    IN PDEBUG_INPUT_CALLBACKS Callbacks
    )
{
    ENTER_ENGINE();

    TRANSFER(m_InputCb, Callbacks);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetOutputCallbacks(
    THIS_
    OUT PDEBUG_OUTPUT_CALLBACKS* Callbacks
    )
{
    ENTER_ENGINE();

    *Callbacks = m_OutputCb;
    m_OutputCb->AddRef();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetOutputCallbacks(
    THIS_
    IN PDEBUG_OUTPUT_CALLBACKS Callbacks
    )
{
    ENTER_ENGINE();

    TRANSFER(m_OutputCb, Callbacks);
    CollectOutMasks();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetOutputMask(
    THIS_
    OUT PULONG Mask
    )
{
    // This method is reentrant.
    *Mask = m_OutMask;
    return S_OK;
}

STDMETHODIMP
DebugClient::SetOutputMask(
    THIS_
    IN ULONG Mask
    )
{
    // This method is reentrant.
    m_OutMask = Mask;
    CollectOutMasks();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetOtherOutputMask(
    THIS_
    IN PDEBUG_CLIENT Client,
    OUT PULONG Mask
    )
{
    return Client->GetOutputMask(Mask);
}

STDMETHODIMP
DebugClient::SetOtherOutputMask(
    THIS_
    IN PDEBUG_CLIENT Client,
    IN ULONG Mask
    )
{
    return Client->SetOutputMask(Mask);
}

STDMETHODIMP
DebugClient::GetOutputWidth(
    THIS_
    OUT PULONG Columns
    )
{
    ENTER_ENGINE();

    *Columns = m_OutputWidth;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetOutputWidth(
    THIS_
    IN ULONG Columns
    )
{
    if (Columns < 1)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    m_OutputWidth = Columns;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetOutputLinePrefix(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG PrefixSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = FillStringBuffer(m_OutputLinePrefix, 0,
                              Buffer, BufferSize, PrefixSize);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetOutputLinePrefix(
    THIS_
    IN OPTIONAL PCSTR Prefix
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    ULONG Len;

    Status = ChangeString((PSTR*)&m_OutputLinePrefix, &Len, Prefix);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetIdentity(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG IdentitySize
    )
{
    return FillStringBuffer(m_Identity, 0,
                            Buffer, BufferSize, IdentitySize);
}

STDMETHODIMP
DebugClient::OutputIdentity(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Flags,
    IN PCSTR Format
    )
{
    HRESULT Status;

    if (Flags != DEBUG_OUTPUT_IDENTITY_DEFAULT)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        dprintf(Format, m_Identity);

        Status = S_OK;
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetEventCallbacks(
    THIS_
    OUT PDEBUG_EVENT_CALLBACKS* Callbacks
    )
{
    ENTER_ENGINE();

    *Callbacks = m_EventCb;
    m_EventCb->AddRef();

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetEventCallbacks(
    THIS_
    IN PDEBUG_EVENT_CALLBACKS Callbacks
    )
{
    ENTER_ENGINE();

    HRESULT Status;
    ULONG Interest;

    if (Callbacks != NULL)
    {
        Status = Callbacks->GetInterestMask(&Interest);
    }
    else
    {
        Status = S_OK;
        Interest = 0;
    }

    if (Status == S_OK)
    {
        TRANSFER(m_EventCb, Callbacks);
        m_EventInterest = Interest;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::FlushCallbacks(
    THIS
    )
{
    ::FlushCallbacks();
    return S_OK;
}

STDMETHODIMP
DebugClient::WriteDumpFile2(
    THIS_
    IN PCSTR DumpFile,
    IN ULONG Qualifier,
    IN ULONG FormatFlags,
    IN OPTIONAL PCSTR Comment
    )
{
    HRESULT Status;

    if ((IS_KERNEL_TARGET() &&
         (Qualifier < DEBUG_KERNEL_SMALL_DUMP ||
          Qualifier > DEBUG_KERNEL_FULL_DUMP)) ||
        (IS_USER_TARGET() &&
         (Qualifier < DEBUG_USER_WINDOWS_SMALL_DUMP ||
          Qualifier > DEBUG_USER_WINDOWS_DUMP)))
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    Status = ::WriteDumpFile(DumpFile, Qualifier, FormatFlags, Comment);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AddDumpInformationFile(
    THIS_
    IN PCSTR InfoFile,
    IN ULONG Type
    )
{
    HRESULT Status;

    if (Type != DEBUG_DUMP_FILE_PAGE_FILE_DUMP)
    {
        return E_INVALIDARG;
    }
    
    ENTER_ENGINE();
    
    // This method must be called before OpenDumpFile.
    if (IS_TARGET_SET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = AddDumpInfoFile(InfoFile, DUMP_INFO_PAGE_FILE,
                                 64 * 1024);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::EndProcessServer(
    THIS_
    IN ULONG64 Server
    )
{
    return ((IUserDebugServices*)Server)->
        Uninitialize(TRUE);
}

STDMETHODIMP
DebugClient::WaitForProcessServerEnd(
    THIS_
    IN ULONG Timeout
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_UserServicesUninitialized)
    {
        Status = S_OK;
    }
    else
    {
        //
        // This could be done with an event to get true
        // waiting but precision isn't that important.
        //

        HRESULT Status = S_FALSE;

        while (Timeout)
        {
            ULONG UseTimeout;

            UseTimeout = min(1000, Timeout);
            Sleep(UseTimeout);
            
            if (g_UserServicesUninitialized)
            {
                Status = S_OK;
                break;
            }
        
            if (Timeout != INFINITE)
            {
                Timeout -= UseTimeout;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::IsKernelDebuggerEnabled(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_DebuggerPlatformId != VER_PLATFORM_WIN32_NT)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        NTSTATUS NtStatus;
        SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo;

        NtStatus = g_NtDllCalls.
            NtQuerySystemInformation(SystemKernelDebuggerInformation,
                                     &KdInfo, sizeof(KdInfo), NULL);
        if (NT_SUCCESS(NtStatus))
        {
            Status = KdInfo.KernelDebuggerEnabled ? S_OK : S_FALSE;
        }
        else
        {
            Status = HRESULT_FROM_NT(NtStatus);
        }
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::TerminateCurrentProcess(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = SeparateCurrentProcess(SEP_TERMINATE, NULL);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::DetachCurrentProcess(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = SeparateCurrentProcess(SEP_DETACH, NULL);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AbandonCurrentProcess(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = SeparateCurrentProcess(SEP_ABANDON, NULL);

    LEAVE_ENGINE();
    return Status;
}

HRESULT
DebugClient::Initialize(void)
{
    m_DispatchSema = CreateSemaphore(NULL, 0, 0x7fffffff, NULL);
    if (m_DispatchSema == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    if (!DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),
                         GetCurrentProcess(), &m_Thread,
                         0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        return WIN32_LAST_STATUS();
    }

    // If we're requesting input allow this client
    // to return input immediately.
    if (g_InputSizeRequested > 0)
    {
        m_InputSequence = 1;
    }

    return S_OK;
}

void
DebugClient::InitializePrimary(void)
{
    m_Flags |= CLIENT_PRIMARY;
    if ((m_Flags & CLIENT_REMOTE) == 0)
    {
        // Can't call GetClientIdentity here as it uses
        // many system APIs and therefore can cause trouble
        // when debugging system processes such as LSA.
        strcpy(m_Identity, "HostMachine\\HostUser");
    }
    m_LastActivity = time(NULL);
}

void
DebugClient::Link(void)
{
    EnterCriticalSection(&g_QuickLock);

    // Keep list grouped by thread ID.
    DebugClient* Cur;

    for (Cur = g_Clients; Cur != NULL; Cur = Cur->m_Next)
    {
        if (Cur->m_ThreadId == m_ThreadId)
        {
            break;
        }
    }

    m_Prev = Cur;
    if (Cur != NULL)
    {
        m_Next = Cur->m_Next;
        Cur->m_Next = this;
    }
    else
    {
        // No ID match so just put it in the front.
        m_Next = g_Clients;
        g_Clients = this;
    }
    if (m_Next != NULL)
    {
        m_Next->m_Prev = this;
    }

    m_Flags |= CLIENT_IN_LIST;

    LeaveCriticalSection(&g_QuickLock);
}

void
DebugClient::Unlink(void)
{
    EnterCriticalSection(&g_QuickLock);

    m_Flags &= ~CLIENT_IN_LIST;

    if (m_Next != NULL)
    {
        m_Next->m_Prev = m_Prev;
    }
    if (m_Prev != NULL)
    {
        m_Prev->m_Next = m_Next;
    }
    else
    {
        g_Clients = m_Next;
    }

    LeaveCriticalSection(&g_QuickLock);
}

//----------------------------------------------------------------------------
//
// Initialize/uninitalize functions.
//
//----------------------------------------------------------------------------

ULONG NTAPI
Win9xDbgPrompt( char *Prompt, char *buffer, ULONG cb)
{
    return gets(buffer) ? strlen(buffer) : 0;
}

ULONG __cdecl
Win9xDbgPrint( char *Text, ... )
{
    char Temp[OUT_BUFFER_SIZE];
    va_list valist;

    va_start(valist, Text);
    wvsprintf(Temp, Text, valist);
    OutputDebugString(Temp);
    va_end(valist);

    return 0;
}

HRESULT
OneTimeInitialization(void)
{
    static BOOL Init = FALSE;
    if (Init)
    {
        return S_OK;
    }

    // This function is called exactly once at the first
    // DebugCreate for a process.  It should perform any
    // global one-time initialization necessary.
    // Nothing initialized here will be explicitly cleaned
    // up, instead it should all be the kind of thing
    // that can wait for process cleanup.

    HRESULT Status = S_OK;

    // These sizes are hard-coded into the remoting script
    // so verify them to ensure no mismatch.
    C_ASSERT(sizeof(DEBUG_BREAKPOINT_PARAMETERS) == 56);
    C_ASSERT(sizeof(DEBUG_STACK_FRAME) == 128);
    C_ASSERT(sizeof(DEBUG_VALUE) == 32);
    C_ASSERT(sizeof(DEBUG_REGISTER_DESCRIPTION) == 32);
    C_ASSERT(sizeof(DEBUG_SYMBOL_PARAMETERS) == 32);
    C_ASSERT(sizeof(DEBUG_MODULE_PARAMETERS) == 64);
    C_ASSERT(sizeof(DEBUG_SPECIFIC_FILTER_PARAMETERS) == 20);
    C_ASSERT(sizeof(DEBUG_EXCEPTION_FILTER_PARAMETERS) == 24);
    C_ASSERT(sizeof(EXCEPTION_RECORD64) == 152);
    C_ASSERT(sizeof(MEMORY_BASIC_INFORMATION64) == 48);

    SYSTEM_INFO SystemInfo;

    GetSystemInfo(&SystemInfo);
    g_DumpCacheGranularity = SystemInfo.dwAllocationGranularity;

    // Get the debugger host system's OS type.  Note that
    // this may be different from g_TargetPlatformId, which
    // is the OS type of the debug target.
    OSVERSIONINFO OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
    if (!GetVersionEx(&OsVersionInfo))
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Fail;
    }
    g_DebuggerPlatformId = OsVersionInfo.dwPlatformId;

    if (g_DebuggerPlatformId == VER_PLATFORM_WIN32_NT)
    {
        if ((Status = InitDynamicCalls(&g_NtDllCallsDesc)) != S_OK)
        {
            goto EH_Fail;
        }
    }
    else
    {
        g_NtDllCalls.DbgPrint = Win9xDbgPrint;
        g_NtDllCalls.DbgPrompt = Win9xDbgPrompt;
    }
    
    if ((Status = InitDynamicCalls(&g_Kernel32CallsDesc)) != S_OK)
    {
        goto EH_Fail;
    }

    if ((Status = InitDynamicCalls(&g_Advapi32CallsDesc)) != S_OK)
    {
        goto EH_Fail;
    }
    
    ULONG SvcFlags;
    
    if ((Status = g_LiveUserDebugServices.Initialize(&SvcFlags)) != S_OK)
    {
        goto EH_Fail;
    }
    
    g_InputEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (g_InputEvent == NULL)
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Fail;
    }

    g_EventStatusWaiting = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (g_EventStatusWaiting == NULL)
    {
        Status = WIN32_LAST_STATUS();
        goto EH_InputEvent;
    }

    g_EventStatusReady = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (g_EventStatusReady == NULL)
    {
        Status = WIN32_LAST_STATUS();
        goto EH_EventStatusWaiting;
    }

    g_SleepPidEvent = CreatePidEvent(GetCurrentProcessId(), CREATE_NEW);
    if (g_SleepPidEvent == NULL)
    {
        Status = E_FAIL;
        goto EH_EventStatusReady;
    }

    if ((Status = InitializeAllAccessSecObj()) != S_OK)
    {
        goto EH_SleepPidEvent;
    }
    
    __try
    {
        InitializeCriticalSection(&g_QuickLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = HRESULT_FROM_NT(GetExceptionCode());
        goto EH_AllAccessObj;
    }

    __try
    {
        InitializeCriticalSection(&g_EngineLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = HRESULT_FROM_NT(GetExceptionCode());
        goto EH_QuickLock;
    }

    g_SrcPath = getenv("_NT_SOURCE_PATH");
    if (g_SrcPath != NULL)
    {
        // This path must be in allocated space.
        // If this fails it's not catastrophic.
        g_SrcPath = _strdup(g_SrcPath);
    }

    // Initialize default machines.  This is to make machine
    // information available early for querying.  Things
    // will get reinitialized every time the true target
    // machine type is discovered.
    InitializeMachines(IMAGE_FILE_MACHINE_UNKNOWN);

    // Set default symbol options.
    SymSetOptions(g_SymOptions);

    if (getenv("KDQUIET"))
    {
        g_QuietMode = TRUE;
    }
    else
    {
        g_QuietMode = FALSE;
    }

    ReadDebugOptions(TRUE, NULL);

    PCSTR Env;

#if DBG
    // Get default out mask from environment variables.
    Env = getenv("DBGENG_OUT_MASK");
    if (Env != NULL)
    {
        ULONG Mask = strtoul(Env, NULL, 0);
        g_EnvOutMask |= Mask;
        g_LogMask |= Mask;
    }
#endif

    Env = getenv("_NT_DEBUG_HISTORY_SIZE");
    if (Env != NULL)
    {
        g_OutHistoryRequestedSize = atoi(Env) * 1024;
    }

    InitKdFileAssoc();
    
    Init = TRUE;

    return S_OK;

 EH_QuickLock:
    DeleteCriticalSection(&g_QuickLock);
 EH_AllAccessObj:
    DeleteAllAccessSecObj();
 EH_SleepPidEvent:
    CloseHandle(g_SleepPidEvent);
    g_SleepPidEvent = NULL;
 EH_EventStatusReady:
    CloseHandle(g_EventStatusReady);
    g_EventStatusReady = NULL;
 EH_EventStatusWaiting:
    CloseHandle(g_EventStatusWaiting);
    g_EventStatusWaiting = NULL;
 EH_InputEvent:
    CloseHandle(g_InputEvent);
    g_InputEvent = NULL;
 EH_Fail:
    return Status;
}

STDAPI
DebugConnect(
    IN PCSTR RemoteOptions,
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;

    if ((Status = OneTimeInitialization()) != S_OK)
    {
        return Status;
    }

    IUnknown* Client;

    if ((Status = DbgRpcConnectServer(RemoteOptions, &IID_IDebugClient,
                                      &Client)) != S_OK)
    {
        return Status;
    }

    Status = Client->QueryInterface(InterfaceId, Interface);

    Client->Release();
    return Status;
}

STDAPI
DebugCreate(
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;

    if ((Status = OneTimeInitialization()) != S_OK)
    {
        return Status;
    }

    DebugClient* Client = new DebugClient;
    if (Client == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        if ((Status = Client->Initialize()) == S_OK)
        {
            Status = Client->QueryInterface(InterfaceId, Interface);
            if (Status == S_OK)
            {
                Client->Link();
            }
        }

        Client->Release();
    }

    return Status;
}

HRESULT
LiveKernelInitialize(DebugClient* Client, ULONG Qual, PCSTR Options)
{
    HRESULT Status;

    if (g_SessionThread != 0)
    {
        // A session is already active.
        return E_UNEXPECTED;
    }

    if ((Status = InitNtCmd(Client)) != S_OK)
    {
        return Status;
    }
    
    g_TargetClass = DEBUG_CLASS_KERNEL;
    g_TargetClassQualifier = Qual;
    if (Qual == DEBUG_KERNEL_CONNECTION)
    {
        g_Target = &g_ConnLiveKernelTarget;
    }
    else if (Qual == DEBUG_KERNEL_LOCAL)
    {
        //
        // We need to get the debug privilege to enable local kernel debugging
        //
        if ((Status = EnableDebugPrivilege()) != S_OK)
        {
            ErrOut("Unable to enable debug privilege, %s\n    \"%s\"\n",
                   FormatStatusCode(Status), FormatStatus(Status));
            return Status;
        }
        
        g_Target = &g_LocalLiveKernelTarget;
    }
    else
    {
        g_Target = &g_ExdiLiveKernelTarget;
    }

    // These options only need to stay valid until Initialize.
    ((LiveKernelTargetInfo*)g_Target)->m_ConnectOptions = Options;

    Status = InitializeTarget();
    if (Status != S_OK)
    {
        return Status;
    }

    if (IS_REMOTE_KERNEL_TARGET())
    {
        //
        // Check environment variables for configuration settings
        //

        PCHAR CacheEnv = getenv("_NT_DEBUG_CACHE_SIZE");
        if (CacheEnv != NULL)
        {
            g_VirtualCache.m_MaxSize = atol(CacheEnv);
            g_PhysicalCache.m_MaxSize = g_VirtualCache.m_MaxSize;
        }

        g_VirtualCache.m_DecodePTEs = TRUE;
    }

    // Other target configuration information is retrieved in various
    // places during KD init.

    dprintf("%s", g_WinKernelVersionString);

    if (IS_CONN_KERNEL_TARGET())
    {
        dprintf("Waiting to reconnect...\n");
    }

    return S_OK;
}

HRESULT
UserInitialize(DebugClient* Client, ULONG64 Server)
{
    HRESULT Status;
    PUSER_DEBUG_SERVICES Services;
    ULONG Qual;

    if ((Status = InitNtCmd(Client)) != S_OK)
    {
        return Status;
    }
    
    if (Server == 0)
    {
        Services = new LiveUserDebugServices(FALSE);
        if (Services == NULL)
        {
            return E_OUTOFMEMORY;
        }

        Qual = DEBUG_USER_WINDOWS_PROCESS;
        g_Target = &g_LocalUserTarget;
    }
    else
    {
        Services = (PUSER_DEBUG_SERVICES)Server;
        Services->AddRef();
        Qual = DEBUG_USER_WINDOWS_PROCESS_SERVER;
        g_Target = &g_RemoteUserTarget;
    }

    if ((Status = Services->
         Initialize(&((UserTargetInfo*)g_Target)->m_ServiceFlags)) == S_OK)
    {
        g_TargetClass = DEBUG_CLASS_USER_WINDOWS;
        g_TargetClassQualifier = Qual;
        ((UserTargetInfo*)g_Target)->m_Services = Services;

        Status = InitializeTarget();
        if (Status == S_OK)
        {
            g_VirtualCache.m_DecodePTEs = FALSE;

            dprintf("%s", g_WinUserVersionString);

            return S_OK;
        }
    }

    // Error path
    if (Qual == DEBUG_USER_WINDOWS_PROCESS)
    {
        delete(Services);
    }
    return Status;
}

HRESULT
InitializeTarget(void)
{
    HRESULT Status;

    DBG_ASSERT(g_SessionThread == 0);
    g_SessionThread = GetCurrentThreadId();

    if ((Status = g_Target->Initialize()) != S_OK)
    {
        DiscardTarget(DEBUG_SESSION_END_SESSION_PASSIVE);
    }

    return Status;
}

HRESULT
InitializeMachine(ULONG Machine)
{
    HRESULT Status;

    // Dump initialization initializes machines so
    // don't reinitialize them.
    if (g_TargetMachineType == IMAGE_FILE_MACHINE_UNKNOWN)
    {
        InitializeMachines(Machine);
    }

    SetEffMachine(Machine, TRUE);
    // Executing machine is not set as code execution
    // status is unknown.  The executing machine will
    // be updated when a wait completes.

    Status = BreakpointInit();
    if (Status != S_OK)
    {
        InitializeMachines(IMAGE_FILE_MACHINE_UNKNOWN);
        SetEffMachine(IMAGE_FILE_MACHINE_UNKNOWN, TRUE);
        return Status;
    }

    // X86 prefers registers to be displayed at the prompt unless
    // we're on a kernel connection where it would force a context
    // load all the time.
    if (Machine == IMAGE_FILE_MACHINE_I386 &&
        (IS_DUMP_TARGET() || IS_USER_TARGET()))
    {
        g_OciOutputRegs = TRUE;
    }

    g_MachineInitialized = TRUE;

    //
    // Load extensions after this is set so Extensions can query information
    // during machine initialization
    //

    LoadMachineExtensions();

    // Now that all initialization is done, send initial
    // notification that a debuggee exists.
    NotifySessionStatus(DEBUG_SESSION_ACTIVE);
    NotifyChangeDebuggeeState(DEBUG_CDS_ALL, 0);
    NotifyExtensions(DEBUG_NOTIFY_SESSION_ACTIVE, 0);

    return S_OK;
}

void
DiscardTarget(ULONG Reason)
{
    if (g_MachineInitialized)
    {
        DiscardMachine(Reason);
    }

    g_Target->Uninitialize();

    g_SessionThread = 0;
    g_TargetClass = DEBUG_CLASS_UNINITIALIZED;
    g_Target = &g_UnexpectedTarget;
    g_TargetClassQualifier = 0;

    g_ThreadToResume = NULL;

    g_GlobalProcOptions = 0;
    g_NextProcessUserId = 0;
    g_EngStatus = 0;
    g_EngDefer = 0;
    g_EngErr = 0;
    g_OutHistRead = NULL;
    g_OutHistWrite = NULL;
    g_OutHistoryMask = 0;
    g_OutHistoryUsed = 0;
}

void
DiscardMachine(ULONG Reason)
{
    g_MachineInitialized = FALSE;
    g_CmdState = 'i';
    g_ExecutionStatusRequest = DEBUG_STATUS_NO_CHANGE;

    PPROCESS_INFO Process;

    for (Process = g_ProcessHead;
         Process != NULL;
         Process = Process->Next)
    {
        Process->Exited = TRUE;
    }

    // Breakpoint removal must wait until all processes are marked as
    // exited to avoid asserts on breakpoints that are inserted.
    RemoveAllBreakpoints(Reason);

    DeleteExitedInfos();
    DiscardPendingProcesses();
    
    g_NumUnloadedModules = 0;

    g_VirtualCache.SetForceDecodePtes(FALSE);
    DiscardLastEvent();
    ClearEventLog();
    ZeroMemory(&g_LastEventInfo, sizeof(g_LastEventInfo));
    g_EventProcess = NULL;
    g_EventThread = NULL;
    g_CurrentProcess = NULL;
    ResetImplicitData();

    g_OciOutputRegs = FALSE;
    DbgKdApi64 = FALSE;
    ZeroMemory(&KdDebuggerData, sizeof(KdDebuggerData));
    g_KdMaxPacketType = 0;
    g_KdMaxStateChange = 0;
    g_KdMaxManipulate = 0;

    g_SystemVersion = SVER_INVALID;
    g_ActualSystemVersion = SVER_INVALID;
    g_TargetCheckedBuild = 0;
    g_TargetBuildNumber = 0;
    g_TargetServicePackString[0] = 0;
    g_TargetServicePackNumber = 0;
    g_TargetPlatformId = 0;
    g_TargetBuildLabName[0] = 0;
    InitializeMachines(IMAGE_FILE_MACHINE_UNKNOWN);
    g_TargetExecMachine = IMAGE_FILE_MACHINE_UNKNOWN;
    SetEffMachine(IMAGE_FILE_MACHINE_UNKNOWN, FALSE);
    g_TargetNumberProcessors = 0;

    EXTDLL* Ext = g_ExtDlls;
    EXTDLL* ExtNext;
    while (Ext != NULL)
    {
        ExtNext = Ext->Next;
        if (!Ext->UserLoaded)
        {
            UnloadExtensionDll(Ext);
        }
        else
        {
            DeferExtensionDll(Ext);
        }
        Ext = ExtNext;
    }
    free(g_ExtensionSearchPath);
    g_ExtensionSearchPath = NULL;

    g_WatchBeginCurFunc = 1;
    g_WatchEndCurFunc = 0;
    g_WatchTrace = FALSE;
    g_WatchInitialSP = 0;
    g_StepTraceInRangeStart = (ULONG64)-1;
    g_StepTraceInRangeEnd = 0;
    
    g_EngStatus &= ~(ENG_STATUS_SUSPENDED |
                     ENG_STATUS_BREAKPOINTS_INSERTED |
                     ENG_STATUS_PROCESSES_ADDED |
                     ENG_STATUS_STATE_CHANGED |
                     ENG_STATUS_MODULES_LOADED |
                     ENG_STATUS_PREPARED_FOR_CALLS |
                     ENG_STATUS_NO_AUTO_WAIT |
                     ENG_STATUS_PENDING_BREAK_IN |
                     ENG_STATUS_AT_INITIAL_BREAK |
                     ENG_STATUS_AT_INITIAL_MODULE_LOAD |
                     ENG_STATUS_EXIT_CURRENT_WAIT |
                     ENG_STATUS_USER_INTERRUPT);
    g_EngDefer &= ~(ENG_DEFER_EXCEPTION_HANDLING |
                    ENG_DEFER_UPDATE_CONTROL_SET |
                    ENG_DEFER_HARDWARE_TRACING |
                    ENG_DEFER_OUTPUT_CURRENT_INFO |
                    ENG_DEFER_CONTINUE_EVENT);
    g_EngErr &= ~(ENG_ERR_DEBUGGER_DATA);

    g_SwitchProcessor = 0;
    g_LastSelector = -1;

    g_RegContextThread = NULL;
    g_RegContextProcessor = -1;

    ULONG i;
    for (i = 0; i < MACHIDX_COUNT; i++)
    {
        if (g_AllMachines[i] != NULL)
        {
            g_AllMachines[i]->InvalidateContext();
        }
    }

    if (IS_CONN_KERNEL_TARGET())
    {
        g_DbgKdTransport->Restart();
    }

    ::FlushCallbacks();

    // Send final notification that debuggee is gone.
    // This must be done after all the work as the lock
    // will be suspended during the callbacks, allowing
    // other threads in, so the state must be consistent.
    NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS,
                            DEBUG_STATUS_NO_DEBUGGEE, TRUE);
    NotifySessionStatus(Reason);
    NotifyExtensions(DEBUG_NOTIFY_SESSION_INACTIVE, 0);
}

//----------------------------------------------------------------------------
//
// DbgRpcClientObject implementation.
//
//----------------------------------------------------------------------------

HRESULT
DebugClient::Initialize(PSTR Identity, PVOID* Interface)
{
    HRESULT Status;

    m_Flags |= CLIENT_REMOTE;
    if ((Status = Initialize()) != S_OK)
    {
        return Status;
    }

    strcpy(m_Identity, Identity);
    *Interface = (IDebugClientN*)this;

    return S_OK;
}

void
DebugClient::Finalize(void)
{
    Link();

    // Take a reference on this object for the RPC client
    // thread to hold.
    AddRef();
}

void
DebugClient::Uninitialize(void)
{
    // Directly destroy the client object rather than releasing
    // as the remote client may have exited without politely
    // cleaning up references.
    Destroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dbgclt.hpp ===
//----------------------------------------------------------------------------
//
// Debug client classes.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#ifndef __DBGCLT_HPP__
#define __DBGCLT_HPP__

// Most-derived interfaces.  When casting back and forth
// from DebugClient to a specific interface these defines
// should be used so that when new versions of interfaces
// are added this is the only place that needs to be updated.
#define IDebugAdvancedN      IDebugAdvanced
#define IDebugClientN        IDebugClient2
#define IDebugControlN       IDebugControl2
#define IDebugDataSpacesN    IDebugDataSpaces2
#define IDebugRegistersN     IDebugRegisters
#define IDebugSymbolGroupN   IDebugSymbolGroup
#define IDebugSymbolsN       IDebugSymbols2
#define IDebugSystemObjectsN IDebugSystemObjects2

#define INPUT_BUFFER_SIZE 4096

extern BOOL g_QuietMode;

// The platform ID of the machine running the debugger.  Note
// that this may be different from g_TargetPlatformId, which
// is the platform ID of the machine being debugged.
extern ULONG g_DebuggerPlatformId;

// A lock that can be used for any short-term protection needs.
// This lock should not be held for a long time nor should
// other locks be taken when it is held.  Users of the lock
// can expect little contention and no deadlock possibilities.
extern CRITICAL_SECTION g_QuickLock;

// The global lock protecting engine state.  This lock
// should be taken everywhere and held any time engine
// activity occurs.  It should be suspended whenever a
// call needs to call out of the engine, such as with
// callbacks.
extern CRITICAL_SECTION g_EngineLock;
extern ULONG g_EngineNesting;

#define ENTER_ENGINE() \
    (EnterCriticalSection(&g_EngineLock), g_EngineNesting++)
#define LEAVE_ENGINE() \
    (::FlushCallbacks(), g_EngineNesting--, \
     LeaveCriticalSection(&g_EngineLock))
#define SUSPEND_ENGINE() \
    (::FlushCallbacks(), LeaveCriticalSection(&g_EngineLock))
#define RESUME_ENGINE() \
    EnterCriticalSection(&g_EngineLock)

// Special routine which opportunistically takes the engine lock.
inline HRESULT
TRY_ENTER_ENGINE()
{
    if (g_DebuggerPlatformId != VER_PLATFORM_WIN32_NT)
    {
        return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
    }

    if (!g_NtDllCalls.RtlTryEnterCriticalSection(&g_EngineLock))
    {
        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    g_EngineNesting++;
    return S_OK;
}
     
// Events and storage space for returning event callback
// status from an APC.
extern HANDLE g_EventStatusWaiting;
extern HANDLE g_EventStatusReady;
extern ULONG g_EventStatus;

// Named event to sleep on.
extern HANDLE g_SleepPidEvent;

extern ULONG64 g_ImplicitThreadData;
extern BOOL    g_ImplicitThreadDataIsDefault;
extern ULONG64 g_ImplicitProcessData;
extern BOOL    g_ImplicitProcessDataIsDefault;

HRESULT GetImplicitThreadData(PULONG64 Offset);
HRESULT GetImplicitThreadDataTeb(PULONG64 Offset);
HRESULT SetImplicitThreadData(ULONG64 Offset, BOOL Verbose);
HRESULT GetImplicitProcessData(PULONG64 Offset);
HRESULT GetImplicitProcessDataPeb(PULONG64 Offset);
HRESULT SetImplicitProcessData(ULONG64 Offset, BOOL Verbose);
void    ResetImplicitData(void);
void    ParseSetImplicitThread(void);
void    ParseSetImplicitProcess(void);

HRESULT
GetContextFromThreadStack(
    ULONG64 ThreadBase,
    PCROSS_PLATFORM_CONTEXT Context,
    PDEBUG_STACK_FRAME StkFrame,
    BOOL Verbose
    );
HRESULT SetContextFromThreadData(ULONG64 ThreadBase, BOOL Verbose);

//----------------------------------------------------------------------------
//
// DebugClient.
//
//----------------------------------------------------------------------------

extern DebugClient* g_Clients;

extern ULONG g_LogMask;
extern ULONG g_OutputWidth;
extern PCSTR g_OutputLinePrefix;

extern char g_InputBuffer[INPUT_BUFFER_SIZE];
extern ULONG g_InputSequence;
extern HANDLE g_InputEvent;
extern ULONG g_InputSizeRequested;

// The thread that created the current session.
extern ULONG g_SessionThread;

extern ULONG g_EngOptions;
extern ULONG g_GlobalProcOptions;

//
// Engine status flags.
//

#define ENG_STATUS_WAITING                    0x00000001
#define ENG_STATUS_SUSPENDED                  0x00000002
#define ENG_STATUS_BREAKPOINTS_INSERTED       0x00000004
#define ENG_STATUS_PROCESSES_ADDED            0x00000008
// A true system state change occurred.
#define ENG_STATUS_STATE_CHANGED              0x00000010
#define ENG_STATUS_MODULES_LOADED             0x00000020
#define ENG_STATUS_STOP_SESSION               0x00000040
#define ENG_STATUS_PREPARED_FOR_CALLS         0x00000080
#define ENG_STATUS_NO_AUTO_WAIT               0x00000100
#define ENG_STATUS_PENDING_BREAK_IN           0x00000200
#define ENG_STATUS_AT_INITIAL_BREAK           0x00000400
#define ENG_STATUS_AT_INITIAL_MODULE_LOAD     0x00000800
#define ENG_STATUS_EXIT_CURRENT_WAIT          0x00001000
#define ENG_STATUS_USER_INTERRUPT             0x00002000

extern ULONG g_EngStatus;

//
// Deferred action flags.
// These flags are set during processing in order to indicate
// actions that should be performed before execution begins
// again.
//

#define ENG_DEFER_SET_EVENT             0x00000001
#define ENG_DEFER_RESUME_THREAD         0x00000002
#define ENG_DEFER_DELETE_EXITED         0x00000004
#define ENG_DEFER_EXCEPTION_HANDLING    0x00000008
#define ENG_DEFER_UPDATE_CONTROL_SET    0x00000010
#define ENG_DEFER_HARDWARE_TRACING      0x00000020
#define ENG_DEFER_OUTPUT_CURRENT_INFO   0x00000040
#define ENG_DEFER_CONTINUE_EVENT        0x00000080

extern ULONG g_EngDefer;

//
// Error suppression flags.
// These flags are set when particular errors are displayed
// in order to avoid repeated errors.
//

#define ENG_ERR_DEBUGGER_DATA           0x00000001

extern ULONG g_EngErr;

//
// Per-client flags.
//

#define CLIENT_IN_LIST                  0x00000001
#define CLIENT_DESTROYED                0x00000002
#define CLIENT_REMOTE                   0x00000004
#define CLIENT_PRIMARY                  0x00000008

class DebugClient
    : public IDebugAdvanced,
      public IDebugClient2,
      public IDebugControl2,
      public IDebugDataSpaces2,
      public IDebugRegisters,
      public IDebugSymbols2,
      public IDebugSystemObjects2,
      public DbgRpcClientObject
{
public:
    DebugClient(void);
    ~DebugClient(void);
    void Destroy(void);

    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugAdvanced.
    STDMETHOD(GetThreadContext)(
        THIS_
        OUT PVOID Context,
        IN ULONG ContextSize
        );
    STDMETHOD(SetThreadContext)(
        THIS_
        IN PVOID Context,
        IN ULONG ContextSize
        );
    
    // IDebugClient and IDebugClient2.
    STDMETHOD(AttachKernel)(
        THIS_
        IN ULONG Flags,
        IN OPTIONAL PCSTR ConnectOptions
        );
    STDMETHOD(GetKernelConnectionOptions)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG OptionsSize
        );
    STDMETHOD(SetKernelConnectionOptions)(
        THIS_
        IN PCSTR Options
        );
    STDMETHOD(StartProcessServer)(
        THIS_
        IN ULONG Flags,
        IN PCSTR Options,
        IN PVOID Reserved
        );
    STDMETHOD(ConnectProcessServer)(
        THIS_
        IN PCSTR RemoteOptions,
        OUT PULONG64 Server
        );
    STDMETHOD(DisconnectProcessServer)(
        THIS_
        IN ULONG64 Server
        );
    STDMETHOD(GetRunningProcessSystemIds)(
        THIS_
        IN ULONG64 Server,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Count,
        OUT OPTIONAL PULONG ActualCount
        );
    STDMETHOD(GetRunningProcessSystemIdByExecutableName)(
        THIS_
        IN ULONG64 Server,
        IN PCSTR ExeName,
        IN ULONG Flags,
        OUT PULONG Id
        );
    STDMETHOD(GetRunningProcessDescription)(
        THIS_
        IN ULONG64 Server,
        IN ULONG SystemId,
        IN ULONG Flags,
        OUT OPTIONAL PSTR ExeName,
        IN ULONG ExeNameSize,
        OUT OPTIONAL PULONG ActualExeNameSize,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG ActualDescriptionSize
        );
    STDMETHOD(AttachProcess)(
        THIS_
        IN ULONG64 Server,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        );
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 Server,
        IN PSTR CommandLine,
        IN ULONG CreateFlags
        );
    STDMETHOD(CreateProcessAndAttach)(
        THIS_
        IN ULONG64 Server,
        IN OPTIONAL PSTR CommandLine,
        IN ULONG CreateFlags,
        IN ULONG ProcessId,
        IN ULONG AttachFlags
        );
    STDMETHOD(GetProcessOptions)(
        THIS_
        OUT PULONG Options
        );
    STDMETHOD(AddProcessOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(RemoveProcessOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(SetProcessOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(OpenDumpFile)(
        THIS_
        IN PCSTR DumpFile
        );
    STDMETHOD(WriteDumpFile)(
        THIS_
        IN PCSTR DumpFile,
        IN ULONG Qualifier
        );
    STDMETHOD(ConnectSession)(
        THIS_
        IN ULONG Flags,
        IN ULONG HistoryLimit
        );
    STDMETHOD(StartServer)(
        THIS_
        IN PCSTR Options
        );
    STDMETHOD(OutputServers)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR Machine,
        IN ULONG Flags
        );
    STDMETHOD(TerminateProcesses)(
        THIS
        );
    STDMETHOD(DetachProcesses)(
        THIS
        );
    STDMETHOD(EndSession)(
        THIS_
        IN ULONG Flags
        );
    STDMETHOD(GetExitCode)(
        THIS_
        OUT PULONG Code
        );
    STDMETHOD(DispatchCallbacks)(
        THIS_
        IN ULONG Timeout
        );
    STDMETHOD(ExitDispatch)(
        THIS_
        IN PDEBUG_CLIENT Client
        );
    STDMETHOD(CreateClient)(
        THIS_
        OUT PDEBUG_CLIENT* Client
        );
    STDMETHOD(GetInputCallbacks)(
        THIS_
        OUT PDEBUG_INPUT_CALLBACKS* Callbacks
        );
    STDMETHOD(SetInputCallbacks)(
        THIS_
        IN PDEBUG_INPUT_CALLBACKS Callbacks
        );
    STDMETHOD(GetOutputCallbacks)(
        THIS_
        OUT PDEBUG_OUTPUT_CALLBACKS* Callbacks
        );
    STDMETHOD(SetOutputCallbacks)(
        THIS_
        IN PDEBUG_OUTPUT_CALLBACKS Callbacks
        );
    STDMETHOD(GetOutputMask)(
        THIS_
        OUT PULONG Mask
        );
    STDMETHOD(SetOutputMask)(
        THIS_
        IN ULONG Mask
        );
    STDMETHOD(GetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        OUT PULONG Mask
        );
    STDMETHOD(SetOtherOutputMask)(
        THIS_
        IN PDEBUG_CLIENT Client,
        IN ULONG Mask
        );
    STDMETHOD(GetOutputWidth)(
        THIS_
        OUT PULONG Columns
        );
    STDMETHOD(SetOutputWidth)(
        THIS_
        IN ULONG Columns
        );
    STDMETHOD(GetOutputLinePrefix)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PrefixSize
        );
    STDMETHOD(SetOutputLinePrefix)(
        THIS_
        IN OPTIONAL PCSTR Prefix
        );
    STDMETHOD(GetIdentity)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG IdentitySize
        );
    STDMETHOD(OutputIdentity)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags,
        IN PCSTR Format
        );
    STDMETHOD(GetEventCallbacks)(
        THIS_
        OUT PDEBUG_EVENT_CALLBACKS* Callbacks
        );
    STDMETHOD(SetEventCallbacks)(
        THIS_
        IN PDEBUG_EVENT_CALLBACKS Callbacks
        );
    STDMETHOD(FlushCallbacks)(
        THIS
        );
    STDMETHOD(WriteDumpFile2)(
        THIS_
        IN PCSTR DumpFile,
        IN ULONG Qualifier,
        IN ULONG FormatFlags,
        IN OPTIONAL PCSTR Comment
        );
    STDMETHOD(AddDumpInformationFile)(
        THIS_
        IN PCSTR InfoFile,
        IN ULONG Type
        );
    STDMETHOD(EndProcessServer)(
        THIS_
        IN ULONG64 Server
        );
    STDMETHOD(WaitForProcessServerEnd)(
        THIS_
        IN ULONG Timeout
        );
    STDMETHOD(IsKernelDebuggerEnabled)(
        THIS
        );
    STDMETHOD(TerminateCurrentProcess)(
        THIS
        );
    STDMETHOD(DetachCurrentProcess)(
        THIS
        );
    STDMETHOD(AbandonCurrentProcess)(
        THIS
        );

    // IDebugControl and IDebugControl2.
    STDMETHOD(GetInterrupt)(
        THIS
        );
    STDMETHOD(SetInterrupt)(
        THIS_
        IN ULONG Flags
        );
    STDMETHOD(GetInterruptTimeout)(
        THIS_
        OUT PULONG Seconds
        );
    STDMETHOD(SetInterruptTimeout)(
        THIS_
        IN ULONG Seconds
        );
    STDMETHOD(GetLogFile)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG FileSize,
        OUT PBOOL Append
        );
    STDMETHOD(OpenLogFile)(
        THIS_
        IN PCSTR File,
        IN BOOL Append
        );
    STDMETHOD(CloseLogFile)(
        THIS
        );
    STDMETHOD(GetLogMask)(
        THIS_
        OUT PULONG Mask
        );
    STDMETHOD(SetLogMask)(
        THIS_
        IN ULONG Mask
        );
    STDMETHOD(Input)(
        THIS_
        OUT PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG InputSize
        );
    STDMETHOD(ReturnInput)(
        THIS_
        IN PCSTR Buffer
        );
    STDMETHODV(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Format,
        ...
        );
    STDMETHOD(OutputVaList)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Format,
        IN va_list Args
        );
    STDMETHODV(ControlledOutput)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Mask,
        IN PCSTR Format,
        ...
        );
    STDMETHOD(ControlledOutputVaList)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Mask,
        IN PCSTR Format,
        IN va_list Args
        );
    STDMETHOD(OutputPrompt)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL PCSTR Format,
        ...
        );
    STDMETHOD(OutputPromptVaList)(
        THIS_
        IN ULONG OutputControl,
        IN OPTIONAL PCSTR Format,
        IN va_list Args
        );
    STDMETHOD(GetPromptText)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TextSize
        );
    STDMETHOD(OutputCurrentState)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        );
    STDMETHOD(OutputVersionInformation)(
        THIS_
        IN ULONG OutputControl
        );
    STDMETHOD(GetNotifyEventHandle)(
        THIS_
        OUT PULONG64 Handle
        );
    STDMETHOD(SetNotifyEventHandle)(
        THIS_
        IN ULONG64 Handle
        );
    STDMETHOD(Assemble)(
        THIS_
        IN ULONG64 Offset,
        IN PCSTR Instr,
        OUT PULONG64 EndOffset
        );
    STDMETHOD(Disassemble)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DisassemblySize,
        OUT PULONG64 EndOffset
        );
    STDMETHOD(GetDisassembleEffectiveOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(OutputDisassembly)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT PULONG64 EndOffset
        );
    STDMETHOD(OutputDisassemblyLines)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG PreviousLines,
        IN ULONG TotalLines,
        IN ULONG64 Offset,
        IN ULONG Flags,
        OUT OPTIONAL PULONG OffsetLine,
        OUT OPTIONAL PULONG64 StartOffset,
        OUT OPTIONAL PULONG64 EndOffset,
        OUT OPTIONAL /* size_is(TotalLines) */ PULONG64 LineOffsets
        );
    STDMETHOD(GetNearInstruction)(
        THIS_
        IN ULONG64 Offset,
        IN LONG Delta,
        OUT PULONG64 NearOffset
        );
    STDMETHOD(GetStackTrace)(
        THIS_
        IN ULONG64 FrameOffset,
        IN ULONG64 StackOffset,
        IN ULONG64 InstructionOffset,
        OUT PDEBUG_STACK_FRAME Frames,
        IN ULONG FramesSize,
        OUT PULONG FramesFilled
        );
    STDMETHOD(GetReturnOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(OutputStackTrace)(
        THIS_
        IN ULONG OutputControl,
        IN PDEBUG_STACK_FRAME Frames,
        IN ULONG FramesSize,
        IN ULONG Flags
        );
    STDMETHOD(GetDebuggeeType)(
        THIS_
        OUT PULONG Class,
        OUT PULONG Qualifier
        );
    STDMETHOD(GetActualProcessorType)(
        THIS_
        OUT PULONG Type
        );
    STDMETHOD(GetExecutingProcessorType)(
        THIS_
        OUT PULONG Type
        );
    STDMETHOD(GetNumberPossibleExecutingProcessorTypes)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetPossibleExecutingProcessorTypes)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT PULONG Types
        );
    STDMETHOD(GetNumberProcessors)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetSystemVersion)(
        THIS_
        OUT PULONG PlatformId,
        OUT PULONG Major,
        OUT PULONG Minor,
        OUT OPTIONAL PSTR ServicePackString,
        IN ULONG ServicePackStringSize,
        OUT OPTIONAL PULONG ServicePackStringUsed,
        OUT PULONG ServicePackNumber,
        OUT OPTIONAL PSTR BuildString,
        IN ULONG BuildStringSize,
        OUT OPTIONAL PULONG BuildStringUsed
        );
    STDMETHOD(GetPageSize)(
        THIS_
        OUT PULONG Size
        );
    STDMETHOD(IsPointer64Bit)(
        THIS
        );
    STDMETHOD(ReadBugCheckData)(
        THIS_
        OUT PULONG Code,
        OUT PULONG64 Arg1,
        OUT PULONG64 Arg2,
        OUT PULONG64 Arg3,
        OUT PULONG64 Arg4
        );
    STDMETHOD(GetNumberSupportedProcessorTypes)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetSupportedProcessorTypes)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT PULONG Types
        );
    STDMETHOD(GetProcessorTypeNames)(
        THIS_
        IN ULONG Type,
        OUT OPTIONAL PSTR FullNameBuffer,
        IN ULONG FullNameBufferSize,
        OUT OPTIONAL PULONG FullNameSize,
        OUT OPTIONAL PSTR AbbrevNameBuffer,
        IN ULONG AbbrevNameBufferSize,
        OUT OPTIONAL PULONG AbbrevNameSize
        );
    STDMETHOD(GetEffectiveProcessorType)(
        THIS_
        OUT PULONG Type
        );
    STDMETHOD(SetEffectiveProcessorType)(
        THIS_
        IN ULONG Type
        );
    STDMETHOD(GetExecutionStatus)(
        THIS_
        OUT PULONG Status
        );
    STDMETHOD(SetExecutionStatus)(
        THIS_
        IN ULONG Status
        );
    STDMETHOD(GetCodeLevel)(
        THIS_
        OUT PULONG Level
        );
    STDMETHOD(SetCodeLevel)(
        THIS_
        IN ULONG Level
        );
    STDMETHOD(GetEngineOptions)(
        THIS_
        OUT PULONG Options
        );
    STDMETHOD(AddEngineOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(RemoveEngineOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(SetEngineOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(GetSystemErrorControl)(
        THIS_
        OUT PULONG OutputLevel,
        OUT PULONG BreakLevel
        );
    STDMETHOD(SetSystemErrorControl)(
        THIS_
        IN ULONG OutputLevel,
        IN ULONG BreakLevel
        );
    STDMETHOD(GetTextMacro)(
        THIS_
        IN ULONG Slot,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG MacroSize
        );
    STDMETHOD(SetTextMacro)(
        THIS_
        IN ULONG Slot,
        IN PCSTR Macro
        );
    STDMETHOD(GetRadix)(
        THIS_
        OUT PULONG Radix
        );
    STDMETHOD(SetRadix)(
        THIS_
        IN ULONG Radix
        );
    STDMETHOD(Evaluate)(
        THIS_
        IN PCSTR Expression,
        IN ULONG DesiredType,
        OUT PDEBUG_VALUE Value,
        OUT OPTIONAL PULONG RemainderIndex
        );
    STDMETHOD(CoerceValue)(
        THIS_
        IN PDEBUG_VALUE In,
        IN ULONG OutType,
        OUT PDEBUG_VALUE Out
        );
    STDMETHOD(CoerceValues)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_VALUE In,
        IN /* size_is(Count) */ PULONG OutTypes,
        OUT /* size_is(Count) */ PDEBUG_VALUE Out
        );
    STDMETHOD(Execute)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR Command,
        IN ULONG Flags
        );
    STDMETHOD(ExecuteCommandFile)(
        THIS_
        IN ULONG OutputControl,
        IN PCSTR CommandFile,
        IN ULONG Flags
        );
    STDMETHOD(GetNumberBreakpoints)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetBreakpointByIndex)(
        THIS_
        IN ULONG Index,
        OUT PDEBUG_BREAKPOINT* Bp
        );
    STDMETHOD(GetBreakpointById)(
        THIS_
        IN ULONG Id,
        OUT PDEBUG_BREAKPOINT* Bp
        );
    STDMETHOD(GetBreakpointParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_BREAKPOINT_PARAMETERS Params
        );
    STDMETHOD(AddBreakpoint)(
        THIS_
        IN ULONG Type,
        IN ULONG DesiredId,
        OUT PDEBUG_BREAKPOINT* Bp
        );
    STDMETHOD(RemoveBreakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        );
    STDMETHOD(AddExtension)(
        THIS_
        IN PCSTR Path,
        IN ULONG Flags,
        OUT PULONG64 Handle
        );
    STDMETHOD(RemoveExtension)(
        THIS_
        IN ULONG64 Handle
        );
    STDMETHOD(GetExtensionByPath)(
        THIS_
        IN PCSTR Path,
        OUT PULONG64 Handle
        );
    STDMETHOD(CallExtension)(
        THIS_
        IN OPTIONAL ULONG64 Handle,
        IN PCSTR Function,
        IN OPTIONAL PCSTR Arguments
        );
    STDMETHOD(GetExtensionFunction)(
        THIS_
        IN ULONG64 Handle,
        IN PCSTR FuncName,
        OUT FARPROC* Function
        );
    STDMETHOD(GetWindbgExtensionApis32)(
        THIS_
        IN OUT PWINDBG_EXTENSION_APIS32 Api
        );
    STDMETHOD(GetWindbgExtensionApis64)(
        THIS_
        IN OUT PWINDBG_EXTENSION_APIS64 Api
        );
    STDMETHOD(GetNumberEventFilters)(
        THIS_
        OUT PULONG SpecificEvents,
        OUT PULONG SpecificExceptions,
        OUT PULONG ArbitraryExceptions
        );
    STDMETHOD(GetEventFilterText)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TextSize
        );
    STDMETHOD(GetEventFilterCommand)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        );
    STDMETHOD(SetEventFilterCommand)(
        THIS_
        IN ULONG Index,
        IN PCSTR Command
        );
    STDMETHOD(GetSpecificFilterParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        );
    STDMETHOD(SetSpecificFilterParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
        );
    STDMETHOD(GetSpecificFilterArgument)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ArgumentSize
        );
    STDMETHOD(SetSpecificFilterArgument)(
        THIS_
        IN ULONG Index,
        IN PCSTR Argument
        );
    STDMETHOD(GetExceptionFilterParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG Codes,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        );
    STDMETHOD(SetExceptionFilterParameters)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
        );
    STDMETHOD(GetExceptionFilterSecondCommand)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG CommandSize
        );
    STDMETHOD(SetExceptionFilterSecondCommand)(
        THIS_
        IN ULONG Index,
        IN PCSTR Command
        );
    STDMETHOD(WaitForEvent)(
        THIS_
        IN ULONG Flags,
        IN ULONG Timeout
        );
    STDMETHOD(GetLastEventInformation)(
        THIS_
        PULONG Type,
        OUT PULONG ProcessId,
        OUT PULONG ThreadId,
        OUT OPTIONAL PVOID ExtraInformation,
        IN ULONG ExtraInformationSize,
        OUT OPTIONAL PULONG ExtraInformationUsed,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG DescriptionUsed
        );
    STDMETHOD(GetCurrentTimeDate)(
        THIS_
        OUT PULONG TimeDate
        );
    STDMETHOD(GetCurrentSystemUpTime)(
        THIS_
        OUT PULONG UpTime
        );
    STDMETHOD(GetDumpFormatFlags)(
        THIS_
        OUT PULONG FormatFlags
        );
    STDMETHOD(GetNumberTextReplacements)(
        THIS_
        OUT PULONG NumRepl
        );
    STDMETHOD(GetTextReplacement)(
        THIS_
        IN OPTIONAL PCSTR SrcText,
        IN ULONG Index,
        OUT OPTIONAL PSTR SrcBuffer,
        IN ULONG SrcBufferSize,
        OUT OPTIONAL PULONG SrcSize,
        OUT OPTIONAL PSTR DstBuffer,
        IN ULONG DstBufferSize,
        OUT OPTIONAL PULONG DstSize
        );
    STDMETHOD(SetTextReplacement)(
        THIS_
        IN PCSTR SrcText,
        IN OPTIONAL PCSTR DstText
        );
    STDMETHOD(RemoveTextReplacements)(
        THIS
        );
    STDMETHOD(OutputTextReplacements)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        );

    // IDebugDataSpaces and IDebugDataSpaces2.
    STDMETHOD(ReadVirtual)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(SearchVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Length,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        IN ULONG PatternGranularity,
        OUT PULONG64 MatchOffset
        );
    STDMETHOD(ReadVirtualUncached)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteVirtualUncached)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(ReadPointersVirtual)(
        THIS_
        IN ULONG Count,
        IN ULONG64 Offset,
        OUT /* size_is(Count) */ PULONG64 Ptrs
        );
    STDMETHOD(WritePointersVirtual)(
        THIS_
        IN ULONG Count,
        IN ULONG64 Offset,
        IN /* size_is(Count) */ PULONG64 Ptrs
        );
    STDMETHOD(ReadPhysical)(
        THIS_
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WritePhysical)(
        THIS_
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(ReadControl)(
        THIS_
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteControl)(
        THIS_
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(ReadIo)(
        THIS_
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteIo)(
        THIS_
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(ReadMsr)(
        THIS_
        IN ULONG Msr,
        OUT PULONG64 Value
        );
    STDMETHOD(WriteMsr)(
        THIS_
        IN ULONG Msr,
        IN ULONG64 Value
        );
    STDMETHOD(ReadBusData)(
        THIS_
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteBusData)(
        THIS_
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(CheckLowMemory)(
        THIS
        );
    STDMETHOD(ReadDebuggerData)(
        THIS_
        IN ULONG Index,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(ReadProcessorSystemData)(
        THIS_
        IN ULONG Processor,
        IN ULONG Index,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(VirtualToPhysical)(
        THIS_
        IN ULONG64 Virtual,
        OUT PULONG64 Physical
        );
    STDMETHOD(GetVirtualTranslationPhysicalOffsets)(
        THIS_
        IN ULONG64 Virtual,
        OUT OPTIONAL /* size_is(OffsetsSize) */ PULONG64 Offsets,
        IN ULONG OffsetsSize,
        OUT OPTIONAL PULONG Levels
        );
    STDMETHOD(ReadHandleData)(
        THIS_
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        );
    STDMETHOD(FillVirtual)(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT OPTIONAL PULONG Filled
        );
    STDMETHOD(FillPhysical)(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT OPTIONAL PULONG Filled
        );
    STDMETHOD(QueryVirtual)(
        THIS_
        IN ULONG64 Offset,
        OUT PMEMORY_BASIC_INFORMATION64 Info
        );

    // IDebugRegisters.
    STDMETHOD(GetNumberRegisters)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetDescription)(
        THIS_
        IN ULONG Register,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PDEBUG_REGISTER_DESCRIPTION Desc
        );
    STDMETHOD(GetIndexByName)(
        THIS_
        IN PCSTR Name,
        OUT PULONG Index
        );
    STDMETHOD(GetValue)(
        THIS_
        IN ULONG Register,
        OUT PDEBUG_VALUE Value
        );
    STDMETHOD(SetValue)(
        THIS_
        IN ULONG Register,
        IN PDEBUG_VALUE Value
        );
    STDMETHOD(GetValues)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL PULONG Indices,
        IN ULONG Start,
        OUT PDEBUG_VALUE Values
        );
    STDMETHOD(SetValues)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL PULONG Indices,
        IN ULONG Start,
        IN PDEBUG_VALUE Values
        );
    STDMETHOD(OutputRegisters)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags
        );
    STDMETHOD(GetInstructionOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(GetStackOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(GetFrameOffset)(
        THIS_
        OUT PULONG64 Offset
        );

    // IDebugSymbols and IDebugSymbols2.
    STDMETHOD(GetSymbolOptions)(
        THIS_
        OUT PULONG Options
        );
    STDMETHOD(AddSymbolOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(RemoveSymbolOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(SetSymbolOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(GetNameByOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Displacement
        );
    STDMETHOD(GetOffsetByName)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG64 Offset
        );
    STDMETHOD(GetNearNameByOffset)(
        THIS_
        IN ULONG64 Offset,
        IN LONG Delta,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize,
        OUT OPTIONAL PULONG64 Displacement
        );
    STDMETHOD(GetLineByOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Line,
        OUT OPTIONAL PSTR FileBuffer,
        IN ULONG FileBufferSize,
        OUT OPTIONAL PULONG FileSize,
        OUT OPTIONAL PULONG64 Displacement
        );
    STDMETHOD(GetOffsetByLine)(
        THIS_
        IN ULONG Line,
        IN PCSTR File,
        OUT PULONG64 Offset
        );
    STDMETHOD(GetNumberModules)(
        THIS_
        OUT PULONG Loaded,
        OUT PULONG Unloaded
        );
    STDMETHOD(GetModuleByIndex)(
        THIS_
        IN ULONG Index,
        OUT PULONG64 Base
        );
    STDMETHOD(GetModuleByModuleName)(
        THIS_
        IN PCSTR Name,
        IN ULONG StartIndex,
        OUT OPTIONAL PULONG Index,
        OUT OPTIONAL PULONG64 Base
        );
    STDMETHOD(GetModuleByOffset)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG StartIndex,
        OUT OPTIONAL PULONG Index,
        OUT OPTIONAL PULONG64 Base
        );
    STDMETHOD(GetModuleNames)(
        THIS_
        IN ULONG Index,
        IN ULONG64 Base,
        OUT OPTIONAL PSTR ImageNameBuffer,
        IN ULONG ImageNameBufferSize,
        OUT OPTIONAL PULONG ImageNameSize,
        OUT OPTIONAL PSTR ModuleNameBuffer,
        IN ULONG ModuleNameBufferSize,
        OUT OPTIONAL PULONG ModuleNameSize,
        OUT OPTIONAL PSTR LoadedImageNameBuffer,
        IN ULONG LoadedImageNameBufferSize,
        OUT OPTIONAL PULONG LoadedImageNameSize
        );
    STDMETHOD(GetModuleParameters)(
        THIS_
        IN ULONG Count,
        IN OPTIONAL /* size_is(Count) */ PULONG64 Bases,
        IN ULONG Start,
        OUT /* size_is(Count) */ PDEBUG_MODULE_PARAMETERS Params
        );
    STDMETHOD(GetSymbolModule)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG64 Base
        );
    STDMETHOD(GetTypeName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        );
    STDMETHOD(GetTypeId)(
        THIS_
        IN ULONG64 Module,
        IN PCSTR Name,
        OUT PULONG TypeId
        );
    STDMETHOD(GetTypeSize)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PULONG Size
        );
    STDMETHOD(GetFieldOffset)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PCSTR Field,
        OUT PULONG Offset
        );
    STDMETHOD(GetSymbolTypeId)(
        THIS_
        IN PCSTR Symbol,
        OUT PULONG TypeId,
        OUT OPTIONAL PULONG64 Module
        );
    STDMETHOD(GetOffsetTypeId)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG TypeId,
        OUT OPTIONAL PULONG64 Module
        );
    STDMETHOD(ReadTypedDataVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteTypedDataVirtual)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(OutputTypedDataVirtual)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG Flags
        );
    STDMETHOD(ReadTypedDataPhysical)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteTypedDataPhysical)(
        THIS_
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(OutputTypedDataPhysical)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG64 Offset,
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG Flags
        );
    STDMETHOD(GetScope)(
        THIS_
        OUT OPTIONAL PULONG64 InstructionOffset,
        OUT OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
        OUT OPTIONAL PVOID ScopeContext,
        IN ULONG ScopeContextSize
        );
    STDMETHOD(SetScope)(
        THIS_
        IN ULONG64 InstructionOffset,
        IN OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
        IN OPTIONAL PVOID ScopeContext,
        IN ULONG ScopeContextSize
        );
    STDMETHOD(ResetScope)(
        THIS
        );
    STDMETHOD(GetScopeSymbolGroup)(
        THIS_
        IN ULONG Flags,
        IN OPTIONAL PDEBUG_SYMBOL_GROUP Update,
        OUT PDEBUG_SYMBOL_GROUP* Symbols
        );
    STDMETHOD(CreateSymbolGroup)(
        THIS_
        OUT PDEBUG_SYMBOL_GROUP* Group
        );
    STDMETHOD(StartSymbolMatch)(
        THIS_
        IN PCSTR Pattern,
        OUT PULONG64 Handle
        );
    STDMETHOD(GetNextSymbolMatch)(
        THIS_
        IN ULONG64 Handle,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG MatchSize,
        OUT OPTIONAL PULONG64 Offset
        );
    STDMETHOD(EndSymbolMatch)(
        THIS_
        IN ULONG64 Handle
        );
    STDMETHOD(Reload)(
        THIS_
        IN PCSTR Module
        );
    STDMETHOD(GetSymbolPath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        );
    STDMETHOD(SetSymbolPath)(
        THIS_
        IN PCSTR Path
        );
    STDMETHOD(AppendSymbolPath)(
        THIS_
        IN PCSTR Addition
        );
    STDMETHOD(GetImagePath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        );
    STDMETHOD(SetImagePath)(
        THIS_
        IN PCSTR Path
        );
    STDMETHOD(AppendImagePath)(
        THIS_
        IN PCSTR Addition
        );
    STDMETHOD(GetSourcePath)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        );
    STDMETHOD(GetSourcePathElement)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG PathSize
        );
    STDMETHOD(SetSourcePath)(
        THIS_
        IN PCSTR Path
        );
    STDMETHOD(AppendSourcePath)(
        THIS_
        IN PCSTR Addition
        );
    STDMETHOD(FindSourceFile)(
        THIS_
        IN ULONG StartElement,
        IN PCSTR File,
        IN ULONG Flags,
        OUT OPTIONAL PULONG FoundElement,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG FoundSize
        );
    STDMETHOD(GetSourceFileLineOffsets)(
        THIS_
        IN PCSTR File,
        OUT OPTIONAL PULONG64 Buffer,
        IN ULONG BufferLines,
        OUT OPTIONAL PULONG FileLines
        );
    STDMETHOD(GetModuleVersionInformation)(
        THIS_
        IN ULONG Index,
        IN ULONG64 Base,
        IN PCSTR Item,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG VerInfoSize
        );
    STDMETHOD(GetModuleNameString)(
        THIS_
        IN ULONG Which,
        IN ULONG Index,
        IN ULONG64 Base,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG NameSize
        );
    STDMETHOD(GetConstantName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG64 Value,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        );
    STDMETHOD(GetFieldName)(
        THIS_
        IN ULONG64 Module,
        IN ULONG TypeId,
        IN ULONG FieldIndex,
        OUT OPTIONAL PSTR NameBuffer,
        IN ULONG NameBufferSize,
        OUT OPTIONAL PULONG NameSize
        );
    STDMETHOD(GetTypeOptions)(
        THIS_
        OUT PULONG Options
        );
    STDMETHOD(SetTypeOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(AddTypeOptions)(
        THIS_
        IN ULONG Options
        );
    STDMETHOD(RemoveTypeOptions)(
        THIS_
        IN ULONG Options
        );

    // IDebugSystemObjects.
    STDMETHOD(GetEventThread)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(GetEventProcess)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentThreadId)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(SetCurrentThreadId)(
        THIS_
        IN ULONG Id
        );
    STDMETHOD(GetCurrentProcessId)(
        THIS_
        OUT PULONG Id
        );
    STDMETHOD(SetCurrentProcessId)(
        THIS_
        IN ULONG Id
        );
    STDMETHOD(GetNumberThreads)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetTotalNumberThreads)(
        THIS_
        OUT PULONG Total,
        OUT PULONG LargestProcess
        );
    STDMETHOD(GetThreadIdsByIndex)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
        );
    STDMETHOD(GetThreadIdByProcessor)(
        THIS_
        IN ULONG Processor,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentThreadDataOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(GetThreadIdByDataOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentThreadTeb)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(GetThreadIdByTeb)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentThreadSystemId)(
        THIS_
        OUT PULONG SysId
        );
    STDMETHOD(GetThreadIdBySystemId)(
        THIS_
        IN ULONG SysId,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentThreadHandle)(
        THIS_
        OUT PULONG64 Handle
        );
    STDMETHOD(GetThreadIdByHandle)(
        THIS_
        IN ULONG64 Handle,
        OUT PULONG Id
        );
    STDMETHOD(GetNumberProcesses)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(GetProcessIdsByIndex)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
        );
    STDMETHOD(GetCurrentProcessDataOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(GetProcessIdByDataOffset)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentProcessPeb)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(GetProcessIdByPeb)(
        THIS_
        IN ULONG64 Offset,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentProcessSystemId)(
        THIS_
        OUT PULONG SysId
        );
    STDMETHOD(GetProcessIdBySystemId)(
        THIS_                                      
        IN ULONG SysId,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentProcessHandle)(
        THIS_
        OUT PULONG64 Handle
        );
    STDMETHOD(GetProcessIdByHandle)(
        THIS_
        IN ULONG64 Handle,
        OUT PULONG Id
        );
    STDMETHOD(GetCurrentProcessExecutableName)(
        THIS_
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG ExeSize
        );

    // IDebugSystemObjects2.
    STDMETHOD(GetCurrentProcessUpTime)(
        THIS_
        OUT PULONG UpTime
        );
    STDMETHOD(GetImplicitThreadDataOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(SetImplicitThreadDataOffset)(
        THIS_
        IN ULONG64 Offset
        );
    STDMETHOD(GetImplicitProcessDataOffset)(
        THIS_
        OUT PULONG64 Offset
        );
    STDMETHOD(SetImplicitProcessDataOffset)(
        THIS_
        IN ULONG64 Offset
        );
    
    // DbgRpcClientObject.
    virtual HRESULT Initialize(PSTR Identity, PVOID* Interface);
    virtual void    Finalize(void);
    virtual void    Uninitialize(void);
    
    //------------------------------------------------------------------------
    // General.

    HRESULT Initialize(void);
    void InitializePrimary(void);
    
    void Link(void);
    void Unlink(void);

    DebugClient* m_Next;
    DebugClient* m_Prev;
    
    ULONG m_Refs;
    ULONG m_Flags;
    ULONG m_ThreadId;
    HANDLE m_Thread;
    char m_Identity[DBGRPC_MAX_IDENTITY];
    time_t m_LastActivity;
    
    PDEBUG_EVENT_CALLBACKS m_EventCb;
    ULONG m_EventInterest;
    HANDLE m_DispatchSema;

    PDEBUG_INPUT_CALLBACKS m_InputCb;
    ULONG m_InputSequence;
    
    PDEBUG_OUTPUT_CALLBACKS m_OutputCb;
    ULONG m_OutMask;
    ULONG m_OutputWidth;
    PCSTR m_OutputLinePrefix;
};

ULONG GetExecutionStatus(void);
HRESULT SetExecutionStatus(ULONG Status);

HRESULT Execute(DebugClient* Client, PCSTR Command, ULONG Flags);
HRESULT ExecuteCommandFile(DebugClient* Client, PCSTR File, ULONG Flags);

HRESULT LiveKernelInitialize(DebugClient* Client, ULONG Qual, PCSTR Options);
HRESULT UserInitialize(DebugClient* Client, ULONG64 Server);

HRESULT InitializeTarget();
HRESULT InitializeMachine(ULONG Machine);

void DiscardTarget(ULONG Reason);
void DiscardMachine(ULONG Reason);

void GetClientIdentity(PSTR Identity);

#endif // #ifndef __DBGCLT_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dbgdata.cpp ===
//----------------------------------------------------------------------------
//
// IDebugDataSpaces implementations.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

//----------------------------------------------------------------------------
//
// TargetInfo data space methods.
//
//----------------------------------------------------------------------------

void
TargetInfo::NearestDifferentlyValidOffsets(ULONG64 Offset,
                                           PULONG64 NextOffset,
                                           PULONG64 NextPage)
{
    //
    // In the default case we assume that address validity
    // is controlled on a per-page basis so the next possibly
    // valid page and offset are both the offset of the next
    // page.
    //
    
    ULONG64 Page = (Offset + g_TargetMachine->m_PageSize) &
        ~((ULONG64)g_TargetMachine->m_PageSize - 1);
    if (NextOffset != NULL)
    {
        *NextOffset = Page;
    }
    if (NextPage != NULL)
    {
        *NextPage = Page;
    }
}

HRESULT
TargetInfo::ReadVirtualUncached(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    return ReadVirtual(Offset, Buffer, BufferSize, BytesRead);
}

HRESULT
TargetInfo::WriteVirtualUncached(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    return WriteVirtual(Offset, Buffer, BufferSize, BytesWritten);
}

// #define DBG_SEARCH

HRESULT
TargetInfo::SearchVirtual(
    IN ULONG64 Offset,
    IN ULONG64 Length,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    IN ULONG PatternGranularity,
    OUT PULONG64 MatchOffset
    )
{
    HRESULT Status;
    ULONG64 SearchEnd;
    UCHAR Buffer[4096];
    PUCHAR Buf, Pat, BufEnd, PatEnd;
    ULONG ReadLen;
    ULONG64 BufOffset;
    ULONG64 PatOffset;
    ULONG64 StartOffset;

    SearchEnd = Offset + Length;
    Buf = Buffer;
    BufEnd = Buffer;
    Pat = (PUCHAR)Pattern;
    PatEnd = Pat + PatternSize;
    ReadLen = Length < sizeof(Buffer) ? (ULONG)Length : sizeof(Buffer);
    BufOffset = Offset;
    PatOffset = Offset;
    StartOffset = Offset;

#ifdef DBG_SEARCH
    g_NtDllCalls.DbgPrint("Search %d bytes from %I64X to %I64X, gran %X\n",
                          PatternSize, Offset, SearchEnd - 1,
                          Granularity);
#endif
    
    for (;;)
    {
#ifdef DBG_SEARCH_VERBOSE
        g_NtDllCalls.DbgPrint("  %I64X: matched %d\n",
                              Offset + (Buf - Buffer),
                              (ULONG)(Pat - (PUCHAR)Pattern));
#endif
        
        if (Pat == PatEnd)
        {
            // Made it to the end of the pattern so there's
            // a match.
            *MatchOffset = PatOffset;
            Status = S_OK;
            break;
        }

        if (Buf >= BufEnd)
        {
            ULONG Read;

            // Ran out of buffered memory so get some more.
            for (;;)
            {
                if (CheckUserInterrupt())
                {
                    dprintf("User interrupt during memory search - "
                            "exiting.\n");
                    Status = HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT);
                    goto Exit;
                }

                if (Offset >= SearchEnd)
                {
                    // Return a result code that's specific and
                    // consistent with the kernel version.
                    Status = HRESULT_FROM_NT(STATUS_NO_MORE_ENTRIES);
                    goto Exit;
                }

                Status = ReadVirtual(Offset, Buffer, ReadLen, &Read);

#ifdef DBG_SEARCH
                g_NtDllCalls.DbgPrint("  Read %X bytes at %I64X, ret %X:%X\n",
                                      ReadLen, Offset,
                                      Status, Read);
#endif
                
                if (Status != S_OK)
                {
                    // Skip to the start of the next page.
                    NearestDifferentlyValidOffsets(Offset, NULL, &Offset);
                    // Restart search due to the address discontinuity.
                    Pat = (PUCHAR)Pattern;
                    PatOffset = Offset;
                }
                else
                {
                    break;
                }
            }

            Buf = Buffer;
            BufEnd = Buffer + Read;
            BufOffset = Offset;
            Offset += Read;
        }

        // If this is the first byte of the pattern it
        // must match on a granularity boundary.
        if (*Buf++ == *Pat &&
            (Pat != (PUCHAR)Pattern ||
             (((PatOffset - StartOffset) % PatternGranularity) == 0)))
        {
            Pat++;
        }
        else
        {
            Buf -= Pat - (PUCHAR)Pattern;
            Pat = (PUCHAR)Pattern;
            PatOffset = BufOffset + (Buf - Buffer);
        }
    }

 Exit:
    return Status;
}

HRESULT
TargetInfo::ReadPhysicalUncached(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    return ReadPhysical(Offset, Buffer, BufferSize, BytesRead);
}

HRESULT
TargetInfo::WritePhysicalUncached(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    return WritePhysical(Offset, Buffer, BufferSize, BytesWritten);
}

HRESULT
TargetInfo::FillVirtual(
    THIS_
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT PULONG Filled
    )
{
    HRESULT Status = S_OK;
    PUCHAR Pat = (PUCHAR)Pattern;
    PUCHAR PatEnd = Pat + PatternSize;

    *Filled = 0;
    while (Size-- > 0)
    {
        ULONG Done;
        
        if (CheckUserInterrupt())
        {
            dprintf("User interrupt during fill - exiting.\n");
            Status = HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT);
            *Filled = 0;
            break;
        }
        
        if ((Status = WriteVirtual(Start, Pat, 1, &Done)) != S_OK)
        {
            break;
        }
        if (Done != 1)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            break;
        }

        Start++;
        if (++Pat == PatEnd)
        {
            Pat = (PUCHAR)Pattern;
        }
        (*Filled)++;
    }

    // If nothing was filled return an error, otherwise
    // consider it a success.
    return *Filled > 0 ? S_OK : Status;
}

HRESULT
TargetInfo::FillPhysical(
    THIS_
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT PULONG Filled
    )
{
    HRESULT Status = S_OK;
    PUCHAR Pat = (PUCHAR)Pattern;
    PUCHAR PatEnd = Pat + PatternSize;

    *Filled = 0;
    while (Size-- > 0)
    {
        ULONG Done;
        
        if (CheckUserInterrupt())
        {
            dprintf("User interrupt during fill - exiting.\n");
            Status = HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT);
            *Filled = 0;
            break;
        }
        
        if ((Status = WritePhysical(Start, Pat, 1, &Done)) != S_OK)
        {
            break;
        }
        if (Done != 1)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            break;
        }

        Start++;
        if (++Pat == PatEnd)
        {
            Pat = (PUCHAR)Pattern;
        }
        (*Filled)++;
    }

    // If nothing was filled return an error, otherwise
    // consider it a success.
    return *Filled > 0 ? S_OK : Status;
}

HRESULT
TargetInfo::GetProcessorId(ULONG Processor,
                           PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    // Base implementation which silently fails for modes
    // where the ID cannot be retrieved.
    return E_UNEXPECTED;
}

HRESULT
TargetInfo::ReadPageFile(ULONG PfIndex, ULONG64 PfOffset,
                         PVOID Buffer, ULONG Size)
{
    // Default implementation for targets which do not
    // support reading the page file.
    return HR_PAGE_NOT_AVAILABLE;
}

HRESULT
TargetInfo::GetFunctionTableListHead(void)
{
    // Get the address of the dynamic function table list head which is the
    // the same for all processes. This only has to be done once.

    if (g_CurrentProcess->DynFuncTableList)
    {
        return S_OK;
    }
    
    GetOffsetFromSym("ntdll!RtlpDynamicFunctionTable",
                     &g_CurrentProcess->DynFuncTableList, NULL);
    if (!g_CurrentProcess->DynFuncTableList)
    {
        // No error message here as it's a common case when
        // symbols are bad.
        return E_NOINTERFACE;
    }

    return S_OK;
}

// These procedures support dynamic function table entries for user-mode
// run-time code. Dynamic function tables are stored in a linked list
// inside ntdll. The address of the linked list head is returned by
// RtlGetFunctionTableListHead. Since dynamic function tables are
// only supported in user-mode the address of the list head will be
// the same in all processes. Dynamic function tables are very rare,
// so in most cases this the list will be unitialized and this routine
// will return NULL. dbghelp only calls this when it
// is unable to find a function entry in any of the images.

PVOID
TargetInfo::FindDynamicFunctionEntry(MachineInfo* Machine, ULONG64 Address)
{
    LIST_ENTRY64 DynamicFunctionTableHead;
    ULONG64 Entry;

    if (GetFunctionTableListHead() != S_OK)
    {
        return NULL;
    }
    
    // Read the dynamic function table list head

    if (ReadListEntry(Machine,
                      g_CurrentProcess->DynFuncTableList,
                      &DynamicFunctionTableHead) != S_OK)
    {
        // This failure happens almost all the time in minidumps
        // because the function table list symbol can be resolved
        // but the memory isn't part of the minidump.
        if (!IS_USER_MINI_DUMP())
        {
            ErrOut("Unable to read dynamic function table list head\n");
        }
        return NULL;
    }

    Entry = DynamicFunctionTableHead.Flink;

    // The list head is initialized the first time it's used so check
    // for an uninitialized pointers. This is the most common result.

    if (Entry == 0)
    {
        return NULL;
    }

    // Loop through the dynamic function table list reading the headers.
    // If the range of a dynamic function table contains Address then
    // search the function table. Dynamic function table ranges are not
    // mututally exclusive like those in images so an address may be
    // in more than one range. However, there can be only one dynamic function
    // entry that contains the address (if there are any at all).

    while (Entry != g_CurrentProcess->DynFuncTableList)
    {
        ULONG64 Table, MinAddress, MaxAddress, BaseAddress, TableData;
        ULONG TableSize;
        WCHAR OutOfProcessDll[MAX_PATH];
        CROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable;
        PVOID FunctionTable;
        PVOID FunctionEntry;

        Table = Entry;
        if (Machine->ReadDynamicFunctionTable(Table, &Entry,
                                              &MinAddress, &MaxAddress,
                                              &BaseAddress,
                                              &TableData, &TableSize,
                                              OutOfProcessDll,
                                              &RawTable) != S_OK)
        {
            ErrOut("Unable to read dynamic function table entry\n");
            continue;
        }

        if (Address >= MinAddress && Address < MaxAddress &&
            (OutOfProcessDll[0] ||
             (TableData && TableSize > 0)))
        {
            if (OutOfProcessDll[0])
            {
                if (ReadOutOfProcessDynamicFunctionTable
                    (OutOfProcessDll, Table, &TableSize,
                     &FunctionTable) != S_OK)
                {
                    ErrOut("Unable to read dynamic function table entries\n");
                    continue;
                }
            }
            else
            {
                FunctionTable = malloc(TableSize);
                if (FunctionTable == NULL)
                {
                    ErrOut("Unable to allocate memory for "
                           "dynamic function table\n");
                    continue;
                }

                // Read the dynamic function table
                if (ReadAllVirtual(TableData, FunctionTable,
                                   TableSize) != S_OK)
                {
                    ErrOut("Unable to read dynamic function table entries\n");
                    free(FunctionTable);
                    continue;
                }
            }

            FunctionEntry = Machine->
                FindDynamicFunctionEntry(&RawTable, Address,
                                         FunctionTable, TableSize);
            
            free(FunctionTable);

            if (FunctionEntry)
            {
                return FunctionEntry;
            }
        }
    }

    return NULL;
}

ULONG64
TargetInfo::GetDynamicFunctionTableBase(MachineInfo* Machine,
                                         ULONG64 Address)
{
    LIST_ENTRY64 ListHead;
    ULONG64 Entry;

    // If the process dynamic function table list head hasn't
    // been looked up yet that means that no dynamic function
    // table entry could be in use yet, so there's no need to look.
    if (!g_CurrentProcess->DynFuncTableList)
    {
        return 0;
    }
    
    if (ReadListEntry(Machine, g_CurrentProcess->DynFuncTableList,
                      &ListHead) != S_OK)
    {
        return 0;
    }

    Entry = ListHead.Flink;

    // The list head is initialized the first time it's used so check
    // for an uninitialized pointers. This is the most common result.

    if (Entry == 0)
    {
        return 0;
    }

    // Loop through the dynamic function table list reading the headers.
    // If the range of a dynamic function table contains Address then
    // return the function table's base.

    while (Entry != g_CurrentProcess->DynFuncTableList)
    {
        ULONG64 MinAddress, MaxAddress, BaseAddress, TableData;
        ULONG TableSize;
        WCHAR OutOfProcessDll[MAX_PATH];
        CROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable;
        
        if (Machine->ReadDynamicFunctionTable(Entry, &Entry,
                                              &MinAddress, &MaxAddress,
                                              &BaseAddress,
                                              &TableData, &TableSize,
                                              OutOfProcessDll,
                                              &RawTable) == S_OK &&
            Address >= MinAddress &&
            Address < MaxAddress)
        {
            return BaseAddress;
        }
    }

    return 0;
}

HRESULT
TargetInfo::ReadOutOfProcessDynamicFunctionTable(PWSTR Dll,
                                                 ULONG64 Table,
                                                 PULONG TableSize,
                                                 PVOID* TableData)
{
    // Empty base implementation to avoid error messages
    // that would be produced by an UNEXPECTED_HR implementation.
    return E_UNEXPECTED;
}

PVOID CALLBACK
TargetInfo::DynamicFunctionTableCallback(HANDLE Process,
                                         ULONG64 Address,
                                         ULONG64 Context)
{
    DBG_ASSERT(Process == g_CurrentProcess->Handle);

    return g_Target->FindDynamicFunctionEntry((MachineInfo*)Context,
                                              Address);
}

HRESULT
TargetInfo::QueryAddressInformation(ULONG64 Address, ULONG InSpace,
                                    PULONG OutSpace, PULONG OutFlags)
{
    // Default implementation which just returns the
    // least restrictive settings.
    *OutSpace = IS_KERNEL_TARGET() ?
        DBGKD_QUERY_MEMORY_KERNEL : DBGKD_QUERY_MEMORY_PROCESS;
    *OutFlags =
        DBGKD_QUERY_MEMORY_READ |
        DBGKD_QUERY_MEMORY_WRITE |
        DBGKD_QUERY_MEMORY_EXECUTE;
    return S_OK;
}

HRESULT
TargetInfo::ReadPointer(
    MachineInfo* Machine,
    ULONG64 Address,
    PULONG64 Pointer64
    )
{
    HRESULT Status;
    ULONG Result;
    ULONG SizeToRead;
    ULONG Pointer32;

    if (Machine->m_Ptr64)
    {
        SizeToRead = sizeof(ULONG64);
        Status = ReadVirtual(Address, Pointer64, SizeToRead, &Result);
    }
    else
    {
        SizeToRead = sizeof(ULONG32);
        Status = ReadVirtual(Address, &Pointer32, SizeToRead, &Result);
        *Pointer64 = EXTEND64(Pointer32);
    }

    if (Status != S_OK)
    {
        return Status;
    }
    if (Result != SizeToRead)
    {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT
TargetInfo::WritePointer(
    MachineInfo* Machine,
    ULONG64 Address,
    ULONG64 Pointer64
    )
{
    HRESULT Status;
    ULONG Result;
    ULONG SizeToWrite;
    ULONG Pointer32;

    if (Machine->m_Ptr64)
    {
        SizeToWrite = sizeof(ULONG64);
        Status = WriteVirtual(Address, &Pointer64, SizeToWrite, &Result);
    }
    else
    {
        SizeToWrite = sizeof(ULONG32);
        Pointer32 = (ULONG)Pointer64;
        Status = WriteVirtual(Address, &Pointer32, SizeToWrite, &Result);
    }

    if (Status != S_OK)
    {
        return Status;
    }
    if (Result != SizeToWrite)
    {
        return HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }

    return S_OK;
}

HRESULT
TargetInfo::ReadListEntry(
    MachineInfo* Machine,
    ULONG64 Address,
    PLIST_ENTRY64 List64
    )
{
    HRESULT Status;
    ULONG Result;
    ULONG SizeToRead;
    LIST_ENTRY32 List32;

    if (Machine->m_Ptr64)
    {
        SizeToRead = sizeof(LIST_ENTRY64);
        Status = ReadVirtual(Address, List64, SizeToRead, &Result);
    }
    else
    {
        SizeToRead = sizeof(LIST_ENTRY32);
        Status = ReadVirtual(Address, &List32, SizeToRead, &Result);
    }

    if (Status != S_OK)
    {
        return Status;
    }
    if (Result != SizeToRead)
    {
        return E_FAIL;
    }

    if (!Machine->m_Ptr64)
    {
        List64->Flink = EXTEND64(List32.Flink);
        List64->Blink = EXTEND64(List32.Blink);
    }

    return S_OK;
}

void
ConvertLoaderEntry32To64(
    PKLDR_DATA_TABLE_ENTRY32 b32,
    PKLDR_DATA_TABLE_ENTRY64 b64
    )
{
#define COPYSE2(p64,s32,f) p64->f = (ULONG64)(LONG64)(LONG)s32->f
    COPYSE2(b64,b32,InLoadOrderLinks.Flink);
    COPYSE2(b64,b32,InLoadOrderLinks.Blink);
    COPYSE2(b64,b32,__Undefined1);
    COPYSE2(b64,b32,__Undefined2);
    COPYSE2(b64,b32,__Undefined3);
    COPYSE2(b64,b32,NonPagedDebugInfo);
    COPYSE2(b64,b32,DllBase);
    COPYSE2(b64,b32,EntryPoint);
    b64->SizeOfImage = b32->SizeOfImage;

    b64->FullDllName.Length = b32->FullDllName.Length;
    b64->FullDllName.MaximumLength = b32->FullDllName.MaximumLength;
    COPYSE2(b64,b32,FullDllName.Buffer);

    b64->BaseDllName.Length = b32->BaseDllName.Length;
    b64->BaseDllName.MaximumLength = b32->BaseDllName.MaximumLength;
    COPYSE2(b64,b32,BaseDllName.Buffer);

    b64->Flags     = b32->Flags;
    b64->LoadCount = b32->LoadCount;
    b64->__Undefined5 = b32->__Undefined5;

    COPYSE2(b64,b32,__Undefined6);
    b64->CheckSum = b32->CheckSum;
    b64->TimeDateStamp = b32->TimeDateStamp;
#undef COPYSE2
    return;
}

HRESULT
TargetInfo::ReadLoaderEntry(
    MachineInfo* Machine,
    ULONG64 Address,
    PKLDR_DATA_TABLE_ENTRY64 Entry
    )
{
    HRESULT Status;
    ULONG Result;
    ULONG SizeToRead;
    KLDR_DATA_TABLE_ENTRY32 Ent32;

    if (Machine->m_Ptr64)
    {
        SizeToRead = sizeof(KLDR_DATA_TABLE_ENTRY64);
        Status = ReadVirtual(Address, Entry, SizeToRead, &Result);
    }
    else
    {
        SizeToRead = sizeof(KLDR_DATA_TABLE_ENTRY32);
        Status = ReadVirtual(Address, &Ent32, SizeToRead, &Result);
        ConvertLoaderEntry32To64(&Ent32, Entry);
    }

    if (Status != S_OK)
    {
        return Status;
    }

    if (Result != SizeToRead)
    {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT
TargetInfo::ReadUnicodeString(MachineInfo* Machine,
                              ULONG64 Address, PUNICODE_STRING64 String)
{
    HRESULT Status;
    ULONG Result;
    ULONG SizeToRead;
    UNICODE_STRING32 Str32;

    if (Machine->m_Ptr64)
    {
        SizeToRead = sizeof(UNICODE_STRING64);
        Status = ReadVirtual(Address, String, SizeToRead, &Result);
    }
    else
    {
        SizeToRead = sizeof(UNICODE_STRING32);
        Status = ReadVirtual(Address, &Str32, SizeToRead, &Result);
        String->Length = Str32.Length;
        String->MaximumLength = Str32.MaximumLength;
        String->Buffer = EXTEND64(Str32.Buffer);
    }

    if (Status != S_OK)
    {
        return Status;
    }

    if (Result != SizeToRead)
    {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT
TargetInfo::ReadDirectoryTableBase(PULONG64 DirBase)
{
    HRESULT Status;
    ULONG64 CurProc;

    // Retrieve the current EPROCESS's DirectoryTableBase[0] value.
    Status = GetProcessInfoDataOffset(g_CurrentProcess->CurrentThread,
                                      0, 0, &CurProc);
    if (Status != S_OK)
    {
        return Status;
    }

    CurProc += g_TargetMachine->m_OffsetEprocessDirectoryTableBase;
    return ReadPointer(g_TargetMachine, CurProc, DirBase);
}

HRESULT
TargetInfo::ReadImplicitThreadInfoPointer(ULONG Offset, PULONG64 Ptr)
{
    HRESULT Status;
    ULONG64 CurThread;

    // Retrieve the current ETHREAD.
    if ((Status = GetImplicitThreadData(&CurThread)) != S_OK)
    {
        return Status;
    }

    return ReadPointer(g_TargetMachine, CurThread + Offset, Ptr);
}

HRESULT
TargetInfo::ReadImplicitProcessInfoPointer(ULONG Offset, PULONG64 Ptr)
{
    HRESULT Status;
    ULONG64 CurProc;

    // Retrieve the current EPROCESS.
    if ((Status = GetImplicitProcessData(&CurProc)) != S_OK)
    {
        return Status;
    }

    return ReadPointer(g_TargetMachine, CurProc + Offset, Ptr);
}

HRESULT
TargetInfo::ReadSharedUserTimeDateN(PULONG64 TimeDate)
{
    HRESULT Status;
    ULONG Done;

    Status = ReadVirtual(g_TargetMachine->m_SharedUserDataOffset +
                         FIELD_OFFSET(KUSER_SHARED_DATA, SystemTime),
                         TimeDate, sizeof(*TimeDate), &Done);
    if (Status != S_OK)
    {
        return Status;
    }
    if (Done != sizeof(*TimeDate))
    {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

    return S_OK;
}

HRESULT
TargetInfo::ReadSharedUserUpTimeN(PULONG64 UpTime)
{
    HRESULT Status;
    ULONG Done;

    Status = ReadVirtual(g_TargetMachine->m_SharedUserDataOffset +
                         FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTime),
                         UpTime, sizeof(*UpTime), &Done);
    if (Status != S_OK)
    {
        return Status;
    }
    if (Done != sizeof(*UpTime))
    {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

    return S_OK;
}

// VS_VERSIONINFO has a variable format but in the case we
// care about it's fixed.
struct PARTIAL_VERSIONINFO
{
    WORD wLength;
    WORD wValueLength;
    WORD wType;
    WCHAR szKey[17];
    VS_FIXEDFILEINFO Value;
};

#define VER2_SIG ((ULONG)'X2EF')

HRESULT
TargetInfo::ReadImageVersionInfo(ULONG64 ImageBase,
                                 PCSTR Item,
                                 PVOID Buffer,
                                 ULONG BufferSize,
                                 PULONG VerInfoSize,
                                 PIMAGE_DATA_DIRECTORY ResDataDir)
{
    if (ResDataDir->VirtualAddress == 0 ||
        ResDataDir->Size < sizeof(IMAGE_RESOURCE_DIRECTORY))
    {
        return E_NOINTERFACE;
    }

    HRESULT Status;
    IMAGE_RESOURCE_DIRECTORY ResDir;
    ULONG64 Offset, DirOffset;

    Offset = ImageBase + ResDataDir->VirtualAddress;
    if ((Status = ReadAllVirtual(Offset, &ResDir, sizeof(ResDir))) != S_OK)
    {
        return Status;
    }

    //
    // Search for the resource directory entry named by VS_FILE_INFO.
    //
    
    IMAGE_RESOURCE_DIRECTORY_ENTRY DirEnt;
    ULONG i;

    DirOffset = Offset;
    Offset += sizeof(ResDir) +
        ((ULONG64)ResDir.NumberOfNamedEntries * sizeof(DirEnt));
    for (i = 0; i < (ULONG)ResDir.NumberOfIdEntries; i++)
    {
        if ((Status = ReadAllVirtual(Offset, &DirEnt, sizeof(DirEnt))) != S_OK)
        {
            return Status;
        }

        if (!DirEnt.NameIsString &&
            MAKEINTRESOURCE(DirEnt.Id) == VS_FILE_INFO)
        {
            break;
        }

        Offset += sizeof(DirEnt);
    }

    if (i >= (ULONG)ResDir.NumberOfIdEntries ||
        !DirEnt.DataIsDirectory)
    {
        return E_NOINTERFACE;
    }

    Offset = DirOffset + DirEnt.OffsetToDirectory;
    if ((Status = ReadAllVirtual(Offset, &ResDir, sizeof(ResDir))) != S_OK)
    {
        return Status;
    }
    
    //
    // Search for the resource directory entry named by VS_VERSION_INFO.
    //

    Offset += sizeof(ResDir) +
        ((ULONG64)ResDir.NumberOfNamedEntries * sizeof(DirEnt));
    for (i = 0; i < (ULONG)ResDir.NumberOfIdEntries; i++)
    {
        if ((Status = ReadAllVirtual(Offset, &DirEnt, sizeof(DirEnt))) != S_OK)
        {
            return Status;
        }

        if (DirEnt.Name == VS_VERSION_INFO)
        {
            break;
        }

        Offset += sizeof(DirEnt);
    }

    if (i >= (ULONG)ResDir.NumberOfIdEntries ||
        !DirEnt.DataIsDirectory)
    {
        return E_NOINTERFACE;
    }

    Offset = DirOffset + DirEnt.OffsetToDirectory;
    if ((Status = ReadAllVirtual(Offset, &ResDir, sizeof(ResDir))) != S_OK)
    {
        return Status;
    }
    
    //
    // We now have the VS_VERSION_INFO directory.  Just take
    // the first entry as we don't care about languages.
    //

    Offset += sizeof(ResDir);
    if ((Status = ReadAllVirtual(Offset, &DirEnt, sizeof(DirEnt))) != S_OK)
    {
        return Status;
    }

    if (DirEnt.DataIsDirectory)
    {
        return E_NOINTERFACE;
    }

    IMAGE_RESOURCE_DATA_ENTRY DataEnt;
    
    Offset = DirOffset + DirEnt.OffsetToData;
    if ((Status = ReadAllVirtual(Offset, &DataEnt, sizeof(DataEnt))) != S_OK)
    {
        return Status;
    }

    if (DataEnt.Size < sizeof(PARTIAL_VERSIONINFO))
    {
        return E_NOINTERFACE;
    }

    PARTIAL_VERSIONINFO RawInfo;

    Offset = ImageBase + DataEnt.OffsetToData;
    if ((Status = ReadAllVirtual(Offset, &RawInfo, sizeof(RawInfo))) != S_OK)
    {
        return Status;
    }

    if (RawInfo.wLength < sizeof(RawInfo) ||
        wcscmp(RawInfo.szKey, L"VS_VERSION_INFO") != 0)
    {
        return E_NOINTERFACE;
    }

    //
    // VerQueryValueA needs extra data space for ANSI translations
    // of version strings.  VQVA assumes that this space is available
    // at the end of the data block passed in.  GetFileVersionInformationSize
    // makes this work by returning a size that's big enough
    // for the actual data plus space for ANSI translations.  We
    // need to do the same thing here so that we also provide
    // the necessary translation area.
    //

    ULONG DataSize = (RawInfo.wLength + 3) & ~3;
    PVOID VerData = malloc(DataSize * 2 + sizeof(ULONG));
    if (VerData == NULL)
    {
        return E_OUTOFMEMORY;
    }
        
    if ((Status = ReadAllVirtual(Offset, VerData, RawInfo.wLength)) == S_OK)
    {
        // Stamp the buffer with the signature that indicates
        // a full-size translation buffer is available after
        // the raw data.
        *(PULONG)((PUCHAR)VerData + DataSize) = VER2_SIG;
        
        Status = QueryVersionDataBuffer(VerData, Item,
                                        Buffer, BufferSize, VerInfoSize);
    }
        
    free(VerData);
    return Status;
}

//----------------------------------------------------------------------------
//
// LiveKernelTargetInfo data space methods.
//
//----------------------------------------------------------------------------

HRESULT
LiveKernelTargetInfo::GetProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    return g_TargetMachine->ReadKernelProcessorId(Processor, Id);
}

//----------------------------------------------------------------------------
//
// ConnLiveKernelTargetInfo data space methods.
//
//----------------------------------------------------------------------------

HRESULT
ConnLiveKernelTargetInfo::ReadVirtual(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    return g_VirtualCache.Read(Offset, Buffer, BufferSize, BytesRead);
}

HRESULT
ConnLiveKernelTargetInfo::WriteVirtual(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    HRESULT Status =
        g_VirtualCache.Write(Offset, Buffer, BufferSize, BytesWritten);
    if (Status == S_OK)
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_VIRTUAL);
    }
    return Status;
}

HRESULT
ConnLiveKernelTargetInfo::SearchVirtual(
    IN ULONG64 Offset,
    IN ULONG64 Length,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    IN ULONG PatternGranularity,
    OUT PULONG64 MatchOffset
    )
{
    // In NT 4.0, the search API is not supported at the kernel protocol
    // level.  Fall back to the default ReamMemory \ search.
    //

    HRESULT Status;

    if (g_SystemVersion <= NT_SVER_NT4 || PatternGranularity != 1)
    {
        Status = TargetInfo::SearchVirtual(Offset, Length, (PUCHAR)Pattern,
                                           PatternSize, PatternGranularity,
                                           MatchOffset);
    }
    else
    {
        NTSTATUS NtStatus =
            DbgKdSearchMemory(Offset, Length, (PUCHAR)Pattern,
                              PatternSize, MatchOffset);
        Status = CONV_NT_STATUS(NtStatus);
    }

    return Status;
}

HRESULT
ConnLiveKernelTargetInfo::ReadVirtualUncached(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    ULONG Length, Read;
    NTSTATUS Status;

    *BytesRead = 0;
    while (BufferSize)
    {
        Length = BufferSize;
        for (;;)
        {
            Status = DbgKdReadVirtualMemoryNow(Offset, Buffer, Length, &Read);
            if (NT_SUCCESS(Status))
            {
                break;
            }

            if (Status == STATUS_CONTROL_C_EXIT)
            {
                return HRESULT_FROM_NT(Status);
            }

            if ((Offset & ~((ULONG64)g_TargetMachine->m_PageSize - 1)) !=
                ((Offset + Length - 1) & ~((ULONG64)g_TargetMachine->m_PageSize - 1)))
            {
                //
                // Before accepting the error, make sure request
                // didn't fail because it crossed multiple pages
                //

                Length = (ULONG)
                    ((Offset | (g_TargetMachine->m_PageSize - 1)) -
                     Offset + 1);
            }
            else
            {
                if (Status == STATUS_UNSUCCESSFUL &&
                    g_VirtualCache.m_DecodePTEs &&
                    !g_VirtualCache.m_ForceDecodePTEs)
                {
                    //
                    // Try getting the memory by looking up the physical
                    // location of the page
                    //

                    Status = DbgKdReadVirtualTranslatedMemory(Offset, Buffer,
                                                              Length, &Read);
                    if (NT_SUCCESS(Status))
                    {
                        break;
                    }
                }

                //
                // Unable to get more memory.  If we already read
                // some return success, otherwise return error to
                // the caller.
                //

                return *BytesRead > 0 ? S_OK : HRESULT_FROM_NT(Status);
            }
        }

        BufferSize -= Read;
        Offset += Read;
        Buffer = (PVOID)((PUCHAR)Buffer + Read);
        *BytesRead += Read;
    }

    return S_OK;
}

HRESULT
ConnLiveKernelTargetInfo::WriteVirtualUncached(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    NTSTATUS Status =
        DbgKdWriteVirtualMemoryNow(Offset, Buffer, BufferSize, BytesWritten);

    if (Status == STATUS_UNSUCCESSFUL &&
        g_VirtualCache.m_DecodePTEs &&
        !g_VirtualCache.m_ForceDecodePTEs)
    {
        //
        // Try getting the memory by looking up the physical
        // location of the page
        //

        Status = DbgKdWriteVirtualTranslatedMemory(Offset, Buffer,
                                                   BufferSize, BytesWritten);
    }

    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_VIRTUAL);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
ConnLiveKernelTargetInfo::ReadPhysical(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    if (g_PhysicalCacheActive)
    {
        return g_PhysicalCache.Read(Offset, Buffer, BufferSize, BytesRead);
    }
    else
    {
        return ReadPhysicalUncached(Offset, Buffer, BufferSize, BytesRead);
    }
}

HRESULT
ConnLiveKernelTargetInfo::WritePhysical(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    if (g_PhysicalCacheActive)
    {
        return g_PhysicalCache.Write(Offset, Buffer, BufferSize,
                                     BytesWritten);
    }
    else
    {
        return WritePhysicalUncached(Offset, Buffer, BufferSize,
                                     BytesWritten);
    }
}

HRESULT
ConnLiveKernelTargetInfo::ReadPhysicalUncached(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    NTSTATUS Status =
        DbgKdReadPhysicalMemory(Offset, Buffer, BufferSize,
                                BytesRead);
    return CONV_NT_STATUS(Status);
}

HRESULT
ConnLiveKernelTargetInfo::WritePhysicalUncached(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    NTSTATUS Status =
        DbgKdWritePhysicalMemory(Offset, Buffer, BufferSize,
                                 BytesWritten);
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_PHYSICAL);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
ConnLiveKernelTargetInfo::ReadControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    NTSTATUS Status =
        DbgKdReadControlSpace((USHORT)Processor, (ULONG)Offset,
                              Buffer, BufferSize, BytesRead);
    return CONV_NT_STATUS(Status);
}

HRESULT
ConnLiveKernelTargetInfo::WriteControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    NTSTATUS Status =
        DbgKdWriteControlSpace((USHORT)Processor, (ULONG)Offset,
                               Buffer, BufferSize,
                               BytesWritten);
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_CONTROL);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
ConnLiveKernelTargetInfo::ReadIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    NTSTATUS Status;

    // Convert trivially extended I/O requests down into simple
    // requests as not all platform support extended requests.
    if (InterfaceType == Isa && BusNumber == 0 && AddressSpace == 1)
    {
        Status = DbgKdReadIoSpace(Offset, Buffer, BufferSize);
    }
    else
    {
        Status = DbgKdReadIoSpaceExtended(Offset, Buffer, BufferSize,
                                          (INTERFACE_TYPE)InterfaceType,
                                          BusNumber, AddressSpace);
    }

    if (NT_SUCCESS(Status))
    {
        // I/O access currently can't successfully return anything
        // than the requested size.
        if (BytesRead != NULL)
        {
            *BytesRead = BufferSize;
        }
        return S_OK;
    }
    else
    {
        return HRESULT_FROM_NT(Status);
    }
}

HRESULT
ConnLiveKernelTargetInfo::WriteIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    NTSTATUS Status;

    // Convert trivially extended I/O requests down into simple
    // requests as not all platform support extended requests.
    if (InterfaceType == Isa && BusNumber == 0 && AddressSpace == 1)
    {
        Status = DbgKdWriteIoSpace(Offset, *(ULONG *)Buffer, BufferSize);
    }
    else
    {
        Status = DbgKdWriteIoSpaceExtended(Offset, *(ULONG *)Buffer,
                                           BufferSize,
                                           (INTERFACE_TYPE)InterfaceType,
                                           BusNumber, AddressSpace);
    }

    if (NT_SUCCESS(Status))
    {
        // I/O access currently can't successfully return anything
        // than the requested size.
        if (BytesWritten != NULL)
        {
            *BytesWritten = BufferSize;
        }
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_IO);
        return S_OK;
    }
    else
    {
        return HRESULT_FROM_NT(Status);
    }
}

HRESULT
ConnLiveKernelTargetInfo::ReadMsr(
    THIS_
    IN ULONG Msr,
    OUT PULONG64 Value
    )
{
    NTSTATUS Status =
        DbgKdReadMsr(Msr, Value);
    return CONV_NT_STATUS(Status);
}

HRESULT
ConnLiveKernelTargetInfo::WriteMsr(
    THIS_
    IN ULONG Msr,
    IN ULONG64 Value
    )
{
    NTSTATUS Status =
        DbgKdWriteMsr(Msr, Value);
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_MSR);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
ConnLiveKernelTargetInfo::ReadBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    NTSTATUS Status =
        DbgKdGetBusData(BusDataType, BusNumber, SlotNumber,
                        Buffer, Offset, &BufferSize);
    if (NT_SUCCESS(Status) && BytesRead != NULL)
    {
        *BytesRead = BufferSize;
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
ConnLiveKernelTargetInfo::WriteBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    NTSTATUS Status =
        DbgKdSetBusData(BusDataType, BusNumber, SlotNumber,
                        Buffer, Offset, &BufferSize);
    if (NT_SUCCESS(Status) && BytesWritten != NULL)
    {
        *BytesWritten = BufferSize;
    }
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_BUS_DATA);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
ConnLiveKernelTargetInfo::CheckLowMemory(
    THIS
    )
{
    NTSTATUS Status =
        DbgKdCheckLowMemory();
    return CONV_NT_STATUS(Status);
}

HRESULT
ConnLiveKernelTargetInfo::FillVirtual(
    THIS_
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT PULONG Filled
    )
{
    HRESULT Status;
    
    if (g_KdMaxManipulate <= DbgKdFillMemoryApi ||
        PatternSize > PACKET_MAX_SIZE)
    {
        Status = TargetInfo::FillVirtual(Start, Size, Pattern,
                                         PatternSize, Filled);
    }
    else
    {
        NTSTATUS NtStatus =
            DbgKdFillMemory(DBGKD_FILL_MEMORY_VIRTUAL, Start, Size,
                            Pattern, PatternSize, Filled);
        Status = CONV_NT_STATUS(NtStatus);
    }

    return Status;
}

HRESULT
ConnLiveKernelTargetInfo::FillPhysical(
    THIS_
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT PULONG Filled
    )
{
    HRESULT Status;
    
    if (g_KdMaxManipulate <= DbgKdFillMemoryApi ||
        PatternSize > PACKET_MAX_SIZE)
    {
        Status = TargetInfo::FillPhysical(Start, Size, Pattern,
                                          PatternSize, Filled);
    }
    else
    {
        NTSTATUS NtStatus =
            DbgKdFillMemory(DBGKD_FILL_MEMORY_PHYSICAL, Start, Size,
                            Pattern, PatternSize, Filled);
        Status = CONV_NT_STATUS(NtStatus);
    }

    return Status;
}

HRESULT
ConnLiveKernelTargetInfo::QueryAddressInformation(ULONG64 Address,
                                                  ULONG InSpace,
                                                  PULONG OutSpace,
                                                  PULONG OutFlags)
{
    HRESULT Status;

    if (g_KdMaxManipulate <= DbgKdQueryMemoryApi)
    {
        Status = TargetInfo::QueryAddressInformation(Address, InSpace,
                                                     OutSpace, OutFlags);
    }
    else
    {
        NTSTATUS NtStatus =
            DbgKdQueryMemory(Address, InSpace, OutSpace, OutFlags);
        Status = CONV_NT_STATUS(NtStatus);
    }

    return Status;
}

//----------------------------------------------------------------------------
//
// LocalLiveKernelTargetInfo data space methods.
//
//----------------------------------------------------------------------------

HRESULT
LocalLiveKernelTargetInfo::ReadVirtual(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    SYSDBG_VIRTUAL Cmd;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // The kernel only allows operations up to
    // KDP_MESSAGE_BUFFER_SIZE, so break things up
    // into chunks if necessary.
    //

    *BytesRead = 0;
    Cmd.Address = (PVOID)(ULONG_PTR)Offset;
    Cmd.Buffer = Buffer;
    
    while (BufferSize > 0)
    {
        ULONG ChunkDone;

        if (BufferSize > PACKET_MAX_SIZE)
        {
            Cmd.Request = PACKET_MAX_SIZE;
        }
        else
        {
            Cmd.Request = BufferSize;
        }

        // The kernel stubs avoid faults so all memory
        // must be paged in ahead of time.  There's
        // still the possibility that something could
        // get paged out after this but the assumption is
        // that the vulnerability is small and it's much
        // better than implementing dual code paths in
        // the kernel.
        if (IsBadWritePtr(Cmd.Buffer, Cmd.Request))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        ChunkDone = 0;
        Status =
            g_NtDllCalls.NtSystemDebugControl(SysDbgReadVirtual,
                                              &Cmd, sizeof(Cmd),
                                              NULL, 0,
                                              &ChunkDone);
        if (!NT_SUCCESS(Status) && Status != STATUS_UNSUCCESSFUL)
        {
            break;
        }
        if (ChunkDone == 0)
        {
            // If some data was processed consider it a success.
            Status = *BytesRead > 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
            break;
        }

        Cmd.Address = (PVOID)((PUCHAR)Cmd.Address + ChunkDone);
        Cmd.Buffer = (PVOID)((PUCHAR)Cmd.Buffer + ChunkDone);
        BufferSize -= ChunkDone;
        *BytesRead += ChunkDone;
    }
    
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::WriteVirtual(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    SYSDBG_VIRTUAL Cmd;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // The kernel only allows operations up to
    // KDP_MESSAGE_BUFFER_SIZE, so break things up
    // into chunks if necessary.
    //

    *BytesWritten = 0;
    Cmd.Address = (PVOID)(ULONG_PTR)Offset;
    Cmd.Buffer = Buffer;
    
    while (BufferSize > 0)
    {
        ULONG ChunkDone;

        if (BufferSize > PACKET_MAX_SIZE)
        {
            Cmd.Request = PACKET_MAX_SIZE;
        }
        else
        {
            Cmd.Request = BufferSize;
        }

        // The kernel stubs avoid faults so all memory
        // must be paged in ahead of time.  There's
        // still the possibility that something could
        // get paged out after this but the assumption is
        // that the vulnerability is small and it's much
        // better than implementing dual code paths in
        // the kernel.
        if (IsBadReadPtr(Cmd.Buffer, Cmd.Request))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        ChunkDone = 0;
        Status =
            g_NtDllCalls.NtSystemDebugControl(SysDbgWriteVirtual,
                                              &Cmd, sizeof(Cmd),
                                              NULL, 0,
                                              &ChunkDone);
        if (!NT_SUCCESS(Status) && Status != STATUS_UNSUCCESSFUL)
        {
            break;
        }
        if (ChunkDone == 0)
        {
            // If some data was processed consider it a success.
            Status = *BytesWritten > 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
            break;
        }

        Cmd.Address = (PVOID)((PUCHAR)Cmd.Address + ChunkDone);
        Cmd.Buffer = (PVOID)((PUCHAR)Cmd.Buffer + ChunkDone);
        BufferSize -= ChunkDone;
        *BytesWritten += ChunkDone;
    }
    
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_VIRTUAL);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::ReadPhysical(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    SYSDBG_PHYSICAL Cmd;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // The kernel only allows operations up to
    // KDP_MESSAGE_BUFFER_SIZE, so break things up
    // into chunks if necessary.
    //

    *BytesRead = 0;
    Cmd.Address.QuadPart = Offset;
    Cmd.Buffer = Buffer;
    
    while (BufferSize > 0)
    {
        ULONG ChunkDone;

        if (BufferSize > PACKET_MAX_SIZE)
        {
            Cmd.Request = PACKET_MAX_SIZE;
        }
        else
        {
            Cmd.Request = BufferSize;
        }

        // The kernel stubs avoid faults so all memory
        // must be paged in ahead of time.  There's
        // still the possibility that something could
        // get paged out after this but the assumption is
        // that the vulnerability is small and it's much
        // better than implementing dual code paths in
        // the kernel.
        if (IsBadWritePtr(Cmd.Buffer, Cmd.Request))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        ChunkDone = 0;
        Status =
            g_NtDllCalls.NtSystemDebugControl(SysDbgReadPhysical,
                                              &Cmd, sizeof(Cmd),
                                              NULL, 0,
                                              &ChunkDone);
        if (!NT_SUCCESS(Status) && Status != STATUS_UNSUCCESSFUL)
        {
            break;
        }
        if (ChunkDone == 0)
        {
            // If some data was processed consider it a success.
            Status = *BytesRead > 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
            break;
        }

        Cmd.Address.QuadPart += ChunkDone;
        Cmd.Buffer = (PVOID)((PUCHAR)Cmd.Buffer + ChunkDone);
        BufferSize -= ChunkDone;
        *BytesRead += ChunkDone;
    }
    
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::WritePhysical(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    SYSDBG_PHYSICAL Cmd;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // The kernel only allows operations up to
    // KDP_MESSAGE_BUFFER_SIZE, so break things up
    // into chunks if necessary.
    //

    *BytesWritten = 0;
    Cmd.Address.QuadPart = Offset;
    Cmd.Buffer = Buffer;
    
    while (BufferSize > 0)
    {
        ULONG ChunkDone;

        if (BufferSize > PACKET_MAX_SIZE)
        {
            Cmd.Request = PACKET_MAX_SIZE;
        }
        else
        {
            Cmd.Request = BufferSize;
        }
        
        // The kernel stubs avoid faults so all memory
        // must be paged in ahead of time.  There's
        // still the possibility that something could
        // get paged out after this but the assumption is
        // that the vulnerability is small and it's much
        // better than implementing dual code paths in
        // the kernel.
        if (IsBadReadPtr(Cmd.Buffer, Cmd.Request))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        ChunkDone = 0;
        Status =
            g_NtDllCalls.NtSystemDebugControl(SysDbgWritePhysical,
                                              &Cmd, sizeof(Cmd),
                                              NULL, 0,
                                              &ChunkDone);
        if (!NT_SUCCESS(Status) && Status != STATUS_UNSUCCESSFUL)
        {
            break;
        }
        if (ChunkDone == 0)
        {
            // If some data was processed consider it a success.
            Status = *BytesWritten > 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
            break;
        }

        Cmd.Address.QuadPart += ChunkDone;
        Cmd.Buffer = (PVOID)((PUCHAR)Cmd.Buffer + ChunkDone);
        BufferSize -= ChunkDone;
        *BytesWritten += ChunkDone;
    }
    
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_PHYSICAL);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::ReadControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    // The kernel stubs avoid faults so all memory
    // must be paged in ahead of time.  There's
    // still the possibility that something could
    // get paged out after this but the assumption is
    // that the vulnerability is small and it's much
    // better than implementing dual code paths in
    // the kernel.
    if (IsBadWritePtr(Buffer, BufferSize))
    {
        return E_INVALIDARG;
    }

    SYSDBG_CONTROL_SPACE Cmd;
    Cmd.Address = Offset;
    Cmd.Buffer = Buffer;
    Cmd.Request = BufferSize;
    Cmd.Processor = Processor;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgReadControlSpace,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          BytesRead);
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::WriteControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    // The kernel stubs avoid faults so all memory
    // must be paged in ahead of time.  There's
    // still the possibility that something could
    // get paged out after this but the assumption is
    // that the vulnerability is small and it's much
    // better than implementing dual code paths in
    // the kernel.
    if (IsBadReadPtr(Buffer, BufferSize))
    {
        return E_INVALIDARG;
    }

    SYSDBG_CONTROL_SPACE Cmd;
    Cmd.Address = Offset;
    Cmd.Buffer = Buffer;
    Cmd.Request = BufferSize;
    Cmd.Processor = Processor;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgWriteControlSpace,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          BytesWritten);
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_CONTROL);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::ReadIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    // The kernel stubs avoid faults so all memory
    // must be paged in ahead of time.  There's
    // still the possibility that something could
    // get paged out after this but the assumption is
    // that the vulnerability is small and it's much
    // better than implementing dual code paths in
    // the kernel.
    if (IsBadWritePtr(Buffer, BufferSize))
    {
        return E_INVALIDARG;
    }

    SYSDBG_IO_SPACE Cmd;
    Cmd.Address = Offset;
    Cmd.Buffer = Buffer;
    Cmd.Request = BufferSize;
    Cmd.InterfaceType = (INTERFACE_TYPE)InterfaceType;
    Cmd.BusNumber = BusNumber;
    Cmd.AddressSpace = AddressSpace;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgReadIoSpace,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          BytesRead);
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::WriteIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    // The kernel stubs avoid faults so all memory
    // must be paged in ahead of time.  There's
    // still the possibility that something could
    // get paged out after this but the assumption is
    // that the vulnerability is small and it's much
    // better than implementing dual code paths in
    // the kernel.
    if (IsBadReadPtr(Buffer, BufferSize))
    {
        return E_INVALIDARG;
    }

    SYSDBG_IO_SPACE Cmd;
    Cmd.Address = Offset;
    Cmd.Buffer = Buffer;
    Cmd.Request = BufferSize;
    Cmd.InterfaceType = (INTERFACE_TYPE)InterfaceType;
    Cmd.BusNumber = BusNumber;
    Cmd.AddressSpace = AddressSpace;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgWriteIoSpace,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          BytesWritten);
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_IO);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::ReadMsr(
    THIS_
    IN ULONG Msr,
    OUT PULONG64 Value
    )
{
    SYSDBG_MSR Cmd;
    Cmd.Msr = Msr;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgReadMsr,
                                          &Cmd, sizeof(Cmd),
                                          &Cmd, sizeof(Cmd),
                                          NULL);
    if (NT_SUCCESS(Status))
    {
        *Value = Cmd.Data;
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::WriteMsr(
    THIS_
    IN ULONG Msr,
    IN ULONG64 Value
    )
{
    SYSDBG_MSR Cmd;
    Cmd.Msr = Msr;
    Cmd.Data = Value;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgWriteMsr,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          NULL);
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_MSR);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::ReadBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    // The kernel stubs avoid faults so all memory
    // must be paged in ahead of time.  There's
    // still the possibility that something could
    // get paged out after this but the assumption is
    // that the vulnerability is small and it's much
    // better than implementing dual code paths in
    // the kernel.
    if (IsBadWritePtr(Buffer, BufferSize))
    {
        return E_INVALIDARG;
    }

    SYSDBG_BUS_DATA Cmd;
    Cmd.Address = Offset;
    Cmd.Buffer = Buffer;
    Cmd.Request = BufferSize;
    Cmd.BusDataType = (BUS_DATA_TYPE)BusDataType;
    Cmd.BusNumber = BusNumber;
    Cmd.SlotNumber = SlotNumber;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgReadBusData,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          BytesRead);
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::WriteBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    // The kernel stubs avoid faults so all memory
    // must be paged in ahead of time.  There's
    // still the possibility that something could
    // get paged out after this but the assumption is
    // that the vulnerability is small and it's much
    // better than implementing dual code paths in
    // the kernel.
    if (IsBadReadPtr(Buffer, BufferSize))
    {
        return E_INVALIDARG;
    }

    SYSDBG_BUS_DATA Cmd;
    Cmd.Address = Offset;
    Cmd.Buffer = Buffer;
    Cmd.Request = BufferSize;
    Cmd.BusDataType = (BUS_DATA_TYPE)BusDataType;
    Cmd.BusNumber = BusNumber;
    Cmd.SlotNumber = SlotNumber;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgWriteBusData,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          BytesWritten);
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_BUS_DATA);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::CheckLowMemory(
    THIS
    )
{
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgCheckLowMemory,
                                          NULL, 0,
                                          NULL, 0,
                                          NULL);
    return CONV_NT_STATUS(Status);
}

//----------------------------------------------------------------------------
//
// ExdiLiveKernelTargetInfo data space methods.
//
//----------------------------------------------------------------------------

HRESULT
ExdiLiveKernelTargetInfo::ReadVirtual(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    HRESULT Status = m_Server->
        ReadVirtualMemory(Offset, BufferSize, 8, (PBYTE)Buffer, BytesRead);
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::WriteVirtual(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    HRESULT Status = m_Server->
        WriteVirtualMemory(Offset, BufferSize, 8, (PBYTE)Buffer, BytesWritten);
    if (Status == S_OK)
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_VIRTUAL);
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::ReadPhysical(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    HRESULT Status = m_Server->
        ReadPhysicalMemoryOrPeriphIO(Offset, 0, BufferSize, 8, (PBYTE)Buffer);
    if (Status == S_OK)
    {
        *BytesRead = BufferSize;
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::WritePhysical(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    HRESULT Status = m_Server->
        WritePhysicalMemoryOrPeriphIO(Offset, 0, BufferSize, 8, (PBYTE)Buffer);
    if (Status == S_OK)
    {
        *BytesWritten = BufferSize;
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_PHYSICAL);
    }
    return Status;
}

// XXX drewb - Guessing at how to implement these spaces.
#define EXDI_ADDR_CONTROL_SPACE 2
#define EXDI_ADDR_MSR           3
#define EXDI_ADDR_BUS_DATA      4

HRESULT
ExdiLiveKernelTargetInfo::ReadControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    if (m_KdSupport != EXDI_KD_IOCTL)
    {
        return E_UNEXPECTED;
    }
    HRESULT Status = m_Server->
        ReadPhysicalMemoryOrPeriphIO(Offset, EXDI_ADDR_CONTROL_SPACE,
                                     BufferSize, 8, (PBYTE)Buffer);
    if (Status == S_OK)
    {
        *BytesRead = BufferSize;
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::WriteControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    if (m_KdSupport != EXDI_KD_IOCTL)
    {
        return E_UNEXPECTED;
    }
    HRESULT Status = m_Server->
        WritePhysicalMemoryOrPeriphIO(Offset, EXDI_ADDR_CONTROL_SPACE,
                                      BufferSize, 8, (PBYTE)Buffer);
    if (Status == S_OK)
    {
        *BytesWritten = BufferSize;
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_CONTROL);
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::ReadIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    HRESULT Status = m_Server->
        ReadPhysicalMemoryOrPeriphIO(Offset, 1, BufferSize, 8, (PBYTE)Buffer);
    if (Status == S_OK)
    {
        *BytesRead = BufferSize;
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::WriteIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    HRESULT Status = m_Server->
        WritePhysicalMemoryOrPeriphIO(Offset, 1, BufferSize, 8, (PBYTE)Buffer);
    if (Status == S_OK)
    {
        *BytesWritten = BufferSize;
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_IO);
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::ReadMsr(
    THIS_
    IN ULONG Msr,
    OUT PULONG64 Value
    )
{
    if (m_KdSupport != EXDI_KD_IOCTL)
    {
        return E_UNEXPECTED;
    }
    HRESULT Status = m_Server->
        ReadPhysicalMemoryOrPeriphIO(Msr, EXDI_ADDR_MSR,
                                     1, 64, (PBYTE)Value);
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::WriteMsr(
    THIS_
    IN ULONG Msr,
    IN ULONG64 Value
    )
{
    if (m_KdSupport != EXDI_KD_IOCTL)
    {
        return E_UNEXPECTED;
    }
    HRESULT Status = m_Server->
        WritePhysicalMemoryOrPeriphIO(Msr, EXDI_ADDR_MSR,
                                      1, 64, (PBYTE)&Value);
    if (Status == S_OK)
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_MSR);
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::ReadBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    if (m_KdSupport != EXDI_KD_IOCTL)
    {
        return E_UNEXPECTED;
    }
    HRESULT Status = m_Server->
        ReadPhysicalMemoryOrPeriphIO(Offset, EXDI_ADDR_BUS_DATA,
                                     BufferSize, 8, (PBYTE)Buffer);
    if (Status == S_OK)
    {
        *BytesRead = BufferSize;
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::WriteBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    if (m_KdSupport != EXDI_KD_IOCTL)
    {
        return E_UNEXPECTED;
    }
    HRESULT Status = m_Server->
        WritePhysicalMemoryOrPeriphIO(Offset, EXDI_ADDR_BUS_DATA,
                                      BufferSize, 8, (PBYTE)Buffer);
    if (Status == S_OK)
    {
        *BytesWritten = BufferSize;
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_BUS_DATA);
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::CheckLowMemory(
    THIS
    )
{
    // XXX drewb - This doesn't have any meaning in
    // the general case.  What about when we know it's
    // NT on the other side of the emulator?
    return E_UNEXPECTED;
}

//----------------------------------------------------------------------------
//
// UserTargetInfo data space methods.
//
//----------------------------------------------------------------------------

HRESULT
UserTargetInfo::ReadVirtualUncached(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    // ReadProcessMemory will fail if any part of the
    // region to read does not have read access.  This
    // routine attempts to read the largest valid prefix
    // so it has to break up reads on page boundaries.

    HRESULT Status = S_OK;
    ULONG TotalBytesRead = 0;
    ULONG Read;
    ULONG ReadSize;

    while (BufferSize > 0)
    {
        // Calculate bytes to read and don't let read cross
        // a page boundary.
        ReadSize = g_TargetMachine->m_PageSize - (ULONG)
            (Offset & (g_TargetMachine->m_PageSize - 1));
        ReadSize = min(BufferSize, ReadSize);

        if ((Status = m_Services->
             ReadVirtual(g_CurrentProcess->FullHandle, Offset,
                         Buffer, ReadSize, &Read)) != S_OK)
        {
            if (TotalBytesRead != 0)
            {
                // If we've read something consider this a success.
                Status = S_OK;
            }
            break;
        }

        TotalBytesRead += Read;
        Offset += Read;
        Buffer = (PVOID)((PUCHAR)Buffer + Read);
        BufferSize -= (DWORD)Read;
    }

    if (Status == S_OK)
    {
        if (BytesRead != NULL)
        {
            *BytesRead = (DWORD)TotalBytesRead;
        }
    }

    return Status;
}

HRESULT
UserTargetInfo::WriteVirtualUncached(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    ULONG RealBytesWritten;
    HRESULT Status =
        m_Services->WriteVirtual(g_CurrentProcess->FullHandle,
                                 Offset, Buffer, BufferSize,
                                 &RealBytesWritten);
    *BytesWritten = (DWORD) RealBytesWritten;
    if (Status == S_OK)
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_VIRTUAL);
    }
    return Status;
}

HRESULT
UserTargetInfo::GetFunctionTableListHead(void)
{
    // Get the address of the dynamic function table list head which is the
    // the same for all processes. This only has to be done once.

    if (g_CurrentProcess->DynFuncTableList)
    {
        return S_OK;
    }

    if (m_Services->
        GetFunctionTableListHead(g_CurrentProcess->FullHandle,
                                 &g_CurrentProcess->DynFuncTableList) == S_OK)
    {
        return S_OK;
    }

    return TargetInfo::GetFunctionTableListHead();
}

HRESULT
UserTargetInfo::ReadOutOfProcessDynamicFunctionTable(PWSTR Dll,
                                                     ULONG64 Table,
                                                     PULONG RetTableSize,
                                                     PVOID* RetTableData)
{
    HRESULT Status;
    char DllA[MAX_PATH];
    PVOID TableData;
    ULONG TableSize;

    if (!WideCharToMultiByte(CP_ACP, 0, Dll, -1,
                             DllA, sizeof(DllA), NULL, NULL))
    {
        return WIN32_LAST_STATUS();
    }

    // Allocate an initial buffer of a reasonable size to try
    // and get the data in a single call.
    TableSize = 65536;

    for (;;)
    {
        TableData = malloc(TableSize);
        if (TableData == NULL)
        {
            return E_OUTOFMEMORY;
        }
    
        Status = m_Services->
            GetOutOfProcessFunctionTable(g_CurrentProcess->FullHandle,
                                         DllA, Table, TableData,
                                         TableSize, &TableSize);
        if (Status == S_OK)
        {
            break;
        }

        free(TableData);
        
        if (Status == S_FALSE)
        {
            // Buffer was too small so loop and try again with
            // the newly retrieved size.
        }
        else
        {
            return Status;
        }
    }

    *RetTableSize = TableSize;
    *RetTableData = TableData;
    return S_OK;
}

HRESULT
UserTargetInfo::QueryMemoryRegion(PULONG64 Handle,
                                  BOOL HandleIsOffset,
                                  PMEMORY_BASIC_INFORMATION64 Info)
{
    MEMORY_BASIC_INFORMATION64 MemInfo;
    HRESULT Status;
    
    for (;;)
    {
        ULONG Used;

        // The handle is always an offset in this mode so
        // there's no need to check.
        if ((Status = m_Services->
             QueryVirtual(g_CurrentProcess->FullHandle,
                          *Handle, &MemInfo, sizeof(MemInfo), &Used)) != S_OK)
        {
            return Status;
        }
        if (g_TargetMachine->m_Ptr64)
        {
            if (Used != sizeof(MEMORY_BASIC_INFORMATION64))
            {
                return E_FAIL;
            }

            *Info = MemInfo;
        }
        else
        {
            if (Used != sizeof(MEMORY_BASIC_INFORMATION32))
            {
                return E_FAIL;
            }

            MemoryBasicInformation32To64((MEMORY_BASIC_INFORMATION32*)&MemInfo,
                                         Info);
        }
        
        if (!((Info->Protect & PAGE_GUARD) ||
              (Info->Protect & PAGE_NOACCESS) ||
              (Info->State & MEM_FREE) ||
              (Info->State & MEM_RESERVE)))
        {
            break;
        }
        
        *Handle = Info->BaseAddress + Info->RegionSize;
    }

    *Handle = Info->BaseAddress + Info->RegionSize;
    
    return S_OK;
}

HRESULT
UserTargetInfo::ReadHandleData(
    IN ULONG64 Handle,
    IN ULONG DataType,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    )
{
    return m_Services->ReadHandleData(g_CurrentProcess->FullHandle,
                                      Handle, DataType, Buffer, BufferSize,
                                      DataSize);
}

HRESULT
UserTargetInfo::GetProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    ULONG Done;
    
    return m_Services->GetProcessorId(Id, sizeof(*Id), &Done);
}

HRESULT
LocalUserTargetInfo::ReadVirtual(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    return ReadVirtualUncached(Offset, Buffer, BufferSize, BytesRead);
}

HRESULT
LocalUserTargetInfo::WriteVirtual(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    return WriteVirtualUncached(Offset, Buffer, BufferSize, BytesWritten);
}

HRESULT
RemoteUserTargetInfo::ReadVirtual(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    return g_VirtualCache.Read(Offset, Buffer, BufferSize, BytesRead);
}

HRESULT
RemoteUserTargetInfo::WriteVirtual(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    return g_VirtualCache.Write(Offset, Buffer, BufferSize, BytesWritten);
}

//----------------------------------------------------------------------------
//
// IDebugDataSpaces.
//
//----------------------------------------------------------------------------

STDMETHODIMP
DebugClient::ReadVirtual(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    ULONG BytesTemp;
    HRESULT Status =
        g_Target->ReadVirtual(Offset, Buffer, BufferSize,
                              BytesRead != NULL ? BytesRead : &BytesTemp);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteVirtual(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    ULONG BytesTemp;
    HRESULT Status =
        g_Target->WriteVirtual(Offset, Buffer, BufferSize,
                               BytesWritten != NULL ? BytesWritten :
                               &BytesTemp);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SearchVirtual(
    THIS_
    IN ULONG64 Offset,
    IN ULONG64 Length,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    IN ULONG PatternGranularity,
    OUT PULONG64 MatchOffset
    )
{
    if (PatternGranularity == 0 ||
        PatternSize % PatternGranularity)
    {
        return E_INVALIDARG;
    }
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;

    ENTER_ENGINE();

    Status = g_Target->SearchVirtual(Offset, Length, Pattern,
                                     PatternSize, PatternGranularity,
                                     MatchOffset);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadVirtualUncached(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    ULONG BytesTemp;
    HRESULT Status =
        g_Target->ReadVirtualUncached(Offset, Buffer, BufferSize,
                                      BytesRead != NULL ? BytesRead :
                                      &BytesTemp);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteVirtualUncached(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    ULONG BytesTemp;
    HRESULT Status =
        g_Target->WriteVirtualUncached(Offset, Buffer, BufferSize,
                                       BytesWritten != NULL ? BytesWritten :
                                       &BytesTemp);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadPointersVirtual(
    THIS_
    IN ULONG Count,
    IN ULONG64 Offset,
    OUT /* size_is(Count) */ PULONG64 Ptrs
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG Done;

        Status = S_OK;
        while (Count-- > 0)
        {
            if ((Status = g_Target->
                 ReadPointer(g_Machine, Offset, Ptrs)) != S_OK)
            {
                break;
            }

            Offset += g_Machine->m_Ptr64 ? sizeof(ULONG64) : sizeof(ULONG);
            Ptrs++;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WritePointersVirtual(
    THIS_
    IN ULONG Count,
    IN ULONG64 Offset,
    IN /* size_is(Count) */ PULONG64 Ptrs
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG Done;

        Status = S_OK;
        while (Count-- > 0)
        {
            if ((Status = g_Target->
                 WritePointer(g_Machine, Offset, *Ptrs)) != S_OK)
            {
                break;
            }

            Offset += g_Machine->m_Ptr64 ? sizeof(ULONG64) : sizeof(ULONG);
            Ptrs++;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadPhysical(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    ULONG BytesTemp;
    HRESULT Status =
        g_Target->ReadPhysical(Offset, Buffer, BufferSize,
                               BytesRead != NULL ? BytesRead : &BytesTemp);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WritePhysical(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    ULONG BytesTemp;
    HRESULT Status =
        g_Target->WritePhysical(Offset, Buffer, BufferSize,
                                BytesWritten != NULL ? BytesWritten :
                                &BytesTemp);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    // KSPECIAL_REGISTER content is kept in control space
    // so accessing control space may touch data that's
    // cached in the current machine KSPECIAL_REGISTERS.
    // Flush the current machine to maintain consistency.
    FlushRegContext();
    
    ULONG BytesTemp;
    HRESULT Status =
        g_Target->ReadControl(Processor, Offset, Buffer, BufferSize,
                              BytesRead != NULL ? BytesRead : &BytesTemp);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    // KSPECIAL_REGISTER content is kept in control space
    // so accessing control space may touch data that's
    // cached in the current machine KSPECIAL_REGISTERS.
    // Flush the current machine to maintain consistency.
    FlushRegContext();
    
    ULONG BytesTemp;
    HRESULT Status =
        g_Target->WriteControl(Processor, Offset, Buffer, BufferSize,
                               BytesWritten != NULL ? BytesWritten :
                               &BytesTemp);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    ULONG BytesTemp;
    HRESULT Status =
        g_Target->ReadIo(InterfaceType, BusNumber, AddressSpace,
                         Offset, Buffer, BufferSize,
                         BytesRead != NULL ? BytesRead : &BytesTemp);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    ULONG BytesTemp;
    HRESULT Status =
        g_Target->WriteIo(InterfaceType, BusNumber, AddressSpace,
                          Offset, Buffer, BufferSize,
                          BytesWritten != NULL ? BytesWritten : &BytesTemp);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadMsr(
    THIS_
    IN ULONG Msr,
    OUT PULONG64 Value
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    HRESULT Status =
        g_Target->ReadMsr(Msr, Value);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteMsr(
    THIS_
    IN ULONG Msr,
    IN ULONG64 Value
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    HRESULT Status =
        g_Target->WriteMsr(Msr, Value);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    ULONG BytesTemp;
    HRESULT Status =
        g_Target->ReadBusData(BusDataType, BusNumber, SlotNumber,
                              Offset, Buffer, BufferSize,
                              BytesRead != NULL ? BytesRead : &BytesTemp);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    ULONG BytesTemp;
    HRESULT Status =
        g_Target->WriteBusData(BusDataType, BusNumber, SlotNumber,
                               Offset, Buffer, BufferSize,
                               BytesWritten != NULL ? BytesWritten :
                               &BytesTemp);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::CheckLowMemory(
    THIS
    )
{
    if (!IS_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    HRESULT Status =
        g_Target->CheckLowMemory();

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadDebuggerData(
    THIS_
    IN ULONG Index,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    // Wait till the machine is accessible because on dump files the
    // debugger data block requires symbols to be loaded.

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    PVOID Data;
    ULONG Size;
    ULONG64 DataSpace;

    if (Index < sizeof(KdDebuggerData))
    {
        // Even though internally all of the debugger data is
        // a single buffer that could be read arbitrarily we
        // restrict access to the defined constants to
        // preserve the abstraction that each constant refers
        // to a separate piece of data.
        if (Index & (sizeof(ULONG64) - 1))
        {
            Status = E_INVALIDARG;
            goto Exit;
        }
        
        Data = (PUCHAR)&KdDebuggerData + Index;
        Size = sizeof(ULONG64);
    }
    else
    {
        switch(Index)
        {
        case DEBUG_DATA_PaeEnabled:
            DataSpace = KdDebuggerData.PaeEnabled;
            Data = &DataSpace;
            Size = sizeof(BOOLEAN);
            break;

        case DEBUG_DATA_SharedUserData:
            DataSpace = g_TargetMachine->m_SharedUserDataOffset;
            Data = &DataSpace;
            Size = sizeof(ULONG64);
            break;

        default:
            Status = E_INVALIDARG;
            goto Exit;
        }
    }

    Status = FillDataBuffer(Data, Size, Buffer, BufferSize, DataSize);

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadProcessorSystemData(
    THIS_
    IN ULONG Processor,
    IN ULONG Index,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    )
{
    HRESULT Status = S_OK;
    PVOID Data;
    ULONG Size;
    ULONG64 DataSpace;
    DEBUG_PROCESSOR_IDENTIFICATION_ALL AllId;

    ENTER_ENGINE();

    switch(Index)
    {
    case DEBUG_DATA_KPCR_OFFSET:
    case DEBUG_DATA_KPRCB_OFFSET:
    case DEBUG_DATA_KTHREAD_OFFSET:
        if (!IS_MACHINE_SET())
        {
            Status = E_UNEXPECTED;
        }
        else
        {
            Status = g_Target->
                GetProcessorSystemDataOffset(Processor, Index, &DataSpace);
            Data = &DataSpace;
            Size = sizeof(DataSpace);
        }
        break;

    case DEBUG_DATA_BASE_TRANSLATION_VIRTUAL_OFFSET:
        if (!IS_MACHINE_SET())
        {
            Status = E_UNEXPECTED;
        }
        else
        {
            Status = g_Machine->GetBaseTranslationVirtualOffset(&DataSpace);
            Data = &DataSpace;
            Size = sizeof(DataSpace);
        }
        break;

    case DEBUG_DATA_PROCESSOR_IDENTIFICATION:
        if (!IS_TARGET_SET())
        {
            Status = E_UNEXPECTED;
        }
        else
        {
            ZeroMemory(&AllId, sizeof(AllId));
            Status = g_Target->GetProcessorId(Processor, &AllId);
            Data = &AllId;
            Size = sizeof(AllId);
        }
        break;
    
    default:
        Status = E_INVALIDARG;
        break;
    }

    if (Status == S_OK)
    {
        if (DataSize != NULL)
        {
            *DataSize = Size;
        }
            
        if (BufferSize < Size)
        {
            Status = S_FALSE;
            Size = BufferSize;
        }
            
        memcpy(Buffer, Data, Size);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::VirtualToPhysical(
    THIS_
    IN ULONG64 Virtual,
    OUT PULONG64 Physical
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG Levels;
        ULONG PfIndex;
        
        Status = g_Machine->
            GetVirtualTranslationPhysicalOffsets(Virtual, NULL, 0,
                                                 &Levels, &PfIndex, Physical);
        // GVTPO returns a special error code if the translation
        // succeeded down to the level of the actual data but
        // the data page itself is in the page file.  This is used
        // for the page file dump support.  To an external caller,
        // though, it's not useful so translate it into the standard
        // page-not-available error.
        if (Status == HR_PAGE_IN_PAGE_FILE)
        {
            Status = HR_PAGE_NOT_AVAILABLE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetVirtualTranslationPhysicalOffsets(
    THIS_
    IN ULONG64 Virtual,
    OUT OPTIONAL /* size_is(OffsetsSize) */ PULONG64 Offsets,
    IN ULONG OffsetsSize,
    OUT OPTIONAL PULONG Levels
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    ULONG _Levels = 0;
    
    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG PfIndex;
        ULONG64 LastPhys;
        
        Status = g_Machine->
            GetVirtualTranslationPhysicalOffsets(Virtual, Offsets,
                                                 OffsetsSize, &_Levels,
                                                 &PfIndex, &LastPhys);
        // GVTPO returns a special error code if the translation
        // succeeded down to the level of the actual data but
        // the data page itself is in the page file.  This is used
        // for the page file dump support.  To an external caller,
        // though, it's not useful so translate it into the standard
        // page-not-available error.
        if (Status == HR_PAGE_IN_PAGE_FILE)
        {
            Status = HR_PAGE_NOT_AVAILABLE;
        }

        // If no translations occurred return the given failure.
        // If there was a failure but translations occurred return
        // S_FALSE to indicate the translation was incomplete.
        if (_Levels > 0 && Status != S_OK)
        {
            Status = S_FALSE;
        }
    }

    if (Levels != NULL)
    {
        *Levels = _Levels;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadHandleData(
    THIS_
    IN ULONG64 Handle,
    IN ULONG DataType,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_TARGET_SET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->ReadHandleData(Handle, DataType, Buffer,
                                          BufferSize, DataSize);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::FillVirtual(
    THIS_
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT OPTIONAL PULONG Filled
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (PatternSize == 0)
    {
        Status = E_INVALIDARG;
    }
    else if (!IS_TARGET_SET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG _Filled = 0;
        
        Status = g_Target->FillVirtual(Start, Size, Pattern, PatternSize,
                                       &_Filled);
        if (Filled != NULL)
        {
            *Filled = _Filled;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::FillPhysical(
    THIS_
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT OPTIONAL PULONG Filled
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (PatternSize == 0)
    {
        Status = E_INVALIDARG;
    }
    else if (!IS_TARGET_SET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG _Filled = 0;
        
        Status = g_Target->FillPhysical(Start, Size, Pattern, PatternSize,
                                        &_Filled);
        if (Filled != NULL)
        {
            *Filled = _Filled;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::QueryVirtual(
    THIS_
    IN ULONG64 Offset,
    OUT PMEMORY_BASIC_INFORMATION64 Info
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_TARGET_SET())
    {
        Status = E_UNEXPECTED;
    }
    else if (!IS_USER_TARGET())
    {
        return E_NOTIMPL;
    }
    else
    {
        ULONG64 Handle = Offset;
        
        Status = g_Target->QueryMemoryRegion(&Handle, TRUE, Info);
    }

    LEAVE_ENGINE();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dbgkdapi.h ===
//----------------------------------------------------------------------------
//
// dbgkdapi.h
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef _DBGKDAPI_H_
#define _DBGKDAPI_H_

extern BOOL DbgKdApi64;

extern ULONG g_KdMaxPacketType;
extern ULONG g_KdMaxStateChange;
extern ULONG g_KdMaxManipulate;

NTSTATUS
DbgKdCrash(
    DWORD BugCheckCode
    );

NTSTATUS
DbgKdWaitStateChange(
    OUT PDBGKD_ANY_WAIT_STATE_CHANGE StateChange,
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    IN BOOL SuspendEngine
    );

NTSTATUS
DbgKdSetSpecialCalls (
    IN ULONG NumSpecialCalls,
    IN PULONG64 Calls
    );

NTSTATUS
DbgKdReadVirtualMemoryNow(
    IN ULONG64 TargetBaseAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesRead
    );

NTSTATUS
NTAPI
DbgKdWriteVirtualMemoryNow(
    IN ULONG64 TargetBaseAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesWritten OPTIONAL
    );

NTSTATUS
DbgKdReadVirtualTranslatedMemory(
    IN ULONG64 TargetBaseAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesRead
    );

NTSTATUS
DbgKdWriteVirtualTranslatedMemory(
    IN ULONG64 TargetBaseAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesWritten OPTIONAL
    );

NTSTATUS
NTAPI
DbgKdReadPhysicalMemory(
    IN ULONGLONG TargetBaseAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesRead OPTIONAL
    );

NTSTATUS
NTAPI
DbgKdWritePhysicalMemory(
    IN ULONGLONG TargetBaseAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesWritten OPTIONAL
    );

NTSTATUS
NTAPI
DbgKdCheckLowMemory(
    );

NTSTATUS
NTAPI
DbgKdGetVersion(
    PDBGKD_GET_VERSION64 GetVersion
    );

NTSTATUS
DbgKdReadIoSpace(
    IN ULONG64 IoAddress,
    OUT PVOID ReturnedData,
    IN ULONG DataSize
    );

NTSTATUS
DbgKdWriteIoSpace(
    IN ULONG64 IoAddress,
    IN ULONG DataValue,
    IN ULONG DataSize
    );

NTSTATUS
DbgKdReadIoSpaceExtended(
    IN ULONG64 IoAddress,
    OUT PVOID ReturnedData,
    IN ULONG DataSize,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace
    );

NTSTATUS
DbgKdWriteIoSpaceExtended(
    IN ULONG64 IoAddress,
    IN ULONG DataValue,
    IN ULONG DataSize,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace
    );

NTSTATUS
DbgKdReadControlSpace(
    IN ULONG Processor,
    IN ULONG  OffsetAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesRead
    );

NTSTATUS
DbgKdWriteControlSpace(
    IN ULONG Processor,
    IN ULONG  OffsetAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesWritten
    );


NTSTATUS
DbgKdGetBusData(
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN OUT PULONG Length
    );

NTSTATUS
DbgKdSetBusData(
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN OUT PULONG Length
    );

NTSTATUS
DbgKdSetInternalBp(
    ULONG64 Addr,
    ULONG Flags
    );

NTSTATUS
DbgKdGetInternalBp (
    ULONG64 addr,
    PULONG flags,
    PULONG calls,
    PULONG minInstr,
    PULONG maxInstr,
    PULONG totInstr,
    PULONG maxCPS
    );

NTSTATUS
DbgKdClearAllInternalBreakpoints(
    void
    );
                                 
NTSTATUS
DbgKdReadDebuggerDataHeader(
    ULONG64 Address,
    PDBGKD_DEBUG_DATA_HEADER64 Header
    );

NTSTATUS
DbgKdReadDebuggerDataBlock(
    ULONG64 Address,
    PDBGKD_DEBUG_DATA_HEADER64 DataBlock,
    ULONG SizeToRead
    );

BOOL
ChangeBaudRate(
    DWORD NewRate
    );

NTSTATUS
DbgKdSearchMemory(
    IN ULONG64 SearchAddress,
    IN ULONG64 SearchLength,
    IN PUCHAR Pattern,
    IN ULONG PatternLength,
    OUT PULONG64 FoundAddress
    );

NTSTATUS
DbgKdWriteBreakPoint(
    IN ULONG64 BreakPointAddress,
    OUT PULONG_PTR BreakPointHandle
    );

NTSTATUS
DbgKdRestoreBreakPoint(
    IN ULONG_PTR BreakPointHandle
    );

NTSTATUS
DbgKdSwitchActiveProcessor(ULONG);

NTSTATUS
DbgKdContinue (
    IN NTSTATUS ContinueStatus
    );

NTSTATUS
DbgKdContinue2 (
    IN NTSTATUS ContinueStatus,
    IN DBGKD_ANY_CONTROL_SET ControlSet
    );

NTSTATUS
DbgKdReadMsr(
    IN ULONG MsrReg,
    OUT PULONGLONG MsrValue
    );

NTSTATUS
DbgKdWriteMsr(
    IN ULONG MsrReg,
    IN ULONGLONG MsrValue
    );

NTSTATUS
DbgKdGetContext(
    IN ULONG Processor,
    IN PCROSS_PLATFORM_CONTEXT Context
    );

NTSTATUS
DbgKdSetContext(
    IN ULONG Processor,
    IN PCROSS_PLATFORM_CONTEXT Context
    );

NTSTATUS
DbgKdRestoreBreakPoint(
    IN ULONG_PTR BreakPointHandle
    );

NTSTATUS
DbgKdReboot(
    VOID
    );

NTSTATUS
DbgKdFillMemory(
    IN ULONG Flags,
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT PULONG Filled
    );

NTSTATUS
DbgKdQueryMemory(
    IN ULONG64 Address,
    IN ULONG InSpace,
    OUT PULONG OutSpace,
    OUT PULONG OutFlags
    );

#endif // #ifndef _DBGKDAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dbgkdtrans.cpp ===
//----------------------------------------------------------------------------
//
// KD hard-line communication support.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include <portio.h>

#define THROTTLE_WRITES 0
#define DBG_KD_READ 0
#define DBG_KD_WRITE 0
#define DBG_SYNCH 0

#define KD_FILE_SIGNATURE 'lFdK'

struct KD_FILE
{
    LIST_ENTRY List;
    HANDLE Handle;
    ULONG Signature;
};

struct KD_FILE_ASSOC
{
    LIST_ENTRY List;
    PWSTR From;
    PSTR To;
};

LIST_ENTRY g_KdFiles;
char g_KdFileAssocSource[MAX_PATH];
LIST_ENTRY g_KdFileAssoc;

ULONG g_LastProcessorToPrint = (ULONG) -1;
CHAR g_PrintBuf[PACKET_MAX_SIZE];

PCSTR g_DbgKdTransportNames[] =
{
    "com", "1394"
};

DbgKdTransport* g_DbgKdTransport;
DbgKdComTransport g_DbgKdComTransport;
DbgKd1394Transport g_DbgKd1394Transport;

// This log is for debugging the protocol so leave it
// a simple global for easy examination.
ULONG g_PacketLogIndex;
ULONG64 g_PacketLog[16];

#define PACKET_LOG_SIZE (sizeof(g_PacketLog) / sizeof(g_PacketLog[0]))

UCHAR DbgKdTransport::s_BreakinPacket[1] =
{
    BREAKIN_PACKET_BYTE
};

UCHAR DbgKdTransport::s_PacketTrailingByte[1] =
{
    PACKET_TRAILING_BYTE
};

UCHAR DbgKdTransport::s_PacketLeader[4] =
{
    PACKET_LEADER_BYTE,
    PACKET_LEADER_BYTE,
    PACKET_LEADER_BYTE,
    PACKET_LEADER_BYTE
};

UCHAR DbgKdTransport::s_Packet[PACKET_MAX_MANIP_SIZE];
KD_PACKET DbgKdTransport::s_PacketHeader;

UCHAR DbgKdTransport::s_SavedPacket[PACKET_MAX_MANIP_SIZE];
KD_PACKET DbgKdTransport::s_SavedPacketHeader;

#define COPYSE(p64,p32,f) p64->f = (ULONG64)(LONG64)(LONG)p32->f

__inline
void
DbgkdGetVersion32To64(
    IN PDBGKD_GET_VERSION32 vs32,
    OUT PDBGKD_GET_VERSION64 vs64,
    OUT PKDDEBUGGER_DATA64 dd64
    )
{
    vs64->MajorVersion = vs32->MajorVersion;
    vs64->MinorVersion = vs32->MinorVersion;
    vs64->ProtocolVersion = vs32->ProtocolVersion;
    vs64->Flags = vs32->Flags;
    vs64->MachineType = vs32->MachineType;
    COPYSE(vs64,vs32,PsLoadedModuleList);
    COPYSE(vs64,vs32,DebuggerDataList);
    COPYSE(vs64,vs32,KernBase);

    COPYSE(dd64,vs32,KernBase);
    COPYSE(dd64,vs32,PsLoadedModuleList);
    dd64->ThCallbackStack = vs32->ThCallbackStack;
    dd64->NextCallback = vs32->NextCallback;
    dd64->FramePointer = vs32->FramePointer;
    COPYSE(dd64,vs32,KiCallUserMode);
    COPYSE(dd64,vs32,KeUserCallbackDispatcher);
    COPYSE(dd64,vs32,BreakpointWithStatus);
}

void
OutputIo(PSTR Format, PVOID _Buffer, ULONG Request, ULONG Done)
{
    ULONG i, Chunk;
    PUCHAR Buffer = (PUCHAR)_Buffer;

    dprintf(Format, Done, Request);
    while (Done > 0)
    {
        Chunk = min(Done, 16);
        Done -= Chunk;
        dprintf("   ");
        for (i = 0; i < Chunk; i++)
        {
            dprintf(" %02X", *Buffer++);
        }
        dprintf("\n");
    }
}

KD_FILE_ASSOC*
FindKdFileAssoc(PWSTR From)
{
    PLIST_ENTRY Entry;
    KD_FILE_ASSOC* Assoc;

    for (Entry = g_KdFileAssoc.Flink;
         Entry != &g_KdFileAssoc;
         Entry = Entry->Flink)
    {
        Assoc = CONTAINING_RECORD(Entry, KD_FILE_ASSOC, List);

        if (!_wcsicmp(From, Assoc->From))
        {
            return Assoc;
        }
    }

    return NULL;
}

void
ClearKdFileAssoc(void)
{
    while (!IsListEmpty(&g_KdFileAssoc))
    {
        KD_FILE_ASSOC* Assoc;

        Assoc = CONTAINING_RECORD(g_KdFileAssoc.Flink, KD_FILE_ASSOC, List);
        RemoveEntryList(&Assoc->List);
        free(Assoc);
    }

    g_KdFileAssocSource[0] = 0;
}

HRESULT
LoadKdFileAssoc(PSTR FileName)
{
    HRESULT Status;
    FILE* File;
    char Op[32], From[MAX_PATH], To[MAX_PATH];

    File = fopen(FileName, "r");
    if (File == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    
    ClearKdFileAssoc();

    Status = S_OK;
    for (;;)
    {
        if (fgets(Op, sizeof(Op), File) == NULL)
        {
            break;
        }
        // Remove newline.
        Op[strlen(Op) - 1] = 0;

        if (_stricmp(Op, "map") != 0)
        {
            Status = E_INVALIDARG;
            break;
        }
        
        if (fgets(From, sizeof(From), File) == NULL ||
            fgets(To, sizeof(To), File) == NULL)
        {
            Status = E_INVALIDARG;
            break;
        }
        // Remove newlines.
        From[strlen(From) - 1] = 0;
        To[strlen(To) - 1] = 0;

        KD_FILE_ASSOC* Assoc;

        Assoc = (KD_FILE_ASSOC*)malloc(sizeof(KD_FILE_ASSOC) +
                                       (strlen(From) + 1) * sizeof(WCHAR) +
                                       strlen(To) + 1);
        if (Assoc == NULL)
        {
            Status = E_OUTOFMEMORY;
            break;
        }

        Assoc->From = (PWSTR)(Assoc + 1);
        if (MultiByteToWideChar(CP_ACP, 0, From, -1, Assoc->From,
                                sizeof(From) / sizeof(WCHAR)) == 0)
        {
            Status = WIN32_LAST_STATUS();
            break;
        }
        
        Assoc->To = (PSTR)(Assoc->From + strlen(From) + 1);
        strcpy(Assoc->To, To);

        InsertHeadList(&g_KdFileAssoc, &Assoc->List);
    }
    
    fclose(File);

    if (Status == S_OK)
    {
        strncat(g_KdFileAssocSource, FileName,
                sizeof(g_KdFileAssocSource) - 1);
    }
    
    return Status;
}

void
InitKdFileAssoc(void)
{
    PSTR Env;
    
    InitializeListHead(&g_KdFileAssoc);

    Env = getenv("_NT_KD_FILES");
    if (Env != NULL)
    {
        LoadKdFileAssoc(Env);
    }
}

void
ParseKdFileAssoc(void)
{
    if (PeekChar() == ';' || *g_CurCmd == 0)
    {
        if (g_KdFileAssocSource[0])
        {
            dprintf("KD file assocations loaded from '%s'\n",
                    g_KdFileAssocSource);
        }
        else
        {
            dprintf("No KD file associations set\n");
        }
        return;
    }

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        g_CurCmd++;
        switch(*g_CurCmd++)
        {
        case 'c':
            ClearKdFileAssoc();
            dprintf("KD file associations cleared\n");
            return;
        default:
            ErrOut("Unknown option '%c'\n", *(g_CurCmd - 1));
            break;
        }
    }
            
    PSTR FileName;
    CHAR Save;

    FileName = StringValue(STRV_TRIM_TRAILING_SPACE, &Save);
    if (LoadKdFileAssoc(FileName) == S_OK)
    {
        dprintf("KD file assocations loaded from '%s'\n", FileName);
    }
    else
    {
        dprintf("Unable to load KD file associations from '%s'\n", FileName);
    }
    *g_CurCmd = Save;
}

NTSTATUS
CreateKdFile(PWSTR FileName,
             ULONG DesiredAccess, ULONG FileAttributes,
             ULONG ShareAccess, ULONG CreateDisposition,
             ULONG CreateOptions,
             KD_FILE** FileEntry, PULONG64 Length)
{
    ULONG Access, Create;
    KD_FILE* File;
    KD_FILE_ASSOC* Assoc;

    Assoc = FindKdFileAssoc(FileName);
    if (Assoc == NULL)
    {
        return STATUS_NO_SUCH_FILE;
    }
    
    File = new KD_FILE;
    if (File == NULL)
    {
        return STATUS_NO_MEMORY;
    }
    
    Access = 0;
    if (DesiredAccess & FILE_GENERIC_READ)
    {
        Access |= GENERIC_READ;
    }
    if (DesiredAccess & FILE_GENERIC_WRITE)
    {
        Access |= GENERIC_WRITE;
    }

    switch(CreateDisposition)
    {
    case FILE_OPEN:
        Create = OPEN_EXISTING;
        break;
    case FILE_CREATE:
        Create = CREATE_NEW;
        break;
    case FILE_OPEN_IF:
        Create = OPEN_ALWAYS;
        break;
    case FILE_OVERWRITE_IF:
        Create = CREATE_ALWAYS;
        break;
    default:
        delete File;
        return STATUS_INVALID_PARAMETER;
    }

    // No interesting CreateOptions at this point.

    File->Handle = CreateFile(Assoc->To, Access, ShareAccess, NULL,
                              Create, FileAttributes, NULL);
    if (File->Handle == NULL || File->Handle == INVALID_HANDLE_VALUE)
    {
        delete File;
        switch(GetLastError())
        {
        case ERROR_FILE_NOT_FOUND:
            return STATUS_NO_SUCH_FILE;
        case ERROR_ACCESS_DENIED:
            return STATUS_ACCESS_DENIED;
        default:
            return STATUS_UNSUCCESSFUL;
        }
    }

    ULONG SizeLow;
    LONG SizeHigh = 0;

    SizeLow = SetFilePointer(File->Handle, 0, &SizeHigh, FILE_END);
    if (SizeLow == INVALID_SET_FILE_POINTER && GetLastError())
    {
        CloseHandle(File->Handle);
        delete File;
        return STATUS_UNSUCCESSFUL;
    }

    *Length = ((ULONG64)SizeHigh << 32) | SizeLow;

    dprintf("KD: Accessing '%s' (%ws)\n  ", Assoc->To, FileName);
    if (*Length > 0)
    {
        dprintf("File size %dK", KBYTES(*Length));
    }
    // Progress dots will be printed for each read/write.
    
    File->Signature = KD_FILE_SIGNATURE;
    InsertHeadList(&g_KdFiles, &File->List);
    *FileEntry = File;
    return STATUS_SUCCESS;
}

void
CloseKdFile(KD_FILE* File)
{
    RemoveEntryList(&File->List);
    CloseHandle(File->Handle);
    File->Signature = 0;
    delete File;
}

KD_FILE*
TranslateKdFileHandle(ULONG64 Handle)
{
    KD_FILE* File = (KD_FILE*)(ULONG_PTR)Handle;

    if (IsBadWritePtr(File, sizeof(*File)) ||
        File->Signature != KD_FILE_SIGNATURE)
    {
        return NULL;
    }

    return File;
}

//----------------------------------------------------------------------------
//
// DbgKdTransport.
//
//----------------------------------------------------------------------------

void
DbgKdTransport::Restart(void)
{
    //
    // Reinitialize per-connection values.
    //

    while (!IsListEmpty(&g_KdFiles))
    {
        CloseKdFile(CONTAINING_RECORD(g_KdFiles.Flink, KD_FILE, List));
    }
        
    m_PacketsRead = 0;
    m_BytesRead = 0;
    m_PacketsWritten = 0;
    m_BytesWritten = 0;
    
    m_PacketExpected = INITIAL_PACKET_ID;
    m_NextPacketToSend = INITIAL_PACKET_ID;
    
    m_WaitingThread = 0;
    
    m_AllowInitialBreak = TRUE;
    m_Resync = TRUE;
    m_BreakIn = FALSE;
    m_SyncBreakIn = FALSE;
    m_ValidUnaccessedPacket = FALSE;
}

void
DbgKdTransport::OutputInfo(void)
{
    char Params[2 * (MAX_PARAM_NAME + MAX_PARAM_VALUE)];
    
    g_DbgKdTransport->GetParameters(Params, sizeof(Params));
    dprintf("Transport %s\n", Params);
    dprintf("Packets read: %u, bytes read %I64u\n",
            m_PacketsRead, m_BytesRead);
    dprintf("Packets written: %u, bytes written %I64u\n",
            m_PacketsWritten, m_BytesWritten);
}

HRESULT
DbgKdTransport::Initialize(void)
{
    HRESULT Status;

    //
    // Create the events used by the overlapped structures for the
    // read and write.
    //

    if ((Status = CreateOverlappedPair(&m_ReadOverlapped,
                                       &m_WriteOverlapped)) != S_OK)
    {
        ErrOut("Unable to create overlapped info, 0x%X\n", Status);
    }

    InitializeListHead(&g_KdFiles);
    
    return Status;
}

void
DbgKdTransport::Uninitialize(void)
{
    if (m_ReadOverlapped.hEvent != NULL)
    {
        CloseHandle(m_ReadOverlapped.hEvent);
        m_ReadOverlapped.hEvent = NULL;
    }
    if (m_WriteOverlapped.hEvent != NULL)
    {
        CloseHandle(m_WriteOverlapped.hEvent);
        m_WriteOverlapped.hEvent = NULL;
    }
}

void
DbgKdTransport::CycleSpeed(void)
{
    WarnOut("KD transport cannot change speeds\n");
}

HRESULT
DbgKdTransport::ReadTargetPhysicalMemory(
    IN ULONG64 MemoryOffset,
    IN PVOID Buffer,
    IN ULONG SizeofBuffer,
    IN PULONG BytesRead
    )
{
    WarnOut("Not valid KD transport operation\n");
    return E_UNEXPECTED;
}

ULONG
DbgKdTransport::HandleDebugIo(PDBGKD_DEBUG_IO Packet)
{
    ULONG ReadStatus = DBGKD_WAIT_AGAIN;

    switch(Packet->ApiNumber)
    {
    case DbgKdPrintStringApi:
        DbgKdpPrint(Packet->Processor,
                    (PSTR)(Packet + 1),
                    (SHORT)Packet->u.PrintString.LengthOfString,
                    DEBUG_OUTPUT_DEBUGGEE);
        break;
    case DbgKdGetStringApi:
        DbgKdpHandlePromptString(Packet);
        break;
    default:
        KdOut("READ: Received INVALID DEBUG_IO packet type %x.\n",
              Packet->ApiNumber);
        ReadStatus = DBGKD_WAIT_RESEND;
        break;
    }

    return ReadStatus;
}

ULONG
DbgKdTransport::HandleTraceIo(PDBGKD_TRACE_IO Packet)
{
    ULONG ReadStatus = DBGKD_WAIT_AGAIN;
            
    switch(Packet->ApiNumber)
    {
    case DbgKdPrintTraceApi:
        DbgKdpPrintTrace(Packet->Processor,
                         (PUCHAR)(Packet + 1),
                         (USHORT)Packet->u.PrintTrace.LengthOfData,
                         DEBUG_OUTPUT_DEBUGGEE);
        break;
    default:
        KdOut("READ: Received INVALID TRACE_IO packet type %x.\n",
              Packet->ApiNumber);
        ReadStatus = DBGKD_WAIT_RESEND;
        break;
    }

    return ReadStatus;
}

ULONG
DbgKdTransport::HandleControlRequest(PDBGKD_CONTROL_REQUEST Packet)
{
    ULONG ReadStatus = DBGKD_WAIT_AGAIN;
            
    switch(Packet->ApiNumber)
    {
    case DbgKdRequestHardwareBp:
        DbgKdpAcquireHardwareBp(Packet);
        break;
    case DbgKdReleaseHardwareBp:
        DbgKdpReleaseHardwareBp(Packet);
        break;
    default:
        KdOut("READ: Received INVALID CONTROL_REQUEST packet type %x.\n",
              Packet->ApiNumber);
        ReadStatus = DBGKD_WAIT_RESEND;
        break;
    }

    return ReadStatus;
}

ULONG
DbgKdTransport::HandleFileIo(PDBGKD_FILE_IO Packet)
{
    KD_FILE* File;
    PVOID ExtraData = NULL;
    USHORT ExtraDataLength = 0;
    LARGE_INTEGER FilePtr;

    // Reenter the engine lock to protect the file list.
    RESUME_ENGINE();
    
    switch(Packet->ApiNumber)
    {
    case DbgKdCreateFileApi:
        Packet->Status = CreateKdFile((PWSTR)(Packet + 1),
                                      Packet->u.CreateFile.DesiredAccess,
                                      Packet->u.CreateFile.FileAttributes,
                                      Packet->u.CreateFile.ShareAccess,
                                      Packet->u.CreateFile.CreateDisposition,
                                      Packet->u.CreateFile.CreateOptions,
                                      &File,
                                      &Packet->u.CreateFile.Length);
        Packet->u.CreateFile.Handle = (ULONG_PTR)File;
        KdOut("KdFile request for '%ws' returns %08X\n",
              (PWSTR)(Packet + 1), Packet->Status);
        break;
    case DbgKdReadFileApi:
        File = TranslateKdFileHandle(Packet->u.ReadFile.Handle);
        if (File == NULL ||
            Packet->u.ReadFile.Length > PACKET_MAX_SIZE - sizeof(*Packet))
        {
            Packet->Status = STATUS_INVALID_PARAMETER;
            break;
        }
        FilePtr.QuadPart = Packet->u.ReadFile.Offset;
        if (SetFilePointer(File->Handle, FilePtr.LowPart, &FilePtr.HighPart,
                           FILE_BEGIN) == INVALID_SET_FILE_POINTER &&
            GetLastError())
        {
            Packet->Status = STATUS_END_OF_FILE;
            break;
        }
        if (!ReadFile(File->Handle, Packet + 1, Packet->u.ReadFile.Length,
                      &Packet->u.ReadFile.Length, NULL))
        {
            Packet->Status = STATUS_UNSUCCESSFUL;
        }
        else
        {
            dprintf(".");
            Packet->Status = STATUS_SUCCESS;
            ExtraData = Packet + 1;
            ExtraDataLength = (USHORT)Packet->u.ReadFile.Length;
        }
        break;
    case DbgKdWriteFileApi:
        File = TranslateKdFileHandle(Packet->u.WriteFile.Handle);
        if (File == NULL ||
            Packet->u.WriteFile.Length > PACKET_MAX_SIZE - sizeof(*Packet))
        {
            Packet->Status = STATUS_INVALID_PARAMETER;
            break;
        }
        FilePtr.QuadPart = Packet->u.WriteFile.Offset;
        if (SetFilePointer(File->Handle, FilePtr.LowPart, &FilePtr.HighPart,
                           FILE_BEGIN) == INVALID_SET_FILE_POINTER &&
            GetLastError())
        {
            Packet->Status = STATUS_END_OF_FILE;
            break;
        }
        if (!WriteFile(File->Handle, Packet + 1, Packet->u.WriteFile.Length,
                      &Packet->u.WriteFile.Length, NULL))
        {
            Packet->Status = STATUS_UNSUCCESSFUL;
        }
        else
        {
            dprintf(".");
            Packet->Status = STATUS_SUCCESS;
        }
        break;
    case DbgKdCloseFileApi:
        File = TranslateKdFileHandle(Packet->u.CloseFile.Handle);
        if (File != NULL)
        {
            // Finish line of progress dots.
            dprintf("\n");
            CloseKdFile(File);
            Packet->Status = STATUS_SUCCESS;
        }
        else
        {
            Packet->Status = STATUS_INVALID_PARAMETER;
        }
        break;
    default:
        KdOut("READ: Received INVALID FILE_IO packet type %x.\n",
              Packet->ApiNumber);
        SUSPEND_ENGINE();
        return DBGKD_WAIT_RESEND;
    }

    //
    // Send response data.
    //

    g_DbgKdTransport->WritePacket(Packet, sizeof(*Packet),
                                  PACKET_TYPE_KD_FILE_IO,
                                  ExtraData, ExtraDataLength);

    SUSPEND_ENGINE();
    return DBGKD_WAIT_AGAIN;
}

ULONG
DbgKdTransport::WaitForPacket(
    IN USHORT PacketType,
    OUT PVOID Packet
    )
{
    ULONG InvPacketRetry = 0;

    // Packets can only be read when the kernel transport
    // is not in use.
    if (m_WaitingThread != 0 &&
        m_WaitingThread != GetCurrentThreadId())
    {
        ErrOut("Kernel transport in use, packet read failed\n");
        return DBGKD_WAIT_FAILED;
    }
    
    if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
    {
        KdOut("READ: Wait for ACK packet with id = %lx\n",
              m_NextPacketToSend);
    }
    else
    {
        KdOut("READ: Wait for type %x packet exp id = %lx\n",
              PacketType, m_PacketExpected);
    }

    g_PacketLog[g_PacketLogIndex++ & (PACKET_LOG_SIZE - 1)] =
        ((ULONG64)PacketType << 32);

    if (PacketType != PACKET_TYPE_KD_ACKNOWLEDGE)
    {
        if (m_ValidUnaccessedPacket)
        {
            KdOut("READ: Grab packet from buffer.\n");
            goto ReadBuffered;
        }
    }

 ReadContents:
    
    for (;;)
    {
        ULONG ReadStatus = ReadPacketContents(PacketType);

        //
        // If we read an internal packet such as IO or Resend, then
        // handle it and continue waiting.
        //
        if (ReadStatus == DBGKD_WAIT_PACKET)
        {
            m_PacketsRead++;

            switch(s_PacketHeader.PacketType)
            {
            case PACKET_TYPE_KD_DEBUG_IO:
                ReadStatus = HandleDebugIo((PDBGKD_DEBUG_IO)s_Packet);
                break;
            case PACKET_TYPE_KD_TRACE_IO:
                ReadStatus = HandleTraceIo((PDBGKD_TRACE_IO)s_Packet);
                break;
            case PACKET_TYPE_KD_CONTROL_REQUEST:
                ReadStatus =
                    HandleControlRequest((PDBGKD_CONTROL_REQUEST)s_Packet);
                break;
            case PACKET_TYPE_KD_FILE_IO:
                ReadStatus = HandleFileIo((PDBGKD_FILE_IO)s_Packet);
                break;
            }
        }
        else if (ReadStatus == DBGKD_WAIT_ACK)
        {
            m_PacketsRead++;
            
            // If we're waiting for an ack we're done,
            // otherwise the communication is confused
            // so ask for a resend.
            if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
            {
                return DBGKD_WAIT_ACK;
            }
            else
            {
                KdOut("READ: Received ACK while waiting for type %d\n",
                      PacketType);
                ReadStatus = DBGKD_WAIT_RESEND;
            }
        }
        
        if (ReadStatus == DBGKD_WAIT_PACKET)
        {
            // If we're waiting for an ack and received
            // a normal packet leave it in the buffer
            // and record the fact that we have one
            // stored.  Consider it an ack and return.
            if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
            {
                m_ValidUnaccessedPacket = TRUE;

                KdOut("READ: Packet Read ahead.\n");
                FlushCallbacks();

                return DBGKD_WAIT_ACK;
            }

            // We're waiting for a data packet and we
            // just got one so process it.
            break;
        }
        else if (ReadStatus == DBGKD_WAIT_RESEND)
        {
            // If the other end didn't wait for an
            // ack then we can't ask for a resend.
            if (!m_AckWrites)
            {
                return DBGKD_WAIT_FAILED;
            }
            
            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
            {
                return DBGKD_WAIT_ACK;
            }

            KdOut("READ: Ask for resend.\n");
        }
        else if (ReadStatus == DBGKD_WAIT_AGAIN)
        {
            // Internal packets count as acknowledgements,
            // so if we processed one while waiting for an
            // ack consider things done.
            if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
            {
                return DBGKD_WAIT_ACK;
            }
        }
        else
        {
            return ReadStatus;
        }
    }
    
 ReadBuffered:
    
    //
    // Check PacketType is what we are waiting for.
    //

    if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64)
    {
        if (s_PacketHeader.PacketType == PACKET_TYPE_KD_STATE_CHANGE64)
        {
            DbgKdApi64 = TRUE;
        }
        else if (s_PacketHeader.PacketType == PACKET_TYPE_KD_STATE_CHANGE32)
        {
            PacketType = PACKET_TYPE_KD_STATE_CHANGE32;
            DbgKdApi64 = FALSE;
        }

        KdOut("READ: Packet type = %x, DbgKdApi64 = %x\n",
              s_PacketHeader.PacketType, DbgKdApi64);
    }

    if (PacketType != s_PacketHeader.PacketType)
    {
        KdOut("READ: Unexpected Packet type %x (Acked). "
              "Expecting Packet type %x\n",
              s_PacketHeader.PacketType, PacketType);

        if (m_InvPacketRetryLimit > 0 &&
            ++InvPacketRetry >= m_InvPacketRetryLimit)
        {
            return DBGKD_WAIT_FAILED;
        }
        
        goto ReadContents;
    }

    if (!DbgKdApi64 && PacketType == PACKET_TYPE_KD_STATE_MANIPULATE)
    {
        DBGKD_MANIPULATE_STATE64 Packet64;
        DWORD AdditionalDataSize;
        
        DbgkdManipulateState32To64((PDBGKD_MANIPULATE_STATE32)&s_Packet,
                                   &Packet64, &AdditionalDataSize);
        if (Packet64.ApiNumber == DbgKdGetVersionApi)
        {
            DbgkdGetVersion32To64(&((PDBGKD_MANIPULATE_STATE32)&s_Packet)->
                                  u.GetVersion32,
                                  &Packet64.u.GetVersion64,
                                  &KdDebuggerData);
        }
        else if (AdditionalDataSize)
        {
            //
            // Move the trailing data to make room for the larger packet header
            //
            MoveMemory(s_Packet + sizeof(DBGKD_MANIPULATE_STATE64),
                       s_Packet + sizeof(DBGKD_MANIPULATE_STATE32),
                       AdditionalDataSize);
        }
        *(PDBGKD_MANIPULATE_STATE64)s_Packet = Packet64;
    }
    
    *(PVOID *)Packet = &s_Packet;
    m_ValidUnaccessedPacket = FALSE;
    return DBGKD_WAIT_PACKET;
}

VOID
DbgKdTransport::WriteBreakInPacket(VOID)
{
    DWORD BytesWritten;
    BOOL rc;

    KdOut("Send Break in ...\n");
    FlushCallbacks();

    do
    {
        rc = Write(&s_BreakinPacket[0], sizeof(s_BreakinPacket),
                   &BytesWritten);
    } while ((!rc) || (BytesWritten != sizeof(s_BreakinPacket)));
    
    m_BreakIn = FALSE;
    m_PacketsWritten++;
}

VOID
DbgKdTransport::WriteControlPacket(
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    )

/*++

Routine Description:

    This function writes a control packet to target machine.

    N.B. a CONTROL Packet header is sent with the following information:
         PacketLeader - indicates it's a control packet
         PacketType - indicates the type of the control packet
         ByteCount - aways zero to indicate no data following the header
         PacketId - Valid ONLY for PACKET_TYPE_KD_ACKNOWLEDGE to indicate
                    which packet is acknowledged.

Arguments:

    PacketType - Supplies the type of the control packet.

    PacketId - Supplies the PacketId.  Used by Acknowledge packet only.

Return Value:

    None.

--*/
{
    DWORD BytesWritten;
    BOOL rc;
    KD_PACKET Packet;

    DBG_ASSERT( (g_KdMaxPacketType == 0 && PacketType < PACKET_TYPE_MAX) ||
                (g_KdMaxPacketType > 0 && PacketType < g_KdMaxPacketType) );

    Packet.PacketLeader = CONTROL_PACKET_LEADER;
    Packet.ByteCount = 0;
    Packet.PacketType = PacketType;
    if ( PacketId )
    {
        Packet.PacketId = PacketId;
    }
    else
    {
        Packet.PacketId = 0;
    }
    Packet.Checksum = 0;

    do
    {
        //
        // Write the control packet header
        //

        rc = Write(&Packet, sizeof(Packet), &BytesWritten);
    } while ( (!rc) || BytesWritten != sizeof(Packet) );

    m_PacketsWritten++;
}

VOID
DbgKdTransport::WriteDataPacket(
    IN PVOID PacketData,
    IN USHORT PacketDataLength,
    IN USHORT PacketType,
    IN PVOID MorePacketData OPTIONAL,
    IN USHORT MorePacketDataLength OPTIONAL,
    IN BOOL NoAck
    )
{
    KD_PACKET Packet;
    USHORT TotalBytesToWrite;
    DBGKD_MANIPULATE_STATE32 m32;
    PVOID ConvertedPacketData = NULL;

    DBG_ASSERT( (g_KdMaxPacketType == 0 && PacketType < PACKET_TYPE_MAX) ||
                (g_KdMaxPacketType > 0 && PacketType < g_KdMaxPacketType) );

    // Packets can only be written when the kernel transport
    // is not in use.
    if (m_WaitingThread != 0 &&
        m_WaitingThread != GetCurrentThreadId())
    {
        ErrOut("Kernel transport in use, packet write failed\n");
        return;
    }
    
    KdOut("WRITE: Write type %x packet id= %lx.\n",
          PacketType, m_NextPacketToSend);

    if (!DbgKdApi64 && PacketType == PACKET_TYPE_KD_STATE_MANIPULATE)
    {
        PacketDataLength = (USHORT)
            DbgkdManipulateState64To32((PDBGKD_MANIPULATE_STATE64)PacketData,
                                       &m32);
        PacketData = (PVOID)&m32;
        if (m32.ApiNumber == DbgKdWriteBreakPointExApi)
        {
            ConvertedPacketData = malloc(MorePacketDataLength / 2);
            if (!ConvertedPacketData)
            {
                ErrOut("Failed to allocate Packet Data\n");
                return;
            }
            ConvertQwordsToDwords((PULONG64)PacketData,
                                  (PULONG)ConvertedPacketData,
                                  MorePacketDataLength / 8);
            MorePacketData = ConvertedPacketData;
            MorePacketDataLength /= 2;
        }
    }

    if ( ARGUMENT_PRESENT(MorePacketData) )
    {
        TotalBytesToWrite = PacketDataLength + MorePacketDataLength;
        Packet.Checksum = ComputeChecksum((PUCHAR)MorePacketData,
                                          MorePacketDataLength);
    }
    else
    {
        TotalBytesToWrite = PacketDataLength;
        Packet.Checksum = 0;
    }
    Packet.Checksum += ComputeChecksum((PUCHAR)PacketData,
                                       PacketDataLength);
    Packet.PacketLeader = PACKET_LEADER;
    Packet.ByteCount = TotalBytesToWrite;
    Packet.PacketType = PacketType;

    g_PacketLog[g_PacketLogIndex++ & (PACKET_LOG_SIZE - 1)] =
        ((ULONG64)0xF << 60) | ((ULONG64)PacketType << 32) | TotalBytesToWrite;

    for (;;)
    {
        Packet.PacketId = m_NextPacketToSend;

        if (WritePacketContents(&Packet, PacketData, PacketDataLength,
                                MorePacketData, MorePacketDataLength,
                                NoAck) == DBGKD_WRITE_PACKET)
        {
            m_PacketsWritten++;
            break;
        }
    }

    if (ConvertedPacketData)
    {
        free(ConvertedPacketData);
    }
}

ULONG
DbgKdTransport::ComputeChecksum(
    IN PUCHAR Buffer,
    IN ULONG Length
    )
{
    ULONG Checksum = 0;

    while (Length > 0)
    {
        Checksum = Checksum + (ULONG)*Buffer++;
        Length--;
    }
    
    return Checksum;
}

//----------------------------------------------------------------------------
//
// DbgKdComTransport.
//
//----------------------------------------------------------------------------

// Environment variable names.
#define COM_PORT_NAME   "_NT_DEBUG_PORT"
#define COM_PORT_BAUD   "_NT_DEBUG_BAUD_RATE"

// Parameter string names.
#define PARAM_COM_PORT    "Port"
#define PARAM_COM_BAUD    "Baud"
#define PARAM_COM_MODEM   "Modem"
#define PARAM_COM_TIMEOUT "Timeout"

DbgKdComTransport::DbgKdComTransport(void)
{
    m_Index = DBGKD_TRANSPORT_COM;
    m_Name = g_DbgKdTransportNames[m_Index];
    m_InvPacketRetryLimit = 0;
    m_AckWrites = TRUE;
}

ULONG
DbgKdComTransport::GetNumberParameters(void)
{
    return 4;
}

void
DbgKdComTransport::GetParameter(ULONG Index, PSTR Name, PSTR Value)
{
    switch(Index)
    {
    case 0:
        strcpy(Name, PARAM_COM_PORT);
        strcpy(Value, m_PortName);
        break;
    case 1:
        strcpy(Name, PARAM_COM_BAUD);
        sprintf(Value, "%d", m_BaudRate);
        break;
    case 2:
        if (m_Modem)
        {
            strcpy(Name, PARAM_COM_MODEM);
        }
        break;
    case 3:
        strcpy(Name, PARAM_COM_TIMEOUT);
        sprintf(Value, "%d", m_Timeout);
        break;
    }
}

void
DbgKdComTransport::ResetParameters(void)
{
    PSTR Env;
    
    if ((Env = getenv(COM_PORT_NAME)) == NULL)
    {
        Env = "com1";
    }
    SetComPortName(Env, m_PortName);
    
    if ((Env = getenv(COM_PORT_BAUD)) != NULL)
    {
        m_BaudRate = atol(Env);
    }
    else
    {
        m_BaudRate = 19200;
    }

    m_Modem = FALSE;
    m_Timeout = 4000;
}

BOOL
DbgKdComTransport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_strcmpi(Name, PARAM_COM_PORT))
    {
        SetComPortName(Value, m_PortName);
    }
    else if (!_strcmpi(Name, PARAM_COM_BAUD))
    {
        m_BaudRate = atol(Value);
    }
    else if (!_strcmpi(Name, PARAM_COM_MODEM))
    {
        m_Modem = TRUE;
    }
    else if (!_strcmpi(Name, PARAM_COM_TIMEOUT))
    {
        m_Timeout = atol(Value);
    }
    else
    {
        ErrOut("COM port parameters: %s is not a valid parameter\n", Name);

        return FALSE;
    }
    
    return TRUE;
}

HRESULT
DbgKdComTransport::Initialize(void)
{
    HRESULT Status;

    if ((Status = DbgKdTransport::Initialize()) != S_OK)
    {
        return Status;
    }

    m_DirectPhysicalMemory = FALSE;

    if ((Status = OpenComPort(m_PortName, m_BaudRate, m_Timeout,
                              &m_Handle, &m_BaudRate)) != S_OK)
    {
        ErrOut("Failed to open %s\n", m_PortName);
        return Status;
    }

    dprintf("Opened %s\n", m_PortName);

    m_ComEvent = 0;
    if (m_Modem)
    {
        DWORD Mask;

        //
        //  Debugger is being run over a modem.  Set event to watch
        //  carrier detect.
        //

        GetCommMask (m_Handle, &Mask);
        // set DDCD event
        if (!SetCommMask (m_Handle, Mask | 0xA0))
        {
            ErrOut("Failed to set event for %s.\n", m_PortName);
            return WIN32_LAST_STATUS();
        }

        m_EventOverlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!m_EventOverlapped.hEvent)
        {
            ErrOut("Failed to create EventOverlapped\n");
            return WIN32_LAST_STATUS();
        }

        m_EventOverlapped.Offset = 0;
        m_EventOverlapped.OffsetHigh = 0;

        // Fake an event, so modem status will be checked
        m_ComEvent = 1;
    }

    return S_OK;
}

void
DbgKdComTransport::Uninitialize(void)
{
    if (m_Handle != NULL)
    {
        CloseHandle(m_Handle);
        m_Handle = NULL;
    }
    if (m_EventOverlapped.hEvent != NULL)
    {
        CloseHandle(m_EventOverlapped.hEvent);
        m_EventOverlapped.hEvent = NULL;
    }

    DbgKdTransport::Uninitialize();
}

BOOL
DbgKdComTransport::Read(
    IN PVOID    Buffer,
    IN ULONG    SizeOfBuffer,
    IN PULONG   BytesRead
    )
{
    if (IS_DUMP_TARGET())
    {
        ErrOut( "Attempted to read KD transport while "
                "debugging a crash dump\n" );
        DebugBreak();
    }

    if (m_ComEvent)
    {
        CheckComStatus ();
    }

    if (ComPortRead(m_Handle, Buffer, SizeOfBuffer, BytesRead,
                    &m_ReadOverlapped))
    {
#if DBG_KD_READ
        OutputIo("CR: Read %d bytes of %d\n",
                 Buffer, SizeOfBuffer, *BytesRead);
#endif

        m_BytesRead += *BytesRead;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL
DbgKdComTransport::Write(
    IN PVOID    Buffer,
    IN ULONG    SizeOfBuffer,
    IN PULONG   BytesWritten
    )
{
    if (IS_DUMP_TARGET())
    {
        ErrOut( "Attempted to write KD transport "
                "while debugging a crash dump\n" );
        DebugBreak();
    }

    if (m_ComEvent)
    {
        CheckComStatus ();
    }

    //
    // Break up large writes in smaller chunks
    // to try and avoid sending too much data
    // to the target all at once.  Sleep a bit
    // between chunks to let the target retrieve
    // data.
    //
    
    BOOL Succ = TRUE;
    *BytesWritten = 0;
    while (SizeOfBuffer > 0)
    {
        ULONG Request, Done;

        // By default we want to encourage vendors
        // to create machines with robust serial
        // support so we don't actually limit
        // the write size.
#if THROTTLE_WRITES
        Request = 96;
#else
        Request = 0xffffffff;
#endif
        if (SizeOfBuffer < Request)
        {
            Request = SizeOfBuffer;
        }
        
        if (!ComPortWrite(m_Handle, Buffer, Request, &Done,
                          &m_WriteOverlapped))
        {
            Succ = FALSE;
            break;
        }
        
#if DBG_KD_WRITE
        OutputIo("CW: Write %d bytes of %d\n",
                 Buffer, Request, Done);
#endif

        *BytesWritten += Done;
        if (Done <= Request)
        {
            break;
        }

        Buffer = (PVOID)((PUCHAR)Buffer + Done);
        SizeOfBuffer -= Done;

        Sleep(10);
    }
    
    m_BytesWritten += *BytesWritten;
    return Succ;
}

void
DbgKdComTransport::CycleSpeed(void)
{
    if (SetComPortBaud(m_Handle, 0, &m_BaudRate) != S_OK)
    {
        ErrOut("New Baud rate Could not be set on Com %I64x - remains %d.\n",
               (ULONG64)m_Handle, m_BaudRate);
    }
    else
    {
        dprintf("Baud rate set to %d\n", m_BaudRate);
    }
}

VOID
DbgKdComTransport::Synchronize(VOID)
{
    USHORT Index;
    UCHAR DataByte, PreviousDataByte;
    USHORT PacketType = 0;
    ULONG TimeoutCount = 0;
    COMMTIMEOUTS CommTimeouts;
    COMMTIMEOUTS OldTimeouts;
    DWORD BytesRead;
    BOOL rc;

    //
    // Get the old time out values and hold them.
    // We then set a new total timeout value of
    // a fraction of the base timeout.
    //

    GetCommTimeouts(g_DbgKdTransport->m_Handle, &OldTimeouts);

    CommTimeouts = OldTimeouts;
    CommTimeouts.ReadIntervalTimeout = 0;
    CommTimeouts.ReadTotalTimeoutMultiplier = 0;
    CommTimeouts.ReadTotalTimeoutConstant = m_Timeout / 8;

#define TIMEOUT_ITERATIONS 6
    
    SetCommTimeouts(g_DbgKdTransport->m_Handle, &CommTimeouts);

    FlushCallbacks();
    
    while (TRUE)
    {
        
Timeout:
        WriteControlPacket(PACKET_TYPE_KD_RESET, 0L);

        //
        // Read packet leader
        //

        BOOL First = TRUE;
        
        Index = 0;
        do
        {
            if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
            {
                KdOut("Synchronize interrupted by exit request\n");
                goto Exit;
            }
            
            //
            // Check user input for control_c.  If user types control_c,
            // we will send a breakin packet to the target.  Hopefully,
            // target will send us a StateChange packet and
            //

            //
            // if we don't get response from kernel in 3 seconds we
            // will resend the reset packet if user does not type ctrl_c.
            // Otherwise, we send breakin character and wait for data again.
            //

            rc = g_DbgKdTransport->Read(&DataByte, 1, &BytesRead);
            if ((!rc) || (BytesRead != 1))
            {
                if (m_BreakIn || m_SyncBreakIn)
                {
                    m_SyncBreakIn = FALSE;
                    WriteBreakInPacket();
                    TimeoutCount = 0;
                    continue;
                }
                TimeoutCount++;
                
                //
                // if we have been waiting for 3 seconds, resend RESYNC packet
                //

                if (TimeoutCount < TIMEOUT_ITERATIONS)
                {
                    continue;
                }
                TimeoutCount = 0;

                KdOut("SYNCTARGET: Timeout.\n");
                FlushCallbacks();

                goto Timeout;
            }

#if DBG_SYNCH
            if (rc && BytesRead == 1 && First)
            {
                dprintf("First byte %X\n", DataByte);
                First = FALSE;
            }
#endif
            
            if (rc && BytesRead == 1 &&
                ( DataByte == PACKET_LEADER_BYTE ||
                  DataByte == CONTROL_PACKET_LEADER_BYTE)
                )
            {
                if ( Index == 0 )
                {
                    PreviousDataByte = DataByte;
                    Index++;
                }
                else if ( DataByte == PreviousDataByte )
                {
                    Index++;
                }
                else
                {
                    PreviousDataByte = DataByte;
                    Index = 1;
                }
            }
            else
            {
                Index = 0;
                
                if (rc && BytesRead == 1)
                {
                    // The target machine is alive and talking but
                    // the received data is in the middle of
                    // a packet.  Break out of the header byte
                    // loop and consume up to a trailer byte.
                    break;
                }
            }
        }
        while ( Index < 4 );

        if (Index == 4 && DataByte == CONTROL_PACKET_LEADER_BYTE)
        {
            //
            // Read 2 byte Packet type
            //

            rc = g_DbgKdTransport->Read((PUCHAR)&PacketType,
                                        sizeof(PacketType), &BytesRead);

            if (rc && BytesRead == sizeof(PacketType) &&
                PacketType == PACKET_TYPE_KD_RESET)
            {
                KdOut("SYNCTARGET: Received KD_RESET ACK packet.\n");

                m_PacketExpected = INITIAL_PACKET_ID;
                m_NextPacketToSend = INITIAL_PACKET_ID;

                KdOut("SYNCTARGET: Target synchronized successfully...\n");
                FlushCallbacks();

                goto Exit;
            }
        }

        //
        // If we receive Data Packet leader, it means target has not
        // receive our reset packet. So we loop back and send it again.
        // N.B. We need to wait until target finishes sending the packet.
        // Otherwise, we may be sending the reset packet while the target
        // is sending the packet. This might cause target loss the reset
        // packet.
        //

        Index = 0;
        while (DataByte != PACKET_TRAILING_BYTE)
        {
            rc = g_DbgKdTransport->Read(&DataByte, 1, &BytesRead);
            if (!rc || BytesRead != 1)
            {
                break;
            }

            Index++;
        }

#if DBG_SYNCH
        dprintf("  ate %x bytes\n", Index);
        FlushCallbacks();
#endif
    }
    
 Exit:
    SetCommTimeouts(g_DbgKdTransport->m_Handle, &OldTimeouts);
}

ULONG
DbgKdComTransport::ReadPacketContents(IN USHORT PacketType)
{
    DWORD BytesRead;
    BOOL rc;
    UCHAR DataByte;
    ULONG Checksum;
    ULONG SyncBit;
    ULONG WaitStatus;

    //
    // First read a packet leader
    //

WaitForPacketLeader:

    WaitStatus = ReadPacketLeader(PacketType, &s_PacketHeader.PacketLeader);
    if (WaitStatus != DBGKD_WAIT_PACKET)
    {
        return WaitStatus;
    }
    if (m_AllowInitialBreak && (g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK))
    {
        KdOut("Attempting to get initial breakpoint.\n");
        WriteBreakInPacket();
    }

    // We've either sent the initial break or we don't want
    // one.  Either way we don't need to send another one.
    m_AllowInitialBreak = FALSE;

    //
    // Read packetLeader ONLY read two Packet Leader bytes.  This do loop
    // filters out the remaining leader byte.
    //

    do
    {
        rc = Read(&DataByte, 1, &BytesRead);
        if ((rc) && BytesRead == 1)
        {
            if (DataByte == PACKET_LEADER_BYTE ||
                DataByte == CONTROL_PACKET_LEADER_BYTE)
            {
                continue;
            }
            else
            {
                *(PUCHAR)&s_PacketHeader.PacketType = DataByte;
                break;
            }
        }
        else
        {
            goto WaitForPacketLeader;
        }
    } while (TRUE);

    //
    // Now we have valid packet leader. Read rest of the packet type.
    //

    rc = Read(((PUCHAR)&s_PacketHeader.PacketType) + 1,
              sizeof(s_PacketHeader.PacketType) - 1, &BytesRead);
    if ((!rc) || BytesRead != sizeof(s_PacketHeader.PacketType) - 1)
    {
        //
        // If we cannot read the packet type and if the packet leader
        // indicates this is a data packet, we need to ask for resend.
        // Otherwise we simply ignore the incomplete packet.
        //

        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdOut("READ: Data packet header Type error (short read).\n");
        }
        
        goto WaitForPacketLeader;
    }

    //
    // Check the Packet type.
    //

    if ((g_KdMaxPacketType == 0 &&
         s_PacketHeader.PacketType >= PACKET_TYPE_MAX) ||
        (g_KdMaxPacketType > 0 &&
         s_PacketHeader.PacketType >= g_KdMaxPacketType))
    {
        KdOut("READ: Received INVALID packet type.\n");

        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
        }

        goto WaitForPacketLeader;
    }

    KdOut("      PacketType=%x, ", s_PacketHeader.PacketType);

    //
    // Read ByteCount
    //

    rc = Read(&s_PacketHeader.ByteCount, sizeof(s_PacketHeader.ByteCount),
              &BytesRead);
    if ((!rc) || BytesRead != sizeof(s_PacketHeader.ByteCount))
    {
        //
        // If we cannot read the packet type and if the packet leader
        // indicates this is a data packet, we need to ask for resend.
        // Otherwise we simply ignore the incomplete packet.
        //

        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdOut("READ: Data packet header ByteCount error (short read).\n");
        }
        
        goto WaitForPacketLeader;
    }

    //
    // Check ByteCount
    //

    if (s_PacketHeader.ByteCount > PACKET_MAX_SIZE)
    {
        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdOut("READ: Data packet header ByteCount error (short read).\n");
        }
        
        goto WaitForPacketLeader;
    }

    KdOut("ByteCount=%x, ", s_PacketHeader.ByteCount);

    //
    // Read Packet Id
    //

    rc = Read(&s_PacketHeader.PacketId, sizeof(s_PacketHeader.PacketId),
              &BytesRead);
    if ((!rc) || BytesRead != sizeof(s_PacketHeader.PacketId))
    {
        //
        // If we cannot read the packet Id and if the packet leader
        // indicates this is a data packet, we need to ask for resend.
        // Otherwise we simply ignore the incomplete packet.
        //

        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdOut("READ: Data packet header Id error (short read).\n");
        }
        
        goto WaitForPacketLeader;
    }

    KdOut("PacketId=%x,\n", s_PacketHeader.PacketId);

    //
    // Don't read checksum here as in some cases
    // it isn't sent with control packets.
    //

    if (s_PacketHeader.PacketLeader == CONTROL_PACKET_LEADER )
    {
        if (s_PacketHeader.PacketType == PACKET_TYPE_KD_ACKNOWLEDGE )
        {
            //
            // If we received an expected ACK packet and we are not
            // waiting for any new packet, update outgoing packet id
            // and return.  If we are NOT waiting for ACK packet
            // we will keep on waiting.  If the ACK packet
            // is not for the packet we send, ignore it and keep on waiting.
            //

            if (s_PacketHeader.PacketId != m_NextPacketToSend)
            {
                KdOut("READ: Received unmatched packet id = %lx, Type = %x\n",
                      s_PacketHeader.PacketId, s_PacketHeader.PacketType);
                goto WaitForPacketLeader;
            }
            else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
            {
                m_NextPacketToSend ^= 1;

                KdOut("READ: Received correct ACK packet.\n");
                FlushCallbacks();

                return DBGKD_WAIT_ACK;
            }
            else
            {
                goto WaitForPacketLeader;
            }
        }
        else if (s_PacketHeader.PacketType == PACKET_TYPE_KD_RESET)
        {
            //
            // if we received Reset packet, reset the packet control variables
            // and resend earlier packet.
            //

            m_NextPacketToSend = INITIAL_PACKET_ID;
            m_PacketExpected = INITIAL_PACKET_ID;
            WriteControlPacket(PACKET_TYPE_KD_RESET, 0L);

            KdOut("DbgKdpWaitForPacket(): Recieved KD_RESET packet, "
                  "send KD_RESET ACK packet\n");
            FlushCallbacks();

            return DBGKD_WAIT_FAILED;
        }
        else if (s_PacketHeader.PacketType == PACKET_TYPE_KD_RESEND)
        {
            KdOut("READ: Received RESEND packet\n");
            FlushCallbacks();

            return DBGKD_WAIT_FAILED;
        }
        else
        {
            //
            // Invalid packet header, ignore it.
            //

            KdOut("READ: Received Control packet with UNKNOWN type\n");
            goto WaitForPacketLeader;
        }
    }
    else
    {
        //
        // The packet header is for data packet (not control packet).
        // Read Checksum.
        //
    
        rc = Read(&s_PacketHeader.Checksum, sizeof(s_PacketHeader.Checksum),
                  &BytesRead);
        if ((!rc) || BytesRead != sizeof(s_PacketHeader.Checksum))
        {
            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdOut("READ: Data packet header "
                  "checksum error (short read).\n");
            goto WaitForPacketLeader;
        }

        if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
        {
            //
            // If we are waiting for ACK packet ONLY
            // and we receive a data packet header, check if the packet id
            // is what we expected.  If yes, assume the acknowledge is lost
            // (but sent) and process the packet.
            //

            if (s_PacketHeader.PacketId == m_PacketExpected)
            {
                m_NextPacketToSend ^= 1;
                KdOut("READ: Received VALID data packet "
                      "while waiting for ACK.\n");
            }
            else
            {
                KdOut("READ: Received Data packet with unmatched ID = %lx\n",
                      s_PacketHeader.PacketId);
                WriteControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                   s_PacketHeader.PacketId);
                goto WaitForPacketLeader;
            }
        }
    }

    //
    // We are waiting for data packet and we received the packet header
    // for data packet. Perform the following checkings to make sure
    // it is the packet we are waiting for.
    //

    if ((s_PacketHeader.PacketId & ~SYNC_PACKET_ID) != INITIAL_PACKET_ID &&
        (s_PacketHeader.PacketId & ~SYNC_PACKET_ID) != (INITIAL_PACKET_ID ^ 1))
    {
        KdOut("READ: Received INVALID packet Id.\n");
        return DBGKD_WAIT_RESEND;
    }

    rc = Read(s_Packet, s_PacketHeader.ByteCount, &BytesRead);
    if ( (!rc) || BytesRead != s_PacketHeader.ByteCount )
    {
        KdOut("READ: Data packet error (short read).\n");
        return DBGKD_WAIT_RESEND;
    }

    //
    // Make sure the next byte is packet trailing byte
    //

    rc = Read(&DataByte, sizeof(DataByte), &BytesRead);
    if ( (!rc) || BytesRead != sizeof(DataByte) ||
         DataByte != PACKET_TRAILING_BYTE )
    {
        KdOut("READ: Packet trailing byte timeout.\n");
        return DBGKD_WAIT_RESEND;
    }

    //
    // Make sure the checksum is valid.
    //

    Checksum = ComputeChecksum(s_Packet, s_PacketHeader.ByteCount);
    if (Checksum != s_PacketHeader.Checksum)
    {
        KdOut("READ: Checksum error.\n");
        return DBGKD_WAIT_RESEND;
    }

    //
    // We have a valid data packet.  If the packetid is bad, we just
    // ack the packet to the sender will step ahead.  If packetid is bad
    // but SYNC_PACKET_ID bit is set, we sync up.  If packetid is good,
    // or SYNC_PACKET_ID is set, we take the packet.
    //

    KdOut("READ: Received Type %x data packet with id = %lx successfully.\n\n",
          s_PacketHeader.PacketType, s_PacketHeader.PacketId);

    SyncBit = s_PacketHeader.PacketId & SYNC_PACKET_ID;
    s_PacketHeader.PacketId = s_PacketHeader.PacketId & ~SYNC_PACKET_ID;

    //
    // Ack the packet.  SYNC_PACKET_ID bit will ALWAYS be OFF.
    //

    WriteControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                       s_PacketHeader.PacketId);

    //
    // Check the incoming packet Id.
    //

    if ((s_PacketHeader.PacketId != m_PacketExpected) &&
        (SyncBit != SYNC_PACKET_ID))
    {
        KdOut("READ: Unexpected Packet Id (Acked).\n");
        goto WaitForPacketLeader;
    }
    else
    {
        if (SyncBit == SYNC_PACKET_ID)
        {
            //
            // We know SyncBit is set, so reset Expected Ids
            //

            KdOut("READ: Got Sync Id, reset PacketId.\n");

            m_PacketExpected = s_PacketHeader.PacketId;
            m_NextPacketToSend = INITIAL_PACKET_ID;
        }
        
        m_PacketExpected ^= 1;
    }

    return DBGKD_WAIT_PACKET;
}

ULONG
DbgKdComTransport::WritePacketContents(IN KD_PACKET* Packet,
                                       IN PVOID PacketData,
                                       IN USHORT PacketDataLength,
                                       IN PVOID MorePacketData OPTIONAL,
                                       IN USHORT MorePacketDataLength OPTIONAL,
                                       IN BOOL NoAck)
{
    BOOL rc;
    ULONG BytesWritten;
    
    // Lock to ensure all parts of the data are
    // sequential in the stream.
    RESUME_ENGINE();
        
    //
    // Write the packet header
    //

    rc = Write(Packet, sizeof(*Packet), &BytesWritten);
    if ( (!rc) || BytesWritten != sizeof(*Packet))
    {
        //
        // An error occured writing the header, so write it again
        //

        KdOut("WRITE: Packet header error.\n");
        SUSPEND_ENGINE();
        return DBGKD_WRITE_RESEND;
    }

    //
    // Write the primary packet data
    //

    rc = Write(PacketData, PacketDataLength, &BytesWritten);
    if ( (!rc) || BytesWritten != PacketDataLength )
    {
        //
        // An error occured writing the primary packet data,
        // so write it again
        //

        KdOut("WRITE: Message header error.\n");
        SUSPEND_ENGINE();
        return DBGKD_WRITE_RESEND;
    }

    //
    // If secondary packet data was specified (WriteMemory, SetContext...)
    // then write it as well.
    //

    if ( ARGUMENT_PRESENT(MorePacketData) )
    {
        rc = Write(MorePacketData, MorePacketDataLength, &BytesWritten);
        if ( (!rc) || BytesWritten != MorePacketDataLength )
        {
            //
            // An error occured writing the secondary packet data,
            // so write it again
            //

            KdOut("WRITE: Message data error.\n");
            SUSPEND_ENGINE();
            return DBGKD_WRITE_RESEND;
        }
    }

    //
    // Output a packet trailing byte
    //

    do
    {
        rc = Write(&s_PacketTrailingByte[0],
                   sizeof(s_PacketTrailingByte),
                   &BytesWritten);
    }
    while ((!rc) || (BytesWritten != sizeof(s_PacketTrailingByte)));

    SUSPEND_ENGINE();

    if (!NoAck)
    {
        ULONG Received;
        
        //
        // Wait for ACK
        //

        Received = WaitForPacket(PACKET_TYPE_KD_ACKNOWLEDGE, NULL);
        if (Received != DBGKD_WAIT_ACK)
        {
            KdOut("WRITE: Wait for ACK failed. Resend Packet.\n");
            return DBGKD_WRITE_RESEND;
        }
    }

    return DBGKD_WRITE_PACKET;
}

ULONG
DbgKdComTransport::ReadPacketLeader(
    IN ULONG PacketType,
    OUT PULONG PacketLeader
    )
{
    DWORD BytesRead;
    BOOL rc;
    USHORT Index;
    UCHAR DataByte, PreviousDataByte;

    Index = 0;
    do
    {
        if (m_BreakIn)
        {
            if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64)
            {
                WriteBreakInPacket();
                return DBGKD_WAIT_RESYNC;
            }
        }

        if (m_Resync)
        {
            m_Resync = FALSE;

            KdOut(" Resync packet id ...");

            Synchronize();

            KdOut(" Done.\n");
            FlushCallbacks();

            return DBGKD_WAIT_RESYNC;
        }

        if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
        {
            KdOut("Packet read interrupted by exit request\n");
            return DBGKD_WAIT_FAILED;
        }
            
        FlushCallbacks();
        
        rc = Read(&DataByte, 1, &BytesRead);
        if (rc && BytesRead == 1 &&
            ( DataByte == PACKET_LEADER_BYTE ||
              DataByte == CONTROL_PACKET_LEADER_BYTE))
        {
            if ( Index == 0 )
            {
                PreviousDataByte = DataByte;
                Index++;
            }
            else if ( DataByte == PreviousDataByte )
            {
                Index++;
            }
            else
            {
                PreviousDataByte = DataByte;
                Index = 1;
            }
        }
        else
        {
            Index = 0;
            if (BytesRead == 0)
            {
                KdOut("READ: Timeout.\n");
                FlushCallbacks();

                if (m_AllowInitialBreak &&
                    (g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK))
                {
                    KdOut("Attempting to get initial breakpoint.\n");
                    WriteBreakInPacket();
                }
                return DBGKD_WAIT_FAILED;
            }
        }
    } while ( Index < 2 );

    if ( DataByte != CONTROL_PACKET_LEADER_BYTE )
    {
        *PacketLeader = PACKET_LEADER;
    }
    else
    {
        *PacketLeader = CONTROL_PACKET_LEADER;
    }
    return DBGKD_WAIT_PACKET;
}

void
DbgKdComTransport::CheckComStatus(void)
/*++

Routine Description:

    Called when the com port status trigger signals a change.
    This function handles the change in status.

    Note: status is only monitored when being used over the modem.

--*/
{
    DWORD   status;
    BOOL    rc;
    ULONG   br, bw;
    CHAR    buf[128];
    DWORD   CommErr;
    COMSTAT CommStat;
    ULONG   Len;

    if (!m_ComEvent)
    {
        //
        // Not triggered, just return
        //

        return;
    }

    // This should succeed since we were just notified,
    // but check the return value to keep PREfix happy.
    if (!GetCommModemStatus(m_Handle, &status))
    {
        // Leave m_ComEvent set for another try.
        return;
    }
    
    m_ComEvent = 0;
    
    if (!(status & 0x80))
    {
        dprintf ("No carrier detect - in terminal mode\n");

        // This routine can be called during a wait when the
        // engine lock isn't held and can also be called when
        // the lock is held.  RESUME handles both of these
        // cases so that the lock is reacquired or reentered.
        RESUME_ENGINE();
    
        //
        // Loop and read any com input
        //

        while (!(status & 0x80))
        {
            //
            // Get some input to send to the modem.
            //

            Len = GetInput("Term> ", buf, sizeof(buf));
            if (Len > 0)
            {
                Write(buf, Len, &Len);
                buf[0] = '\n';
                buf[1] = '\r';
                Write(buf, 2, &Len);
            }

            GetCommModemStatus (m_Handle, &status);
            rc = Read(buf, sizeof buf, &br);
            if (rc != TRUE || br == 0)
            {
                continue;
            }

            //
            // print the string.
            //

            dprintf("%s", buf);
            FlushCallbacks();

            //
            // if logging is on, log the output
            //

            if (g_LogFile != -1)
            {
                _write(g_LogFile, buf, br);
            }
        }

        dprintf ("Carrier detect - returning to debugger\n");
        FlushCallbacks();

        ClearCommError (
            m_Handle,
            &CommErr,
            &CommStat
            );

        SUSPEND_ENGINE();
    }
    else
    {
        CommErr = 0;
        ClearCommError (
            m_Handle,
            &CommErr,
            &CommStat
            );

        if (CommErr & CE_FRAME)
        {
            dprintf (" [FRAME ERR] ");
        }

        if (CommErr & CE_OVERRUN)
        {
            dprintf (" [OVERRUN ERR] ");
        }

        if (CommErr & CE_RXPARITY)
        {
            dprintf (" [PARITY ERR] ");
        }
    }

    //
    // Reset trigger
    //

    WaitCommEvent (m_Handle, &m_ComEvent, &m_EventOverlapped);
}

//----------------------------------------------------------------------------
//
// DbgKd1394Transport.
//
//----------------------------------------------------------------------------

#define PARAM_1394_CHANNEL "Channel"

#define ENV_1394_CHANNEL "_NT_DEBUG_1394_CHANNEL"

DbgKd1394Transport::DbgKd1394Transport(void)
{
    m_Index = DBGKD_TRANSPORT_1394;
    m_Name = g_DbgKdTransportNames[m_Index];
    m_InvPacketRetryLimit = 3;
    m_AckWrites = FALSE;
}

ULONG
DbgKd1394Transport::GetNumberParameters(void)
{
    return 1;
}

void
DbgKd1394Transport::GetParameter(ULONG Index, PSTR Name, PSTR Value)
{
    switch(Index)
    {
    case 0:
        strcpy(Name, PARAM_1394_CHANNEL);
        sprintf(Value, "%d", m_Channel);
        break;
    }
}

void
DbgKd1394Transport::ResetParameters(void)
{
    PSTR Env;
    
    if ((Env = getenv(ENV_1394_CHANNEL)) == NULL)
    {
        m_Channel = 0;
    }
    else
    {
        m_Channel = atol(Env);
    }
}

BOOL
DbgKd1394Transport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_strcmpi(Name, PARAM_1394_CHANNEL))
    {
        m_Channel = atol(Value);
    }
    else
    {
        ErrOut("1394 port parameters: %s is not a valid parameter\n", Name);

        return FALSE;
    }
    
    return TRUE;
}

HRESULT
DbgKd1394Transport::Initialize(void)
{
    char Name[64];
    HRESULT Status;

    dprintf("Using 1394 for debugging\n");
    
    if ((Status = DbgKdTransport::Initialize()) != S_OK)
    {
        return Status;
    }
    
    m_DirectPhysicalMemory = TRUE;

    Status = Create1394Channel(m_Channel, Name, &m_Handle);
    if (Status != S_OK)
    {
        ErrOut("Failed to open 1394 channel %d\n", m_Channel);
        ErrOut("If this is the first time KD was run, this is"
               " why this failed.\nVirtual 1394 "
               "Debugger Driver Installation will now be attempted\n");
        return Status;
    }
    else
    {
        dprintf("Opened %s\n", Name);
    }

    //
    // put the virtual driver in the right operating mode..
    //

    if (!SwitchVirtualDebuggerDriverMode(V1394DBG_API_CONFIGURATION_MODE_DEBUG)) {

        return FALSE;

    }


    return S_OK;
}

void
DbgKd1394Transport::Uninitialize(void)
{
    if (m_Handle != NULL)
    {
        CloseHandle(m_Handle);
        m_Handle = NULL;
    }

    DbgKdTransport::Uninitialize();
}

BOOL
DbgKd1394Transport::Read(
    IN PVOID    Buffer,
    IN ULONG    SizeOfBuffer,
    IN PULONG   BytesRead
    )
{
    BOOL    rc;
    DWORD   TrashErr;
    COMSTAT TrashStat;

    if (IS_DUMP_TARGET())
    {
        ErrOut( "Attempted to read KD transport while "
                "debugging a crash dump\n" );
        DebugBreak();
    }

    if (!SwitchVirtualDebuggerDriverMode(V1394DBG_API_CONFIGURATION_MODE_DEBUG)) {

        return FALSE;

    }

    rc = ReadFile(
             m_Handle,
             Buffer,
             SizeOfBuffer,
             BytesRead,
             &m_ReadOverlapped
             );
    if (!rc)
    {
        if (GetLastError() == ERROR_IO_PENDING)
        {
            rc = GetOverlappedResult(m_Handle,
                                     &m_ReadOverlapped,
                                     BytesRead,
                                     TRUE);
        }
        else
        {
            // Prevent looping on read errors from
            // burning 100% of the CPU.
            Sleep(50);
        }
    }

    if (rc)
    {
        m_BytesRead += *BytesRead;
    }
    
    return rc;
}

BOOL
DbgKd1394Transport::Write(
    IN PVOID    Buffer,
    IN ULONG    SizeOfBuffer,
    IN PULONG   BytesWritten
    )
{
    BOOL    rc;
    DWORD   TrashErr;
    COMSTAT TrashStat;

    if (IS_DUMP_TARGET())
    {
        ErrOut( "Attempted to write KD transport "
                "while debugging a crash dump\n" );
        DebugBreak();
    }

    if (!SwitchVirtualDebuggerDriverMode(V1394DBG_API_CONFIGURATION_MODE_DEBUG)) {

        return FALSE;

    }

    rc = WriteFile(
             m_Handle,
             Buffer,
             SizeOfBuffer,
             BytesWritten,
             &m_WriteOverlapped
             );
    if (!rc)
    {
        if (GetLastError() == ERROR_IO_PENDING)
        {
            rc = GetOverlappedResult(m_Handle,
                                     &m_WriteOverlapped,
                                     BytesWritten,
                                     TRUE);
        }
    }

    if (rc)
    {
        m_BytesWritten += *BytesWritten;
    }
    
    return rc;
}

HRESULT
DbgKd1394Transport::ReadTargetPhysicalMemory(
    IN ULONG64 MemoryOffset,
    IN PVOID Buffer,
    IN ULONG SizeofBuffer,
    IN PULONG BytesRead
    )
{
    DWORD   dwRet, dwBytesRet;
    PV1394DBG_API_REQUEST pApiReq;

    if (IS_DUMP_TARGET())
    {
        ErrOut( "Attempted to access KD transport while "
                "debugging a crash dump\n" );
        DebugBreak();
    }

    //
    // first setup the read i/o parameters in the virtual driver
    //

    pApiReq = (PV1394DBG_API_REQUEST)
        LocalAlloc(LPTR, sizeof(V1394DBG_API_REQUEST));
    if (pApiReq == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // if the virtual driver is not set in raw access mode, we need to 
    // tell it to change modes..
    //

    if (!SwitchVirtualDebuggerDriverMode(V1394DBG_API_CONFIGURATION_MODE_RAW_MEMORY_ACCESS)) {

        LocalFree(pApiReq);
        return E_UNEXPECTED;

    }

    pApiReq->RequestNumber = V1394DBG_API_SET_IO_PARAMETERS;
    pApiReq->Flags = V1394DBG_API_FLAG_READ_IO;

    pApiReq->u.SetIoParameters.fulFlags = 0;
    pApiReq->u.SetIoParameters.StartingMemoryOffset.QuadPart = MemoryOffset;

    dwRet = DeviceIoControl( m_Handle,
                             IOCTL_V1394DBG_API_REQUEST,
                             pApiReq,
                             sizeof(V1394DBG_API_REQUEST),
                             NULL,
                             0,
                             &dwBytesRet,
                             NULL
                             );
    if (!dwRet)
    {
        dwRet = GetLastError();
        ErrOut("Failed to send SetIoParameters 1394 "
               "Virtual Driver Request, error %x\n",dwRet);

        LocalFree(pApiReq);
        return E_UNEXPECTED;
    }

    LocalFree(pApiReq);

    //
    // now do anormal read. The virtual driver will read SizeofBuffer bytes
    // starting at the remote PCs physical address we specified above
    //

    dwRet = ReadFile(
             m_Handle,
             Buffer,
             SizeofBuffer,
             BytesRead,
             &m_ReadOverlapped
             );
    if (!dwRet)
    {
        if (GetLastError() == ERROR_IO_PENDING)
        {
            dwRet = GetOverlappedResult(m_Handle,
                                     &m_ReadOverlapped,
                                     BytesRead,
                                     TRUE);
        }
    }

    return (dwRet != 0) ? S_OK : E_UNEXPECTED;
}

BOOL
DbgKd1394Transport::SwitchVirtualDebuggerDriverMode(
    IN ULONG    DesiredOperationMode
    )
{
    DWORD   dwRet, dwBytesRet;
    PV1394DBG_API_REQUEST pApiReq;

    //
    // if the virtual driver is not set in raw access mode, we need to 
    // tell it to change modes..
    //

    if (m_OperationMode != DesiredOperationMode) {

        //
        // first setup the read i/o parameters in the virtual driver
        //
    
        pApiReq = (PV1394DBG_API_REQUEST)
            LocalAlloc(LPTR, sizeof(V1394DBG_API_REQUEST));
        if (pApiReq == NULL)
        {
            return FALSE;
        }

        pApiReq->RequestNumber = V1394DBG_API_SET_CONFIGURATION;
        pApiReq->Flags = 0;
    
        pApiReq->u.SetConfiguration.OperationMode = DesiredOperationMode;
    
        dwRet = DeviceIoControl( m_Handle,
                                 IOCTL_V1394DBG_API_REQUEST,
                                 pApiReq,
                                 sizeof(V1394DBG_API_REQUEST),
                                 NULL,
                                 0,
                                 &dwBytesRet,
                                 NULL
                                 );
    
        if (!dwRet)
        {
            dwRet = GetLastError();
            ErrOut("Failed to send SetConfiguration 1394 "
                   "Virtual Driver Request, error %x\n", dwRet);
    
            LocalFree(pApiReq);
            return FALSE;
        }

        m_OperationMode = DesiredOperationMode;

        LocalFree(pApiReq);

    }

    return TRUE;
}

VOID
DbgKd1394Transport::Synchronize(VOID)
{
    ULONG Index;
    ULONG BytesRead;
    BOOL rc;
    
    // XXX drewb - Why is this code disabled?
    return;
        
    Index = 3;
    while (TRUE)
    {
        if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
        {
            KdOut("Synchronize interrupted by exit request\n");
            return;
        }
            
        WriteControlPacket(PACKET_TYPE_KD_RESET, 0L);

        FlushCallbacks();
            
        rc = Read(s_Packet, sizeof(s_Packet), &BytesRead);

        CopyMemory(&s_PacketHeader, &s_Packet[0], sizeof(KD_PACKET));
        
        if (rc && (BytesRead >= sizeof(s_PacketHeader)))
        {
            if (s_PacketHeader.PacketType == PACKET_TYPE_KD_RESET)
            {
                break;
            }
        }

        if (!Index--)
        {
            break;
        }
    }
}

ULONG
DbgKd1394Transport::ReadPacketContents(IN USHORT PacketType)
{
    DWORD BytesRead;
    BOOL rc;
    UCHAR DataByte;
    ULONG Checksum;

WaitForPacket1394:

    if (m_AllowInitialBreak && (g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK))
    {
        KdOut("Attempting to get initial breakpoint.\n");
        WriteBreakInPacket();
        m_AllowInitialBreak = FALSE;
    }

    if (m_Resync)
    {
        m_Resync = FALSE;

        KdOut(" Resync packet id ...");

        Synchronize();

        KdOut(" Done.\n");
        FlushCallbacks();

        return DBGKD_WAIT_RESYNC;
    }

    if (m_BreakIn)
    {
        WriteBreakInPacket();
        return DBGKD_WAIT_RESYNC;
    }

    if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
    {
        KdOut("Packet read interrupted by exit request\n");
        return DBGKD_WAIT_FAILED;
    }
            
    FlushCallbacks();
    
    //
    // read the whole packet at once.
    // we try to read MAX_PACKET worth of data and then check how much 
    // we really read. Also since the packet header (KD_PACKET) is part of what
    // we read, we later have to move the data packet back sizeof(KD_PACKET)
    //

    rc = Read(s_Packet, sizeof(s_Packet), &BytesRead);
    CopyMemory(&s_PacketHeader, &s_Packet[0], sizeof(KD_PACKET));

    if (!rc || (BytesRead < sizeof(s_PacketHeader)))
    {
        if (!rc)
        {
            KdOut("READ: Error %x.\n",GetLastError());
        }
        else
        {
            KdOut("READ: Data ByteCount error (short read) %x, %x.\n",
                  BytesRead, sizeof(s_PacketHeader));
        }

        if (rc && (BytesRead >= sizeof(s_PacketHeader)) )
        {
            if (s_PacketHeader.PacketLeader == PACKET_LEADER)
            {
                WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
                KdOut("READ: Data packet header "
                      "ByteCount error (short read).\n");
            }
        }

        goto WaitForPacket1394;
    }

    //
    // move data portion to start of packet.
    //

    MoveMemory(s_Packet, ((PUCHAR)s_Packet + sizeof(KD_PACKET)),
               BytesRead - sizeof(KD_PACKET));

    //
    // Check the Packet type.
    //

    if ((g_KdMaxPacketType == 0 &&
         s_PacketHeader.PacketType >= PACKET_TYPE_MAX) ||
        (g_KdMaxPacketType > 0 &&
         s_PacketHeader.PacketType >= g_KdMaxPacketType))
    {
        KdOut("READ: Received INVALID packet type.\n");

        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            return DBGKD_WAIT_RESEND;
        }

        return DBGKD_WAIT_FAILED;
    }

    KdOut("      PacketType=%x, ", s_PacketHeader.PacketType);

    //
    // Check ByteCount
    //

    if (s_PacketHeader.ByteCount > PACKET_MAX_SIZE )
    {
        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            KdOut("READ: Data packet header ByteCount error (short read).\n");
            return DBGKD_WAIT_RESEND;
        }

        return DBGKD_WAIT_FAILED;
    }

    KdOut("ByteCount=%x, PacketId=%x,\n",
          s_PacketHeader.ByteCount,
          s_PacketHeader.PacketId);

    if (s_PacketHeader.ByteCount != (BytesRead - sizeof(s_PacketHeader)))
    {
        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            KdOut("READ: Data packet header ByteCount error (short read).\n");
            return DBGKD_WAIT_RESEND;
        }
        
        return DBGKD_WAIT_FAILED;
    }

    //
    // Make sure the checksum is valid.
    //

    Checksum = ComputeChecksum(s_Packet, s_PacketHeader.ByteCount);
    if (Checksum != s_PacketHeader.Checksum)
    {
        KdOut("READ: Checksum error.\n");
        return DBGKD_WAIT_RESEND;
    }

    if (s_PacketHeader.PacketLeader == CONTROL_PACKET_LEADER)
    {
        if (s_PacketHeader.PacketType == PACKET_TYPE_KD_RESET)
        {
            //
            // if we received Reset packet, reset the packet control variables
            // and resend earlier packet.
            //

            m_NextPacketToSend = INITIAL_PACKET_ID;
            m_PacketExpected = INITIAL_PACKET_ID;
            WriteControlPacket(PACKET_TYPE_KD_RESET, 0L);

            KdOut("DbgKdpWaitForPacket(): "
                  "Recieved KD_RESET packet, send KD_RESET ACK packet\n");
            FlushCallbacks();

            return DBGKD_WAIT_FAILED;
        }
        else if (s_PacketHeader.PacketType == PACKET_TYPE_KD_RESEND)
        {
            KdOut("READ: Received RESEND packet\n");
            FlushCallbacks();

            return DBGKD_WAIT_FAILED;
        }
        else
        {
            //
            // Invalid packet header, ignore it.
            //

            KdOut("READ: Received Control packet with UNKNOWN type\n");
            FlushCallbacks();

            return DBGKD_WAIT_FAILED;
        }
    }

    //
    // we are waiting for data packet and we received the packet header
    // for data packet. Perform the following checkings to make sure
    // it is the packet we are waiting for.
    //

    KdOut("READ: Received Type %x data packet with id = %lx successfully.\n\n",
          s_PacketHeader.PacketType, s_PacketHeader.PacketId);

    return DBGKD_WAIT_PACKET;
}

ULONG
DbgKd1394Transport::WritePacketContents(IN KD_PACKET* Packet,
                                        IN PVOID PacketData,
                                        IN USHORT PacketDataLength,
                                        IN PVOID MorePacketData OPTIONAL,
                                        IN USHORT MorePacketDataLength OPTIONAL,
                                        IN BOOL NoAck)
{
    BOOL rc;
    ULONG BytesWritten;
    PUCHAR Tx;
    
    // Lock to ensure only one thread is using
    // the transmit buffer.
    RESUME_ENGINE();
        
    //
    // On 1394 we double buffer all packet segments into one contigious
    // buffer and write it all at once
    //

    Tx = m_TxPacket;

    memcpy(Tx, Packet, sizeof(*Packet));
    Tx += sizeof(*Packet);

    memcpy(Tx, PacketData, PacketDataLength);
    Tx += PacketDataLength;

    if ( ARGUMENT_PRESENT(MorePacketData) )
    {
        memcpy(Tx, MorePacketData, MorePacketDataLength);
        Tx += MorePacketDataLength;
    }

    //
    // The 1394 Debug protocol does not use trailer bytes
    //

    //
    // Write the whole packet out to the bus
    //

    do
    {
        rc = Write(&m_TxPacket[0], (ULONG)(Tx - m_TxPacket), &BytesWritten);
    }
    while ((!rc) || (BytesWritten != (ULONG)(Tx - m_TxPacket)));

    SUSPEND_ENGINE();

    return DBGKD_WRITE_PACKET;
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

#define BUS_TYPE         "_NT_DEBUG_BUS"
#define DBG_BUS1394_NAME "1394"

HRESULT
DbgKdConnectAndInitialize(PCSTR Options)
{
    DbgKdTransport* Trans = NULL;
    ULONG Index;
        
    // Try and find the transport by name.
    Index = ParameterStringParser::
        GetParser(Options, DBGKD_TRANSPORT_COUNT, g_DbgKdTransportNames);
    if (Index < DBGKD_TRANSPORT_COUNT)
    {
        switch(Index)
        {
        case DBGKD_TRANSPORT_COM:
            Trans = &g_DbgKdComTransport;
            break;
        case DBGKD_TRANSPORT_1394:
            Trans = &g_DbgKd1394Transport;
            break;
        }
    }

    if (Trans == NULL)
    {
        PCHAR BusType;

        // Couldn't identify the transport from options so check
        // the environment.

        // Default to com port.
        Trans = &g_DbgKdComTransport;
        
        if (BusType = getenv(BUS_TYPE))
        {
            if (strstr(BusType, DBG_BUS1394_NAME))
            {
                Trans = &g_DbgKd1394Transport;
            }
        }
    }

    HRESULT Status;

    // Clear parameter state.
    Trans->ResetParameters();
    
    if (!Trans->ParseParameters(Options))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        Status = Trans->Initialize();
        if (Status != S_OK)
        {
            ErrOut("Kernel Debugger failed initialization, 0x%X\n", Status);
        }
    }
    
    if (Status == S_OK)
    {
        g_DbgKdTransport = Trans;
        Trans->Restart();
    }
    
    return Status;
}

VOID
DbgKdpPrint(
    IN ULONG Processor,
    IN PCSTR String,
    IN USHORT StringLength,
    IN ULONG Mask
    )
{
    DWORD i;
    DWORD j;
    CHAR c;
    PSTR d;

    DBG_ASSERT(StringLength < PACKET_MAX_SIZE - 2);

    // This routine can be called during a wait when the
    // engine lock isn't held and can also be called when
    // the lock is held.  RESUME handles both of these
    // cases so that the lock is reacquired or reentered.
    RESUME_ENGINE();
    
    if (g_TargetNumberProcessors > 1 && Processor != g_LastProcessorToPrint)
    {
        g_LastProcessorToPrint = Processor;
        MaskOut(Mask, "%d:", Processor);
    }

    StartOutLine(Mask, OUT_LINE_NO_PREFIX);

    //
    // Add the original data to the print buffer.
    //

    d = g_PrintBuf;

    for (i = 0; i < StringLength ; i++)
    {
        c = *(String + i);
        if ( c == '\n' )
        {
            g_LastProcessorToPrint = -1;
            *d++ = '\n';
            *d++ = '\r';
        }
        else
        {
            if ( c )
            {
                *d++ = c;
            }
        }
    }

    j = (DWORD)(d - g_PrintBuf);

    //
    // print the string.
    //

    MaskOut(Mask, "%*.*s", j, j, g_PrintBuf);

    SUSPEND_ENGINE();
}

VOID
DbgKdpHandlePromptString(
    IN PDBGKD_DEBUG_IO IoMessage
    )
{
    PSTR IoData;
    DWORD j;

    // This routine can be called during a wait when the
    // engine lock isn't held and can also be called when
    // the lock is held.  RESUME handles both of these
    // cases so that the lock is reacquired or reentered.
    RESUME_ENGINE();
    
    IoData = (PSTR)(IoMessage + 1);

    DbgKdpPrint(IoMessage->Processor,
                IoData,
                (USHORT)IoMessage->u.GetString.LengthOfPromptString,
                DEBUG_OUTPUT_DEBUGGEE_PROMPT
                );

    //
    // read the prompt data
    //

    j = GetInput(NULL, IoData,
                 IoMessage->u.GetString.LengthOfStringRead);
    if (j == 0)
    {
        j = IoMessage->u.GetString.LengthOfStringRead;
        memset(IoData, 0, j);
    }

    g_LastProcessorToPrint = -1;
    if ( j < (USHORT)IoMessage->u.GetString.LengthOfStringRead )
    {
        IoMessage->u.GetString.LengthOfStringRead = j;
    }

    //
    // Log the user's input
    //

    if (g_LogFile != -1)
    {
        _write(g_LogFile, IoData, j);
        _write(g_LogFile, "\n", 1);
    }

    SUSPEND_ENGINE();
    
    //
    // Send data to the debugger-target
    //

    g_DbgKdTransport->WritePacket(IoMessage, sizeof(*IoMessage),
                                  PACKET_TYPE_KD_DEBUG_IO,
                                  IoData,
                                  (USHORT)IoMessage->
                                  u.GetString.LengthOfStringRead);
}

VOID
DbgKdpPrintTrace(
    IN ULONG Processor,
    IN PUCHAR Data,
    IN USHORT DataLength,
    IN ULONG Mask
    )
{
    // This routine can be called during a wait when the
    // engine lock isn't held and can also be called when
    // the lock is held.  RESUME handles both of these
    // cases so that the lock is reacquired or reentered.
    RESUME_ENGINE();

    DebugClient* Client;
    
    // Find a client with output callbacks to use for output.
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_OutputCb != NULL)
        {
            break;
        }
    }
    if (Client == NULL)
    {
        // No clients have output callbacks so nobody
        // cares about output and we can just quit.
        goto Exit;
    }
    
    // Prefix the entire output block with the processor
    // number as we can't (and don't want to) get involved
    // in the individual messages.
    if (g_TargetNumberProcessors > 1 && Processor != g_LastProcessorToPrint)
    {
        g_LastProcessorToPrint = Processor;
        MaskOut(Mask, "%d", Processor);
    }

    if (g_WmiFormatTraceData == NULL)
    {
        AddExtensionDll("wmikd.dll", FALSE, NULL);
    }

    if (g_WmiFormatTraceData == NULL)
    {
        ErrOut("Missing or incorrect wmikd.dll - "
               "0x%X byte trace data buffer ignored\n",
               DataLength);
    }
    else
    {
        g_WmiFormatTraceData((PDEBUG_CONTROL)(IDebugControlN*)Client,
                             Mask, DataLength, Data);
    }

 Exit:
    SUSPEND_ENGINE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dbgkdapi.cpp ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    dbgkdapi.cpp

Abstract:

    This module implements the DbgKd APIs

--*/

#include "ntsdp.hpp"

BOOL DbgKdApi64;

ULONG g_KdMaxPacketType;
ULONG g_KdMaxStateChange;
ULONG g_KdMaxManipulate;

//++
//
// VOID
// DbgKdpWaitPacketForever (
//     IN ULONG PacketType,
//     IN PVOID Buffer
//     )
//
// Routine Description:
//
//     This macro is invoked to wait for specifi type of message without
//     timeout.
//
// Arguments:
//
//     PacketType - Type of the message we are expecting.
//
//     Buffer - Buffer to store the message.
//
// Return Value:
//
//     None.
//
//--

#define DbgKdpWaitPacketForever( PacketType, Buffer ) {        \
        ULONG WaitStatus;                                      \
        do {                                                   \
            WaitStatus = g_DbgKdTransport->WaitForPacket(      \
                PacketType,                                    \
                Buffer                                         \
                );                                             \
        } while (WaitStatus != DBGKD_WAIT_PACKET);             \
}

#define COPYSE(p64, p32, f) p64->f = (ULONG64)(LONG64)(LONG)p32->f

void
WaitStateChange32ToAny(
    IN PDBGKD_WAIT_STATE_CHANGE32 Ws32,
    IN ULONG ControlReportSize,
    OUT PDBGKD_ANY_WAIT_STATE_CHANGE WsAny
    )
{
    WsAny->NewState = Ws32->NewState;
    WsAny->ProcessorLevel = Ws32->ProcessorLevel;
    WsAny->Processor = Ws32->Processor;
    WsAny->NumberProcessors = Ws32->NumberProcessors;
    COPYSE(WsAny, Ws32, Thread);
    COPYSE(WsAny, Ws32, ProgramCounter);
    memcpy(&WsAny->ControlReport, Ws32 + 1, ControlReportSize);
    if (Ws32->NewState == DbgKdLoadSymbolsStateChange)
    {
        DbgkdLoadSymbols32To64(&Ws32->u.LoadSymbols, &WsAny->u.LoadSymbols);
    }
    else
    {
        DbgkmException32To64(&Ws32->u.Exception, &WsAny->u.Exception);
    }
}

#undef COPYSE

NTSTATUS
DbgKdWaitStateChange(
    OUT PDBGKD_ANY_WAIT_STATE_CHANGE StateChange,
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    IN BOOL SuspendEngine
    )

/*++

Routine Description:

    This function causes the calling user interface to wait for a state
    change to occur in the system being debugged.  Once a state change
    occurs, the user interface can either continue the system using
    DbgKdContinue, or it can manipulate system state using anyone of the
    DbgKd state manipulation APIs.

Arguments:

    StateChange - Supplies the address of state change record that
        will contain the state change information.

    Buffer - Supplies the address of a buffer that returns additional
        information.

    BufferLength - Supplies the length of Buffer.

Return Value:

    STATUS_SUCCESS - A state change occured. Valid state change information
        was returned.

--*/

{

    PVOID LocalStateChange;
    NTSTATUS Status;
    PUCHAR Data;
    ULONG SizeofStateChange;

    //
    // Waiting for a state change message. Copy the message to the callers
    // buffer.
    //

    DBG_ASSERT(g_DbgKdTransport->m_WaitingThread == 0);
    g_DbgKdTransport->m_WaitingThread = GetCurrentThreadId();
    if (SuspendEngine)
    {
        SUSPEND_ENGINE();
    }

    DbgKdpWaitPacketForever(
            PACKET_TYPE_KD_STATE_CHANGE64,
            &LocalStateChange
            );

    if (SuspendEngine)
    {
        RESUME_ENGINE();
    }
    g_DbgKdTransport->m_WaitingThread = 0;

    Status = STATUS_SUCCESS;

    // If this is the very first wait we don't know what machine
    // type we've connected to.  Update the version information
    // right away.
    if (g_TargetMachineType == IMAGE_FILE_MACHINE_UNKNOWN)
    {
        g_DbgKdTransport->SaveReadPacket();

        g_Target->GetKdVersion();

        g_DbgKdTransport->RestoreReadPacket();

        if (g_TargetMachineType == IMAGE_FILE_MACHINE_UNKNOWN)
        {
            //
            // We were unable to determine what kind of machine
            // has connected so we cannot properly communicate with it.
            //

            return STATUS_UNSUCCESSFUL;
        }
    }

    if (DbgKdApi64)
    {
        if (g_KdVersion.ProtocolVersion < DBGKD_64BIT_PROTOCOL_VERSION2)
        {
            PDBGKD_WAIT_STATE_CHANGE64 Ws64 =
                (PDBGKD_WAIT_STATE_CHANGE64)LocalStateChange;
            ULONG Offset, Align, Pad;

            //
            // The 64-bit structures contain 64-bit quantities and
            // therefore the compiler rounds the total size up to
            // an even multiple of 64 bits (or even more, the IA64
            // structures are 16-byte aligned).  Internal structures
            // are also aligned, so make sure that we account for any
            // padding.  Knowledge of which structures need which
            // padding pretty much has to be hard-coded in.
            //

            C_ASSERT((sizeof(DBGKD_WAIT_STATE_CHANGE64) & 15) == 0);

            SizeofStateChange =
                sizeof(DBGKD_WAIT_STATE_CHANGE64) +
                g_TargetMachine->m_SizeControlReport +
                g_TargetMachine->m_SizeTargetContext;

            // We shouldn't need to align the base of the control report
            // so copy the base data and control report.
            Offset = sizeof(DBGKD_WAIT_STATE_CHANGE64) +
                g_TargetMachine->m_SizeControlReport;
            memcpy(StateChange, Ws64, Offset);

            //
            // Add alignment padding before the context.
            //

            switch(g_TargetMachineType)
            {
            case IMAGE_FILE_MACHINE_IA64:
                Align = 15;
                break;
            default:
                Align = 7;
                break;
            }

            Pad = ((Offset + Align) & ~Align) - Offset;
            Offset += Pad;
            SizeofStateChange += Pad;

            //
            // Add alignment padding after the context.
            //
            
            Offset += g_TargetMachine->m_SizeTargetContext;
            Pad = ((Offset + Align) & ~Align) - Offset;
            SizeofStateChange += Pad;
        }
        else
        {
            PDBGKD_ANY_WAIT_STATE_CHANGE WsAny =
                (PDBGKD_ANY_WAIT_STATE_CHANGE)LocalStateChange;
            SizeofStateChange = sizeof(*WsAny);
            *StateChange = *WsAny;
        }
    }
    else
    {
        SizeofStateChange =
            sizeof(DBGKD_WAIT_STATE_CHANGE32) +
            g_TargetMachine->m_SizeControlReport +
            g_TargetMachine->m_SizeTargetContext;
        WaitStateChange32ToAny((PDBGKD_WAIT_STATE_CHANGE32)LocalStateChange,
                               g_TargetMachine->m_SizeControlReport,
                               StateChange);
    }

    switch(StateChange->NewState)
    {
    case DbgKdExceptionStateChange:
    case DbgKdCommandStringStateChange:
        if (BufferLength <
            (g_DbgKdTransport->s_PacketHeader.ByteCount - SizeofStateChange))
        {
            Status = STATUS_BUFFER_OVERFLOW;
        }
        else
        {
            Data = (UCHAR *)LocalStateChange + SizeofStateChange;
            memcpy(Buffer, Data,
                   g_DbgKdTransport->s_PacketHeader.ByteCount -
                   SizeofStateChange);
        }
        break;
    case DbgKdLoadSymbolsStateChange:
        if ( BufferLength < StateChange->u.LoadSymbols.PathNameLength )
        {
            Status = STATUS_BUFFER_OVERFLOW;
        }
        else
        {
            Data = ((UCHAR *) LocalStateChange) +
                g_DbgKdTransport->s_PacketHeader.ByteCount -
                (int)StateChange->u.LoadSymbols.PathNameLength;
            memcpy(Buffer, Data,
                   (int)StateChange->u.LoadSymbols.PathNameLength);
        }
        break;
    default:
        ErrOut("Unknown state change type %X\n", StateChange->NewState);
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    
    return Status;
}

NTSTATUS
DbgKdContinue (
    IN NTSTATUS ContinueStatus
    )

/*++

Routine Description:

    Continuing a system that previously reported a state change causes
    the system to continue executiontion using the context in effect at
    the time the state change was reported (of course this context could
    have been modified using the DbgKd state manipulation APIs).

Arguments:

    ContinueStatus - Supplies the continuation status to the thread
        being continued.  Valid values for this are
        DBG_EXCEPTION_HANDLED, DBG_EXCEPTION_NOT_HANDLED
        or DBG_CONTINUE.

Return Value:

    STATUS_SUCCESS - Successful call to DbgUiContinue

    STATUS_INVALID_PARAMETER - An invalid continue status or was
        specified.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_CONTINUE a = &m.u.Continue;
    NTSTATUS st;

    if ( ContinueStatus == DBG_EXCEPTION_HANDLED ||
         ContinueStatus == DBG_EXCEPTION_NOT_HANDLED ||
         ContinueStatus == DBG_CONTINUE )
    {
        m.ApiNumber = DbgKdContinueApi;
        m.ReturnStatus = ContinueStatus;

        a->ContinueStatus = ContinueStatus;
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        st = STATUS_SUCCESS;
    }
    else
    {
        st = STATUS_INVALID_PARAMETER;
    }

    KdOut("DbgKdContinue returns %08lx\n", st);

    return st;
}


NTSTATUS
DbgKdContinue2 (
    IN NTSTATUS ContinueStatus,
    IN DBGKD_ANY_CONTROL_SET ControlSet
    )

/*++

Routine Description:

    Continuing a system that previously reported a state change causes
    the system to continue executiontion using the context in effect at
    the time the state change was reported, modified by the values set
    in the ControlSet structure.  (And, of course, the context could have
    been modified by used the DbgKd state manipulation APIs.)

Arguments:

    ContinueStatus - Supplies the continuation status to the thread
        being continued.  Valid values for this are
        DBG_EXCEPTION_HANDLED, DBG_EXCEPTION_NOT_HANDLED
        or DBG_CONTINUE.

    ControlSet - Supplies a pointer to a structure containing the machine
        specific control data to set.  For the x86 this is the TraceFlag
        and Dr7.

Return Value:

    STATUS_SUCCESS - Successful call to DbgUiContinue

    STATUS_INVALID_PARAMETER - An invalid continue status or was
        specified.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    NTSTATUS st;

    if ( ContinueStatus == DBG_EXCEPTION_HANDLED ||
         ContinueStatus == DBG_EXCEPTION_NOT_HANDLED ||
         ContinueStatus == DBG_CONTINUE)
    {
        m.ApiNumber = DbgKdContinueApi2;
        m.ReturnStatus = ContinueStatus;

        m.u.Continue2.ContinueStatus = ContinueStatus;
        m.u.Continue2.AnyControlSet = ControlSet;

        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        st = STATUS_SUCCESS;
    }
    else
    {
        st = STATUS_INVALID_PARAMETER;
    }

    KdOut("DbgKdContinue2 returns %08lx\n", st);

    return st;
}

NTSTATUS
DbgKdSetSpecialCalls (
    IN ULONG NumSpecialCalls,
    IN PULONG64 Calls
    )

/*++

Routine Description:

    Inform the debugged kernel that calls to these addresses
    are "special" calls, and they should result in callbacks
    to the kernel debugger rather than continued local stepping.
    The new values *replace* any old ones that may have previously
    set (not that you're likely to want to change this).

Arguments:

    NumSpecialCalls - how many special calls there are

    Calls - pointer to an array of calls.

Return Value:

    STATUS_SUCCESS - Successful call to DbgUiContinue

    STATUS_INVALID_PARAMETER - The number of special calls
        wasn't between 0 and MAX_SPECIAL_CALLS.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    ULONG i;

    m.ApiNumber = DbgKdClearSpecialCallsApi;
    m.ReturnStatus = STATUS_PENDING;
    g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                  PACKET_TYPE_KD_STATE_MANIPULATE,
                                  NULL, 0);
    InvalidateMemoryCaches();

    for (i = 0; i < NumSpecialCalls; i++)
    {
        m.ApiNumber = DbgKdSetSpecialCallApi;
        m.ReturnStatus = STATUS_PENDING;
        m.u.SetSpecialCall.SpecialCall = Calls[i];
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
    }

    KdOut("DbgKdSetSpecialCalls returns 0x00000000\n");
    
    return STATUS_SUCCESS;
}

NTSTATUS
DbgKdSetInternalBp (
    ULONG64 addr,
    ULONG flags
    )

/*++

Routine Description:

    Inform the debugged kernel that a breakpoint at this address
    is to be internally counted, and not result in a callback to the
    remote debugger (us).  This function DOES NOT cause the kernel to
    set the breakpoint; the debugger must do that independently.

Arguments:

    Addr - address of the breakpoint

    Flags - the breakpoint flags to set (note: if the invalid bit
    is set, this CLEARS a breakpoint).

Return Value:

    STATUS_SUCCESS - Successful call to DbgUiContinue

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    NTSTATUS st;

    m.ApiNumber = DbgKdSetInternalBreakPointApi;
    m.ReturnStatus = STATUS_PENDING;

#ifdef IBP_WORKAROUND
    // The kernel code keeps a ULONG64 for an internal breakpoint
    // address but older kernels did not sign-extend the current IP
    // when comparing against them.  In order to work with both
    // broken and fixed kernels send down zero-extended addresses.
    // Don't actually enable this workaround right now as other
    // internal breakpoint bugs can cause the machine to bugcheck.
    addr = g_TargetMachine->m_Ptr64 ? addr : (ULONG)addr;
#endif

    m.u.SetInternalBreakpoint.BreakpointAddress = addr;
    m.u.SetInternalBreakpoint.Flags = flags;

    g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                  PACKET_TYPE_KD_STATE_MANIPULATE,
                                  NULL, 0);

    KdOut("DbgKdSetInternalBp returns 0x00000000\n");

    return STATUS_SUCCESS;
}

NTSTATUS
DbgKdGetInternalBp (
    ULONG64 addr,
    PULONG flags,
    PULONG calls,
    PULONG minInstr,
    PULONG maxInstr,
    PULONG totInstr,
    PULONG maxCPS
    )

/*++

Routine Description:

    Query the status of an internal breakpoint from the debugged
    kernel and return the data to the caller.

Arguments:

    Addr - address of the breakpoint

    flags, calls, minInstr, maxInstr, totInstr - values returned
        describing the particular breakpoint.  flags will contain
        the invalid bit if the breakpoint is bogus.

Return Value:

    STATUS_SUCCESS - Successful call to DbgUiContinue

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    NTSTATUS st;
    ULONG rc;

    m.ApiNumber = DbgKdGetInternalBreakPointApi;
    m.ReturnStatus = STATUS_PENDING;

#ifdef IBP_WORKAROUND
    // The kernel code keeps a ULONG64 for an internal breakpoint
    // address but older kernels did not sign-extend the current IP
    // when comparing against them.  In order to work with both
    // broken and fixed kernels send down zero-extended addresses.
    // Don't actually enable this workaround right now as other
    // internal breakpoint bugs can cause the machine to bugcheck.
    addr = g_TargetMachine->m_Ptr64 ? addr : (ULONG)addr;
#endif

    m.u.GetInternalBreakpoint.BreakpointAddress = addr;

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    }
    while (rc != DBGKD_WAIT_PACKET);

    *flags = Reply->u.GetInternalBreakpoint.Flags;
    *calls = Reply->u.GetInternalBreakpoint.Calls;
    *maxCPS = Reply->u.GetInternalBreakpoint.MaxCallsPerPeriod;
    *maxInstr = Reply->u.GetInternalBreakpoint.MaxInstructions;
    *minInstr = Reply->u.GetInternalBreakpoint.MinInstructions;
    *totInstr = Reply->u.GetInternalBreakpoint.TotalInstructions;

    KdOut("DbgKdGetInternalBp returns 0x00000000\n");

    return STATUS_SUCCESS;
}

NTSTATUS
DbgKdClearAllInternalBreakpoints(
    void
    )
{
    if (g_KdMaxManipulate <= DbgKdClearAllInternalBreakpointsApi)
    {
        return STATUS_NOT_IMPLEMENTED;
    }
    
    DBGKD_MANIPULATE_STATE64 Request;
    NTSTATUS Status = STATUS_SUCCESS;

    Request.ApiNumber = DbgKdClearAllInternalBreakpointsApi;
    Request.ReturnStatus = STATUS_PENDING;

    g_DbgKdTransport->WritePacket(&Request, sizeof(Request),
                                  PACKET_TYPE_KD_STATE_MANIPULATE,
                                  NULL, 0);

    KdOut("DbgKdClearAllInternalBreakpoints returns 0x%08X\n", Status);

    return Status;
}

NTSTATUS
DbgKdReadVirtualMemoryNow(
    IN ULONG64 TargetBaseAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesRead
    )

/*++

Routine Description:

    This function reads the specified data from the system being debugged
    using the current mapping of the processor.

Arguments:

    TargetBaseAddress - Supplies the base address of the memory to read
        from the system being debugged.  The virtual address is in terms
        of the current mapping for the processor that reported the last
        state change.  Until we figure out how to do this differently,
        the virtual address must refer to a valid page (although it does
        not necesserily have to be in the TB).

    UserInterfaceBuffer - Supplies the address of the buffer in the user
        interface that data read is to be placed.

    TransferCount - Specifies the number of bytes to read.

    ActualBytesRead - Supplies a pointer to the variable that receives the
        the number of bytes actually read.

Return Value:

    If the read operation is successful, then a success status is returned.
    Otherwise, and unsuccessful status is returned.

--*/

{

    ULONG cb;
    DBGKD_MANIPULATE_STATE64 m;
    ULONG rc;
    PDBGKD_MANIPULATE_STATE64 Reply;
    NTSTATUS Status = STATUS_SUCCESS;

    if (g_VirtualCache.m_ForceDecodePTEs)
    {
        return DbgKdReadVirtualTranslatedMemory(TargetBaseAddress,
                                                UserInterfaceBuffer,
                                                TransferCount,
                                                ActualBytesRead);
    }

    cb = 0;
    while (TransferCount != 0)
    {
        //
        // Exit on user interrupt
        //
        if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
        {
            // dprintf("User interrupt during memory read - exiting.\n");
            ActualBytesRead = 0;
            return  STATUS_CONTROL_C_EXIT;
        }

        //
        // Initialize state manipulate message to read virtual memory.
        //

        m.ApiNumber = DbgKdReadVirtualMemoryApi;
        m.u.ReadMemory.TargetBaseAddress = TargetBaseAddress + cb;
        m.u.ReadMemory.TransferCount = min(TransferCount, PACKET_MAX_SIZE);

        //
        // Send the read virtual message to the target system and wait for
        // a reply.
        //

        do
        {
            g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                          PACKET_TYPE_KD_STATE_MANIPULATE,
                                          NULL, 0);
            rc = g_DbgKdTransport->
                WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
        }
        while ((rc != DBGKD_WAIT_PACKET) ||
               (Reply->ApiNumber != DbgKdReadVirtualMemoryApi));

        //
        // If the read virtual is successful, then copy the next segment
        // of data to the target buffer. Otherwise, terminate the read and
        // return the number of bytes read.
        //

        Status = Reply->ReturnStatus;
        if (!NT_SUCCESS(Status))
        {
            break;
        }
        else if (Reply->u.ReadMemory.ActualBytesRead == 0)
        {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }
        else
        {
            ULONG Copy;

            if (Reply->u.ReadMemory.ActualBytesRead > TransferCount)
            {
                ErrOut("DbgKdReadVirtualMemoryNow: Asked for %d, got %d\n",
                       TransferCount, Reply->u.ReadMemory.ActualBytesRead);
                Copy = TransferCount;
            }
            else
            {
                Copy = Reply->u.ReadMemory.ActualBytesRead;
            }

            memcpy((PUCHAR)UserInterfaceBuffer + cb,
                   Reply + 1,
                   Copy);

            TransferCount -= Copy;
            cb += Copy;
        }
    }

    //
    // Set the number of bytes actually read and return the status of the
    // read operation.
    //

    *ActualBytesRead = cb;

    KdOut("DbgKdReadVirtualMemoryNow(%s) returns %08lx, %X read\n",
          FormatAddr64(TargetBaseAddress), Status, cb);

    return Status;
}

NTSTATUS
DbgKdWriteVirtualMemoryNow(
    IN ULONG64 TargetBaseAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesWritten
    )

/*++

Routine Description:

    This function writes the specified data to the system being debugged
    using the current mapping of the processor.

Arguments:

    TargetBaseAddress - Supplies the base address of the memory to be written
        into the system being debugged.  The virtual address is in terms
        of the current mapping for the processor that reported the last
        state change.  Until we figure out how to do this differently,
        the virtual address must refer to a valid page (although it does
        not necessarily have to be in the TB).

    UserInterfaceBuffer - Supplies the address of the buffer in the user
        interface that contains the data to be written.

    TransferCount - Specifies the number of bytes to write.

    ActualBytesWritten - Supplies a pointer to a variable that receives the
        actual number of bytes written.

Return Value:

    If the write operation is successful, then a success status is returned.
    Otherwise, and unsuccessful status is returned.

--*/

{

    ULONG cb;
    DBGKD_MANIPULATE_STATE64 m;
    ULONG rc;
    PDBGKD_MANIPULATE_STATE64 Reply;
    NTSTATUS Status = STATUS_SUCCESS;

    DBG_ASSERT(g_TargetMachine->m_Ptr64 ||
               EXTEND64((ULONG)TargetBaseAddress) == TargetBaseAddress);

    if (g_VirtualCache.m_ForceDecodePTEs)
    {
        return DbgKdWriteVirtualTranslatedMemory(TargetBaseAddress,
                                                 UserInterfaceBuffer,
                                                 TransferCount,
                                                 ActualBytesWritten);
    }

    cb = 0;
    while (TransferCount != 0)
    {
        //
        // Initialize state manipulate message to write virtual memory.
        //

        m.ApiNumber = DbgKdWriteVirtualMemoryApi;
        m.u.WriteMemory.TargetBaseAddress = TargetBaseAddress + cb;
        m.u.WriteMemory.TransferCount = min(TransferCount, PACKET_MAX_SIZE);

        //
        // Send the write message and data to the target system and wait
        // for a reply.
        //

        do
        {
            g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                          PACKET_TYPE_KD_STATE_MANIPULATE,
                                          (PUCHAR)UserInterfaceBuffer + cb,
                                          (USHORT)m.u.WriteMemory.
                                          TransferCount);

            rc = g_DbgKdTransport->
                WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
        }
        while ((rc != DBGKD_WAIT_PACKET) ||
               (Reply->ApiNumber != DbgKdWriteVirtualMemoryApi));

        //
        // If the write virtual is successful, then update the byte count
        // and write the next data segment. Otherwise, terminate the write
        // and return the number of bytes written.
        //

        Status = Reply->ReturnStatus;
        if (!NT_SUCCESS(Status))
        {
            break;
        }
        else
        {
            TransferCount -= Reply->u.ReadMemory.ActualBytesRead;
            cb += Reply->u.ReadMemory.ActualBytesRead;
        }
    }

    //
    // Set the number of bytes actually written and return the status of the
    // write operation.
    //

    *ActualBytesWritten = cb;

    KdOut("DbgKdWriteVirtualMemory returns %08lx\n", Status);

    return Status;
}

NTSTATUS
DbgKdReadVirtualTranslatedMemory(
    IN ULONG64 TargetBaseAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesRead
    )
{
    NTSTATUS Status;
    ULONG64  TargetPhysicalAddress;

    if (TransferCount == 0)
    {
        return STATUS_SUCCESS;
    }

    ULONG Levels;
    ULONG PfIndex;
    
    if (g_TargetMachine->
        GetVirtualTranslationPhysicalOffsets(TargetBaseAddress, NULL, 0,
                                             &Levels, &PfIndex,
                                             &TargetPhysicalAddress) == S_OK)
    {
        Status = DbgKdReadPhysicalMemory(TargetPhysicalAddress,
                                         UserInterfaceBuffer,
                                         TransferCount,
                                         ActualBytesRead);
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

NTSTATUS
DbgKdWriteVirtualTranslatedMemory(
    IN ULONG64 TargetBaseAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesWritten OPTIONAL
    )
{
    NTSTATUS Status;
    ULONG64  TargetPhysicalAddress;

    ULONG Levels;
    ULONG PfIndex;
    
    if (g_TargetMachine->
        GetVirtualTranslationPhysicalOffsets(TargetBaseAddress, NULL, 0,
                                             &Levels, &PfIndex,
                                             &TargetPhysicalAddress) == S_OK)
    {
        Status = DbgKdWritePhysicalMemory(TargetPhysicalAddress,
                                          UserInterfaceBuffer,
                                          TransferCount,
                                          ActualBytesWritten);
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

NTSTATUS
DbgKdReadControlSpace(
    IN ULONG Processor,
    IN ULONG  OffsetAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesRead
    )

/*++

Routine Description:

    This function reads the specified data from the control space of
    the system being debugged.

    Control space is processor dependent. TargetBaseAddress is mapped
    to control space in a processor/implementation defined manner.

Arguments:

    Processor - Supplies the processor whoes control space is desired.

    OffsetAddress - Supplies the base address in control space to
        read. This address is interpreted in an implementation defined
        manner.

    UserInterfaceBuffer - Supplies the address of the buffer in the user
        interface that data read is to be placed.

    TransferCount - Specifies the number of bytes to read.

    ActualBytesRead - Specifies the number of bytes actually read.

Return Value:

    STATUS_SUCCESS - The specified read occured.

    STATUS_BUFFER_OVERFLOW - A read that is to large was specified.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_READ_MEMORY64 a = &m.u.ReadMemory;
    NTSTATUS st = STATUS_UNSUCCESSFUL;
    ULONG rc;
    ULONG Read;

    if ( TransferCount + sizeof(m) > PACKET_MAX_SIZE )
    {
        st = STATUS_BUFFER_OVERFLOW;
    }
    else
    {
        //
        // Format state manipulate message
        //

        m.ApiNumber = DbgKdReadControlSpaceApi;
        m.ReturnStatus = STATUS_PENDING;
        m.Processor = (SHORT)Processor;
        a->TargetBaseAddress = OffsetAddress;
        a->TransferCount = TransferCount;
        a->ActualBytesRead = 0L;

        //
        // Send the message and then wait for reply
        //

        do
        {
            g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                          PACKET_TYPE_KD_STATE_MANIPULATE,
                                          NULL, 0);
            rc = g_DbgKdTransport->
                WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
        } while (rc != DBGKD_WAIT_PACKET ||
                 Reply->ApiNumber != DbgKdReadControlSpaceApi);

        st = Reply->ReturnStatus;

        //
        // Reset message address to reply.
        //

        a = &Reply->u.ReadMemory;
        DBG_ASSERT(a->ActualBytesRead <= TransferCount);

        //
        // Return actual bytes read, and then transfer the bytes
        //

        if (ARGUMENT_PRESENT(ActualBytesRead)) {
            *ActualBytesRead = a->ActualBytesRead;
        }

        //
        // Since read response data follows message, Reply+1 should point
        // at the data
        //

        memcpy(UserInterfaceBuffer, Reply+1, (int)a->ActualBytesRead);
    }

    KdOut("DbgKdReadControlSpace returns %08lx\n", st);

    return st;
}

NTSTATUS
DbgKdWriteControlSpace(
    IN ULONG Processor,
    IN ULONG  OffsetAddress,
    IN PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesWritten
    )

/*++

Routine Description:

    This function writes the specified data to control space on the system
    being debugged.

    Control space is processor dependent. TargetBaseAddress is mapped
    to control space in a processor/implementation defined manner.

Arguments:

    Processor - Supplies the processor whoes control space is desired.

    OffsetAddress - Supplies the base address in control space to be
        written.

    UserInterfaceBuffer - Supplies the address of the buffer in the user
        interface that contains the data to be written.

    TransferCount - Specifies the number of bytes to write.

    ActualBytesWritten - Specifies the number of bytes actually written.

Return Value:

    STATUS_SUCCESS - The specified read occured.

    STATUS_BUFFER_OVERFLOW - A read that is to large was specified.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_WRITE_MEMORY64 a = &m.u.WriteMemory;
    NTSTATUS st;
    ULONG rc;

    if ( TransferCount + sizeof(m) > PACKET_MAX_SIZE ) {
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdWriteControlSpaceApi;
    m.ReturnStatus = STATUS_PENDING;
    m.Processor = (USHORT) Processor;
    a->TargetBaseAddress = OffsetAddress;
    a->TransferCount = TransferCount;
    a->ActualBytesWritten = 0L;

    //
    // Send the message and data to write and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      UserInterfaceBuffer,
                                      (USHORT)TransferCount);

        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdWriteControlSpaceApi);

    st = Reply->ReturnStatus;

    a = &Reply->u.WriteMemory;
    DBG_ASSERT(a->ActualBytesWritten <= TransferCount);

    //
    // Return actual bytes written
    //

    *ActualBytesWritten = a->ActualBytesWritten;

    KdOut("DbgWriteControlSpace returns %08lx\n", st);

    return st;
}


NTSTATUS
DbgKdGetContext(
    IN ULONG Processor,
    PCROSS_PLATFORM_CONTEXT Context
    )

/*++

Routine Description:

    This function reads the context from the system being debugged.
    The ContextFlags field determines how much context is read.

Arguments:

    Processor - Supplies a processor number to get context from.

    Context - On input, the ContextFlags field controls what portions of
        the context record the caller as interested in reading.  On
        output, the context record returns the current context for the
        processor that reported the last state change.

Return Value:

    STATUS_SUCCESS - The specified get context occured.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_GET_CONTEXT a = &m.u.GetContext;
    NTSTATUS st;
    ULONG rc;

    if (g_TargetMachine == NULL) {
        return STATUS_DEVICE_NOT_READY;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdGetContextApi;
    m.ReturnStatus = STATUS_PENDING;
    m.Processor = (USHORT) Processor;

    //
    // Send the message and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdGetContextApi);

    st = Reply->ReturnStatus;

    //
    // Since get context response data follows message, Reply+1 should point
    // at the data
    //

    memcpy(Context, Reply+1, g_TargetMachine->m_SizeTargetContext);

    KdOut("DbgKdGetContext returns %08lx\n", st);

    return st;
}

NTSTATUS
DbgKdSetContext(
    IN ULONG Processor,
    PCROSS_PLATFORM_CONTEXT Context
    )

/*++

Routine Description:

    This function writes the specified context to the system being debugged.

Arguments:

    Processor - Supplies a processor number to set the context to.

    Context - Supplies a context record used to set the context for the
        processor that reported the last state change.  Only the
        portions of the context indicated by the ContextFlags field are
        actually written.


Return Value:

    STATUS_SUCCESS - The specified set context occured.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_SET_CONTEXT a = &m.u.SetContext;
    NTSTATUS st;
    ULONG rc;

    if (g_TargetMachine == NULL) {
        return STATUS_DEVICE_NOT_READY;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdSetContextApi;
    m.ReturnStatus = STATUS_PENDING;
    m.Processor = (USHORT) Processor;

    //
    // Send the message and context and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      Context,
                                      (USHORT)g_TargetMachine->
                                      m_SizeTargetContext);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdSetContextApi);

    st = Reply->ReturnStatus;

    KdOut("DbgKdSetContext returns %08lx\n", st);

    return st;
}


NTSTATUS
DbgKdWriteBreakPoint(
    IN ULONG64 BreakPointAddress,
    OUT PULONG_PTR BreakPointHandle
    )

/*++

Routine Description:

    This function is used to write a breakpoint at the address specified.


Arguments:

    BreakPointAddress - Supplies the address that a breakpoint
        instruction is to be written.  This address is interpreted using
        the current mapping on the processor reporting the previous
        state change.  If the address refers to a page that is not
        valid, the the breakpoint is remembered by the system.  As each
        page is made valid, the system will check for pending
        breakpoints and install breakpoints as necessary.

    BreakPointHandle - Returns a handle to a breakpoint.  This handle
        may be used in a subsequent call to DbgKdRestoreBreakPoint.

Return Value:

    STATUS_SUCCESS - The specified breakpoint write occured.

--*/

{

    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_WRITE_BREAKPOINT64 a = &m.u.WriteBreakPoint;
    NTSTATUS st;
    ULONG rc;

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdWriteBreakPointApi;
    m.ReturnStatus = STATUS_PENDING;
    a->BreakPointAddress = BreakPointAddress;

    //
    // Send the message and context and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdWriteBreakPointApi);

    st = Reply->ReturnStatus;

    *BreakPointHandle = Reply->u.WriteBreakPoint.BreakPointHandle;

    KdOut("DbgKdWriteBreakPoint(%s) returns %08lx, %x\n",
          FormatAddr64(BreakPointAddress), st,
          (ULONG)*BreakPointHandle);

    return st;
}


NTSTATUS
DbgKdRestoreBreakPoint(
    IN ULONG_PTR BreakPointHandle
    )

/*++

Routine Description:

    This function is used to restore a breakpoint to its original
    value.

Arguments:

    BreakPointHandle - Supplies a handle returned by
        DbgKdWriteBreakPoint.  This handle must refer to a valid
        address.  The contents of the address must also be a breakpoint
        instruction.  If both of these are true, then the original value
        at the breakpoint address is restored.

Return Value:

    STATUS_SUCCESS - The specified breakpoint restore occured.

--*/

{

    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_RESTORE_BREAKPOINT a = &m.u.RestoreBreakPoint;
    NTSTATUS st;
    ULONG rc;

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdRestoreBreakPointApi;
    m.ReturnStatus = STATUS_PENDING;
    a->BreakPointHandle = (ULONG)BreakPointHandle;

    //
    // Send the message and context and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdRestoreBreakPointApi);

    st = Reply->ReturnStatus;

    KdOut("DbgKdRestoreBreakPoint(%x) returns %08lx\n",
          (ULONG)BreakPointHandle, st);

    return st;
}


NTSTATUS
DbgKdReadIoSpace(
    IN ULONG64 IoAddress,
    OUT PVOID ReturnedData,
    IN ULONG DataSize
    )

/*++

Routine Description:

    This function is used read a byte, short, or long (1,2,4 bytes) from
    the specified I/O address.

Arguments:

    IoAddress - Supplies the Io address to read from.

    ReturnedData - Supplies the value read from the I/O address.

    DataSize - Supplies the size in bytes to read. Values of 1, 2, or
        4 are accepted.

Return Value:

    STATUS_SUCCESS - Data was successfully read from the I/O
        address.

    STATUS_INVALID_PARAMETER - A DataSize value other than 1,2, or 4 was
        specified.

--*/

{

    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_READ_WRITE_IO64 a = &m.u.ReadWriteIo;
    NTSTATUS st;
    ULONG rc;

    switch ( DataSize )
    {
    case 1:
    case 2:
    case 4:
        break;
    default:
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdReadIoSpaceApi;
    m.ReturnStatus = STATUS_PENDING;

    a->DataSize = DataSize;
    a->IoAddress = IoAddress;

    //
    // Send the message and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdReadIoSpaceApi);

    st = Reply->ReturnStatus;

    a = &Reply->u.ReadWriteIo;

    switch ( DataSize )
    {
    case 1:
        *(PUCHAR)ReturnedData = (UCHAR)a->DataValue;
        break;
    case 2:
        *(PUSHORT)ReturnedData = (USHORT)a->DataValue;
        break;
    case 4:
        *(PULONG)ReturnedData = a->DataValue;
        break;
    }

    KdOut("DbgKdReadIoSpace returns %08lx\n", st);

    return st;
}


NTSTATUS
DbgKdWriteIoSpace(
    IN ULONG64 IoAddress,
    IN ULONG DataValue,
    IN ULONG DataSize
    )

/*++

Routine Description:

    This function is used write a byte, short, or long (1,2,4 bytes) to
    the specified I/O address.

Arguments:

    IoAddress - Supplies the Io address to write to.

    DataValue - Supplies the value to write to the I/O address.

    DataSize - Supplies the size in bytes to write. Values of 1, 2, or
        4 are accepted.

Return Value:

    STATUS_SUCCESS - Data was successfully written to the I/O
        address.

    STATUS_INVALID_PARAMETER - A DataSize value other than 1,2, or 4 was
        specified.

--*/

{

    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_READ_WRITE_IO64 a = &m.u.ReadWriteIo;
    NTSTATUS st;
    ULONG rc;

    switch ( DataSize ) {
        case 1:
        case 2:
        case 4:
            break;
        default:
            return STATUS_INVALID_PARAMETER;
        }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdWriteIoSpaceApi;
    m.ReturnStatus = STATUS_PENDING;

    a->DataSize = DataSize;
    a->IoAddress = IoAddress;
    a->DataValue = DataValue;

    //
    // Send the message and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdWriteIoSpaceApi);

    st = Reply->ReturnStatus;

    KdOut("DbgKdWriteIoSpace returns %08lx\n", st);

    return st;
}


NTSTATUS
DbgKdReadMsr(
    IN ULONG MsrReg,
    OUT PULONGLONG MsrValue
    )

/*++

Routine Description:

    This function is used read a MSR at the specified location

Arguments:

    MsrReg  - Which model specific register to read

    MsrValue - Its value

Return Value:

    STATUS_SUCCESS - Data was successfully read from the I/O
        address.

    STATUS_INVALID_PARAMETER - A DataSize value other than 1,2, or 4 was
        specified.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_READ_WRITE_MSR a = &m.u.ReadWriteMsr;
    LARGE_INTEGER li;
    NTSTATUS st;
    ULONG rc;

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdReadMachineSpecificRegister;
    m.ReturnStatus = STATUS_PENDING;

    a->Msr = MsrReg;

    //
    // Send the message and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdReadMachineSpecificRegister);

    st = Reply->ReturnStatus;

    a = &Reply->u.ReadWriteMsr;

    li.LowPart = a->DataValueLow;
    li.HighPart = a->DataValueHigh;
    *MsrValue = li.QuadPart;

    KdOut("DbgKdReadMsr returns %08lx\n", st);

    return st;
}


NTSTATUS
DbgKdWriteMsr(
    IN ULONG MsrReg,
    IN ULONGLONG MsrValue
    )

/*++

Routine Description:

    This function is used write a MSR to the specified location

Arguments:

    MsrReg  - Which model specific register to read
    MsrValue - It's value

Return Value:

    STATUS_SUCCESS - Data was successfully written to the I/O
        address.

    STATUS_INVALID_PARAMETER - A DataSize value other than 1,2, or 4 was
        specified.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_READ_WRITE_MSR a = &m.u.ReadWriteMsr;
    LARGE_INTEGER li;
    NTSTATUS st;
    ULONG rc;

    li.QuadPart = MsrValue;

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdWriteMachineSpecificRegister;
    m.ReturnStatus = STATUS_PENDING;

    // Quiet PREfix warnings.
    m.Processor = 0;
    m.ProcessorLevel = 0;

    a->Msr = MsrReg;
    a->DataValueLow = li.LowPart;
    a->DataValueHigh = li.HighPart;

    //
    // Send the message and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdWriteMachineSpecificRegister);

    st = Reply->ReturnStatus;

    KdOut("DbgKdWriteMsr returns %08lx\n", st);

    return st;
}



NTSTATUS
DbgKdReadIoSpaceExtended(
    IN ULONG64 IoAddress,
    OUT PVOID ReturnedData,
    IN ULONG DataSize,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace
    )

/*++

Routine Description:

    This function is used read a byte, short, or long (1,2,4 bytes) from
    the specified I/O address.

Arguments:

    IoAddress - Supplies the Io address to read from.

    ReturnedData - Supplies the value read from the I/O address.

    DataSize - Supplies the size in bytes to read. Values of 1, 2, or
        4 are accepted.

    InterfaceType - The type of interface for the bus.

    BusNumber - The bus number of the bus to be used. Normally this would
        be zero.

    AddressSpace - This contains a zero if we are using I/O memory space,
        else it contains a one if we are using I/O port space.

Return Value:

    STATUS_SUCCESS - Data was successfully read from the I/O
        address.

    STATUS_INVALID_PARAMETER - A DataSize value other than 1,2, or 4 was
        specified.

--*/

{

    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_READ_WRITE_IO_EXTENDED64 a = &m.u.ReadWriteIoExtended;
    NTSTATUS st;
    ULONG rc;

    switch ( DataSize )
    {
    case 1:
    case 2:
    case 4:
        break;
    default:
        return STATUS_INVALID_PARAMETER;
    }

    if ( !(AddressSpace == 0 || AddressSpace == 1) )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdReadIoSpaceExtendedApi;
    m.ReturnStatus = STATUS_PENDING;

    a->DataSize = DataSize;
    a->IoAddress = IoAddress;
    a->InterfaceType = InterfaceType;
    a->BusNumber = BusNumber;
    a->AddressSpace = AddressSpace;

    //
    // Send the message and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdReadIoSpaceExtendedApi);

    st = Reply->ReturnStatus;

    a = &Reply->u.ReadWriteIoExtended;

    switch ( DataSize )
    {
    case 1:
        *(PUCHAR)ReturnedData = (UCHAR)a->DataValue;
        break;
    case 2:
        *(PUSHORT)ReturnedData = (USHORT)a->DataValue;
        break;
    case 4:
        *(PULONG)ReturnedData = a->DataValue;
        break;
    }

    KdOut("DbgKdReadIoSpaceExtended returns %08lx\n", st);

    return st;
}

NTSTATUS
DbgKdWriteIoSpaceExtended(
    IN ULONG64 IoAddress,
    IN ULONG DataValue,
    IN ULONG DataSize,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace
    )

/*++

Routine Description:

    This function is used write a byte, short, or long (1,2,4 bytes) to
    the specified I/O address.

Arguments:

    IoAddress - Supplies the Io address to write to.

    DataValue - Supplies the value to write to the I/O address.

    DataSize - Supplies the size in bytes to write. Values of 1, 2, or
        4 are accepted.

Return Value:

    STATUS_SUCCESS - Data was successfully written to the I/O
        address.

    STATUS_INVALID_PARAMETER - A DataSize value other than 1,2, or 4 was
        specified.

--*/

{

    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_READ_WRITE_IO_EXTENDED64 a = &m.u.ReadWriteIoExtended;
    NTSTATUS st;
    ULONG rc;

    switch ( DataSize )
    {
    case 1:
    case 2:
    case 4:
        break;
    default:
        return STATUS_INVALID_PARAMETER;
    }

    if ( !(AddressSpace == 0 || AddressSpace == 1) )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdWriteIoSpaceExtendedApi;
    m.ReturnStatus = STATUS_PENDING;

    a->DataSize = DataSize;
    a->IoAddress = IoAddress;
    a->DataValue = DataValue;
    a->InterfaceType = InterfaceType;
    a->BusNumber = BusNumber;
    a->AddressSpace = AddressSpace;

    //
    // Send the message and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdWriteIoSpaceExtendedApi);

    st = Reply->ReturnStatus;

    KdOut("DbgKdWriteIoSpaceExtended returns %08lx\n", st);

    return st;
}


NTSTATUS
DbgKdGetBusData(
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This function is used to read I/O configuration space.

Arguments:

    BusDataType - BUS_DATA_TYPE

    BusNumber - Bus number.

    SlotNumber - Slot number.

    Buffer - Buffer to receive bus data.

    Offset - Offset.

    Length - Length.

Return Value:

    STATUS_SUCCESS - Data was successfully read from
        configuration space.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
        PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_GET_SET_BUS_DATA a = &m.u.GetSetBusData;
    NTSTATUS st;
    ULONG rc;

    //
    // Check the buffer size.
    //

    if (*Length > PACKET_MAX_SIZE - sizeof (DBGKD_MANIPULATE_STATE64))
    {
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdGetBusDataApi;
    m.ReturnStatus = STATUS_PENDING;

    a->BusDataType = BusDataType;
    a->BusNumber = BusNumber;
    a->SlotNumber = SlotNumber;
    a->Offset = Offset;
    a->Length = *Length;

    //
    // Send the message and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdGetBusDataApi);

    st = Reply->ReturnStatus;

    a = &Reply->u.GetSetBusData;

    if (NT_SUCCESS(st))
    {
        memcpy(Buffer, Reply + 1, a->Length);
        *Length = a->Length;
    }

    KdOut("DbgKdGetBusData returns %08lx\n", st);

    return st;
}


NTSTATUS
DbgKdSetBusData(
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This function is used to write I/O configuration space.

Arguments:

    BusDataType - BUS_DATA_TYPE

    BusNumber - Bus number.

    SlotNumber - Slot number.

    Buffer - Buffer containing bus data.

    Offset - Offset.

    Length - Length.

Return Value:

    STATUS_SUCCESS - Data was successfully written to
        configuration space.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_GET_SET_BUS_DATA a = &m.u.GetSetBusData;
    NTSTATUS st;
    ULONG rc;

    //
    // Check the buffer size.
    //

    if (*Length > PACKET_MAX_SIZE - sizeof (DBGKD_MANIPULATE_STATE64))
    {
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdSetBusDataApi;
    m.ReturnStatus = STATUS_PENDING;

    a->BusDataType = BusDataType;
    a->BusNumber = BusNumber;
    a->SlotNumber = SlotNumber;
    a->Offset = Offset;
    a->Length = *Length;

    //
    // Send the message and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      Buffer, (USHORT)*Length);

        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdSetBusDataApi);

    st = Reply->ReturnStatus;

    if (NT_SUCCESS(st))
    {
        a = &Reply->u.GetSetBusData;
        *Length = a->Length;
    }

    KdOut("DbgKdSetBusData returns %08lx\n", st);

    return st;
}


NTSTATUS
DbgKdGetVersion (
    PDBGKD_GET_VERSION64 GetVersion
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_GET_VERSION64 a = &m.u.GetVersion64;
    DWORD st;
    ULONG rc;

    m.ApiNumber = DbgKdGetVersionApi;
    m.ReturnStatus = STATUS_PENDING;
    a->ProtocolVersion = 1;  // request context records on state changes

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET);

    st = Reply->ReturnStatus;

    *GetVersion = Reply->u.GetVersion64;

    KdOut("DbgKdGetVersion returns %08lx\n", st);

    return st;
}


NTSTATUS
DbgKdReboot(
    VOID
    )

/*++

Routine Description:

    This function reboots being debugged.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdRebootApi;
    m.ReturnStatus = STATUS_PENDING;

    //
    // Send the message.
    //

    g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                  PACKET_TYPE_KD_STATE_MANIPULATE,
                                  NULL, 0);
    InvalidateMemoryCaches();

    KdOut("DbgKdReboot returns 0x00000000\n");

    return STATUS_SUCCESS;
}


NTSTATUS
DbgKdCrash(
    DWORD BugCheckCode
    )

/*++

Routine Description:

    This function reboots being debugged.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdCauseBugCheckApi;
    m.ReturnStatus = STATUS_PENDING;
    *(PULONG)&m.u = BugCheckCode;

    //
    // Send the message.
    //

    g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                  PACKET_TYPE_KD_STATE_MANIPULATE,
                                  NULL, 0);
    InvalidateMemoryCaches();

    KdOut("DbgKdCrash returns 0x00000000\n");

    return STATUS_SUCCESS;
}


NTSTATUS
DbgKdReadPhysicalMemory(
    IN ULONG64 TargetBaseAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesRead OPTIONAL
    )

/*++

Routine Description:

    This function reads the specified data from the physical memory of
    the system being debugged.

Arguments:

    TargetBaseAddress - Supplies the physical address of the memory to read
        from the system being debugged.

    UserInterfaceBuffer - Supplies the address of the buffer in the user
        interface that data read is to be placed.

    TransferCount - Specifies the number of bytes to read.

    ActualBytesRead - An optional parameter that if supplied, returns
        the number of bytes actually read.

Return Value:

    STATUS_SUCCESS - The specified read occured.

    STATUS_BUFFER_OVERFLOW - A read that is too large was specified.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_READ_MEMORY64 a;
    NTSTATUS st;
    ULONG rc;
    ULONG cb, cb2;

    cb2 = 0;

    if (ARGUMENT_PRESENT(ActualBytesRead)) {
        *ActualBytesRead = 0;
    }

readmore:

    cb = TransferCount;
    if (cb > PACKET_MAX_SIZE) {
        cb = PACKET_MAX_SIZE;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdReadPhysicalMemoryApi;
    m.ReturnStatus = STATUS_PENDING;

    a = &m.u.ReadMemory;
    a->TargetBaseAddress = TargetBaseAddress+cb2;
    a->TransferCount = cb;
    a->ActualBytesRead = 0L;

    //
    // Send the message and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdReadPhysicalMemoryApi);

    st = Reply->ReturnStatus;

    a = &Reply->u.ReadMemory;
    DBG_ASSERT(a->ActualBytesRead <= cb);

    //
    // Return actual bytes read, and then transfer the bytes
    //

    if (ARGUMENT_PRESENT(ActualBytesRead)) {
        *ActualBytesRead += a->ActualBytesRead;
    }

    //
    // Since read response data follows message, Reply+1 should point
    // at the data
    //

    if (NT_SUCCESS(st))
    {
        memcpy((PCHAR)((ULONG_PTR) UserInterfaceBuffer+cb2), Reply+1, (int)a->ActualBytesRead);

        TransferCount -= a->ActualBytesRead;

        if (TransferCount)
        {
            cb2 += a->ActualBytesRead;
            goto readmore;
        }
    }

    KdOut("DbgKdReadPhysical memory TargetBaseAddress %s, status %08lx\n",
          FormatAddr64(TargetBaseAddress), st);

    return st;
}


NTSTATUS
DbgKdWritePhysicalMemory(
    IN ULONG64 TargetBaseAddress,
    OUT PVOID UserInterfaceBuffer,
    IN ULONG TransferCount,
    OUT PULONG ActualBytesWritten OPTIONAL
    )

/*++

Routine Description:

    This function writes the specified data to the physical memory of the
    system being debugged.

Arguments:

    TargetBaseAddress - Supplies the physical address of the memory to write
        to the system being debugged.

    UserInterfaceBuffer - Supplies the address of the buffer in the user
        interface that contains the data to be written.

    TransferCount - Specifies the number of bytes to write.

    ActualBytesWritten - An optional parameter that if supplied, returns
        the number of bytes actually written.

Return Value:

    STATUS_SUCCESS - The specified read occured.

    STATUS_BUFFER_OVERFLOW - A read that is to large was specified.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_WRITE_MEMORY64 a;
    NTSTATUS st;
    ULONG rc;
    ULONG cb, cb2;

    g_VirtualCache.Empty ();

    cb2 = 0;

    if (ARGUMENT_PRESENT(ActualBytesWritten)) {
        *ActualBytesWritten = 0;
    }

writemore:

    cb = TransferCount;
    if (cb > PACKET_MAX_SIZE) {
        cb = PACKET_MAX_SIZE;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdWritePhysicalMemoryApi;
    m.ReturnStatus = STATUS_PENDING;

    a = &m.u.WriteMemory;
    a->TargetBaseAddress = TargetBaseAddress+cb2;
    a->TransferCount = cb;
    a->ActualBytesWritten = 0L;

    //
    // Send the message and data to write and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      (PVOID)
                                      ((ULONG_PTR)UserInterfaceBuffer+cb2),
                                      (USHORT)cb);

        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdWritePhysicalMemoryApi);

    st = Reply->ReturnStatus;

    a = &Reply->u.WriteMemory;
    DBG_ASSERT(a->ActualBytesWritten <= cb);

    //
    // Return actual bytes written
    //

    if (ARGUMENT_PRESENT(ActualBytesWritten)) {
        *ActualBytesWritten += a->ActualBytesWritten;
    }

    if (NT_SUCCESS(st))
    {
        TransferCount -= a->ActualBytesWritten;

        if (TransferCount)
        {
            cb2 += a->ActualBytesWritten;
            goto writemore;
        }
    }

    KdOut("DbgKdWritePhysical memory %08lx\n", st);

    return st;
}


NTSTATUS
DbgKdCheckLowMemory(
    )

/*++

Routine Description:

    This function forces a call on the system being debugged that will check
    if physical pages lower than 4gb have a specific fill pattern.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - The specified read occured.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    ULONG rc;

    //
    // Format state manipulate message
    //

    RtlZeroMemory (&m, sizeof(m));
    m.ApiNumber = DbgKdCheckLowMemoryApi;
    m.ReturnStatus = STATUS_PENDING;

    //
    // We wait for an answer from the kernel side.
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);

        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);

    } while (rc != DBGKD_WAIT_PACKET);

    if (Reply->ReturnStatus != STATUS_SUCCESS)
    {
        dprintf ("Corrupted page with pfn %x \n", Reply->ReturnStatus);
    }

    KdOut("DbgKdCheckLowMemory 0x00000000\n");

    return STATUS_SUCCESS;
}


NTSTATUS
DbgKdSwitchActiveProcessor (
    IN ULONG ProcessorNumber
    )

/*++

Routine Description:


Arguments:

    ProcessorNumber -

Return Value:

    STATUS_SUCCESS - Successful call to DbgUiContinue

    STATUS_INVALID_PARAMETER - An invalid continue status or was
        specified.

--*/

{
    DBGKD_MANIPULATE_STATE64 m;

    m.ApiNumber   = (USHORT)DbgKdSwitchProcessor;
    m.Processor   = (USHORT)ProcessorNumber;

    // Quiet PREfix warnings.
    m.ProcessorLevel = 0;

    g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                  PACKET_TYPE_KD_STATE_MANIPULATE,
                                  NULL, 0);
    g_VirtualCache.Empty ();

    KdOut("DbgKdSwitchActiveProcessor 0x00000000\n");

    return STATUS_SUCCESS;
}

NTSTATUS
DbgKdSearchMemory(
    IN ULONG64 SearchAddress,
    IN ULONG64 SearchLength,
    IN PUCHAR Pattern,
    IN ULONG PatternLength,
    OUT PULONG64 FoundAddress
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_SEARCH_MEMORY a = &m.u.SearchMemory;
    ULONG rc;
    NTSTATUS st;

    KdOut("Search called %s, length %I64x\n",
          FormatAddr64(SearchAddress), SearchLength);

    *FoundAddress = 0;

    a->SearchAddress = SearchAddress;
    a->SearchLength = SearchLength;
    a->PatternLength = PatternLength;

    m.ApiNumber = DbgKdSearchMemoryApi;
    m.ReturnStatus = STATUS_PENDING;

    //
    // Send the message and data to write and then wait for reply
    //

    do
    {
        g_DbgKdTransport->WritePacket(&m, sizeof(m),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      Pattern, (USHORT)PatternLength);

        rc = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdSearchMemoryApi);

    st = Reply->ReturnStatus;

    if (NT_SUCCESS(st))
    {
        if (g_TargetMachine->m_Ptr64)
        {
            *FoundAddress = Reply->u.SearchMemory.FoundAddress;
        }
        else
        {
            *FoundAddress = EXTEND64(Reply->u.SearchMemory.FoundAddress);
        }
    }

    KdOut("DbgKdSearchMemory %08lx\n", st);

    return st;
}

NTSTATUS
DbgKdFillMemory(
    IN ULONG Flags,
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT PULONG Filled
    )
{
    DBGKD_MANIPULATE_STATE64 Manip;
    PDBGKD_MANIPULATE_STATE64 Reply;
    NTSTATUS Status = STATUS_SUCCESS;

    DBG_ASSERT(g_KdMaxManipulate > DbgKdFillMemoryApi &&
               (Flags & 0xffff0000) == 0 &&
               PatternSize <= PACKET_MAX_SIZE);

    // Invalidate any cached memory.
    if (Flags & DBGKD_FILL_MEMORY_VIRTUAL)
    {
        g_VirtualCache.Remove(Start, Size);
    }
    else if (Flags & DBGKD_FILL_MEMORY_PHYSICAL)
    {
        g_PhysicalCache.Remove(Start, Size);
    }
    
    //
    // Initialize state manipulate message to fill memory.
    //

    Manip.ApiNumber = DbgKdFillMemoryApi;
    Manip.u.FillMemory.Address = Start;
    Manip.u.FillMemory.Length = Size;
    Manip.u.FillMemory.Flags = (USHORT)Flags;
    Manip.u.FillMemory.PatternLength = (USHORT)PatternSize;
    
    //
    // Send the message and data to the target system and wait
    // for a reply.
    //

    ULONG Recv;

    do
    {
        g_DbgKdTransport->WritePacket(&Manip, sizeof(Manip),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      Pattern, (USHORT)PatternSize);
        Recv = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    }
    while ((Recv != DBGKD_WAIT_PACKET) ||
           (Reply->ApiNumber != DbgKdFillMemoryApi));

    Status = Reply->ReturnStatus;
    *Filled = Reply->u.FillMemory.Length;

    KdOut("DbgKdFillMemory returns %08lx\n", Status);
    return Status;
}

NTSTATUS
DbgKdQueryMemory(
    IN ULONG64 Address,
    IN ULONG InSpace,
    OUT PULONG OutSpace,
    OUT PULONG OutFlags
    )
{
    DBGKD_MANIPULATE_STATE64 Manip;
    PDBGKD_MANIPULATE_STATE64 Reply;
    NTSTATUS Status = STATUS_SUCCESS;

    DBG_ASSERT(g_KdMaxManipulate > DbgKdQueryMemoryApi);

    //
    // Initialize state manipulate message to query memory.
    //

    Manip.ApiNumber = DbgKdQueryMemoryApi;
    Manip.u.QueryMemory.Address = Address;
    Manip.u.QueryMemory.Reserved = 0;
    Manip.u.QueryMemory.AddressSpace = InSpace;
    Manip.u.QueryMemory.Flags = 0;
    
    //
    // Send the message and data to the target system and wait
    // for a reply.
    //

    ULONG Recv;

    do
    {
        g_DbgKdTransport->WritePacket(&Manip, sizeof(Manip),
                                      PACKET_TYPE_KD_STATE_MANIPULATE,
                                      NULL, 0);
        Recv = g_DbgKdTransport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    }
    while ((Recv != DBGKD_WAIT_PACKET) ||
           (Reply->ApiNumber != DbgKdQueryMemoryApi));

    Status = Reply->ReturnStatus;
    *OutSpace = Reply->u.QueryMemory.AddressSpace;
    *OutFlags = Reply->u.QueryMemory.Flags;

    KdOut("DbgKdQueryMemory returns %08lx\n", Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dbgkdtrans.hpp ===
//----------------------------------------------------------------------------
//
// KD hard-line communication support.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#ifndef __DBGKDTRANS_HPP__
#define __DBGKDTRANS_HPP__

#define PACKET_MAX_MANIP_SIZE \
    (PACKET_MAX_SIZE + sizeof(DBGKD_MANIPULATE_STATE64) - \
     sizeof(DBGKD_MANIPULATE_STATE32) + sizeof(KD_PACKET))

enum
{
    DBGKD_WRITE_PACKET,
    DBGKD_WRITE_RESEND,
};

enum
{
    DBGKD_WAIT_PACKET,
    DBGKD_WAIT_ACK,
    DBGKD_WAIT_RESYNC,
    DBGKD_WAIT_FAILED,
    DBGKD_WAIT_RESEND,
    DBGKD_WAIT_AGAIN,
};

enum
{
    DBGKD_TRANSPORT_COM,
    DBGKD_TRANSPORT_1394,
    DBGKD_TRANSPORT_COUNT
};

void InitKdFileAssoc(void);
void ParseKdFileAssoc(void);

class DbgKdTransport : public ParameterStringParser
{
public:
    //
    // DbgKdTransport.
    //

    void Restart(void);

    // Base implementation displays general information and
    // packets/bytes read/written.  It should be invoked
    // before derived operations.
    virtual void OutputInfo(void);
    
    // Base implementation creates events for overlapped operations.
    virtual HRESULT Initialize(void);
    // Base implementation cleans up events.
    virtual void    Uninitialize(void);
    
    virtual BOOL Read(IN PVOID Buffer,
                      IN ULONG SizeOfBuffer,
                      IN PULONG BytesRead) = 0;
    virtual BOOL Write(IN PVOID Buffer,
                       IN ULONG SizeOfBuffer,
                       IN PULONG BytesWritten) = 0;

    // Base implementation does nothing.
    virtual void CycleSpeed(void);

    virtual HRESULT ReadTargetPhysicalMemory(IN ULONG64 MemoryOffset,
                                             IN PVOID Buffer,
                                             IN ULONG SizeofBuffer,
                                             IN PULONG BytesRead);

    // This routine keeps on sending reset packet to target until reset packet
    // is acknowledged by a reset packet from target.
    //
    // N.B. This routine is intended to be used by kernel debugger at startup
    //      time (ONLY) to get packet control variables on both target and host
    //      back in synchronization.  Also, reset request will cause kernel to
    //      reset its control variables AND resend us its previous packet (with
    //      the new packet id).
    virtual VOID Synchronize(VOID) = 0;

    virtual ULONG ReadPacketContents(IN USHORT PacketType) = 0;
    virtual ULONG WritePacketContents(IN KD_PACKET* Packet,
                                      IN PVOID PacketData,
                                      IN USHORT PacketDataLength,
                                      IN PVOID MorePacketData OPTIONAL,
                                      IN USHORT MorePacketDataLength OPTIONAL,
                                      IN BOOL NoAck) = 0;

    ULONG HandleDebugIo(PDBGKD_DEBUG_IO Packet);
    ULONG HandleTraceIo(PDBGKD_TRACE_IO Packet);
    ULONG HandleControlRequest(PDBGKD_CONTROL_REQUEST Packet);
    ULONG HandleFileIo(PDBGKD_FILE_IO Packet);
    
    ULONG WaitForPacket(IN USHORT PacketType,
                        OUT PVOID Packet);

    VOID WriteBreakInPacket(VOID);
    VOID WriteControlPacket(IN USHORT PacketType,
                            IN ULONG PacketId OPTIONAL);
    VOID WriteDataPacket(IN PVOID PacketData,
                         IN USHORT PacketDataLength,
                         IN USHORT PacketType,
                         IN PVOID MorePacketData OPTIONAL,
                         IN USHORT MorePacketDataLength OPTIONAL,
                         IN BOOL NoAck);

    inline VOID WritePacket(IN PVOID PacketData,
                            IN USHORT PacketDataLength,
                            IN USHORT PacketType,
                            IN PVOID MorePacketData OPTIONAL,
                            IN USHORT MorePacketDataLength OPTIONAL)
    {
        WriteDataPacket(PacketData, PacketDataLength, PacketType,
                        MorePacketData, MorePacketDataLength, FALSE);
    }
    inline VOID WriteAsyncPacket(IN PVOID PacketData,
                                 IN USHORT PacketDataLength,
                                 IN USHORT PacketType,
                                 IN PVOID MorePacketData OPTIONAL,
                                 IN USHORT MorePacketDataLength OPTIONAL)
    {
        WriteDataPacket(PacketData, PacketDataLength, PacketType,
                        MorePacketData, MorePacketDataLength, TRUE);
    }

    ULONG ComputeChecksum(IN PUCHAR Buffer,
                          IN ULONG Length);

    // This save/restore isn't particularly elegant
    // but we need something like it.  We receive a state change
    // without knowing what kind of machine we're talking to.
    // We have to send/receive a GetVersion packet to get that
    // information, but we need to keep the original packet
    // information around while we do so.
    void SaveReadPacket(void)
    {
        memcpy(s_SavedPacket, s_Packet, sizeof(s_Packet));
        s_SavedPacketHeader = s_PacketHeader;
    }
    void RestoreReadPacket(void)
    {
        memcpy(s_Packet, s_SavedPacket, sizeof(s_Packet));
        s_PacketHeader = s_SavedPacketHeader;
    }

    ULONG m_Index;
    HANDLE m_Handle;
    BOOL m_DirectPhysicalMemory;
    ULONG m_InvPacketRetryLimit;
    BOOL m_AckWrites;

    //
    // This overlapped structure will be used for all serial read
    // operations. We only need one structure since the code is
    // designed so that no more than one serial read operation is
    // outstanding at any one time.
    //
    OVERLAPPED m_ReadOverlapped;

    //
    // This overlapped structure will be used for all serial write
    // operations. We only need one structure since the code is
    // designed so that no more than one serial write operation is
    // outstanding at any one time.
    //
    OVERLAPPED m_WriteOverlapped;

    ULONG m_PacketsRead;
    ULONG64 m_BytesRead;
    ULONG m_PacketsWritten;
    ULONG64 m_BytesWritten;
    
    // ID for expected incoming packet.
    ULONG m_PacketExpected;
    // ID for Next packet to send.
    ULONG m_NextPacketToSend;

    // Thread ID for thread in WaitStateChange.  Normally
    // multithreaded access to the transport is prevented by
    // the engine lock, but the engine lock is suspended
    // while WaitStateChange is doing its WaitPacketForever.
    // During that time other threads must be forcibly
    // prevented from using the kernel connection.
    ULONG m_WaitingThread;

    BOOL m_AllowInitialBreak;
    BOOL m_Resync;
    BOOL m_BreakIn;
    BOOL m_SyncBreakIn;
    BOOL m_ValidUnaccessedPacket;
    
    static UCHAR s_BreakinPacket[1];
    static UCHAR s_PacketTrailingByte[1];
    static UCHAR s_PacketLeader[4];

    static UCHAR s_Packet[PACKET_MAX_MANIP_SIZE];
    static KD_PACKET s_PacketHeader;

    static UCHAR s_SavedPacket[PACKET_MAX_MANIP_SIZE];
    static KD_PACKET s_SavedPacketHeader;
};

class DbgKdComTransport : public DbgKdTransport
{
public:
    DbgKdComTransport(void);

    // ParameterStringParser.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index, PSTR Name, PSTR Value);
    
    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    // DbgKdTransport.
    virtual HRESULT Initialize(void);
    virtual void    Uninitialize(void);

    virtual BOOL Read(IN PVOID Buffer,
                      IN ULONG SizeOfBuffer,
                      IN PULONG BytesRead);
    virtual BOOL Write(IN PVOID Buffer,
                       IN ULONG SizeOfBuffer,
                       IN PULONG BytesWritten);
    virtual void CycleSpeed(void);

    virtual VOID Synchronize(VOID);

    virtual ULONG ReadPacketContents(IN USHORT PacketType);
    virtual ULONG WritePacketContents(IN KD_PACKET* Packet,
                                      IN PVOID PacketData,
                                      IN USHORT PacketDataLength,
                                      IN PVOID MorePacketData OPTIONAL,
                                      IN USHORT MorePacketDataLength OPTIONAL,
                                      IN BOOL NoAck);

    //
    // DbgKdComTransport.
    //
    
    ULONG ReadPacketLeader(IN ULONG PacketType,
                           OUT PULONG PacketLeader);
    void CheckComStatus(void);
    DWORD SelectNewBaudRate(DWORD NewRate);

    char m_PortName[MAX_PARAM_VALUE + 8];
    ULONG m_BaudRate;
    BOOL m_Modem;
    ULONG m_Timeout;

    // Used to carrier detection.
    DWORD m_ComEvent;

    //
    // This overlapped structure will be used for all event operations.
    // We only need one structure since the code is designed so that no more
    // than one serial event operation is outstanding at any one time.
    //
    OVERLAPPED m_EventOverlapped;
};

enum 
{
    DBGKD_1394_OPERATION_MODE_DEBUG,
    DBGKD_1394_OPERATION_RAW_MEMORY_ACCESS
};

class DbgKd1394Transport : public DbgKdTransport
{
public:
    DbgKd1394Transport(void);

    // ParameterStringParser.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index, PSTR Name, PSTR Value);
    
    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    // DbgKdTransport.
    virtual HRESULT Initialize(void);
    virtual void    Uninitialize(void);

    virtual BOOL Read(IN PVOID Buffer,
                      IN ULONG SizeOfBuffer,
                      IN PULONG BytesRead);
    virtual BOOL Write(IN PVOID Buffer,
                       IN ULONG SizeOfBuffer,
                       IN PULONG BytesWritten);

    virtual HRESULT ReadTargetPhysicalMemory(IN ULONG64 MemoryOffset,
                                             IN PVOID Buffer,
                                             IN ULONG SizeofBuffer,
                                             IN PULONG BytesRead);

    virtual VOID Synchronize(VOID);

    virtual ULONG ReadPacketContents(IN USHORT PacketType);
    virtual ULONG WritePacketContents(IN KD_PACKET* Packet,
                                      IN PVOID PacketData,
                                      IN USHORT PacketDataLength,
                                      IN PVOID MorePacketData OPTIONAL,
                                      IN USHORT MorePacketDataLength OPTIONAL,
                                      IN BOOL NoAck);

    // DbgKd1394Transport.

    BOOL SwitchVirtualDebuggerDriverMode(IN ULONG NewMode);

    ULONG m_Channel;
    ULONG m_OperationMode;

    UCHAR m_TxPacket[PACKET_MAX_MANIP_SIZE];
};

extern DbgKdTransport* g_DbgKdTransport;

HRESULT
DbgKdConnectAndInitialize(PCSTR Options);

VOID
DbgKdpHandlePromptString(
    IN PDBGKD_DEBUG_IO IoMessage
    );

VOID
DbgKdpPrint(
    IN ULONG Processor,
    IN PCSTR String,
    IN USHORT StringLength,
    IN ULONG Mask
    );

VOID
DbgKdpPrintTrace(
    IN ULONG Processor,
    IN PUCHAR Data,
    IN USHORT DataLength,
    IN ULONG Mask
    );

#endif // #ifndef __DBGKDTRANS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dbgsym.hpp ===
//----------------------------------------------------------------------------
//
// Symbol interface implementations.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#ifndef __DBGSYM_HPP__
#define __DBGSYM_HPP__

//
// DEBUG_SYMBOL_PARAMETERS_INTERNAL Flags
//
// SYMF_REGISTER; SYMF_FRAMEREL; SYMF_REGREL
#define ADDRESS_TRANSLATION_MASK   (SYMF_REGISTER | SYMF_FRAMEREL | SYMF_REGREL)

#define SYMBOL_SCOPE_MASK          (SYMF_PARAMETER | SYMF_LOCAL)
// DBG_DUMP_FIELD_STRING          0xf0000
#define STRING_DUMP_MASK            DBG_DUMP_FIELD_STRING   
// TypeName 
#define TYPE_NAME_VALID            0x100
#define TYPE_NAME_USED             0x200
#define TYPE_NAME_CHANGED          0x400
#define TYPE_NAME_MASK             0xf00

// Used for locals when locals are added on change of scope
#define SYMBOL_IS_IN_SCOPE         0x1000

#define SYMBOL_IS_EXPRESSION       0x2000

#define SYMBOL_IS_EXTENSION        0x4000

typedef struct DEBUG_SYMBOL_PARAMETERS_INTERNAL {
    DEBUG_SYMBOL_PARAMETERS External;
    ULONG64 Address;
    ULONG64 Offset;
    ULONG   Register;
    ULONG   Flags;  
    ANSI_STRING Name;
    ULONG   SymbolIndex;
    ULONG   TypeIndex;
    ULONG   Size;

    // Deatails for eapanding this symbol
    BOOL    Expanded;
    ULONG64 ExpandTypeAddress;
    ULONG   ExpandTypeIndex;

    PVOID   DataBuffer; // For extensions support
    
    // Use a fixed size array for type name
    // TYPE_NAME_VALID is unset for larger / unavailable names.
    // TYPE_NAME_USED  is set when this name is used to type-cast the symbol
    CHAR    TypeName[64];
    
    ULONG64 Mask;         // For bitfields
    USHORT  Shift;

    DEBUG_SYMBOL_PARAMETERS_INTERNAL *Parent;
    DEBUG_SYMBOL_PARAMETERS_INTERNAL *Next;
} DEBUG_SYMBOL_PARAMETERS_INTERNAL, *PDEBUG_SYMBOL_PARAMETERS_INTERNAL;
//----------------------------------------------------------------------------
//
// DebugSymbolGroup.
//
//----------------------------------------------------------------------------

#define MAX_DISPLAY_NAME 256 // Not MAX_NAME
class DebugSymbolGroup : public IDebugSymbolGroup
{
public:
    DebugSymbolGroup(DebugClient *CreatedBy, ULONG ScopeGroup);
    DebugSymbolGroup(DebugClient *CreatedBy);
    ~DebugSymbolGroup(void);

    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugSymbolGroup.
    STDMETHOD(ShowAll)(
        THIS_
        );

    STDMETHOD(GetNumberSymbols)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(AddSymbol)(
        THIS_
        IN PCSTR Name,
        OUT PULONG Index
        );
    STDMETHOD(RemoveSymbolByName)(
        THIS_
        IN PCSTR Name
        );
    STDMETHOD(RemoveSymbolByIndex)(
        THIS_
        IN ULONG Index
        );
    STDMETHOD(GetSymbolName)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG NameSize
        );
    STDMETHOD(GetSymbolParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PDEBUG_SYMBOL_PARAMETERS Params
        );
    STDMETHOD(ExpandSymbol)(
        THIS_
        IN ULONG Index,
        IN BOOL Expand
        );
    STDMETHOD(OutputSymbols)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags,
        IN ULONG Start,
        IN ULONG Count
        );
    STDMETHOD(WriteSymbol)(
        THIS_
        IN ULONG Index,
        IN PCSTR Value
        );
    STDMETHOD(OutputAsType)(
        THIS_
        IN ULONG Index,
        IN PCSTR Type
        );
    
private:
    ULONG m_Refs;
    BOOL  m_Locals;
    ULONG m_ScopeGroup;
    ULONG m_NumParams;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL m_pSymParams;
    DebugClient  *m_pCreatedBy;
    BOOL    m_LastClassExpanded;
    ULONG   m_thisAdjust; // ThisAdjust value for this pointer in class function scope

    PDEBUG_SYMBOL_PARAMETERS_INTERNAL 
    LookupSymbolParameter(
            IN ULONG Index
            );
    
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL 
    LookupSymbolParameter(
            IN PCSTR Name
            );

    HRESULT AddOneSymbol(
        IN PCSTR Name,
        IN OPTIONAL PSYMBOL_INFO pSymInfo,
        OUT PULONG Index
        );
    
    VOID ResetIndex(
        IN PDEBUG_SYMBOL_PARAMETERS_INTERNAL Start,
        IN ULONG StartIndex
        );

    ULONG AddSymbolParameters(
        IN ULONG Index,
        IN ULONG Count,
        IN PDEBUG_SYMBOL_PARAMETERS_INTERNAL SymbolParam
        );

    ULONG DeleteSymbolParam(
        IN ULONG Index,
        IN ULONG Count
        );

    BOOL IsRootSymbol (
        IN ULONG Index
        );

    ULONG FindSortedIndex (
        IN PCSTR   Name,
        IN BOOL    IsArg,
        IN ULONG64 Address
        );

    HRESULT ResetCurrentLocals();
    
    HRESULT AddCurrentLocals();
    
    void KeepLastScopeClass(
        IN PDEBUG_SYMBOL_PARAMETERS_INTERNAL Sym_this,
        IN PCHAR ExpansionState,
        IN ULONG NumChilds
        );

    HRESULT ExpandSymPri(
        THIS_
        IN ULONG Index,
        IN BOOL Expand
        );
    
    static BOOL CALLBACK AddLocals(
        PSYMBOL_INFO    pSymInfo,
        ULONG           Size,
        PVOID           Context
        );

    HRESULT FindChildren(
        PDEBUG_SYMBOL_PARAMETERS_INTERNAL pParentSym,
        PDEBUG_SYMBOL_PARAMETERS_INTERNAL *pChildren,
        PULONG pChildCount,
        PCHAR *pChildNames
        );
};

typedef struct _ADDLOCALS_CTXT {
    DebugSymbolGroup *pGrp;
} ADDLOCALS_CTXT;

BOOL
GetThisAdjustForCurrentScope(
    PULONG thisAdjust
    );

// 
// Generated structs / entensions / extension function as DebugSymbolgroup
//
typedef enum _DGS_FIELD_TYPE {
    DGS_FldDefault,
    DGS_FldPointer,
    DGS_FldBit,
} DGS_FIELD_TYPE;

typedef struct _DBG_GENERATED_STRUCT_FIELDS {
    PCHAR    Name;
    ULONG    Offset;
    ULONG    Size;
    DGS_FIELD_TYPE Type;
    ULONG64  BitMask;
    USHORT   BitShift;
    PCHAR    StructType;             // If the filed has some subtypes,
                                     // This points to Name in the struct array
} DBG_GENERATED_STRUCT_FIELDS, *PDBG_GENERATED_STRUCT_FIELDS;

typedef enum _DGS_TYPE {
    DGS_DefaultStruct,
    DGS_EFN,
    DGS_Extension
} DGS_TYPE;

typedef struct _DBG_GENERATED_STRUCT_INFO {
    ULONG    Id;
    PCHAR    Name;
    ULONG    Size;
    DGS_TYPE Type;
    ULONG    NumFields;
    PDBG_GENERATED_STRUCT_FIELDS Fields;  // Last member must have NULL name.
} DBG_GENERATED_STRUCT_INFO, *PDBG_GENERATED_STRUCT_INFO;

//
// Extension function to let debugger know about any generated sturct
//              
//    pGenStructs:   This contains array of DBG_GENERATED_STRUCT_INFO
//                   for any generated structs the extension wants to support
//                   Last member should have NULL name.
//
// Following should be defined and exported from extension dlls for this purpose:
//
// BOOL _EFN_GetGeneratedStructInfo(PDEBUG_CLIENT Client, PDBG_GENERATED_STRUCT_INFO pGenStructs);
//
typedef BOOL
(WINAPI *EXT_GENERATED_STRUCT_INFO)(
     PDEBUG_CLIENT Client,
     PDBG_GENERATED_STRUCT_INFO *pGenStructs
     );
#endif // #ifndef __DBGSYM_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dbgsys.cpp ===
//----------------------------------------------------------------------------
//
// IDebugSystemObjects implementations.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

ULONG64 g_ImplicitThreadData;
BOOL    g_ImplicitThreadDataIsDefault = TRUE;
ULONG64 g_ImplicitProcessData;
BOOL    g_ImplicitProcessDataIsDefault = TRUE;

//----------------------------------------------------------------------------
//
// Utility functions.
//
//----------------------------------------------------------------------------

HRESULT
EmulateNtSelDescriptor(MachineInfo* Machine,
                       ULONG Selector, PDESCRIPTOR64 Desc)
{
    // Only emulate on platforms that support segments.
    if (Machine->m_ExecTypes[0] != IMAGE_FILE_MACHINE_I386 &&
        Machine->m_ExecTypes[0] != IMAGE_FILE_MACHINE_AMD64)
    {
        return E_UNEXPECTED;
    }

    ULONG Type, Gran;

    //
    // For user mode and triage dumps, we can hardcode the selector
    // since we do not have it anywhere.
    // XXX drewb - How many should we fake?  There are quite
    // a few KGDT entries.  Which ones are valid in user mode and
    // which are valid for a triage dump?
    //

    switch(Selector)
    {
    case X86_KGDT_R3_TEB + 3:
        HRESULT Status;

        // In user mode fs points to the TEB so fake up
        // a selector for it.
        if ((Status = GetImplicitThreadDataTeb(&Desc->Base)) != S_OK)
        {
            return Status;
        }

        if (Machine != g_TargetMachine)
        {
            ULONG Read;

            // We're asking for an emulated machine's TEB.
            // The only case we currently handle is x86-on-IA64
            // for Wow64, where the 32-bit TEB pointer is
            // stored in NT_TIB.ExceptionList.
            // Conveniently, this is the very first entry.
            if ((Status = g_Target->ReadVirtual(Desc->Base, &Desc->Base,
                                                sizeof(ULONG), &Read)) != S_OK)
            {
                return Status;
            }
            if (Read != sizeof(ULONG))
            {
                return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
            }

            Desc->Base = EXTEND64(Desc->Base);
        }

        Desc->Limit = Machine->m_PageSize - 1;
        Type = 0x13;
        Gran = 0;
        break;

    case X86_KGDT_R3_DATA + 3:
        Desc->Base = 0;
        Desc->Limit = Machine->m_Ptr64 ? 0xffffffffffffffffI64 : 0xffffffff;
        Type = 0x13;
        Gran = X86_DESC_GRANULARITY;
        break;

    default:
        Desc->Base = 0;
        Desc->Limit = Machine->m_Ptr64 ? 0xffffffffffffffffI64 : 0xffffffff;
        Type = 0x1b;
        Gran = X86_DESC_GRANULARITY |
            (Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64 ?
             X86_DESC_LONG_MODE : 0);
        break;
    }

    Desc->Flags = Gran | X86_DESC_DEFAULT_BIG | X86_DESC_PRESENT | Type |
        (IS_USER_TARGET() ?
         (3 << X86_DESC_PRIVILEGE_SHIFT) : (Selector & 3));

    return S_OK;
}

void
X86DescriptorToDescriptor64(PX86_LDT_ENTRY X86Desc,
                            PDESCRIPTOR64 Desc64)
{
    Desc64->Base = EXTEND64((ULONG)X86Desc->BaseLow +
                            ((ULONG)X86Desc->HighWord.Bits.BaseMid << 16) +
                            ((ULONG)X86Desc->HighWord.Bytes.BaseHi << 24));
    Desc64->Limit = (ULONG)X86Desc->LimitLow +
        ((ULONG)X86Desc->HighWord.Bits.LimitHi << 16);
    if (X86Desc->HighWord.Bits.Granularity)
    {
        Desc64->Limit = (Desc64->Limit << X86_PAGE_SHIFT) +
            ((1 << X86_PAGE_SHIFT) - 1);
    }
    Desc64->Flags = (ULONG)X86Desc->HighWord.Bytes.Flags1 +
        (((ULONG)X86Desc->HighWord.Bytes.Flags2 >> 4) << 8);
}

HRESULT
ReadX86Descriptor(ULONG Selector, ULONG64 Base, ULONG Limit,
                  PDESCRIPTOR64 Desc)
{
    ULONG Index;

    // Mask off irrelevant bits
    Index = Selector & ~0x7;

    // Check to make sure that the selector is within the table bounds
    if (Index > Limit)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;
    X86_LDT_ENTRY X86Desc;
    ULONG Result;

    Status = g_Target->ReadVirtual(Base + Index, &X86Desc, sizeof(X86Desc),
                                   &Result);
    if (Status != S_OK)
    {
        return Status;
    }
    if (Result != sizeof(X86Desc))
    {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

    X86DescriptorToDescriptor64(&X86Desc, Desc);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// TargetInfo system object methods.
//
//----------------------------------------------------------------------------

HRESULT
TargetInfo::GetProcessorSystemDataOffset(
    IN ULONG Processor,
    IN ULONG Index,
    OUT PULONG64 Offset
    )
{
    if (!IS_KERNEL_TARGET())
    {
        return E_UNEXPECTED;
    }

    // XXX drewb - Temporary until different OS support is
    // sorted out.
    if (g_ActualSystemVersion < NT_SVER_START ||
        g_ActualSystemVersion > NT_SVER_END)
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;
    ULONG Read;

    if (g_TargetMachineType == IMAGE_FILE_MACHINE_I386)
    {
        DESCRIPTOR64 Entry;

        //
        // We always need the PCR address so go ahead and get it.
        //
        
        if (!IS_CONTEXT_ACCESSIBLE())
        {
            X86_DESCRIPTOR GdtDesc;
            
            // We can't go through the normal context segreg mapping
            // but all we really need is an entry from the
            // kernel GDT that should always be present and
            // constant while the system is initialized.  We
            // can get the GDT information from the x86 control
            // space so do that.
            if ((Status = ReadControl
                 (Processor, g_TargetMachine->m_OffsetSpecialRegisters +
                  FIELD_OFFSET(X86_KSPECIAL_REGISTERS, Gdtr),
                  &GdtDesc, sizeof(GdtDesc), &Read)) != S_OK ||
                Read != sizeof(GdtDesc) ||
                (Status = ReadX86Descriptor(X86_KGDT_R0_PCR,
                                            EXTEND64(GdtDesc.Base),
                                            GdtDesc.Limit, &Entry)) != S_OK)
            {
                ErrOut("Unable to read selector for PCR for processor %u\n",
                       Processor);
                return Status != S_OK ?
                    Status : HRESULT_FROM_WIN32(ERROR_READ_FAULT);
            }
        }
        else
        {
            if ((Status = GetSelDescriptor(g_TargetMachine,
                                           VIRTUAL_THREAD_HANDLE(Processor),
                                           X86_KGDT_R0_PCR, &Entry)) != S_OK)
            {
                ErrOut("Unable to read selector for PCR for processor %u\n",
                       Processor);
                return Status;
            }
        }

        switch(Index)
        {
        case DEBUG_DATA_KPCR_OFFSET:

            Status = ReadPointer(g_TargetMachine,
                                 Entry.Base + FIELD_OFFSET(X86_KPCR, SelfPcr),
                                 Offset);
            if ((Status != S_OK) || Entry.Base != *Offset)
            {
                ErrOut("KPCR is corrupted !");
            }

            *Offset = Entry.Base;
            break;

        case DEBUG_DATA_KPRCB_OFFSET:
        case DEBUG_DATA_KTHREAD_OFFSET:
            Status = ReadPointer(g_TargetMachine,
                                 Entry.Base + FIELD_OFFSET(X86_KPCR, Prcb),
                                 Offset);
            if (Status != S_OK)
            {
                return Status;
            }

            if (Index == DEBUG_DATA_KPRCB_OFFSET)
            {
                break;
            }

            Status = ReadPointer(g_TargetMachine,
                                 *Offset + KPRCB_CURRENT_THREAD_OFFSET_32,
                                 Offset);
            if (Status != S_OK)
            {
                return Status;
            }
            break;
        }
    }
    else
    {
        ULONG ReadSize = g_TargetMachine->m_Ptr64 ?
            sizeof(ULONG64) : sizeof(ULONG);
        ULONG64 Address;

        switch(g_TargetMachineType)
        {
        case IMAGE_FILE_MACHINE_ALPHA:
        case IMAGE_FILE_MACHINE_AXP64:
            switch(Index)
            {
            case DEBUG_DATA_KPCR_OFFSET:
                Index = ALPHA_DEBUG_CONTROL_SPACE_PCR;
                break;
            case DEBUG_DATA_KPRCB_OFFSET:
                Index = ALPHA_DEBUG_CONTROL_SPACE_PRCB;
                break;
            case DEBUG_DATA_KTHREAD_OFFSET:
                Index = ALPHA_DEBUG_CONTROL_SPACE_THREAD;
                break;
            }
            break;

        case IMAGE_FILE_MACHINE_IA64:
            switch(Index)
            {
            case DEBUG_DATA_KPCR_OFFSET:
                Index = IA64_DEBUG_CONTROL_SPACE_PCR;
                break;
            case DEBUG_DATA_KPRCB_OFFSET:
                Index = IA64_DEBUG_CONTROL_SPACE_PRCB;
                break;
            case DEBUG_DATA_KTHREAD_OFFSET:
                Index = IA64_DEBUG_CONTROL_SPACE_THREAD;
                break;
            }
            break;
            
        case IMAGE_FILE_MACHINE_AMD64:
            switch(Index)
            {
            case DEBUG_DATA_KPCR_OFFSET:
                Index = AMD64_DEBUG_CONTROL_SPACE_PCR;
                break;
            case DEBUG_DATA_KPRCB_OFFSET:
                Index = AMD64_DEBUG_CONTROL_SPACE_PRCB;
                break;
            case DEBUG_DATA_KTHREAD_OFFSET:
                Index = AMD64_DEBUG_CONTROL_SPACE_THREAD;
                break;
            }
            break;
        }

        Status = ReadControl(Processor, Index, &Address, ReadSize, &Read);
        if (Status != S_OK)
        {
            return Status;
        }
        else if (Read != ReadSize)
        {
            return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
        }
        if (!g_TargetMachine->m_Ptr64)
        {
            Address = EXTEND64(Address);
        }

        *Offset = Address;
    }

    return S_OK;
}

HRESULT
TargetInfo::GetTargetSegRegDescriptors(ULONG64 Thread,
                                       ULONG Start, ULONG Count,
                                       PDESCRIPTOR64 Descs)
{
    while (Count-- > 0)
    {
        Descs->Flags = SEGDESC_INVALID;
        Descs++;
    }

    return S_OK;
}

HRESULT
TargetInfo::GetTargetSpecialRegisters
    (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    HRESULT Status;
    ULONG Done;

    Status = ReadControl(VIRTUAL_THREAD_INDEX(Thread),
                         g_TargetMachine->m_OffsetSpecialRegisters,
                         Special, g_TargetMachine->m_SizeKspecialRegisters,
                         &Done);
    if (Status != S_OK)
    {
        return Status;
    }
    return Done == g_TargetMachine->m_SizeKspecialRegisters ? S_OK : E_FAIL;
}

HRESULT
TargetInfo::SetTargetSpecialRegisters
    (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    HRESULT Status;
    ULONG Done;

    Status = WriteControl(VIRTUAL_THREAD_INDEX(Thread),
                          g_TargetMachine->m_OffsetSpecialRegisters,
                          Special, g_TargetMachine->m_SizeKspecialRegisters,
                          &Done);
    if (Status != S_OK)
    {
        return Status;
    }
    return Done == g_TargetMachine->m_SizeKspecialRegisters ? S_OK : E_FAIL;
}

void
TargetInfo::InvalidateTargetContext(void)
{
    // Nothing to do.
}

HRESULT
TargetInfo::GetContext(
    ULONG64 Thread,
    PCROSS_PLATFORM_CONTEXT Context
    )
{
    if (g_TargetMachine == NULL)
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;
    CROSS_PLATFORM_CONTEXT TargetContextBuffer;
    PCROSS_PLATFORM_CONTEXT TargetContext;

    if (g_TargetMachine->m_SverCanonicalContext <= g_SystemVersion)
    {
        TargetContext = Context;
    }
    else
    {
        TargetContext = &TargetContextBuffer;
        g_TargetMachine->InitializeContextFlags(TargetContext,
                                                g_SystemVersion);
    }

    Status = GetTargetContext(Thread, TargetContext);

    if (Status == S_OK && TargetContext == &TargetContextBuffer)
    {
        Status = g_TargetMachine->
            ConvertContextFrom(Context, g_SystemVersion,
                               g_TargetMachine->m_SizeTargetContext,
                               TargetContext);
        // Conversion should always succeed since the size is
        // known to be valid.
        DBG_ASSERT(Status == S_OK);
    }

    return Status;
}

HRESULT
TargetInfo::SetContext(
    ULONG64 Thread,
    PCROSS_PLATFORM_CONTEXT Context
    )
{
    if (g_TargetMachine == NULL)
    {
        return E_UNEXPECTED;
    }

    CROSS_PLATFORM_CONTEXT TargetContextBuffer;
    PCROSS_PLATFORM_CONTEXT TargetContext;

    if (g_TargetMachine->m_SverCanonicalContext <= g_SystemVersion)
    {
        TargetContext = Context;
    }
    else
    {
        TargetContext = &TargetContextBuffer;
        HRESULT Status = g_TargetMachine->
            ConvertContextTo(Context, g_SystemVersion,
                             g_TargetMachine->m_SizeTargetContext,
                             TargetContext);
        // Conversion should always succeed since the size is
        // known to be valid.
        DBG_ASSERT(Status == S_OK);
    }

    return SetTargetContext(Thread, TargetContext);
}

HRESULT
TargetInfo::KdGetThreadInfoDataOffset(PTHREAD_INFO Thread,
                                      ULONG64 ThreadHandle,
                                      PULONG64 Offset)
{
    if (Thread != NULL && Thread->DataOffset != 0)
    {
        *Offset = Thread->DataOffset;
        return S_OK;
    }

    ULONG Processor;

    if (Thread != NULL)
    {
        ThreadHandle = Thread->Handle;
    }
    Processor = VIRTUAL_THREAD_INDEX(ThreadHandle);

    HRESULT Status;

    Status = GetProcessorSystemDataOffset(Processor,
                                          DEBUG_DATA_KTHREAD_OFFSET,
                                          Offset);

    if (Status == S_OK && Thread != NULL)
    {
        Thread->DataOffset = *Offset;
    }

    return Status;
}

HRESULT
TargetInfo::KdGetProcessInfoDataOffset(PTHREAD_INFO Thread,
                                       ULONG Processor,
                                       ULONG64 ThreadData,
                                       PULONG64 Offset)
{
    // Process data offsets are not cached for kernel mode
    // since the only PROCESS_INFO is for kernel space.

    ULONG64 ProcessAddr;
    HRESULT Status;

    if (ThreadData == 0)
    {
        Status = GetThreadInfoDataOffset(Thread,
                                         VIRTUAL_THREAD_HANDLE(Processor),
                                         &ThreadData);
        if (Status != S_OK)
        {
            return Status;
        }
    }

    ThreadData += g_TargetMachine->m_OffsetKThreadApcProcess;

    Status = ReadPointer(g_TargetMachine, ThreadData, &ProcessAddr);
    if (Status != S_OK)
    {
        ErrOut("Unable to read KTHREAD address %p\n", ThreadData);
    }
    else
    {
        *Offset = ProcessAddr;
    }

    return Status;
}

HRESULT
TargetInfo::KdGetThreadInfoTeb(PTHREAD_INFO Thread,
                               ULONG ThreadIndex,
                               ULONG64 ThreadData,
                               PULONG64 Offset)
{
    ULONG64 TebAddr;
    HRESULT Status;

    if (ThreadData == 0)
    {
        Status = GetThreadInfoDataOffset(Thread,
                                         VIRTUAL_THREAD_HANDLE(ThreadIndex),
                                         &ThreadData);
        if (Status != S_OK)
        {
            return Status;
        }
    }

    ThreadData += g_TargetMachine->m_OffsetKThreadTeb;

    Status = ReadPointer(g_TargetMachine, ThreadData, &TebAddr);
    if (Status != S_OK)
    {
        ErrOut("Could not read KTHREAD address %p\n", ThreadData);
    }
    else
    {
        *Offset = TebAddr;
    }

    return Status;
}

HRESULT
TargetInfo::KdGetProcessInfoPeb(PTHREAD_INFO Thread,
                                ULONG Processor,
                                ULONG64 ThreadData,
                                PULONG64 Offset)
{
    HRESULT Status;
    ULONG64 Process, PebAddr;

    Status = GetProcessInfoDataOffset(Thread, Processor,
                                      ThreadData, &Process);
    if (Status != S_OK)
    {
        return Status;
    }

    Process += g_TargetMachine->m_OffsetEprocessPeb;

    Status = ReadPointer(g_TargetMachine, Process, &PebAddr);
    if (Status != S_OK)
    {
        ErrOut("Could not read KPROCESS address %p\n", Process);
    }
    else
    {
        *Offset = PebAddr;
    }

    return Status;
}

#define SELECTOR_CACHE_LENGTH 6

typedef struct _sc
{
    struct _sc            *nextYoungest;
    struct _sc            *nextOldest;
    ULONG                  Processor;
    ULONG                  Selector;
    DESCRIPTOR64           Desc;
} SELCACHEENTRY;

SELCACHEENTRY SelectorCache[SELECTOR_CACHE_LENGTH], *selYoungest, *selOldest;

void
InitSelCache(void)
{
    int i;

    for (i = 0; i < SELECTOR_CACHE_LENGTH; i++)
    {
        SelectorCache[i].nextYoungest = &SelectorCache[i+1];
        SelectorCache[i].nextOldest   = &SelectorCache[i-1];
        SelectorCache[i].Processor    = (LONG) -1;
        SelectorCache[i].Selector     = 0;
    }
    SelectorCache[--i].nextYoungest = NULL;
    SelectorCache[0].nextOldest     = NULL;
    selYoungest = &SelectorCache[i];
    selOldest   = &SelectorCache[0];
}

BOOL
FindSelector(ULONG Processor, ULONG Selector, PDESCRIPTOR64 Desc)
{
    int i;

    for (i = 0; i < SELECTOR_CACHE_LENGTH; i++)
    {
        if (SelectorCache[i].Selector == Selector &&
            SelectorCache[i].Processor == Processor)
        {
            *Desc = SelectorCache[i].Desc;
            return TRUE;
        }
    }
    return FALSE;
}

void
PutSelector(ULONG Processor, ULONG Selector, PDESCRIPTOR64 Desc)
{
    selOldest->Processor = Processor;
    selOldest->Selector = Selector;
    selOldest->Desc = *Desc;
    (selOldest->nextYoungest)->nextOldest = NULL;
    selOldest->nextOldest = selYoungest;
    selYoungest->nextYoungest = selOldest;
    selYoungest = selOldest;
    selOldest = selOldest->nextYoungest;
}

HRESULT
TargetInfo::KdGetSelDescriptor(MachineInfo* Machine,
                               ULONG64 Thread, ULONG Selector,
                               PDESCRIPTOR64 Desc)
{
    ULONG Processor = VIRTUAL_THREAD_INDEX(Thread);

    if (FindSelector(Processor, Selector, Desc))
    {
        return S_OK;
    }

    PTHREAD_INFO CtxThread, ProcThread;

    ProcThread = FindThreadByHandle(g_CurrentProcess, Thread);
    if (ProcThread == NULL)
    {
        return E_INVALIDARG;
    }

    CtxThread = g_RegContextThread;
    ChangeRegContext(ProcThread);
    
    ULONG TableReg;
    DESCRIPTOR64 Table;
    HRESULT Status;

    // Find out whether this is a GDT or LDT selector
    if (Selector & 0x4)
    {
        TableReg = SEGREG_LDT;
    }
    else
    {
        TableReg = SEGREG_GDT;
    }

    //
    // Fetch the address and limit of the appropriate descriptor table,
    // then look up the selector entry.
    //

    if ((Status = Machine->GetSegRegDescriptor(TableReg, &Table)) != S_OK)
    {
        goto Exit;
    }

    Status = ReadX86Descriptor(Selector, Table.Base, (ULONG)Table.Limit, Desc);
    if (Status == S_OK)
    {
        PutSelector(Processor, Selector, Desc);
    }

 Exit:
    ChangeRegContext(CtxThread);
    return Status;
}

//----------------------------------------------------------------------------
//
// LiveKernelTargetInfo system object methods.
//
//----------------------------------------------------------------------------

HRESULT
LiveKernelTargetInfo::GetThreadIdByProcessor(
    IN ULONG Processor,
    OUT PULONG Id
    )
{
    *Id = VIRTUAL_THREAD_ID(Processor);
    return S_OK;
}

HRESULT
LiveKernelTargetInfo::GetThreadInfoDataOffset(PTHREAD_INFO Thread,
                                          ULONG64 ThreadHandle,
                                          PULONG64 Offset)
{
    return KdGetThreadInfoDataOffset(Thread, ThreadHandle, Offset);
}

HRESULT
LiveKernelTargetInfo::GetProcessInfoDataOffset(PTHREAD_INFO Thread,
                                           ULONG Processor,
                                           ULONG64 ThreadData,
                                           PULONG64 Offset)
{
    return KdGetProcessInfoDataOffset(Thread, Processor, ThreadData, Offset);
}

HRESULT
LiveKernelTargetInfo::GetThreadInfoTeb(PTHREAD_INFO Thread,
                                   ULONG ThreadIndex,
                                   ULONG64 ThreadData,
                                   PULONG64 Offset)
{
    return KdGetThreadInfoTeb(Thread, ThreadIndex, ThreadData, Offset);
}

HRESULT
LiveKernelTargetInfo::GetProcessInfoPeb(PTHREAD_INFO Thread,
                                    ULONG Processor,
                                    ULONG64 ThreadData,
                                    PULONG64 Offset)
{
    return KdGetProcessInfoPeb(Thread, Processor, ThreadData, Offset);
}

HRESULT
LiveKernelTargetInfo::GetSelDescriptor(MachineInfo* Machine,
                                       ULONG64 Thread, ULONG Selector,
                                       PDESCRIPTOR64 Desc)
{
    return KdGetSelDescriptor(Machine, Thread, Selector, Desc);
}

//----------------------------------------------------------------------------
//
// ConnLiveKernelTargetInfo system object methods.
//
//----------------------------------------------------------------------------

HRESULT
ConnLiveKernelTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    NTSTATUS Status = DbgKdGetContext((USHORT)VIRTUAL_THREAD_INDEX(Thread),
                                      (PCROSS_PLATFORM_CONTEXT)Context);
    return CONV_NT_STATUS(Status);
}

HRESULT
ConnLiveKernelTargetInfo::SetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    NTSTATUS Status = DbgKdSetContext((USHORT)VIRTUAL_THREAD_INDEX(Thread),
                                      (PCROSS_PLATFORM_CONTEXT)Context);
    return CONV_NT_STATUS(Status);
}

//----------------------------------------------------------------------------
//
// LocalLiveKernelTargetInfo system object methods.
//
//----------------------------------------------------------------------------

HRESULT
LocalLiveKernelTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    // There really isn't any way to make
    // this work in a meaningful way unless the system
    // is paused.
    return E_NOTIMPL;
}

HRESULT
LocalLiveKernelTargetInfo::SetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    // There really isn't any way to make
    // this work in a meaningful way unless the system
    // is paused.
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
// ExdiLiveKernelTargetInfo system object methods.
//
//----------------------------------------------------------------------------

HRESULT
ExdiLiveKernelTargetInfo::GetProcessorSystemDataOffset(
    IN ULONG Processor,
    IN ULONG Index,
    OUT PULONG64 Offset
    )
{
    if (m_KdSupport != EXDI_KD_GS_PCR ||
        g_TargetMachineType != IMAGE_FILE_MACHINE_AMD64)
    {
        return LiveKernelTargetInfo::
            GetProcessorSystemDataOffset(Processor, Index, Offset);
    }

    HRESULT Status;
    DESCRIPTOR64 GsDesc;
        
    if ((Status =
         GetTargetSegRegDescriptors(0, SEGREG_GS, 1, &GsDesc)) != S_OK)
    {
        return Status;
    }

    switch(Index)
    {
    case DEBUG_DATA_KPCR_OFFSET:
        *Offset = GsDesc.Base;
        break;

    case DEBUG_DATA_KPRCB_OFFSET:
    case DEBUG_DATA_KTHREAD_OFFSET:
        Status = ReadPointer(g_TargetMachine,
                             GsDesc.Base +
                             FIELD_OFFSET(AMD64_KPCR, CurrentPrcb),
                             Offset);
        if (Status != S_OK)
        {
            return Status;
        }

        if (Index == DEBUG_DATA_KPRCB_OFFSET)
        {
            break;
        }

        Status = ReadPointer(g_TargetMachine,
                             *Offset + KPRCB_CURRENT_THREAD_OFFSET_64,
                             Offset);
        if (Status != S_OK)
        {
            return Status;
        }
        break;
    }

    return S_OK;
}

HRESULT
ExdiLiveKernelTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    if (!m_ContextValid)
    {
        HRESULT Status;

        if ((Status = g_TargetMachine->
             GetExdiContext(m_Context, &m_ContextData)) != S_OK)
        {
            return Status;
        }

        m_ContextValid = TRUE;
    }

    g_TargetMachine->ConvertExdiContextToContext
        (&m_ContextData, (PCROSS_PLATFORM_CONTEXT)Context);
    return S_OK;
}

HRESULT
ExdiLiveKernelTargetInfo::SetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    if (!m_ContextValid)
    {
        HRESULT Status;

        if ((Status = g_TargetMachine->
             GetExdiContext(m_Context, &m_ContextData)) != S_OK)
        {
            return Status;
        }

        m_ContextValid = TRUE;
    }

    g_TargetMachine->ConvertExdiContextFromContext
        ((PCROSS_PLATFORM_CONTEXT)Context, &m_ContextData);
    return g_TargetMachine->SetExdiContext(m_Context, &m_ContextData);
}

HRESULT
ExdiLiveKernelTargetInfo::GetTargetSegRegDescriptors(ULONG64 Thread,
                                                     ULONG Start, ULONG Count,
                                                     PDESCRIPTOR64 Descs)
{
    if (!m_ContextValid)
    {
        HRESULT Status;

        if ((Status = g_TargetMachine->
             GetExdiContext(m_Context, &m_ContextData)) != S_OK)
        {
            return Status;
        }

        m_ContextValid = TRUE;
    }

    g_TargetMachine->ConvertExdiContextToSegDescs(&m_ContextData, Start,
                                                  Count, Descs);
    return S_OK;
}

void
ExdiLiveKernelTargetInfo::InvalidateTargetContext(void)
{
    m_ContextValid = FALSE;
}

HRESULT
ExdiLiveKernelTargetInfo::GetTargetSpecialRegisters
    (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    if (!m_ContextValid)
    {
        HRESULT Status;

        if ((Status = g_TargetMachine->
             GetExdiContext(m_Context, &m_ContextData)) != S_OK)
        {
            return Status;
        }

        m_ContextValid = TRUE;
    }

    g_TargetMachine->ConvertExdiContextToSpecial(&m_ContextData, Special);
    return S_OK;
}

HRESULT
ExdiLiveKernelTargetInfo::SetTargetSpecialRegisters
    (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    if (!m_ContextValid)
    {
        HRESULT Status;

        if ((Status = g_TargetMachine->
             GetExdiContext(m_Context, &m_ContextData)) != S_OK)
        {
            return Status;
        }

        m_ContextValid = TRUE;
    }

    g_TargetMachine->ConvertExdiContextFromSpecial(Special, &m_ContextData);
    return g_TargetMachine->SetExdiContext(m_Context, &m_ContextData);
}

//----------------------------------------------------------------------------
//
// UserTargetInfo system object methods.
//
//----------------------------------------------------------------------------

HRESULT
UserTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    return m_Services->
        // g_TargetMachine should be used because of Wx86 debugging
        GetContext(Thread,
                   *(PULONG)((PUCHAR)Context +
                             g_TargetMachine->m_OffsetTargetContextFlags),
                   g_TargetMachine->m_OffsetTargetContextFlags,
                   Context,
                   g_TargetMachine->m_SizeTargetContext, NULL);
}

HRESULT
UserTargetInfo::SetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    return m_Services->SetContext(Thread, Context,
                                  // g_TargetMachine should be used because of Wx86 debugging
                                  g_TargetMachine->m_SizeTargetContext, NULL);
}

HRESULT
UserTargetInfo::GetThreadInfoDataOffset(PTHREAD_INFO Thread,
                                        ULONG64 ThreadHandle,
                                        PULONG64 Offset)
{
    if (Thread != NULL && Thread->DataOffset != 0)
    {
        *Offset = Thread->DataOffset;
        return S_OK;
    }

    if (Thread != NULL)
    {
        ThreadHandle = Thread->Handle;
    }
    else if (ThreadHandle == NULL)
    {
        ThreadHandle = g_CurrentProcess->CurrentThread->Handle;
    }

    HRESULT Status = m_Services->
        GetThreadDataOffset(ThreadHandle, Offset);

    if (Status == S_OK)
    {
        if (Thread != NULL)
        {
            Thread->DataOffset = *Offset;
        }
    }

    return Status;
}

HRESULT
UserTargetInfo::GetProcessInfoDataOffset(PTHREAD_INFO Thread,
                                         ULONG Processor,
                                         ULONG64 ThreadData,
                                         PULONG64 Offset)
{
    HRESULT Status;
    PPROCESS_INFO Process;

    // Processor isn't any use so default to the current thread.
    if (Thread == NULL)
    {
        Process = g_CurrentProcess;
    }
    else
    {
        Process = Thread->Process;
    }

    if (ThreadData == 0 && Process->DataOffset != 0)
    {
        *Offset = Process->DataOffset;
        return S_OK;
    }

    if (ThreadData != 0)
    {
        if (g_DebuggerPlatformId == VER_PLATFORM_WIN32_NT)
        {
            ThreadData += g_TargetMachine->m_Ptr64 ?
                PEB_FROM_TEB64 : PEB_FROM_TEB32;
            Status = ReadPointer(g_TargetMachine, ThreadData, Offset);
        }
        else
        {
            Status = E_NOTIMPL;
        }
    }
    else
    {
        Status = m_Services->GetProcessDataOffset(Process->FullHandle, Offset);
    }

    if (Status == S_OK)
    {
        if (ThreadData == 0)
        {
            Process->DataOffset = *Offset;
        }
    }

    return Status;
}

HRESULT
UserTargetInfo::GetThreadInfoTeb(PTHREAD_INFO Thread,
                                 ULONG Processor,
                                 ULONG64 ThreadData,
                                 PULONG64 Offset)
{
    return GetThreadInfoDataOffset(Thread, ThreadData, Offset);
}

HRESULT
UserTargetInfo::GetProcessInfoPeb(PTHREAD_INFO Thread,
                                  ULONG Processor,
                                  ULONG64 ThreadData,
                                  PULONG64 Offset)
{
    // Thread data is not useful.
    return GetProcessInfoDataOffset(Thread, 0, 0, Offset);
}

HRESULT
UserTargetInfo::GetSelDescriptor(MachineInfo* Machine,
                                 ULONG64 Thread, ULONG Selector,
                                 PDESCRIPTOR64 Desc)
{
    HRESULT Status;
    ULONG Used;
    X86_LDT_ENTRY X86Desc;

    if ((Status = m_Services->
         DescribeSelector(Thread, Selector, &X86Desc, sizeof(X86Desc),
                          &Used)) != S_OK)
    {
        return Status;
    }
    if (Used != sizeof(X86Desc))
    {
        return E_FAIL;
    }

    X86DescriptorToDescriptor64(&X86Desc, Desc);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// IDebugSystemObjects methods.
//
//----------------------------------------------------------------------------

STDMETHODIMP
DebugClient::GetEventThread(
    THIS_
    OUT PULONG Id
    )
{
    ENTER_ENGINE();

    HRESULT Status;

    if (g_EventThread == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Id = g_EventThread->UserId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetEventProcess(
    THIS_
    OUT PULONG Id
    )
{
    ENTER_ENGINE();

    HRESULT Status;

    if (g_EventProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Id = g_EventProcess->UserId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentThreadId(
    THIS_
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL ||
        g_CurrentProcess->CurrentThread == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Id = g_CurrentProcess->CurrentThread->UserId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetCurrentThreadId(
    THIS_
    IN ULONG Id
    )
{
    ENTER_ENGINE();

    HRESULT Status;
    PTHREAD_INFO Thread = FindThreadByUserId(NULL, Id);
    if (Thread != NULL)
    {
        SetCurrentThread(Thread, FALSE);
        ResetCurrentScopeLazy();
        Status = S_OK;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessId(
    THIS_
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Id = g_CurrentProcess->UserId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetCurrentProcessId(
    THIS_
    IN ULONG Id
    )
{
    ENTER_ENGINE();

    HRESULT Status;
    PPROCESS_INFO Process = FindProcessByUserId(Id);
    if (Process != NULL)
    {
        if (Process->CurrentThread == NULL)
        {
            Process->CurrentThread = Process->ThreadHead;
        }
        if (Process->CurrentThread == NULL)
        {
            Status = E_FAIL;
        }
        else
        {
            SetCurrentThread(Process->CurrentThread, FALSE);
            ResetCurrentScopeLazy();
            Status = S_OK;
        }
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberThreads(
    THIS_
    OUT PULONG Number
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Number = g_CurrentProcess->NumberThreads;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetTotalNumberThreads(
    THIS_
    OUT PULONG Total,
    OUT PULONG LargestProcess
    )
{
    ENTER_ENGINE();

    *Total = g_TotalNumberThreads;
    *LargestProcess = g_MaxThreadsInProcess;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetThreadIdsByIndex(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
    OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        PTHREAD_INFO Thread;
        ULONG Index;

        if (Start >= g_CurrentProcess->NumberThreads ||
            Start + Count > g_CurrentProcess->NumberThreads)
        {
            Status = E_INVALIDARG;
        }
        else
        {
            Index = 0;
            for (Thread = g_CurrentProcess->ThreadHead;
                 Thread != NULL;
                 Thread = Thread->Next)
            {
                if (Index >= Start && Index < Start + Count)
                {
                    if (Ids != NULL)
                    {
                        *Ids++ = Thread->UserId;
                    }
                    if (SysIds != NULL)
                    {
                        *SysIds++ = Thread->SystemId;
                    }
                }

                Index++;
            }

            Status = S_OK;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetThreadIdByProcessor(
    THIS_
    IN ULONG Processor,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG SysId;

        Status = g_Target->GetThreadIdByProcessor(Processor, &SysId);
        if (Status == S_OK)
        {
            PTHREAD_INFO Thread =
                FindThreadBySystemId(g_CurrentProcess, SysId);
            if (Thread != NULL)
            {
                *Id = Thread->UserId;
            }
            else
            {
                Status = E_NOINTERFACE;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentThreadDataOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->
            GetThreadInfoDataOffset(g_CurrentProcess->CurrentThread,
                                    0, Offset);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetThreadIdByDataOffset(
    THIS_
    IN ULONG64 Offset,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        PTHREAD_INFO Thread;

        Status = E_NOINTERFACE;
        for (Thread = g_CurrentProcess->ThreadHead;
             Thread != NULL;
             Thread = Thread->Next)
        {
            HRESULT Status;
            ULONG64 DataOffset;

            Status = g_Target->GetThreadInfoDataOffset(Thread, 0, &DataOffset);
            if (Status != S_OK)
            {
                break;
            }

            if (DataOffset == Offset)
            {
                *Id = Thread->UserId;
                Status = S_OK;
                break;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentThreadTeb(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->GetThreadInfoTeb(g_CurrentProcess->CurrentThread,
                                            0, 0, Offset);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetThreadIdByTeb(
    THIS_
    IN ULONG64 Offset,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        PTHREAD_INFO Thread;

        Status = E_NOINTERFACE;
        for (Thread = g_CurrentProcess->ThreadHead;
             Thread != NULL;
             Thread = Thread->Next)
        {
            HRESULT Status;
            ULONG64 Teb;

            Status = g_Target->GetThreadInfoTeb(Thread, 0, 0, &Teb);
            if (Status != S_OK)
            {
                break;
            }

            if (Teb == Offset)
            {
                *Id = Thread->UserId;
                Status = S_OK;
                break;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentThreadSystemId(
    THIS_
    OUT PULONG SysId
    )
{
    if (IS_KERNEL_TARGET())
    {
        return E_NOTIMPL;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *SysId = g_CurrentProcess->CurrentThread->SystemId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetThreadIdBySystemId(
    THIS_
    IN ULONG SysId,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    if (IS_KERNEL_TARGET())
    {
        Status = E_NOTIMPL;
    }
    else if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        PTHREAD_INFO Thread = FindThreadBySystemId(g_CurrentProcess, SysId);
        if (Thread != NULL)
        {
            *Id = Thread->UserId;
            Status = S_OK;
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentThreadHandle(
    THIS_
    OUT PULONG64 Handle
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Handle = g_CurrentProcess->CurrentThread->Handle;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetThreadIdByHandle(
    THIS_
    IN ULONG64 Handle,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        PTHREAD_INFO Thread = FindThreadByHandle(g_CurrentProcess, Handle);
        if (Thread != NULL)
        {
            *Id = Thread->UserId;
            Status = S_OK;
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberProcesses(
    THIS_
    OUT PULONG Number
    )
{
    if (!IS_TARGET_SET())
    {
        return E_UNEXPECTED;
    }

    ENTER_ENGINE();

    *Number = g_NumberProcesses;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetProcessIdsByIndex(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
    OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
    )
{
    if (!IS_TARGET_SET())
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;

    ENTER_ENGINE();

    PPROCESS_INFO Process;
    ULONG Index;

    if (Start >= g_NumberProcesses ||
        Start + Count > g_NumberProcesses)
    {
        Status = E_INVALIDARG;
        goto EH_Exit;
    }

    Index = 0;
    for (Process = g_ProcessHead;
         Process != NULL;
         Process = Process->Next)
    {
        if (Index >= Start && Index < Start + Count)
        {
            if (Ids != NULL)
            {
                *Ids++ = Process->UserId;
            }
            if (SysIds != NULL)
            {
                *SysIds++ = Process->SystemId;
            }
        }

        Index++;
    }

    Status = S_OK;

 EH_Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessDataOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->
            GetProcessInfoDataOffset(g_CurrentProcess->CurrentThread,
                                     0, 0, Offset);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetProcessIdByDataOffset(
    THIS_
    IN ULONG64 Offset,
    OUT PULONG Id
    )
{
    if (!IS_TARGET_SET())
    {
        return E_UNEXPECTED;
    }
    if (IS_KERNEL_TARGET())
    {
        return E_NOTIMPL;
    }

    HRESULT Status;
    PPROCESS_INFO Process;

    ENTER_ENGINE();

    Status = E_NOINTERFACE;
    for (Process = g_ProcessHead;
         Process != NULL;
         Process = Process->Next)
    {
        ULONG64 DataOffset;

        Status = g_Target->
            GetProcessInfoDataOffset(Process->ThreadHead, 0, 0, &DataOffset);
        if (Status != S_OK)
        {
            break;
        }

        if (DataOffset == Offset)
        {
            *Id = Process->UserId;
            Status = S_OK;
            break;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessPeb(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->GetProcessInfoPeb(g_CurrentProcess->CurrentThread,
                                             0, 0, Offset);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetProcessIdByPeb(
    THIS_
    IN ULONG64 Offset,
    OUT PULONG Id
    )
{
    if (!IS_TARGET_SET())
    {
        return E_UNEXPECTED;
    }
    if (IS_KERNEL_TARGET())
    {
        return E_NOTIMPL;
    }

    HRESULT Status;
    PPROCESS_INFO Process;

    ENTER_ENGINE();

    Status = E_NOINTERFACE;
    for (Process = g_ProcessHead;
         Process != NULL;
         Process = Process->Next)
    {
        ULONG64 Peb;

        Status = g_Target->GetProcessInfoPeb(Process->ThreadHead, 0, 0, &Peb);
        if (Status != S_OK)
        {
            break;
        }

        if (Peb == Offset)
        {
            *Id = Process->UserId;
            Status = S_OK;
            break;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessSystemId(
    THIS_
    OUT PULONG SysId
    )
{
    if (IS_KERNEL_TARGET())
    {
        return E_NOTIMPL;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *SysId = g_CurrentProcess->SystemId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetProcessIdBySystemId(
    THIS_
    IN ULONG SysId,
    OUT PULONG Id
    )
{
    if (!IS_TARGET_SET())
    {
        return E_UNEXPECTED;
    }
    if (IS_KERNEL_TARGET())
    {
        return E_NOTIMPL;
    }

    HRESULT Status;

    ENTER_ENGINE();

    PPROCESS_INFO Process = FindProcessBySystemId(SysId);
    if (Process != NULL)
    {
        *Id = Process->UserId;
        Status = S_OK;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessHandle(
    THIS_
    OUT PULONG64 Handle
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Handle = (ULONG64)g_CurrentProcess->Handle;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetProcessIdByHandle(
    THIS_
    IN ULONG64 Handle,
    OUT PULONG Id
    )
{
    if (!IS_TARGET_SET())
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;

    ENTER_ENGINE();

    PPROCESS_INFO Process = FindProcessByHandle(Handle);
    if (Process != NULL)
    {
        *Id = Process->UserId;
        Status = S_OK;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessExecutableName(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG ExeSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else if (g_CurrentProcess->ExecutableImage == NULL)
    {
        Status = E_NOINTERFACE;
    }
    else
    {
        Status = FillStringBuffer(g_CurrentProcess->ExecutableImage->ImagePath,
                                  0, Buffer, BufferSize, ExeSize);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessUpTime(
    THIS_
    OUT PULONG UpTime
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_LIVE_USER_TARGET() || g_CurrentProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG64 LongUpTime;
        
        LongUpTime = g_Target->GetProcessUpTimeN(g_CurrentProcess->FullHandle);
        if (LongUpTime == 0)
        {
            Status = E_NOINTERFACE;
        }
        else
        {
            *UpTime = FileTimeToTime(LongUpTime);
            Status = S_OK;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
GetContextFromThreadStack(
    ULONG64 ThreadBase,
    PCROSS_PLATFORM_CONTEXT Context,
    PDEBUG_STACK_FRAME StkFrame,
    BOOL Verbose
    )
{
    DBG_ASSERT(ThreadBase && Context != NULL);

    if (!IS_KERNEL_TARGET()) 
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;
    CROSS_PLATFORM_THREAD ThreadContents;
    DEBUG_STACK_FRAME LocalStkFrame;
    ULONG Proc;

    if (!StkFrame) 
    {
        StkFrame = &LocalStkFrame;
    } 

    ZeroMemory(StkFrame, sizeof(*StkFrame));

    if ((Status = g_Target->ReadAllVirtual
         (ThreadBase, &ThreadContents,
          g_TargetMachine->m_SizePartialKThread)) != S_OK)
    {
        {
            ErrOut("Cannot read thread contents @ %s, %s\n",
                   FormatAddr64(ThreadBase), FormatStatusCode(Status));
        }
        return Status;
    }
        
    if (*((PCHAR) &ThreadContents) != 6) 
    {
        ErrOut("Invalid thread @ %s type - context unchanged.\n",
               FormatAddr64(ThreadBase));
        return E_INVALIDARG;
    }

    Status = g_TargetMachine->GetContextFromThreadStack
        (ThreadBase, &ThreadContents, Context, StkFrame, &Proc);
    if (Status == S_FALSE)
    {
        // Get the processor context if it's a valid processor.
        if (Proc < g_TargetNumberProcessors)
        {
            // This get may be getting the context of the thread
            // currently cached by the register code.  Make sure
            // the cache is flushed.
            FlushRegContext();

            g_TargetMachine->InitializeContextFlags(Context, g_SystemVersion);
            if ((Status = g_Target->GetContext(VIRTUAL_THREAD_HANDLE(Proc),
                                               Context)) != S_OK)
            {
                ErrOut("Unable to get context for thread "
                       "running on processor %d, %s\n",
                       Proc, FormatStatusCode(Status));
                return Status;
            }
        }
        else 
        {
            if (Verbose)
            {
                ErrOut("Thread running on invalid processor %d\n", Proc);
            }
            return E_INVALIDARG;
        }
    }
    else if (Status != S_OK)
    {
        if (Verbose)
        {
            ErrOut("Can't retrieve thread context, %s\n", 
                   FormatStatusCode(Status));
        }
        return Status;
    }

    return S_OK;
}

HRESULT
SetContextFromThreadData(ULONG64 ThreadBase, BOOL Verbose)
{
    if (!ThreadBase) 
    {
        if (GetCurrentScopeContext())
        {
            ResetCurrentScope();
        }
        return S_OK;
    }

    HRESULT Status;
    DEBUG_STACK_FRAME StkFrame = {0};
    CROSS_PLATFORM_CONTEXT Context = {0};
    
    if ((Status = GetContextFromThreadStack(ThreadBase, &Context,
                                            &StkFrame, FALSE)) != S_OK)
    {
        return Status;
    }
    
    SetCurrentScope(&StkFrame, &Context, sizeof(Context));
    if (StackTrace(StkFrame.FrameOffset, StkFrame.StackOffset,
                   StkFrame.InstructionOffset,
                   &StkFrame, 1, 0, 0, FALSE) != 1)
    {
        if (Verbose) 
        {
            ErrOut("Scope can't be set for thread %s\n",
                   FormatAddr64(ThreadBase));
        }
        ResetCurrentScope();
        return E_FAIL;
    }

    return S_OK;
}

HRESULT
GetImplicitThreadData(PULONG64 Offset)
{
    HRESULT Status;
    
    if (g_ImplicitThreadData == 0)
    {
        Status = SetImplicitThreadData(0, FALSE);
    }
    else
    {
        Status = S_OK;
    }
    
    *Offset = g_ImplicitThreadData;
    return Status;
}

HRESULT
GetImplicitThreadDataTeb(PULONG64 Offset)
{
    if (IS_USER_TARGET())
    {
        // In user mode the thread data is the TEB.
        return GetImplicitThreadData(Offset);
    }
    else
    {
        return g_Target->ReadImplicitThreadInfoPointer
            (g_TargetMachine->m_OffsetKThreadTeb, Offset);
    }
}

HRESULT
SetImplicitThreadData(ULONG64 Offset, BOOL Verbose)
{
    HRESULT Status;
    BOOL Default = FALSE;
    
    if (Offset == 0)
    {
        if ((Status = g_Target->
             GetThreadInfoDataOffset(g_CurrentProcess->CurrentThread,
                                     0, &Offset)) != S_OK)
        {
            if (Verbose)
            {
                ErrOut("Unable to get the current thread data\n");
            }
            return Status;
        }
        if (Offset == 0)
        {
            if (Verbose)
            {
                ErrOut("Current thread data is NULL\n");
            }
            return E_FAIL;
        }

        Default = TRUE;
    }

    if (IS_KERNEL_TARGET() &&
        (Status = SetContextFromThreadData(Default ? 0 : Offset,
                                           Verbose)) != S_OK)
    {
        return Status;
    }
    
    g_ImplicitThreadData = Offset;
    g_ImplicitThreadDataIsDefault = Default;
    return S_OK;
}

STDMETHODIMP
DebugClient::GetImplicitThreadDataOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = ::GetImplicitThreadData(Offset);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetImplicitThreadDataOffset(
    THIS_
    IN ULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = ::SetImplicitThreadData(Offset, FALSE);
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
GetImplicitProcessData(PULONG64 Offset)
{
    HRESULT Status;
    
    if (g_ImplicitProcessData == 0)
    {
        Status = SetImplicitProcessData(0, FALSE);
    }
    else
    {
        Status = S_OK;
    }
    
    *Offset = g_ImplicitProcessData;
    return Status;
}

HRESULT
GetImplicitProcessDataPeb(PULONG64 Offset)
{
    if (IS_USER_TARGET())
    {
        // In user mode the process data is the PEB.
        return GetImplicitProcessData(Offset);
    }
    else
    {
        return g_Target->ReadImplicitProcessInfoPointer
            (g_TargetMachine->m_OffsetEprocessPeb, Offset);
    }
}

HRESULT
SetImplicitProcessData(ULONG64 Offset, BOOL Verbose)
{
    HRESULT Status;
    BOOL Default = FALSE;

    if (Offset == 0)
    {
        if ((Status = g_Target->
             GetProcessInfoDataOffset(g_CurrentProcess->CurrentThread,
                                      0, 0, &Offset)) != S_OK)
        {
            if (Verbose)
            {
                ErrOut("Unable to get the current process data\n");
            }
            return Status;
        }
        if (Offset == 0)
        {
            if (Verbose)
            {
                ErrOut("Current process data is NULL\n");
            }
            return E_FAIL;
        }

        Default = TRUE;
    }
    
    ULONG64 Old = g_ImplicitProcessData;
    BOOL OldDefault = g_ImplicitProcessDataIsDefault;
        
    g_ImplicitProcessData = Offset;
    g_ImplicitProcessDataIsDefault = Default;
    if (IS_KERNEL_TARGET() &&
        (Status = g_TargetMachine->
         SetDefaultPageDirectories(PAGE_DIR_ALL)) != S_OK)
    {
        g_ImplicitProcessData = Old;
        g_ImplicitProcessDataIsDefault = OldDefault;
        if (Verbose)
        {
            ErrOut("Process %s has invalid page directories\n",
                   FormatAddr64(Offset));
        }

        return Status;
    }

    return S_OK;
}

STDMETHODIMP
DebugClient::GetImplicitProcessDataOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = ::GetImplicitProcessData(Offset);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetImplicitProcessDataOffset(
    THIS_
    IN ULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = ::SetImplicitProcessData(Offset, FALSE);
    }

    LEAVE_ENGINE();
    return Status;
}

void
ResetImplicitData(void)
{
    g_ImplicitThreadData = 0;
    g_ImplicitThreadDataIsDefault = TRUE;
    g_ImplicitProcessData = 0;
    g_ImplicitProcessDataIsDefault = TRUE;
}

void
ParseSetImplicitThread(void)
{
    ULONG64 Base = 0;

    if (PeekChar() && *g_CurCmd != ';')
    {
        Base = GetExpression();
    }

    if (SetImplicitThreadData(Base, TRUE) == S_OK)
    {
        dprintf("Implicit thread is now %s\n",
                FormatAddr64(g_ImplicitThreadData));
    }
}

HRESULT
KernelPageIn(ULONG64 Process, ULONG64 Data)
{
    HRESULT Status;
    ULONG work;
    ULONG Size;

    ULONG64 ExpDebuggerProcessAttach = 0;
    ULONG64 ExpDebuggerPageIn = 0;
    ULONG64 ExpDebuggerWork = 0;

    if (!IS_LIVE_KERNEL_TARGET())
    {
        ErrOut("This operation only works on live kernel debug sessions\n");
        return E_NOTIMPL;
    }

    GetOffsetFromSym("nt!ExpDebuggerProcessAttach", &ExpDebuggerProcessAttach, NULL);
    GetOffsetFromSym("nt!ExpDebuggerPageIn", &ExpDebuggerPageIn, NULL);
    GetOffsetFromSym("nt!ExpDebuggerWork", &ExpDebuggerWork, NULL);

    if (!ExpDebuggerProcessAttach ||
        !ExpDebuggerPageIn        ||
        !ExpDebuggerWork)
    {
        ErrOut("Symbols are wrong or this version of the operating system"
               "does not support this command\n");
        return E_NOTIMPL;
    }

    Status = g_Target->ReadVirtual(ExpDebuggerWork, &work, sizeof(work), &Size);

    if ((Status != S_OK) || Size != sizeof(work))
    {
        ErrOut("Could not determine status or debugger worker thread\n");
        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }
    else if (work > 1)
    {
        ErrOut("Debugger worker thread has pending command\n");
        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    Status = g_Target->WritePointer(g_Machine, ExpDebuggerProcessAttach,
                                    Process);
    if (Status == S_OK)
    {
        Status = g_Target->WritePointer(g_Machine, ExpDebuggerPageIn,
                                        Data);
    }

    if (Status == S_OK)
    {
        work = 1;
        Status = g_Target->WriteVirtual(ExpDebuggerWork, &work,
                                        sizeof(work), &Size);
    }

    if (Status != S_OK)
    {
        ErrOut("Could not queue operation to debugger worker thread\n");
    }

    return Status;
}



void
ParseSetImplicitProcess(void)
{
    ULONG64 Base = 0;
    BOOL Ptes = FALSE;
    BOOL Invasive = FALSE;
    BOOL OldPtes = g_VirtualCache.m_ForceDecodePTEs;

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*(++g_CurCmd))
        {
        case 'p':
            Ptes = TRUE;
            break;
        case 'i':
            Invasive = TRUE;
            break;
        default:
            dprintf("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }
    
    if (PeekChar() && *g_CurCmd != ';')
    {
        Base = GetExpression();
    }

    if (Invasive)
    {
        if (S_OK == KernelPageIn(Base, 0))
        {
            dprintf("You need to continue execution (press 'g' <enter>) for "
                    "the context to be switched.  When the debugger breaks "
                    "in again, you will be in the new process context.\n");
        }
        return;
    }
    if (Ptes && !Base)
    {
        // If the user has requested a reset to the default
        // process with no translations we need to turn
        // off translations immediately so that any
        // existing base doesn't interfere with determining
        // the default process.
        g_VirtualCache.SetForceDecodePtes(FALSE);
    }
        
    if (SetImplicitProcessData(Base, TRUE) == S_OK)
    {
        dprintf("Implicit process is now %s\n",
                FormatAddr64(g_ImplicitProcessData));

        if (Ptes)
        {
            if (Base)
            {
                g_VirtualCache.SetForceDecodePtes(TRUE);
            }
            dprintf(".cache %sforcedecodeptes done\n",
                    Base != 0 ? "" : "no");
        }
        
        if (Base && !g_VirtualCache.m_ForceDecodePTEs)
        {
            WarnOut("WARNING: .cache forcedecodeptes is not enabled\n");
        }
    }
    else if (Ptes && !Base && OldPtes)
    {
        // Restore settings to the way they were.
        g_VirtualCache.SetForceDecodePtes(TRUE);
    }
}

void
ParsePageIn(void)
{
    ULONG64 Process = 0;
    ULONG64 Data = 0;

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*(++g_CurCmd))
        {
        case 'p':
            g_CurCmd++;
            Process = GetExpression();
            break;
        default:
            g_CurCmd++;
            dprintf("Unknown option '%c'\n", *g_CurCmd);
            break;
        }
    }
    
    if (PeekChar() && *g_CurCmd != ';')
    {
        Data = GetExpression();
    }

    if (!Data)
    {
        ErrOut("Pagein requires an address to be specified\n");
        return;
    }

    //
    // Modify kernel state to do the pagein
    //

    if (S_OK != KernelPageIn(Process, Data))
    {
        ErrOut("PageIn for address %s, process %s failed\n",
               FormatAddr64(Data),
               FormatAddr64(Process));
    }
    else
    {
        dprintf("You need to continue execution (press 'g' <enter>) for "
                 "the pagein to be brought in.  When the debugger breaks in "
                 "again, the page will be present.\n");
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dbgreg.cpp ===
//----------------------------------------------------------------------------
//
// IDebugRegisters implementation.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

STDMETHODIMP
DebugClient::GetNumberRegisters(
    THIS_
    OUT PULONG Number
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_MACHINE_SET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Number = g_Machine->m_NumberRegs;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetDescription(
    THIS_
    IN ULONG Register,
    OUT OPTIONAL PSTR NameBuffer,
    IN ULONG NameBufferSize,
    OUT OPTIONAL PULONG NameSize,
    OUT OPTIONAL PDEBUG_REGISTER_DESCRIPTION Desc
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_MACHINE_SET())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }
    
    if (Register >= g_Machine->m_NumberRegs)
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    ULONG Index;
    ULONG Type;
    REGDEF* FullDef;

    FullDef = RegDefFromCount(Register);
    if (!FullDef) 
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    Type = g_Machine->GetType(FullDef->index);

    Status = FillStringBuffer(FullDef->psz, 0,
                              NameBuffer, NameBufferSize, NameSize);
    
    if (Desc != NULL)
    {
        ZeroMemory(Desc, sizeof(*Desc));

        switch(Type)
        {
        case REGVAL_INT16:
            Desc->Type = DEBUG_VALUE_INT16;
            break;
        case REGVAL_SUB32:
            Desc->Flags |= DEBUG_REGISTER_SUB_REGISTER;
            // Fall through.
        case REGVAL_INT32:
            Desc->Type = DEBUG_VALUE_INT32;
            break;
        case REGVAL_SUB64:
            Desc->Flags |= DEBUG_REGISTER_SUB_REGISTER;
            // Fall through.
        case REGVAL_INT64:
        case REGVAL_INT64N:
            Desc->Type = DEBUG_VALUE_INT64;
            break;
        case REGVAL_FLOAT8:
            Desc->Type = DEBUG_VALUE_FLOAT64;
            break;
        case REGVAL_FLOAT10:
            Desc->Type = DEBUG_VALUE_FLOAT80;
            break;
        case REGVAL_FLOAT82:
            Desc->Type = DEBUG_VALUE_FLOAT82;
            break;
        case REGVAL_FLOAT16:
            Desc->Type = DEBUG_VALUE_FLOAT128;
            break;
        case REGVAL_VECTOR64:
            Desc->Type = DEBUG_VALUE_VECTOR64;
            break;
        case REGVAL_VECTOR128:
            Desc->Type = DEBUG_VALUE_VECTOR128;
            break;
        }

        if (Desc->Flags & DEBUG_REGISTER_SUB_REGISTER)
        {
            REGSUBDEF* SubDef = RegSubDefFromIndex(FullDef->index);
            if (!SubDef) 
            {
                Status = E_UNEXPECTED;
                goto Exit;
            }

            // Find fullreg definition and count.
            RegisterGroup* Group;
            ULONG FullCount = 0;
            
            for (Group = g_Machine->m_Groups;
                 Group != NULL;
                 Group = Group->Next)
            {
                FullDef = Group->Regs;
                while (FullDef->psz != NULL)
                {
                    if (FullDef->index == SubDef->fullreg)
                    {
                        break;
                    }
                
                    FullDef++;
                }

                FullCount += (ULONG)(FullDef - Group->Regs);
                if (FullDef->psz != NULL)
                {
                    break;
                }
            }
            
            DBG_ASSERT(FullDef->psz != NULL);

            Desc->SubregMaster = FullCount;

            // Count the bits in the mask to derive length.

            ULONG64 Mask;

            Mask = SubDef->mask;
            Desc->SubregMask = Mask;
        
            while (Mask != 0)
            {
                Desc->SubregLength++;
                Mask &= Mask - 1;
            }

            Desc->SubregShift = SubDef->shift;
        }
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetIndexByName(
    THIS_
    IN PCSTR Name,
    OUT PULONG Index
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    if (!IS_MACHINE_SET())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        RegisterGroup* Group;
        ULONG Idx;

        Status = E_NOINTERFACE;
        Idx = 0;
        for (Group = g_Machine->m_Groups;
             Group != NULL && Status != S_OK;
             Group = Group->Next)
        {
            REGDEF* Def;
            
            Def = Group->Regs;
            while (Def->psz != NULL)
            {
                if (!strcmp(Def->psz, Name))
                {
                    Status = S_OK;
                    break;
                }

                Idx++;
                Def++;
            }
        }

        *Index = Idx;
    }

    LEAVE_ENGINE();
    return Status;
}
    
STDMETHODIMP
DebugClient::GetValue(
    THIS_
    IN ULONG Register,
    OUT PDEBUG_VALUE Value
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }
    
    if (Register >= g_Machine->m_NumberRegs)
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    ZeroMemory(Value, sizeof(*Value));
    
    ULONG Index;
    REGVAL Val;

    REGDEF* RegDef = RegDefFromCount(Register);
    if (!RegDef) 
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    Index = RegDef->index;
    GetRegVal(Index, &Val);

    switch(Val.type)
    {
    case REGVAL_INT16:
        Value->Type = DEBUG_VALUE_INT16;
        Value->I16 = (USHORT)Val.i32;
        break;
    case REGVAL_SUB32:
    case REGVAL_INT32:
        Value->Type = DEBUG_VALUE_INT32;
        Value->I32 = Val.i32;
        break;
    case REGVAL_SUB64:
    case REGVAL_INT64:
        Val.Nat = FALSE;
        // Fall through.
    case REGVAL_INT64N:
        Value->Type = DEBUG_VALUE_INT64;
        Value->I64 = Val.i64;
        Value->Nat = Val.Nat;
        break;
    case REGVAL_FLOAT8:
        Value->Type = DEBUG_VALUE_FLOAT64;
        Value->F64 = Val.f8;
        break;
    case REGVAL_FLOAT10:
        Value->Type = DEBUG_VALUE_FLOAT80;
        memcpy(Value->F80Bytes, Val.f10, sizeof(Value->F80Bytes));
        break;
    case REGVAL_FLOAT82:
        Value->Type = DEBUG_VALUE_FLOAT82;
        memcpy(Value->F82Bytes, Val.f82, sizeof(Value->F82Bytes));
        break;
    case REGVAL_FLOAT16:
        Value->Type = DEBUG_VALUE_FLOAT128;
        memcpy(Value->F128Bytes, Val.f16, sizeof(Value->F128Bytes));
        break;
    case REGVAL_VECTOR64:
        Value->Type = DEBUG_VALUE_VECTOR64;
        memcpy(Value->RawBytes, Val.bytes, 8);
        break;
    case REGVAL_VECTOR128:
        Value->Type = DEBUG_VALUE_VECTOR128;
        memcpy(Value->RawBytes, Val.bytes, 16);
        break;
    }

    Status = S_OK;
    
 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetValue(
    THIS_
    IN ULONG Register,
    IN PDEBUG_VALUE Value
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }
    
    if (Register >= g_Machine->m_NumberRegs)
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    ULONG Index;
    ULONG Type;
    REGVAL Val;
    DEBUG_VALUE Coerce;

    REGDEF* RegDef = RegDefFromCount(Register);
    if (!RegDef) 
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    Index = RegDef->index;
    Type = g_Machine->GetType(Index);
    Val.type = Type;

    switch(Type)
    {
    case REGVAL_INT16:
        Status = CoerceValue(Value, DEBUG_VALUE_INT16, &Coerce);
        Val.i32 = Coerce.I16;
        break;
    case REGVAL_SUB32:
    case REGVAL_INT32:
        Status = CoerceValue(Value, DEBUG_VALUE_INT32, &Coerce);
        Val.i32 = Coerce.I32;
        break;
    case REGVAL_INT64:
        Val.type = REGVAL_INT64N;
        // Fall through.
    case REGVAL_SUB64:
    case REGVAL_INT64N:
        Status = CoerceValue(Value, DEBUG_VALUE_INT64, &Coerce);
        Val.i64 = Coerce.I64;
        Val.Nat = Coerce.Nat ? TRUE : FALSE;
        break;
    case REGVAL_FLOAT8:
        Status = CoerceValue(Value, DEBUG_VALUE_FLOAT64, &Coerce);
        Val.f8 = Coerce.F64;
        break;
    case REGVAL_FLOAT10:
        Status = CoerceValue(Value, DEBUG_VALUE_FLOAT80, &Coerce);
        memcpy(Val.f10, Coerce.F80Bytes, sizeof(Coerce.F80Bytes));
        break;
    case REGVAL_FLOAT82:
        Status = CoerceValue(Value, DEBUG_VALUE_FLOAT82, &Coerce);
        memcpy(Val.f82, Coerce.F82Bytes, sizeof(Coerce.F82Bytes));
        break;
    case REGVAL_FLOAT16:
        Status = CoerceValue(Value, DEBUG_VALUE_FLOAT128, &Coerce);
        memcpy(Val.f16, Coerce.F128Bytes, sizeof(Coerce.F128Bytes));
        break;
    case REGVAL_VECTOR64:
        Status = CoerceValue(Value, DEBUG_VALUE_VECTOR64, &Coerce);
        memcpy(Val.bytes, Coerce.RawBytes, 8);
        break;
    case REGVAL_VECTOR128:
        Status = CoerceValue(Value, DEBUG_VALUE_VECTOR128, &Coerce);
        memcpy(Val.bytes, Coerce.RawBytes, 16);
        break;
    }

    if (Status == S_OK)
    {
        SetRegVal(Index, &Val);
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetValues(
    THIS_
    IN ULONG Count,
    IN OPTIONAL PULONG Indices,
    IN ULONG Start,
    OUT PDEBUG_VALUE Values
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    HRESULT SingleStatus;
    ULONG i;
    PCROSS_PLATFORM_CONTEXT ScopeContext;
    
    if (ScopeContext = GetCurrentScopeContext())
    {
        g_Machine->PushContext(ScopeContext);
    }
    
    Status = S_OK;
    if (Indices != NULL)
    {
        for (i = 0; i < Count; i++)
        {
            SingleStatus = GetValue(Indices[i], Values + i);
            if (SingleStatus != S_OK)
            {
                Status = SingleStatus;
            }
        }
    }
    else
    {
        for (i = 0; i < Count; i++)
        {
            SingleStatus = GetValue(Start + i, Values + i);
            if (SingleStatus != S_OK)
            {
                Status = SingleStatus;
            }
        }
    }
    
    if (ScopeContext)
    {
        g_Machine->PopContext();
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetValues(
    THIS_
    IN ULONG Count,
    IN OPTIONAL PULONG Indices,
    IN ULONG Start,
    IN PDEBUG_VALUE Values
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    HRESULT SingleStatus;
    ULONG i;

    Status = S_OK;
    if (Indices != NULL)
    {
        for (i = 0; i < Count; i++)
        {
            SingleStatus = SetValue(Indices[i], Values + i);
            if (SingleStatus != S_OK)
            {
                Status = SingleStatus;
            }
        }
    }
    else
    {
        for (i = 0; i < Count; i++)
        {
            SingleStatus = SetValue(Start + i, Values + i);
            if (SingleStatus != S_OK)
            {
                Status = SingleStatus;
            }
        }
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OutputRegisters(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Flags
    )
{
    // Ensure that the public flags match the internal flags.
    C_ASSERT(DEBUG_REGISTERS_INT32 == REGALL_INT32 &&
             DEBUG_REGISTERS_INT64 == REGALL_INT64 &&
             DEBUG_REGISTERS_FLOAT == REGALL_FLOAT);

    if (Flags & ~DEBUG_REGISTERS_ALL)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        OutCtlSave OldCtl;
        if (!PushOutCtl(OutputControl, this, &OldCtl))
        {
            Status = E_INVALIDARG;
        }
        else
        {
            if (Flags == DEBUG_REGISTERS_DEFAULT)
            {
                Flags = g_Machine->m_AllMask;
            }
            
            OutCurInfo(OCI_FORCE_REG, Flags, DEBUG_OUTPUT_NORMAL);
            Status = S_OK;
            PopOutCtl(&OldCtl);
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetInstructionOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ADDR Addr;
        g_Machine->GetPC(&Addr);
        *Offset = Flat(Addr);
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetStackOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ADDR Addr;
        g_Machine->GetSP(&Addr);
        *Offset = Flat(Addr);
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetFrameOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ADDR Addr;
        g_Machine->GetFP(&Addr);
        *Offset = Flat(Addr);
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dump.hpp ===
//----------------------------------------------------------------------------
//
// Dump file support.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#ifndef __DUMP_HPP__
#define __DUMP_HPP__

#define MI_UNLOADED_DRIVERS 50

#define IS_DUMP_TARGET() \
    (g_DumpType < DTYPE_COUNT)

#define IS_USER_DUMP() \
    (g_DumpType >= DTYPE_USER_FULL32 && g_DumpType <= DTYPE_USER_MINI)
#define IS_KERNEL_DUMP() \
    (g_DumpType >= DTYPE_KERNEL_SUMMARY32 && g_DumpType <= DTYPE_KERNEL_FULL64)

#define IS_KERNEL_SUMMARY_DUMP() \
    (g_DumpType == DTYPE_KERNEL_SUMMARY32 || \
     g_DumpType == DTYPE_KERNEL_SUMMARY64)
#define IS_KERNEL_TRIAGE_DUMP() \
    (g_DumpType == DTYPE_KERNEL_TRIAGE32 || \
     g_DumpType == DTYPE_KERNEL_TRIAGE64)
#define IS_KERNEL_FULL_DUMP() \
    (g_DumpType == DTYPE_KERNEL_FULL32 || \
     g_DumpType == DTYPE_KERNEL_FULL64)
#define IS_USER_FULL_DUMP() \
    (g_DumpType == DTYPE_USER_FULL32 || g_DumpType == DTYPE_USER_FULL64)
#define IS_USER_MINI_DUMP() \
    (g_DumpType == DTYPE_USER_MINI_PARTIAL || \
     g_DumpType == DTYPE_USER_MINI_FULL)

#define IS_DUMP_WITH_MAPPED_IMAGES() \
    (IS_KERNEL_TRIAGE_DUMP() || g_DumpType == DTYPE_USER_MINI_PARTIAL)

enum DTYPE
{
    DTYPE_KERNEL_SUMMARY32,
    DTYPE_KERNEL_SUMMARY64,
    DTYPE_KERNEL_TRIAGE32,
    DTYPE_KERNEL_TRIAGE64,
    // Kernel full dumps must come after summary and triage
    // dumps so that the more specific dumps are identified first.
    DTYPE_KERNEL_FULL32,
    DTYPE_KERNEL_FULL64,
    DTYPE_USER_FULL32,
    DTYPE_USER_FULL64,
    DTYPE_USER_MINI_PARTIAL,
    DTYPE_USER_MINI_FULL,
    DTYPE_COUNT
};

enum
{
    // Actual dump file.
    DUMP_INFO_DUMP,
    // Paging file information.
    DUMP_INFO_PAGE_FILE,

    DUMP_INFO_COUNT
};

extern ULONG64             g_DumpKiProcessors[MAXIMUM_PROCESSORS];
extern ULONG64             g_DumpKiPcrBaseAddress;
extern BOOL                g_TriageDumpHasDebuggerData;

extern DTYPE               g_DumpType;
extern ULONG               g_DumpFormatFlags;
extern EXCEPTION_RECORD64  g_DumpException;
extern ULONG               g_DumpExceptionFirstChance;

extern ULONG               g_DumpCacheGranularity;

HRESULT AddDumpInfoFile(PCSTR FileName, ULONG Index, ULONG InitialView);
void CloseDumpInfoFile(ULONG Index);
void CloseDumpInfoFiles(void);

HRESULT DmpInitialize(LPCSTR FileName);
void DmpUninitialize(void);

void ParseDumpFileCommand(void);

HRESULT WriteDumpFile(PCSTR DumpFile, ULONG Qualifier, ULONG FormatFlags,
                      PCSTR Comment);

//----------------------------------------------------------------------------
//
// DumpTargetInfo hierarchy.
//
// Each kind of dump has its own target for methods that are
// specific to the kind of dump.
//
//----------------------------------------------------------------------------

class DumpTargetInfo : public TargetInfo
{
public:
    // TargetInfo.
    virtual void Uninitialize(void);

    virtual HRESULT ReadVirtual(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtual(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    
    virtual HRESULT WaitForEvent(ULONG Flags, ULONG Timeout);

    //
    // DumpTargetInfo.
    //

    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize) = 0;

    virtual void DumpDebug(void) = 0;

    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail) = 0;

    // Base implementation returns E_NOTIMPL.
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags, PCSTR Comment);
};

class KernelDumpTargetInfo : public DumpTargetInfo
{
public:
    // TargetInfo.
    virtual void Uninitialize(void);
    
    virtual HRESULT ReadControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );

    virtual HRESULT GetThreadIdByProcessor(
        IN ULONG Processor,
        OUT PULONG Id
        );
    
    virtual HRESULT GetThreadInfoDataOffset(PTHREAD_INFO Thread,
                                            ULONG64 ThreadHandle,
                                            PULONG64 Offset);
    virtual HRESULT GetProcessInfoDataOffset(PTHREAD_INFO Thread,
                                             ULONG Processor,
                                             ULONG64 ThreadData,
                                             PULONG64 Offset);
    virtual HRESULT GetThreadInfoTeb(PTHREAD_INFO Thread,
                                     ULONG Processor,
                                     ULONG64 ThreadData,
                                     PULONG64 Offset);
    virtual HRESULT GetProcessInfoPeb(PTHREAD_INFO Thread,
                                      ULONG Processor,
                                      ULONG64 ThreadData,
                                      PULONG64 Offset);

    virtual ULONG64 GetCurrentTimeDateN(void);
    virtual ULONG64 GetCurrentSystemUpTimeN(void);
    
    // KernelDumpTargetInfo.
    PUCHAR m_HeaderContext;

    virtual ULONG GetCurrentProcessor(void) = 0;
    
    HRESULT InitGlobals32(PMEMORY_DUMP32 Dump);
    HRESULT InitGlobals64(PMEMORY_DUMP64 Dump);
    
    void DumpHeader32(PDUMP_HEADER32 Header);
    void DumpHeader64(PDUMP_HEADER64 Header);

    void InitDumpHeader32(PDUMP_HEADER32 Header, PCSTR Comment,
                          ULONG BugCheckCodeModifier);
    void InitDumpHeader64(PDUMP_HEADER64 Header, PCSTR Comment,
                          ULONG BugCheckCodeModifier);
};

class KernelFullSumDumpTargetInfo : public KernelDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    
    virtual HRESULT ReadPhysical(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysical(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT GetProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id);
    virtual HRESULT ReadPageFile(ULONG PfIndex, ULONG64 PfOffset,
                                 PVOID Buffer, ULONG Size);
    
    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );

    virtual HRESULT GetSelDescriptor(class MachineInfo* Machine,
                                     ULONG64 Thread, ULONG Selector,
                                     PDESCRIPTOR64 Desc);
    
    // DumpTargetInfo.
    virtual void DumpDebug(void);
    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail);
    
    // KernelDumpTargetInfo.
    virtual ULONG GetCurrentProcessor(void);

    // KernelFullSumDumpTargetInfo.
    virtual ULONG64 PhysicalToOffset(ULONG64 Phys, PULONG Avail) = 0;

    ULONG64 m_ProvokingVirtAddr;
};

class KernelSummaryDumpTargetInfo : public KernelFullSumDumpTargetInfo
{
public:
    // TargetInfo.
    virtual void Uninitialize(void);

    // KernelSummaryDumpTargetInfo.
    PULONG m_LocationCache;
    ULONG64 m_PageBitmapSize;
    RTL_BITMAP m_PageBitmap;
    
    void ConstructLocationCache(ULONG BitmapSize,
                                ULONG SizeOfBitMap,
                                IN PULONG Buffer);
    ULONG64 SumPhysicalToOffset(ULONG HeaderSize, ULONG64 Phys, PULONG Avail);
};

class KernelSummary32DumpTargetInfo : public KernelSummaryDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    virtual void Uninitialize(void);

    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    
    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);

    // KernelFullSumDumpTargetInfo.
    virtual ULONG64 PhysicalToOffset(ULONG64 Phys, PULONG Avail);

    // KernelSummary32DumpTargetInfo.
    PMEMORY_DUMP32 m_Dump;
};

class KernelSummary64DumpTargetInfo : public KernelSummaryDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    virtual void Uninitialize(void);

    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    
    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);

    // KernelFullSumDumpTargetInfo.
    virtual ULONG64 PhysicalToOffset(ULONG64 Phys, PULONG Avail);

    // KernelSummary64DumpTargetInfo.
    PMEMORY_DUMP64 m_Dump;
};

class KernelTriageDumpTargetInfo : public KernelDumpTargetInfo
{
public:
    // TargetInfo.
    virtual void Uninitialize(void);

    virtual void NearestDifferentlyValidOffsets(ULONG64 Offset,
                                                PULONG64 NextOffset,
                                                PULONG64 NextPage);
    
    virtual HRESULT ReadVirtual(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT GetProcessorSystemDataOffset(
        IN ULONG Processor,
        IN ULONG Index,
        OUT PULONG64 Offset
        );
    
    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );

    virtual HRESULT GetSelDescriptor(class MachineInfo* Machine,
                                     ULONG64 Thread, ULONG Selector,
                                     PDESCRIPTOR64 Desc);
    
    // DumpTargetInfo.
    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail);
    
    // KernelDumpTargetInfo.
    virtual ULONG GetCurrentProcessor(void);
    
    // KernelTriageDumpTargetInfo.
    ULONG m_PrcbOffset;
    
    HRESULT MapMemoryRegions(ULONG PrcbOffset,
                             ULONG ThreadOffset,
                             ULONG ProcessOffset,
                             ULONG64 TopOfStack,
                             ULONG SizeOfCallStack,
                             ULONG CallStackOffset,
                             ULONG64 BStoreLimit,
                             ULONG SizeOfBStore,
                             ULONG BStoreOffset,
                             ULONG64 DataPageAddress,
                             ULONG DataPageOffset,
                             ULONG DataPageSize,
                             ULONG64 DebuggerDataAddress,
                             ULONG DebuggerDataOffset,
                             ULONG DebuggerDataSize,
                             ULONG MmDataOffset,
                             ULONG DataBlocksOffset,
                             ULONG DataBlocksCount);
};

class KernelTriage32DumpTargetInfo : public KernelTriageDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    virtual void Uninitialize(void);

    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    virtual ModuleInfo* GetModuleInfo(BOOL UserMode);
    virtual UnloadedModuleInfo* GetUnloadedModuleInfo(void);
    
    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags, PCSTR Comment);


    // KernelTriage32DumpTargetInfo.
    PMEMORY_DUMP32 m_Dump;
};

class KernelTriage64DumpTargetInfo : public KernelTriageDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    virtual void Uninitialize(void);

    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    virtual ModuleInfo* GetModuleInfo(BOOL UserMode);
    virtual UnloadedModuleInfo* GetUnloadedModuleInfo(void);
    
    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags, PCSTR Comment);

    // KernelTriage64DumpTargetInfo.
    PMEMORY_DUMP64 m_Dump;
};

class KernelFull32DumpTargetInfo : public KernelFullSumDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    virtual void Uninitialize(void);

    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    
    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags, PCSTR Comment);

    // KernelFullSumDumpTargetInfo.
    virtual ULONG64 PhysicalToOffset(ULONG64 Phys, PULONG Avail);

    // KernelFull32DumpTargetInfo.
    PMEMORY_DUMP32 m_Dump;
};

class KernelFull64DumpTargetInfo : public KernelFullSumDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    virtual void Uninitialize(void);

    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    
    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags, PCSTR Comment);

    // KernelFullSumDumpTargetInfo.
    virtual ULONG64 PhysicalToOffset(ULONG64 Phys, PULONG Avail);

    // KernelFull64DumpTargetInfo.
    PMEMORY_DUMP64 m_Dump;
};

class UserDumpTargetInfo : public DumpTargetInfo
{
public:
    // TargetInfo.
    virtual void Uninitialize(void);

    virtual HRESULT GetThreadInfoDataOffset(PTHREAD_INFO Thread,
                                            ULONG64 ThreadHandle,
                                            PULONG64 Offset);
    virtual HRESULT GetProcessInfoDataOffset(PTHREAD_INFO Thread,
                                             ULONG Processor,
                                             ULONG64 ThreadData,
                                             PULONG64 Offset);
    virtual HRESULT GetThreadInfoTeb(PTHREAD_INFO Thread,
                                     ULONG Processor,
                                     ULONG64 ThreadData,
                                     PULONG64 Offset);
    virtual HRESULT GetProcessInfoPeb(PTHREAD_INFO Thread,
                                      ULONG Processor,
                                      ULONG64 ThreadData,
                                      PULONG64 Offset);

    virtual HRESULT GetSelDescriptor(class MachineInfo* Machine,
                                     ULONG64 Thread, ULONG Selector,
                                     PDESCRIPTOR64 Desc);
    
    // UserDumpTargetInfo.
    ULONG m_HighestMemoryRegion32;
    ULONG m_EventProcess;
    ULONG m_EventThread;
    ULONG m_ThreadCount;
    
    virtual HRESULT GetThreadInfo(ULONG Index,
                                  PULONG Id, PULONG Suspend, PULONG64 Teb) = 0;
};

class UserFullDumpTargetInfo : public UserDumpTargetInfo
{
public:
    // TargetInfo.
    virtual void Uninitialize(void);

    // DumpTargetInfo.
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags, PCSTR Comment);
    
    // UserFullDumpTargetInfo.
    HRESULT GetBuildAndPlatform(ULONG MajorVersion, ULONG MinorVersion,
                                PULONG BuildNumber, PULONG PlatformId);
};

class UserFull32DumpTargetInfo : public UserFullDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    virtual void Uninitialize(void);
    
    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    
    virtual HRESULT GetImageVersionInformation(PCSTR ImagePath,
                                               ULONG64 ImageBase,
                                               PCSTR Item,
                                               PVOID Buffer,
                                               ULONG BufferSize,
                                               PULONG VerInfoSize);

    virtual HRESULT QueryMemoryRegion(PULONG64 Handle,
                                      BOOL HandleIsOffset,
                                      PMEMORY_BASIC_INFORMATION64 Info);

    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail);
    
    // UserDumpTargetInfo.
    virtual HRESULT GetThreadInfo(ULONG Index,
                                  PULONG Id, PULONG Suspend, PULONG64 Teb);
    
    // UserFull32DumpTargetInfo.
    PUSERMODE_CRASHDUMP_HEADER32 m_Header;
    PMEMORY_BASIC_INFORMATION32 m_Memory;
    BOOL m_IgnoreGuardPages;

    BOOL VerifyModules(void);
};

class UserFull64DumpTargetInfo : public UserFullDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    virtual void Uninitialize(void);
    
    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    
    virtual HRESULT GetImageVersionInformation(PCSTR ImagePath,
                                               ULONG64 ImageBase,
                                               PCSTR Item,
                                               PVOID Buffer,
                                               ULONG BufferSize,
                                               PULONG VerInfoSize);

    virtual HRESULT QueryMemoryRegion(PULONG64 Handle,
                                      BOOL HandleIsOffset,
                                      PMEMORY_BASIC_INFORMATION64 Info);

    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail);

    // UserDumpTargetInfo.
    virtual HRESULT GetThreadInfo(ULONG Index,
                                  PULONG Id, PULONG Suspend, PULONG64 Teb);
    
    // UserFull64DumpTargetInfo.
    PUSERMODE_CRASHDUMP_HEADER64 m_Header;
    PMEMORY_BASIC_INFORMATION64 m_Memory;
};

class UserMiniDumpTargetInfo : public UserDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    virtual void Uninitialize(void);

    virtual void NearestDifferentlyValidOffsets(ULONG64 Offset,
                                                PULONG64 NextOffset,
                                                PULONG64 NextPage);
    
    virtual HRESULT ReadHandleData(
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        );
    virtual HRESULT GetProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id);

    virtual PVOID FindDynamicFunctionEntry(MachineInfo* Machine,
                                           ULONG64 Address);
    virtual ULONG64 GetDynamicFunctionTableBase(MachineInfo* Machine,
                                                ULONG64 Address);

    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );

    virtual ModuleInfo* GetModuleInfo(BOOL UserMode);
    virtual HRESULT GetImageVersionInformation(PCSTR ImagePath,
                                               ULONG64 ImageBase,
                                               PCSTR Item,
                                               PVOID Buffer,
                                               ULONG BufferSize,
                                               PULONG VerInfoSize);
    
    virtual HRESULT GetExceptionContext(PCROSS_PLATFORM_CONTEXT Context);
    virtual ULONG64 GetCurrentTimeDateN(void);

    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags, PCSTR Comment);

    // UserDumpTargetInfo.
    virtual HRESULT GetThreadInfo(ULONG Index,
                                  PULONG Id, PULONG Suspend, PULONG64 Teb);
    
    // UserMiniDumpTargetInfo.
    HRESULT WriteNonProcess(HANDLE File, ULONG FormatFlags, PCSTR Comment);

    PVOID IndexRva(RVA Rva, ULONG Size, PCSTR Title);
    PVOID IndexDirectory(ULONG Index, MINIDUMP_DIRECTORY UNALIGNED *Dir,
                         PVOID* Store);
    
    MINIDUMP_THREAD_EX UNALIGNED *IndexThreads(ULONG Index)
    {
        // Only a MINIDUMP_THREAD's worth of data may be valid
        // here if the dump only contains MINIDUMP_THREADs.
        // Check m_ThreadStructSize in any place that it matters.
        return (MINIDUMP_THREAD_EX UNALIGNED *)
            (m_Threads + Index * m_ThreadStructSize);
    }
    
    PMINIDUMP_HEADER                       m_Header;
    MINIDUMP_SYSTEM_INFO UNALIGNED *       m_SysInfo;
    ULONG                                  m_ActualThreadCount;
    ULONG                                  m_ThreadStructSize;
    PUCHAR                                 m_Threads;
    MINIDUMP_MEMORY_LIST UNALIGNED *       m_Memory;
    MINIDUMP_MEMORY64_LIST UNALIGNED *     m_Memory64;
    RVA64                                  m_Memory64DataBase;
    MINIDUMP_MODULE_LIST UNALIGNED *       m_Modules;
    MINIDUMP_EXCEPTION_STREAM UNALIGNED *  m_Exception;
    MINIDUMP_HANDLE_DATA_STREAM UNALIGNED *m_Handles;
    MINIDUMP_FUNCTION_TABLE_STREAM UNALIGNED* m_FunctionTables;
    ULONG                                  m_ImageType;
};

class UserMiniPartialDumpTargetInfo : public UserMiniDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);

    virtual HRESULT ReadVirtual(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    
    virtual HRESULT QueryMemoryRegion(PULONG64 Handle,
                                      BOOL HandleIsOffset,
                                      PMEMORY_BASIC_INFORMATION64 Info);

    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail);
};

class UserMiniFullDumpTargetInfo : public UserMiniDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);

    virtual HRESULT QueryMemoryRegion(PULONG64 Handle,
                                      BOOL HandleIsOffset,
                                      PMEMORY_BASIC_INFORMATION64 Info);

    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail);
};

// Indexed by DTYPE.
extern DumpTargetInfo* g_DumpTargets[];

//----------------------------------------------------------------------------
//
// ModuleInfo implementations.
//
//----------------------------------------------------------------------------

class KernelTriage32ModuleInfo : public NtModuleInfo
{
public:
    virtual HRESULT Initialize(void);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

private:
    KernelTriage32DumpTargetInfo* m_Target;
};

extern KernelTriage32ModuleInfo g_KernelTriage32ModuleIterator;

class KernelTriage64ModuleInfo : public NtModuleInfo
{
public:
    virtual HRESULT Initialize(void);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

private:
    KernelTriage64DumpTargetInfo* m_Target;
};

extern KernelTriage64ModuleInfo g_KernelTriage64ModuleIterator;

class UserMiniModuleInfo : public NtModuleInfo
{
public:
    virtual HRESULT Initialize(void);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

private:
    UserMiniDumpTargetInfo* m_Target;
};

extern UserMiniModuleInfo g_UserMiniModuleIterator;

class KernelTriage32UnloadedModuleInfo : public UnloadedModuleInfo
{
public:
    virtual HRESULT Initialize(void);
    virtual HRESULT GetEntry(PSTR Name, PDEBUG_MODULE_PARAMETERS Params);

private:
    KernelTriage32DumpTargetInfo* m_Target;
    PDUMP_UNLOADED_DRIVERS32 m_Cur, m_End;
};

extern KernelTriage32UnloadedModuleInfo g_KernelTriage32UnloadedModuleIterator;

class KernelTriage64UnloadedModuleInfo : public UnloadedModuleInfo
{
public:
    virtual HRESULT Initialize(void);
    virtual HRESULT GetEntry(PSTR Name, PDEBUG_MODULE_PARAMETERS Params);

private:
    KernelTriage64DumpTargetInfo* m_Target;
    PDUMP_UNLOADED_DRIVERS64 m_Cur, m_End;
};

extern KernelTriage64UnloadedModuleInfo g_KernelTriage64UnloadedModuleIterator;

//----------------------------------------------------------------------------
//
// Temporary class to generate kernel minidump class
//
//----------------------------------------------------------------------------


class CCrashDumpWrapper32
{
public:
    void WriteDriverList(BYTE *pb, TRIAGE_DUMP32 *ptdh);
    void WriteUnloadedDrivers(BYTE *pb);
    void WriteMmTriageInformation(BYTE *pb);
};

class CCrashDumpWrapper64
{
public:
    void WriteDriverList(BYTE *pb, TRIAGE_DUMP64 *ptdh);
    void WriteUnloadedDrivers(BYTE *pb);
    void WriteMmTriageInformation(BYTE *pb);
};

#endif // #ifndef __DUMP_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\dump.cpp ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    dump.cpp

Abstract:

    This module implements crashdump loading and analysis code

Comments:

    There are five basic types of dumps:

        User-mode dumps - contains the context and address of the user-mode
            program plus all process memory.

        User-mode minidumps - contains just thread stacks for
            register and stack traces.

        Kernel-mode normal dump - contains the context and address space of
            the entire kernel at the time of crash.

        Kernel-mode summary dump - contains a subset of the kernel-mode
            memory plus optionally the user-mode address space.

        Kernel-mode triage dump - contains a very small dump with registers,
            current process kernel-mode context, current thread kernel-mode
            context and some processor information. This dump is very small
            (typically 64K) but is designed to contain enough information
            to be able to figure out what went wrong when the machine
            crashed.

    This module also implements the following functions:

        Retrieving a normal Kernel-Mode dump from a target machine using 1394
            and storing it locally in a crashdump file format

--*/

#include "ntsdp.hpp"

#define HR_DUMP_CORRUPT HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT)

#define DUMP_INITIAL_VIEW_SIZE (1024 * 1024)
#define DUMP_MAXIMUM_VIEW_SIZE (256 * 1024 * 1024)

typedef ULONG PFN_NUMBER32;

//
// Page file dump file information.
//

#define DMPPF_IDENTIFIER "PAGE.DMP"

#define DMPPF_PAGE_NOT_PRESENT 0xffffffff

struct DMPPF_PAGE_FILE_INFO
{
    ULONG Size;
    ULONG MaximumSize;
};

// Left to its own devices the compiler will add a
// ULONG of padding at the end of this structure to
// keep it an even ULONG64 multiple in size.  Force
// it to consider only the declared items.
#pragma pack(4)

struct DMPPF_FILE_HEADER
{
    char Id[8];
    LARGE_INTEGER BootTime;
    ULONG PageData;
    DMPPF_PAGE_FILE_INFO PageFiles[16];
};

#pragma pack()

KernelSummary32DumpTargetInfo g_KernelSummary32DumpTarget;
KernelSummary64DumpTargetInfo g_KernelSummary64DumpTarget;
KernelTriage32DumpTargetInfo g_KernelTriage32DumpTarget;
KernelTriage64DumpTargetInfo g_KernelTriage64DumpTarget;
KernelFull32DumpTargetInfo g_KernelFull32DumpTarget;
KernelFull64DumpTargetInfo g_KernelFull64DumpTarget;
UserFull32DumpTargetInfo g_UserFull32DumpTarget;
UserFull64DumpTargetInfo g_UserFull64DumpTarget;
UserMiniPartialDumpTargetInfo g_UserMiniPartialDumpTarget;
UserMiniFullDumpTargetInfo g_UserMiniFullDumpTarget;

// Indexed by DTYPE.
DumpTargetInfo* g_DumpTargets[DTYPE_COUNT] =
{
    &g_KernelSummary32DumpTarget,
    &g_KernelSummary64DumpTarget,
    &g_KernelTriage32DumpTarget,
    &g_KernelTriage64DumpTarget,
    &g_KernelFull32DumpTarget,
    &g_KernelFull64DumpTarget,
    &g_UserFull32DumpTarget,
    &g_UserFull64DumpTarget,
    &g_UserMiniPartialDumpTarget,
    &g_UserMiniFullDumpTarget,
};


// Set this value to track down page numbers and contents of a virtual address
// in a dump file.
// Initialized to an address no one will look for.
ULONG64 g_DebugDump_VirtualAddress = 12344321;


//
// Globals
//

#define IndexByByte(Pointer, Index) (&(((CHAR*) (Pointer))) [Index])

#define RtlCheckBit(BMH,BP) ((((BMH)->Buffer[(BP) / 32]) >> ((BP) % 32)) & 0x1)

ULONG64                         g_DumpKiProcessors[MAXIMUM_PROCESSORS];
ULONG64                         g_DumpKiPcrBaseAddress;
BOOL                            g_TriageDumpHasDebuggerData;

DTYPE                           g_DumpType = DTYPE_COUNT;
ULONG                           g_DumpFormatFlags;
EXCEPTION_RECORD64              g_DumpException;
ULONG                           g_DumpExceptionFirstChance;

//
// MM Triage information.
//

struct MM_TRIAGE_TRANSLATION
{
    ULONG DebuggerDataOffset;
    ULONG Triage32Offset;
    ULONG Triage64Offset;
    ULONG PtrSize:1;
};

MM_TRIAGE_TRANSLATION g_MmTriageTranslations[] =
{
    FIELD_OFFSET(KDDEBUGGER_DATA64, MmSpecialPoolTag),
    FIELD_OFFSET(DUMP_MM_STORAGE32, MmSpecialPoolTag),
    FIELD_OFFSET(DUMP_MM_STORAGE64, MmSpecialPoolTag),
    FALSE,
    
    FIELD_OFFSET(KDDEBUGGER_DATA64, MmTriageActionTaken),
    FIELD_OFFSET(DUMP_MM_STORAGE32, MiTriageActionTaken),
    FIELD_OFFSET(DUMP_MM_STORAGE64, MiTriageActionTaken),
    FALSE,
    
    FIELD_OFFSET(KDDEBUGGER_DATA64, KernelVerifier),
    FIELD_OFFSET(DUMP_MM_STORAGE32, KernelVerifier),
    FIELD_OFFSET(DUMP_MM_STORAGE64, KernelVerifier),
    FALSE,
    
    FIELD_OFFSET(KDDEBUGGER_DATA64, MmAllocatedNonPagedPool),
    FIELD_OFFSET(DUMP_MM_STORAGE32, MmAllocatedNonPagedPool),
    FIELD_OFFSET(DUMP_MM_STORAGE64, MmAllocatedNonPagedPool),
    TRUE,
    
    FIELD_OFFSET(KDDEBUGGER_DATA64, MmTotalCommittedPages),
    FIELD_OFFSET(DUMP_MM_STORAGE32, CommittedPages),
    FIELD_OFFSET(DUMP_MM_STORAGE64, CommittedPages),
    TRUE,
    
    FIELD_OFFSET(KDDEBUGGER_DATA64, MmPeakCommitment),
    FIELD_OFFSET(DUMP_MM_STORAGE32, CommittedPagesPeak),
    FIELD_OFFSET(DUMP_MM_STORAGE64, CommittedPagesPeak),
    TRUE,
    
    FIELD_OFFSET(KDDEBUGGER_DATA64, MmTotalCommitLimitMaximum),
    FIELD_OFFSET(DUMP_MM_STORAGE32, CommitLimitMaximum),
    FIELD_OFFSET(DUMP_MM_STORAGE64, CommitLimitMaximum),
    TRUE,

#if 0
    // These MM triage fields are in pages while the corresponding
    // debugger data fields are in bytes.  There's no way to
    // directly map one to the other.
    FIELD_OFFSET(KDDEBUGGER_DATA64, MmMaximumNonPagedPoolInBytes),
    FIELD_OFFSET(DUMP_MM_STORAGE32, MmMaximumNonPagedPool),
    FIELD_OFFSET(DUMP_MM_STORAGE64, MmMaximumNonPagedPool),
    TRUE,
    
    FIELD_OFFSET(KDDEBUGGER_DATA64, MmSizeOfPagedPoolInBytes),
    FIELD_OFFSET(DUMP_MM_STORAGE32, PagedPoolMaximum),
    FIELD_OFFSET(DUMP_MM_STORAGE64, PagedPoolMaximum),
    TRUE,
#endif

    0, 0, 0, 0, 0,
};

//
// Internal globals.
//

struct DUMP_INFO_FILE
{
    HANDLE  File;
    ULONG64 FileSize;
    HANDLE  Map;
    PVOID   MapBase;
    ULONG   MapSize;
    
    //
    // If a page is dirty, it will stay in the cache indefinitely.
    // A maximum of MAX_CLEAN_PAGE_RECORD clean pages are kept in
    // the LRU list.
    //
    ULONG   ActiveCleanPages;

    //
    // Cache may be cleaned up after use and reinitialized later.
    // This flag records its current state.
    //
    BOOL    Initialized;

    //
    // This is a list of all mapped pages, dirty and clean.
    // This list is not intended to get very big:  the page finder
    // searches it, so it is not a good data structure for a large
    // list.  It is expected that MAX_CLEAN_PAGE_RECORD will be a
    // small number, and that there aren't going to be very many
    // pages dirtied in a typical debugging session, so this will
    // work well.
    //

    LIST_ENTRY InFileOrderList;

    //
    // This is a list of all clean pages.  When the list is full
    // and a new page is mapped, the oldest page will be discarded.
    //

    LIST_ENTRY InLRUOrderList;
};
typedef DUMP_INFO_FILE* PDUMP_INFO_FILE;

DUMP_INFO_FILE g_DumpInfoFiles[DUMP_INFO_COUNT];

PVOID g_DumpBase;

//
// Cache manager
//
// A dump file may be larger than can be mapped into the
// debugger's address space, so we use a simple cached
// paging method to access the data area.
//

//
// Allocation granularity for cache.  This will be the
// allocation granularity for the system hosting the
// debugger and not for the system which produced the dump.
//
ULONG g_DumpCacheGranularity;

//
// Cache structure
//
typedef struct _DUMPFILE_CACHE_RECORD
{
    LIST_ENTRY InFileOrderList;
    LIST_ENTRY InLRUOrderList;

    //
    // Base address of mapped region.
    //
    PVOID MappedAddress;

    //
    // File page number of mapped region.  pages are of
    // size == FileCacheData.Granularity.
    //
    // The virtual address of a page is not stored; it is
    // translated into a page number by the read routines
    // and all access is by page number.
    //
    ULONG64 PageNumber;

    //
    // A page may be locked into the cache, either because it is used
    // frequently or because it has been modified.
    //
    BOOL Locked;

} DUMPFILE_CACHE_RECORD, *PDUMPFILE_CACHE_RECORD;

#define MAX_CLEAN_PAGE_RECORD 4

void
DmppDumpFileCacheInit(PDUMP_INFO_FILE File)
{
    File->ActiveCleanPages = 0;
    InitializeListHead(&File->InFileOrderList);
    InitializeListHead(&File->InLRUOrderList);
    File->Initialized = TRUE;
}

VOID
DmppDumpFileCacheEmpty(PDUMP_INFO_FILE File)
{
    PLIST_ENTRY Next;
    PDUMPFILE_CACHE_RECORD CacheRecord;

    Next = File->InFileOrderList.Flink;

    while (Next != &File->InFileOrderList)
    {
        CacheRecord = CONTAINING_RECORD(Next,
                                        DUMPFILE_CACHE_RECORD,
                                        InFileOrderList);
        Next = Next->Flink;

        UnmapViewOfFile(CacheRecord->MappedAddress);

        free (CacheRecord);
    }

    File->ActiveCleanPages = 0;
    InitializeListHead(&File->InFileOrderList);
    InitializeListHead(&File->InLRUOrderList);
}

VOID
DmppDumpFileCacheCleanup(PDUMP_INFO_FILE File)
{
    if (File->Initialized)
    {
        File->Initialized = FALSE;
        DmppDumpFileCacheEmpty(File);
    }
}

PDUMPFILE_CACHE_RECORD
DmppReuseOldestCacheRecord(PDUMP_INFO_FILE File, ULONG64 FileByteOffset)
{
    PDUMPFILE_CACHE_RECORD CacheRecord;
    PLIST_ENTRY Next;
    PVOID MappedAddress;
    ULONG64 MapOffset;
    ULONG Size;

    MapOffset = FileByteOffset & ~((ULONG64)g_DumpCacheGranularity - 1);

    if ((File->FileSize - MapOffset) < g_DumpCacheGranularity)
    {
        Size = (ULONG)(File->FileSize - MapOffset);
    }
    else
    {
        Size = g_DumpCacheGranularity;
    }

    MappedAddress = MapViewOfFile(File->Map, FILE_MAP_READ,
                                  (DWORD)(MapOffset >> 32),
                                  (DWORD)MapOffset, Size);
    if (MappedAddress == NULL)
    {
        return NULL;
    }

    Next = File->InLRUOrderList.Flink;

    CacheRecord = CONTAINING_RECORD(Next,
                                    DUMPFILE_CACHE_RECORD,
                                    InLRUOrderList);

    UnmapViewOfFile(CacheRecord->MappedAddress);

    CacheRecord->PageNumber = FileByteOffset / g_DumpCacheGranularity;
    CacheRecord->MappedAddress = MappedAddress;

    //
    // Move record to end of LRU
    //

    RemoveEntryList(Next);
    InsertTailList(&File->InLRUOrderList, Next);

    //
    // Move record to correct place in ordered list
    //

    RemoveEntryList(&CacheRecord->InFileOrderList);
    Next = File->InFileOrderList.Flink;
    while (Next != &File->InFileOrderList)
    {
        PDUMPFILE_CACHE_RECORD NextCacheRecord;
        NextCacheRecord = CONTAINING_RECORD(Next,
                                            DUMPFILE_CACHE_RECORD,
                                            InFileOrderList);
        if (CacheRecord->PageNumber < NextCacheRecord->PageNumber)
        {
            break;
        }
        Next = Next->Flink;
    }
    InsertTailList(Next, &CacheRecord->InFileOrderList);

    return CacheRecord;
}

PDUMPFILE_CACHE_RECORD
DmppFindCacheRecordForFileByteOffset(PDUMP_INFO_FILE File,
                                     ULONG64 FileByteOffset)
{
    PDUMPFILE_CACHE_RECORD CacheRecord;
    PLIST_ENTRY Next;
    ULONG64 PageNumber;

    PageNumber = FileByteOffset / g_DumpCacheGranularity;
    Next = File->InFileOrderList.Flink;
    while (Next != &File->InFileOrderList)
    {
        CacheRecord = CONTAINING_RECORD(Next,
                                        DUMPFILE_CACHE_RECORD,
                                        InFileOrderList);

        if (CacheRecord->PageNumber < PageNumber)
        {
            Next = Next->Flink;
        }
        else if (CacheRecord->PageNumber == PageNumber)
        {
            if (!CacheRecord->Locked)
            {
                RemoveEntryList(&CacheRecord->InLRUOrderList);
                InsertTailList(&File->InLRUOrderList,
                               &CacheRecord->InLRUOrderList);
            }
            
            return CacheRecord;
        }
        else
        {
            break;
        }
    }

    //
    // Can't find it in cache.
    //

    return NULL;
}

PDUMPFILE_CACHE_RECORD
DmppCreateNewFileCacheRecord(PDUMP_INFO_FILE File, ULONG64 FileByteOffset)
{
    PDUMPFILE_CACHE_RECORD CacheRecord;
    PDUMPFILE_CACHE_RECORD NextCacheRecord;
    PLIST_ENTRY Next;
    ULONG64 MapOffset;
    ULONG Size;

    CacheRecord = (PDUMPFILE_CACHE_RECORD)malloc(sizeof(*CacheRecord));
    if (CacheRecord == NULL)
    {
        return NULL;
    }

    ZeroMemory(CacheRecord, sizeof(*CacheRecord));

    MapOffset = (FileByteOffset / g_DumpCacheGranularity) *
        g_DumpCacheGranularity;

    if ((File->FileSize - MapOffset) < g_DumpCacheGranularity)
    {
        Size = (ULONG)(File->FileSize - MapOffset);
    }
    else
    {
        Size = g_DumpCacheGranularity;
    }

    CacheRecord->MappedAddress = MapViewOfFile(File->Map, FILE_MAP_READ,
                                               (DWORD)(MapOffset >> 32),
                                               (DWORD)MapOffset, Size);
    if (CacheRecord->MappedAddress == NULL)
    {
        free(CacheRecord);
        return NULL;
    }
    CacheRecord->PageNumber = FileByteOffset / g_DumpCacheGranularity;

    //
    // Insert new record in file order list
    //

    Next = File->InFileOrderList.Flink;
    while (Next != &File->InFileOrderList)
    {
        NextCacheRecord = CONTAINING_RECORD(Next,
                                            DUMPFILE_CACHE_RECORD,
                                            InFileOrderList);
        if (CacheRecord->PageNumber < NextCacheRecord->PageNumber)
        {
            break;
        }
        
        Next = Next->Flink;
    }
    InsertTailList(Next, &CacheRecord->InFileOrderList);

    //
    // Insert new record at tail of LRU list
    //

    InsertTailList(&File->InLRUOrderList,
                   &CacheRecord->InLRUOrderList);

    return CacheRecord;
}

PUCHAR
DmppFileOffsetToMappedAddress(IN PDUMP_INFO_FILE File,
                              IN ULONG64 FileOffset,
                              IN BOOL LockCacheRecord,
                              OUT PULONG Avail)
{
    PDUMPFILE_CACHE_RECORD CacheRecord;
    ULONG64 FileByteOffset;

    if (FileOffset == 0)
    {
        return NULL;
    }

    // The base view covers the beginning of the file.
    if (FileOffset < File->MapSize)
    {
        *Avail = (ULONG)(File->MapSize - FileOffset);
        return (PUCHAR)File->MapBase + FileOffset;
    }

    FileByteOffset = FileOffset;
    CacheRecord = DmppFindCacheRecordForFileByteOffset(File, FileByteOffset);

    if (CacheRecord == NULL)
    {
        if (File->ActiveCleanPages < MAX_CLEAN_PAGE_RECORD)
        {
            CacheRecord = DmppCreateNewFileCacheRecord(File, FileByteOffset);
            if (CacheRecord)
            {
                File->ActiveCleanPages++;
            }
        }
        else
        {
            //
            // too many pages cached in
            // overwrite existing cache
            //
            CacheRecord = DmppReuseOldestCacheRecord(File, FileByteOffset);
        }
    }

    if (CacheRecord == NULL)
    {
        return NULL;
    }
    else
    {
        if (LockCacheRecord && !CacheRecord->Locked)
        {
            RemoveEntryList(&CacheRecord->InLRUOrderList);
            CacheRecord->Locked = TRUE;
            File->ActiveCleanPages--;
        }

        ULONG PageRemainder =
            (ULONG)(FileByteOffset & (g_DumpCacheGranularity - 1));
        *Avail = g_DumpCacheGranularity - PageRemainder;
        return ((PUCHAR)CacheRecord->MappedAddress) + PageRemainder;
    }
}

ULONG
DmppReadFileOffset(ULONG FileIndex,
                   ULONG64 Offset, PVOID Buffer, ULONG BufferSize)
{
    ULONG Done = 0;
    ULONG Avail;
    PUCHAR Mapping;
    PDUMP_INFO_FILE File = &g_DumpInfoFiles[FileIndex];

    if (File->File == NULL)
    {
        // Information for this kind of file wasn't provided.
        return 0;
    }
    
    __try
    {
        while (BufferSize > 0)
        {
            Mapping = DmppFileOffsetToMappedAddress(File, Offset, FALSE,
                                                    &Avail);
            if (Mapping == NULL)
            {
                break;
            }

            if (Avail > BufferSize)
            {
                Avail = BufferSize;
            }
            memcpy(Buffer, Mapping, Avail);

            Offset += Avail;
            Buffer = (PUCHAR)Buffer + Avail;
            BufferS